From 5c13e0834bf1707a14aa43d13a1809f03056abd2 Mon Sep 17 00:00:00 2001
From: Brian Avery <bavery@redhat.com>
Date: Tue, 16 Feb 2021 11:44:40 +0100
Subject: [ior] MAISTRA-1400 Add IOR to Pilot

* [MAISTRA-1089][MAISTRA-1400][MAISTRA-1744][MAISTRA-1811]: Add IOR to Pilot (#135) (#240)

* MAISTRA-1400: Add IOR to Pilot (#135)

* MAISTRA-1400: Add IOR to Pilot

* [MAISTRA-1744] Add route annotation propagation (#158)

* MAISTRA-1811 Store resourceVersion of reconciled Gateway resource (#190)

* MAISTRA-1089 Add support for IOR routes in all namespaces (#193)

* MAISTRA-2131: ior: honor Gateway's httpsRedirect (#276)

If Gateway's httpsRedirect is set to true, create the OpenShift Route
with Insecure Policy set to `Redirect`.

Manual cherrypick from https://github.com/maistra/istio/pull/269.

* MAISTRA-2149: Make IOR robust in multiple replicas (#282)

In scenarios where multiple replicas of istiod are running,
only one IOR should be in charge of keeping routes in sync
with Istio Gateways. We achieve this by making sure IOR only
runs in the leader replica.

Also, because leader election is not 100% acurate, meaning
that for a small window of time there might be two instances
being the leader - which could lead to duplicated routes
being created if a new gateway is created in that time frame -
we also change the way the Route name is created: Instead of
having a generateName field, we now explicitly pass a name to
the Route object to be created. Being deterministic, it allows
the Route creation to fail when there's already a Route object
with the same name (created by the other leader in that time frame).

Use an exclusive leader ID for IOR

* Manual cherrypick of https://github.com/maistra/istio/pull/275

* MAISTRA-1813: Add unit tests for IOR (#286)

* MAISTRA-2051 fixes for maistra install

* MAISTRA-2164: Refactor IOR internals (#295)

Instead of doing lots of API calls on every event - this
does not scale well with lots of namespaces - keep the state
in memory, by doing an initial synchronization on start up and
updating it when receiving events.

The initial synchronization is more complex, as we have to deal with
asynchronous events (e.g., we have to wait for the Gateway store to
be warmed up). Once it's initialized, handling events as they arrive
becomes trivial.

Tests that make sure we do not make more calls to the API server than
the necessary were added, to avoid regressions.

* MAISTRA-2205: Add an option to opt-out for automatic route creation

If the Istio Gateway contains the annotation `maistra.io/manageRoute: false`
then IOR ignores it and doesn't attempt to create or manage route(s) for
this Gateway.

Also, ignore Gateways with the annotation `istio: egressgateway` as
these are not meant to have routes.
---
 pilot/pkg/bootstrap/configcontroller.go       |   29 +
 pilot/pkg/config/kube/ior/client.go           |   59 +
 pilot/pkg/config/kube/ior/fake.go             |  249 ++
 pilot/pkg/config/kube/ior/ior.go              |   91 +
 pilot/pkg/config/kube/ior/ior_test.go         |  642 ++++
 pilot/pkg/config/kube/ior/route.go            |  567 +++
 pilot/pkg/features/pilot.go                   |    3 +
 pilot/pkg/leaderelection/leaderelection.go    |    1 +
 pkg/kube/client.go                            |    3 +
 .../github.com/openshift/api/route/v1/doc.go  |    8 +
 .../openshift/api/route/v1/generated.pb.go    | 3039 +++++++++++++++++
 .../openshift/api/route/v1/generated.proto    |  241 ++
 .../openshift/api/route/v1/legacy.go          |   22 +
 .../openshift/api/route/v1/register.go        |   39 +
 .../openshift/api/route/v1/types.go           |  280 ++
 .../api/route/v1/zz_generated.deepcopy.go     |  240 ++
 .../v1/zz_generated.swagger_doc_generated.go  |  128 +
 .../route/clientset/versioned/scheme/doc.go   |    4 +
 .../clientset/versioned/scheme/register.go    |   40 +
 .../clientset/versioned/typed/route/v1/doc.go |    4 +
 .../typed/route/v1/generated_expansion.go     |    5 +
 .../versioned/typed/route/v1/route.go         |  179 +
 .../versioned/typed/route/v1/route_client.go  |   73 +
 vendor/modules.txt                            |    3 +
 24 files changed, 5949 insertions(+)
 create mode 100644 pilot/pkg/config/kube/ior/client.go
 create mode 100644 pilot/pkg/config/kube/ior/fake.go
 create mode 100644 pilot/pkg/config/kube/ior/ior.go
 create mode 100644 pilot/pkg/config/kube/ior/ior_test.go
 create mode 100644 pilot/pkg/config/kube/ior/route.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/doc.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/generated.pb.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/generated.proto
 create mode 100644 vendor/github.com/openshift/api/route/v1/legacy.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/register.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/types.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/zz_generated.deepcopy.go
 create mode 100644 vendor/github.com/openshift/api/route/v1/zz_generated.swagger_doc_generated.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/doc.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/register.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/doc.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/generated_expansion.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route.go
 create mode 100644 vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route_client.go

diff --git a/pilot/pkg/bootstrap/configcontroller.go b/pilot/pkg/bootstrap/configcontroller.go
index 92cf06d837..ee8f06fd20 100644
--- a/pilot/pkg/bootstrap/configcontroller.go
+++ b/pilot/pkg/bootstrap/configcontroller.go
@@ -27,6 +27,7 @@ import (
 	"istio.io/istio/pilot/pkg/config/kube/gateway"
 	"istio.io/istio/pilot/pkg/config/kube/ingress"
 	ingressv1 "istio.io/istio/pilot/pkg/config/kube/ingressv1"
+	"istio.io/istio/pilot/pkg/config/kube/ior"
 	"istio.io/istio/pilot/pkg/config/memory"
 	configmonitor "istio.io/istio/pilot/pkg/config/monitor"
 	"istio.io/istio/pilot/pkg/controller/workloadentry"
@@ -142,6 +143,8 @@ func (s *Server) initConfigController(args *PilotArgs) error {
 	// Create the config store.
 	s.environment.IstioConfigStore = model.MakeIstioStore(s.configController)
 
+	s.startIOR(args)
+
 	// Defer starting the controller until after the service is created.
 	s.addStartFunc(func(stop <-chan struct{}) error {
 		go s.configController.Run(stop)
@@ -151,6 +154,32 @@ func (s *Server) initConfigController(args *PilotArgs) error {
 	return nil
 }
 
+// startIOR tries to start IOR, if it's enabled. If it encounters any failure, it logs an error and continue
+func (s *Server) startIOR(args *PilotArgs) {
+	if !features.EnableIOR {
+		return
+	}
+
+	routerClient, err := ior.NewRouterClient()
+	if err != nil {
+		ior.IORLog.Errorf("error creating an openshift router client: %v", err)
+		return
+	}
+
+	iorKubeClient := ior.NewKubeClient(s.kubeClient)
+
+	s.addStartFunc(func(stop <-chan struct{}) error {
+		go leaderelection.
+			NewLeaderElection(args.Namespace, args.PodName, leaderelection.IORController, args.Revision, s.kubeClient).
+			AddRunFunction(func(stop <-chan struct{}) {
+				if err := ior.Register(iorKubeClient, routerClient, s.configController, args.Namespace, s.kubeClient.GetMemberRoll(), stop, nil); err != nil {
+					ior.IORLog.Error(err)
+				}
+			}).Run(stop)
+		return nil
+	})
+}
+
 func (s *Server) initK8SConfigStore(args *PilotArgs) error {
 	if s.kubeClient == nil {
 		return nil
diff --git a/pilot/pkg/config/kube/ior/client.go b/pilot/pkg/config/kube/ior/client.go
new file mode 100644
index 0000000000..a16cb030b7
--- /dev/null
+++ b/pilot/pkg/config/kube/ior/client.go
@@ -0,0 +1,59 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ior
+
+import (
+	"strings"
+	"time"
+
+	"k8s.io/client-go/kubernetes"
+)
+
+// KubeClient is an extension of `kubernetes.Interface` with auxiliary functions for IOR
+type KubeClient interface {
+	IsRouteSupported() bool
+	GetActualClient() kubernetes.Interface
+	GetHandleEventTimeout() time.Duration
+}
+
+type kubeClient struct {
+	client kubernetes.Interface
+}
+
+// NewKubeClient creates the IOR version of KubeClient
+func NewKubeClient(client kubernetes.Interface) KubeClient {
+	return &kubeClient{client: client}
+}
+
+func (c *kubeClient) IsRouteSupported() bool {
+	_, s, _ := c.client.Discovery().ServerGroupsAndResources()
+	// This may fail if any api service is down, but the result will still be populated, so we skip the error
+	for _, res := range s {
+		for _, api := range res.APIResources {
+			if api.Kind == "Route" && strings.HasPrefix(res.GroupVersion, "route.openshift.io/") {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+func (c *kubeClient) GetActualClient() kubernetes.Interface {
+	return c.client
+}
+
+func (c *kubeClient) GetHandleEventTimeout() time.Duration {
+	return 10 * time.Second
+}
diff --git a/pilot/pkg/config/kube/ior/fake.go b/pilot/pkg/config/kube/ior/fake.go
new file mode 100644
index 0000000000..5269165267
--- /dev/null
+++ b/pilot/pkg/config/kube/ior/fake.go
@@ -0,0 +1,249 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ior
+
+import (
+	"fmt"
+	"sync"
+	"time"
+
+	v1 "github.com/openshift/api/route/v1"
+	routev1 "github.com/openshift/client-go/route/clientset/versioned/typed/route/v1"
+	"golang.org/x/net/context"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/rest"
+
+	"istio.io/istio/pkg/servicemesh/controller"
+)
+
+// FakeRouter implements routev1.RouteInterface
+type FakeRouter struct {
+	routes     map[string]*v1.Route
+	routesLock sync.Mutex
+}
+
+// FakeRouterClient implements routev1.RouteV1Interface
+type FakeRouterClient struct {
+	routesByNamespace     map[string]routev1.RouteInterface
+	routesByNamespaceLock sync.Mutex
+}
+
+type fakeKubeClient struct {
+	client kubernetes.Interface
+}
+
+// NewFakeKubeClient creates a new FakeKubeClient
+func NewFakeKubeClient(client kubernetes.Interface) KubeClient {
+	return &fakeKubeClient{client: client}
+}
+
+func (c *fakeKubeClient) IsRouteSupported() bool {
+	return true
+}
+
+func (c *fakeKubeClient) GetActualClient() kubernetes.Interface {
+	return c.client
+}
+
+func (c *fakeKubeClient) GetHandleEventTimeout() time.Duration {
+	return time.Millisecond
+}
+
+// NewFakeRouterClient creates a new FakeRouterClient
+func NewFakeRouterClient() routev1.RouteV1Interface {
+	return &FakeRouterClient{
+		routesByNamespace: make(map[string]routev1.RouteInterface),
+	}
+}
+
+// NewFakeRouter creates a new FakeRouter
+func NewFakeRouter() routev1.RouteInterface {
+	return &FakeRouter{
+		routes: make(map[string]*v1.Route),
+	}
+}
+
+// RESTClient implements routev1.RouteV1Interface
+func (rc *FakeRouterClient) RESTClient() rest.Interface {
+	panic("not implemented")
+}
+
+// Routes implements routev1.RouteV1Interface
+func (rc *FakeRouterClient) Routes(namespace string) routev1.RouteInterface {
+	rc.routesByNamespaceLock.Lock()
+	defer rc.routesByNamespaceLock.Unlock()
+
+	if _, ok := rc.routesByNamespace[namespace]; !ok {
+		rc.routesByNamespace[namespace] = NewFakeRouter()
+	}
+
+	countCallsIncrement("routes")
+	return rc.routesByNamespace[namespace]
+}
+
+var generatedHostNumber int
+
+// Create implements routev1.RouteInterface
+func (fk *FakeRouter) Create(ctx context.Context, route *v1.Route, opts metav1.CreateOptions) (*v1.Route, error) {
+	fk.routesLock.Lock()
+	defer fk.routesLock.Unlock()
+
+	if route.Spec.Host == "" {
+		generatedHostNumber++
+		route.Spec.Host = fmt.Sprintf("generated-host%d.com", generatedHostNumber)
+	}
+
+	fk.routes[route.Name] = route
+
+	countCallsIncrement("create")
+	return route, nil
+}
+
+// Update implements routev1.RouteInterface
+func (fk *FakeRouter) Update(ctx context.Context, route *v1.Route, opts metav1.UpdateOptions) (*v1.Route, error) {
+	panic("not implemented")
+}
+
+// UpdateStatus implements routev1.RouteInterface
+func (fk *FakeRouter) UpdateStatus(ctx context.Context, route *v1.Route, opts metav1.UpdateOptions) (*v1.Route, error) {
+	panic("not implemented")
+}
+
+// Delete implements routev1.RouteInterface
+func (fk *FakeRouter) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
+	fk.routesLock.Lock()
+	defer fk.routesLock.Unlock()
+
+	if _, ok := fk.routes[name]; !ok {
+		return fmt.Errorf("route %s not found", name)
+	}
+
+	delete(fk.routes, name)
+
+	countCallsIncrement("delete")
+	return nil
+}
+
+// DeleteCollection implements routev1.RouteInterface
+func (fk *FakeRouter) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
+	panic("not implemented")
+}
+
+// Get implements routev1.RouteInterface
+func (fk *FakeRouter) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Route, error) {
+	panic("not implemented")
+}
+
+// List implements routev1.RouteInterface
+func (fk *FakeRouter) List(ctx context.Context, opts metav1.ListOptions) (*v1.RouteList, error) {
+	fk.routesLock.Lock()
+	defer fk.routesLock.Unlock()
+
+	var items []v1.Route
+	for _, route := range fk.routes {
+		items = append(items, *route)
+	}
+	result := &v1.RouteList{Items: items}
+
+	countCallsIncrement("list")
+	return result, nil
+}
+
+// Watch Create implements routev1.RouteInterface
+func (fk *FakeRouter) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
+	panic("not implemented")
+}
+
+// Patch implements routev1.RouteInterface
+func (fk *FakeRouter) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions,
+	subresources ...string) (result *v1.Route, err error) {
+	panic("not implemented")
+}
+
+// fakeMemberRollController implements controller.MemberRollController
+type fakeMemberRollController struct {
+	listeners  []controller.MemberRollListener
+	namespaces []string
+	lock       sync.Mutex
+}
+
+func newFakeMemberRollController() *fakeMemberRollController {
+	return &fakeMemberRollController{}
+}
+
+// Register implements controller.MemberRollController
+func (fk *fakeMemberRollController) Register(listener controller.MemberRollListener, name string) {
+	fk.lock.Lock()
+	defer fk.lock.Unlock()
+
+	if listener == nil {
+		return
+	}
+	fk.listeners = append(fk.listeners, listener)
+}
+
+// Start implements controller.MemberRollController
+func (fk *fakeMemberRollController) Start(stopCh <-chan struct{}) {
+	panic("not implemented")
+}
+
+func (fk *fakeMemberRollController) addNamespaces(namespaces ...string) {
+	fk.namespaces = append(fk.namespaces, namespaces...)
+	fk.invokeListeners()
+}
+
+func (fk *fakeMemberRollController) setNamespaces(namespaces ...string) {
+	fk.namespaces = namespaces
+	fk.invokeListeners()
+}
+
+func (fk *fakeMemberRollController) invokeListeners() {
+	fk.lock.Lock()
+	defer fk.lock.Unlock()
+
+	for _, l := range fk.listeners {
+		l.SetNamespaces(fk.namespaces...)
+	}
+}
+
+var (
+	countCalls     map[string]int = map[string]int{}
+	countCallsLock sync.Mutex
+)
+
+func countCallsReset() {
+	countCallsLock.Lock()
+	defer countCallsLock.Unlock()
+	countCalls = map[string]int{}
+}
+
+func countCallsGet(k string) int {
+	countCallsLock.Lock()
+	defer countCallsLock.Unlock()
+	v, ok := countCalls[k]
+	if !ok {
+		v = 0
+	}
+	return v
+}
+
+func countCallsIncrement(k string) {
+	countCallsLock.Lock()
+	defer countCallsLock.Unlock()
+	countCalls[k]++
+}
diff --git a/pilot/pkg/config/kube/ior/ior.go b/pilot/pkg/config/kube/ior/ior.go
new file mode 100644
index 0000000000..b0f0865bb3
--- /dev/null
+++ b/pilot/pkg/config/kube/ior/ior.go
@@ -0,0 +1,91 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ior
+
+import (
+	"sync"
+
+	routev1 "github.com/openshift/client-go/route/clientset/versioned/typed/route/v1"
+
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/pkg/log"
+)
+
+// IORLog is IOR-scoped log
+var IORLog = log.RegisterScope("ior", "IOR logging", 0)
+
+// Register configures IOR component to respond to Gateway creations and removals
+func Register(
+	k8sClient KubeClient,
+	routerClient routev1.RouteV1Interface,
+	store model.ConfigStoreCache,
+	pilotNamespace string,
+	mrc controller.MemberRollController,
+	stop <-chan struct{},
+	errorChannel chan error) error {
+	IORLog.Info("Registering IOR component")
+
+	r, err := newRoute(k8sClient, routerClient, store, pilotNamespace, mrc, stop)
+	if err != nil {
+		return err
+	}
+
+	alive := true
+	var aliveLock sync.Mutex
+	go func(stop <-chan struct{}) {
+		// Stop responding to events when we are no longer a leader.
+		// Two notes here:
+		// (1) There's no such method "UnregisterEventHandler()"
+		// (2) It might take a few seconds to this channel to be closed. So, both pods might be leader for a few seconds.
+		<-stop
+		IORLog.Info("This pod is no longer a leader. IOR stopped responding")
+		aliveLock.Lock()
+		alive = false
+		aliveLock.Unlock()
+	}(stop)
+
+	IORLog.Debugf("Registering IOR into Istio's Gateway broadcast")
+	kind := collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind()
+	store.RegisterEventHandler(kind, func(_, curr config.Config, event model.Event) {
+		aliveLock.Lock()
+		defer aliveLock.Unlock()
+		if !alive {
+			return
+		}
+
+		// encapsulate in goroutine to not slow down processing because of waiting for mutex
+		go func() {
+			_, ok := curr.Spec.(*networking.Gateway)
+			if !ok {
+				IORLog.Errorf("could not decode object as Gateway. Object = %v", curr)
+				return
+			}
+
+			IORLog.Debugf("Event %v arrived. Object: %v", event, curr)
+			if err := r.handleEvent(event, curr); err != nil {
+				IORLog.Errora(err)
+				if errorChannel != nil {
+					errorChannel <- err
+				}
+			}
+		}()
+	})
+
+	return nil
+}
diff --git a/pilot/pkg/config/kube/ior/ior_test.go b/pilot/pkg/config/kube/ior/ior_test.go
new file mode 100644
index 0000000000..de8f9036e0
--- /dev/null
+++ b/pilot/pkg/config/kube/ior/ior_test.go
@@ -0,0 +1,642 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ior
+
+import (
+	"context"
+	"fmt"
+	"strings"
+	"testing"
+	"time"
+
+	routeapiv1 "github.com/openshift/api/route/v1"
+	routev1 "github.com/openshift/client-go/route/clientset/versioned/typed/route/v1"
+	"github.com/stretchr/testify/assert"
+	k8sioapicorev1 "k8s.io/api/core/v1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/tools/cache"
+
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/config/kube/crdclient"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/kube"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/istio/pkg/test/util/retry"
+	"istio.io/pkg/log"
+)
+
+func initClients(t *testing.T,
+	stop <-chan struct{},
+	errorChannel chan error,
+	mrc memberroll.MemberRollController) (model.ConfigStoreCache, kube.Client, routev1.RouteV1Interface) {
+	t.Helper()
+
+	k8sClient := kube.NewFakeClient()
+	iorKubeClient := NewFakeKubeClient(k8sClient)
+	routerClient := NewFakeRouterClient()
+	store, err := crdclient.New(k8sClient, "", "", false)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	go store.Run(stop)
+	k8sClient.RunAndWait(stop)
+	cache.WaitForCacheSync(stop, store.HasSynced)
+	retry.UntilSuccessOrFail(t, func() error {
+		if !store.HasSynced() {
+			return fmt.Errorf("store has not synced yet")
+		}
+		return nil
+	}, retry.Timeout(time.Second))
+
+	if err := Register(iorKubeClient, routerClient, store, "istio-system", mrc, stop, errorChannel); err != nil {
+		t.Fatal(err)
+	}
+
+	return store, k8sClient, routerClient
+}
+
+func TestCreate(t *testing.T) {
+	cases := []struct {
+		testName       string
+		ns             string
+		hosts          []string
+		gwSelector     map[string]string
+		expectedRoutes int
+		expectedError  string
+		tls            bool
+		annotations    map[string]string
+	}{
+		{
+			"One host",
+			"istio-system",
+			[]string{"one.org"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+			nil,
+		},
+		{
+			"Two hosts",
+			"istio-system",
+			[]string{"two.org", "three.com"},
+			map[string]string{"istio": "ingressgateway"},
+			2,
+			"",
+			false,
+			nil,
+		},
+		{
+			"Wildcard 1",
+			"istio-system",
+			[]string{"*"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+			nil,
+		},
+		{
+			"Wildcard 2",
+			"istio-system",
+			[]string{"*.a.com"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+			nil,
+		},
+		{
+			"Invalid gateway",
+			"istio-system",
+			[]string{"fail.com"},
+			map[string]string{"istio": "nonexistent"},
+			0,
+			"could not find a service that matches the gateway selector `istio=nonexistent'",
+			false,
+			nil,
+		},
+		{
+			"TLS 1",
+			"istio-system",
+			[]string{"one.org"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			true,
+			nil,
+		},
+		{
+			"Non-existing namespace",
+			"non-existing",
+			[]string{"fail.com"},
+			map[string]string{"istio": "ingressgateway"},
+			0,
+			"could not handle the ADD event for non-existing",
+			false,
+			nil,
+		},
+		{
+			"Gateway not managed",
+			"istio-system",
+			[]string{"notmanaged.org"},
+			map[string]string{"istio": "ingressgateway"},
+			0,
+			"",
+			false,
+			map[string]string{ShouldManageRouteAnnotation: "false", "foo": "bar"},
+		},
+		{
+			"Gateway explicitly managed",
+			"istio-system",
+			[]string{"explicitlymanaged.org"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+			map[string]string{ShouldManageRouteAnnotation: "TRUE", "foo": "bar"},
+		},
+		{
+			"Gateway explicitly managed with an invalid value",
+			"istio-system",
+			[]string{"explicitlymanaged.org"},
+			map[string]string{"istio": "ingressgateway"},
+			0,
+			fmt.Sprintf("could not parse annotation %q:", ShouldManageRouteAnnotation),
+			false,
+			map[string]string{ShouldManageRouteAnnotation: "ABC", "foo": "bar"},
+		},
+		{
+			"Egress gateway must be ignored",
+			"istio-system",
+			[]string{"egress.org"},
+			map[string]string{"istio": "egressgateway"},
+			0,
+			"",
+			false,
+			nil,
+		},
+	}
+
+	IORLog.SetOutputLevel(log.DebugLevel)
+	stop := make(chan struct{})
+	defer func() { close(stop) }()
+	errorChannel := make(chan error)
+	mrc := newFakeMemberRollController()
+	store, k8sClient, routerClient := initClients(t, stop, errorChannel, mrc)
+	mrc.setNamespaces("istio-system")
+
+	controlPlane := "istio-system"
+	createIngressGateway(t, k8sClient, controlPlane, map[string]string{"istio": "ingressgateway"})
+
+	for i, c := range cases {
+		t.Run(c.testName, func(t *testing.T) {
+			gatewayName := fmt.Sprintf("gw%d", i)
+			createGateway(t, store, c.ns, gatewayName, c.hosts, c.gwSelector, c.tls, c.annotations)
+
+			list, _ := getRoutes(t, routerClient, controlPlane, c.expectedRoutes, time.Second)
+			if err := getError(errorChannel); err != nil {
+				if c.expectedError == "" {
+					t.Fatal(err)
+				}
+
+				if !strings.Contains(err.Error(), c.expectedError) {
+					t.Fatalf("expected error message containing `%s', got: %s", c.expectedError, err.Error())
+				}
+
+				// Error is expected and matches the golden string, nothing to do
+			} else {
+				if c.expectedError != "" {
+					t.Fatalf("expected error message containing `%s', got success", c.expectedError)
+				}
+
+				// Only continue the validation if any route is expected to be created
+				if c.expectedRoutes > 0 {
+					validateRoutes(t, c.hosts, list, gatewayName, c.tls)
+
+					// Remove the gateway and expect all routes get removed
+					deleteGateway(t, store, c.ns, gatewayName)
+					_, _ = getRoutes(t, routerClient, c.ns, 0, time.Second)
+					if err := getError(errorChannel); err != nil {
+						t.Fatal(err)
+					}
+				}
+			}
+
+		})
+	}
+}
+
+func validateRoutes(t *testing.T, hosts []string, list *routeapiv1.RouteList, gatewayName string, tls bool) {
+	for _, host := range hosts {
+		route := findRouteByHost(list, host)
+		if route == nil {
+			t.Fatalf("could not find a route with hostname %s", host)
+		}
+
+		// Check metadata
+		if route.Labels[gatewayNameLabel] != gatewayName {
+			t.Fatalf("wrong label, expecting %s, got %s", gatewayName, route.Annotations[gatewayNameLabel])
+		}
+		if route.Annotations["foo"] != "bar" {
+			t.Fatal("gateway annotations were not copied to route")
+		}
+		if _, found := route.Annotations[ShouldManageRouteAnnotation]; found {
+			t.Fatal(fmt.Sprintf("annotation %q should not be copied to the route", ShouldManageRouteAnnotation))
+		}
+
+		// Check hostname
+		if host == "*" && route.Spec.Host == "*" {
+			t.Fatal("Route's host wrongly set to *")
+		}
+		if strings.Contains(host, "*.") && !strings.Contains(route.Spec.Host, "wildcard.") {
+			t.Fatal("Route's host wrongly not set to wildcard.")
+		}
+
+		// TLS
+		if tls {
+			if route.Spec.TLS.InsecureEdgeTerminationPolicy != routeapiv1.InsecureEdgeTerminationPolicyRedirect {
+				t.Fatalf("wrong InsecureEdgeTerminationPolicy: %v", route.Spec.TLS.InsecureEdgeTerminationPolicy)
+			}
+			if route.Spec.TLS.Termination != routeapiv1.TLSTerminationPassthrough {
+				t.Fatalf("wrong Termination: %v", route.Spec.TLS.Termination)
+			}
+		}
+	}
+}
+
+func TestEdit(t *testing.T) {
+	cases := []struct {
+		testName       string
+		ns             string
+		hosts          []string
+		gwSelector     map[string]string
+		expectedRoutes int
+		expectedError  string
+		tls            bool
+	}{
+		{
+			"One host",
+			"istio-system",
+			[]string{"def.com"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+		},
+		{
+			"Two hosts",
+			"istio-system",
+			[]string{"ghi.org", "jkl.com"},
+			map[string]string{"istio": "ingressgateway"},
+			2,
+			"",
+			false,
+		},
+		{
+			"Wildcard 1",
+			"istio-system",
+			[]string{"*"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+		},
+		{
+			"Wildcard 2",
+			"istio-system",
+			[]string{"*.a.com"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			false,
+		},
+		{
+			"TLS 1",
+			"istio-system",
+			[]string{"one.org"},
+			map[string]string{"istio": "ingressgateway"},
+			1,
+			"",
+			true,
+		},
+	}
+
+	stop := make(chan struct{})
+	defer func() { close(stop) }()
+	errorChannel := make(chan error)
+	mrc := newFakeMemberRollController()
+	store, k8sClient, routerClient := initClients(t, stop, errorChannel, mrc)
+
+	controlPlane := "istio-system"
+	createIngressGateway(t, k8sClient, controlPlane, map[string]string{"istio": "ingressgateway"})
+	createGateway(t, store, controlPlane, "gw", []string{"abc.com"}, map[string]string{"istio": "ingressgateway"}, false, nil)
+	mrc.setNamespaces("istio-system")
+
+	list, _ := getRoutes(t, routerClient, controlPlane, 1, time.Second)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+
+	for i, c := range cases {
+		t.Run(c.testName, func(t *testing.T) {
+			editGateway(t, store, c.ns, "gw", c.hosts, c.gwSelector, c.tls, fmt.Sprintf("%d", i+2))
+			list, _ = getRoutes(t, routerClient, controlPlane, c.expectedRoutes, time.Second)
+			if err := getError(errorChannel); err != nil {
+				t.Fatal(err)
+			}
+
+			validateRoutes(t, c.hosts, list, "gw", c.tls)
+		})
+	}
+}
+
+// TestPerf makes sure we are not doing more API calls than necessary
+func TestPerf(t *testing.T) {
+	IORLog.SetOutputLevel(log.DebugLevel)
+	countCallsReset()
+
+	stop := make(chan struct{})
+	defer func() { close(stop) }()
+	errorChannel := make(chan error)
+	mrc := newFakeMemberRollController()
+	store, k8sClient, routerClient := initClients(t, stop, errorChannel, mrc)
+
+	// Create a bunch of namespaces and gateways, and make sure they don't take too long to be created
+	createIngressGateway(t, k8sClient, "istio-system", map[string]string{"istio": "ingressgateway"})
+	qty := 100
+	qtyNamespaces := qty + 1
+	createGateways(t, store, 1, qty)
+	mrc.setNamespaces(generateNamespaces(qty)...)
+
+	// It takes ~ 2s on my laptop, it's slower on prow
+	_, ignore := getRoutes(t, routerClient, "istio-system", qty, time.Minute)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+	assert.Equal(t, qty, countCallsGet("create"), "wrong number of calls to client.Routes().Create()")
+	assert.Equal(t, 0, countCallsGet("delete"), "wrong number of calls to client.Routes().Delete()")
+	assert.Equal(t, qtyNamespaces, countCallsGet("list")-ignore, "wrong number of calls to client.Routes().List()")
+	// qty=number of Create() calls; qtyNamespaces=number of List() calls
+	assert.Equal(t, qty+qtyNamespaces, countCallsGet("routes")-ignore, "wrong number of calls to client.Routes()")
+
+	// Now we have a lot of routes created, let's create one more gateway. We don't expect a lot of new API calls
+	countCallsReset()
+	createGateway(t, store, "ns1", "gw-ns1-1", []string{"instant.com"}, map[string]string{"istio": "ingressgateway"}, false, nil)
+	_, ignore = getRoutes(t, routerClient, "istio-system", qty+1, time.Second)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+	assert.Equal(t, 1, countCallsGet("create"), "wrong number of calls to client.Routes().Create()")
+	assert.Equal(t, 0, countCallsGet("delete"), "wrong number of calls to client.Routes().Delete()")
+	assert.Equal(t, 0, countCallsGet("list")-ignore, "wrong number of calls to client.Routes().List()")
+	assert.Equal(t, 1, countCallsGet("routes")-ignore, "wrong number of calls to client.Routes()")
+
+	// Editing. We don't expect a lot of new API calls
+	countCallsReset()
+	editGateway(t, store, "ns1", "gw-ns1-1", []string{"edited.com", "edited-other.com"}, map[string]string{"istio": "ingressgateway"}, false, "2")
+	_, ignore = getRoutes(t, routerClient, "istio-system", qty+2, time.Second)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+	assert.Equal(t, 2, countCallsGet("create"), "wrong number of calls to client.Routes().Create()")
+	assert.Equal(t, 1, countCallsGet("delete"), "wrong number of calls to client.Routes().Delete()")
+	assert.Equal(t, 0, countCallsGet("list")-ignore, "wrong number of calls to client.Routes().List()")
+	assert.Equal(t, 3, countCallsGet("routes")-ignore, "wrong number of calls to client.Routes()")
+
+	// Same for deletion. We don't expect a lot of new API calls
+	countCallsReset()
+	deleteGateway(t, store, "ns1", "gw-ns1-1")
+	_, ignore = getRoutes(t, routerClient, "istio-system", qty, time.Second)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+	assert.Equal(t, 0, countCallsGet("create"), "wrong number of calls to client.Routes().Create()")
+	assert.Equal(t, 2, countCallsGet("delete"), "wrong number of calls to client.Routes().Delete()")
+	assert.Equal(t, 0, countCallsGet("list")-ignore, "wrong number of calls to client.Routes().List()")
+	assert.Equal(t, 2, countCallsGet("routes")-ignore, "wrong number of calls to client.Routes()")
+}
+
+// TestConcurrency makes sure IOR can respond to events even when doing its initial sync
+func TestConcurrency(t *testing.T) {
+	IORLog.SetOutputLevel(log.DebugLevel)
+	stop := make(chan struct{})
+	defer func() { close(stop) }()
+	errorChannel := make(chan error)
+	mrc := newFakeMemberRollController()
+	store, k8sClient, routerClient := initClients(t, stop, errorChannel, mrc)
+
+	// Create a bunch of namespaces and gateways
+	createIngressGateway(t, k8sClient, "istio-system", map[string]string{"istio": "ingressgateway"})
+	qty := 50
+	createGateways(t, store, 1, qty)
+	mrc.setNamespaces(generateNamespaces(qty)...)
+
+	// At the same time, while IOR is processing those initial `qty` gateways, create `qty` more
+	go func() {
+		mrc.setNamespaces(generateNamespaces(qty * 2)...)
+		createGateways(t, store, qty+1, qty*2)
+	}()
+
+	// And expect all `qty * 2` gateways to be created
+	_, _ = getRoutes(t, routerClient, "istio-system", (qty * 2), time.Minute)
+	if err := getError(errorChannel); err != nil {
+		t.Fatal(err)
+	}
+
+}
+
+func generateNamespaces(qty int) []string {
+	var result []string
+
+	for i := 1; i <= qty; i++ {
+		result = append(result, fmt.Sprintf("ns%d", i))
+	}
+
+	return append(result, "istio-system")
+}
+
+func createGateways(t *testing.T, store model.ConfigStoreCache, begin, end int) {
+	for i := begin; i <= end; i++ {
+		createGateway(t,
+			store,
+			fmt.Sprintf("ns%d", i),
+			fmt.Sprintf("gw-ns%d", i),
+			[]string{fmt.Sprintf("d%d.com", i)},
+			map[string]string{"istio": "ingressgateway"},
+			false,
+			nil)
+	}
+}
+
+// getError tries to read an error from the error channel.
+// It tries 3 times beforing returning nil, in case of there's no error in the channel,
+// this is to give some time to async functions to run and fill the channel properly
+func getError(errorChannel chan error) error {
+	for i := 1; i < 3; i++ {
+		select {
+		case err := <-errorChannel:
+			return err
+		default:
+		}
+		time.Sleep(10 * time.Millisecond)
+	}
+	return nil
+}
+
+// getRoutes is a helper function that keeps trying getting a list of routes until it gets `size` items.
+// It returns the list of routes itself and the number of retries it run
+func getRoutes(t *testing.T, routerClient routev1.RouteV1Interface, ns string, size int, timeout time.Duration) (*routeapiv1.RouteList, int) {
+	var list *routeapiv1.RouteList
+
+	t.Helper()
+	count := 0
+
+	retry.UntilSuccessOrFail(t, func() error {
+		var err error
+
+		time.Sleep(time.Millisecond * 100)
+		list, err = routerClient.Routes(ns).List(context.TODO(), v1.ListOptions{})
+		count++
+		if err != nil {
+			return err
+		}
+		if len(list.Items) != size {
+			return fmt.Errorf("expected %d route(s), got %d", size, len(list.Items))
+		}
+		return nil
+	}, retry.Timeout(timeout))
+
+	return list, count
+}
+
+func findRouteByHost(list *routeapiv1.RouteList, host string) *routeapiv1.Route {
+	for _, route := range list.Items {
+		if route.Annotations[originalHostAnnotation] == host {
+			return &route
+		}
+	}
+	return nil
+}
+
+func createIngressGateway(t *testing.T, client kube.Client, ns string, labels map[string]string) {
+	t.Helper()
+	createPod(t, client, ns, labels)
+	createService(t, client, ns, labels)
+}
+
+func createPod(t *testing.T, client kube.Client, ns string, labels map[string]string) {
+	t.Helper()
+
+	_, err := client.CoreV1().Pods(ns).Create(context.TODO(), &k8sioapicorev1.Pod{
+		ObjectMeta: v1.ObjectMeta{
+			Labels: labels,
+		},
+	}, v1.CreateOptions{})
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func createService(t *testing.T, client kube.Client, ns string, labels map[string]string) {
+	t.Helper()
+
+	_, err := client.CoreV1().Services(ns).Create(context.TODO(), &k8sioapicorev1.Service{
+		ObjectMeta: v1.ObjectMeta{
+			Labels: labels,
+		},
+	}, v1.CreateOptions{})
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func createGateway(t *testing.T, store model.ConfigStoreCache, ns string, name string, hosts []string, gwSelector map[string]string,
+	tls bool, annotations map[string]string) {
+	t.Helper()
+
+	var tlsConfig *networking.ServerTLSSettings
+	if tls {
+		tlsConfig = &networking.ServerTLSSettings{HttpsRedirect: true}
+	}
+
+	if annotations == nil {
+		annotations = map[string]string{"foo": "bar"}
+	}
+
+	_, err := store.Create(config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+			Namespace:        ns,
+			Name:             name,
+			Annotations:      annotations,
+			ResourceVersion:  "1",
+		},
+		Spec: &networking.Gateway{
+			Selector: gwSelector,
+			Servers: []*networking.Server{
+				{
+					Hosts: hosts,
+					Tls:   tlsConfig,
+				},
+			},
+		},
+	})
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func editGateway(t *testing.T, store model.ConfigStoreCache, ns string, name string, hosts []string, gwSelector map[string]string, tls bool, resource string) {
+	t.Helper()
+
+	var tlsConfig *networking.ServerTLSSettings
+	if tls {
+		tlsConfig = &networking.ServerTLSSettings{HttpsRedirect: true}
+	}
+	_, err := store.Update(config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+			Namespace:        ns,
+			Name:             name,
+			Annotations:      map[string]string{"foo": "bar"},
+			ResourceVersion:  resource,
+		},
+		Spec: &networking.Gateway{
+			Selector: gwSelector,
+			Servers: []*networking.Server{
+				{
+					Hosts: hosts,
+					Tls:   tlsConfig,
+				},
+			},
+		},
+	})
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func deleteGateway(t *testing.T, store model.ConfigStoreCache, ns string, name string) {
+	t.Helper()
+
+	err := store.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(), name, ns, nil)
+	if err != nil {
+		t.Fatal(err)
+	}
+}
diff --git a/pilot/pkg/config/kube/ior/route.go b/pilot/pkg/config/kube/ior/route.go
new file mode 100644
index 0000000000..6aeaf02ce6
--- /dev/null
+++ b/pilot/pkg/config/kube/ior/route.go
@@ -0,0 +1,567 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ior
+
+import (
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/hashicorp/go-multierror"
+	v1 "github.com/openshift/api/route/v1"
+	routev1 "github.com/openshift/client-go/route/clientset/versioned/typed/route/v1"
+	"golang.org/x/net/context"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/util/intstr"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/tools/cache"
+
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/controller"
+)
+
+const (
+	maistraPrefix               = "maistra.io/"
+	generatedByLabel            = maistraPrefix + "generated-by"
+	generatedByValue            = "ior"
+	originalHostAnnotation      = maistraPrefix + "original-host"
+	gatewayNameLabel            = maistraPrefix + "gateway-name"
+	gatewayNamespaceLabel       = maistraPrefix + "gateway-namespace"
+	gatewayResourceVersionLabel = maistraPrefix + "gateway-resourceVersion"
+	ShouldManageRouteAnnotation = maistraPrefix + "manageRoute"
+)
+
+type syncRoutes struct {
+	metadata config.Meta
+	gateway  *networking.Gateway
+	routes   []*v1.Route
+}
+
+// route manages the integration between Istio Gateways and OpenShift Routes
+type route struct {
+	pilotNamespace     string
+	routerClient       routev1.RouteV1Interface
+	kubeClient         kubernetes.Interface
+	store              model.ConfigStoreCache
+	gatewaysMap        map[string]*syncRoutes
+	gatewaysLock       sync.Mutex
+	initialSyncRun     chan struct{}
+	alive              bool
+	stop               <-chan struct{}
+	handleEventTimeout time.Duration
+
+	// memberroll functionality
+	mrc              controller.MemberRollController
+	namespaceLock    sync.Mutex
+	namespaces       []string
+	gotInitialUpdate bool
+}
+
+// NewRouterClient returns an OpenShift client for Routers
+func NewRouterClient() (routev1.RouteV1Interface, error) {
+	config, err := kube.BuildClientConfig("", "")
+	if err != nil {
+		return nil, err
+	}
+
+	client, err := routev1.NewForConfig(config)
+	if err != nil {
+		return nil, err
+	}
+
+	return client, nil
+}
+
+// newRoute returns a new instance of Route object
+func newRoute(
+	kubeClient KubeClient,
+	routerClient routev1.RouteV1Interface,
+	store model.ConfigStoreCache,
+	pilotNamespace string,
+	mrc controller.MemberRollController,
+	stop <-chan struct{}) (*route, error) {
+	if !kubeClient.IsRouteSupported() {
+		return nil, fmt.Errorf("routes are not supported in this cluster")
+	}
+
+	r := &route{}
+
+	r.kubeClient = kubeClient.GetActualClient()
+	r.routerClient = routerClient
+	r.pilotNamespace = pilotNamespace
+	r.store = store
+	r.mrc = mrc
+	r.namespaces = []string{pilotNamespace}
+	r.stop = stop
+	r.initialSyncRun = make(chan struct{})
+	r.handleEventTimeout = kubeClient.GetHandleEventTimeout()
+
+	if r.mrc != nil {
+		IORLog.Debugf("Registering IOR into SMMR broadcast")
+		r.alive = true
+		r.mrc.Register(r, "ior")
+
+		go func(stop <-chan struct{}) {
+			<-stop
+			r.alive = false
+			IORLog.Debugf("Unregistering IOR from SMMR broadcast")
+		}(stop)
+	}
+
+	return r, nil
+}
+
+// initialSync runs on initialization only.
+//
+// It lists all Istio Gateways (source of truth) and OpenShift Routes, compares them and makes the necessary adjustments
+// (creation and/or removal of routes) so that gateways and routes be in sync.
+func (r *route) initialSync(initialNamespaces []string) error {
+	var result *multierror.Error
+	r.gatewaysMap = make(map[string]*syncRoutes)
+
+	r.gatewaysLock.Lock()
+	defer r.gatewaysLock.Unlock()
+
+	// List the gateways and put them into the gatewaysMap
+	// The store must be synced otherwise we might get an empty list
+	// We enforce this before calling this function in UpdateNamespaces()
+	configs, err := r.store.List(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(), model.NamespaceAll)
+	if err != nil {
+		return fmt.Errorf("could not get list of Gateways: %s", err)
+	}
+	IORLog.Debugf("initialSync() - Got %d Gateway(s)", len(configs))
+
+	for i, cfg := range configs {
+		IORLog.Debugf("initialSync() - Parsing Gateway [%d] %s/%s", i+1, cfg.Namespace, cfg.Name)
+		r.addNewSyncRoute(cfg)
+	}
+
+	// List the routes and put them into a map. Map key is the route object name
+	routes := map[string]v1.Route{}
+	for _, ns := range initialNamespaces {
+		IORLog.Debugf("initialSync() - Listing routes in ns %s", ns)
+		routeList, err := r.routerClient.Routes(ns).List(context.TODO(), metav1.ListOptions{
+			LabelSelector: fmt.Sprintf("%s=%s", generatedByLabel, generatedByValue),
+		})
+		if err != nil {
+			return fmt.Errorf("could not get list of Routes in namespace %s: %s", ns, err)
+		}
+		for _, route := range routeList.Items {
+			routes[route.Name] = route
+		}
+	}
+	IORLog.Debugf("initialSync() - Got %d route(s) across all %d namespace(s)", len(routes), len(initialNamespaces))
+
+	// Now that we have maps and routes mapped we can compare them (Gateways are the source of truth)
+	for _, syncRoute := range r.gatewaysMap {
+		for _, server := range syncRoute.gateway.Servers {
+			for _, host := range server.Hosts {
+				actualHost, _ := getActualHost(host, false)
+				routeName := getRouteName(syncRoute.metadata.Namespace, syncRoute.metadata.Name, actualHost)
+				route, ok := routes[routeName]
+				if ok {
+					// A route for this host was found, remove its entry in this map so that in the end only orphan routes are left
+					delete(routes, routeName)
+
+					// Route matches, no need to create one. Put it in the gatewaysMap and move to the next one
+					if syncRoute.metadata.ResourceVersion == route.Labels[gatewayResourceVersionLabel] {
+						syncRoute.routes = append(syncRoute.routes, &route)
+						continue
+					}
+
+					// Route does not match, remove it.
+					result = multierror.Append(result, r.deleteRoute(&route))
+				}
+
+				// Route is not found or was removed above because it didn't match. We need to create one now.
+				route2, err := r.createRoute(syncRoute.metadata, syncRoute.gateway, host, server.Tls)
+				if err != nil {
+					result = multierror.Append(result, err)
+				} else {
+					// Put it in the gatewaysMap and move to the next one
+					syncRoute.routes = append(syncRoute.routes, route2)
+				}
+			}
+		}
+	}
+
+	// At this point there are routes for every hostname in every Gateway.
+	// The `routes` map should only contain "orphan" routes, i.e., routes that do not belong to any Gateway
+	//
+	for _, route := range routes {
+		result = multierror.Append(result, r.deleteRoute(&route))
+	}
+
+	return result.ErrorOrNil()
+}
+
+func gatewaysMapKey(namespace, name string) string {
+	return namespace + "/" + name
+}
+
+// addNewSyncRoute creates a new syncRoutes and adds it to the gatewaysMap
+// Must be called with gatewaysLock locked
+func (r *route) addNewSyncRoute(cfg config.Config) *syncRoutes {
+	gw := cfg.Spec.(*networking.Gateway)
+	syncRoute := &syncRoutes{
+		metadata: cfg.Meta,
+		gateway:  gw,
+	}
+
+	r.gatewaysMap[gatewaysMapKey(cfg.Namespace, cfg.Name)] = syncRoute
+	return syncRoute
+}
+
+// ensureNamespaceExists makes sure the gateway namespace is present in r.namespaces
+// r.namespaces is updated by the SMMR controller, in SetNamespaces()
+// This handles the case where an ADD event comes before SetNamespaces() is called and
+// the unlikely case an ADD event arrives for a gateway whose namespace does not belong to the SMMR at all
+func (r *route) ensureNamespaceExists(cfg config.Config) error {
+	timeout := time.After(r.handleEventTimeout) // production default is 10s, but test default is only 1ms
+
+	for {
+		r.namespaceLock.Lock()
+		namespaces := r.namespaces
+		r.namespaceLock.Unlock()
+
+		for _, ns := range namespaces {
+			if ns == cfg.Namespace {
+				IORLog.Debugf("Namespace %s found in SMMR", cfg.Namespace)
+				return nil
+			}
+		}
+
+		select {
+		case <-timeout:
+			IORLog.Debugf("Namespace %s not found in SMMR. Aborting.", cfg.Namespace)
+			return fmt.Errorf("could not handle the ADD event for %s/%s: SMMR does not recognize this namespace", cfg.Namespace, cfg.Name)
+		default:
+			IORLog.Debugf("Namespace %s not found in SMMR, trying again", cfg.Namespace)
+		}
+		time.Sleep(100 * time.Millisecond)
+	}
+}
+
+func (r *route) handleAdd(cfg config.Config) error {
+	var result *multierror.Error
+
+	if err := r.ensureNamespaceExists(cfg); err != nil {
+		return err
+	}
+
+	r.gatewaysLock.Lock()
+	defer r.gatewaysLock.Unlock()
+
+	if _, ok := r.gatewaysMap[gatewaysMapKey(cfg.Namespace, cfg.Name)]; ok {
+		IORLog.Infof("gateway %s/%s already exists, not creating route(s) for it", cfg.Namespace, cfg.Name)
+		return nil
+	}
+
+	syncRoute := r.addNewSyncRoute(cfg)
+
+	for _, server := range syncRoute.gateway.Servers {
+		for _, host := range server.Hosts {
+			route, err := r.createRoute(cfg.Meta, syncRoute.gateway, host, server.Tls)
+			if err != nil {
+				result = multierror.Append(result, err)
+			} else {
+				syncRoute.routes = append(syncRoute.routes, route)
+			}
+		}
+	}
+
+	return result.ErrorOrNil()
+}
+
+func isManagedByIOR(cfg config.Config) (bool, error) {
+	// We don't manage egress gateways, but we can only look for the default label here.
+	// Users can still use generic labels (e.g. "app: my-ingressgateway" as in the istio docs) to refer to the gateway pod
+	gw := cfg.Spec.(*networking.Gateway)
+	if istioLabel, ok := gw.Selector["istio"]; ok && istioLabel == "egressgateway" {
+		return false, nil
+	}
+
+	manageRouteValue, ok := cfg.Annotations[ShouldManageRouteAnnotation]
+	if !ok {
+		// Manage routes by default, when annotation is not found.
+		return true, nil
+	}
+
+	manageRoute, err := strconv.ParseBool(manageRouteValue)
+	if err != nil {
+		return false, fmt.Errorf("could not parse annotation %q: %s", ShouldManageRouteAnnotation, err)
+	}
+
+	return manageRoute, nil
+}
+
+func (r *route) handleDel(cfg config.Config) error {
+	var result *multierror.Error
+
+	r.gatewaysLock.Lock()
+	defer r.gatewaysLock.Unlock()
+
+	key := gatewaysMapKey(cfg.Namespace, cfg.Name)
+	syncRoute, ok := r.gatewaysMap[key]
+	if !ok {
+		return fmt.Errorf("could not find an internal reference to gateway %s/%s", cfg.Namespace, cfg.Name)
+	}
+
+	IORLog.Debugf("The gateway %s/%s has %d route(s) associated with it. Removing them now.", cfg.Namespace, cfg.Name, len(syncRoute.routes))
+	for _, route := range syncRoute.routes {
+		result = multierror.Append(result, r.deleteRoute(route))
+	}
+
+	delete(r.gatewaysMap, key)
+
+	return result.ErrorOrNil()
+}
+
+func (r *route) handleEvent(event model.Event, cfg config.Config) error {
+	// Block until initial sync has finished
+	<-r.initialSyncRun
+
+	manageRoute, err := isManagedByIOR(cfg)
+	if err != nil {
+		return err
+	}
+	if !manageRoute {
+		IORLog.Infof("Ignoring Gateway %s/%s as it is not managed by Istiod", cfg.Namespace, cfg.Name)
+		return nil
+	}
+
+	switch event {
+	case model.EventAdd:
+		return r.handleAdd(cfg)
+
+	case model.EventUpdate:
+		var result *multierror.Error
+		result = multierror.Append(result, r.handleDel(cfg))
+		result = multierror.Append(result, r.handleAdd(cfg))
+		return result.ErrorOrNil()
+
+	case model.EventDelete:
+		return r.handleDel(cfg)
+	}
+
+	return fmt.Errorf("unknown event type %s", event)
+}
+
+// Trigerred by SMMR controller when SMMR changes
+func (r *route) SetNamespaces(namespaces ...string) {
+	if !r.alive {
+		return
+	}
+
+	IORLog.Debugf("UpdateNamespaces(%v)", namespaces)
+	r.namespaceLock.Lock()
+	r.namespaces = namespaces
+	r.namespaceLock.Unlock()
+
+	if r.gotInitialUpdate {
+		return
+	}
+	r.gotInitialUpdate = true
+
+	// In the first update we perform an initial sync
+	go func() {
+		// But only after gateway store cache is synced
+		IORLog.Debug("Waiting for the Gateway store cache to sync before performing our initial sync")
+		if !cache.WaitForNamedCacheSync("Gateways", r.stop, r.store.HasSynced) {
+			IORLog.Infof("Failed to sync Gateway store cache. Not performing initial sync.")
+			return
+		}
+		IORLog.Debug("Gateway store cache synced. Performing our initial sync now")
+
+		if err := r.initialSync(namespaces); err != nil {
+			IORLog.Errora(err)
+		}
+		IORLog.Debug("Initial sync finished")
+		close(r.initialSyncRun)
+	}()
+}
+
+func getHost(route v1.Route) string {
+	if host := route.ObjectMeta.Annotations[originalHostAnnotation]; host != "" {
+		return host
+	}
+	return route.Spec.Host
+}
+
+func (r *route) deleteRoute(route *v1.Route) error {
+	var immediate int64
+	host := getHost(*route)
+	err := r.routerClient.Routes(route.Namespace).Delete(context.TODO(), route.ObjectMeta.Name, metav1.DeleteOptions{GracePeriodSeconds: &immediate})
+	if err != nil {
+		return fmt.Errorf("error deleting route %s/%s: %s", route.ObjectMeta.Namespace, route.ObjectMeta.Name, err)
+	}
+
+	IORLog.Infof("Deleted route %s/%s (gateway hostname: %s)", route.ObjectMeta.Namespace, route.ObjectMeta.Name, host)
+	return nil
+}
+
+func (r *route) createRoute(metadata config.Meta, gateway *networking.Gateway, originalHost string, tls *networking.ServerTLSSettings) (*v1.Route, error) {
+	IORLog.Debugf("Creating route for hostname %s", originalHost)
+	actualHost, wildcard := getActualHost(originalHost, true)
+
+	var tlsConfig *v1.TLSConfig
+	targetPort := "http2"
+	if tls != nil {
+		tlsConfig = &v1.TLSConfig{Termination: v1.TLSTerminationPassthrough}
+		targetPort = "https"
+		if tls.HttpsRedirect {
+			tlsConfig.InsecureEdgeTerminationPolicy = v1.InsecureEdgeTerminationPolicyRedirect
+		}
+	}
+
+	serviceNamespace, serviceName, err := r.findService(gateway)
+	if err != nil {
+		return nil, err
+	}
+
+	annotations := map[string]string{
+		originalHostAnnotation: originalHost,
+	}
+	for keyName, keyValue := range metadata.Annotations {
+		if !strings.HasPrefix(keyName, "kubectl.kubernetes.io") && keyName != ShouldManageRouteAnnotation {
+			annotations[keyName] = keyValue
+		}
+	}
+
+	nr, err := r.routerClient.Routes(serviceNamespace).Create(context.TODO(), &v1.Route{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      getRouteName(metadata.Namespace, metadata.Name, actualHost),
+			Namespace: serviceNamespace,
+			Labels: map[string]string{
+				generatedByLabel:            generatedByValue,
+				gatewayNamespaceLabel:       metadata.Namespace,
+				gatewayNameLabel:            metadata.Name,
+				gatewayResourceVersionLabel: metadata.ResourceVersion,
+			},
+			Annotations: annotations,
+		},
+		Spec: v1.RouteSpec{
+			Host: actualHost,
+			Port: &v1.RoutePort{
+				TargetPort: intstr.IntOrString{
+					Type:   intstr.String,
+					StrVal: targetPort,
+				},
+			},
+			To: v1.RouteTargetReference{
+				Name: serviceName,
+			},
+			TLS:            tlsConfig,
+			WildcardPolicy: wildcard,
+		},
+	}, metav1.CreateOptions{})
+	if err != nil {
+		return nil, fmt.Errorf("error creating a route for the host %s (gateway: %s/%s): %s", originalHost, metadata.Namespace, metadata.Name, err)
+	}
+
+	IORLog.Infof("Created route %s/%s for hostname %s (gateway: %s/%s)",
+		nr.ObjectMeta.Namespace, nr.ObjectMeta.Name,
+		nr.Spec.Host,
+		metadata.Namespace, metadata.Name)
+
+	return nr, nil
+}
+
+// findService tries to find a service that matches with the given gateway selector
+// Returns the namespace and service name that is a match, or an error
+func (r *route) findService(gateway *networking.Gateway) (string, string, error) {
+	r.namespaceLock.Lock()
+	namespaces := r.namespaces
+	r.namespaceLock.Unlock()
+
+	gwSelector := labels.SelectorFromSet(gateway.Selector)
+
+	for _, ns := range namespaces {
+		// Get the list of pods that match the gateway selector
+		podList, err := r.kubeClient.CoreV1().Pods(ns).List(context.TODO(), metav1.ListOptions{LabelSelector: gwSelector.String()})
+		if err != nil {
+			return "", "", fmt.Errorf("could not get the list of pods in namespace %s: %v", ns, err)
+		}
+
+		// Get the list of services in this namespace
+		svcList, err := r.kubeClient.CoreV1().Services(ns).List(context.TODO(), metav1.ListOptions{})
+		if err != nil {
+			return "", "", fmt.Errorf("could not get the list of services in namespace %s: %v", ns, err)
+		}
+
+		// Look for a service whose selector matches the pod labels
+		for _, pod := range podList.Items {
+			podLabels := labels.Set(pod.ObjectMeta.Labels)
+
+			for _, svc := range svcList.Items {
+				svcSelector := labels.SelectorFromSet(svc.Spec.Selector)
+				if svcSelector.Matches(podLabels) {
+					return ns, svc.Name, nil
+				}
+			}
+		}
+	}
+
+	return "", "", fmt.Errorf("could not find a service that matches the gateway selector `%s'. Namespaces where we looked at: %v",
+		gwSelector.String(), namespaces)
+}
+
+func getRouteName(namespace, name, actualHost string) string {
+	return fmt.Sprintf("%s-%s-%s", namespace, name, hostHash(actualHost))
+}
+
+// getActualHost returns the actual hostname to be used in the route
+// `emitWarning` should be false when this function is used internally, without user interaction
+// It also returns the route's WildcardPolicy based on the hostname
+func getActualHost(originalHost string, emitWarning bool) (string, v1.WildcardPolicyType) {
+	wildcard := v1.WildcardPolicyNone
+	actualHost := originalHost
+
+	if originalHost == "*" {
+		actualHost = ""
+		if emitWarning {
+			IORLog.Warn("Hostname * is not supported at the moment. Letting OpenShift create it instead.")
+		}
+	} else if strings.HasPrefix(originalHost, "*.") {
+		// FIXME: Update link below to version 4.5 when it's out
+		// Wildcards are not enabled by default in OCP 3.x.
+		// See https://docs.openshift.com/container-platform/3.11/install_config/router/default_haproxy_router.html#using-wildcard-routes
+		// FIXME(2): Is there a way to check if OCP supports wildcard and print out a warning if not?
+		wildcard = v1.WildcardPolicySubdomain
+		actualHost = "wildcard." + strings.TrimPrefix(originalHost, "*.")
+	}
+
+	return actualHost, wildcard
+}
+
+// hostHash applies a sha256 on the host and truncate it to the first 8 bytes
+// This gives enough uniqueness for a given hostname
+func hostHash(name string) string {
+	if name == "" {
+		name = "star"
+	}
+
+	hash := sha256.Sum256([]byte(name))
+	return hex.EncodeToString(hash[:8])
+}
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 8a99e863ce..94fe95e26f 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -577,6 +577,9 @@ var (
 
 	EnableMaistraExtensionSupport = env.RegisterBoolVar("ENABLE_MAISTRA_EXTENSIONS", false,
 		"If enabled, pilot, will watch ServiceMeshExtension resources and apply them to filter chains of its proxies").Get()
+
+	EnableIOR = env.RegisterBoolVar("ENABLE_IOR", false,
+		"Whether to enable IOR component, which provides integration between Istio Gateways and OpenShift Routes").Get()
 )
 
 // UnsafeFeaturesEnabled returns true if any unsafe features are enabled.
diff --git a/pilot/pkg/leaderelection/leaderelection.go b/pilot/pkg/leaderelection/leaderelection.go
index 97417c2ed9..d9157fe1de 100644
--- a/pilot/pkg/leaderelection/leaderelection.go
+++ b/pilot/pkg/leaderelection/leaderelection.go
@@ -49,6 +49,7 @@ const (
 	GatewayDeploymentController = "istio-gateway-deployment-leader"
 	StatusController            = "istio-status-leader"
 	AnalyzeController           = "istio-analyze-leader"
+	IORController               = "ior-leader"
 )
 
 type LeaderElection struct {
diff --git a/pkg/kube/client.go b/pkg/kube/client.go
index 293d906ed5..8206b07133 100644
--- a/pkg/kube/client.go
+++ b/pkg/kube/client.go
@@ -572,6 +572,9 @@ func (c *client) RunAndWait(stop <-chan struct{}) {
 		c.gatewayapiInformer.Start(stop)
 	}
 	c.mcsapisInformers.Start(stop)
+	if c.memberRoll != nil {
+		c.memberRoll.Start(stop)
+	}
 	if c.fastSync {
 		// WaitForCacheSync will virtually never be synced on the first call, as its called immediately after Start()
 		// This triggers a 100ms delay per call, which is often called 2-3 times in a test, delaying tests.
diff --git a/vendor/github.com/openshift/api/route/v1/doc.go b/vendor/github.com/openshift/api/route/v1/doc.go
new file mode 100644
index 0000000000..e56fbbd8d1
diff --git a/vendor/github.com/openshift/api/route/v1/generated.pb.go b/vendor/github.com/openshift/api/route/v1/generated.pb.go
new file mode 100644
index 0000000000..977fa2618d
diff --git a/vendor/github.com/openshift/api/route/v1/generated.proto b/vendor/github.com/openshift/api/route/v1/generated.proto
new file mode 100644
index 0000000000..c4bc446e34
diff --git a/vendor/github.com/openshift/api/route/v1/legacy.go b/vendor/github.com/openshift/api/route/v1/legacy.go
new file mode 100644
index 0000000000..498f5dd0f0
diff --git a/vendor/github.com/openshift/api/route/v1/register.go b/vendor/github.com/openshift/api/route/v1/register.go
new file mode 100644
index 0000000000..6f99ef5c96
diff --git a/vendor/github.com/openshift/api/route/v1/types.go b/vendor/github.com/openshift/api/route/v1/types.go
new file mode 100644
index 0000000000..9e59c69782
diff --git a/vendor/github.com/openshift/api/route/v1/zz_generated.deepcopy.go b/vendor/github.com/openshift/api/route/v1/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..a9576c414c
diff --git a/vendor/github.com/openshift/api/route/v1/zz_generated.swagger_doc_generated.go b/vendor/github.com/openshift/api/route/v1/zz_generated.swagger_doc_generated.go
new file mode 100644
index 0000000000..9974795f62
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/doc.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/doc.go
new file mode 100644
index 0000000000..14db57a58f
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/register.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/scheme/register.go
new file mode 100644
index 0000000000..0604e5613d
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/doc.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/doc.go
new file mode 100644
index 0000000000..225e6b2be3
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/generated_expansion.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/generated_expansion.go
new file mode 100644
index 0000000000..4f2173b6fc
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route.go
new file mode 100644
index 0000000000..adbe7e565c
diff --git a/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route_client.go b/vendor/github.com/openshift/client-go/route/clientset/versioned/typed/route/v1/route_client.go
new file mode 100644
index 0000000000..351945deab
-- 
2.31.1

