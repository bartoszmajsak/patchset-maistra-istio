From 6bceb317c0abebebfc1c5b5d40ae3eeb81389f5b Mon Sep 17 00:00:00 2001
From: Daniel Grimm <dgrimm@redhat.com>
Date: Thu, 21 Jan 2021 19:15:50 +0100
Subject: [federation] Initial federation implementation

* MAISTRA-2194 Add server/client code for Federation Service Discovery v1

* MAISTRA-2195 Implement /watch endpoint

* MAISTRA-2293 add CRD and controller for federating meshes

* MAISTRA-2294 create CRD for federation ServiceExport (#324)

* MAISTRA-2294 update example VirtualService resources for ratings and mongodb (#333)
---
 go.mod                                        |   3 +
 go.sum                                        |   4 +
 licenses/github.com/cenkalti/backoff/LICENSE  |  20 +
 .../mitchellh/hashstructure/v2/LICENSE        |  21 +
 .../base/crds/maistra.io_meshfederations.yaml | 141 ++++
 .../base/crds/maistra.io_serviceexports.yaml  | 177 ++++
 .../maistra.io_servicemeshextensions.yaml     |  95 +++
 .../charts/base/files/gen-istio-cluster.yaml  | 427 ++++++++++
 manifests/charts/base/templates/crds.yaml     |   3 +
 manifests/charts/base/templates/role.yaml     |   5 +
 .../istio-discovery/files/gen-istio.yaml      |   7 +
 .../istio-discovery/templates/deployment.yaml |   4 +
 .../istio-discovery/templates/service.yaml    |   3 +
 .../istio-control/istio-discovery/values.yaml |   1 +
 manifests/charts/istiod-remote/values.yaml    |   5 +-
 mec/pkg/server/worker.go                      |   2 +-
 mec/pkg/server/worker_test.go                 |   2 +-
 pilot/cmd/pilot-discovery/app/cmd.go          |   2 +
 pilot/pkg/bootstrap/configcontroller.go       |   8 +
 pilot/pkg/bootstrap/options.go                |   5 +
 pilot/pkg/bootstrap/server.go                 |  46 ++
 pilot/pkg/bootstrap/server_test.go            |   1 +
 pilot/pkg/config/kube/crdclient/client.go     |   2 +-
 pilot/pkg/config/kube/ingressv1/status.go     |   9 +-
 pilot/pkg/config/kube/ior/ior_test.go         |   2 -
 pilot/pkg/features/pilot.go                   |   5 +
 .../serviceregistry/aggregate/controller.go   |   7 +
 .../serviceregistry/federation/controller.go  | 760 ++++++++++++++++++
 .../pkg/serviceregistry/federation/routing.go | 196 +++++
 .../pkg/serviceregistry/provider/providers.go |   2 +
 pkg/kube/controller/controller.go             | 147 ++++
 .../apis/servicemesh/v1alpha1/doc.go          |  19 +
 .../v1alpha1/meshfederation_types.go          | 169 ++++
 .../apis/servicemesh/v1alpha1/register.go     |   4 +
 .../v1alpha1/serviceexports_types.go          | 123 +++
 .../v1alpha1/servicemeshextension_types.go    |   1 +
 .../v1alpha1/zz_generated.deepcopy.go         | 431 +++++++++-
 .../v1alpha1/clientset/versioned/clientset.go |  18 +-
 .../versioned/fake/clientset_generated.go     |  10 +-
 .../clientset/versioned/fake/register.go      |   4 +-
 .../clientset/versioned/scheme/register.go    |   4 +-
 .../v1alpha1/fake/fake_meshfederation.go      | 140 ++++
 .../v1alpha1/fake/fake_serviceexports.go      | 140 ++++
 .../v1alpha1/fake/fake_servicemesh_client.go  |  14 +-
 .../fake/fake_servicemeshextension.go         |   6 +-
 .../v1alpha1/generated_expansion.go           |   4 +
 .../servicemesh/v1alpha1/meshfederation.go    | 193 +++++
 .../servicemesh/v1alpha1/serviceexports.go    | 193 +++++
 .../v1alpha1/servicemesh_client.go            |  36 +-
 .../v1alpha1/servicemeshextension.go          |   2 +-
 .../informers/externalversions/factory.go     |   4 +-
 .../informers/externalversions/generic.go     |   8 +-
 .../servicemesh/v1alpha1/interface.go         |  14 +
 .../servicemesh/v1alpha1/meshfederation.go    |  88 ++
 .../servicemesh/v1alpha1/serviceexports.go    |  88 ++
 .../v1alpha1/servicemeshextension.go          |   4 +-
 .../v1alpha1/expansion_generated.go           |  16 +
 .../servicemesh/v1alpha1/meshfederation.go    |  92 +++
 .../servicemesh/v1alpha1/serviceexports.go    |  92 +++
 pkg/servicemesh/federation/common/const.go    |  26 +
 pkg/servicemesh/federation/common/options.go  |  27 +
 .../federation/discovery/controller.go        | 329 ++++++++
 .../federation/discovery/controller_test.go   | 323 ++++++++
 .../federation/discovery/discovery.go         | 602 ++++++++++++++
 .../federation/example/config-poc/README.txt  |  35 +
 .../example/config-poc/cacerts/README.md      |  20 +
 .../example/config-poc/cacerts/ca-cert.pem    |  22 +
 .../example/config-poc/cacerts/ca-key.pem     |  27 +
 .../example/config-poc/cacerts/cert-chain.pem |  22 +
 .../config-poc/cacerts/generate-workload.sh   |  65 ++
 .../example/config-poc/cacerts/root-cert.pem  |  24 +
 .../config-poc/cacerts/workload-bar-cert.pem  |  43 +
 .../config-poc/cacerts/workload-bar-key.pem   |  27 +
 .../config-poc/cacerts/workload-foo-cert.pem  |  43 +
 .../config-poc/cacerts/workload-foo-key.pem   |  27 +
 .../federation/example/config-poc/cleanup.sh  |  25 +
 .../authorizationpolicy-direct-to-direct.yaml |  52 ++
 ...authorizationpolicy-direct-to-proxied.yaml |  38 +
 .../mongodb-remote-virtualservice.yaml        |  15 +
 .../ratings-split-virtualservice.yaml         |  19 +
 .../config-poc/export/meshfederation.yaml     |  14 +
 .../config-poc/export/serviceexports.yaml     |  23 +
 .../example/config-poc/export/smcp.yaml       |  85 ++
 .../example/config-poc/export/smmr.yaml       |   8 +
 .../config-poc/import/meshfederation.yaml     |  14 +
 .../config-poc/import/mongodb-service.yaml    |  12 +
 .../example/config-poc/import/smcp.yaml       |  85 ++
 .../example/config-poc/import/smmr.yaml       |   8 +
 .../federation/example/config-poc/install.sh  |  67 ++
 .../federation/export/controller.go           | 167 ++++
 pkg/servicemesh/federation/export/exports.go  | 183 +++++
 pkg/servicemesh/federation/federation.go      | 152 ++++
 pkg/servicemesh/federation/federation_test.go |  84 ++
 pkg/servicemesh/federation/model/model.go     |  73 ++
 pkg/servicemesh/federation/server/routing.go  | 275 +++++++
 pkg/servicemesh/federation/server/server.go   | 573 +++++++++++++
 .../federation/server/server_test.go          | 756 +++++++++++++++++
 pkg/servicemesh/maistra.mk                    |  15 +-
 vendor/github.com/cenkalti/backoff/.gitignore |  22 +
 .../github.com/cenkalti/backoff/.travis.yml   |  10 +
 vendor/github.com/cenkalti/backoff/LICENSE    |  20 +
 vendor/github.com/cenkalti/backoff/README.md  |  30 +
 vendor/github.com/cenkalti/backoff/backoff.go |  66 ++
 vendor/github.com/cenkalti/backoff/context.go |  63 ++
 .../cenkalti/backoff/exponential.go           | 153 ++++
 vendor/github.com/cenkalti/backoff/retry.go   |  82 ++
 vendor/github.com/cenkalti/backoff/ticker.go  |  82 ++
 vendor/github.com/cenkalti/backoff/tries.go   |  35 +
 .../mitchellh/hashstructure/v2/LICENSE        |  21 +
 .../mitchellh/hashstructure/v2/README.md      |  76 ++
 .../mitchellh/hashstructure/v2/errors.go      |  22 +
 .../mitchellh/hashstructure/v2/go.mod         |   3 +
 .../hashstructure/v2/hashstructure.go         | 483 +++++++++++
 .../mitchellh/hashstructure/v2/include.go     |  22 +
 vendor/modules.txt                            |   7 +
 115 files changed, 9556 insertions(+), 75 deletions(-)
 create mode 100644 licenses/github.com/cenkalti/backoff/LICENSE
 create mode 100644 licenses/github.com/mitchellh/hashstructure/v2/LICENSE
 create mode 100644 manifests/charts/base/crds/maistra.io_meshfederations.yaml
 create mode 100644 manifests/charts/base/crds/maistra.io_serviceexports.yaml
 create mode 100644 manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
 create mode 100644 pilot/pkg/serviceregistry/federation/controller.go
 create mode 100644 pilot/pkg/serviceregistry/federation/routing.go
 create mode 100644 pkg/kube/controller/controller.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/doc.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/meshfederation_types.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/serviceexports_types.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_meshfederation.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_serviceexports.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/meshfederation.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/serviceexports.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/meshfederation.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/serviceexports.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/meshfederation.go
 create mode 100644 pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/serviceexports.go
 create mode 100644 pkg/servicemesh/federation/common/const.go
 create mode 100644 pkg/servicemesh/federation/common/options.go
 create mode 100644 pkg/servicemesh/federation/discovery/controller.go
 create mode 100644 pkg/servicemesh/federation/discovery/controller_test.go
 create mode 100644 pkg/servicemesh/federation/discovery/discovery.go
 create mode 100644 pkg/servicemesh/federation/example/config-poc/README.txt
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/README.md
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/ca-cert.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/ca-key.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/cert-chain.pem
 create mode 100755 pkg/servicemesh/federation/example/config-poc/cacerts/generate-workload.sh
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/root-cert.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-cert.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-key.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-cert.pem
 create mode 100644 pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-key.pem
 create mode 100755 pkg/servicemesh/federation/example/config-poc/cleanup.sh
 create mode 100644 pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-direct.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-proxied.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/examples/mongodb-remote-virtualservice.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/examples/ratings-split-virtualservice.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/smmr.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/mongodb-service.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/smmr.yaml
 create mode 100755 pkg/servicemesh/federation/example/config-poc/install.sh
 create mode 100644 pkg/servicemesh/federation/export/controller.go
 create mode 100644 pkg/servicemesh/federation/export/exports.go
 create mode 100644 pkg/servicemesh/federation/federation.go
 create mode 100644 pkg/servicemesh/federation/federation_test.go
 create mode 100644 pkg/servicemesh/federation/model/model.go
 create mode 100644 pkg/servicemesh/federation/server/routing.go
 create mode 100644 pkg/servicemesh/federation/server/server.go
 create mode 100644 pkg/servicemesh/federation/server/server_test.go
 create mode 100644 vendor/github.com/cenkalti/backoff/.gitignore
 create mode 100644 vendor/github.com/cenkalti/backoff/.travis.yml
 create mode 100644 vendor/github.com/cenkalti/backoff/LICENSE
 create mode 100644 vendor/github.com/cenkalti/backoff/README.md
 create mode 100644 vendor/github.com/cenkalti/backoff/backoff.go
 create mode 100644 vendor/github.com/cenkalti/backoff/context.go
 create mode 100644 vendor/github.com/cenkalti/backoff/exponential.go
 create mode 100644 vendor/github.com/cenkalti/backoff/retry.go
 create mode 100644 vendor/github.com/cenkalti/backoff/ticker.go
 create mode 100644 vendor/github.com/cenkalti/backoff/tries.go
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/LICENSE
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/README.md
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/errors.go
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/go.mod
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/hashstructure.go
 create mode 100644 vendor/github.com/mitchellh/hashstructure/v2/include.go

diff --git a/go.mod b/go.mod
index 12448485d4..f7c9aa8493 100644
--- a/go.mod
+++ b/go.mod
@@ -22,6 +22,7 @@ require (
 	github.com/AdaLogics/go-fuzz-headers v0.0.0-20210929163055-e81b3f25be97
 	github.com/Masterminds/sprig/v3 v3.2.2
 	github.com/aws/aws-sdk-go v1.41.7
+	github.com/cenkalti/backoff v2.2.1+incompatible
 	github.com/cenkalti/backoff/v4 v4.1.1
 	github.com/census-instrumentation/opencensus-proto v0.3.0
 	github.com/cheggaaa/pb/v3 v3.0.8
@@ -58,9 +59,11 @@ require (
 	github.com/miekg/dns v1.1.43
 	github.com/mitchellh/copystructure v1.2.0
 	github.com/mitchellh/go-homedir v1.1.0
+	github.com/mitchellh/hashstructure/v2 v2.0.1
 	github.com/onsi/gomega v1.16.0
 	github.com/openshift/api v0.0.0-20200929171550-c99a4deebbe5
 	github.com/openshift/client-go v0.0.0-20200929181438-91d71ef2122c
+	github.com/pkg/errors v0.9.1
 	github.com/pmezard/go-difflib v1.0.0
 	github.com/prometheus/client_golang v1.11.0
 	github.com/prometheus/client_model v0.2.0
diff --git a/go.sum b/go.sum
index 6b2bcdb7fc..da9cf7733f 100644
--- a/go.sum
+++ b/go.sum
@@ -204,6 +204,8 @@ github.com/buger/jsonparser v1.1.1/go.mod h1:6RYKKt7H4d4+iWqouImQ9R2FZql3VbhNgx2
 github.com/bugsnag/bugsnag-go v0.0.0-20141110184014-b1d153021fcd/go.mod h1:2oa8nejYd4cQ/b0hMIopN0lCRxU0bueqREvZLWFrtK8=
 github.com/bugsnag/osext v0.0.0-20130617224835-0dd3f918b21b/go.mod h1:obH5gd0BsqsP2LwDJ9aOkm/6J86V6lyAXCoQWGw3K50=
 github.com/bugsnag/panicwrap v0.0.0-20151223152923-e2c28503fcd0/go.mod h1:D/8v3kj0zr8ZAKg1AQ6crr+5VwKN5eIywRkfhyM/+dE=
+github.com/cenkalti/backoff v2.2.1+incompatible h1:tNowT99t7UNflLxfYYSlKYsBpXdEet03Pg2g16Swow4=
+github.com/cenkalti/backoff v2.2.1+incompatible/go.mod h1:90ReRw6GdpyfrHakVjL/QHaoyV4aDUVVkXQJJJ3NXXM=
 github.com/cenkalti/backoff/v4 v4.1.1 h1:G2HAfAmvm/GcKan2oOQpBXOd2tT2G57ZnZGWa1PxPBQ=
 github.com/cenkalti/backoff/v4 v4.1.1/go.mod h1:scbssz8iZGpm3xbr14ovlUdkxfGXNInqkPWOWmG2CLw=
 github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
@@ -907,6 +909,8 @@ github.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG
 github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
 github.com/mitchellh/go-wordwrap v1.0.0 h1:6GlHJ/LTGMrIJbwgdqdl2eEH8o+Exx/0m8ir9Gns0u4=
 github.com/mitchellh/go-wordwrap v1.0.0/go.mod h1:ZXFpozHsX6DPmq2I0TCekCxypsnAUbP2oI0UX1GXzOo=
+github.com/mitchellh/hashstructure/v2 v2.0.1 h1:L60q1+q7cXE4JeEJJKMnh2brFIe3rZxCihYAB61ypAY=
+github.com/mitchellh/hashstructure/v2 v2.0.1/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
 github.com/mitchellh/mapstructure v1.1.2 h1:fmNYVwqnSfB9mZU6OS2O6GsXM+wcskZDuKQzvN1EDeE=
 github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
 github.com/mitchellh/osext v0.0.0-20151018003038-5e2d6d41470f/go.mod h1:OkQIRizQZAeMln+1tSwduZz7+Af5oFlKirV/MSYes2A=
diff --git a/licenses/github.com/cenkalti/backoff/LICENSE b/licenses/github.com/cenkalti/backoff/LICENSE
new file mode 100644
index 0000000000..89b8179965
--- /dev/null
+++ b/licenses/github.com/cenkalti/backoff/LICENSE
@@ -0,0 +1,20 @@
+The MIT License (MIT)
+
+Copyright (c) 2014 Cenk AltÄ±
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/licenses/github.com/mitchellh/hashstructure/v2/LICENSE b/licenses/github.com/mitchellh/hashstructure/v2/LICENSE
new file mode 100644
index 0000000000..a3866a291f
--- /dev/null
+++ b/licenses/github.com/mitchellh/hashstructure/v2/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2016 Mitchell Hashimoto
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/manifests/charts/base/crds/maistra.io_meshfederations.yaml b/manifests/charts/base/crds/maistra.io_meshfederations.yaml
new file mode 100644
index 0000000000..4090dd0a00
--- /dev/null
+++ b/manifests/charts/base/crds/maistra.io_meshfederations.yaml
@@ -0,0 +1,141 @@
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: meshfederations.maistra.io
+spec:
+  group: maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: MeshFederation
+    listKind: MeshFederationList
+    plural: meshfederations
+    singular: meshfederation
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: MeshFederation is the Schema for joining two meshes together.  The
+        resource name will be used to identify the 'cluster' to which imported services
+        belong.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: TODO
+          properties:
+            gateways:
+              properties:
+                egress:
+                  description: Gateway through which outbound federated service traffic
+                    will travel. This is not required if AllowDirectOutbound is set
+                    to true.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                        TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+                ingress:
+                  description: Gateway through which inbound federated service traffic
+                    will travel.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                        TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+              type: object
+            networkAddress:
+              description: 'NetworkAddress is the address used to communicate with
+                the external mesh. Port 15443 will be used for service traffic and
+                port 8188 will be used for service discovery. XXX: should this be
+                an array?'
+              type: string
+            security:
+              properties:
+                allowDirectInbound:
+                  description: 'AllowDirectInbound determines whether or not external
+                    service invocations will be terminated at the ingress the gateway.
+                    XXX: should this also be configurable per exported service?'
+                  type: boolean
+                allowDirectOutbound:
+                  description: 'AllowDirectOutbound determines whether or not external
+                    service invocations will be proxied through the gateway XXX: should
+                    this also be configurable per imported service?'
+                  type: boolean
+                certificateChain:
+                  description: 'Name of secret containing certificate chain to be
+                    used to validate the remote.  This is also used to validate certificates
+                    used by the remote services (both client and server certificates).
+                    XXX: maybe this is only used to initiate a connection, with the
+                    actual certs stored in the status field, as retrieved from the
+                    remote mesh, or maybe this identifies an endpoint used to retrieve
+                    a cert chain, a la jwks'
+                  type: string
+                clientID:
+                  description: ClientID of the remote mesh.  This is used to authenticate
+                    incoming requrests from the remote mesh's discovery client.
+                  type: string
+                trustDomain:
+                  description: TrustDomain of remote mesh.
+                  type: string
+              type: object
+          type: object
+        status:
+          description: TODO
+          properties:
+            conditions:
+              items:
+                properties:
+                  lastTransitionTime:
+                    description: Last time the condition transitioned from one status
+                      to another.
+                    format: date-time
+                    type: string
+                  message:
+                    description: Human-readable message indicating details about the
+                      last transition.
+                    type: string
+                  reason:
+                    description: Unique, single-word, CamelCase reason for the condition's
+                      last transition.
+                    type: string
+                  status:
+                    description: The status of this condition. Can be True, False
+                      or Unknown.
+                    type: string
+                  type:
+                    description: The type of this condition.
+                    type: string
+                type: object
+              type: array
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_serviceexports.yaml b/manifests/charts/base/crds/maistra.io_serviceexports.yaml
new file mode 100644
index 0000000000..9248c64f1e
--- /dev/null
+++ b/manifests/charts/base/crds/maistra.io_serviceexports.yaml
@@ -0,0 +1,177 @@
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: serviceexports.maistra.io
+spec:
+  group: maistra.io
+  names:
+    kind: ServiceExports
+    listKind: ServiceExportsList
+    plural: serviceexports
+    singular: serviceexports
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: ServiceExport is the Schema for configuring exported services.  The
+        name of the ServiceExports resource must match the name of a MeshFederation
+        resource defining the remote mesh to which the services will be exported.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: Spec defines rules for matching services to be exported.
+          properties:
+            exports:
+              description: Exports are the rules that determine which services are
+                exported from the mesh.  The list is processed in order and the first
+                spec in the list that applies to a service is the one that will be
+                applied.  This allows more specific selectors to be placed before
+                more general selectors.
+              items:
+                properties:
+                  labelSelector:
+                    description: LabelSelector provides a mechanism for selecting
+                      services to export by using a label selector to match Service
+                      resources for export.
+                    properties:
+                      aliases:
+                        description: 'Aliases is a map of aliases to apply to exported
+                          services.  If a name is not found in the map, the original
+                          service name is exported.  A ''*'' will match any name.
+                          The Aliases list will be processed in order, with the first
+                          match found being applied to the exported service. Examples:
+                          */foo->*/bar will match foo service in any namesapce, exporting
+                          it as bar from its original namespace. */foo->bar/bar will
+                          match foo service in any namespace, exporting it as bar/bar.
+                          foo/*->bar/* will match any service in foo namespace, exporting
+                          it from the bar namespace with its original name */*->bar/*
+                          will match any service and export it from the bar namespace
+                          with its original name. */*->*/* is the same as not specifying
+                          anything'
+                        items:
+                          properties:
+                            alias:
+                              properties:
+                                names:
+                                  type: string
+                                namespace:
+                                  type: string
+                              type: object
+                            name:
+                              properties:
+                                names:
+                                  type: string
+                                namespace:
+                                  type: string
+                              type: object
+                          type: object
+                        type: array
+                      namespace:
+                        description: Namespace specifies to which namespace the selector
+                          applies.  An empty value applies to all namespaces in the
+                          mesh.
+                        type: string
+                      selector:
+                        description: Selector used to select Service resources in
+                          the namespace/mesh.  An empty selector selects all services.
+                        properties:
+                          matchExpressions:
+                            description: matchExpressions is a list of label selector
+                              requirements. The requirements are ANDed.
+                            items:
+                              description: A label selector requirement is a selector
+                                that contains values, a key, and an operator that
+                                relates the key and values.
+                              properties:
+                                key:
+                                  description: key is the label key that the selector
+                                    applies to.
+                                  type: string
+                                operator:
+                                  description: operator represents a key's relationship
+                                    to a set of values. Valid operators are In, NotIn,
+                                    Exists and DoesNotExist.
+                                  type: string
+                                values:
+                                  description: values is an array of string values.
+                                    If the operator is In or NotIn, the values array
+                                    must be non-empty. If the operator is Exists or
+                                    DoesNotExist, the values array must be empty.
+                                    This array is replaced during a strategic merge
+                                    patch.
+                                  items:
+                                    type: string
+                                  type: array
+                              required:
+                              - key
+                              - operator
+                              type: object
+                            type: array
+                          matchLabels:
+                            additionalProperties:
+                              type: string
+                            description: matchLabels is a map of {key,value} pairs.
+                              A single {key,value} in the matchLabels map is equivalent
+                              to an element of matchExpressions, whose key field is
+                              "key", the operator is "In", and the values array contains
+                              only "value". The requirements are ANDed.
+                            type: object
+                        type: object
+                    type: object
+                  nameSelector:
+                    description: NameSelector provides a simple name matcher for exporting
+                      services in the mesh.
+                    properties:
+                      alias:
+                        properties:
+                          names:
+                            type: string
+                          namespace:
+                            type: string
+                        type: object
+                      name:
+                        properties:
+                          names:
+                            type: string
+                          namespace:
+                            type: string
+                        type: object
+                    type: object
+                  type:
+                    type: string
+                required:
+                - type
+                type: object
+              type: array
+          type: object
+        status:
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml b/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
new file mode 100644
index 0000000000..93a53e1754
--- /dev/null
+++ b/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
@@ -0,0 +1,95 @@
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: servicemeshextensions.maistra.io
+spec:
+  group: maistra.io
+  names:
+    kind: ServiceMeshExtension
+    listKind: ServiceMeshExtensionList
+    plural: servicemeshextensions
+    singular: servicemeshextension
+  preserveUnknownFields: false
+  scope: Namespaced
+  validation:
+    openAPIV3Schema:
+      description: ServiceMeshExtension is the Schema for the servicemeshextensions
+        API
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: ServiceMeshExtensionSpec defines the desired state of ServiceMeshExtension
+          properties:
+            config:
+              type: string
+            image:
+              type: string
+            phase:
+              description: FilterPhase defines point of injection of Envoy filter
+              type: string
+            priority:
+              type: integer
+            workloadSelector:
+              description: WorkloadSelector is used to match workloads based on pod
+                labels
+              properties:
+                labels:
+                  additionalProperties:
+                    type: string
+                  type: object
+              required:
+              - labels
+              type: object
+          required:
+          - phase
+          type: object
+        status:
+          description: ServiceMeshExtensionStatus defines the observed state of ServiceMeshExtension
+          properties:
+            deployment:
+              properties:
+                containerSha256:
+                  type: string
+                ready:
+                  type: boolean
+                sha256:
+                  type: string
+                url:
+                  type: string
+              type: object
+            observedGeneration:
+              format: int64
+              type: integer
+            phase:
+              description: FilterPhase defines point of injection of Envoy filter
+              type: string
+            priority:
+              type: integer
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/files/gen-istio-cluster.yaml b/manifests/charts/base/files/gen-istio-cluster.yaml
index da4025a7d4..e0f2e5c950 100644
--- a/manifests/charts/base/files/gen-istio-cluster.yaml
+++ b/manifests/charts/base/files/gen-istio-cluster.yaml
@@ -5993,6 +5993,428 @@ spec:
     storage: true
 ---
 
+---
+# Source: crds/maistra.io_meshfederations.yaml
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: meshfederations.maistra.io
+spec:
+  group: maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: MeshFederation
+    listKind: MeshFederationList
+    plural: meshfederations
+    singular: meshfederation
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: MeshFederation is the Schema for joining two meshes together.  The
+        resource name will be used to identify the 'cluster' to which imported services
+        belong.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: TODO
+          properties:
+            gateways:
+              properties:
+                egress:
+                  description: Gateway through which outbound federated service traffic
+                    will travel. This is not required if AllowDirectOutbound is set
+                    to true.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                        TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+                ingress:
+                  description: Gateway through which inbound federated service traffic
+                    will travel.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
+                        TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+              type: object
+            networkAddress:
+              description: 'NetworkAddress is the address used to communicate with
+                the external mesh. Port 15443 will be used for service traffic and
+                port 8188 will be used for service discovery. XXX: should this be
+                an array?'
+              type: string
+            security:
+              properties:
+                allowDirectInbound:
+                  description: 'AllowDirectInbound determines whether or not external
+                    service invocations will be terminated at the ingress the gateway.
+                    XXX: should this also be configurable per exported service?'
+                  type: boolean
+                allowDirectOutbound:
+                  description: 'AllowDirectOutbound determines whether or not external
+                    service invocations will be proxied through the gateway XXX: should
+                    this also be configurable per imported service?'
+                  type: boolean
+                certificateChain:
+                  description: 'Name of secret containing certificate chain to be
+                    used to validate the remote.  This is also used to validate certificates
+                    used by the remote services (both client and server certificates).
+                    XXX: maybe this is only used to initiate a connection, with the
+                    actual certs stored in the status field, as retrieved from the
+                    remote mesh, or maybe this identifies an endpoint used to retrieve
+                    a cert chain, a la jwks'
+                  type: string
+                clientID:
+                  description: ClientID of the remote mesh.  This is used to authenticate
+                    incoming requrests from the remote mesh's discovery client.
+                  type: string
+                trustDomain:
+                  description: TrustDomain of remote mesh.
+                  type: string
+              type: object
+          type: object
+        status:
+          description: TODO
+          properties:
+            conditions:
+              items:
+                properties:
+                  lastTransitionTime:
+                    description: Last time the condition transitioned from one status
+                      to another.
+                    format: date-time
+                    type: string
+                  message:
+                    description: Human-readable message indicating details about the
+                      last transition.
+                    type: string
+                  reason:
+                    description: Unique, single-word, CamelCase reason for the condition's
+                      last transition.
+                    type: string
+                  status:
+                    description: The status of this condition. Can be True, False
+                      or Unknown.
+                    type: string
+                  type:
+                    description: The type of this condition.
+                    type: string
+                type: object
+              type: array
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
+
+---
+# Source: crds/maistra.io_serviceexports.yaml
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: serviceexports.maistra.io
+spec:
+  group: maistra.io
+  names:
+    kind: ServiceExports
+    listKind: ServiceExportsList
+    plural: serviceexports
+    singular: serviceexports
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: ServiceExport is the Schema for configuring exported services.  The
+        name of the ServiceExports resource must match the name of a MeshFederation
+        resource defining the remote mesh to which the services will be exported.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: Spec defines rules for matching services to be exported.
+          properties:
+            exports:
+              description: Exports are the rules that determine which services are
+                exported from the mesh.  The list is processed in order and the first
+                spec in the list that applies to a service is the one that will be
+                applied.  This allows more specific selectors to be placed before
+                more general selectors.
+              items:
+                properties:
+                  labelSelector:
+                    description: LabelSelector provides a mechanism for selecting
+                      services to export by using a label selector to match Service
+                      resources for export.
+                    properties:
+                      aliases:
+                        description: 'Aliases is a map of aliases to apply to exported
+                          services.  If a name is not found in the map, the original
+                          service name is exported.  A ''*'' will match any name.
+                          The Aliases list will be processed in order, with the first
+                          match found being applied to the exported service. Examples:
+                          */foo->*/bar will match foo service in any namesapce, exporting
+                          it as bar from its original namespace. */foo->bar/bar will
+                          match foo service in any namespace, exporting it as bar/bar.
+                          foo/*->bar/* will match any service in foo namespace, exporting
+                          it from the bar namespace with its original name */*->bar/*
+                          will match any service and export it from the bar namespace
+                          with its original name. */*->*/* is the same as not specifying
+                          anything'
+                        items:
+                          properties:
+                            alias:
+                              properties:
+                                names:
+                                  type: string
+                                namespace:
+                                  type: string
+                              type: object
+                            name:
+                              properties:
+                                names:
+                                  type: string
+                                namespace:
+                                  type: string
+                              type: object
+                          type: object
+                        type: array
+                      namespace:
+                        description: Namespace specifies to which namespace the selector
+                          applies.  An empty value applies to all namespaces in the
+                          mesh.
+                        type: string
+                      selector:
+                        description: Selector used to select Service resources in
+                          the namespace/mesh.  An empty selector selects all services.
+                        properties:
+                          matchExpressions:
+                            description: matchExpressions is a list of label selector
+                              requirements. The requirements are ANDed.
+                            items:
+                              description: A label selector requirement is a selector
+                                that contains values, a key, and an operator that
+                                relates the key and values.
+                              properties:
+                                key:
+                                  description: key is the label key that the selector
+                                    applies to.
+                                  type: string
+                                operator:
+                                  description: operator represents a key's relationship
+                                    to a set of values. Valid operators are In, NotIn,
+                                    Exists and DoesNotExist.
+                                  type: string
+                                values:
+                                  description: values is an array of string values.
+                                    If the operator is In or NotIn, the values array
+                                    must be non-empty. If the operator is Exists or
+                                    DoesNotExist, the values array must be empty.
+                                    This array is replaced during a strategic merge
+                                    patch.
+                                  items:
+                                    type: string
+                                  type: array
+                              required:
+                              - key
+                              - operator
+                              type: object
+                            type: array
+                          matchLabels:
+                            additionalProperties:
+                              type: string
+                            description: matchLabels is a map of {key,value} pairs.
+                              A single {key,value} in the matchLabels map is equivalent
+                              to an element of matchExpressions, whose key field is
+                              "key", the operator is "In", and the values array contains
+                              only "value". The requirements are ANDed.
+                            type: object
+                        type: object
+                    type: object
+                  nameSelector:
+                    description: NameSelector provides a simple name matcher for exporting
+                      services in the mesh.
+                    properties:
+                      alias:
+                        properties:
+                          names:
+                            type: string
+                          namespace:
+                            type: string
+                        type: object
+                      name:
+                        properties:
+                          names:
+                            type: string
+                          namespace:
+                            type: string
+                        type: object
+                    type: object
+                  type:
+                    type: string
+                required:
+                - type
+                type: object
+              type: array
+          type: object
+        status:
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
+
+---
+# Source: crds/maistra.io_servicemeshextensions.yaml
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.2.4
+  creationTimestamp: null
+  name: servicemeshextensions.maistra.io
+spec:
+  group: maistra.io
+  names:
+    kind: ServiceMeshExtension
+    listKind: ServiceMeshExtensionList
+    plural: servicemeshextensions
+    singular: servicemeshextension
+  preserveUnknownFields: false
+  scope: Namespaced
+  validation:
+    openAPIV3Schema:
+      description: ServiceMeshExtension is the Schema for the servicemeshextensions
+        API
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation
+            of an object. Servers should convert recognized schemas to the latest
+            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this
+            object represents. Servers may infer this from the endpoint the client
+            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: ServiceMeshExtensionSpec defines the desired state of ServiceMeshExtension
+          properties:
+            config:
+              type: string
+            image:
+              type: string
+            phase:
+              description: FilterPhase defines point of injection of Envoy filter
+              type: string
+            priority:
+              type: integer
+            workloadSelector:
+              description: WorkloadSelector is used to match workloads based on pod
+                labels
+              properties:
+                labels:
+                  additionalProperties:
+                    type: string
+                  type: object
+              required:
+              - labels
+              type: object
+          required:
+          - phase
+          type: object
+        status:
+          description: ServiceMeshExtensionStatus defines the observed state of ServiceMeshExtension
+          properties:
+            deployment:
+              properties:
+                containerSha256:
+                  type: string
+                ready:
+                  type: boolean
+                sha256:
+                  type: string
+                url:
+                  type: string
+              type: object
+            observedGeneration:
+              format: int64
+              type: integer
+            phase:
+              description: FilterPhase defines point of injection of Envoy filter
+              type: string
+            priority:
+              type: integer
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
+
 ---
 # Source: base/templates/reader-serviceaccount.yaml
 # This service account aggregates reader permissions for the revisions in a given cluster
@@ -6241,6 +6663,11 @@ rules:
   resources: ["secrets"]
   # TODO lock this down to istio-ca-cert if not using the DNS cert mesh config
   verbs: ["create", "get", "watch", "list", "update", "delete"]
+
+# For MeshFederation support
+- apiGroups: ["maistra.io"]
+  resources: ["meshfederations", "meshfederations/status", "serviceexports", "serviceexports/status"]
+  verbs: ["get", "list", "watch", "patch", "update"]
 ---
 # Source: base/templates/rolebinding.yaml
 # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
diff --git a/manifests/charts/base/templates/crds.yaml b/manifests/charts/base/templates/crds.yaml
index 871ee2a6b4..0f53a7126d 100644
--- a/manifests/charts/base/templates/crds.yaml
+++ b/manifests/charts/base/templates/crds.yaml
@@ -1,4 +1,7 @@
 {{- if .Values.base.enableCRDTemplates }}
 {{ .Files.Get "crds/crd-all.gen.yaml" }}
 {{ .Files.Get "crds/crd-operator.yaml" }}
+{{ .Files.Get "crds/maistra.io_meshfederations.yaml" }}
+{{ .Files.Get "crds/maistra.io_serviceexports.yaml" }}
+{{ .Files.Get "crds/maistra.io_servicemeshextensions.yaml" }}
 {{- end }}
diff --git a/manifests/charts/base/templates/role.yaml b/manifests/charts/base/templates/role.yaml
index ca1a4243f0..46710679e2 100644
--- a/manifests/charts/base/templates/role.yaml
+++ b/manifests/charts/base/templates/role.yaml
@@ -23,3 +23,8 @@ rules:
   resources: ["secrets"]
   # TODO lock this down to istio-ca-cert if not using the DNS cert mesh config
   verbs: ["create", "get", "watch", "list", "update", "delete"]
+
+# For MeshFederation support
+- apiGroups: ["maistra.io"]
+  resources: ["meshfederations", "meshfederations/status", "serviceexports", "serviceexports/status"]
+  verbs: ["get", "list", "watch", "patch", "update"]
diff --git a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
index 3ab8aba896..562c7a3a52 100644
--- a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
+++ b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
@@ -1521,6 +1521,9 @@ spec:
     - port: 15014
       name: http-monitoring # prometheus stats
       protocol: TCP
+    - port: 8188
+      name: http-discovery # federation discovery
+      protocol: TCP
   selector:
     app: istiod
     # Label used by the 'default' service. For versioned deployments we match with app and version.
@@ -1583,6 +1586,8 @@ spec:
             protocol: TCP
           - containerPort: 15017
             protocol: TCP
+          - containerPort: 8188
+            protocol: TCP
           readinessProbe:
             httpGet:
               path: /ready
@@ -1614,6 +1619,8 @@ spec:
                 fieldPath: spec.serviceAccountName
           - name: KUBECONFIG
             value: /var/run/secrets/remote/config
+          - name: PILOT_ENABLE_FEDERATION
+            value: "true"
           - name: PILOT_TRACE_SAMPLING
             value: "1"
           - name: PILOT_ENABLE_PROTOCOL_SNIFFING_FOR_OUTBOUND
diff --git a/manifests/charts/istio-control/istio-discovery/templates/deployment.yaml b/manifests/charts/istio-control/istio-discovery/templates/deployment.yaml
index 5b13aa9d2a..0c7c9c77a9 100644
--- a/manifests/charts/istio-control/istio-discovery/templates/deployment.yaml
+++ b/manifests/charts/istio-control/istio-discovery/templates/deployment.yaml
@@ -104,6 +104,8 @@ spec:
             protocol: TCP
           - containerPort: 15017
             protocol: TCP
+          - containerPort: 8188
+            protocol: TCP
           readinessProbe:
             httpGet:
               path: /ready
@@ -141,6 +143,8 @@ spec:
             value: "{{ $val }}"
           {{- end }}
           {{- end }}
+          - name: PILOT_ENABLE_FEDERATION
+            value: "{{ .Values.pilot.enableFederation }}"
 {{- if .Values.pilot.traceSampling }}
           - name: PILOT_TRACE_SAMPLING
             value: "{{ .Values.pilot.traceSampling }}"
diff --git a/manifests/charts/istio-control/istio-discovery/templates/service.yaml b/manifests/charts/istio-control/istio-discovery/templates/service.yaml
index b5ddf5b6e5..6fb94b9337 100644
--- a/manifests/charts/istio-control/istio-discovery/templates/service.yaml
+++ b/manifests/charts/istio-control/istio-discovery/templates/service.yaml
@@ -29,6 +29,9 @@ spec:
     - port: 15014
       name: http-monitoring # prometheus stats
       protocol: TCP
+    - port: 8188
+      name: http-discovery # federation discovery
+      protocol: TCP
   selector:
     app: istiod
     {{- if ne .Values.revision "" }}
diff --git a/manifests/charts/istio-control/istio-discovery/values.yaml b/manifests/charts/istio-control/istio-discovery/values.yaml
index b211f38913..74983bba9a 100644
--- a/manifests/charts/istio-control/istio-discovery/values.yaml
+++ b/manifests/charts/istio-control/istio-discovery/values.yaml
@@ -2,6 +2,7 @@
 
 ## Discovery Settings
 pilot:
+  enableFederation: true
   autoscaleEnabled: true
   autoscaleMin: 1
   autoscaleMax: 5
diff --git a/manifests/charts/istiod-remote/values.yaml b/manifests/charts/istiod-remote/values.yaml
index f11639ac42..f4c1ac2884 100644
--- a/manifests/charts/istiod-remote/values.yaml
+++ b/manifests/charts/istiod-remote/values.yaml
@@ -2,6 +2,7 @@
 
 ## Discovery Settings
 pilot:
+  enableFederation: true
   autoscaleEnabled: true
   autoscaleMin: 1
   autoscaleMax: 5
@@ -114,8 +115,8 @@ sidecarInjectorWebhook:
   # This is intended for advanced configuration only; most users should use the built in template
   templates: {}
   # Default templates specifies a set of default templates that are used in sidecar injection.
-  # By default, a template `sidecar` is always provided, which contains the template of default sidecar. 
-  # To inject other additional templates, define it using the `templates` option, and add it to 
+  # By default, a template `sidecar` is always provided, which contains the template of default sidecar.
+  # To inject other additional templates, define it using the `templates` option, and add it to
   # the default templates list.
   # For example:
   #
diff --git a/mec/pkg/server/worker.go b/mec/pkg/server/worker.go
index 793f156fa0..e40074072b 100644
--- a/mec/pkg/server/worker.go
+++ b/mec/pkg/server/worker.go
@@ -54,7 +54,7 @@ type Worker struct {
 
 	pullStrategy model.ImagePullStrategy
 
-	client       v1alpha1client.ServicemeshV1alpha1Interface
+	client       v1alpha1client.MaistraV1alpha1Interface
 	stopChan     <-chan struct{}
 	resultChan   chan workerResult
 	Queue        chan ExtensionEvent
diff --git a/mec/pkg/server/worker_test.go b/mec/pkg/server/worker_test.go
index 3d4f0ba0e6..ba34c4bfb4 100644
--- a/mec/pkg/server/worker_test.go
+++ b/mec/pkg/server/worker_test.go
@@ -272,7 +272,7 @@ func TestWorker(t *testing.T) {
 func createWorker(tmpDir string, clientset *fake.Clientset) *Worker {
 	return &Worker{
 		baseURL:        baseURL,
-		client:         clientset.ServicemeshV1alpha1(),
+		client:         clientset.MaistraV1alpha1(),
 		mut:            sync.Mutex{},
 		pullStrategy:   &fakestrategy.PullStrategy{},
 		serveDirectory: tmpDir,
diff --git a/pilot/cmd/pilot-discovery/app/cmd.go b/pilot/cmd/pilot-discovery/app/cmd.go
index d029591289..3b81d2d4b2 100644
--- a/pilot/cmd/pilot-discovery/app/cmd.go
+++ b/pilot/cmd/pilot-discovery/app/cmd.go
@@ -161,6 +161,8 @@ func addFlags(c *cobra.Command) {
 		true, "Whether support processing Ingress resources that use the new ingressClassName field in their spec")
 	c.PersistentFlags().StringVar(&extension.CacheCluster, "cacheCluster", extension.DefaultCacheCluster,
 		"Cluster pointing to Extension Cache component. This is used in proxies to retrieve WASM filters.")
+	c.PersistentFlags().StringVar(&serverArgs.ServerOptions.FederationAddr, "federationAddr", ":8188",
+		"Federation Service Discovery HTTP address")
 
 	// using address, so it can be configured as localhost:.. (possibly UDS in future)
 	c.PersistentFlags().StringVar(&serverArgs.ServerOptions.HTTPAddr, "httpAddr", ":8080",
diff --git a/pilot/pkg/bootstrap/configcontroller.go b/pilot/pkg/bootstrap/configcontroller.go
index ee8f06fd20..0164cd117a 100644
--- a/pilot/pkg/bootstrap/configcontroller.go
+++ b/pilot/pkg/bootstrap/configcontroller.go
@@ -133,6 +133,14 @@ func (s *Server) initConfigController(args *PilotArgs) error {
 		})
 	}
 
+	if features.EnableFederation {
+		if s.federation == nil {
+			log.Errorf("Federation support disabled: federation not initialized")
+		} else {
+			s.ConfigStores = append(s.ConfigStores, s.federation.ConfigStore())
+		}
+	}
+
 	// Wrap the config controller with a cache.
 	aggregateConfigController, err := configaggregate.MakeCache(s.ConfigStores)
 	if err != nil {
diff --git a/pilot/pkg/bootstrap/options.go b/pilot/pkg/bootstrap/options.go
index ed24340810..07ae5daf48 100644
--- a/pilot/pkg/bootstrap/options.go
+++ b/pilot/pkg/bootstrap/options.go
@@ -57,6 +57,7 @@ type PilotArgs struct {
 	Namespace          string
 	Revision           string
 	MeshConfigFile     string
+	Network            string
 	NetworksConfigFile string
 	RegistryOptions    RegistryOptions
 	CtrlZOptions       *ctrlz.Options
@@ -95,6 +96,10 @@ type DiscoveryServerOptions struct {
 	// The listening address for secured gRPC. If the port in the address is empty or "0" (as in "127.0.0.1:" or "[::1]:0")
 	// a port number is automatically chosen.
 	SecureGRPCAddr string
+
+	// The listening address for federation service discovery. If the port in the address is empty or "0" (as in "127.0.0.1:" or "[::1]:0")
+	// a port number is automatically chosen.
+	FederationAddr string
 }
 
 type InjectionOptions struct {
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index b33111f907..9842570a59 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -71,6 +71,8 @@
 	"istio.io/istio/pkg/kube/multicluster"
 	"istio.io/istio/pkg/security"
 	"istio.io/istio/pkg/servicemesh/controller/extension"
+	"istio.io/istio/pkg/servicemesh/federation"
+	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/spiffe"
 	"istio.io/istio/security/pkg/k8s/chiron"
 	"istio.io/istio/security/pkg/pki/ca"
@@ -131,6 +133,8 @@ type Server struct {
 	httpsServer      *http.Server // webhooks HTTPS Server.
 	httpsReadyClient *http.Client
 
+	federation *federation.Federation
+
 	grpcServer        *grpc.Server
 	grpcAddress       string
 	secureGrpcServer  *grpc.Server
@@ -268,10 +272,41 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 		return nil, err
 	}
 
+	// federation support must be initialized before config and service controllers
+	if features.EnableFederation {
+		if s.kubeClient == nil {
+			log.Errorf("could not initialize federation discovery server: kubeClient is nil")
+		} else {
+			var err error
+			s.federation, err = federation.New(federation.Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient:   s.kubeClient,
+					ResyncPeriod: args.RegistryOptions.KubeOptions.ResyncPeriod,
+					Namespace:    args.RegistryOptions.ClusterRegistriesNamespace,
+				},
+				BindAddress:       args.ServerOptions.FederationAddr,
+				Env:               s.environment,
+				Network:           features.NetworkName,
+				XDSUpdater:        s.XDSServer,
+				ServiceController: s.ServiceController(),
+			})
+			if err != nil {
+				return nil, fmt.Errorf("error initializing federation: %v", err)
+			}
+		}
+	}
+
 	if err := s.initControllers(args); err != nil {
 		return nil, err
 	}
 
+	if s.federation != nil {
+		s.addStartFunc(func(stop <-chan struct{}) error {
+			go s.federation.StartControllers(stop)
+			return nil
+		})
+	}
+
 	s.XDSServer.InitGenerators(e, args.Namespace)
 
 	// Initialize workloadTrustBundle after CA has been initialized
@@ -510,6 +545,10 @@ func (s *Server) Start(stop <-chan struct{}) error {
 		}()
 	}
 
+	if s.federation != nil {
+		go s.federation.StartServer(stop)
+	}
+
 	s.waitForShutdown(stop)
 
 	return nil
@@ -905,6 +944,9 @@ func (s *Server) cachesSynced() bool {
 	if !s.configController.HasSynced() {
 		return false
 	}
+	if s.federation != nil && !s.federation.ControllersSynced() {
+		return false
+	}
 	return true
 }
 
@@ -926,6 +968,10 @@ func (s *Server) initRegistryEventHandlers() {
 	}
 	s.ServiceController().AppendServiceHandler(serviceHandler)
 
+	if s.federation != nil {
+		s.federation.RegisterServiceHandlers(s.ServiceController())
+	}
+
 	if s.configController != nil {
 		configHandler := func(prev config.Config, curr config.Config, event model.Event) {
 			defer func() {
diff --git a/pilot/pkg/bootstrap/server_test.go b/pilot/pkg/bootstrap/server_test.go
index f185cb8ad6..12d62ee19a 100644
--- a/pilot/pkg/bootstrap/server_test.go
+++ b/pilot/pkg/bootstrap/server_test.go
@@ -27,6 +27,7 @@
 	"time"
 
 	. "github.com/onsi/gomega"
+
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/keycertbundle"
 	"istio.io/istio/pilot/pkg/server"
diff --git a/pilot/pkg/config/kube/crdclient/client.go b/pilot/pkg/config/kube/crdclient/client.go
index 89f8e86428..57e900fe97 100644
--- a/pilot/pkg/config/kube/crdclient/client.go
+++ b/pilot/pkg/config/kube/crdclient/client.go
@@ -138,7 +138,7 @@ func NewForSchemas(ctx context.Context, client kube.Client, revision, domainSuff
 		name := fmt.Sprintf("%s.%s", s.Resource().Plural(), s.Resource().Group())
 		schemasByCRDName[name] = s
 	}
-	var out = &Client{
+	out := &Client{
 		domainSuffix:     domainSuffix,
 		schemas:          schemas,
 		schemasByCRDName: schemasByCRDName,
diff --git a/pilot/pkg/config/kube/ingressv1/status.go b/pilot/pkg/config/kube/ingressv1/status.go
index 236278568a..b4ff3ab368 100644
--- a/pilot/pkg/config/kube/ingressv1/status.go
+++ b/pilot/pkg/config/kube/ingressv1/status.go
@@ -21,10 +21,6 @@
 	"strings"
 	"time"
 
-	"istio.io/istio/pkg/config/mesh"
-	kubelib "istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/queue"
-	"istio.io/pkg/log"
 	coreV1 "k8s.io/api/core/v1"
 	knetworking "k8s.io/api/networking/v1"
 	kerrors "k8s.io/apimachinery/pkg/api/errors"
@@ -34,6 +30,11 @@
 	"k8s.io/client-go/kubernetes"
 	listerv1 "k8s.io/client-go/listers/core/v1"
 	ingresslister "k8s.io/client-go/listers/networking/v1"
+
+	"istio.io/istio/pkg/config/mesh"
+	kubelib "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/queue"
+	"istio.io/pkg/log"
 )
 
 const (
diff --git a/pilot/pkg/config/kube/ior/ior_test.go b/pilot/pkg/config/kube/ior/ior_test.go
index de8f9036e0..470c9ae7cd 100644
--- a/pilot/pkg/config/kube/ior/ior_test.go
+++ b/pilot/pkg/config/kube/ior/ior_test.go
@@ -237,7 +237,6 @@ func TestCreate(t *testing.T) {
 					}
 				}
 			}
-
 		})
 	}
 }
@@ -458,7 +457,6 @@ func TestConcurrency(t *testing.T) {
 	if err := getError(errorChannel); err != nil {
 		t.Fatal(err)
 	}
-
 }
 
 func generateNamespaces(qty int) []string {
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 94fe95e26f..8bef0801fc 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -352,6 +352,9 @@
 	ExternalIstiod = env.RegisterBoolVar("EXTERNAL_ISTIOD", false,
 		"If this is set to true, one Istiod will control remote clusters including CA.").Get()
 
+	NetworkName = env.RegisterStringVar("NETWORK_NAME", "Kubernetes",
+		"Defines the network that this Istiod instance belongs to").Get()
+
 	EnableCAServer = env.RegisterBoolVar("ENABLE_CA_SERVER", true,
 		"If this is set to false, will not create CA server in istiod.").Get()
 
@@ -580,6 +583,8 @@
 
 	EnableIOR = env.RegisterBoolVar("ENABLE_IOR", false,
 		"Whether to enable IOR component, which provides integration between Istio Gateways and OpenShift Routes").Get()
+
+	EnableFederation = env.RegisterBoolVar("PILOT_ENABLE_FEDERATION", false, "").Get()
 )
 
 // UnsafeFeaturesEnabled returns true if any unsafe features are enabled.
diff --git a/pilot/pkg/serviceregistry/aggregate/controller.go b/pilot/pkg/serviceregistry/aggregate/controller.go
index ab7d4a7142..6a4d17319b 100644
--- a/pilot/pkg/serviceregistry/aggregate/controller.go
+++ b/pilot/pkg/serviceregistry/aggregate/controller.go
@@ -379,3 +379,10 @@ func (c *Controller) GetIstioServiceAccounts(svc *model.Service, ports []int) []
 	sort.Strings(result)
 	return result
 }
+
+func (c *Controller) Unwrap(registry serviceregistry.Instance) serviceregistry.Instance {
+	if registryEntry, ok := registry.(*registryEntry); ok {
+		return registryEntry.Instance
+	}
+	return registry
+}
diff --git a/pilot/pkg/serviceregistry/federation/controller.go b/pilot/pkg/serviceregistry/federation/controller.go
new file mode 100644
index 0000000000..011d80c504
--- /dev/null
+++ b/pilot/pkg/serviceregistry/federation/controller.go
@@ -0,0 +1,760 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package federation
+
+import (
+	"encoding/json"
+	"fmt"
+	"net"
+	"net/http"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/cenkalti/backoff"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry"
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/labels"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/pkg/log"
+)
+
+var (
+	_ model.ServiceDiscovery   = &Controller{}
+	_ model.Controller         = &Controller{}
+	_ serviceregistry.Instance = &Controller{}
+)
+
+var logger = log.RegisterScope("federation-registry", "federation-registry", 0)
+
+const (
+	federationPort = common.FederationPort
+)
+
+// Controller aggregates data across different registries and monitors for changes
+type Controller struct {
+	networkAddress string
+	egressService  string
+	egressName     string
+	discoveryURL   string
+	useDirectCalls bool
+	networkID      network.ID
+	namespace      string
+	clusterID      cluster.ID
+	resyncPeriod   time.Duration
+	backoffPolicy  *backoff.ExponentialBackOff
+
+	configStore model.ConfigStoreCache
+	xdsUpdater  model.XDSUpdater
+
+	storeLock     sync.RWMutex
+	imports       map[federationmodel.ServiceKey]*existingImport
+	serviceStore  []*model.Service
+	instanceStore map[host.Name][]*model.ServiceInstance
+	gatewayStore  []model.NetworkGateway
+
+	lastMessage *federationmodel.ServiceListMessage
+	stopped     int32
+}
+
+type existingImport struct {
+	*federationmodel.ServiceMessage
+	localName federationmodel.ServiceKey
+}
+
+type Options struct {
+	NetworkAddress string
+	EgressService  string
+	EgressName     string
+	UseDirectCalls bool
+	NetworkName    string
+	ClusterID      string
+	Namespace      string
+	ConfigStore    model.ConfigStoreCache
+	XDSUpdater     model.XDSUpdater
+	ResyncPeriod   time.Duration
+}
+
+// NewController creates a new Aggregate controller
+func NewController(opt Options) *Controller {
+	backoffPolicy := backoff.NewExponentialBackOff()
+	backoffPolicy.MaxElapsedTime = 0
+	return &Controller{
+		discoveryURL:   fmt.Sprintf("%s://%s:%d", common.DiscoveryScheme, opt.EgressService, common.DefaultDiscoveryPort),
+		egressService:  opt.EgressService,
+		egressName:     opt.EgressName,
+		networkAddress: opt.NetworkAddress,
+		useDirectCalls: opt.UseDirectCalls,
+		networkID:      network.ID(opt.NetworkName),
+		namespace:      opt.Namespace,
+		clusterID:      cluster.ID(opt.ClusterID),
+		imports:        map[federationmodel.ServiceKey]*existingImport{},
+		instanceStore:  map[host.Name][]*model.ServiceInstance{},
+		configStore:    opt.ConfigStore,
+		xdsUpdater:     opt.XDSUpdater,
+		resyncPeriod:   opt.ResyncPeriod,
+		backoffPolicy:  backoffPolicy,
+	}
+}
+
+func (c *Controller) Cluster() cluster.ID {
+	return c.clusterID
+}
+
+func (c *Controller) Provider() provider.ID {
+	return provider.Federation
+}
+
+func (c *Controller) NetworkAddress() string {
+	return c.networkAddress
+}
+
+func (c *Controller) pollServices() *federationmodel.ServiceListMessage {
+	url := c.discoveryURL + "/services/"
+	req, err := http.NewRequest(http.MethodGet, url, nil)
+	if err != nil {
+		logger.Errorf("Failed to create request: '%s': %s", url, err)
+		return nil
+	}
+	req.Header.Add("discovery-address", c.networkAddress)
+	resp, err := http.DefaultClient.Do(req)
+	if err != nil {
+		logger.Errorf("Failed to GET URL: '%s': %s", url, err)
+		return nil
+	}
+	if resp.StatusCode != http.StatusOK {
+		logger.Errorf("status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
+		return nil
+	}
+
+	respBytes := []byte{}
+	_, err = resp.Body.Read(respBytes)
+	if err != nil {
+		logger.Errorf("Failed to read response body from URL '%s': %s", url, err)
+		return nil
+	}
+
+	var serviceList federationmodel.ServiceListMessage
+	err = json.NewDecoder(resp.Body).Decode(&serviceList)
+	if err != nil {
+		logger.Errorf("Failed to unmarshal response bytes: %s", err)
+		return nil
+	}
+	return &serviceList
+}
+
+func (c *Controller) convertExportedService(s *federationmodel.ServiceMessage) (*model.Service, []*model.ServiceInstance) {
+	serviceVisibility := visibility.Private
+	if c.useDirectCalls {
+		serviceVisibility = visibility.Public
+	}
+	serviceName := fmt.Sprintf("%s.%s.remote", s.Name, s.Namespace)
+	return c.createService(s, serviceName, s.Hostname, c.clusterID, c.networkID, serviceVisibility, c.gatewayStore)
+}
+
+func (c *Controller) convertToLocalService(s *federationmodel.ServiceMessage,
+	importedName federationmodel.ServiceKey) (*model.Service, []*model.ServiceInstance) {
+	serviceName := fmt.Sprintf("%s.%s.local", s.Name, s.Namespace)
+	egressAddrs, err := c.getIPAddrsForHostOrIP(c.egressService)
+	gateways := make([]model.NetworkGateway, len(egressAddrs))
+	if err == nil {
+		for index, addr := range egressAddrs {
+			gateways[index] = model.NetworkGateway{
+				Addr: addr,
+				Port: federationPort,
+			}
+		}
+	} else {
+		logger.Errorf("could not get address for egress gateway: %s", err)
+	}
+	network := network.ID("")
+	// XXX: make this configurable
+	serviceVisibility := visibility.Public
+	return c.createService(s, serviceName, importedName.Hostname, c.clusterID, network, serviceVisibility, gateways)
+}
+
+func (c *Controller) createService(s *federationmodel.ServiceMessage, serviceName, hostname string, clusterID cluster.ID, network network.ID,
+	serviceVisibility visibility.Instance, networkGateways []model.NetworkGateway) (*model.Service, []*model.ServiceInstance) {
+	instances := []*model.ServiceInstance{}
+	svc := &model.Service{
+		Attributes: model.ServiceAttributes{
+			ServiceRegistry: provider.Federation,
+			Name:            serviceName, // simple name in the form name.namespace of the exported service
+			Namespace:       c.namespace, // the federation namespace
+			ExportTo: map[visibility.Instance]bool{
+				serviceVisibility: true,
+			},
+		},
+		Resolution:      model.ClientSideLB,
+		DefaultAddress:  constants.UnspecifiedIP,
+		Hostname:        host.Name(hostname),
+		Ports:           model.PortList{},
+		ServiceAccounts: []string{},
+	}
+	for _, port := range s.ServicePorts {
+		svc.Ports = append(svc.Ports, &model.Port{
+			Name:     port.Name,
+			Port:     port.Port,
+			Protocol: protocol.Instance(port.Protocol),
+		})
+	}
+
+	for _, port := range svc.Ports {
+		for _, networkGateway := range networkGateways {
+			instances = append(instances, &model.ServiceInstance{
+				Service:     svc,
+				ServicePort: port,
+				Endpoint: &model.IstioEndpoint{
+					Address:      networkGateway.Addr,
+					EndpointPort: networkGateway.Port,
+					Network:      network,
+					Locality: model.Locality{
+						ClusterID: clusterID,
+					},
+					ServicePortName: port.Name,
+					TLSMode:         model.IstioMutualTLSModeLabel,
+				},
+			})
+		}
+	}
+	return svc, instances
+}
+
+func (c *Controller) gatewayForNetworkAddress() []model.NetworkGateway {
+	var gateways []model.NetworkGateway
+	addrs, err := c.getIPAddrsForHostOrIP(c.networkAddress)
+	if err != nil {
+		logger.Errorf("error resolving IP addr for federation network %s: %v", c.networkAddress, err)
+	} else {
+		logger.Debugf("adding gateway %s endpoints for cluster %s", c.networkAddress, c.clusterID)
+		for _, ip := range addrs {
+			logger.Debugf("adding gateway %s endpoint %s for cluster %s", c.networkAddress, ip, c.clusterID)
+			gateways = append(gateways, model.NetworkGateway{
+				Addr: ip,
+				Port: federationPort,
+			})
+		}
+	}
+	return gateways
+}
+
+func (c *Controller) getIPAddrsForHostOrIP(host string) ([]string, error) {
+	gwIP := net.ParseIP(host)
+	if gwIP != nil {
+		return []string{gwIP.String()}, nil
+	}
+	return net.LookupHost(host)
+}
+
+func (c *Controller) getImportNameForService(name federationmodel.ServiceKey) federationmodel.ServiceKey {
+	// XXX: integrate ServiceImports CRD functionality here
+	// for now, hardcoding values for all services
+	return federationmodel.ServiceKey{
+		Name:      fmt.Sprintf("%s.%s", name.Name, name.Namespace),
+		Namespace: c.namespace,
+		Hostname:  fmt.Sprintf("%s.%s.svc.%s.local", name.Name, name.Namespace, c.clusterID),
+	}
+}
+
+func (c *Controller) convertServices(serviceList *federationmodel.ServiceListMessage) {
+	c.gatewayStore = c.gatewayForNetworkAddress()
+	for _, gateway := range serviceList.NetworkGatewayEndpoints {
+		c.gatewayStore = append(c.gatewayStore, model.NetworkGateway{
+			Addr: gateway.Hostname,
+			Port: uint32(gateway.Port),
+		})
+	}
+
+	oldImports := c.imports
+	c.imports = map[federationmodel.ServiceKey]*existingImport{}
+	allUpdatedConfigs := map[model.ConfigKey]struct{}{}
+	for _, s := range serviceList.Services {
+		var updatedConfigs map[model.ConfigKey]struct{}
+		var err error
+		importName := c.getImportNameForService(s.ServiceKey)
+		if existing, update := oldImports[s.ServiceKey]; update {
+			if updatedConfigs, err = c.updateService(s, existing, importName); err != nil {
+				// XXX: just log for now, we can't really recover
+				logger.Errorf("error updating configuration for federated service %+v from mesh %s: %s", s.ServiceKey, c.clusterID, err)
+			}
+		} else if importName.Hostname != "" {
+			if updatedConfigs, err = c.addService(s, importName); err != nil {
+				// XXX: just log for now, we can't really recover
+				logger.Errorf("error adding configuration for federated service %+v from mesh %s: %s", s.ServiceKey, c.clusterID, err)
+			}
+		}
+		for key, value := range updatedConfigs {
+			allUpdatedConfigs[key] = value
+		}
+	}
+	for key, existing := range oldImports {
+		if _, exists := c.imports[key]; !exists {
+			updatedConfigs := c.deleteService(&federationmodel.ServiceMessage{ServiceKey: key}, existing)
+			for key, value := range updatedConfigs {
+				allUpdatedConfigs[key] = value
+			}
+		}
+	}
+	if len(allUpdatedConfigs) > 0 {
+		logger.Debugf("pushing XDS config for services: %+v", allUpdatedConfigs)
+		c.xdsUpdater.ConfigUpdate(&model.PushRequest{
+			Full:           true,
+			ConfigsUpdated: allUpdatedConfigs,
+		})
+	}
+}
+
+func autoAllocateIPs(services []*model.Service) []*model.Service {
+	// i is everything from 240.241.0.(j) to 240.241.255.(j)
+	// j is everything from 240.241.(i).1 to 240.241.(i).254
+	// we can capture this in one integer variable.
+	// given X, we can compute i by X/255, and j is X%255
+	// To avoid allocating 240.241.(i).255, if X % 255 is 0, increment X.
+	// For example, when X=510, the resulting IP would be 240.241.2.0 (invalid)
+	// So we bump X to 511, so that the resulting IP is 240.241.2.1
+	maxIPs := 255 * 255 // are we going to exceeed this limit by processing 64K services?
+	x := 0
+	for _, svc := range services {
+		// we can allocate IPs only if
+		// 1. the service has resolution set to static/dns. We cannot allocate
+		//   for NONE because we will not know the original DST IP that the application requested.
+		// 2. the address is not set (0.0.0.0)
+		// 3. the hostname is not a wildcard
+		if svc.DefaultAddress == constants.UnspecifiedIP && !svc.Hostname.IsWildCarded() &&
+			svc.Resolution != model.Passthrough {
+			x++
+			if x%255 == 0 {
+				x++
+			}
+			if x >= maxIPs {
+				logger.Errorf("out of IPs to allocate for service entries")
+				return services
+			}
+			thirdOctet := x / 255
+			fourthOctet := x % 255
+			svc.AutoAllocatedAddress = fmt.Sprintf("240.241.%d.%d", thirdOctet, fourthOctet)
+		}
+	}
+	return services
+}
+
+// Services lists services
+func (c *Controller) Services() ([]*model.Service, error) {
+	c.storeLock.RLock()
+	defer c.storeLock.RUnlock()
+	return autoAllocateIPs(c.serviceStore), nil
+}
+
+// GetService retrieves a service by hostname if exists
+func (c *Controller) GetService(hostname host.Name) *model.Service {
+	var out *model.Service
+	return out
+}
+
+// NetworkGateways merges the service-based cross-network gateways from each registry.
+func (c *Controller) NetworkGateways() []model.NetworkGateway {
+	c.storeLock.RLock()
+	defer c.storeLock.RUnlock()
+	return c.gatewayStore
+}
+
+func (c *Controller) MCSServices() []model.MCSServiceInfo {
+	return nil // TODO: Implement
+}
+
+// InstancesByPort retrieves instances for a service on a given port that match
+// any of the supplied labels. All instances match an empty label list.
+func (c *Controller) InstancesByPort(svc *model.Service, port int, labels labels.Collection) []*model.ServiceInstance {
+	instances := []*model.ServiceInstance{}
+	c.storeLock.RLock()
+	defer c.storeLock.RUnlock()
+	for _, instanceList := range c.instanceStore {
+		for _, instance := range instanceList {
+			if instance.Service == svc && instance.ServicePort.Port == port {
+				instances = append(instances, instance.DeepCopy())
+			}
+		}
+	}
+	return instances
+}
+
+// GetProxyServiceInstances lists service instances co-located with a given proxy
+func (c *Controller) GetProxyServiceInstances(node *model.Proxy) []*model.ServiceInstance {
+	return make([]*model.ServiceInstance, 0)
+}
+
+func (c *Controller) GetProxyWorkloadLabels(proxy *model.Proxy) labels.Collection {
+	return labels.Collection{}
+}
+
+// Run starts all the controllers
+func (c *Controller) Run(stop <-chan struct{}) {
+	eventCh := make(chan *federationmodel.WatchEvent)
+	refreshTicker := time.NewTicker(c.resyncPeriod)
+	defer refreshTicker.Stop()
+	c.resync()
+	go func() {
+		for !c.hasStopped() {
+			logger.Info("starting watch")
+			err := c.watch(eventCh, stop)
+			if err != nil {
+				logger.Errorf("watch failed: %s", err)
+				time.Sleep(c.backoffPolicy.NextBackOff())
+			} else {
+				return
+			}
+		}
+	}()
+	for {
+		select {
+		case <-stop:
+			logger.Info("Federation Controller terminated")
+			c.stop()
+			return
+		case e := <-eventCh:
+			logger.Debugf("watch event received: %s service %s", e.Action, e.Service.Name)
+			c.handleEvent(e)
+		case <-refreshTicker.C:
+			logger.Debugf("performing full resync for cluster %s", c.clusterID)
+			_ = c.resync()
+		}
+	}
+}
+
+func (c *Controller) stop() {
+	atomic.StoreInt32(&c.stopped, 1)
+}
+
+func (c *Controller) hasStopped() bool {
+	return atomic.LoadInt32(&c.stopped) != 0
+}
+
+func (c *Controller) handleEvent(e *federationmodel.WatchEvent) {
+	if e.Service == nil || c.lastMessage == nil {
+		checksum := c.resync()
+		if checksum != e.Checksum {
+			// this shouldn't happen
+			logger.Error("checksum mismatch after resync")
+		}
+		return
+	}
+
+	unlockIt := true
+	c.storeLock.Lock()
+	defer func() {
+		if unlockIt {
+			c.storeLock.Unlock()
+		}
+	}()
+	// verify we're up to date
+	lastReceivedMessage := *c.lastMessage
+	switch e.Action {
+	case federationmodel.ActionAdd:
+		lastReceivedMessage.Services = append(c.lastMessage.Services, e.Service)
+	case federationmodel.ActionUpdate:
+		for i, s := range lastReceivedMessage.Services {
+			if s.Name == e.Service.Name {
+				lastReceivedMessage.Services[i] = e.Service
+				break
+			}
+		}
+	case federationmodel.ActionDelete:
+		for i, s := range lastReceivedMessage.Services {
+			if s.Name == e.Service.Name {
+				lastReceivedMessage.Services[i] = c.lastMessage.Services[len(c.lastMessage.Services)-1]
+				lastReceivedMessage.Services = c.lastMessage.Services[:len(c.lastMessage.Services)-1]
+				break
+			}
+		}
+	default:
+		logger.Errorf("unknown Action from federation watch: %s", e.Action)
+		return
+	}
+
+	lastReceivedMessage.Checksum = lastReceivedMessage.GenerateChecksum()
+	if lastReceivedMessage.Checksum != e.Checksum {
+		logger.Warnf("checksums don't match. resyncing")
+		unlockIt = false
+		c.storeLock.Unlock()
+		c.resync()
+		return
+	}
+
+	c.lastMessage = &lastReceivedMessage
+
+	importedName := c.getImportNameForService(e.Service.ServiceKey)
+	existing := c.imports[e.Service.ServiceKey]
+	var updatedConfigs map[model.ConfigKey]struct{}
+	var err error
+	switch e.Action {
+	case federationmodel.ActionAdd:
+		if importedName.Hostname != "" {
+			if updatedConfigs, err = c.addService(e.Service, importedName); err != nil {
+				// XXX: just log for now, we can't really recover
+				logger.Errorf("error adding configuration for federated service %+v from mesh %s: %s", e.Service.ServiceKey, c.clusterID, err)
+			}
+		}
+	case federationmodel.ActionUpdate:
+		if importedName.Hostname == "" {
+			if existing != nil {
+				updatedConfigs = c.deleteService(e.Service, existing)
+			}
+		} else {
+			if updatedConfigs, err = c.updateService(e.Service, existing, importedName); err != nil {
+				// XXX: just log for now, we can't really recover
+				logger.Errorf("error updating configuration for federated service %+v from mesh %s: %s", e.Service.ServiceKey, c.clusterID, err)
+			}
+		}
+	case federationmodel.ActionDelete:
+		updatedConfigs = c.deleteService(e.Service, existing)
+	}
+	if len(updatedConfigs) > 0 {
+		logger.Debugf("pushing XDS config for services: %+v", updatedConfigs)
+		c.xdsUpdater.ConfigUpdate(&model.PushRequest{
+			Full:           true,
+			ConfigsUpdated: updatedConfigs,
+		})
+	}
+}
+
+// store has to be Lock()ed
+func (c *Controller) updateXDS(hostname, namespace string, instances []*model.ServiceInstance, event model.Event) {
+	endpoints := []*model.IstioEndpoint{}
+	for _, instance := range instances {
+		endpoints = append(endpoints, instance.Endpoint)
+	}
+	c.xdsUpdater.SvcUpdate(model.ShardKeyFromRegistry(c), hostname, namespace, event)
+	c.xdsUpdater.EDSCacheUpdate(model.ShardKeyFromRegistry(c), hostname, namespace, endpoints)
+}
+
+// store has to be Lock()ed
+func (c *Controller) addService(service *federationmodel.ServiceMessage, importName federationmodel.ServiceKey) (map[model.ConfigKey]struct{}, error) {
+	logger.Debugf("adding exported service %+v, known locally as %+v", service.ServiceKey, importName)
+	updatedConfigs := map[model.ConfigKey]struct{}{}
+	exportedService, exportedInstances := c.convertExportedService(service)
+	localService, localInstances := c.convertToLocalService(service, importName)
+
+	if err := c.createRoutingResources(service.ServiceKey, importName); err != nil {
+		return nil, err
+	}
+
+	c.imports[service.ServiceKey] = &existingImport{ServiceMessage: service, localName: importName}
+
+	c.addServiceToStore(exportedService, exportedInstances)
+	updatedConfigs[model.ConfigKey{
+		Kind:      gvk.ServiceEntry,
+		Name:      string(exportedService.Hostname),
+		Namespace: c.namespace,
+	}] = struct{}{}
+
+	c.addServiceToStore(localService, localInstances)
+	updatedConfigs[model.ConfigKey{
+		Kind:      gvk.ServiceEntry,
+		Name:      string(localService.Hostname),
+		Namespace: c.namespace,
+	}] = struct{}{}
+
+	return updatedConfigs, nil
+}
+
+// store has to be Lock()ed
+func (c *Controller) updateService(service *federationmodel.ServiceMessage, existing *existingImport,
+	importName federationmodel.ServiceKey) (map[model.ConfigKey]struct{}, error) {
+	logger.Debugf("updating exported service %+v, known locally as %+v", service.ServiceKey, importName)
+	updatedConfigs := map[model.ConfigKey]struct{}{}
+	exportedService, exportedInstances := c.convertExportedService(service)
+	localService, localInstances := c.convertToLocalService(service, importName)
+
+	if existing != nil && importName.Hostname != existing.localName.Hostname {
+		if err := c.createRoutingResources(service.ServiceKey, importName); err != nil {
+			return nil, err
+		}
+		// TODO: optimize service and instance updates
+	}
+
+	// TODO: be smart and see if anything changed, so we don't push unnecessarily
+
+	c.imports[service.ServiceKey] = &existingImport{ServiceMessage: service, localName: importName}
+
+	c.updateServiceInStore(exportedService, exportedInstances)
+	updatedConfigs[model.ConfigKey{
+		Kind:      gvk.ServiceEntry,
+		Name:      string(exportedService.Hostname),
+		Namespace: c.namespace,
+	}] = struct{}{}
+
+	c.updateServiceInStore(localService, localInstances)
+	updatedConfigs[model.ConfigKey{
+		Kind:      gvk.ServiceEntry,
+		Name:      string(localService.Hostname),
+		Namespace: c.namespace,
+	}] = struct{}{}
+
+	return updatedConfigs, nil
+}
+
+// store has to be Lock()ed
+func (c *Controller) deleteService(service *federationmodel.ServiceMessage, existing *existingImport) map[model.ConfigKey]struct{} {
+	if existing != nil {
+		logger.Debugf("deleting exported service %+v, known locally as %+v", service.ServiceKey, existing.localName)
+	} else {
+		logger.Debugf("deleting exported service %+v, with unknown locally name", service.ServiceKey)
+	}
+	_ = c.deleteRoutingResources(service.ServiceKey)
+	updatedConfigs := map[model.ConfigKey]struct{}{}
+
+	delete(c.imports, service.ServiceKey)
+
+	c.removeServiceFromStore(service.ServiceKey)
+	updatedConfigs[model.ConfigKey{
+		Kind:      gvk.ServiceEntry,
+		Name:      service.Hostname,
+		Namespace: c.namespace,
+	}] = struct{}{}
+
+	if existing != nil {
+		c.removeServiceFromStore(existing.localName)
+		updatedConfigs[model.ConfigKey{
+			Kind:      gvk.ServiceEntry,
+			Name:      existing.localName.Hostname,
+			Namespace: c.namespace,
+		}] = struct{}{}
+	}
+
+	return updatedConfigs
+}
+
+func (c *Controller) addServiceToStore(service *model.Service, instances []*model.ServiceInstance) {
+	c.serviceStore = append(c.serviceStore, service)
+	c.instanceStore[service.Hostname] = instances
+	c.updateXDS(string(service.Hostname), service.Attributes.Namespace, instances, model.EventAdd)
+}
+
+func (c *Controller) updateServiceInStore(service *model.Service, instances []*model.ServiceInstance) {
+	eventType := model.EventUpdate
+	found := false
+	for i, s := range c.serviceStore {
+		if s.Hostname == service.Hostname {
+			c.serviceStore[i] = service
+			found = true
+			break
+		}
+	}
+	if !found {
+		logger.Warnf("trying to update unknown service %s, adding it to the registry", service.Hostname)
+		c.serviceStore = append(c.serviceStore, service)
+		eventType = model.EventAdd
+	}
+	c.instanceStore[service.Hostname] = instances
+	c.updateXDS(string(service.Hostname), service.Attributes.Namespace, instances, eventType)
+}
+
+func (c *Controller) removeServiceFromStore(service federationmodel.ServiceKey) {
+	for i, s := range c.serviceStore {
+		if s.Hostname == host.Name(service.Hostname) {
+			c.serviceStore[i] = c.serviceStore[len(c.serviceStore)-1]
+			c.serviceStore = c.serviceStore[:len(c.serviceStore)-1]
+			break
+		}
+	}
+	delete(c.instanceStore, host.Name(service.Hostname))
+	c.xdsUpdater.SvcUpdate(model.ShardKeyFromRegistry(c), service.Hostname, c.namespace, model.EventDelete)
+	c.xdsUpdater.EDSCacheUpdate(model.ShardKeyFromRegistry(c), service.Hostname, c.namespace, nil)
+}
+
+func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-chan struct{}) error {
+	url := c.discoveryURL + "/watch"
+	req, err := http.NewRequest(http.MethodGet, url, nil)
+	if err != nil {
+		logger.Errorf("Failed to create request: '%s': %s", url, err)
+		return nil
+	}
+	req.Header.Add("discovery-address", c.networkAddress)
+	resp, err := http.DefaultClient.Do(req)
+	if err != nil {
+		return err
+	}
+	if resp.StatusCode != http.StatusOK {
+		return fmt.Errorf("status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
+	}
+
+	// connection was established successfully. reset backoffPolicy
+	c.backoffPolicy.Reset()
+
+	dec := json.NewDecoder(resp.Body)
+	for {
+		select {
+		case <-stopCh:
+			return nil
+		default:
+		}
+		var e federationmodel.WatchEvent
+		err := dec.Decode(&e)
+		if err != nil {
+			return err
+		}
+		eventCh <- &e
+	}
+}
+
+func (c *Controller) resync() uint64 {
+	c.storeLock.Lock()
+	defer c.storeLock.Unlock()
+	logger.Debugf("performing full resync")
+	svcList := c.pollServices()
+	if svcList != nil {
+		c.convertServices(svcList)
+		return svcList.Checksum
+	}
+	return 0
+}
+
+// HasSynced always returns true so not to stall istiod on a broken federation connection
+func (c *Controller) HasSynced() bool {
+	return true
+}
+
+// AppendServiceHandler implements a service catalog operation
+func (c *Controller) AppendServiceHandler(f func(*model.Service, model.Event)) {
+	// TODO
+}
+
+func (c *Controller) AppendWorkloadHandler(f func(*model.WorkloadInstance, model.Event)) {
+	// TODO
+}
+
+// GetIstioServiceAccounts implements model.ServiceAccounts operation.
+// The returned list contains all SPIFFE based identities that backs the service.
+// This method also expand the results from different registries based on the mesh config trust domain aliases.
+// To retain such trust domain expansion behavior, the xDS server implementation should wrap any (even if single)
+// service registry by this aggreated one.
+// For example,
+// - { "spiffe://cluster.local/bar@iam.gserviceaccount.com"}; when annotation is used on corresponding workloads.
+// - { "spiffe://cluster.local/ns/default/sa/foo" }; normal kubernetes cases
+// - { "spiffe://cluster.local/ns/default/sa/foo", "spiffe://trust-domain-alias/ns/default/sa/foo" };
+//   if the trust domain alias is configured.
+func (c *Controller) GetIstioServiceAccounts(svc *model.Service, ports []int) []string {
+	return []string{}
+}
diff --git a/pilot/pkg/serviceregistry/federation/routing.go b/pilot/pkg/serviceregistry/federation/routing.go
new file mode 100644
index 0000000000..2b7350b865
--- /dev/null
+++ b/pilot/pkg/serviceregistry/federation/routing.go
@@ -0,0 +1,196 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package federation
+
+import (
+	"fmt"
+	"strings"
+	"time"
+
+	"github.com/pkg/errors"
+
+	rawnetworking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+)
+
+// ensure our config gets ignored if the user wants to change routing for
+// exported services
+var armageddonTime = time.Unix(1<<62-1, 0)
+
+func createResourceName(mesh cluster.ID, source federationmodel.ServiceKey) string {
+	return fmt.Sprintf("federation-imports-%s-%s-%s", mesh, source.Name, source.Namespace)
+}
+
+func (c *Controller) deleteRoutingResources(remote federationmodel.ServiceKey) error {
+	resourceName := createResourceName(c.clusterID, remote)
+	// Delete() is always successful
+	_ = c.configStore.Delete(gvk.Gateway, resourceName, c.namespace, nil)
+	return c.configStore.Delete(gvk.VirtualService, resourceName, c.namespace, nil)
+}
+
+func (c *Controller) createRoutingResources(remote, local federationmodel.ServiceKey) error {
+	resourceName := createResourceName(c.clusterID, remote)
+	gateway := c.gatewayForImport(remote, local)
+	if rawGateway := c.configStore.Get(gvk.Gateway, gateway.Name, c.namespace); rawGateway == nil {
+		if gateway != nil {
+			if _, err := c.configStore.Create(*gateway); err != nil {
+				return errors.Wrapf(err, "error creating Gateway resource")
+			}
+		}
+	} else if gateway == nil {
+		_ = c.configStore.Delete(gvk.Gateway, resourceName, c.namespace, nil)
+	} else {
+		existingGateway := rawGateway.Spec.(*rawnetworking.Gateway)
+		if len(existingGateway.Servers) > 0 && len(existingGateway.Servers[0].Hosts) > 0 && existingGateway.Servers[0].Hosts[0] != local.Hostname {
+			// overwrite whatever's there
+			logger.Warnf("Gateway resource %s already exists for exported service (%s => %s).  It will be overwritten.", gateway.Name, remote.Hostname, local.Hostname)
+			if _, err := c.configStore.Update(*gateway); err != nil {
+				return errors.Wrapf(err, "error updating Gateway resource")
+			}
+		}
+	}
+	vs := c.virtualServiceForImport(remote, local)
+	if rawVS := c.configStore.Get(gvk.VirtualService, vs.Name, c.namespace); rawVS == nil {
+		if _, err := c.configStore.Create(*vs); err != nil {
+			return errors.Wrapf(err, "error creating VirtualService resource")
+		}
+	} else {
+		existingVS := rawVS.Spec.(*rawnetworking.VirtualService)
+		if (len(existingVS.Hosts) > 0 && !strings.HasSuffix(existingVS.Hosts[0], "/"+local.Hostname)) ||
+			(len(existingVS.ExportTo) > 0 && existingVS.ExportTo[0] != vs.Spec.(*rawnetworking.VirtualService).ExportTo[0]) {
+			// overwrite whatever's there
+			logger.Warnf("VirtualService resource %s already exists for exported service (%s => %s).  It will be overwritten.", vs.Name, remote.Hostname, local.Hostname)
+			if _, err := c.configStore.Update(*vs); err != nil {
+				return errors.Wrapf(err, "error updating VirtualService resource")
+			}
+		}
+	}
+	return nil
+}
+
+func (c *Controller) gatewayForImport(remote, local federationmodel.ServiceKey) *config.Config {
+	resourceName := createResourceName(c.clusterID, remote)
+	mode := rawnetworking.ServerTLSSettings_ISTIO_MUTUAL
+	if c.useDirectCalls {
+		// no gateway when directly accessing services
+		return nil
+	}
+	gateway := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: gvk.Gateway,
+			Name:             resourceName,
+			Namespace:        c.namespace,
+		},
+		Spec: &rawnetworking.Gateway{
+			Selector: map[string]string{
+				"service.istio.io/canonical-name": c.egressName,
+			},
+			Servers: []*rawnetworking.Server{
+				{
+					Name: resourceName,
+					Hosts: []string{
+						local.Hostname,
+						"*." + local.Hostname,
+					},
+					Port: &rawnetworking.Port{
+						Name:     "tls-federation",
+						Number:   uint32(common.FederationPort),
+						Protocol: "TLS",
+					},
+					Tls: &rawnetworking.ServerTLSSettings{
+						Mode: mode,
+					},
+				},
+			},
+		},
+	}
+	return gateway
+}
+
+func (c *Controller) virtualServiceForImport(remote, local federationmodel.ServiceKey) *config.Config {
+	// VirtualService used to route inbound requests to the service.
+	name := createResourceName(c.clusterID, remote)
+	egressGatewayName := fmt.Sprintf("%s/%s", c.namespace, name)
+	exportTo := "."
+	creationTime := time.Now()
+	if c.useDirectCalls {
+		exportTo = "*"
+		creationTime = armageddonTime
+	}
+	vs := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind:  gvk.VirtualService,
+			Name:              name,
+			Namespace:         c.namespace,
+			CreationTimestamp: creationTime,
+		},
+		Spec: &rawnetworking.VirtualService{
+			Hosts: []string{
+				local.Hostname,
+				"*." + local.Hostname,
+			},
+			Gateways: []string{
+				egressGatewayName,
+			},
+			ExportTo: []string{
+				exportTo,
+			},
+			Tcp: []*rawnetworking.TCPRoute{
+				{
+					Match: []*rawnetworking.L4MatchAttributes{
+						{
+							Gateways: []string{
+								egressGatewayName,
+							},
+						},
+					},
+					Route: []*rawnetworking.RouteDestination{
+						{
+							Destination: &rawnetworking.Destination{
+								Host: remote.Hostname,
+							},
+						},
+					},
+				},
+			},
+			// Http: []*rawnetworking.HTTPRoute{
+			// 	{
+			// 		Match: []*rawnetworking.HTTPMatchRequest{
+			// 			{
+			// 				Gateways: []string{
+			// 					egressGatewayName,
+			// 				},
+			// 			},
+			// 		},
+			// 		Rewrite: &rawnetworking.HTTPRewrite{
+			// 			Authority: remote.Hostname,
+			// 		},
+			// 		Route: []*rawnetworking.HTTPRouteDestination{
+			// 			{
+			// 				Destination: &rawnetworking.Destination{
+			// 					Host: remote.Hostname,
+			// 				},
+			// 			},
+			// 		},
+			// 	},
+			// },
+		},
+	}
+	return vs
+}
diff --git a/pilot/pkg/serviceregistry/provider/providers.go b/pilot/pkg/serviceregistry/provider/providers.go
index 7c38b85d4a..db23e29c71 100644
--- a/pilot/pkg/serviceregistry/provider/providers.go
+++ b/pilot/pkg/serviceregistry/provider/providers.go
@@ -22,6 +22,8 @@
 	Mock ID = "Mock"
 	// Kubernetes is a service registry backed by k8s API server
 	Kubernetes ID = "Kubernetes"
+	// Federation is a service registry backed by Federation
+	Federation ID = "Federation"
 	// External is a service registry for externally provided ServiceEntries
 	External ID = "External"
 )
diff --git a/pkg/kube/controller/controller.go b/pkg/kube/controller/controller.go
new file mode 100644
index 0000000000..234fbb80db
--- /dev/null
+++ b/pkg/kube/controller/controller.go
@@ -0,0 +1,147 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package controller
+
+import (
+	"time"
+
+	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
+	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/client-go/tools/cache"
+	"k8s.io/client-go/util/workqueue"
+
+	"istio.io/pkg/log"
+)
+
+const (
+	maxRetries = 5
+)
+
+type (
+	ReconcilerFunc func(name string) error
+	Options        struct {
+		ResyncPeriod time.Duration
+		Informer     cache.SharedIndexInformer
+		Reconciler   ReconcilerFunc
+		Logger       *log.Scope
+	}
+)
+
+type Controller struct {
+	informer     cache.SharedIndexInformer
+	queue        workqueue.RateLimitingInterface
+	resyncPeriod time.Duration
+	logger       *log.Scope
+	reconcile    ReconcilerFunc
+}
+
+// NewController creates a new Aggregate controller
+func NewController(opt Options) *Controller {
+	queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())
+
+	if opt.Logger == nil {
+		opt.Logger = log.RegisterScope("kube-controller", "kube-controller", 0)
+	}
+	if opt.ResyncPeriod == 0 {
+		opt.ResyncPeriod = 60 * time.Second
+	}
+	controller := &Controller{
+		informer:     opt.Informer,
+		queue:        queue,
+		logger:       opt.Logger,
+		resyncPeriod: opt.ResyncPeriod,
+		reconcile:    opt.Reconciler,
+	}
+
+	controller.informer.AddEventHandler(
+		cache.ResourceEventHandlerFuncs{
+			AddFunc: func(obj interface{}) {
+				key, err := cache.MetaNamespaceKeyFunc(obj)
+				controller.logger.Debugf("Processing add: %s", key)
+				if err == nil {
+					queue.Add(key)
+				} else {
+					controller.logger.Errorf("error retrieving key for object %T", obj)
+				}
+			},
+			UpdateFunc: func(oldObj, newObj interface{}) {
+				key, err := cache.MetaNamespaceKeyFunc(newObj)
+				controller.logger.Debugf("Processing update: %s", key)
+				if err == nil {
+					queue.Add(key)
+				} else {
+					controller.logger.Errorf("error retrieving key for object %T", newObj)
+				}
+			},
+			DeleteFunc: func(obj interface{}) {
+				key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
+				controller.logger.Debugf("Processing delete: %s", key)
+				if err == nil {
+					queue.Add(key)
+				} else {
+					controller.logger.Errorf("error retrieving key for object %T", obj)
+				}
+			},
+		})
+
+	return controller
+}
+
+func (c *Controller) Start(stopChan <-chan struct{}) {
+	defer utilruntime.HandleCrash()
+	defer c.queue.ShutDown()
+
+	t0 := time.Now()
+	c.logger.Info("Starting controller")
+
+	go c.informer.Run(stopChan)
+
+	cache.WaitForCacheSync(stopChan, c.HasSynced)
+	c.logger.Infof("Controller synced in %s", time.Since(t0))
+
+	c.logger.Info("Starting workers")
+	wait.Until(c.worker, c.resyncPeriod, stopChan)
+}
+
+func (c *Controller) HasSynced() bool {
+	return c.informer.HasSynced()
+}
+
+func (c *Controller) worker() {
+	for c.processNextItem() {
+	}
+}
+
+func (c *Controller) processNextItem() bool {
+	resourceName, quit := c.queue.Get()
+	if quit {
+		return false
+	}
+	defer c.queue.Done(resourceName)
+
+	err := c.reconcile(resourceName.(string))
+	if err == nil {
+		// No error, reset the ratelimit counters
+		c.queue.Forget(resourceName)
+	} else if c.queue.NumRequeues(resourceName) < maxRetries {
+		c.logger.Errorf("Error processing %s (will retry): %v", resourceName, err)
+		c.queue.AddRateLimited(resourceName)
+	} else {
+		c.logger.Errorf("Error processing %s (giving up): %v", resourceName, err)
+		c.queue.Forget(resourceName)
+		utilruntime.HandleError(err)
+	}
+
+	return true
+}
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/doc.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/doc.go
new file mode 100644
index 0000000000..b1855f0942
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/doc.go
@@ -0,0 +1,19 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +k8s:deepcopy-gen=package
+// +k8s:defaulter-gen=TypeMeta
+// +groupName=maistra.io
+
+package v1alpha1
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/meshfederation_types.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/meshfederation_types.go
new file mode 100644
index 0000000000..93e483cbee
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/meshfederation_types.go
@@ -0,0 +1,169 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package v1alpha1
+
+import (
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// func init() {
+// 	SchemeBuilder.Register(&MeshFederation{}, &MeshFederationList{})
+// }
+
+// +kubebuilder:object:root=true
+// +kubebuilder:subresource:status
+// +genclient
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+// +kubebuilder:resource:categories=maistra-io
+
+// MeshFederation is the Schema for joining two meshes together.  The resource
+// name will be used to identify the 'cluster' to which imported services
+// belong.
+type MeshFederation struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	Spec   MeshFederationSpec   `json:"spec,omitempty"`
+	Status MeshFederationStatus `json:"status,omitempty"`
+}
+
+// +kubebuilder:object:root=true
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// MeshFederationList contains a list of MeshFederation
+type MeshFederationList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []MeshFederation `json:"items"`
+}
+
+// MeshFederationGateway defines resourcing associated with a gateway used to
+// federate service traffic between meshes.
+type MeshFederationGateway struct {
+	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
+	// Defaults to federation-<ingress|egress>-<remote-mesh-name>
+	// +optional
+	ServiceAccountName string `json:"serviceAccountName,omitempty"`
+	// Compute Resources required by this container.
+	// Cannot be updated.
+	// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
+	// +optional
+	Resources corev1.ResourceRequirements `json:"resources,omitempty"`
+	// NodeSelector is a selector which must be true for the pod to fit on a node.
+	// Selector which must match a node's labels for the pod to be scheduled on that node.
+	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
+	// +optional
+	NodeSelector map[string]string `json:"nodeSelector,omitempty"`
+	// If specified, the pod's scheduling constraints
+	// +optional
+	Affinity *corev1.Affinity `json:"affinity,omitempty"`
+	// If specified, the pod's tolerations.
+	// +optional
+	Tolerations []corev1.Toleration `json:"tolerations,omitempty"`
+}
+
+type MeshFederationSecurity struct {
+	// ClientID of the remote mesh.  This is used to authenticate incoming
+	// requrests from the remote mesh's discovery client.
+	// +required
+	ClientID string `json:"clientID,omitempty"`
+
+	// TrustDomain of remote mesh.
+	// +required
+	TrustDomain string `json:"trustDomain,omitempty"`
+
+	// Name of secret containing certificate chain to be used to validate
+	// the remote.  This is also used to validate certificates used by the
+	// remote services (both client and server certificates).
+	// XXX: maybe this is only used to initiate a connection, with the actual
+	// certs stored in the status field, as retrieved from the remote mesh, or
+	// maybe this identifies an endpoint used to retrieve a cert chain, a la jwks
+	// +optional
+	CertificateChain string `json:"certificateChain,omitempty"`
+
+	// AllowDirectInbound determines whether or not external service
+	// invocations will be terminated at the ingress gateway.
+	// XXX: should this also be configurable per exported service?
+	// +optional
+	AllowDirectInbound bool `json:"allowDirectInbound,omitempty"`
+
+	// AllowDirectOutbound determines whether or not external service
+	// invocations will be proxied through and terminated at the egress gateway
+	// XXX: should this also be configurable per imported service?
+	// +optional
+	AllowDirectOutbound bool `json:"allowDirectOutbound,omitempty"`
+}
+
+type MeshFederationGateways struct {
+	// Gateway through which inbound federated service traffic will travel.
+	// +optional
+	Ingress corev1.LocalObjectReference `json:"ingress,omitempty"`
+
+	// Gateway through which outbound federated service traffic will travel.
+	// This is not required if AllowDirectOutbound is set to true.
+	Egress corev1.LocalObjectReference `json:"egress,omitempty"`
+}
+
+// TODO
+type MeshFederationSpec struct {
+	// NetworkAddress is the address used to communicate with the external mesh.
+	// Port 15443 will be used for service traffic and port 8188 will be used
+	// for service discovery.
+	// XXX: should this be an array?
+	// +required
+	NetworkAddress string `json:"networkAddress,omitempty"`
+
+	Gateways MeshFederationGateways `json:"gateways,omitempty"`
+
+	Security *MeshFederationSecurity `json:"security,omitempty"`
+}
+
+type FederationConditionType string
+
+const (
+	FederationReady            FederationConditionType = "Ready"
+	FederationDiscoverable     FederationConditionType = "Discoverable"
+	FederationConnected        FederationConditionType = "Connected"
+	FederationIngressAvailable FederationConditionType = "IngressAvailable"
+	FederationEgressAvailable  FederationConditionType = "EgressAvailable"
+)
+
+type FederationConditionReason string
+
+const (
+// TODO FederationConditionReason constants
+)
+
+type Condition struct {
+	// The type of this condition.
+	Type FederationConditionType `json:"type,omitempty"`
+
+	// The status of this condition. Can be True, False or Unknown.
+	Status corev1.ConditionStatus `json:"status,omitempty"`
+
+	// Unique, single-word, CamelCase reason for the condition's last transition.
+	Reason FederationConditionReason `json:"reason,omitempty"`
+
+	// Human-readable message indicating details about the last transition.
+	Message string `json:"message,omitempty"`
+
+	// Last time the condition transitioned from one status to another.
+	LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty"`
+}
+
+// TODO
+type MeshFederationStatus struct {
+	Conditions []Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"`
+}
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
index b277291e8e..51bcfbd521 100644
--- a/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
@@ -55,6 +55,10 @@ func addKnownTypes(scheme *runtime.Scheme) error {
 		SchemeGroupVersion,
 		&ServiceMeshExtension{},
 		&ServiceMeshExtensionList{},
+		&MeshFederation{},
+		&MeshFederationList{},
+		&ServiceExports{},
+		&ServiceExportsList{},
 	)
 
 	metav1.AddToGroupVersion(
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/serviceexports_types.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/serviceexports_types.go
new file mode 100644
index 0000000000..5e544ca217
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/serviceexports_types.go
@@ -0,0 +1,123 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1alpha1
+
+import (
+	"fmt"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// +kubebuilder:object:root=true
+// +kubebuilder:subresource:status
+// +genclient
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ServiceExport is the Schema for configuring exported services.  The name of
+// the ServiceExports resource must match the name of a MeshFederation resource
+// defining the remote mesh to which the services will be exported.
+type ServiceExports struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	// Spec defines rules for matching services to be exported.
+	Spec   ServiceExportsSpec  `json:"spec,omitempty"`
+	Status ServiceExportStatus `json:"status,omitempty"`
+}
+
+// +kubebuilder:object:root=true
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ServiceExportList contains a list of ServiceExport
+type ServiceExportsList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []ServiceMeshExtension `json:"items"`
+}
+
+type ServiceExportSelectorType string
+
+const (
+	LabelSelectorType ServiceExportSelectorType = "Label"
+	NameSelectorType  ServiceExportSelectorType = "Name"
+)
+
+type ServiceName struct {
+	Namespace string `json:"namespace,omitempty"`
+	Name      string `json:"names,omitempty"`
+}
+
+func (s ServiceName) String() string {
+	return fmt.Sprintf("%s/%s", s.Namespace, s.Name)
+}
+
+// XXX: this messes up crd generation
+// func (s ServiceName) NamespacedName() types.NamespacedName {
+// 	return types.NamespacedName{Namespace: s.Namespace, Name: s.Name}
+// }
+
+const MatchAny = "*"
+
+type ServiceNameMapping struct {
+	Name  ServiceName  `json:"name,omitempty"`
+	Alias *ServiceName `json:"alias,omitempty"`
+}
+
+type ServiceExportLabelSelector struct {
+	// Namespace specifies to which namespace the selector applies.  An empty
+	// value applies to all namespaces in the mesh.
+	// +optional
+	Namespace string `json:"namespace,omitempty"`
+	// Selector used to select Service resources in the namespace/mesh.  An
+	// empty selector selects all services.
+	// +required
+	Selector metav1.LabelSelector `json:"selector,omitempty"`
+
+	// Aliases is a map of aliases to apply to exported services.  If a name is
+	// not found in the map, the original service name is exported.  A '*' will
+	// match any name. The Aliases list will be processed in order, with the
+	// first match found being applied to the exported service.
+	// Examples:
+	// */foo->*/bar will match foo service in any namesapce, exporting it as bar from its original namespace.
+	// */foo->bar/bar will match foo service in any namespace, exporting it as bar/bar.
+	// foo/*->bar/* will match any service in foo namespace, exporting it from the bar namespace with its original name
+	// */*->bar/* will match any service and export it from the bar namespace with its original name.
+	// */*->*/* is the same as not specifying anything
+	// +optional
+	Aliases []ServiceNameMapping `json:"aliases,omitempty"`
+}
+
+type ServiceExportsSpec struct {
+	// Exports are the rules that determine which services are exported from the
+	// mesh.  The list is processed in order and the first spec in the list that
+	// applies to a service is the one that will be applied.  This allows more
+	// specific selectors to be placed before more general selectors.
+	Exports []ServiceExportRule `json:"exports,omitempty"`
+}
+
+type ServiceExportRule struct {
+	// +required
+	Type ServiceExportSelectorType `json:"type"`
+	// LabelSelector provides a mechanism for selecting services to export by
+	// using a label selector to match Service resources for export.
+	// +optional
+	LabelSelector *ServiceExportLabelSelector `json:"labelSelector,omitempty"`
+	// NameSelector provides a simple name matcher for exporting services in
+	// the mesh.
+	// +optional
+	NameSelector *ServiceNameMapping `json:"nameSelector,omitempty"`
+}
+
+type ServiceExportStatus struct{}
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
index d185d3eba4..3e24af3296 100644
--- a/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
@@ -74,6 +74,7 @@ type ServiceMeshExtension struct {
 }
 
 // +kubebuilder:object:root=true
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 
 // ServiceMeshExtensionList contains a list of ServiceMeshExtension
 type ServiceMeshExtensionList struct {
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
index b9e924407b..bbda6b8007 100644
--- a/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
@@ -1,32 +1,50 @@
+//go:build !ignore_autogenerated
 // +build !ignore_autogenerated
 
-/*
-Copyright Red Hat, Inc.
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Code generated by controller-gen. DO NOT EDIT.
+// Code generated by deepcopy-gen. DO NOT EDIT.
 
 package v1alpha1
 
 import (
+	v1 "k8s.io/api/core/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 )
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *Condition) DeepCopyInto(out *Condition) {
+	*out = *in
+	in.LastTransitionTime.DeepCopyInto(&out.LastTransitionTime)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Condition.
+func (in *Condition) DeepCopy() *Condition {
+	if in == nil {
+		return nil
+	}
+	out := new(Condition)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *DeploymentStatus) DeepCopyInto(out *DeploymentStatus) {
 	*out = *in
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeploymentStatus.
@@ -40,12 +58,339 @@ func (in *DeploymentStatus) DeepCopy() *DeploymentStatus {
 }
 
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *ServiceMeshExtension) DeepCopyInto(out *ServiceMeshExtension) {
+func (in *MeshFederation) DeepCopyInto(out *MeshFederation) {
 	*out = *in
 	out.TypeMeta = in.TypeMeta
 	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
 	in.Spec.DeepCopyInto(&out.Spec)
 	in.Status.DeepCopyInto(&out.Status)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederation.
+func (in *MeshFederation) DeepCopy() *MeshFederation {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederation)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *MeshFederation) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationGateway) DeepCopyInto(out *MeshFederationGateway) {
+	*out = *in
+	in.Resources.DeepCopyInto(&out.Resources)
+	if in.NodeSelector != nil {
+		in, out := &in.NodeSelector, &out.NodeSelector
+		*out = make(map[string]string, len(*in))
+		for key, val := range *in {
+			(*out)[key] = val
+		}
+	}
+	if in.Affinity != nil {
+		in, out := &in.Affinity, &out.Affinity
+		*out = new(v1.Affinity)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.Tolerations != nil {
+		in, out := &in.Tolerations, &out.Tolerations
+		*out = make([]v1.Toleration, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationGateway.
+func (in *MeshFederationGateway) DeepCopy() *MeshFederationGateway {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationGateway)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationGateways) DeepCopyInto(out *MeshFederationGateways) {
+	*out = *in
+	out.Ingress = in.Ingress
+	out.Egress = in.Egress
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationGateways.
+func (in *MeshFederationGateways) DeepCopy() *MeshFederationGateways {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationGateways)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationList) DeepCopyInto(out *MeshFederationList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]MeshFederation, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationList.
+func (in *MeshFederationList) DeepCopy() *MeshFederationList {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *MeshFederationList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationSecurity) DeepCopyInto(out *MeshFederationSecurity) {
+	*out = *in
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationSecurity.
+func (in *MeshFederationSecurity) DeepCopy() *MeshFederationSecurity {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationSecurity)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationSpec) DeepCopyInto(out *MeshFederationSpec) {
+	*out = *in
+	out.Gateways = in.Gateways
+	if in.Security != nil {
+		in, out := &in.Security, &out.Security
+		*out = new(MeshFederationSecurity)
+		**out = **in
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationSpec.
+func (in *MeshFederationSpec) DeepCopy() *MeshFederationSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationSpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MeshFederationStatus) DeepCopyInto(out *MeshFederationStatus) {
+	*out = *in
+	if in.Conditions != nil {
+		in, out := &in.Conditions, &out.Conditions
+		*out = make([]Condition, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshFederationStatus.
+func (in *MeshFederationStatus) DeepCopy() *MeshFederationStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(MeshFederationStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExportLabelSelector) DeepCopyInto(out *ServiceExportLabelSelector) {
+	*out = *in
+	in.Selector.DeepCopyInto(&out.Selector)
+	if in.Aliases != nil {
+		in, out := &in.Aliases, &out.Aliases
+		*out = make([]ServiceNameMapping, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExportLabelSelector.
+func (in *ServiceExportLabelSelector) DeepCopy() *ServiceExportLabelSelector {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExportLabelSelector)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExportRule) DeepCopyInto(out *ServiceExportRule) {
+	*out = *in
+	if in.LabelSelector != nil {
+		in, out := &in.LabelSelector, &out.LabelSelector
+		*out = new(ServiceExportLabelSelector)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.NameSelector != nil {
+		in, out := &in.NameSelector, &out.NameSelector
+		*out = new(ServiceNameMapping)
+		(*in).DeepCopyInto(*out)
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExportRule.
+func (in *ServiceExportRule) DeepCopy() *ServiceExportRule {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExportRule)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExportStatus) DeepCopyInto(out *ServiceExportStatus) {
+	*out = *in
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExportStatus.
+func (in *ServiceExportStatus) DeepCopy() *ServiceExportStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExportStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExports) DeepCopyInto(out *ServiceExports) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	out.Status = in.Status
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExports.
+func (in *ServiceExports) DeepCopy() *ServiceExports {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExports)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceExports) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExportsList) DeepCopyInto(out *ServiceExportsList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]ServiceMeshExtension, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExportsList.
+func (in *ServiceExportsList) DeepCopy() *ServiceExportsList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExportsList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceExportsList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceExportsSpec) DeepCopyInto(out *ServiceExportsSpec) {
+	*out = *in
+	if in.Exports != nil {
+		in, out := &in.Exports, &out.Exports
+		*out = make([]ServiceExportRule, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceExportsSpec.
+func (in *ServiceExportsSpec) DeepCopy() *ServiceExportsSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceExportsSpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceMeshExtension) DeepCopyInto(out *ServiceMeshExtension) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	out.Status = in.Status
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtension.
@@ -78,6 +423,7 @@ func (in *ServiceMeshExtensionList) DeepCopyInto(out *ServiceMeshExtensionList)
 			(*in)[i].DeepCopyInto(&(*out)[i])
 		}
 	}
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionList.
@@ -102,6 +448,17 @@ func (in *ServiceMeshExtensionList) DeepCopyObject() runtime.Object {
 func (in *ServiceMeshExtensionSpec) DeepCopyInto(out *ServiceMeshExtensionSpec) {
 	*out = *in
 	in.WorkloadSelector.DeepCopyInto(&out.WorkloadSelector)
+	if in.Phase != nil {
+		in, out := &in.Phase, &out.Phase
+		*out = new(FilterPhase)
+		**out = **in
+	}
+	if in.Priority != nil {
+		in, out := &in.Priority, &out.Priority
+		*out = new(int)
+		**out = **in
+	}
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionSpec.
@@ -118,6 +475,7 @@ func (in *ServiceMeshExtensionSpec) DeepCopy() *ServiceMeshExtensionSpec {
 func (in *ServiceMeshExtensionStatus) DeepCopyInto(out *ServiceMeshExtensionStatus) {
 	*out = *in
 	out.Deployment = in.Deployment
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionStatus.
@@ -130,6 +488,44 @@ func (in *ServiceMeshExtensionStatus) DeepCopy() *ServiceMeshExtensionStatus {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceName) DeepCopyInto(out *ServiceName) {
+	*out = *in
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceName.
+func (in *ServiceName) DeepCopy() *ServiceName {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceName)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceNameMapping) DeepCopyInto(out *ServiceNameMapping) {
+	*out = *in
+	out.Name = in.Name
+	if in.Alias != nil {
+		in, out := &in.Alias, &out.Alias
+		*out = new(ServiceName)
+		**out = **in
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceNameMapping.
+func (in *ServiceNameMapping) DeepCopy() *ServiceNameMapping {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceNameMapping)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *WorkloadSelector) DeepCopyInto(out *WorkloadSelector) {
 	*out = *in
@@ -140,6 +536,7 @@ func (in *WorkloadSelector) DeepCopyInto(out *WorkloadSelector) {
 			(*out)[key] = val
 		}
 	}
+	return
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new WorkloadSelector.
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
index f048056bf0..d0afff1f95 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
@@ -19,7 +19,7 @@
 import (
 	"fmt"
 
-	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
+	maistrav1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
@@ -27,19 +27,19 @@
 
 type Interface interface {
 	Discovery() discovery.DiscoveryInterface
-	ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface
+	MaistraV1alpha1() maistrav1alpha1.MaistraV1alpha1Interface
 }
 
 // Clientset contains the clients for groups. Each group has exactly one
 // version included in a Clientset.
 type Clientset struct {
 	*discovery.DiscoveryClient
-	servicemeshV1alpha1 *servicemeshv1alpha1.ServicemeshV1alpha1Client
+	maistraV1alpha1 *maistrav1alpha1.MaistraV1alpha1Client
 }
 
-// ServicemeshV1alpha1 retrieves the ServicemeshV1alpha1Client
-func (c *Clientset) ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface {
-	return c.servicemeshV1alpha1
+// MaistraV1alpha1 retrieves the MaistraV1alpha1Client
+func (c *Clientset) MaistraV1alpha1() maistrav1alpha1.MaistraV1alpha1Interface {
+	return c.maistraV1alpha1
 }
 
 // Discovery retrieves the DiscoveryClient
@@ -63,7 +63,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 	}
 	var cs Clientset
 	var err error
-	cs.servicemeshV1alpha1, err = servicemeshv1alpha1.NewForConfig(&configShallowCopy)
+	cs.maistraV1alpha1, err = maistrav1alpha1.NewForConfig(&configShallowCopy)
 	if err != nil {
 		return nil, err
 	}
@@ -79,7 +79,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 // panics if there is an error in the config.
 func NewForConfigOrDie(c *rest.Config) *Clientset {
 	var cs Clientset
-	cs.servicemeshV1alpha1 = servicemeshv1alpha1.NewForConfigOrDie(c)
+	cs.maistraV1alpha1 = maistrav1alpha1.NewForConfigOrDie(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)
 	return &cs
@@ -88,7 +88,7 @@ func NewForConfigOrDie(c *rest.Config) *Clientset {
 // New creates a new Clientset for the given RESTClient.
 func New(c rest.Interface) *Clientset {
 	var cs Clientset
-	cs.servicemeshV1alpha1 = servicemeshv1alpha1.New(c)
+	cs.maistraV1alpha1 = maistrav1alpha1.New(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
 	return &cs
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
index c0a70531a5..6e00cc5840 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
@@ -18,8 +18,8 @@
 
 import (
 	clientset "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
-	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
-	fakeservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake"
+	maistrav1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
+	fakemaistrav1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
@@ -74,7 +74,7 @@ func (c *Clientset) Tracker() testing.ObjectTracker {
 
 var _ clientset.Interface = &Clientset{}
 
-// ServicemeshV1alpha1 retrieves the ServicemeshV1alpha1Client
-func (c *Clientset) ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface {
-	return &fakeservicemeshv1alpha1.FakeServicemeshV1alpha1{Fake: &c.Fake}
+// MaistraV1alpha1 retrieves the MaistraV1alpha1Client
+func (c *Clientset) MaistraV1alpha1() maistrav1alpha1.MaistraV1alpha1Interface {
+	return &fakemaistrav1alpha1.FakeMaistraV1alpha1{Fake: &c.Fake}
 }
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
index 0089129d44..46534cb26a 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
@@ -17,7 +17,7 @@
 package fake
 
 import (
-	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	maistrav1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -29,7 +29,7 @@
 var codecs = serializer.NewCodecFactory(scheme)
 var parameterCodec = runtime.NewParameterCodec(scheme)
 var localSchemeBuilder = runtime.SchemeBuilder{
-	servicemeshv1alpha1.AddToScheme,
+	maistrav1alpha1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
index 2a9754a1e0..2634b56335 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
@@ -17,7 +17,7 @@
 package scheme
 
 import (
-	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	maistrav1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -29,7 +29,7 @@
 var Codecs = serializer.NewCodecFactory(Scheme)
 var ParameterCodec = runtime.NewParameterCodec(Scheme)
 var localSchemeBuilder = runtime.SchemeBuilder{
-	servicemeshv1alpha1.AddToScheme,
+	maistrav1alpha1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_meshfederation.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_meshfederation.go
new file mode 100644
index 0000000000..79da20e03a
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_meshfederation.go
@@ -0,0 +1,140 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeMeshFederations implements MeshFederationInterface
+type FakeMeshFederations struct {
+	Fake *FakeMaistraV1alpha1
+	ns   string
+}
+
+var meshfederationsResource = schema.GroupVersionResource{Group: "maistra.io", Version: "v1alpha1", Resource: "meshfederations"}
+
+var meshfederationsKind = schema.GroupVersionKind{Group: "maistra.io", Version: "v1alpha1", Kind: "MeshFederation"}
+
+// Get takes name of the meshFederation, and returns the corresponding meshFederation object, and an error if there is any.
+func (c *FakeMeshFederations) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.MeshFederation, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewGetAction(meshfederationsResource, c.ns, name), &v1alpha1.MeshFederation{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.MeshFederation), err
+}
+
+// List takes label and field selectors, and returns the list of MeshFederations that match those selectors.
+func (c *FakeMeshFederations) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.MeshFederationList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewListAction(meshfederationsResource, meshfederationsKind, c.ns, opts), &v1alpha1.MeshFederationList{})
+
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1alpha1.MeshFederationList{ListMeta: obj.(*v1alpha1.MeshFederationList).ListMeta}
+	for _, item := range obj.(*v1alpha1.MeshFederationList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested meshFederations.
+func (c *FakeMeshFederations) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewWatchAction(meshfederationsResource, c.ns, opts))
+
+}
+
+// Create takes the representation of a meshFederation and creates it.  Returns the server's representation of the meshFederation, and an error, if there is any.
+func (c *FakeMeshFederations) Create(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.CreateOptions) (result *v1alpha1.MeshFederation, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewCreateAction(meshfederationsResource, c.ns, meshFederation), &v1alpha1.MeshFederation{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.MeshFederation), err
+}
+
+// Update takes the representation of a meshFederation and updates it. Returns the server's representation of the meshFederation, and an error, if there is any.
+func (c *FakeMeshFederations) Update(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (result *v1alpha1.MeshFederation, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateAction(meshfederationsResource, c.ns, meshFederation), &v1alpha1.MeshFederation{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.MeshFederation), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeMeshFederations) UpdateStatus(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (*v1alpha1.MeshFederation, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateSubresourceAction(meshfederationsResource, "status", c.ns, meshFederation), &v1alpha1.MeshFederation{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.MeshFederation), err
+}
+
+// Delete takes name of the meshFederation and deletes it. Returns an error if one occurs.
+func (c *FakeMeshFederations) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewDeleteAction(meshfederationsResource, c.ns, name), &v1alpha1.MeshFederation{})
+
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeMeshFederations) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewDeleteCollectionAction(meshfederationsResource, c.ns, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1alpha1.MeshFederationList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched meshFederation.
+func (c *FakeMeshFederations) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.MeshFederation, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewPatchSubresourceAction(meshfederationsResource, c.ns, name, pt, data, subresources...), &v1alpha1.MeshFederation{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.MeshFederation), err
+}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_serviceexports.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_serviceexports.go
new file mode 100644
index 0000000000..fbdeb591d7
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_serviceexports.go
@@ -0,0 +1,140 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeServiceExports implements ServiceExportsInterface
+type FakeServiceExports struct {
+	Fake *FakeMaistraV1alpha1
+	ns   string
+}
+
+var serviceexportsResource = schema.GroupVersionResource{Group: "maistra.io", Version: "v1alpha1", Resource: "serviceexports"}
+
+var serviceexportsKind = schema.GroupVersionKind{Group: "maistra.io", Version: "v1alpha1", Kind: "ServiceExports"}
+
+// Get takes name of the serviceExports, and returns the corresponding serviceExports object, and an error if there is any.
+func (c *FakeServiceExports) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.ServiceExports, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewGetAction(serviceexportsResource, c.ns, name), &v1alpha1.ServiceExports{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceExports), err
+}
+
+// List takes label and field selectors, and returns the list of ServiceExports that match those selectors.
+func (c *FakeServiceExports) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.ServiceExportsList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewListAction(serviceexportsResource, serviceexportsKind, c.ns, opts), &v1alpha1.ServiceExportsList{})
+
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1alpha1.ServiceExportsList{ListMeta: obj.(*v1alpha1.ServiceExportsList).ListMeta}
+	for _, item := range obj.(*v1alpha1.ServiceExportsList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested serviceExports.
+func (c *FakeServiceExports) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewWatchAction(serviceexportsResource, c.ns, opts))
+
+}
+
+// Create takes the representation of a serviceExports and creates it.  Returns the server's representation of the serviceExports, and an error, if there is any.
+func (c *FakeServiceExports) Create(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.CreateOptions) (result *v1alpha1.ServiceExports, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewCreateAction(serviceexportsResource, c.ns, serviceExports), &v1alpha1.ServiceExports{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceExports), err
+}
+
+// Update takes the representation of a serviceExports and updates it. Returns the server's representation of the serviceExports, and an error, if there is any.
+func (c *FakeServiceExports) Update(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (result *v1alpha1.ServiceExports, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateAction(serviceexportsResource, c.ns, serviceExports), &v1alpha1.ServiceExports{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceExports), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeServiceExports) UpdateStatus(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (*v1alpha1.ServiceExports, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateSubresourceAction(serviceexportsResource, "status", c.ns, serviceExports), &v1alpha1.ServiceExports{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceExports), err
+}
+
+// Delete takes name of the serviceExports and deletes it. Returns an error if one occurs.
+func (c *FakeServiceExports) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewDeleteAction(serviceexportsResource, c.ns, name), &v1alpha1.ServiceExports{})
+
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeServiceExports) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewDeleteCollectionAction(serviceexportsResource, c.ns, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1alpha1.ServiceExportsList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched serviceExports.
+func (c *FakeServiceExports) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceExports, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewPatchSubresourceAction(serviceexportsResource, c.ns, name, pt, data, subresources...), &v1alpha1.ServiceExports{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceExports), err
+}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
index c4280e5e44..c4927c8e32 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
@@ -22,17 +22,25 @@
 	testing "k8s.io/client-go/testing"
 )
 
-type FakeServicemeshV1alpha1 struct {
+type FakeMaistraV1alpha1 struct {
 	*testing.Fake
 }
 
-func (c *FakeServicemeshV1alpha1) ServiceMeshExtensions(namespace string) v1alpha1.ServiceMeshExtensionInterface {
+func (c *FakeMaistraV1alpha1) MeshFederations(namespace string) v1alpha1.MeshFederationInterface {
+	return &FakeMeshFederations{c, namespace}
+}
+
+func (c *FakeMaistraV1alpha1) ServiceExports(namespace string) v1alpha1.ServiceExportsInterface {
+	return &FakeServiceExports{c, namespace}
+}
+
+func (c *FakeMaistraV1alpha1) ServiceMeshExtensions(namespace string) v1alpha1.ServiceMeshExtensionInterface {
 	return &FakeServiceMeshExtensions{c, namespace}
 }
 
 // RESTClient returns a RESTClient that is used to communicate
 // with API server by this client implementation.
-func (c *FakeServicemeshV1alpha1) RESTClient() rest.Interface {
+func (c *FakeMaistraV1alpha1) RESTClient() rest.Interface {
 	var ret *rest.RESTClient
 	return ret
 }
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
index d863eb6de6..18f5d04db1 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
@@ -30,13 +30,13 @@
 
 // FakeServiceMeshExtensions implements ServiceMeshExtensionInterface
 type FakeServiceMeshExtensions struct {
-	Fake *FakeServicemeshV1alpha1
+	Fake *FakeMaistraV1alpha1
 	ns   string
 }
 
-var servicemeshextensionsResource = schema.GroupVersionResource{Group: "servicemesh", Version: "v1alpha1", Resource: "servicemeshextensions"}
+var servicemeshextensionsResource = schema.GroupVersionResource{Group: "maistra.io", Version: "v1alpha1", Resource: "servicemeshextensions"}
 
-var servicemeshextensionsKind = schema.GroupVersionKind{Group: "servicemesh", Version: "v1alpha1", Kind: "ServiceMeshExtension"}
+var servicemeshextensionsKind = schema.GroupVersionKind{Group: "maistra.io", Version: "v1alpha1", Kind: "ServiceMeshExtension"}
 
 // Get takes name of the serviceMeshExtension, and returns the corresponding serviceMeshExtension object, and an error if there is any.
 func (c *FakeServiceMeshExtensions) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
index 0ac191c6e7..98ef7e0941 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
@@ -16,4 +16,8 @@
 
 package v1alpha1
 
+type MeshFederationExpansion interface{}
+
+type ServiceExportsExpansion interface{}
+
 type ServiceMeshExtensionExpansion interface{}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/meshfederation.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/meshfederation.go
new file mode 100644
index 0000000000..4bb005c9fa
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/meshfederation.go
@@ -0,0 +1,193 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	"time"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	scheme "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// MeshFederationsGetter has a method to return a MeshFederationInterface.
+// A group's client should implement this interface.
+type MeshFederationsGetter interface {
+	MeshFederations(namespace string) MeshFederationInterface
+}
+
+// MeshFederationInterface has methods to work with MeshFederation resources.
+type MeshFederationInterface interface {
+	Create(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.CreateOptions) (*v1alpha1.MeshFederation, error)
+	Update(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (*v1alpha1.MeshFederation, error)
+	UpdateStatus(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (*v1alpha1.MeshFederation, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.MeshFederation, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.MeshFederationList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.MeshFederation, err error)
+	MeshFederationExpansion
+}
+
+// meshFederations implements MeshFederationInterface
+type meshFederations struct {
+	client rest.Interface
+	ns     string
+}
+
+// newMeshFederations returns a MeshFederations
+func newMeshFederations(c *MaistraV1alpha1Client, namespace string) *meshFederations {
+	return &meshFederations{
+		client: c.RESTClient(),
+		ns:     namespace,
+	}
+}
+
+// Get takes name of the meshFederation, and returns the corresponding meshFederation object, and an error if there is any.
+func (c *meshFederations) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.MeshFederation, err error) {
+	result = &v1alpha1.MeshFederation{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of MeshFederations that match those selectors.
+func (c *meshFederations) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.MeshFederationList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1alpha1.MeshFederationList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested meshFederations.
+func (c *meshFederations) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a meshFederation and creates it.  Returns the server's representation of the meshFederation, and an error, if there is any.
+func (c *meshFederations) Create(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.CreateOptions) (result *v1alpha1.MeshFederation, err error) {
+	result = &v1alpha1.MeshFederation{}
+	err = c.client.Post().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(meshFederation).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a meshFederation and updates it. Returns the server's representation of the meshFederation, and an error, if there is any.
+func (c *meshFederations) Update(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (result *v1alpha1.MeshFederation, err error) {
+	result = &v1alpha1.MeshFederation{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		Name(meshFederation.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(meshFederation).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *meshFederations) UpdateStatus(ctx context.Context, meshFederation *v1alpha1.MeshFederation, opts v1.UpdateOptions) (result *v1alpha1.MeshFederation, err error) {
+	result = &v1alpha1.MeshFederation{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		Name(meshFederation.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(meshFederation).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the meshFederation and deletes it. Returns an error if one occurs.
+func (c *meshFederations) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *meshFederations) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("meshfederations").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched meshFederation.
+func (c *meshFederations) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.MeshFederation, err error) {
+	result = &v1alpha1.MeshFederation{}
+	err = c.client.Patch(pt).
+		Namespace(c.ns).
+		Resource("meshfederations").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/serviceexports.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/serviceexports.go
new file mode 100644
index 0000000000..0f76984d58
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/serviceexports.go
@@ -0,0 +1,193 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	"time"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	scheme "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// ServiceExportsGetter has a method to return a ServiceExportsInterface.
+// A group's client should implement this interface.
+type ServiceExportsGetter interface {
+	ServiceExports(namespace string) ServiceExportsInterface
+}
+
+// ServiceExportsInterface has methods to work with ServiceExports resources.
+type ServiceExportsInterface interface {
+	Create(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.CreateOptions) (*v1alpha1.ServiceExports, error)
+	Update(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (*v1alpha1.ServiceExports, error)
+	UpdateStatus(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (*v1alpha1.ServiceExports, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ServiceExports, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ServiceExportsList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceExports, err error)
+	ServiceExportsExpansion
+}
+
+// serviceExports implements ServiceExportsInterface
+type serviceExports struct {
+	client rest.Interface
+	ns     string
+}
+
+// newServiceExports returns a ServiceExports
+func newServiceExports(c *MaistraV1alpha1Client, namespace string) *serviceExports {
+	return &serviceExports{
+		client: c.RESTClient(),
+		ns:     namespace,
+	}
+}
+
+// Get takes name of the serviceExports, and returns the corresponding serviceExports object, and an error if there is any.
+func (c *serviceExports) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.ServiceExports, err error) {
+	result = &v1alpha1.ServiceExports{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of ServiceExports that match those selectors.
+func (c *serviceExports) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.ServiceExportsList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1alpha1.ServiceExportsList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested serviceExports.
+func (c *serviceExports) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a serviceExports and creates it.  Returns the server's representation of the serviceExports, and an error, if there is any.
+func (c *serviceExports) Create(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.CreateOptions) (result *v1alpha1.ServiceExports, err error) {
+	result = &v1alpha1.ServiceExports{}
+	err = c.client.Post().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceExports).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a serviceExports and updates it. Returns the server's representation of the serviceExports, and an error, if there is any.
+func (c *serviceExports) Update(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (result *v1alpha1.ServiceExports, err error) {
+	result = &v1alpha1.ServiceExports{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		Name(serviceExports.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceExports).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *serviceExports) UpdateStatus(ctx context.Context, serviceExports *v1alpha1.ServiceExports, opts v1.UpdateOptions) (result *v1alpha1.ServiceExports, err error) {
+	result = &v1alpha1.ServiceExports{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		Name(serviceExports.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceExports).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the serviceExports and deletes it. Returns an error if one occurs.
+func (c *serviceExports) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *serviceExports) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("serviceexports").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched serviceExports.
+func (c *serviceExports) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceExports, err error) {
+	result = &v1alpha1.ServiceExports{}
+	err = c.client.Patch(pt).
+		Namespace(c.ns).
+		Resource("serviceexports").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
index 2f8e991308..9ac6517af8 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
@@ -22,22 +22,32 @@
 	rest "k8s.io/client-go/rest"
 )
 
-type ServicemeshV1alpha1Interface interface {
+type MaistraV1alpha1Interface interface {
 	RESTClient() rest.Interface
+	MeshFederationsGetter
+	ServiceExportsGetter
 	ServiceMeshExtensionsGetter
 }
 
-// ServicemeshV1alpha1Client is used to interact with features provided by the servicemesh group.
-type ServicemeshV1alpha1Client struct {
+// MaistraV1alpha1Client is used to interact with features provided by the maistra.io group.
+type MaistraV1alpha1Client struct {
 	restClient rest.Interface
 }
 
-func (c *ServicemeshV1alpha1Client) ServiceMeshExtensions(namespace string) ServiceMeshExtensionInterface {
+func (c *MaistraV1alpha1Client) MeshFederations(namespace string) MeshFederationInterface {
+	return newMeshFederations(c, namespace)
+}
+
+func (c *MaistraV1alpha1Client) ServiceExports(namespace string) ServiceExportsInterface {
+	return newServiceExports(c, namespace)
+}
+
+func (c *MaistraV1alpha1Client) ServiceMeshExtensions(namespace string) ServiceMeshExtensionInterface {
 	return newServiceMeshExtensions(c, namespace)
 }
 
-// NewForConfig creates a new ServicemeshV1alpha1Client for the given config.
-func NewForConfig(c *rest.Config) (*ServicemeshV1alpha1Client, error) {
+// NewForConfig creates a new MaistraV1alpha1Client for the given config.
+func NewForConfig(c *rest.Config) (*MaistraV1alpha1Client, error) {
 	config := *c
 	if err := setConfigDefaults(&config); err != nil {
 		return nil, err
@@ -46,12 +56,12 @@ func NewForConfig(c *rest.Config) (*ServicemeshV1alpha1Client, error) {
 	if err != nil {
 		return nil, err
 	}
-	return &ServicemeshV1alpha1Client{client}, nil
+	return &MaistraV1alpha1Client{client}, nil
 }
 
-// NewForConfigOrDie creates a new ServicemeshV1alpha1Client for the given config and
+// NewForConfigOrDie creates a new MaistraV1alpha1Client for the given config and
 // panics if there is an error in the config.
-func NewForConfigOrDie(c *rest.Config) *ServicemeshV1alpha1Client {
+func NewForConfigOrDie(c *rest.Config) *MaistraV1alpha1Client {
 	client, err := NewForConfig(c)
 	if err != nil {
 		panic(err)
@@ -59,9 +69,9 @@ func NewForConfigOrDie(c *rest.Config) *ServicemeshV1alpha1Client {
 	return client
 }
 
-// New creates a new ServicemeshV1alpha1Client for the given RESTClient.
-func New(c rest.Interface) *ServicemeshV1alpha1Client {
-	return &ServicemeshV1alpha1Client{c}
+// New creates a new MaistraV1alpha1Client for the given RESTClient.
+func New(c rest.Interface) *MaistraV1alpha1Client {
+	return &MaistraV1alpha1Client{c}
 }
 
 func setConfigDefaults(config *rest.Config) error {
@@ -79,7 +89,7 @@ func setConfigDefaults(config *rest.Config) error {
 
 // RESTClient returns a RESTClient that is used to communicate
 // with API server by this client implementation.
-func (c *ServicemeshV1alpha1Client) RESTClient() rest.Interface {
+func (c *MaistraV1alpha1Client) RESTClient() rest.Interface {
 	if c == nil {
 		return nil
 	}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
index 1a18eea8c1..b53b8b9704 100644
--- a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
@@ -55,7 +55,7 @@ type serviceMeshExtensions struct {
 }
 
 // newServiceMeshExtensions returns a ServiceMeshExtensions
-func newServiceMeshExtensions(c *ServicemeshV1alpha1Client, namespace string) *serviceMeshExtensions {
+func newServiceMeshExtensions(c *MaistraV1alpha1Client, namespace string) *serviceMeshExtensions {
 	return &serviceMeshExtensions{
 		client: c.RESTClient(),
 		ns:     namespace,
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
index 20c4fa2980..72713d9afe 100644
--- a/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
@@ -170,9 +170,9 @@ type SharedInformerFactory interface {
 	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
 	WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool
 
-	Servicemesh() servicemesh.Interface
+	Maistra() servicemesh.Interface
 }
 
-func (f *sharedInformerFactory) Servicemesh() servicemesh.Interface {
+func (f *sharedInformerFactory) Maistra() servicemesh.Interface {
 	return servicemesh.New(f, f.namespace, f.tweakListOptions)
 }
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
index e1e61e2945..f1797d6ccc 100644
--- a/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
@@ -50,9 +50,13 @@ func (f *genericInformer) Lister() cache.GenericLister {
 // TODO extend this to unknown resources with a client pool
 func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {
 	switch resource {
-	// Group=servicemesh, Version=v1alpha1
+	// Group=maistra.io, Version=v1alpha1
+	case v1alpha1.SchemeGroupVersion.WithResource("meshfederations"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Maistra().V1alpha1().MeshFederations().Informer()}, nil
+	case v1alpha1.SchemeGroupVersion.WithResource("serviceexports"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Maistra().V1alpha1().ServiceExports().Informer()}, nil
 	case v1alpha1.SchemeGroupVersion.WithResource("servicemeshextensions"):
-		return &genericInformer{resource: resource.GroupResource(), informer: f.Servicemesh().V1alpha1().ServiceMeshExtensions().Informer()}, nil
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Maistra().V1alpha1().ServiceMeshExtensions().Informer()}, nil
 
 	}
 
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
index fd3b2bbc22..0c9f3c9def 100644
--- a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
@@ -22,6 +22,10 @@
 
 // Interface provides access to all the informers in this group version.
 type Interface interface {
+	// MeshFederations returns a MeshFederationInformer.
+	MeshFederations() MeshFederationInformer
+	// ServiceExports returns a ServiceExportsInformer.
+	ServiceExports() ServiceExportsInformer
 	// ServiceMeshExtensions returns a ServiceMeshExtensionInformer.
 	ServiceMeshExtensions() ServiceMeshExtensionInformer
 }
@@ -37,6 +41,16 @@ func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakList
 	return &version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
 }
 
+// MeshFederations returns a MeshFederationInformer.
+func (v *version) MeshFederations() MeshFederationInformer {
+	return &meshFederationInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
+}
+
+// ServiceExports returns a ServiceExportsInformer.
+func (v *version) ServiceExports() ServiceExportsInformer {
+	return &serviceExportsInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
+}
+
 // ServiceMeshExtensions returns a ServiceMeshExtensionInformer.
 func (v *version) ServiceMeshExtensions() ServiceMeshExtensionInformer {
 	return &serviceMeshExtensionInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/meshfederation.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/meshfederation.go
new file mode 100644
index 0000000000..0085f1caf7
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/meshfederation.go
@@ -0,0 +1,88 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	time "time"
+
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// MeshFederationInformer provides access to a shared informer and lister for
+// MeshFederations.
+type MeshFederationInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1alpha1.MeshFederationLister
+}
+
+type meshFederationInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+	namespace        string
+}
+
+// NewMeshFederationInformer constructs a new informer for MeshFederation type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewMeshFederationInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredMeshFederationInformer(client, namespace, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredMeshFederationInformer constructs a new informer for MeshFederation type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredMeshFederationInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.MaistraV1alpha1().MeshFederations(namespace).List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.MaistraV1alpha1().MeshFederations(namespace).Watch(context.TODO(), options)
+			},
+		},
+		&servicemeshv1alpha1.MeshFederation{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *meshFederationInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredMeshFederationInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *meshFederationInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&servicemeshv1alpha1.MeshFederation{}, f.defaultInformer)
+}
+
+func (f *meshFederationInformer) Lister() v1alpha1.MeshFederationLister {
+	return v1alpha1.NewMeshFederationLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/serviceexports.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/serviceexports.go
new file mode 100644
index 0000000000..da45d6cf1b
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/serviceexports.go
@@ -0,0 +1,88 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	time "time"
+
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// ServiceExportsInformer provides access to a shared informer and lister for
+// ServiceExports.
+type ServiceExportsInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1alpha1.ServiceExportsLister
+}
+
+type serviceExportsInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+	namespace        string
+}
+
+// NewServiceExportsInformer constructs a new informer for ServiceExports type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewServiceExportsInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredServiceExportsInformer(client, namespace, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredServiceExportsInformer constructs a new informer for ServiceExports type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredServiceExportsInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.MaistraV1alpha1().ServiceExports(namespace).List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.MaistraV1alpha1().ServiceExports(namespace).Watch(context.TODO(), options)
+			},
+		},
+		&servicemeshv1alpha1.ServiceExports{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *serviceExportsInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredServiceExportsInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *serviceExportsInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&servicemeshv1alpha1.ServiceExports{}, f.defaultInformer)
+}
+
+func (f *serviceExportsInformer) Lister() v1alpha1.ServiceExportsLister {
+	return v1alpha1.NewServiceExportsLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
index 504a29f6c4..3687f4d97e 100644
--- a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
@@ -60,13 +60,13 @@ func NewFilteredServiceMeshExtensionInformer(client versioned.Interface, namespa
 				if tweakListOptions != nil {
 					tweakListOptions(&options)
 				}
-				return client.ServicemeshV1alpha1().ServiceMeshExtensions(namespace).List(context.TODO(), options)
+				return client.MaistraV1alpha1().ServiceMeshExtensions(namespace).List(context.TODO(), options)
 			},
 			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
 				if tweakListOptions != nil {
 					tweakListOptions(&options)
 				}
-				return client.ServicemeshV1alpha1().ServiceMeshExtensions(namespace).Watch(context.TODO(), options)
+				return client.MaistraV1alpha1().ServiceMeshExtensions(namespace).Watch(context.TODO(), options)
 			},
 		},
 		&servicemeshv1alpha1.ServiceMeshExtension{},
diff --git a/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
index a92f0a1fee..33fa459131 100644
--- a/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
+++ b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
@@ -16,6 +16,22 @@
 
 package v1alpha1
 
+// MeshFederationListerExpansion allows custom methods to be added to
+// MeshFederationLister.
+type MeshFederationListerExpansion interface{}
+
+// MeshFederationNamespaceListerExpansion allows custom methods to be added to
+// MeshFederationNamespaceLister.
+type MeshFederationNamespaceListerExpansion interface{}
+
+// ServiceExportsListerExpansion allows custom methods to be added to
+// ServiceExportsLister.
+type ServiceExportsListerExpansion interface{}
+
+// ServiceExportsNamespaceListerExpansion allows custom methods to be added to
+// ServiceExportsNamespaceLister.
+type ServiceExportsNamespaceListerExpansion interface{}
+
 // ServiceMeshExtensionListerExpansion allows custom methods to be added to
 // ServiceMeshExtensionLister.
 type ServiceMeshExtensionListerExpansion interface{}
diff --git a/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/meshfederation.go b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/meshfederation.go
new file mode 100644
index 0000000000..c9b5d011e3
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/meshfederation.go
@@ -0,0 +1,92 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// MeshFederationLister helps list MeshFederations.
+type MeshFederationLister interface {
+	// List lists all MeshFederations in the indexer.
+	List(selector labels.Selector) (ret []*v1alpha1.MeshFederation, err error)
+	// MeshFederations returns an object that can list and get MeshFederations.
+	MeshFederations(namespace string) MeshFederationNamespaceLister
+	MeshFederationListerExpansion
+}
+
+// meshFederationLister implements the MeshFederationLister interface.
+type meshFederationLister struct {
+	indexer cache.Indexer
+}
+
+// NewMeshFederationLister returns a new MeshFederationLister.
+func NewMeshFederationLister(indexer cache.Indexer) MeshFederationLister {
+	return &meshFederationLister{indexer: indexer}
+}
+
+// List lists all MeshFederations in the indexer.
+func (s *meshFederationLister) List(selector labels.Selector) (ret []*v1alpha1.MeshFederation, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.MeshFederation))
+	})
+	return ret, err
+}
+
+// MeshFederations returns an object that can list and get MeshFederations.
+func (s *meshFederationLister) MeshFederations(namespace string) MeshFederationNamespaceLister {
+	return meshFederationNamespaceLister{indexer: s.indexer, namespace: namespace}
+}
+
+// MeshFederationNamespaceLister helps list and get MeshFederations.
+type MeshFederationNamespaceLister interface {
+	// List lists all MeshFederations in the indexer for a given namespace.
+	List(selector labels.Selector) (ret []*v1alpha1.MeshFederation, err error)
+	// Get retrieves the MeshFederation from the indexer for a given namespace and name.
+	Get(name string) (*v1alpha1.MeshFederation, error)
+	MeshFederationNamespaceListerExpansion
+}
+
+// meshFederationNamespaceLister implements the MeshFederationNamespaceLister
+// interface.
+type meshFederationNamespaceLister struct {
+	indexer   cache.Indexer
+	namespace string
+}
+
+// List lists all MeshFederations in the indexer for a given namespace.
+func (s meshFederationNamespaceLister) List(selector labels.Selector) (ret []*v1alpha1.MeshFederation, err error) {
+	err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.MeshFederation))
+	})
+	return ret, err
+}
+
+// Get retrieves the MeshFederation from the indexer for a given namespace and name.
+func (s meshFederationNamespaceLister) Get(name string) (*v1alpha1.MeshFederation, error) {
+	obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1alpha1.Resource("meshfederation"), name)
+	}
+	return obj.(*v1alpha1.MeshFederation), nil
+}
diff --git a/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/serviceexports.go b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/serviceexports.go
new file mode 100644
index 0000000000..0d9b255397
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/serviceexports.go
@@ -0,0 +1,92 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// ServiceExportsLister helps list ServiceExports.
+type ServiceExportsLister interface {
+	// List lists all ServiceExports in the indexer.
+	List(selector labels.Selector) (ret []*v1alpha1.ServiceExports, err error)
+	// ServiceExports returns an object that can list and get ServiceExports.
+	ServiceExports(namespace string) ServiceExportsNamespaceLister
+	ServiceExportsListerExpansion
+}
+
+// serviceExportsLister implements the ServiceExportsLister interface.
+type serviceExportsLister struct {
+	indexer cache.Indexer
+}
+
+// NewServiceExportsLister returns a new ServiceExportsLister.
+func NewServiceExportsLister(indexer cache.Indexer) ServiceExportsLister {
+	return &serviceExportsLister{indexer: indexer}
+}
+
+// List lists all ServiceExports in the indexer.
+func (s *serviceExportsLister) List(selector labels.Selector) (ret []*v1alpha1.ServiceExports, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.ServiceExports))
+	})
+	return ret, err
+}
+
+// ServiceExports returns an object that can list and get ServiceExports.
+func (s *serviceExportsLister) ServiceExports(namespace string) ServiceExportsNamespaceLister {
+	return serviceExportsNamespaceLister{indexer: s.indexer, namespace: namespace}
+}
+
+// ServiceExportsNamespaceLister helps list and get ServiceExports.
+type ServiceExportsNamespaceLister interface {
+	// List lists all ServiceExports in the indexer for a given namespace.
+	List(selector labels.Selector) (ret []*v1alpha1.ServiceExports, err error)
+	// Get retrieves the ServiceExports from the indexer for a given namespace and name.
+	Get(name string) (*v1alpha1.ServiceExports, error)
+	ServiceExportsNamespaceListerExpansion
+}
+
+// serviceExportsNamespaceLister implements the ServiceExportsNamespaceLister
+// interface.
+type serviceExportsNamespaceLister struct {
+	indexer   cache.Indexer
+	namespace string
+}
+
+// List lists all ServiceExports in the indexer for a given namespace.
+func (s serviceExportsNamespaceLister) List(selector labels.Selector) (ret []*v1alpha1.ServiceExports, err error) {
+	err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.ServiceExports))
+	})
+	return ret, err
+}
+
+// Get retrieves the ServiceExports from the indexer for a given namespace and name.
+func (s serviceExportsNamespaceLister) Get(name string) (*v1alpha1.ServiceExports, error) {
+	obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1alpha1.Resource("serviceexports"), name)
+	}
+	return obj.(*v1alpha1.ServiceExports), nil
+}
diff --git a/pkg/servicemesh/federation/common/const.go b/pkg/servicemesh/federation/common/const.go
new file mode 100644
index 0000000000..0188dc9f2e
--- /dev/null
+++ b/pkg/servicemesh/federation/common/const.go
@@ -0,0 +1,26 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package common
+
+import (
+	"time"
+)
+
+const (
+	DiscoveryScheme      = "http"
+	DefaultDiscoveryPort = 8188
+	DefaultResyncPeriod  = 60 * time.Second
+	FederationPort       = 15443
+)
diff --git a/pkg/servicemesh/federation/common/options.go b/pkg/servicemesh/federation/common/options.go
new file mode 100644
index 0000000000..6f5fcceca9
--- /dev/null
+++ b/pkg/servicemesh/federation/common/options.go
@@ -0,0 +1,27 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package common
+
+import (
+	"time"
+
+	"istio.io/istio/pkg/kube"
+)
+
+type ControllerOptions struct {
+	KubeClient   kube.Client
+	ResyncPeriod time.Duration
+	Namespace    string
+}
diff --git a/pkg/servicemesh/federation/discovery/controller.go b/pkg/servicemesh/federation/discovery/controller.go
new file mode 100644
index 0000000000..a39b9f9a77
--- /dev/null
+++ b/pkg/servicemesh/federation/discovery/controller.go
@@ -0,0 +1,329 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package discovery
+
+import (
+	"context"
+	"fmt"
+	"sync"
+	"time"
+
+	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	utilerrors "k8s.io/apimachinery/pkg/util/errors"
+	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/client-go/tools/cache"
+
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pkg/cluster"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry"
+	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
+	federationregistry "istio.io/istio/pilot/pkg/serviceregistry/federation"
+	kubecontroller "istio.io/istio/pkg/kube/controller"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	clientsetservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	informersservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	"istio.io/istio/pkg/servicemesh/federation/server"
+	"istio.io/pkg/log"
+)
+
+var logger = log.RegisterScope("federation-controller", "federation-controller", 0)
+
+type Options struct {
+	common.ControllerOptions
+	ServiceController *aggregate.Controller
+	XDSUpdater        model.XDSUpdater
+	Env               *model.Environment
+	ConfigStore       model.ConfigStoreCache
+	FederationManager server.FederationManager
+}
+
+type Controller struct {
+	*kubecontroller.Controller
+	model.ConfigStoreCache
+	cs                clientsetservicemeshv1alpha1.Interface
+	env               *model.Environment
+	federationManager server.FederationManager
+	sc                *aggregate.Controller
+	xds               model.XDSUpdater
+	mu                sync.Mutex
+	stopChannels      map[cluster.ID]chan struct{}
+}
+
+var (
+	_ model.ConfigStore      = (*Controller)(nil)
+	_ model.ConfigStoreCache = (*Controller)(nil)
+)
+
+// NewController creates a new Aggregate controller
+func NewController(opt Options) (*Controller, error) {
+	if err := opt.validate(); err != nil {
+		return nil, err
+	}
+
+	cs, err := clientsetservicemeshv1alpha1.NewForConfig(opt.KubeClient.RESTConfig())
+	if err != nil {
+		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
+	}
+
+	mrc := opt.KubeClient.GetMemberRoll()
+
+	return internalNewController(cs, mrc, opt), nil
+}
+
+// allows using a fake client set for testing purposes
+func internalNewController(cs clientsetservicemeshv1alpha1.Interface, mrc memberroll.MemberRollController, opt Options) *Controller {
+	var informer cache.SharedIndexInformer
+	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
+	if mrc != nil && false {
+		newInformer := func(namespace string) cache.SharedIndexInformer {
+			return cache.NewSharedIndexInformer(
+				&cache.ListWatch{
+					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
+						return cs.MaistraV1alpha1().MeshFederations(namespace).List(context.TODO(), options)
+					},
+					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
+						return cs.MaistraV1alpha1().MeshFederations(namespace).Watch(context.TODO(), options)
+					},
+				},
+				&v1alpha1.MeshFederation{},
+				opt.ResyncPeriod,
+				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
+			)
+		}
+
+		namespaceSet := xnsinformers.NewNamespaceSet()
+		informer = xnsinformers.NewMultiNamespaceInformer(namespaceSet, opt.ResyncPeriod, newInformer)
+		mrc.Register(namespaceSet, "federation-controller")
+	} else {
+		informer = informersservicemeshv1alpha1.NewMeshFederationInformer(
+			cs, opt.Namespace, opt.ResyncPeriod,
+			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
+	}
+
+	controller := &Controller{
+		ConfigStoreCache:  opt.ConfigStore,
+		cs:                cs,
+		env:               opt.Env,
+		sc:                opt.ServiceController,
+		stopChannels:      make(map[cluster.ID]chan struct{}),
+		xds:               opt.XDSUpdater,
+		federationManager: opt.FederationManager,
+	}
+	internalController := kubecontroller.NewController(kubecontroller.Options{
+		Informer:     informer,
+		Logger:       logger,
+		ResyncPeriod: opt.ResyncPeriod,
+		Reconciler:   controller.reconcile,
+	})
+	controller.Controller = internalController
+
+	return controller
+}
+
+func (c *Controller) Run(stopChan <-chan struct{}) {
+	c.Controller.Start(stopChan)
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	for _, registryStopCh := range c.stopChannels {
+		close(registryStopCh)
+	}
+}
+
+func (c *Controller) HasSynced() bool {
+	return c.Controller.HasSynced()
+}
+
+func (c *Controller) reconcile(resourceName string) error {
+	logger.Debugf("Reconciling MeshFederation %s", resourceName)
+	defer func() {
+		logger.Infof("Completed reconciliation of MeshFederation %s", resourceName)
+	}()
+
+	ctx := context.TODO()
+
+	namespace, name, err := cache.SplitMetaNamespaceKey(resourceName)
+	if err != nil {
+		logger.Errorf("error splitting resource name: %s", resourceName)
+	}
+	instance, err := c.cs.MaistraV1alpha1().MeshFederations(namespace).Get(
+		ctx, name, metav1.GetOptions{
+			TypeMeta: metav1.TypeMeta{
+				Kind:       "MeshFederation",
+				APIVersion: v1alpha1.SchemeGroupVersion.String(),
+			},
+		})
+	if err != nil {
+		if apierrors.IsNotFound(err) || apierrors.IsGone(err) {
+			// Request object not found, could have been deleted after reconcile request.
+			// Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
+			// Return and don't requeue
+			err = c.delete(ctx, &v1alpha1.MeshFederation{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      name,
+					Namespace: namespace,
+				},
+			})
+			if err == nil {
+				logger.Info("MeshFederation deleted")
+			}
+		}
+		// Error reading the object
+		return err
+	}
+
+	return c.update(ctx, instance)
+}
+
+func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederation) error {
+	registry := c.getRegistry(cluster.ID(instance.Name))
+
+	egressGatewayService := fmt.Sprintf("%s.%s.svc.cluster.local",
+		instance.Spec.Gateways.Egress.Name, instance.Namespace)
+
+	// check for existing registry
+	if registry != nil {
+		// if there's an existing registry
+		// make sure it's one of ours
+		if registry.Provider() != provider.Federation {
+			return fmt.Errorf(
+				"cannot create Federation registry for %s, registry exists and belongs to another provider (%s)",
+				instance.Name, registry.Provider())
+		}
+		// check to see if it needs updating
+		// TODO: support updates
+		if federationRegistry, ok := registry.(*federationregistry.Controller); ok {
+			if federationRegistry.NetworkAddress() != instance.Spec.NetworkAddress {
+				// TODO: support updates
+				logger.Warnf("updating NetworkAddress for MeshFederation (%s) is not supported", instance.Name)
+			}
+		} else {
+			return fmt.Errorf("registry %s is not a Federation registry (type=%T)", instance.Name, registry)
+		}
+	} else {
+		// if there's no existing registry
+		logger.Info("Creating handler for Federation discovery server")
+		exportConfig, err := c.cs.MaistraV1alpha1().ServiceExports(instance.Namespace).Get(context.TODO(), instance.Name, metav1.GetOptions{})
+		if err != nil && !(apierrors.IsNotFound(err) || apierrors.IsGone(err)) {
+			logger.Errorf("error retrieving ServiceExports associated with MeshFederation %s: %s", instance.Name, err)
+			return err
+		}
+		if err := c.federationManager.AddMeshFederation(instance, exportConfig); err != nil {
+			return err
+		}
+
+		logger.Infof("Creating Istio resources for Federation discovery")
+		if err := c.createDiscoveryResources(ctx, instance, c.env.Mesh()); err != nil {
+			return err
+		}
+
+		logger.Infof("Initializing Federation service registry %q at %s", instance.Name, instance.Spec.NetworkAddress)
+		// create a registry instance
+		options := federationregistry.Options{
+			NetworkAddress: instance.Spec.NetworkAddress,
+			EgressName:     instance.Spec.Gateways.Egress.Name,
+			EgressService:  egressGatewayService,
+			ClusterID:      instance.Name,
+			Namespace:      instance.Namespace,
+			UseDirectCalls: instance.Spec.Security != nil && instance.Spec.Security.AllowDirectOutbound,
+			ConfigStore:    c.ConfigStoreCache,
+			XDSUpdater:     c.xds,
+			ResyncPeriod:   time.Minute * 5,
+			NetworkName:    fmt.Sprintf("network-%s", instance.Name),
+		}
+		registry = federationregistry.NewController(options)
+		// register the new instance
+		c.sc.AddRegistry(registry)
+
+		stopCh := make(chan struct{})
+		c.mu.Lock()
+		defer c.mu.Unlock()
+		c.stopChannels[cluster.ID(instance.Name)] = stopCh
+		go registry.Run(stopCh)
+	}
+
+	return nil
+}
+
+func (c *Controller) delete(ctx context.Context, instance *v1alpha1.MeshFederation) error {
+	var allErrors []error
+	// delete the server
+	c.federationManager.DeleteMeshFederation(instance.Name)
+
+	// delete the registry
+	registry := c.getRegistry(cluster.ID(instance.Name))
+	if registry != nil {
+		// make sure it's one of ours
+		if registry.Provider() == provider.Federation {
+			// unregister federation registry
+			logger.Infof("Removing registry for Federation cluster %s", instance.Name)
+			c.sc.DeleteRegistry(registry.Cluster(), provider.Federation)
+			c.mu.Lock()
+			defer c.mu.Unlock()
+			if registryStopCh := c.stopChannels[registry.Cluster()]; registryStopCh != nil {
+				close(registryStopCh)
+				delete(c.stopChannels, registry.Cluster())
+			}
+		} else {
+			allErrors = append(allErrors,
+				fmt.Errorf("cannot delete Federation registry for %s, registry belongs to another provider (%s)",
+					instance.Name, registry.Provider()))
+		}
+	}
+
+	if err := c.deleteDiscoveryResources(ctx, instance); err != nil {
+		allErrors = append(allErrors, err)
+	}
+
+	return utilerrors.NewAggregate(allErrors)
+}
+
+func (c *Controller) getRegistry(clusterID cluster.ID) serviceregistry.Instance {
+	for _, registry := range c.sc.GetRegistries() {
+		if registry.Cluster() == clusterID {
+			return c.sc.Unwrap(registry)
+		}
+	}
+	return nil
+}
+
+func (opt Options) validate() error {
+	var allErrors []error
+	if opt.KubeClient == nil {
+		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	}
+	if opt.ServiceController == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ServiceController field must not be nil"))
+	}
+	if opt.XDSUpdater == nil {
+		allErrors = append(allErrors, fmt.Errorf("the XDSUpdater field must not be nil"))
+	}
+	if opt.Env == nil {
+		allErrors = append(allErrors, fmt.Errorf("the Env field must not be nil"))
+	}
+	if opt.FederationManager == nil {
+		allErrors = append(allErrors, fmt.Errorf("the FederationManager field must not be nil"))
+	}
+	if opt.ResyncPeriod == 0 {
+		opt.ResyncPeriod = common.DefaultResyncPeriod
+		logger.Warnf("ResyncPeriod not specified, defaulting to %s", opt.ResyncPeriod)
+	}
+	return utilerrors.NewAggregate(allErrors)
+}
diff --git a/pkg/servicemesh/federation/discovery/controller_test.go b/pkg/servicemesh/federation/discovery/controller_test.go
new file mode 100644
index 0000000000..89a0b55351
--- /dev/null
+++ b/pkg/servicemesh/federation/discovery/controller_test.go
@@ -0,0 +1,323 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package discovery
+
+import (
+	"context"
+	"fmt"
+	"testing"
+	"time"
+
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/meta"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/watch"
+
+	"istio.io/istio/pkg/cluster"
+
+	"istio.io/api/mesh/v1alpha1"
+	configmemory "istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
+	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/kube"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+)
+
+type fakeManager struct{}
+
+func (m *fakeManager) AddMeshFederation(mesh *servicemeshv1alpha1.MeshFederation, exports *servicemeshv1alpha1.ServiceExports) error {
+	return nil
+}
+func (m *fakeManager) DeleteMeshFederation(name string) {}
+func (m *fakeManager) UpdateExportsForMesh(exports *servicemeshv1alpha1.ServiceExports) error {
+	return nil
+}
+func (m *fakeManager) DeleteExportsForMesh(name string) {}
+
+func TestValidOptions(t *testing.T) {
+	opt := Options{
+		ControllerOptions: common.ControllerOptions{
+			KubeClient: kube.NewFakeClient(),
+		},
+		ServiceController: &aggregate.Controller{},
+		XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+		Env:               &model.Environment{},
+		FederationManager: &fakeManager{},
+	}
+	if err := opt.validate(); err != nil {
+		t.Errorf("unexpected error")
+	}
+}
+
+func TestInvalidOptions(t *testing.T) {
+	testCases := []struct {
+		name string
+		opt  Options
+	}{
+		{
+			name: "client",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: nil,
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "service-controller",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: nil,
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "xds-updater",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        nil,
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "env",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               nil,
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			if _, err := NewController(tc.opt); err == nil {
+				t.Errorf("expected error")
+			}
+		})
+	}
+}
+
+type options struct {
+	client            kube.Client
+	serviceController *aggregate.Controller
+	xdsUpdater        *v1alpha3.FakeXdsUpdater
+	env               *model.Environment
+}
+
+func newTestOptions(discoveryAddress string) options {
+	client := kube.NewFakeClient()
+	meshConfig := &v1alpha1.MeshConfig{
+		DefaultConfig: &v1alpha1.ProxyConfig{
+			DiscoveryAddress: discoveryAddress,
+		},
+	}
+	meshWatcher := mesh.NewFixedWatcher(meshConfig)
+	serviceController := aggregate.NewController(aggregate.Options{
+		MeshHolder: meshWatcher,
+	})
+	xdsUpdater := &v1alpha3.FakeXdsUpdater{}
+	env := &model.Environment{
+		ServiceDiscovery: serviceController,
+		Watcher:          meshWatcher,
+	}
+	return options{
+		client:            client,
+		serviceController: serviceController,
+		xdsUpdater:        xdsUpdater,
+		env:               env,
+	}
+}
+
+func TestReconcile(t *testing.T) {
+	resyncPeriod := 30 * time.Second
+	options := newTestOptions("test.address")
+	controller := internalNewController(fake.NewSimpleClientset(), nil, Options{
+		ControllerOptions: common.ControllerOptions{
+			KubeClient:   kube.NewFakeClient(),
+			ResyncPeriod: resyncPeriod,
+			Namespace:    "",
+		},
+		ServiceController: options.serviceController,
+		XDSUpdater:        options.xdsUpdater,
+		Env:               options.env,
+		FederationManager: &fakeManager{},
+		ConfigStore:       configmemory.NewController(configmemory.Make(Schemas)),
+	})
+
+	name := "test"
+	namespace := "test"
+	federation := &servicemeshv1alpha1.MeshFederation{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: namespace,
+		},
+		Spec: servicemeshv1alpha1.MeshFederationSpec{
+			NetworkAddress: "test.mesh",
+			Gateways: servicemeshv1alpha1.MeshFederationGateways{
+				Ingress: corev1.LocalObjectReference{
+					Name: "test-ingress",
+				},
+				Egress: corev1.LocalObjectReference{
+					Name: "test-egress",
+				},
+			},
+			Security: &servicemeshv1alpha1.MeshFederationSecurity{
+				ClientID:            "cluster.local/ns/test-mesh/sa/test-egress-service-account",
+				TrustDomain:         "test.local",
+				CertificateChain:    "dummy",
+				AllowDirectInbound:  false,
+				AllowDirectOutbound: false,
+			},
+		},
+	}
+	cs := controller.cs
+	fedwatch, err := cs.MaistraV1alpha1().MeshFederations(namespace).Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		t.Errorf("failed to watch for MeshFederation")
+		return
+	}
+	newFederation, err := cs.MaistraV1alpha1().MeshFederations(namespace).Create(context.TODO(), federation, metav1.CreateOptions{})
+	if err != nil {
+		t.Errorf("failed to create MeshFederation")
+		fedwatch.Stop()
+		return
+	}
+	// wait for object to show up
+	func() {
+		defer fedwatch.Stop()
+		select {
+		case event := <-fedwatch.ResultChan():
+			if event.Type == watch.Added {
+				metaObj, _ := meta.Accessor(event.Object)
+				if metaObj != nil && metaObj.GetName() == name && metaObj.GetNamespace() == namespace {
+					break
+				}
+			}
+			t.Errorf("unexpected watch event: %#v", event)
+		case <-time.After(5 * time.Second):
+			t.Errorf("timed out waiting for watch event")
+		}
+	}()
+	if err := controller.reconcile(fmt.Sprintf("%s/%s", namespace, name)); err != nil {
+		t.Errorf("unexpected error reconciling new MeshFederation: %#v", err)
+	}
+	// verify registry has been created
+	if controller.getRegistry(cluster.ID(newFederation.Name)) == nil {
+		t.Errorf("failed to create service registry for federation")
+	}
+	// verify resources have been created
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		discoveryIngressResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		discoveryEgressResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+
+	// now delete
+	fedwatch, err = cs.MaistraV1alpha1().MeshFederations(namespace).Watch(context.TODO(), metav1.ListOptions{})
+	if err != nil {
+		t.Errorf("failed to watch for MeshFederation")
+		return
+	}
+	if err = cs.MaistraV1alpha1().MeshFederations(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{}); err != nil {
+		t.Errorf("error deleting MeshFederation")
+		fedwatch.Stop()
+		return
+	}
+
+	// wait for deletion to show up
+	func() {
+		defer fedwatch.Stop()
+		select {
+		case event := <-fedwatch.ResultChan():
+			if event.Type == watch.Deleted {
+				metaObj, _ := meta.Accessor(event.Object)
+				if metaObj != nil && metaObj.GetName() == name && metaObj.GetNamespace() == namespace {
+					break
+				}
+			}
+			t.Errorf("unexpected watch event: %#v", event)
+		case <-time.After(5 * time.Second):
+			t.Errorf("timed out waiting for watch event")
+		}
+	}()
+
+	if err := controller.reconcile(fmt.Sprintf("%s/%s", namespace, name)); err != nil {
+		t.Errorf("unexpected error reconciling new MeshFederation: %#v", err)
+	}
+	// verify registry has been deleted
+	if controller.getRegistry(cluster.ID(newFederation.Name)) != nil {
+		t.Errorf("failed to delete service registry for federation")
+	}
+	// verify resources have been deleted
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		discoveryIngressResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		discoveryEgressResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+	if resource := controller.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+		discoveryResourceName(federation), namespace); resource != nil {
+		t.Errorf("resource not deleted")
+	}
+}
diff --git a/pkg/servicemesh/federation/discovery/discovery.go b/pkg/servicemesh/federation/discovery/discovery.go
new file mode 100644
index 0000000000..c692fac120
--- /dev/null
+++ b/pkg/servicemesh/federation/discovery/discovery.go
@@ -0,0 +1,602 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package discovery
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+
+	utilerrors "k8s.io/apimachinery/pkg/util/errors"
+
+	meshv1alpha1 "istio.io/api/mesh/v1alpha1"
+	rawnetworking "istio.io/api/networking/v1alpha3"
+	rawsecurity "istio.io/api/security/v1beta1"
+	rawtype "istio.io/api/type/v1beta1"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+)
+
+func init() {
+	schemasBuilder := collection.NewSchemasBuilder()
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Destinationrules)
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Virtualservices)
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Gateways)
+	schemasBuilder.MustAdd(collections.IstioSecurityV1Beta1Authorizationpolicies)
+	// XXX: we should consider adding this directly to the service registry
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Serviceentries)
+	Schemas = schemasBuilder.Build()
+}
+
+var Schemas collection.Schemas
+
+// only to facilitate processing errors from the store
+type storeErrorChecker struct {
+	s string
+}
+
+func (e *storeErrorChecker) Error() string {
+	return e.s
+}
+
+func (e *storeErrorChecker) Is(other error) bool {
+	return other.Error() == e.s
+}
+
+var (
+	memoryStoreErrNotFound      = &storeErrorChecker{"item not found"}
+	memoryStoreErrAlreadyExists = &storeErrorChecker{"item already exists"}
+)
+
+func (c *Controller) deleteDiscoveryResources(
+	_ context.Context, instance *servicemeshv1alpha1.MeshFederation) error {
+	logger.Infof("deleting discovery resources for Federation cluster %s", instance.Name)
+	var allErrors []error
+	rootName := discoveryResourceName(instance)
+	egressName := discoveryEgressResourceName(instance)
+	ingressName := discoveryIngressResourceName(instance)
+	// XXX: the only errors possible on delete are "does not exist" and "unknown
+	// type", so maybe we should just skip error checking?
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery Service %s for Federation cluster %s: %v",
+			rootName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery VirtualService %s for Federation cluster %s: %v",
+			rootName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		ingressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery ingress Gateway %s for Federation cluster %s: %v",
+			ingressName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+		egressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery egress Gateway %s for Federation cluster %s: %v",
+			egressName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery DestinationRule %s for Federation cluster %s: %v",
+			rootName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		logger.Errorf("error deleting discovery AuthorizationPolicy %s for Federation cluster %s: %v",
+			rootName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	return utilerrors.NewAggregate(allErrors)
+}
+
+func (c *Controller) createDiscoveryResources(
+	_ context.Context, instance *servicemeshv1alpha1.MeshFederation, meshConfig *meshv1alpha1.MeshConfig) (err error) {
+	var s, ap, dr, ig, eg, vs *config.Config
+
+	defer func() {
+		if err != nil {
+			logger.Errorf("error creating discovery configuration for Federation cluster %s: %v", instance.Name, err)
+			logger.Infof("rolling back discovery Service for %s", instance.Name)
+			if s != nil {
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
+					s.Name, s.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery Service %s: %v", s.Name, newErr)
+				}
+			}
+			logger.Infof("rolling back discovery AuthorizationPolicy for Federation cluster %s", instance.Name)
+			if ap != nil {
+				if newErr := c.Delete(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+					ap.Name, ap.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery AuthorizationPolicy %s: %v", ap.Name, newErr)
+				}
+			}
+			if dr != nil {
+				logger.Infof("rolling back discovery DestinationRule for Federation cluster %s", instance.Name)
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+					dr.Name, dr.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery DestinationRule %s: %v", dr.Name, newErr)
+				}
+			}
+			if ig != nil {
+				logger.Infof("rolling back discovery ingress Gateway for Federation cluster %s", instance.Name)
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+					ig.Name, ig.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery ingress Gateway %s: %v", ig.Name, newErr)
+				}
+			}
+			if eg != nil {
+				logger.Infof("rolling back discovery egress Gateway for Federation cluster %s", instance.Name)
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+					eg.Name, eg.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery ingress Gateway %s: %v", eg.Name, newErr)
+				}
+			}
+			if vs != nil {
+				logger.Infof("rolling back discovery VirtualService for Federation cluster %s", instance.Name)
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+					vs.Name, vs.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					logger.Errorf("error deleting discovery VirtualService %s: %v", vs.Name, newErr)
+				}
+			}
+		}
+	}()
+
+	s = c.discoveryService(instance)
+	_, err = c.Create(*s)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			s = nil
+			return
+		}
+	}
+
+	ap = c.discoveryAuthorizationPolicy(instance)
+	_, err = c.Create(*ap)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			ap = nil
+			return
+		}
+	}
+
+	dr = c.discoveryDestinationRule(instance)
+	_, err = c.Create(*dr)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			dr = nil
+			return
+		}
+	}
+
+	ig = c.discoveryIngressGateway(instance)
+	_, err = c.Create(*ig)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			ig = nil
+			return
+		}
+	}
+
+	eg = c.discoveryEgressGateway(instance)
+	_, err = c.Create(*eg)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			return
+		}
+	}
+
+	vs = c.discoveryVirtualService(instance, meshConfig)
+	_, err = c.Create(*vs)
+	if err != nil {
+		if errors.Is(err, memoryStoreErrAlreadyExists) {
+			// XXX: We don't support upgrade, so ignore this for now
+			err = nil
+		} else {
+			vs = nil
+			return
+		}
+	}
+
+	return
+}
+
+func discoveryResourceName(instance *servicemeshv1alpha1.MeshFederation) string {
+	return fmt.Sprintf("federation-discovery-%s", instance.Name)
+}
+
+func discoveryEgressResourceName(instance *servicemeshv1alpha1.MeshFederation) string {
+	return fmt.Sprintf("%s-egress", discoveryResourceName(instance))
+}
+
+func discoveryIngressResourceName(instance *servicemeshv1alpha1.MeshFederation) string {
+	return fmt.Sprintf("%s-ingress", discoveryResourceName(instance))
+}
+
+func federationIngressLabels(instance *servicemeshv1alpha1.MeshFederation) map[string]string {
+	return map[string]string{
+		"service.istio.io/canonical-name": instance.Spec.Gateways.Ingress.Name,
+	}
+}
+
+func federationEgressLabels(instance *servicemeshv1alpha1.MeshFederation) map[string]string {
+	return map[string]string{
+		"service.istio.io/canonical-name": instance.Spec.Gateways.Egress.Name,
+	}
+}
+
+func serviceAddressPort(addr string) (string, string) {
+	portIndex := strings.Index(addr, ":")
+	if portIndex >= 0 {
+		return addr[:portIndex], addr[portIndex:]
+	}
+	return addr, "80"
+}
+
+func (c *Controller) discoveryHostname(base string) string {
+	return base + ".federation.dummy.domain"
+}
+
+func (c *Controller) discoveryService(instance *servicemeshv1alpha1.MeshFederation) *config.Config {
+	// This is used for routing out of the egress gateway, primarily to configure mtls for discovery and
+	// to give the gateway an endpoint to route to (i.e. it creates a cluster with an endpoint in the gateway).
+	// This should turn into a service entry for the other mesh's network.
+	name := discoveryResourceName(instance)
+	discoveryHost := instance.Spec.NetworkAddress
+	discoveryPort := common.DefaultDiscoveryPort
+	service := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+			Labels: map[string]string{
+				"topology.istio.io/network": fmt.Sprintf("network-%s", instance.Name),
+			},
+		},
+		Spec: &rawnetworking.ServiceEntry{
+			Hosts: []string{
+				c.discoveryHostname(name),
+			},
+			Location: rawnetworking.ServiceEntry_MESH_EXTERNAL,
+			Ports: []*rawnetworking.Port{
+				{
+					Name:       "https-discovery",
+					Number:     uint32(8188),
+					Protocol:   "HTTPS",
+					TargetPort: uint32(8188),
+				},
+			},
+			Resolution: rawnetworking.ServiceEntry_DNS,
+			Endpoints: []*rawnetworking.WorkloadEntry{
+				{
+					Address: discoveryHost,
+					Ports: map[string]uint32{
+						"https-discovery": uint32(discoveryPort),
+					},
+				},
+			},
+			ExportTo: []string{
+				".",
+			},
+		},
+	}
+	return service
+}
+
+func (c *Controller) discoveryIngressGateway(instance *servicemeshv1alpha1.MeshFederation) *config.Config {
+	// Gateway definition for handling inbound discovery requests
+	name := discoveryIngressResourceName(instance)
+	discoveryPort := common.DefaultDiscoveryPort
+	gateway := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+		},
+		Spec: &rawnetworking.Gateway{
+			Selector: federationIngressLabels(instance),
+			Servers: []*rawnetworking.Server{
+				{
+					Name: name,
+					Hosts: []string{
+						"*",
+					},
+					Port: &rawnetworking.Port{
+						Name:     "https-discovery",
+						Number:   uint32(discoveryPort),
+						Protocol: "HTTPS",
+					},
+					Tls: &rawnetworking.ServerTLSSettings{
+						Mode: rawnetworking.ServerTLSSettings_ISTIO_MUTUAL,
+					},
+				},
+			},
+		},
+	}
+	return gateway
+}
+
+func (c *Controller) discoveryEgressGateway(instance *servicemeshv1alpha1.MeshFederation) *config.Config {
+	// Gateway definition for routing outbound discovery.  This is used to terminate source mtls for discovery.
+	name := discoveryEgressResourceName(instance)
+	egressGatewayServiceName := fmt.Sprintf("%s.%s.svc.cluster.local", instance.Spec.Gateways.Egress.Name, instance.Namespace)
+	discoveryPort := common.DefaultDiscoveryPort
+	gateway := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+		},
+		Spec: &rawnetworking.Gateway{
+			Selector: federationEgressLabels(instance),
+			Servers: []*rawnetworking.Server{
+				{
+					Name: name,
+					Hosts: []string{
+						egressGatewayServiceName,
+					},
+					Port: &rawnetworking.Port{
+						// XXX: this will eventually be encrypted
+						Name:     "http-discovery",
+						Number:   uint32(discoveryPort),
+						Protocol: "HTTP",
+					},
+				},
+			},
+		},
+	}
+	return gateway
+}
+
+func (c *Controller) discoveryAuthorizationPolicy(instance *servicemeshv1alpha1.MeshFederation) *config.Config {
+	// AuthorizationPolicy used to restrict inbound discovery requests to known clients.
+	name := discoveryResourceName(instance)
+	discoveryPort := common.DefaultDiscoveryPort
+	ap := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+		},
+		Spec: &rawsecurity.AuthorizationPolicy{
+			Selector: &rawtype.WorkloadSelector{
+				MatchLabels: federationIngressLabels(instance),
+			},
+			Action: rawsecurity.AuthorizationPolicy_DENY,
+			Rules: []*rawsecurity.Rule{
+				{
+					From: []*rawsecurity.Rule_From{
+						{
+							Source: &rawsecurity.Source{
+								NotPrincipals: []string{
+									instance.Spec.Security.ClientID,
+								},
+							},
+						},
+					},
+					To: []*rawsecurity.Rule_To{
+						{
+							Operation: &rawsecurity.Operation{
+								Ports: []string{
+									strconv.FormatInt(int64(discoveryPort), 10),
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	return ap
+}
+
+func (c *Controller) discoveryVirtualService(
+	instance *servicemeshv1alpha1.MeshFederation, meshConfig *meshv1alpha1.MeshConfig) *config.Config {
+	// VirtualService used to route inbound and outbound discovery requests.
+	name := discoveryResourceName(instance)
+	istiodService, _ := serviceAddressPort(meshConfig.DefaultConfig.DiscoveryAddress)
+	if svcIndex := strings.LastIndex(istiodService, ".svc"); svcIndex >= 0 {
+		istiodService = istiodService[:svcIndex] + ".svc.cluster.local"
+	}
+	ingressGatewayName := fmt.Sprintf("%s/%s-ingress", instance.Namespace, name)
+	egressGatewayName := fmt.Sprintf("%s/%s-egress", instance.Namespace, name)
+	discoveryService := c.discoveryHostname(name)
+	discoveryHost := instance.Spec.NetworkAddress
+	discoveryPort := common.DefaultDiscoveryPort
+	vs := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+		},
+		Spec: &rawnetworking.VirtualService{
+			Hosts: []string{
+				"*",
+			},
+			Gateways: []string{
+				ingressGatewayName,
+				egressGatewayName,
+			},
+			ExportTo: []string{
+				".",
+			},
+			Http: []*rawnetworking.HTTPRoute{
+				{
+					// Outbound discovery requests
+					Name: fmt.Sprintf("%s-egress", name),
+					Match: []*rawnetworking.HTTPMatchRequest{
+						{
+							Gateways: []string{
+								egressGatewayName,
+							},
+							Headers: map[string]*rawnetworking.StringMatch{
+								"discovery-address": {
+									MatchType: &rawnetworking.StringMatch_Exact{
+										Exact: discoveryHost,
+									},
+								},
+							},
+							Port: uint32(discoveryPort),
+						},
+					},
+					Rewrite: &rawnetworking.HTTPRewrite{
+						// Allows us to get the correct endpoint for outbound
+						Authority: discoveryService,
+					},
+					Route: []*rawnetworking.HTTPRouteDestination{
+						{
+							Destination: &rawnetworking.Destination{
+								Host: discoveryService,
+								Port: &rawnetworking.PortSelector{
+									Number: uint32(discoveryPort),
+								},
+								// to configure mtls appropriately
+								Subset: name,
+							},
+						},
+					},
+				},
+				{
+					// inbound descovery /services/ requests
+					Name: fmt.Sprintf("%s-ingress-services", name),
+					Match: []*rawnetworking.HTTPMatchRequest{
+						{
+							Gateways: []string{
+								ingressGatewayName,
+							},
+							Port: uint32(discoveryPort),
+							Uri: &rawnetworking.StringMatch{
+								MatchType: &rawnetworking.StringMatch_Exact{
+									Exact: "/services/",
+								},
+							},
+						},
+					},
+					Rewrite: &rawnetworking.HTTPRewrite{
+						Authority: istiodService,
+						Uri:       "/services/" + instance.Name,
+					},
+					Route: []*rawnetworking.HTTPRouteDestination{
+						{
+							Destination: &rawnetworking.Destination{
+								Host: istiodService,
+								Port: &rawnetworking.PortSelector{
+									Number: uint32(discoveryPort),
+								},
+							},
+						},
+					},
+				},
+				{
+					// inbound discovery /watch requests
+					Name: fmt.Sprintf("%s-ingress-watch", name),
+					Match: []*rawnetworking.HTTPMatchRequest{
+						{
+							Gateways: []string{
+								ingressGatewayName,
+							},
+							Port: uint32(discoveryPort),
+							Uri: &rawnetworking.StringMatch{
+								MatchType: &rawnetworking.StringMatch_Exact{
+									Exact: "/watch",
+								},
+							},
+						},
+					},
+					Rewrite: &rawnetworking.HTTPRewrite{
+						Authority: istiodService,
+						Uri:       "/watch/" + instance.Name,
+					},
+					Route: []*rawnetworking.HTTPRouteDestination{
+						{
+							Destination: &rawnetworking.Destination{
+								Host: istiodService,
+								Port: &rawnetworking.PortSelector{
+									Number: uint32(discoveryPort),
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	return vs
+}
+
+func (c *Controller) discoveryDestinationRule(instance *servicemeshv1alpha1.MeshFederation) *config.Config {
+	// DestinationRule to configure mTLS for outbound discovery requests
+	name := discoveryResourceName(instance)
+	discoveryHost := c.discoveryHostname(name)
+	discoveryPort := common.DefaultDiscoveryPort
+	dr := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+		},
+		Spec: &rawnetworking.DestinationRule{
+			// the "fake" discovery service
+			Host: discoveryHost,
+			ExportTo: []string{
+				".",
+			},
+			Subsets: []*rawnetworking.Subset{
+				{
+					Name: name,
+					TrafficPolicy: &rawnetworking.TrafficPolicy{
+						PortLevelSettings: []*rawnetworking.TrafficPolicy_PortTrafficPolicy{
+							{
+								Port: &rawnetworking.PortSelector{
+									Number: uint32(discoveryPort),
+								},
+								Tls: &rawnetworking.ClientTLSSettings{
+									Mode: rawnetworking.ClientTLSSettings_ISTIO_MUTUAL,
+									Sni:  discoveryHost,
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	return dr
+}
diff --git a/pkg/servicemesh/federation/example/config-poc/README.txt b/pkg/servicemesh/federation/example/config-poc/README.txt
new file mode 100644
index 0000000000..97aa698df7
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/README.txt
@@ -0,0 +1,35 @@
+Everything can be setup by running ./install.sh.
+
+Once the install is complete, you'll need to install bookinfo into the following
+namespaces:
+  mesh1-bookinfo
+  mesh2-bookinfo
+
+Redirect to the aliased service through the egress gateway:
+You can redirect mesh2-bookinfo to use the ratings service in mesh1-bookinfo by
+modifying the mesh2-imports/ratings-aliased-mesh1 VirtualService.  Add the
+following to the list of hosts:
+    ratings.mesh2-bookinfo.svc.cluster.local
+and modify the mesh routing (gateway=mesh) to rewrite the authority to:
+    ratings-aliased.mesh1-exports.svc.cluster.local
+
+Redirect to the actual service using passthrough on both sides:
+Add the following VirtualService to mesh2.  If you've tested redirecting to the
+aliased service, make sure to remove the ratings.mesh2-bookinfo.svc.cluster.local
+from the hosts list in the mesh2-imports/ratings-aliased-mesh1 VirtualService.
+
+kind: VirtualService
+apiVersion: networking.istio.io/v1beta1
+metadata:
+  name: ratings-passthrough
+  namespace: mesh2-imports
+spec:
+  hosts:
+    - ratings.mesh2-bookinfo.svc.cluster.local
+  http:
+    - rewrite:
+        authority: ratings.mesh1-bookinfo.svc.cluster.local
+      route:
+        - destination:
+            host: ratings.mesh1-bookinfo.svc.cluster.local
+
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/README.md b/pkg/servicemesh/federation/example/config-poc/cacerts/README.md
new file mode 100644
index 0000000000..38621dfafd
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/README.md
@@ -0,0 +1,20 @@
+# Istio plugin CA sample certificates
+
+This directory contains sample pre-generated certificate and keys to demonstrate how an operator could configure Citadel with an existing root certificate, signing certificates and keys. In such
+a deployment, Citadel acts as an intermediate certificate authority (CA), under the given root CA.
+Instructions are available [here](https://istio.io/docs/tasks/security/cert-management/plugin-ca-cert/).
+
+The included sample files are:
+
+- `root-cert.pem`: root CA certificate.
+- `ca-[cert|key].pem`: Citadel intermediate certificate and corresponding private key.
+- `cert-chain.pem`: certificate trust chain.
+- `workload-foo-[cert|key].pem`: workload certificate and key for URI SAN `spiffe://trust-domain-foo/ns/foo/sa/foo` signed by `ca-cert.key`.
+- `workload-bar-[cert|key].pem`: workload certificate and key for URI SAN `spiffe://trust-domain-bar/ns/bar/sa/bar` signed by `ca-cert.key`.
+
+The workload cert and key are generated by:
+
+```shell script
+ ./generate-workload.sh foo
+ ./generate-workload.sh bar
+```
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/ca-cert.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/ca-cert.pem
new file mode 100644
index 0000000000..a460e036b3
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/ca-cert.pem
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDnzCCAoegAwIBAgIJAON1ifrBZ2/BMA0GCSqGSIb3DQEBCwUAMIGLMQswCQYD
+VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl
+MQ4wDAYDVQQKDAVJc3RpbzENMAsGA1UECwwEVGVzdDEQMA4GA1UEAwwHUm9vdCBD
+QTEiMCAGCSqGSIb3DQEJARYTdGVzdHJvb3RjYUBpc3Rpby5pbzAgFw0xODAxMjQx
+OTE1NTFaGA8yMTE3MTIzMTE5MTU1MVowWTELMAkGA1UEBhMCVVMxEzARBgNVBAgT
+CkNhbGlmb3JuaWExEjAQBgNVBAcTCVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8x
+ETAPBgNVBAMTCElzdGlvIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAyzCxr/xu0zy5rVBiso9ffgl00bRKvB/HF4AX9/ytmZ6Hqsy13XIQk8/u/By9
+iCvVwXIMvyT0CbiJq/aPEj5mJUy0lzbrUs13oneXqrPXf7ir3HzdRw+SBhXlsh9z
+APZJXcF93DJU3GabPKwBvGJ0IVMJPIFCuDIPwW4kFAI7R/8A5LSdPrFx6EyMXl7K
+M8jekC0y9DnTj83/fY72WcWX7YTpgZeBHAeeQOPTZ2KYbFal2gLsar69PgFS0Tom
+ESO9M14Yit7mzB1WDK2z9g3r+zLxENdJ5JG/ZskKe+TO4Diqi5OJt/h8yspS1ck8
+LJtCole9919umByg5oruflqIlQIDAQABozUwMzALBgNVHQ8EBAMCAgQwDAYDVR0T
+BAUwAwEB/zAWBgNVHREEDzANggtjYS5pc3Rpby5pbzANBgkqhkiG9w0BAQsFAAOC
+AQEAltHEhhyAsve4K4bLgBXtHwWzo6SpFzdAfXpLShpOJNtQNERb3qg6iUGQdY+w
+A2BpmSkKr3Rw/6ClP5+cCG7fGocPaZh+c+4Nxm9suMuZBZCtNOeYOMIfvCPcCS+8
+PQ/0hC4/0J3WJKzGBssaaMufJxzgFPPtDJ998kY8rlROghdSaVt423/jXIAYnP3Y
+05n8TGERBj7TLdtIVbtUIx3JHAo3PWJywA6mEDovFMJhJERp9sDHIr1BbhXK1TFN
+Z6HNH6gInkSSMtvC4Ptejb749PTaePRPF7ID//eq/3AH8UK50F3TQcLjEqWUsJUn
+aFKltOc+RAjzDklcUPeG4Y6eMA==
+-----END CERTIFICATE-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/ca-key.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/ca-key.pem
new file mode 100644
index 0000000000..faa77f3882
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/ca-key.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAyzCxr/xu0zy5rVBiso9ffgl00bRKvB/HF4AX9/ytmZ6Hqsy1
+3XIQk8/u/By9iCvVwXIMvyT0CbiJq/aPEj5mJUy0lzbrUs13oneXqrPXf7ir3Hzd
+Rw+SBhXlsh9zAPZJXcF93DJU3GabPKwBvGJ0IVMJPIFCuDIPwW4kFAI7R/8A5LSd
+PrFx6EyMXl7KM8jekC0y9DnTj83/fY72WcWX7YTpgZeBHAeeQOPTZ2KYbFal2gLs
+ar69PgFS0TomESO9M14Yit7mzB1WDK2z9g3r+zLxENdJ5JG/ZskKe+TO4Diqi5OJ
+t/h8yspS1ck8LJtCole9919umByg5oruflqIlQIDAQABAoIBAGZI8fnUinmd5R6B
+C941XG3XFs6GAuUm3hNPcUFuGnntmv/5I0gBpqSyFO0nDqYg4u8Jma8TTCIkmnFN
+ogIeFU+LiJFinR3GvwWzTE8rTz1FWoaY+M9P4ENd/I4pVLxUPuSKhfA2ChAVOupU
+8F7D9Q/dfBXQQCT3VoUaC+FiqjL4HvIhji1zIqaqpK7fChGPraC/4WHwLMNzI0Zg
+oDdAanwVygettvm6KD7AeKzhK94gX1PcnsOi3KuzQYvkenQE1M6/K7YtEc5qXCYf
+QETj0UCzB55btgdF36BGoZXf0LwHqxys9ubfHuhwKBpY0xg2z4/4RXZNhfIDih3w
+J3mihcECgYEA6FtQ0cfh0Zm03OPDpBGc6sdKxTw6aBDtE3KztfI2hl26xHQoeFqp
+FmV/TbnExnppw+gWJtwx7IfvowUD8uRR2P0M2wGctWrMpnaEYTiLAPhXsj69HSM/
+CYrh54KM0YWyjwNhtUzwbOTrh1jWtT9HV5e7ay9Atk3UWljuR74CFMUCgYEA392e
+DVoDLE0XtbysmdlfSffhiQLP9sT8+bf/zYnr8Eq/4LWQoOtjEARbuCj3Oq7bP8IE
+Vz45gT1mEE3IacC9neGwuEa6icBiuQi86NW8ilY/ZbOWrRPLOhk3zLiZ+yqkt+sN
+cqWx0JkIh7IMKWI4dVQgk4I0jcFP7vNG/So4AZECgYEA426eSPgxHQwqcBuwn6Nt
+yJCRq0UsljgbFfIr3Wfb3uFXsntQMZ3r67QlS1sONIgVhmBhbmARrcfQ0+xQ1SqO
+wqnOL4AAd8K11iojoVXLGYP7ssieKysYxKpgPE8Yru0CveE9fkx0+OGJeM2IO5hY
+qHAoTt3NpaPAuz5Y3XgqaVECgYA0TONS/TeGjxA9/jFY1Cbl8gp35vdNEKKFeM5D
+Z7h+cAg56FE8tyFyqYIAGVoBFL7WO26mLzxiDEUfA/0Rb90c2JBfzO5hpleqIPd5
+cg3VR+cRzI4kK16sWR3nLy2SN1k6OqjuovVS5Z3PjfI3bOIBz0C5FY9Pmt0g1yc7
+mDRzcQKBgQCXWCZStbdjewaLd5u5Hhbw8tIWImMVfcfs3H1FN669LLpbARM8RtAa
+8dYwDVHmWmevb/WX03LiSE+GCjCBO79fa1qc5RKAalqH/1OYxTuvYOeTUebSrg8+
+lQFlP2OC4GGolKrN6HVWdxtf+F+SdjwX6qGCfYkXJRLYXIFSFjFeuw==
+-----END RSA PRIVATE KEY-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/cert-chain.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/cert-chain.pem
new file mode 100644
index 0000000000..a460e036b3
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/cert-chain.pem
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDnzCCAoegAwIBAgIJAON1ifrBZ2/BMA0GCSqGSIb3DQEBCwUAMIGLMQswCQYD
+VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl
+MQ4wDAYDVQQKDAVJc3RpbzENMAsGA1UECwwEVGVzdDEQMA4GA1UEAwwHUm9vdCBD
+QTEiMCAGCSqGSIb3DQEJARYTdGVzdHJvb3RjYUBpc3Rpby5pbzAgFw0xODAxMjQx
+OTE1NTFaGA8yMTE3MTIzMTE5MTU1MVowWTELMAkGA1UEBhMCVVMxEzARBgNVBAgT
+CkNhbGlmb3JuaWExEjAQBgNVBAcTCVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8x
+ETAPBgNVBAMTCElzdGlvIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAyzCxr/xu0zy5rVBiso9ffgl00bRKvB/HF4AX9/ytmZ6Hqsy13XIQk8/u/By9
+iCvVwXIMvyT0CbiJq/aPEj5mJUy0lzbrUs13oneXqrPXf7ir3HzdRw+SBhXlsh9z
+APZJXcF93DJU3GabPKwBvGJ0IVMJPIFCuDIPwW4kFAI7R/8A5LSdPrFx6EyMXl7K
+M8jekC0y9DnTj83/fY72WcWX7YTpgZeBHAeeQOPTZ2KYbFal2gLsar69PgFS0Tom
+ESO9M14Yit7mzB1WDK2z9g3r+zLxENdJ5JG/ZskKe+TO4Diqi5OJt/h8yspS1ck8
+LJtCole9919umByg5oruflqIlQIDAQABozUwMzALBgNVHQ8EBAMCAgQwDAYDVR0T
+BAUwAwEB/zAWBgNVHREEDzANggtjYS5pc3Rpby5pbzANBgkqhkiG9w0BAQsFAAOC
+AQEAltHEhhyAsve4K4bLgBXtHwWzo6SpFzdAfXpLShpOJNtQNERb3qg6iUGQdY+w
+A2BpmSkKr3Rw/6ClP5+cCG7fGocPaZh+c+4Nxm9suMuZBZCtNOeYOMIfvCPcCS+8
+PQ/0hC4/0J3WJKzGBssaaMufJxzgFPPtDJ998kY8rlROghdSaVt423/jXIAYnP3Y
+05n8TGERBj7TLdtIVbtUIx3JHAo3PWJywA6mEDovFMJhJERp9sDHIr1BbhXK1TFN
+Z6HNH6gInkSSMtvC4Ptejb749PTaePRPF7ID//eq/3AH8UK50F3TQcLjEqWUsJUn
+aFKltOc+RAjzDklcUPeG4Y6eMA==
+-----END CERTIFICATE-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/generate-workload.sh b/pkg/servicemesh/federation/example/config-poc/cacerts/generate-workload.sh
new file mode 100755
index 0000000000..e3befaf565
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/generate-workload.sh
@@ -0,0 +1,65 @@
+#!/bin/bash
+#
+# Copyright Istio Authors
+#
+#   Licensed under the Apache License, Version 2.0 (the "License");
+#   you may not use this file except in compliance with the License.
+#   You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#   Unless required by applicable law or agreed to in writing, software
+#   distributed under the License is distributed on an "AS IS" BASIS,
+#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#   See the License for the specific language governing permissions and
+#   limitations under the License.
+
+name=${1:-foo}
+ns=${2:-$name}
+sa=${3:-$name}
+tmp=${4:-""}
+san="spiffe://trust-domain-$name/ns/$ns/sa/$sa"
+
+DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+
+if [ ! -d "$DIR/$tmp" ]; then
+  mkdir "$DIR/$tmp"
+fi
+
+openssl genrsa -out "$DIR/$tmp/workload-$name-key.pem" 2048
+
+cat > "$DIR"/workload.cfg <<EOF
+[req]
+distinguished_name = req_distinguished_name
+req_extensions = v3_req
+x509_extensions = v3_req
+prompt = no
+[req_distinguished_name]
+countryName = US
+[v3_req]
+keyUsage = critical, digitalSignature, keyEncipherment
+extendedKeyUsage = serverAuth, clientAuth
+basicConstraints = critical, CA:FALSE
+subjectAltName = critical, @alt_names
+[alt_names]
+URI = $san
+EOF
+
+openssl req -new -key "$DIR/$tmp/workload-$name-key.pem" -subj "/" -out "$DIR"/workload.csr -config "$DIR"/workload.cfg
+
+openssl x509 -req -in "$DIR"/workload.csr -CA "$DIR"/ca-cert.pem -CAkey "$DIR"/ca-key.pem -CAcreateserial \
+-out "$DIR/$tmp/workload-$name-cert.pem" -days 3650 -extensions v3_req -extfile "$DIR"/workload.cfg
+
+cat "$DIR"/cert-chain.pem >> "$DIR/$tmp/workload-$name-cert.pem"
+
+echo "Generated workload-$name-[cert|key].pem with URI SAN $san"
+openssl verify -CAfile <(cat "$DIR"/cert-chain.pem "$DIR"/root-cert.pem) "$DIR/$tmp/workload-$name-cert.pem"
+
+# clean temporary files
+if [ -f "$DIR"/.srl ]; then
+  rm "$DIR"/.srl
+fi
+if [ -f "$DIR"/ca-cert.srl ]; then
+  rm "$DIR"/ca-cert.srl
+fi
+rm "$DIR"/workload.cfg "$DIR"/workload.csr
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/root-cert.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/root-cert.pem
new file mode 100644
index 0000000000..64c3fd50cb
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/root-cert.pem
@@ -0,0 +1,24 @@
+-----BEGIN CERTIFICATE-----
+MIID7TCCAtWgAwIBAgIJAOIRDhOcxsx6MA0GCSqGSIb3DQEBCwUAMIGLMQswCQYD
+VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl
+MQ4wDAYDVQQKDAVJc3RpbzENMAsGA1UECwwEVGVzdDEQMA4GA1UEAwwHUm9vdCBD
+QTEiMCAGCSqGSIb3DQEJARYTdGVzdHJvb3RjYUBpc3Rpby5pbzAgFw0xODAxMjQx
+OTE1NTFaGA8yMTE3MTIzMTE5MTU1MVowgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQI
+DApDYWxpZm9ybmlhMRIwEAYDVQQHDAlTdW5ueXZhbGUxDjAMBgNVBAoMBUlzdGlv
+MQ0wCwYDVQQLDARUZXN0MRAwDgYDVQQDDAdSb290IENBMSIwIAYJKoZIhvcNAQkB
+FhN0ZXN0cm9vdGNhQGlzdGlvLmlvMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
+CgKCAQEA38uEfAatzQYqbaLou1nxJ348VyNzumYMmDDt5pbLYRrCo2pS3ki1ZVDN
+8yxIENJFkpKw9UctTGdbNGuGCiSDP7uqF6BiVn+XKAU/3pnPFBbTd0S33NqbDEQu
+IYraHSl/tSk5rARbC1DrQRdZ6nYD2KrapC4g0XbjY6Pu5l4y7KnFwSunnp9uqpZw
+uERv/BgumJ5QlSeSeCmhnDhLxooG8w5tC2yVr1yDpsOHGimP/mc8Cds4V0zfIhQv
+YzfIHphhE9DKjmnjBYLOdj4aycv44jHnOGc+wvA1Jqsl60t3wgms+zJTiWwABLdw
+zgMAa7yxLyoV0+PiVQud6k+8ZoIFcwIDAQABo1AwTjAdBgNVHQ4EFgQUOUYGtUyh
+euxO4lGe4Op1y8NVoagwHwYDVR0jBBgwFoAUOUYGtUyheuxO4lGe4Op1y8NVoagw
+DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEANXLyfAs7J9rmBamGJvPZ
+ltx390WxzzLFQsBRAaH6rgeipBq3dR9qEjAwb6BTF+ROmtQzX+fjstCRrJxCto9W
+tC8KvXTdRfIjfCCZjhtIOBKqRxE4KJV/RBfv9xD5lyjtCPCQl3Ia6MSf42N+abAK
+WCdU6KCojA8WB9YhSCzza3aQbPTzd26OC/JblJpVgtus5f8ILzCsz+pbMimgTkhy
+AuhYRppJaQ24APijsEC9+GIaVKPg5IwWroiPoj+QXNpshuvqVQQXvGaRiq4zoSnx
+xAJz+w8tjrDWcf826VN14IL+/Cmqlg/rIfB5CHdwVIfWwpuGB66q/UiPegZMNs8a
+3g==
+-----END CERTIFICATE-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-cert.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-cert.pem
new file mode 100644
index 0000000000..c614ffc385
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-cert.pem
@@ -0,0 +1,43 @@
+-----BEGIN CERTIFICATE-----
+MIIDXTCCAkWgAwIBAgIUBn+v5JAoezzNx9s3Euvzlny0LWcwDQYJKoZIhvcNAQEL
+BQAwWTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcT
+CVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8xETAPBgNVBAMTCElzdGlvIENBMB4X
+DTIwMDgxNDIyMTA1M1oXDTMwMDgxMjIyMTA1M1owADCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBAMD18u/U1ouLwc2VblyFQCDN7XdGODoLV2eYA3NQrzMv
+0873zS5wbvte2eRc+MX9jnwg8rW+Won7KUaEzD62a9QZv5ilO1137YUBZrTgQIkO
+bhOnmpJRmR3Cxck8ZTEBMFsM+xyGAGc8ptdGJjEuxifFJHT3IB0ibXsnYuHnzpj1
+totq3sIPTRSkjsSOnKpyaOfBFiAyDQ0Rnm4+O32cJ654l0Co6iRABTnO9vIq1Tjn
+fQm6+F99w3Wvv9Ik8HxB4HBLZ3+qgXQIJOD+d5+z88OnsiEMYKO4XHy2D/OAh9ND
+7i9lzr+wXLYb5H1+TcEJuHFTHQcsm5YCl/zFt4YHgX0CAwEAAaN2MHQwDgYDVR0P
+AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB
+Af8EAjAAMDUGA1UdEQEB/wQrMCmGJ3NwaWZmZTovL3RydXN0LWRvbWFpbi1iYXIv
+bnMvYmFyL3NhL2JhcjANBgkqhkiG9w0BAQsFAAOCAQEAGAWE6bLO4L8fDFg2hVCJ
+G+8uTVVeO2H8wFiDOqB0xq9OCrzSp39cZsBZLj9KFBWx/V0PEAlcmGlgHozdGkVG
+Z1/B+ukeRgALYBmHgOegoC2zHOz5qacqiRnV8Kijxa6nFyU0qbJCFVWs76DSZZDm
+872SMmoURs2VrAQTWInbtWxR4tAyEdmecYOdHEIXQDc13LQSwu7TINLs7JnjKlv7
+xIv6TsOyAyx305DSK0htxYfgrvo4cc33JmDOtL81bHfyUfx2B8HKeDYTaDh+V01G
+OesJNzqECzW6IMMFJey0f/4W7hbldpZmgXs8qa/g1CR8pCRs2eTWKTS336glXLCG
+MA==
+-----END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDnzCCAoegAwIBAgIJAON1ifrBZ2/BMA0GCSqGSIb3DQEBCwUAMIGLMQswCQYD
+VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl
+MQ4wDAYDVQQKDAVJc3RpbzENMAsGA1UECwwEVGVzdDEQMA4GA1UEAwwHUm9vdCBD
+QTEiMCAGCSqGSIb3DQEJARYTdGVzdHJvb3RjYUBpc3Rpby5pbzAgFw0xODAxMjQx
+OTE1NTFaGA8yMTE3MTIzMTE5MTU1MVowWTELMAkGA1UEBhMCVVMxEzARBgNVBAgT
+CkNhbGlmb3JuaWExEjAQBgNVBAcTCVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8x
+ETAPBgNVBAMTCElzdGlvIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAyzCxr/xu0zy5rVBiso9ffgl00bRKvB/HF4AX9/ytmZ6Hqsy13XIQk8/u/By9
+iCvVwXIMvyT0CbiJq/aPEj5mJUy0lzbrUs13oneXqrPXf7ir3HzdRw+SBhXlsh9z
+APZJXcF93DJU3GabPKwBvGJ0IVMJPIFCuDIPwW4kFAI7R/8A5LSdPrFx6EyMXl7K
+M8jekC0y9DnTj83/fY72WcWX7YTpgZeBHAeeQOPTZ2KYbFal2gLsar69PgFS0Tom
+ESO9M14Yit7mzB1WDK2z9g3r+zLxENdJ5JG/ZskKe+TO4Diqi5OJt/h8yspS1ck8
+LJtCole9919umByg5oruflqIlQIDAQABozUwMzALBgNVHQ8EBAMCAgQwDAYDVR0T
+BAUwAwEB/zAWBgNVHREEDzANggtjYS5pc3Rpby5pbzANBgkqhkiG9w0BAQsFAAOC
+AQEAltHEhhyAsve4K4bLgBXtHwWzo6SpFzdAfXpLShpOJNtQNERb3qg6iUGQdY+w
+A2BpmSkKr3Rw/6ClP5+cCG7fGocPaZh+c+4Nxm9suMuZBZCtNOeYOMIfvCPcCS+8
+PQ/0hC4/0J3WJKzGBssaaMufJxzgFPPtDJ998kY8rlROghdSaVt423/jXIAYnP3Y
+05n8TGERBj7TLdtIVbtUIx3JHAo3PWJywA6mEDovFMJhJERp9sDHIr1BbhXK1TFN
+Z6HNH6gInkSSMtvC4Ptejb749PTaePRPF7ID//eq/3AH8UK50F3TQcLjEqWUsJUn
+aFKltOc+RAjzDklcUPeG4Y6eMA==
+-----END CERTIFICATE-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-key.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-key.pem
new file mode 100644
index 0000000000..bc11603b99
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-bar-key.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAwPXy79TWi4vBzZVuXIVAIM3td0Y4OgtXZ5gDc1CvMy/TzvfN
+LnBu+17Z5Fz4xf2OfCDytb5aifspRoTMPrZr1Bm/mKU7XXfthQFmtOBAiQ5uE6ea
+klGZHcLFyTxlMQEwWwz7HIYAZzym10YmMS7GJ8UkdPcgHSJteydi4efOmPW2i2re
+wg9NFKSOxI6cqnJo58EWIDINDRGebj47fZwnrniXQKjqJEAFOc728irVOOd9Cbr4
+X33Dda+/0iTwfEHgcEtnf6qBdAgk4P53n7Pzw6eyIQxgo7hcfLYP84CH00PuL2XO
+v7BcthvkfX5NwQm4cVMdByyblgKX/MW3hgeBfQIDAQABAoIBAQCKn6bZ2YQQWGTw
+tsvEOA5sAsT4jT/To1Y1nCXOcEaNdWyrIacMF8YDXI8Y2hn200PLtTfojUoqGn/6
+o2jAHPm2NJFKrlnJumCuzuTkSL7UN8Oo5x3KxEhF8yl4eqUP4ZTFtLuqMDKV+CK8
+QS8q4jmFVMHuLaOqipMwiIknVgs8IvmQSZf3LBPOLRX9vcTtT0YnOAhFQjb3048s
+Da+pDSsKesVkcsTx9aw4pUHWcLFuDHxZ1f0hAXcOfkzjzuBkQ0uoUxSIE+kcA2i0
+9vZB7fSqL/5zKrKooDSjW189WHd8wMEtmGZW6VDeH0fMuC+KWEVZnyjMrrlCMesJ
+MismTSABAoGBAPD2XAf01iMy4Y84XtI4vku0uO+pseyhZ2nyqLJW2q3M0bXKFMiD
+jiE7GlxBjynZFfU5R/H7QJ3rDwH4PpKyd13mgnlUImyLTUVaSbC3Bu0rJ+NFLtsQ
+7OCxi4F3pOvOAWUL5WJc0gyqmSBywoGFuCT1x0wch2si1/XGUH973EwBAoGBAM0A
+te01yywQ+X17fApIh/R+LLPkORecpDJgC3vTcMvuvC9Rq1HEC4S4b7X0SfrUzvCw
+BO+J3KUMBJXHC2S4VsWBn/jHA8vJ1RD11gDVUV776WLxhXiBekwneFyFlNUukkTa
+2bcnM3vtXZBl8z8Fhddfo5i9MR0Wh6jXF3HpemV9AoGAW1k6CHYkHBH0+sOnBtEm
+KzMnDQxq/EcwGjU5COruWgcU1XL3sBBXeHecha8A5B99OIrvoGfc1kE/XkLLDfgE
+Up/JhM+FgVrJ/2m8F/c68/xxUbJvkfL3qjMErR87cX2Wf8Ujv8dqhgzCok9/N3UH
+G1PlqxABsnbyIiV9bOb63AECgYEAqbsd5YF1b026k3dK8uSsk/RnpKWf03ngxMia
+mXIt4NsPugnfU3qCoudlrnvNSL0rfUHvRDibk5dIsI21VDX/udUiEwMLlI3OOBWi
+ktwLXB4sVLxtaqGhFS5UzB3ZZUwC1LlyKt9tE/0qS2Ttqc8zymcn900lPdUqitNT
+WQAbU60CgYBsR9gyXA4SXFjKmk5WKFhHlvTf87UfaOrPeeDE7zeEo2iVgjq9gSHw
+7zBaiVvrwcSn3COszrPgtOUM+Vl/T7Z2QmPTteP2R8mKxOJk4BWQ5q/bhoc3sEH7
+EjR9twDPRg3V9xEKtcTiJhzm4TitKGYBH8FQ22B4X6mouVE8KfXkyA==
+-----END RSA PRIVATE KEY-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-cert.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-cert.pem
new file mode 100644
index 0000000000..e3697421be
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-cert.pem
@@ -0,0 +1,43 @@
+-----BEGIN CERTIFICATE-----
+MIIDXTCCAkWgAwIBAgIUKR+dap3TpKhxmpwtNLchLa7E4JEwDQYJKoZIhvcNAQEL
+BQAwWTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcT
+CVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8xETAPBgNVBAMTCElzdGlvIENBMB4X
+DTIwMDgxNDIyMTA0OVoXDTMwMDgxMjIyMTA0OVowADCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBAM3y5xVP1qYDsy4DSEG7eXhQEGL/XUbXOR1kTEXTAhAk
+/Wo0YclowxRQuIyeXpLM+nRN2z0xDttkMRpI0m6Qb1vK43XtPkBieVm/tBSUyis+
+iBV6KBOhw7ionoAlyq6tOkwL2V3siMK5LvkpeeC7lJPJamaRN19LJcnWS214bcur
+lq6g6+owQGb4BS4STqfiRkIciw7MHTN5vWQcNmWNT3ME19KNQGKLXPkJGJoNlq4P
+98pIuO58k0mow8xESpmrJ1zOtMtUUDicXV67m8BV2xkn7YLDehfAyKsqMJjsdWB3
+LUlk/kFia9n/AwFz+3mMSPWe4OnRQGdtwUMuanknfSUCAwEAAaN2MHQwDgYDVR0P
+AQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMB
+Af8EAjAAMDUGA1UdEQEB/wQrMCmGJ3NwaWZmZTovL3RydXN0LWRvbWFpbi1mb28v
+bnMvZm9vL3NhL2ZvbzANBgkqhkiG9w0BAQsFAAOCAQEAO3Rcr/CEnEieuKujrQ/j
+ZrM5cjQckt/+NcpkXsTQaqpkARmUL23D/g3Cg3P9rfJVIfSIfN2509meX+ouDzIm
+JWoFW3XVFLiev18aBBO6rmLaMMMKiVOZYAYzeM8Zt/3qH8mLxNq2CQYUL8EtAd7V
+P1FVx6vauFqlyqPn2BWZO3CgdGyPwPRQkBUTrItcUI8OTgAFYd/Q5vQuLt82QIAl
+givsPvGaKEWV02tpf8PfAZDgXrFkJLeFhFd0pgf7RSIdvShNdPyyz4r9/2CqEVmc
+BRDyTw09OLceF0Mhi4HqcnzgVeLWvWT+yUo3FYf6kzeavK93CEdSU8c9OvQbyi9D
+cQ==
+-----END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDnzCCAoegAwIBAgIJAON1ifrBZ2/BMA0GCSqGSIb3DQEBCwUAMIGLMQswCQYD
+VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl
+MQ4wDAYDVQQKDAVJc3RpbzENMAsGA1UECwwEVGVzdDEQMA4GA1UEAwwHUm9vdCBD
+QTEiMCAGCSqGSIb3DQEJARYTdGVzdHJvb3RjYUBpc3Rpby5pbzAgFw0xODAxMjQx
+OTE1NTFaGA8yMTE3MTIzMTE5MTU1MVowWTELMAkGA1UEBhMCVVMxEzARBgNVBAgT
+CkNhbGlmb3JuaWExEjAQBgNVBAcTCVN1bm55dmFsZTEOMAwGA1UEChMFSXN0aW8x
+ETAPBgNVBAMTCElzdGlvIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAyzCxr/xu0zy5rVBiso9ffgl00bRKvB/HF4AX9/ytmZ6Hqsy13XIQk8/u/By9
+iCvVwXIMvyT0CbiJq/aPEj5mJUy0lzbrUs13oneXqrPXf7ir3HzdRw+SBhXlsh9z
+APZJXcF93DJU3GabPKwBvGJ0IVMJPIFCuDIPwW4kFAI7R/8A5LSdPrFx6EyMXl7K
+M8jekC0y9DnTj83/fY72WcWX7YTpgZeBHAeeQOPTZ2KYbFal2gLsar69PgFS0Tom
+ESO9M14Yit7mzB1WDK2z9g3r+zLxENdJ5JG/ZskKe+TO4Diqi5OJt/h8yspS1ck8
+LJtCole9919umByg5oruflqIlQIDAQABozUwMzALBgNVHQ8EBAMCAgQwDAYDVR0T
+BAUwAwEB/zAWBgNVHREEDzANggtjYS5pc3Rpby5pbzANBgkqhkiG9w0BAQsFAAOC
+AQEAltHEhhyAsve4K4bLgBXtHwWzo6SpFzdAfXpLShpOJNtQNERb3qg6iUGQdY+w
+A2BpmSkKr3Rw/6ClP5+cCG7fGocPaZh+c+4Nxm9suMuZBZCtNOeYOMIfvCPcCS+8
+PQ/0hC4/0J3WJKzGBssaaMufJxzgFPPtDJ998kY8rlROghdSaVt423/jXIAYnP3Y
+05n8TGERBj7TLdtIVbtUIx3JHAo3PWJywA6mEDovFMJhJERp9sDHIr1BbhXK1TFN
+Z6HNH6gInkSSMtvC4Ptejb749PTaePRPF7ID//eq/3AH8UK50F3TQcLjEqWUsJUn
+aFKltOc+RAjzDklcUPeG4Y6eMA==
+-----END CERTIFICATE-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-key.pem b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-key.pem
new file mode 100644
index 0000000000..bfad4d4cde
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cacerts/workload-foo-key.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAzfLnFU/WpgOzLgNIQbt5eFAQYv9dRtc5HWRMRdMCECT9ajRh
+yWjDFFC4jJ5eksz6dE3bPTEO22QxGkjSbpBvW8rjde0+QGJ5Wb+0FJTKKz6IFXoo
+E6HDuKiegCXKrq06TAvZXeyIwrku+Sl54LuUk8lqZpE3X0slydZLbXhty6uWrqDr
+6jBAZvgFLhJOp+JGQhyLDswdM3m9ZBw2ZY1PcwTX0o1AYotc+QkYmg2Wrg/3yki4
+7nyTSajDzERKmasnXM60y1RQOJxdXrubwFXbGSftgsN6F8DIqyowmOx1YHctSWT+
+QWJr2f8DAXP7eYxI9Z7g6dFAZ23BQy5qeSd9JQIDAQABAoIBAQDLs7PpGnze284A
+dvKjQYFWBSsQIDDsfrhZX/kpHxptSYj14TXPdzVtBKJlQ8ebP++B1fhBwCJH0gPX
+UawB/A6JJlZxL+Vg3YXVxY2ixcBpoYIMbDTzpg7muLF9YuPkfiapTRcElY53u57A
+h8urAx5kRtZc+MliEfwgdTtJ3dILnbXxGanKfi+nz9P5YuLkKzqIolbqu9ZxlJFD
+/V4DKITA0IootE0OhCKP0GfeA6L9z3tH2OuEn/LXl2S8FbbFCeY4ji8FQBr2icSB
+pXdee0gYIrvrU8G0eoE0ZV9bAGXkRhA3057HF9RqlAqhRc012s4ojbl/q4uINdWp
+R+UiUecJAoGBAP4Pzo+NwS054kOgSYu+NMSi63j2OJD9aeHYJT6QwVYZurTMChxx
+x283Da4qsCBGI37YjU5Ygd6DYc0T57GXfeka8tZQb5+v/ZvV1oIY+pVN5cp0xben
+Ttm0qskF2H57TmPcH5atWkW7b5CjrSo7DYFtd6jKzzoAJ9uPH4DCM5ufAoGBAM+F
+IRkSmzAPpiyPA1P7OlWy0vQLsNrFwZ59HOmovpQTgDLVW5Xbq+etEiAXmSvuxBU0
+OKiHMgGK2Pmg/vsM3mUVskrx+bDk+6GGM52feqa8N1rtxDTjamI5EHx29896jX/U
+HGSW+8YYVZ/jbSSneY71AO1E2INsNEi1Ei5qWTC7AoGABOdnNEwnK2lPncCNSt48
+BIOkiewuwVWy4oIaje+bW78ZZH3/v/bOQ65LXE5EogrYio1BhP6eWx4sGBpHQZ1L
+9+DmSQ66aNmryoNBJbe3toQPaG4Clv3qvrcHCORM/nwA0lqgXXcxI+FvUNpn8EW9
+h/8F7UMk5tiz7EAB+qlE978CgYAJBj8UOgzpoCSX13hLlKdKxsYJuuBsAyGSZNp3
+BtGS2u4+R6z97Vmib5JUNvKASJfaXDUCjy6LhqA86tVr0XlyZ+ki/TbgjHSs54sj
+FaZdzd2SZLidnC4qK1UeNIY+TZQNtQmvDinQyYofs+IxL99HajwqFU5dGL2FU+qA
+fjt2tQKBgQDrnpSRmAhhGcazmNVnzF8PVJGPwY4clGKB2jo6ru57tL0QRc/N+5pJ
+8boLB7CqRpC0mHpijJLKkLoJ0oVoC9jsn3e8tfVuVqbO3AfwdB+nkABQVHRxRRGt
+AlUeHXbjlY7OpemfK3smhLGBoOZKJVL7cKwyJc5MTPjcUgMwlwbW5w==
+-----END RSA PRIVATE KEY-----
diff --git a/pkg/servicemesh/federation/example/config-poc/cleanup.sh b/pkg/servicemesh/federation/example/config-poc/cleanup.sh
new file mode 100755
index 0000000000..02ae38baad
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/cleanup.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Copyright Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http:#www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+oc delete -n mesh1-system meshfederation/mesh2
+oc delete -n mesh2-system meshfederation/mesh1
+
+oc delete project mesh1-system
+oc delete project mesh2-system
+# oc delete project mesh1-exports
+# oc delete project mesh2-imports
+oc delete project mesh1-bookinfo
+oc delete project mesh2-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-direct.yaml b/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-direct.yaml
new file mode 100644
index 0000000000..8f3da945ca
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-direct.yaml
@@ -0,0 +1,52 @@
+# AuthorizationPolicy resources that apply when ingress gateway is using
+# AUTO_PASSTHROUGH.  In these cases, the gateway does not authenticate, so
+# the policy cannot match against principals.  Note, if proxying on the import
+# side, the egress gateway's principal should be used instead of the workload's.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: mongodb-authz
+  namespace: mesh1-bookinfo
+spec:
+  action: ALLOW
+  selector:
+    matchLabels:
+      app: mongodb
+  rules:
+    - from:
+        - source:
+            principals:
+              - cluster.local/ns/mesh2-bookinfo/sa/bookinfo-ratings-v2
+      to:
+        - operation:
+            ports:
+              - '27017'
+      when:
+        - key: connection.sni
+          values:
+            - '*.mongodb.mesh1-exports.svc.cluster.local'
+
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: ratings-authz
+  namespace: mesh1-bookinfo
+spec:
+  action: ALLOW
+  selector:
+    matchLabels:
+      app: ratings
+  rules:
+    - from:
+        - source:
+            principals:
+              - cluster.local/ns/mesh2-bookinfo/sa/bookinfo-reviews-v2
+      to:
+        - operation:
+            hosts:
+              - '*.ratings.mesh1-bookinfo.svc.local'
+            ports:
+              - '9080'
diff --git a/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-proxied.yaml b/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-proxied.yaml
new file mode 100644
index 0000000000..58f5c367b7
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/examples/authorizationpolicy-direct-to-proxied.yaml
@@ -0,0 +1,38 @@
+# These work when using aliased services.  In these cases, the gateway
+# performs authentication, so principals can be checked.  Note, if using
+# passthrough on the import side, the principals should match the client
+# workloads, e.g. cluster.local/ns/mesh2-bookinfo/sa/bookinfo-ratings-v2 for
+# mongodb-aliased.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: aliased-authz
+  namespace: mesh1-exports
+spec:
+  action: ALLOW
+  rules:
+    - from:
+        - source:
+            principals:
+              - cluster.local/ns/mesh2-bookinfo/sa/bookinfo-ratings-v2
+      to:
+        - operation:
+            ports:
+              - "27017"
+      when:
+        - key: connection.sni
+          values:
+            - "*.mongodb.bookinfo.svc.mesh2.local"
+    - from:
+        - source:
+            principals:
+              - cluster.local/ns/mesh2-bookinfo/sa/bookinfo-reviews-v2
+      to:
+        - operation:
+            ports:
+              - "9080"
+      when:
+        - key: connection.sni
+          values:
+            - "*.ratings.bookinfo.svc.mesh2.local"
diff --git a/pkg/servicemesh/federation/example/config-poc/examples/mongodb-remote-virtualservice.yaml b/pkg/servicemesh/federation/example/config-poc/examples/mongodb-remote-virtualservice.yaml
new file mode 100644
index 0000000000..2445fe8a58
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/examples/mongodb-remote-virtualservice.yaml
@@ -0,0 +1,15 @@
+# VirtualService resource that redirects the local service to the remote
+# services.  This only works with passthrough.
+
+kind: VirtualService
+apiVersion: networking.istio.io/v1alpha3
+metadata:
+  name: mongodb-remote
+  namespace: mesh2-bookinfo
+spec:
+  hosts:
+    - mongodb.mesh2-bookinfo.svc.cluster.local
+  tcp:
+    - route:
+        - destination:
+            host: mongodb.bookinfo.svc.mesh1.local
diff --git a/pkg/servicemesh/federation/example/config-poc/examples/ratings-split-virtualservice.yaml b/pkg/servicemesh/federation/example/config-poc/examples/ratings-split-virtualservice.yaml
new file mode 100644
index 0000000000..69153bf88c
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/examples/ratings-split-virtualservice.yaml
@@ -0,0 +1,19 @@
+# VirtualService resource that redirects the local service to the remote
+# services.  This only works with passthrough.
+
+kind: VirtualService
+apiVersion: networking.istio.io/v1alpha3
+metadata:
+  name: ratings-split
+  namespace: mesh2-bookinfo
+spec:
+  hosts:
+    - ratings.mesh2-bookinfo.svc.cluster.local
+  http:
+    - route:
+        - destination:
+            host: ratings.bookinfo.svc.mesh1.local
+          weight: 50
+        - destination:
+            host: ratings.mesh2-bookinfo.svc.cluster.local
+          weight: 50
diff --git a/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml b/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
new file mode 100644
index 0000000000..ac9df3375b
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
@@ -0,0 +1,14 @@
+apiVersion: maistra.io/v1alpha1
+kind: MeshFederation
+metadata:
+  name: mesh2
+  namespace: mesh1-system
+spec:
+  networkAddress: federation-ingress.mesh2-system.svc.cluster.local
+  gateways:
+    ingress:
+      name: federation-ingress
+    egress:
+      name: federation-egress
+  security:
+    clientID: cluster.local/ns/mesh2-system/sa/federation-egress-service-account
diff --git a/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml b/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
new file mode 100644
index 0000000000..09ecbe5d61
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
@@ -0,0 +1,23 @@
+apiVersion: maistra.io/v1alpha1
+kind: ServiceExports
+metadata:
+  name: mesh2
+  namespace: mesh1-system
+spec:
+  exports:
+  - type: Name
+    nameSelector:
+      name:
+        namespace: mesh1-bookinfo
+        name: ratings
+      alias:
+        namespace: bookinfo
+        name: ratings
+  - type: Name
+    nameSelector:
+      name:
+        namespace: mesh1-bookinfo
+        name: mongodb
+      alias:
+        namespace: bookinfo
+        name: mongodb
diff --git a/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml b/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
new file mode 100644
index 0000000000..6656049665
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
@@ -0,0 +1,85 @@
+apiVersion: maistra.io/v2
+kind: ServiceMeshControlPlane
+metadata:
+  name: fed-export
+  namespace: mesh1-system
+spec:
+  version: v2.1
+  cluster:
+    name: cluster1
+    network: network1
+  runtime:
+    defaults:
+      container:
+        imagePullPolicy: Always
+  addons:
+    grafana:
+      enabled: true
+    kiali:
+      enabled: true
+  tracing:
+    type: Jaeger
+    sampling: 10000
+  proxy:
+    accessLogging:
+      file:
+        name: /dev/stdout
+  techPreview:
+    meshConfig:
+      defaultConfig:
+        holdApplicationUntilProxyStarts: false
+        proxyMetadata:
+          ISTIO_META_DNS_CAPTURE: "true"
+          PROXY_XDS_VIA_AGENT: "true"
+  gateways:
+    additionalEgress:
+      federation-egress:
+        enabled: true
+        requestedNetworkView:
+        - network-mesh2
+        routerMode: sni-dnat
+        service:
+          metadata:
+            labels:
+              federation.maistra.io/proxy: mesh2
+          ports:
+          - port: 15443
+            name: tls
+          - port: 8188
+            name: http-discovery
+        runtime:
+          deployment:
+            autoScaling:
+              enabled: false
+          container:
+            # constrain resources for use in smaller environments
+            resources:
+              requests:
+                cpu: 10m
+                memory: 128Mi
+              limits: {}
+    additionalIngress:
+      federation-ingress:
+        enabled: true
+        routerMode: sni-dnat
+        service:
+          type: LoadBalancer
+          metadata:
+            labels:
+              federation.maistra.io/proxy: mesh2
+          ports:
+          - port: 15443
+            name: tls
+          - port: 8188
+            name: https-discovery
+        runtime:
+          deployment:
+            autoScaling:
+              enabled: false
+          container:
+            # constrain resources for use in smaller environments
+            resources:
+              requests:
+                cpu: 10m
+                memory: 128Mi
+              limits: {}
diff --git a/pkg/servicemesh/federation/example/config-poc/export/smmr.yaml b/pkg/servicemesh/federation/example/config-poc/export/smmr.yaml
new file mode 100644
index 0000000000..b665e255c5
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/smmr.yaml
@@ -0,0 +1,8 @@
+apiVersion: maistra.io/v1
+kind: ServiceMeshMemberRoll
+metadata:
+  name: default
+  namespace: mesh1-system
+spec:
+  members:
+  - mesh1-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml b/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
new file mode 100644
index 0000000000..46af8e6bfa
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
@@ -0,0 +1,14 @@
+apiVersion: maistra.io/v1alpha1
+kind: MeshFederation
+metadata:
+  name: mesh1
+  namespace: mesh2-system
+spec:
+  networkAddress: federation-ingress.mesh1-system.svc.cluster.local
+  gateways:
+    ingress:
+      name: federation-ingress
+    egress:
+      name: federation-egress
+  security:
+    clientID: cluster.local/ns/mesh1-system/sa/federation-egress-service-account
diff --git a/pkg/servicemesh/federation/example/config-poc/import/mongodb-service.yaml b/pkg/servicemesh/federation/example/config-poc/import/mongodb-service.yaml
new file mode 100644
index 0000000000..c513f76786
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/mongodb-service.yaml
@@ -0,0 +1,12 @@
+# This is required, as apparently a VirtualService matching 
+# mongodb.mesh2-bookinfo.svc.cluster.local does not create DNS entry for routing
+kind: Service
+apiVersion: v1
+metadata:
+  name: mongodb
+  namespace: mesh2-bookinfo
+spec:
+  type: ClusterIP
+  ports:
+  - port: 27017
+    name: mongo
diff --git a/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml b/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
new file mode 100644
index 0000000000..1aef5fa966
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
@@ -0,0 +1,85 @@
+apiVersion: maistra.io/v2
+kind: ServiceMeshControlPlane
+metadata:
+  name: fed-import
+  namespace: mesh2-system
+spec:
+  version: v2.1
+  cluster:
+    name: cluster2
+    network: network2
+  runtime:
+    defaults:
+      container:
+        imagePullPolicy: Always
+  addons:
+    grafana:
+      enabled: true
+    kiali:
+      enabled: true
+  tracing:
+    type: Jaeger
+    sampling: 10000
+  proxy:
+    accessLogging:
+      file:
+        name: /dev/stdout
+  techPreview:
+    meshConfig:
+      defaultConfig:
+        holdApplicationUntilProxyStarts: false
+        proxyMetadata:
+          ISTIO_META_DNS_CAPTURE: "true"
+          PROXY_XDS_VIA_AGENT: "true"
+  gateways:
+    additionalEgress:
+      federation-egress:
+        enabled: true
+        requestedNetworkView:
+        - network-mesh1
+        routerMode: sni-dnat
+        service:
+          metadata:
+            labels:
+              federation.maistra.io/proxy: mesh1
+          ports:
+          - port: 15443
+            name: tls
+          - port: 8188
+            name: http-discovery
+        runtime:
+          deployment:
+            autoScaling:
+              enabled: false
+          container:
+            # constrain resources for use in smaller environments
+            resources:
+              requests:
+                cpu: 10m
+                memory: 128Mi
+              limits: {}
+    additionalIngress:
+      federation-ingress:
+        enabled: true
+        routerMode: sni-dnat
+        service:
+          type: LoadBalancer
+          metadata:
+            labels:
+              federation.maistra.io/proxy: mesh1
+          ports:
+          - port: 15443
+            name: tls
+          - port: 8188
+            name: https-discovery
+        runtime:
+          deployment:
+            autoScaling:
+              enabled: false
+          container:
+            # constrain resources for use in smaller environments
+            resources:
+              requests:
+                cpu: 10m
+                memory: 128Mi
+              limits: {}
diff --git a/pkg/servicemesh/federation/example/config-poc/import/smmr.yaml b/pkg/servicemesh/federation/example/config-poc/import/smmr.yaml
new file mode 100644
index 0000000000..7de7a45030
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/smmr.yaml
@@ -0,0 +1,8 @@
+apiVersion: maistra.io/v1
+kind: ServiceMeshMemberRoll
+metadata:
+  name: default
+  namespace: mesh2-system
+spec:
+  members:
+  - mesh2-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/install.sh b/pkg/servicemesh/federation/example/config-poc/install.sh
new file mode 100755
index 0000000000..5adc7804c4
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/install.sh
@@ -0,0 +1,67 @@
+#!/bin/bash
+
+# Copyright Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http:#www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+echo "Creating projects for mesh1"
+oc new-project mesh1-system || true
+oc new-project mesh1-bookinfo || true
+
+echo "Creating CA Secret for mesh1"
+oc create secret generic cacerts -n mesh1-system --from-file ./cacerts/
+
+echo "Installing control plane for mesh1"
+oc create -f export/smcp.yaml
+oc create -f export/smmr.yaml
+
+echo "Creating projects for mesh2"
+oc new-project mesh2-system || true
+oc new-project mesh2-bookinfo || true
+
+echo "Creating CA Secret for mesh2"
+oc create secret generic cacerts -n mesh2-system --from-file ./cacerts/
+
+echo "Installing control plane for mesh2"
+oc create -f import/smcp.yaml
+oc create -f import/smmr.yaml
+
+echo "Waiting for mesh1 installation to complete"
+oc wait --for condition=Ready -n mesh1-system smmr/default --timeout 180s
+
+echo "Enabling federation for mesh1"
+oc create -f export/meshfederation.yaml
+oc create -f export/serviceexports.yaml
+
+echo "Waiting for mesh2 installation to complete"
+oc wait --for condition=Ready -n mesh2-system smmr/default --timeout 180s
+
+echo "Enabling federation mesh2"
+oc create -f import/meshfederation.yaml
+
+echo "Installing mongodb k8s Service for mesh2"
+oc create -f import/mongodb-service.yaml
+
+echo "Installing VirtualServices for mesh2"
+oc create -f examples/mongodb-remote-virtualservice.yaml
+oc create -f examples/ratings-split-virtualservice.yaml
+
+echo "Please install bookinfo into mesh1-bookinfo and mesh2-bookinfo"
+echo "For the tcp example, install bookinfo-db into mesh1-bookinfo and"
+echo "bookinfo-ratings-v2 into mesh2-bookinfo, for example:"
+echo "    oc create -n mesh1-bookinfo bookinfo-db.yaml"
+echo "    oc create -n mesh2-bookinfo bookinfo-ratings-v2.yaml"
+echo ""
+echo "The meshes are configured to split ratings traffic in mesh2-bookinfo"
+echo "between mesh1 and mesh2.  The ratings-v2 service in mesh2 is configured to"
+echo "use the mongodb service in mesh1."
diff --git a/pkg/servicemesh/federation/export/controller.go b/pkg/servicemesh/federation/export/controller.go
new file mode 100644
index 0000000000..32664391da
--- /dev/null
+++ b/pkg/servicemesh/federation/export/controller.go
@@ -0,0 +1,167 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package export
+
+import (
+	"context"
+	"fmt"
+	"time"
+
+	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/errors"
+	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/client-go/tools/cache"
+
+	kubecontroller "istio.io/istio/pkg/kube/controller"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	clientsetservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	informersservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	"istio.io/pkg/log"
+)
+
+const (
+	defaultResyncPeriod = 60 * time.Second
+)
+
+var logger = log.RegisterScope("federation-exports-controller", "federation-exports-controller", 0)
+
+type ServiceExportManager interface {
+	UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error
+	DeleteExportsForMesh(name string)
+}
+
+type Options struct {
+	common.ControllerOptions
+	ServiceExportManager ServiceExportManager
+}
+
+type Controller struct {
+	*kubecontroller.Controller
+	cs            clientsetservicemeshv1alpha1.Interface
+	exportManager ServiceExportManager
+}
+
+// newExportsController creates a new ServiceExports controller
+func NewController(opt Options) (*Controller, error) {
+	if err := opt.validate(); err != nil {
+		return nil, fmt.Errorf("invalid Options specified for federation export controller: %s", err)
+	}
+
+	cs, err := clientsetservicemeshv1alpha1.NewForConfig(opt.KubeClient.RESTConfig())
+	if err != nil {
+		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
+	}
+
+	mrc := opt.KubeClient.GetMemberRoll()
+
+	return internalNewController(cs, mrc, opt), nil
+}
+
+// allows using a fake client set for testing purposes
+func internalNewController(cs clientsetservicemeshv1alpha1.Interface, mrc memberroll.MemberRollController, opt Options) *Controller {
+	var informer cache.SharedIndexInformer
+	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
+	if mrc != nil && false {
+		newInformer := func(namespace string) cache.SharedIndexInformer {
+			return cache.NewSharedIndexInformer(
+				&cache.ListWatch{
+					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
+						return cs.MaistraV1alpha1().ServiceExports(namespace).List(context.TODO(), options)
+					},
+					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
+						return cs.MaistraV1alpha1().ServiceExports(namespace).Watch(context.TODO(), options)
+					},
+				},
+				&v1alpha1.MeshFederation{},
+				opt.ResyncPeriod,
+				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
+			)
+		}
+
+		namespaceSet := xnsinformers.NewNamespaceSet()
+		informer = xnsinformers.NewMultiNamespaceInformer(namespaceSet, opt.ResyncPeriod, newInformer)
+		mrc.Register(namespaceSet, "federation-exports-controller")
+	} else {
+		informer = informersservicemeshv1alpha1.NewServiceExportsInformer(
+			cs, opt.Namespace, opt.ResyncPeriod,
+			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
+	}
+
+	controller := &Controller{
+		cs:            cs,
+		exportManager: opt.ServiceExportManager,
+	}
+	internalController := kubecontroller.NewController(kubecontroller.Options{
+		Informer:     informer,
+		Logger:       logger,
+		ResyncPeriod: opt.ResyncPeriod,
+		Reconciler:   controller.reconcile,
+	})
+	controller.Controller = internalController
+
+	return controller
+}
+
+func (c *Controller) HasSynced() bool {
+	return c.Controller.HasSynced()
+}
+
+func (c *Controller) reconcile(resourceName string) error {
+	logger.Debugf("Reconciling MeshFederation %s", resourceName)
+	defer func() {
+		logger.Infof("Completed reconciliation of ServiceExports %s", resourceName)
+	}()
+
+	ctx := context.TODO()
+
+	namespace, name, err := cache.SplitMetaNamespaceKey(resourceName)
+	if err != nil {
+		logger.Errorf("error splitting resource name: %s", resourceName)
+	}
+	instance, err := c.cs.MaistraV1alpha1().ServiceExports(namespace).Get(ctx, name, metav1.GetOptions{})
+	if err != nil {
+		if apierrors.IsNotFound(err) || apierrors.IsGone(err) {
+			// Request object not found, could have been deleted after reconcile request.
+			// Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
+			// Return and don't requeue
+			c.exportManager.DeleteExportsForMesh(name)
+			logger.Info("ServiceExports deleted")
+			err = nil
+		}
+		return err
+	}
+
+	return c.exportManager.UpdateExportsForMesh(instance)
+}
+
+func (opt Options) validate() error {
+	var allErrors []error
+	if opt.KubeClient == nil {
+		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	}
+	if opt.ServiceExportManager == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ServiceExportManager field must not be nil"))
+	}
+	if opt.ResyncPeriod == 0 {
+		opt.ResyncPeriod = defaultResyncPeriod
+		logger.Warnf("ResyncPeriod not specified, defaulting to %s", opt.ResyncPeriod)
+	}
+	return errors.NewAggregate(allErrors)
+}
diff --git a/pkg/servicemesh/federation/export/exports.go b/pkg/servicemesh/federation/export/exports.go
new file mode 100644
index 0000000000..f05e58ba17
--- /dev/null
+++ b/pkg/servicemesh/federation/export/exports.go
@@ -0,0 +1,183 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package export
+
+import (
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/labels"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+)
+
+type ServiceExporter struct {
+	exportConfig        []matcher
+	defaultExportConfig []matcher
+}
+
+func NewServiceExporter(exportConfig *v1alpha1.ServiceExports, defaultConfig *ServiceExporter) *ServiceExporter {
+	var defaultExportConfig []matcher
+	if defaultConfig != nil && len(defaultConfig.defaultExportConfig) > 0 {
+		defaultExportConfig = append([]matcher(nil), defaultConfig.exportConfig...)
+	}
+	return &ServiceExporter{
+		exportConfig:        convertServiceExportsToExportConfig(exportConfig),
+		defaultExportConfig: defaultExportConfig,
+	}
+}
+
+func convertServiceExportsToExportConfig(serviceExports *v1alpha1.ServiceExports) []matcher {
+	if serviceExports == nil {
+		return nil
+	}
+	var exportConfig []matcher
+	for _, rule := range serviceExports.Spec.Exports {
+		switch rule.Type {
+		case v1alpha1.LabelSelectorType:
+			if rule.LabelSelector == nil {
+				// XXX: log error?  this should be caught in validation
+				continue
+			}
+			if matcher, err := newLabelMatcher(rule.LabelSelector); err != nil {
+				// XXX: log error?  this should be caught in validation
+				continue
+			} else {
+				exportConfig = append(exportConfig, matcher)
+			}
+		case v1alpha1.NameSelectorType:
+			if rule.NameSelector == nil {
+				// XXX: log error?  this should be caught in validation
+				continue
+			}
+			exportConfig = append(exportConfig, newNameMatcher(rule.NameSelector))
+		default:
+			// unknown selector type
+			// XXX: log error?  this should be caught in validation
+		}
+	}
+	return exportConfig
+}
+
+func (se *ServiceExporter) ExportedNameForService(svc *model.Service) *v1alpha1.ServiceName {
+	// don't reexport federated services
+	if svc.Attributes.ServiceRegistry == provider.Federation || svc.MeshExternal {
+		return nil
+	}
+	for _, matcher := range se.exportConfig {
+		if name := matcher.exportedNameForService(svc); name != nil {
+			return name
+		}
+	}
+	for _, matcher := range se.defaultExportConfig {
+		if name := matcher.exportedNameForService(svc); name != nil {
+			return name
+		}
+	}
+	return nil
+}
+
+type matcher interface {
+	exportedNameForService(svc *model.Service) *v1alpha1.ServiceName
+}
+
+type nameMatcher struct {
+	match v1alpha1.ServiceName
+	alias *v1alpha1.ServiceName
+}
+
+var _ matcher = (*nameMatcher)(nil)
+
+func newNameMatcher(mapping *v1alpha1.ServiceNameMapping) matcher {
+	var alias *v1alpha1.ServiceName
+	// if it's nil or matches anything, it may as well be nil
+	if mapping.Alias == nil ||
+		((mapping.Alias.Namespace == v1alpha1.MatchAny || mapping.Alias.Namespace == "") &&
+			(mapping.Alias.Name == v1alpha1.MatchAny || mapping.Alias.Name == "")) {
+		alias = nil
+	} else {
+		alias = &v1alpha1.ServiceName{}
+		*alias = *mapping.Alias
+	}
+	return &nameMatcher{
+		match: mapping.Name,
+		alias: alias,
+	}
+}
+
+func (m *nameMatcher) exportedNameForService(svc *model.Service) *v1alpha1.ServiceName {
+	if (m.match.Namespace == "" || m.match.Namespace == v1alpha1.MatchAny || m.match.Namespace == svc.Attributes.Namespace) &&
+		(m.match.Name == "" || m.match.Name == v1alpha1.MatchAny || m.match.Name == svc.Attributes.Name) {
+		name := &v1alpha1.ServiceName{}
+		if m.alias == nil {
+			name.Namespace = svc.Attributes.Namespace
+			name.Name = svc.Attributes.Name
+		} else {
+			if m.alias.Namespace == v1alpha1.MatchAny || m.alias.Namespace == "" {
+				name.Namespace = svc.Attributes.Namespace
+			} else {
+				name.Namespace = m.alias.Namespace
+			}
+			if m.alias.Name == v1alpha1.MatchAny || m.alias.Name == "" {
+				name.Name = svc.Attributes.Name
+			} else {
+				name.Name = m.alias.Name
+			}
+		}
+		return name
+	}
+	return nil
+}
+
+type labelMatcher struct {
+	namespace string
+	selector  labels.Selector
+	aliases   []matcher
+}
+
+var _ matcher = (*labelMatcher)(nil)
+
+func newLabelMatcher(labelSelector *v1alpha1.ServiceExportLabelSelector) (matcher, error) {
+	selector, err := metav1.LabelSelectorAsSelector(&labelSelector.Selector)
+	if err != nil {
+		return nil, err
+	}
+	aliases := make([]matcher, len(labelSelector.Aliases))
+	for index, alias := range labelSelector.Aliases {
+		aliases[index] = newNameMatcher(&alias)
+	}
+	return &labelMatcher{
+		namespace: labelSelector.Namespace,
+		selector:  selector,
+		aliases:   aliases,
+	}, nil
+}
+
+func (m *labelMatcher) exportedNameForService(svc *model.Service) *v1alpha1.ServiceName {
+	if (m.namespace == "" || m.namespace == v1alpha1.MatchAny || m.namespace == svc.Attributes.Namespace) &&
+		m.selector.Matches(labels.Set(svc.Attributes.Labels)) {
+		for _, alias := range m.aliases {
+			if name := alias.exportedNameForService(svc); name != nil {
+				return name
+			}
+		}
+		// if there's no alias, we return the original service name
+		return &v1alpha1.ServiceName{
+			Namespace: svc.Attributes.Namespace,
+			Name:      svc.Attributes.Name,
+		}
+	}
+	return nil
+}
diff --git a/pkg/servicemesh/federation/federation.go b/pkg/servicemesh/federation/federation.go
new file mode 100644
index 0000000000..c5205da805
--- /dev/null
+++ b/pkg/servicemesh/federation/federation.go
@@ -0,0 +1,152 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package federation
+
+import (
+	"fmt"
+
+	"k8s.io/apimachinery/pkg/util/errors"
+
+	"istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	"istio.io/istio/pkg/servicemesh/federation/discovery"
+	"istio.io/istio/pkg/servicemesh/federation/export"
+	"istio.io/istio/pkg/servicemesh/federation/server"
+	"istio.io/pkg/log"
+)
+
+func init() {
+	schemasBuilder := collection.NewSchemasBuilder()
+	discovery.Schemas.ForEach(func(s collection.Schema) (done bool) {
+		// only error is already exists, which we don't care about
+		_ = schemasBuilder.Add(s)
+		return false
+	})
+	server.Schemas.ForEach(func(s collection.Schema) (done bool) {
+		// only error is already exists, which we don't care about
+		_ = schemasBuilder.Add(s)
+		return false
+	})
+	schemas = schemasBuilder.Build()
+}
+
+var schemas collection.Schemas
+
+type Options struct {
+	common.ControllerOptions
+	BindAddress       string
+	Env               *model.Environment
+	Network           string
+	XDSUpdater        model.XDSUpdater
+	ServiceController *aggregate.Controller
+}
+
+type Federation struct {
+	configStore         model.ConfigStoreCache
+	server              *server.Server
+	exportController    *export.Controller
+	discoveryController *discovery.Controller
+}
+
+func New(opt Options) (*Federation, error) {
+	if err := opt.validate(); err != nil {
+		return nil, err
+	}
+	configStore := newConfigStore()
+	server, err := server.NewServer(server.Options{
+		BindAddress: opt.BindAddress,
+		Env:         opt.Env,
+		Network:     opt.Network,
+		ConfigStore: configStore,
+	})
+	if err != nil {
+		return nil, err
+	}
+	exportController, err := export.NewController(export.Options{
+		ControllerOptions:    opt.ControllerOptions,
+		ServiceExportManager: server,
+	})
+	if err != nil {
+		return nil, err
+	}
+	discoveryController, err := discovery.NewController(discovery.Options{
+		ControllerOptions: opt.ControllerOptions,
+		ServiceController: opt.ServiceController,
+		XDSUpdater:        opt.XDSUpdater,
+		Env:               opt.Env,
+		ConfigStore:       configStore,
+		FederationManager: server,
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	federation := &Federation{
+		configStore:         configStore,
+		server:              server,
+		exportController:    exportController,
+		discoveryController: discoveryController,
+	}
+	return federation, nil
+}
+
+func newConfigStore() model.ConfigStoreCache {
+	return memory.NewController(memory.Make(schemas))
+}
+
+func (f *Federation) ConfigStore() model.ConfigStoreCache {
+	return f.configStore
+}
+
+func (f *Federation) RegisterServiceHandlers(serviceController *aggregate.Controller) {
+	serviceController.AppendServiceHandler(f.server.UpdateService)
+}
+
+func (f *Federation) StartControllers(stopCh <-chan struct{}) {
+	go f.discoveryController.Start(stopCh)
+	f.exportController.Start(stopCh)
+}
+
+func (f *Federation) ControllersSynced() bool {
+	return f.exportController.HasSynced() && f.discoveryController.HasSynced()
+}
+
+func (f *Federation) StartServer(stopCh <-chan struct{}) {
+	f.server.Run(stopCh)
+}
+
+func (opt Options) validate() error {
+	var allErrors []error
+	if opt.KubeClient == nil {
+		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	}
+	if opt.XDSUpdater == nil {
+		allErrors = append(allErrors, fmt.Errorf("the XDSUpdater field must not be nil"))
+	}
+	if opt.Env == nil {
+		allErrors = append(allErrors, fmt.Errorf("the Env field must not be nil"))
+	}
+	if opt.ResyncPeriod == 0 {
+		opt.ResyncPeriod = common.DefaultResyncPeriod
+		log.Warnf("ResyncPeriod not specified, defaulting to %s", opt.ResyncPeriod)
+	}
+	if opt.ServiceController == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ServiceController field must not be nil"))
+	}
+	return errors.NewAggregate(allErrors)
+}
diff --git a/pkg/servicemesh/federation/federation_test.go b/pkg/servicemesh/federation/federation_test.go
new file mode 100644
index 0000000000..19ff27d32a
--- /dev/null
+++ b/pkg/servicemesh/federation/federation_test.go
@@ -0,0 +1,84 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package federation
+
+import (
+	"testing"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
+	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+)
+
+func TestInvalidOptions(t *testing.T) {
+	testCases := []struct {
+		name string
+		opt  Options
+	}{
+		{
+			name: "client",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: nil,
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "service-controller",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: nil,
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "xds-updater",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        nil,
+				Env:               &model.Environment{},
+			},
+		},
+		{
+			name: "env",
+			opt: Options{
+				ControllerOptions: common.ControllerOptions{
+					KubeClient: kube.NewFakeClient(),
+				},
+				ServiceController: &aggregate.Controller{},
+				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
+				Env:               nil,
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			if err := tc.opt.validate(); err == nil {
+				t.Errorf("expected error")
+			}
+		})
+	}
+}
diff --git a/pkg/servicemesh/federation/model/model.go b/pkg/servicemesh/federation/model/model.go
new file mode 100644
index 0000000000..0a528e9b49
--- /dev/null
+++ b/pkg/servicemesh/federation/model/model.go
@@ -0,0 +1,73 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
+
+import hashstructure "github.com/mitchellh/hashstructure/v2"
+
+type ServiceKey struct {
+	Name      string `json:"name"`
+	Namespace string `json:"namespace"`
+	Hostname  string `json:"hostname"`
+}
+
+type ServiceListMessage struct {
+	Checksum                uint64             `json:"checksum" hash:"ignore"`
+	NetworkGatewayEndpoints []*ServiceEndpoint `json:"networkGatewayEndpoints" hash:"set"`
+	Services                []*ServiceMessage  `json:"services" hash:"set"`
+}
+
+type ServiceMessage struct {
+	ServiceKey   `json:"inline"`
+	ServicePorts []*ServicePort `json:"servicePorts"`
+}
+
+type ServicePort struct {
+	Name     string `json:"name"`
+	Port     int    `json:"port"`
+	Protocol string `json:"protocol"`
+}
+
+type ServiceEndpoint struct {
+	Port     int    `json:"port"`
+	Hostname string `json:"hostname"`
+}
+
+type WatchEvent struct {
+	Action   string          `json:"action"`
+	Service  *ServiceMessage `json:"service"`
+	Checksum uint64          `json:"checksum"`
+}
+
+var (
+	ActionAdd    = "add"
+	ActionUpdate = "update"
+	ActionDelete = "delete"
+)
+
+func (s *ServiceListMessage) GenerateChecksum() uint64 {
+	checksum, err := hashstructure.Hash(s, hashstructure.FormatV2, &hashstructure.HashOptions{SlicesAsSets: true})
+	if err != nil {
+		return 0
+	}
+	return checksum
+}
+
+func (s *ServiceMessage) GenerateChecksum() uint64 {
+	checksum, err := hashstructure.Hash(s, hashstructure.FormatV2, &hashstructure.HashOptions{SlicesAsSets: true})
+	if err != nil {
+		return 0
+	}
+	return checksum
+}
diff --git a/pkg/servicemesh/federation/server/routing.go b/pkg/servicemesh/federation/server/routing.go
new file mode 100644
index 0000000000..158e9942e2
--- /dev/null
+++ b/pkg/servicemesh/federation/server/routing.go
@@ -0,0 +1,275 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"fmt"
+	"strconv"
+	"time"
+
+	"github.com/pkg/errors"
+
+	rawnetworking "istio.io/api/networking/v1alpha3"
+	rawsecurity "istio.io/api/security/v1beta1"
+	rawtype "istio.io/api/type/v1beta1"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+)
+
+func init() {
+	schemasBuilder := collection.NewSchemasBuilder()
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Virtualservices)
+	schemasBuilder.MustAdd(collections.IstioNetworkingV1Alpha3Gateways)
+	schemasBuilder.MustAdd(collections.IstioSecurityV1Beta1Authorizationpolicies)
+	Schemas = schemasBuilder.Build()
+}
+
+var (
+	Schemas collection.Schemas
+	// ensure our config gets ignored if the user wants to change routing for
+	// exported services
+	armageddonTime = time.Unix(1<<62-1, 0)
+)
+
+func createResourceName(mesh string, source federationmodel.ServiceKey) string {
+	return fmt.Sprintf("federation-exports-%s-%s-%s", mesh, source.Name, source.Namespace)
+}
+
+func (s *meshServer) deleteExportResources(source federationmodel.ServiceKey, target *federationmodel.ServiceMessage) error {
+	resourceName := createResourceName(s.mesh.Name, source)
+	// Delete() is always successful
+	_ = s.configStore.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(), resourceName, s.mesh.Namespace, nil)
+	_ = s.configStore.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(), resourceName, s.mesh.Namespace, nil)
+	return s.removeServiceFromAuthorizationPolicy(target)
+}
+
+func (s *meshServer) removeServiceFromAuthorizationPolicy(target *federationmodel.ServiceMessage) error {
+	// AuthorizationPolicy used to restrict inbound requests to known clients accessing exported services.
+	// We use a DENY policy to block any traffic coming in that's not from a known client or destined for an exported service
+	name := fmt.Sprintf("federation-exports-%s", s.mesh.Name)
+	rawAP := s.configStore.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(), name, s.mesh.Namespace)
+	if rawAP == nil {
+		// nothing to remove
+		logger.Warnf("could not find AuthorizationPolicy %s/%s associated with federation export", s.mesh.Namespace, name)
+		return nil
+	}
+	apSpec := rawAP.Spec.(*rawsecurity.AuthorizationPolicy)
+	if len(apSpec.Rules) != 1 || len(apSpec.Rules[0].To) != 1 {
+		return fmt.Errorf("invalid AuthorizationPolicy for service export")
+	}
+	for index, host := range apSpec.Rules[0].To[0].Operation.NotHosts {
+		if host == target.Hostname {
+			apSpec.Rules[0].To[0].Operation.NotHosts = append(apSpec.Rules[0].To[0].Operation.NotHosts[:index], apSpec.Rules[0].To[0].Operation.NotHosts[index+1:]...)
+			if _, err := s.configStore.Update(*rawAP); err != nil {
+				return err
+			}
+			return nil
+		}
+	}
+	logger.Warnf("AuthorizationPolicy %s/%s did not have rule for exported service %s", s.mesh.Namespace, name, target.Hostname)
+	return nil
+}
+
+func (s *meshServer) createExportResources(source federationmodel.ServiceKey, target *federationmodel.ServiceMessage) error {
+	if err := s.createOrUpdateAuthorizationPolicy(target); err != nil {
+		return errors.Wrapf(err, "error updating AuthorinzationPolicy resource")
+	}
+	gateway := s.gatewayForExport(source, target)
+	if rawGateway := s.configStore.Get(
+		collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(), gateway.Name, s.mesh.Namespace); rawGateway == nil {
+		if _, err := s.configStore.Create(*gateway); err != nil {
+			return errors.Wrapf(err, "error creating Gateway resource")
+		}
+	} else {
+		// overwrite whatever's there
+		logger.Warnf("Gateway resource %s already exists for exported service (%s => %s).  It will be overwritten.", gateway.Name, source.Hostname, target.Hostname)
+		if _, err := s.configStore.Update(*gateway); err != nil {
+			return errors.Wrapf(err, "error updating Gateway resource")
+		}
+	}
+	vs := s.virtualServiceForExport(source, target)
+	if rawVS := s.configStore.Get(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(), vs.Name, s.mesh.Namespace); rawVS == nil {
+		if _, err := s.configStore.Create(*vs); err != nil {
+			return errors.Wrapf(err, "error creating VirtualService resource")
+		}
+	} else {
+		// overwrite whatever's there
+		logger.Warnf("VirtualService resource %s already exists for exported service (%s => %s).  It will be overwritten.", vs.Name, source.Hostname, target.Hostname)
+		if _, err := s.configStore.Update(*vs); err != nil {
+			return errors.Wrapf(err, "error updating VirtualService resource")
+		}
+	}
+	return nil
+}
+
+func (s *meshServer) createOrUpdateAuthorizationPolicy(target *federationmodel.ServiceMessage) error {
+	// AuthorizationPolicy used to restrict inbound requests to known clients accessing exported services.
+	// We use a DENY policy to block any traffic coming in that's not from a known client or destined for an exported service
+	name := fmt.Sprintf("federation-exports-%s", s.mesh.Name)
+	rawAP := s.configStore.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(), name, s.mesh.Namespace)
+	if rawAP == nil {
+		if s.mesh.Spec.Security == nil || s.mesh.Spec.Security.ClientID == "" {
+			logger.Errorf("no ClientID specified for MeshFederation %s/%s: AuthorizationPolicy for exported services will not be created", s.mesh.Namespace, s.mesh.Name)
+			return nil
+		}
+		ap := &config.Config{
+			Meta: config.Meta{
+				GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+				Name:             name,
+				Namespace:        s.mesh.Namespace,
+			},
+			Spec: &rawsecurity.AuthorizationPolicy{
+				Selector: &rawtype.WorkloadSelector{
+					MatchLabels: map[string]string{
+						"service.istio.io/canonical-name": s.mesh.Spec.Gateways.Ingress.Name,
+					},
+				},
+				Action: rawsecurity.AuthorizationPolicy_DENY,
+				Rules: []*rawsecurity.Rule{
+					{
+						From: []*rawsecurity.Rule_From{
+							{
+								Source: &rawsecurity.Source{
+									NotPrincipals: []string{
+										s.mesh.Spec.Security.ClientID,
+									},
+								},
+							},
+						},
+						To: []*rawsecurity.Rule_To{
+							{
+								Operation: &rawsecurity.Operation{
+									NotHosts: []string{
+										target.Hostname,
+									},
+									Ports: []string{
+										strconv.FormatInt(common.FederationPort, 10),
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		}
+		if _, err := s.configStore.Create(*ap); err != nil {
+			return err
+		}
+		return nil
+	}
+	apSpec := rawAP.Spec.(*rawsecurity.AuthorizationPolicy)
+	if len(apSpec.Rules) != 1 || len(apSpec.Rules[0].To) != 1 {
+		return fmt.Errorf("invalid AuthorizationPolicy for service export")
+	}
+	for _, host := range apSpec.Rules[0].To[0].Operation.NotHosts {
+		if host == target.Hostname {
+			// no update required
+			return nil
+		}
+	}
+	// add the host to the list of available targets
+	apSpec.Rules[0].To[0].Operation.NotHosts = append(apSpec.Rules[0].To[0].Operation.NotHosts, target.Hostname)
+	if _, err := s.configStore.Update(*rawAP); err != nil {
+		return err
+	}
+	return nil
+}
+
+func (s *meshServer) gatewayForExport(source federationmodel.ServiceKey, target *federationmodel.ServiceMessage) *config.Config {
+	resourceName := createResourceName(s.mesh.Name, source)
+	mode := rawnetworking.ServerTLSSettings_ISTIO_MUTUAL
+	if s.mesh.Spec.Security != nil && s.mesh.Spec.Security.AllowDirectInbound {
+		// XXX: this will not work, as the exported services will have a different domain suffix
+		// for example, svc.mesh2.local as opposed to svc.cluster.local
+		mode = rawnetworking.ServerTLSSettings_AUTO_PASSTHROUGH
+	}
+	gateway := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
+			Name:             resourceName,
+			Namespace:        s.mesh.Namespace,
+		},
+		Spec: &rawnetworking.Gateway{
+			Selector: map[string]string{
+				"service.istio.io/canonical-name": s.mesh.Spec.Gateways.Ingress.Name,
+			},
+			Servers: []*rawnetworking.Server{
+				{
+					Name: resourceName,
+					Hosts: []string{
+						target.Hostname,
+						fmt.Sprintf("*.%s", target.Hostname),
+					},
+					Port: &rawnetworking.Port{
+						Name:     "tls-federation",
+						Number:   uint32(common.FederationPort),
+						Protocol: "TLS",
+					},
+					Tls: &rawnetworking.ServerTLSSettings{
+						Mode: mode,
+					},
+				},
+			},
+		},
+	}
+	return gateway
+}
+
+func (s *meshServer) virtualServiceForExport(source federationmodel.ServiceKey, target *federationmodel.ServiceMessage) *config.Config {
+	// VirtualService used to route inbound requests to the service.
+	name := createResourceName(s.mesh.Name, source)
+	ingressGatewayName := fmt.Sprintf("%s/%s", s.mesh.Namespace, name)
+	vs := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind:  collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:              name,
+			Namespace:         s.mesh.Namespace,
+			CreationTimestamp: armageddonTime,
+		},
+		Spec: &rawnetworking.VirtualService{
+			Hosts: []string{
+				target.Hostname,
+			},
+			Gateways: []string{
+				ingressGatewayName,
+			},
+			ExportTo: []string{
+				".",
+			},
+			Tcp: []*rawnetworking.TCPRoute{
+				{
+					Match: []*rawnetworking.L4MatchAttributes{
+						{
+							Gateways: []string{
+								ingressGatewayName,
+							},
+						},
+					},
+					Route: []*rawnetworking.RouteDestination{
+						{
+							Destination: &rawnetworking.Destination{
+								Host: source.Hostname,
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	return vs
+}
diff --git a/pkg/servicemesh/federation/server/server.go b/pkg/servicemesh/federation/server/server.go
new file mode 100644
index 0000000000..42c4aa26ac
--- /dev/null
+++ b/pkg/servicemesh/federation/server/server.go
@@ -0,0 +1,573 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"net"
+	"net/http"
+	"sort"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/gorilla/mux"
+	hashstructure "github.com/mitchellh/hashstructure/v2"
+	"k8s.io/apimachinery/pkg/util/errors"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/federation/export"
+	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/pkg/log"
+)
+
+const (
+	meshURLParameter = "mesh"
+)
+
+var logger = log.RegisterScope("federation-server", "federation-server", 0)
+
+type Options struct {
+	BindAddress string
+	Env         *model.Environment
+	Network     string
+	ConfigStore model.ConfigStoreCache
+}
+
+type FederationManager interface {
+	AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports) error
+	DeleteMeshFederation(name string)
+	UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error
+	DeleteExportsForMesh(name string)
+}
+
+type Server struct {
+	sync.RWMutex
+
+	Env        *model.Environment
+	listener   net.Listener
+	httpServer *http.Server
+
+	configStore model.ConfigStoreCache
+
+	defaultExportConfig *export.ServiceExporter
+	meshes              *sync.Map
+
+	// XXX: we need to decide if we really want to allow this or not.
+	// Gateway configuration is managed explicitly through the MeshFederation
+	// resource and using other gateway addresses over discovery would force
+	// us to know what the workload identifiers were so we could manage the
+	// routing config for each mesh.  This may or may not be possible.
+	Network string
+
+	currentGatewayEndpoints []*federationmodel.ServiceEndpoint
+}
+
+var _ FederationManager = (*Server)(nil)
+
+func NewServer(opt Options) (*Server, error) {
+	if err := opt.validate(); err != nil {
+		return nil, err
+	}
+	listener, err := net.Listen("tcp", opt.BindAddress)
+	if err != nil {
+		return nil, err
+	}
+	fed := &Server{
+		Env: opt.Env,
+		httpServer: &http.Server{
+			ReadTimeout:    10 * time.Second,
+			MaxHeaderBytes: 1 << 20,
+		},
+		configStore: opt.ConfigStore,
+		meshes:      &sync.Map{},
+		Network:     opt.Network,
+		listener:    listener,
+	}
+	mux := mux.NewRouter()
+	mux.HandleFunc("/services/{mesh}", fed.handleServiceList)
+	mux.HandleFunc("/watch/{mesh}", fed.handleWatch)
+	fed.httpServer.Handler = mux
+	return fed, nil
+}
+
+func (s *Server) Addr() string {
+	return s.listener.Addr().String()
+}
+
+func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports) error {
+	exportConfig := export.NewServiceExporter(exports, s.defaultExportConfig)
+
+	untypedMeshServer, ok := s.meshes.Load(mesh.Name)
+	if untypedMeshServer != nil && ok {
+		return fmt.Errorf("exporter already exists for federation %s", mesh.Name)
+	}
+	meshServer := &meshServer{
+		GatewayEndpointsProvider: s,
+		Env:                      s.Env,
+		mesh:                     mesh,
+		exportConfig:             exportConfig,
+		configStore:              s.configStore,
+		currentServices:          make(map[federationmodel.ServiceKey]*federationmodel.ServiceMessage),
+	}
+	if _, loaded := s.meshes.LoadOrStore(mesh.Name, meshServer); !loaded {
+		meshServer.resync()
+	}
+	return nil
+}
+
+func (s *Server) DeleteMeshFederation(name string) {
+	ms, ok := s.meshes.Load(name)
+	s.meshes.Delete(name)
+	if ms == nil || !ok {
+		return
+	}
+	ms.(*meshServer).stop()
+}
+
+func (s *Server) UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error {
+	untypedMeshServer, ok := s.meshes.Load(exports.Name)
+	if untypedMeshServer == nil || !ok {
+		return fmt.Errorf("cannot update exporter for non-existent federation: %s", exports.Name)
+	}
+	untypedMeshServer.(*meshServer).updateExportConfig(export.NewServiceExporter(exports, s.defaultExportConfig))
+	return nil
+}
+
+func (s *Server) DeleteExportsForMesh(name string) {
+	untypedMeshServer, ok := s.meshes.Load(name)
+	if untypedMeshServer == nil || !ok {
+		return
+	}
+	// set an empty set of export rules
+	untypedMeshServer.(*meshServer).updateExportConfig(&export.ServiceExporter{})
+}
+
+func (s *Server) getMeshServerForRequest(request *http.Request) (*meshServer, error) {
+	vars := mux.Vars(request)
+	if vars == nil {
+		return nil, fmt.Errorf("no mesh specified")
+	}
+	meshName := vars[meshURLParameter]
+	untypedMesh, ok := s.meshes.Load(meshName)
+	if !ok || untypedMesh == nil {
+		return nil, fmt.Errorf("unknown mesh specified: %s", meshName)
+	}
+
+	return untypedMesh.(*meshServer), nil
+}
+
+func (s *Server) handleServiceList(response http.ResponseWriter, request *http.Request) {
+	mesh, err := s.getMeshServerForRequest(request)
+	if err != nil {
+		logger.Errorf("error handling /services/ request: %s", err)
+		response.WriteHeader(400)
+		return
+	}
+	ret := mesh.getServiceListMessage()
+
+	respBytes, err := json.Marshal(ret)
+	if err != nil {
+		logger.Errorf("failed to marshal to json: %s", err)
+		response.WriteHeader(500)
+		return
+	}
+	_, err = response.Write(respBytes)
+	if err != nil {
+		logger.Errorf("failed to send response: %s", err)
+		response.WriteHeader(500)
+		return
+	}
+}
+
+func (s *Server) handleWatch(response http.ResponseWriter, request *http.Request) {
+	mesh, err := s.getMeshServerForRequest(request)
+	if err != nil {
+		logger.Errorf("error handling /watch request: %s", err)
+		response.WriteHeader(400)
+		return
+	}
+	mesh.handleWatch(response)
+}
+
+func (s *Server) Run(stopCh <-chan struct{}) {
+	logger.Infof("starting federation service discovery at %s", s.Addr())
+	go func() {
+		_ = s.httpServer.Serve(s.listener)
+	}()
+	<-stopCh
+	_ = s.httpServer.Shutdown(context.TODO())
+}
+
+func (s *Server) GetGatewayEndpoints() []*federationmodel.ServiceEndpoint {
+	s.Lock()
+	defer s.Unlock()
+	return append([]*federationmodel.ServiceEndpoint(nil), s.currentGatewayEndpoints...)
+}
+
+func (s *Server) resyncNetworkGateways() (bool, error) {
+	s.Lock()
+	defer s.Unlock()
+
+	gatewayEndpoints := []*federationmodel.ServiceEndpoint{}
+	for _, gateway := range s.Env.NetworkGateways() {
+		gatewayEndpoints = append(gatewayEndpoints, &federationmodel.ServiceEndpoint{
+			Port:     int(gateway.Port),
+			Hostname: gateway.Addr,
+		})
+	}
+
+	newGatewayChecksum, err := hashstructure.Hash(gatewayEndpoints, hashstructure.FormatV2, &hashstructure.HashOptions{SlicesAsSets: true})
+	if err != nil {
+		return false, err
+	}
+
+	oldGatewayChecksum, err := hashstructure.Hash(s.currentGatewayEndpoints, hashstructure.FormatV2, &hashstructure.HashOptions{SlicesAsSets: true})
+	if err != nil {
+		return false, err
+	}
+	if oldGatewayChecksum != newGatewayChecksum {
+		s.currentGatewayEndpoints = gatewayEndpoints
+		return true, nil
+	}
+	return false, nil
+}
+
+func (s *Server) UpdateService(svc *model.Service, event model.Event) {
+	// this might be a NetworkGateway
+	if svc != nil {
+		networkGatewaysChanged, _ := s.resyncNetworkGateways()
+		if networkGatewaysChanged {
+			s.meshes.Range(func(_, value interface{}) bool {
+				value.(*meshServer).resync()
+				return true
+			})
+			s.meshes.Range(func(_, value interface{}) bool {
+				value.(*meshServer).pushWatchEvent(&federationmodel.WatchEvent{
+					Action:  federationmodel.ActionUpdate,
+					Service: nil,
+				})
+				return true
+			})
+		}
+	}
+	s.meshes.Range(func(_, value interface{}) bool {
+		value.(*meshServer).serviceUpdated(svc, event)
+		return true
+	})
+}
+
+// resync ensures the export lists are current.  used for testing
+func (s *Server) resync() {
+	_, _ = s.resyncNetworkGateways()
+	s.meshes.Range(func(_, value interface{}) bool {
+		value.(*meshServer).resync()
+		return true
+	})
+}
+
+type GatewayEndpointsProvider interface {
+	GetGatewayEndpoints() []*federationmodel.ServiceEndpoint
+}
+
+func serviceKeyForService(svc *model.Service) federationmodel.ServiceKey {
+	return federationmodel.ServiceKey{
+		Name:      svc.Attributes.Name,
+		Namespace: svc.Attributes.Namespace,
+		Hostname:  string(svc.Hostname),
+	}
+}
+
+type meshServer struct {
+	GatewayEndpointsProvider
+	sync.RWMutex
+
+	Env *model.Environment
+
+	mesh         *v1alpha1.MeshFederation
+	exportConfig *export.ServiceExporter
+
+	configStore model.ConfigStoreCache
+
+	currentServices map[federationmodel.ServiceKey]*federationmodel.ServiceMessage
+
+	watchMut       sync.RWMutex
+	currentWatches []chan *federationmodel.WatchEvent
+}
+
+func (s *meshServer) updateExportConfig(exportConfig *export.ServiceExporter) {
+	s.Lock()
+	s.exportConfig = exportConfig
+	s.Unlock()
+	s.resync()
+}
+
+func (s *meshServer) getServiceMessage(svc *model.Service, exportedName *v1alpha1.ServiceName) *federationmodel.ServiceMessage {
+	if svc == nil || exportedName == nil {
+		return nil
+	}
+	ret := &federationmodel.ServiceMessage{
+		ServiceKey: federationmodel.ServiceKey{
+			Name:      exportedName.Name,
+			Namespace: exportedName.Namespace,
+			Hostname:  fmt.Sprintf("%s.%s.svc.%s.local", exportedName.Name, exportedName.Namespace, s.mesh.Name),
+		},
+		ServicePorts: make([]*federationmodel.ServicePort, 0),
+	}
+	for _, port := range svc.Ports {
+		ret.ServicePorts = append(ret.ServicePorts, &federationmodel.ServicePort{
+			Name:     port.Name,
+			Port:     port.Port,
+			Protocol: string(port.Protocol),
+		})
+	}
+	return ret
+}
+
+// s has to be Lock()ed
+func (s *meshServer) getServiceListMessage() *federationmodel.ServiceListMessage {
+	ret := &federationmodel.ServiceListMessage{
+		NetworkGatewayEndpoints: s.GetGatewayEndpoints(),
+	}
+	ret.Services = []*federationmodel.ServiceMessage{}
+	for _, svcMessage := range s.currentServices {
+		ret.Services = append(ret.Services, svcMessage)
+	}
+	sort.Slice(ret.Services, func(i, j int) bool { return strings.Compare(ret.Services[i].Hostname, ret.Services[j].Hostname) < 0 })
+	ret.Checksum = ret.GenerateChecksum()
+	return ret
+}
+
+func (s *meshServer) handleServiceList(response http.ResponseWriter) {
+	ret := func() *federationmodel.ServiceListMessage {
+		s.RLock()
+		defer s.RUnlock()
+		return s.getServiceListMessage()
+	}()
+
+	respBytes, err := json.Marshal(ret)
+	if err != nil {
+		logger.Errorf("failed to marshal to json: %s", err)
+		response.WriteHeader(500)
+		return
+	}
+	_, err = response.Write(respBytes)
+	if err != nil {
+		logger.Errorf("failed to send response: %s", err)
+		response.WriteHeader(500)
+		return
+	}
+}
+
+func (s *meshServer) handleWatch(response http.ResponseWriter) {
+	watch := make(chan *federationmodel.WatchEvent)
+	s.watchMut.Lock()
+	s.currentWatches = append(s.currentWatches, watch)
+	s.watchMut.Unlock()
+	defer func() {
+		s.watchMut.Lock()
+		for i, w := range s.currentWatches {
+			if w == watch {
+				s.currentWatches[i] = s.currentWatches[len(s.currentWatches)-1]
+				s.currentWatches = s.currentWatches[:len(s.currentWatches)-1]
+				break
+			}
+		}
+		s.watchMut.Unlock()
+	}()
+	response.Header().Set("Content-Type", "application/json")
+	response.Header().Set("Transfer-Encoding", "chunked")
+	response.WriteHeader(200)
+	flusher, ok := response.(http.Flusher)
+	if !ok {
+		panic("expected http.ResponseWriter to be an http.Flusher")
+	}
+	flusher.Flush()
+	for {
+		event := <-watch
+		respBytes, err := json.Marshal(event)
+		if err != nil {
+			return
+		}
+		_, err = response.Write(respBytes)
+		if err != nil {
+			logger.Errorf("failed to write http response: %s", err)
+			return
+		}
+		_, err = response.Write([]byte("\r\n"))
+		if err != nil {
+			logger.Errorf("failed to write http response: %s", err)
+			return
+		}
+		flusher.Flush()
+	}
+}
+
+func (s *meshServer) resync() {
+	s.Lock()
+	defer s.Unlock()
+	services, err := s.Env.Services()
+	if err != nil {
+		logger.Errorf("failed to call env.Services(): %s", err)
+		return
+	}
+	for _, svc := range services {
+		if svc.Attributes.Name == "" || svc.Attributes.Namespace == "" {
+			logger.Debugf("skipping service with no Namespace/Name: %s", svc.Hostname)
+			continue
+		} else if svc.External() {
+			logger.Debugf("skipping external service: %s", svc.Hostname)
+			continue
+		}
+		svcMessage := s.getServiceMessage(svc, s.exportConfig.ExportedNameForService(svc))
+		svcKey := serviceKeyForService(svc)
+		if existingSvc, found := s.currentServices[svcKey]; found {
+			if existingSvc.GenerateChecksum() == svcMessage.GenerateChecksum() {
+				continue
+			}
+			if existingSvc.Name != svcMessage.Name || existingSvc.Namespace != svcMessage.Namespace {
+				s.deleteService(svcKey, existingSvc)
+				s.addService(svcKey, svcMessage)
+			} else {
+				s.updateService(svcKey, svcMessage)
+			}
+		} else if svcMessage != nil {
+			s.addService(svcKey, svcMessage)
+		}
+	}
+}
+
+func (s *meshServer) serviceUpdated(svc *model.Service, event model.Event) {
+	if svc == nil {
+		return
+	}
+	s.Lock()
+	defer s.Unlock()
+	var svcMessage *federationmodel.ServiceMessage
+	switch event {
+	case model.EventAdd:
+		svcMessage = s.getServiceMessage(svc, s.exportConfig.ExportedNameForService(svc))
+		if svcMessage != nil {
+			s.addService(serviceKeyForService(svc), svcMessage)
+		}
+	case model.EventUpdate:
+		svcMessage = s.getServiceMessage(svc, s.exportConfig.ExportedNameForService(svc))
+		svcKey := serviceKeyForService(svc)
+		if svcMessage != nil {
+			if existingSvc, found := s.currentServices[svcKey]; found {
+				if existingSvc.Name != svcMessage.Name || existingSvc.Namespace != svcMessage.Namespace {
+					s.deleteService(svcKey, existingSvc)
+					s.addService(svcKey, svcMessage)
+				} else {
+					s.updateService(svcKey, svcMessage)
+				}
+			} else {
+				s.addService(svcKey, svcMessage)
+			}
+		} else if existingSvc, found := s.currentServices[svcKey]; found {
+			s.deleteService(svcKey, existingSvc)
+		}
+	case model.EventDelete:
+		svcKey := serviceKeyForService(svc)
+		if existingSvc, found := s.currentServices[svcKey]; found {
+			s.deleteService(svcKey, existingSvc)
+		}
+	}
+}
+
+// s has to be Lock()ed
+func (s *meshServer) addService(svc federationmodel.ServiceKey, msg *federationmodel.ServiceMessage) {
+	if err := s.createExportResources(svc, msg); err != nil {
+		logger.Errorf("error creating resources for exported service %s => %s: %s", svc.Hostname, msg.Hostname, err)
+		return
+	}
+	s.currentServices[svc] = msg
+	e := &federationmodel.WatchEvent{
+		Action:  federationmodel.ActionAdd,
+		Service: msg,
+	}
+	s.pushWatchEvent(e)
+}
+
+// s has to be Lock()ed
+func (s *meshServer) updateService(svc federationmodel.ServiceKey, msg *federationmodel.ServiceMessage) {
+	// resources used to configure export are all based on names, so we don't need to update them
+	s.currentServices[svc] = msg
+	e := &federationmodel.WatchEvent{
+		Action:  federationmodel.ActionUpdate,
+		Service: msg,
+	}
+	s.pushWatchEvent(e)
+}
+
+// s has to be Lock()ed
+func (s *meshServer) deleteService(svc federationmodel.ServiceKey, msg *federationmodel.ServiceMessage) {
+	if err := s.deleteExportResources(svc, msg); err != nil {
+		logger.Errorf("couldn't remove resources associated with exported service %s => %s: %s", svc.Hostname, msg.Hostname, err)
+		// let the deletion go through, so the other mesh won't try to call us
+	}
+	delete(s.currentServices, svc)
+	e := &federationmodel.WatchEvent{
+		Action:  federationmodel.ActionDelete,
+		Service: msg,
+	}
+	s.pushWatchEvent(e)
+}
+
+// s has to be Lock()ed
+func (s *meshServer) pushWatchEvent(e *federationmodel.WatchEvent) {
+	list := s.getServiceListMessage()
+	e.Checksum = list.Checksum
+	s.watchMut.RLock()
+	defer s.watchMut.RUnlock()
+	for _, w := range s.currentWatches {
+		w <- e
+	}
+}
+
+func (s *meshServer) stop() {
+	s.Lock()
+	defer s.Unlock()
+	s.watchMut.Lock()
+	defer s.watchMut.Unlock()
+
+	// copy map as deleteService() removes entries
+	currentServices := make(map[federationmodel.ServiceKey]*federationmodel.ServiceMessage)
+	for source, svc := range s.currentServices {
+		currentServices[source] = svc
+	}
+	// send a delete event for all the services
+	for source, svc := range currentServices {
+		s.deleteService(source, svc)
+	}
+
+	for _, watch := range s.currentWatches {
+		close(watch)
+	}
+}
+
+func (opt Options) validate() error {
+	var allErrors []error
+	if opt.Env == nil {
+		allErrors = append(allErrors, fmt.Errorf("the Env field must not be nil"))
+	}
+	if opt.ConfigStore == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ConfigStore field must not be nil"))
+	}
+	return errors.NewAggregate(allErrors)
+}
diff --git a/pkg/servicemesh/federation/server/server_test.go b/pkg/servicemesh/federation/server/server_test.go
new file mode 100644
index 0000000000..757e8a4c8f
--- /dev/null
+++ b/pkg/servicemesh/federation/server/server_test.go
@@ -0,0 +1,756 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"encoding/json"
+	"io"
+	"io/ioutil"
+	"net/http"
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	"istio.io/istio/pkg/cluster"
+
+	configmemory "istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/model"
+	serviceregistrymemory "istio.io/istio/pilot/pkg/serviceregistry/memory"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+)
+
+var ignoreChecksum = cmp.FilterPath(func(p cmp.Path) bool { return p.String() == "Checksum" }, cmp.Ignore())
+
+func TestServiceList(t *testing.T) {
+	federation := &v1alpha1.MeshFederation{
+		ObjectMeta: v1.ObjectMeta{
+			Name:      "test-remote",
+			Namespace: "istio-system-test",
+		},
+		Spec: v1alpha1.MeshFederationSpec{
+			Security: &v1alpha1.MeshFederationSecurity{
+				ClientID: "federation-egress.other-mesh.svc.cluster.local",
+			},
+		},
+	}
+	exportAllServices := &v1alpha1.ServiceExports{
+		ObjectMeta: v1.ObjectMeta{
+			Name:      "test-remote",
+			Namespace: "istio-system-test",
+		},
+		Spec: v1alpha1.ServiceExportsSpec{
+			Exports: []v1alpha1.ServiceExportRule{
+				{
+					Type:         v1alpha1.NameSelectorType,
+					NameSelector: &v1alpha1.ServiceNameMapping{},
+				},
+			},
+		},
+	}
+	testCases := []struct {
+		name           string
+		remoteName     string
+		defaultExports *v1alpha1.ServiceExports
+		serviceExports *v1alpha1.ServiceExports
+		services       []*model.Service
+		serviceEvents  []struct {
+			event model.Event
+			svc   *model.Service
+		}
+		gateways        []model.NetworkGateway
+		expectedMessage federationmodel.ServiceListMessage
+	}{
+		{
+			name:           "empty serviceList",
+			remoteName:     "test-remote",
+			serviceExports: exportAllServices,
+			services:       []*model.Service{},
+			expectedMessage: federationmodel.ServiceListMessage{
+				Services: []*federationmodel.ServiceMessage{},
+			},
+		},
+		{
+			name:       "exported service, no gateway",
+			remoteName: "test-remote",
+			serviceExports: &v1alpha1.ServiceExports{
+				ObjectMeta: v1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1alpha1.ServiceExportsSpec{
+					Exports: []v1alpha1.ServiceExportRule{
+						{
+							Type: v1alpha1.NameSelectorType,
+							NameSelector: &v1alpha1.ServiceNameMapping{
+								Name: v1alpha1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+								Alias: &v1alpha1.ServiceName{
+									Namespace: "federation",
+									Name:      "service",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				Services: []*federationmodel.ServiceMessage{
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "service, no exports, no gateway",
+			remoteName:     "test-remote",
+			serviceExports: nil,
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				Services: []*federationmodel.ServiceMessage{},
+			},
+		},
+		{
+			name:       "exported service + gateway",
+			remoteName: "test-remote",
+			serviceExports: &v1alpha1.ServiceExports{
+				ObjectMeta: v1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1alpha1.ServiceExportsSpec{
+					Exports: []v1alpha1.ServiceExportRule{
+						{
+							Type: v1alpha1.NameSelectorType,
+							NameSelector: &v1alpha1.ServiceNameMapping{
+								Name: v1alpha1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+								Alias: &v1alpha1.ServiceName{
+									Namespace: "federation",
+									Name:      "service",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+				{
+					Hostname: "ratings.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "ratings",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			gateways: []model.NetworkGateway{
+				{
+					Addr: "127.0.0.1",
+					Port: 8080,
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				NetworkGatewayEndpoints: []*federationmodel.ServiceEndpoint{
+					{
+						Port:     8080,
+						Hostname: "127.0.0.1",
+					},
+				},
+				Services: []*federationmodel.ServiceMessage{
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "exported service + gateway, updated",
+			remoteName:     "test-remote",
+			serviceExports: exportAllServices,
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+				{
+					Hostname: "ratings.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "ratings",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			gateways: []model.NetworkGateway{
+				{
+					Addr: "127.0.0.1",
+					Port: 8080,
+				},
+			},
+			serviceEvents: []struct {
+				event model.Event
+				svc   *model.Service
+			}{
+				{
+					event: model.EventUpdate,
+					svc: &model.Service{
+						Hostname: "productpage.bookinfo.svc.cluster.local",
+						Attributes: model.ServiceAttributes{
+							Name:      "productpage",
+							Namespace: "bookinfo",
+						},
+						Ports: model.PortList{
+							&model.Port{
+								Name:     "https",
+								Protocol: protocol.HTTPS,
+								Port:     8443,
+							},
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				NetworkGatewayEndpoints: []*federationmodel.ServiceEndpoint{
+					{
+						Port:     8080,
+						Hostname: "127.0.0.1",
+					},
+				},
+				Services: []*federationmodel.ServiceMessage{
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "productpage",
+							Namespace: "bookinfo",
+							Hostname:  "productpage.bookinfo.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     8443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "ratings",
+							Namespace: "bookinfo",
+							Hostname:  "ratings.bookinfo.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			serviceDiscovery := serviceregistrymemory.NewServiceDiscovery(tc.services)
+			serviceDiscovery.AddGateways(tc.gateways...)
+			env := &model.Environment{
+				ServiceDiscovery: serviceDiscovery,
+			}
+
+			s, _ := NewServer(Options{
+				BindAddress: "127.0.0.1:0",
+				Env:         env,
+				Network:     "network1",
+				ConfigStore: configmemory.NewController(configmemory.Make(Schemas)),
+			})
+			stopCh := make(chan struct{})
+			go s.Run(stopCh)
+			defer close(stopCh)
+			s.resyncNetworkGateways()
+			s.AddMeshFederation(federation, tc.serviceExports)
+			for _, e := range tc.serviceEvents {
+				s.UpdateService(e.svc, e.event)
+			}
+			serviceList := getServiceList(t, s.Addr(), tc.remoteName)
+			tc.expectedMessage.Checksum = tc.expectedMessage.GenerateChecksum()
+			if tc.expectedMessage.Checksum != serviceList.GenerateChecksum() {
+				t.Errorf("checksums don't match")
+			}
+			if diff := cmp.Diff(serviceList, tc.expectedMessage); diff != "" {
+				t.Fatalf("comparison failed, -got +want:\n%s", diff)
+			}
+		})
+	}
+}
+
+func getServiceList(t *testing.T, addr, remoteName string) federationmodel.ServiceListMessage {
+	resp, err := http.Get("http://" + addr + "/services/" + remoteName)
+	if err != nil {
+		t.Fatal(err)
+	}
+	if resp.StatusCode != http.StatusOK {
+		t.Fatalf("Status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
+	}
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		t.Fatal(err)
+	}
+	serviceList := federationmodel.ServiceListMessage{}
+	err = json.Unmarshal(body, &serviceList)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return serviceList
+}
+
+func TestWatch(t *testing.T) {
+	federation := &v1alpha1.MeshFederation{
+		ObjectMeta: v1.ObjectMeta{
+			Name:      "test-remote",
+			Namespace: "istio-system-test",
+		},
+		Spec: v1alpha1.MeshFederationSpec{
+			Security: &v1alpha1.MeshFederationSecurity{
+				ClientID: "federation-egress.other-mesh.svc.cluster.local",
+			},
+		},
+	}
+	exportProductPage := &v1alpha1.ServiceExports{
+		ObjectMeta: v1.ObjectMeta{
+			Name:      "test-remote",
+			Namespace: "istio-system-test",
+		},
+		Spec: v1alpha1.ServiceExportsSpec{
+			Exports: []v1alpha1.ServiceExportRule{
+				{
+					Type: v1alpha1.NameSelectorType,
+					NameSelector: &v1alpha1.ServiceNameMapping{
+						Name: v1alpha1.ServiceName{
+							Namespace: "bookinfo",
+							Name:      "productpage",
+						},
+						Alias: &v1alpha1.ServiceName{
+							Namespace: "federation",
+							Name:      "service",
+						},
+					},
+				},
+			},
+		},
+	}
+	testCases := []struct {
+		name           string
+		remoteName     string
+		defaultExports *v1alpha1.ServiceExports
+		serviceExports *v1alpha1.ServiceExports
+		updatedExports *v1alpha1.ServiceExports
+		services       []*model.Service
+		serviceEvents  []struct {
+			event model.Event
+			svc   *model.Service
+		}
+		gateways      []model.NetworkGateway
+		gatewayEvents []struct {
+			newGateways []model.NetworkGateway
+		}
+		expectedWatchEvents []*federationmodel.WatchEvent
+	}{
+		{
+			name:           "no gateways, service added + removed",
+			remoteName:     "test-remote",
+			serviceExports: exportProductPage,
+			services:       []*model.Service{},
+			serviceEvents: []struct {
+				event model.Event
+				svc   *model.Service
+			}{
+				{
+					event: model.EventAdd,
+					svc: &model.Service{
+						Hostname: "productpage.bookinfo.svc.cluster.local",
+						Attributes: model.ServiceAttributes{
+							Name:      "productpage",
+							Namespace: "bookinfo",
+						},
+						Ports: model.PortList{
+							&model.Port{
+								Name:     "https",
+								Protocol: protocol.HTTPS,
+								Port:     443,
+							},
+						},
+					},
+				},
+				{
+					event: model.EventDelete,
+					svc: &model.Service{
+						Hostname: "productpage.bookinfo.svc.cluster.local",
+						Attributes: model.ServiceAttributes{
+							Name:      "productpage",
+							Namespace: "bookinfo",
+						},
+					},
+				},
+			},
+			expectedWatchEvents: []*federationmodel.WatchEvent{
+				{
+					Action: federationmodel.ActionAdd,
+					Service: &federationmodel.ServiceMessage{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+				{
+					Action: federationmodel.ActionDelete,
+					Service: &federationmodel.ServiceMessage{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "no gateways, service exported name changes",
+			remoteName:     "test-remote",
+			serviceExports: exportProductPage,
+			updatedExports: &v1alpha1.ServiceExports{
+				ObjectMeta: v1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1alpha1.ServiceExportsSpec{
+					Exports: []v1alpha1.ServiceExportRule{
+						{
+							Type: v1alpha1.NameSelectorType,
+							NameSelector: &v1alpha1.ServiceNameMapping{
+								Name: v1alpha1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+								Alias: &v1alpha1.ServiceName{
+									Namespace: "cluster",
+									Name:      "service",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			serviceEvents: nil,
+			expectedWatchEvents: []*federationmodel.WatchEvent{
+				{
+					Action: federationmodel.ActionDelete,
+					Service: &federationmodel.ServiceMessage{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+				{
+					Action: federationmodel.ActionAdd,
+					Service: &federationmodel.ServiceMessage{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "cluster",
+							Hostname:  "service.cluster.svc.test-remote.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "single gateway, public IP changed",
+			remoteName:     "test-remote",
+			serviceExports: exportProductPage,
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			gateways: []model.NetworkGateway{
+				{
+					Addr: "127.0.0.1",
+					Port: 443,
+				},
+			},
+			gatewayEvents: []struct{ newGateways []model.NetworkGateway }{
+				{
+					newGateways: []model.NetworkGateway{
+						{
+							Addr: "127.0.0.2",
+							Port: 443,
+						},
+					},
+				},
+			},
+			expectedWatchEvents: []*federationmodel.WatchEvent{
+				{
+					Action:  federationmodel.ActionUpdate,
+					Service: nil,
+				},
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			serviceDiscovery := serviceregistrymemory.NewServiceDiscovery(tc.services)
+			serviceDiscovery.AddGateways(tc.gateways...)
+			env := &model.Environment{
+				ServiceDiscovery: serviceDiscovery,
+			}
+
+			s, _ := NewServer(Options{
+				BindAddress: "127.0.0.1:0",
+				Env:         env,
+				Network:     "network1",
+				ConfigStore: configmemory.NewController(configmemory.Make(Schemas)),
+			})
+			stopCh := make(chan struct{})
+			go s.Run(stopCh)
+			defer close(stopCh)
+			s.resyncNetworkGateways()
+			s.AddMeshFederation(federation, tc.serviceExports)
+			req, err := http.NewRequest("GET", "http://"+s.Addr()+"/watch/"+tc.remoteName, nil)
+			if err != nil {
+				t.Fatal(err)
+			}
+			resp, err := http.DefaultClient.Do(req)
+			if err != nil {
+				t.Fatal(err)
+			}
+			if resp.StatusCode != http.StatusOK {
+				t.Fatalf("Status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
+			}
+			for _, e := range tc.serviceEvents {
+				s.UpdateService(e.svc, e.event)
+			}
+			if tc.updatedExports != nil {
+				s.UpdateExportsForMesh(tc.updatedExports)
+			}
+			for _, e := range tc.gatewayEvents {
+				serviceDiscovery.AddGateways(e.newGateways...)
+				// trigger a gateway resync
+				s.UpdateService(&model.Service{
+					Attributes: model.ServiceAttributes{
+						ClusterExternalAddresses: model.AddressMap{
+							Addresses: map[cluster.ID][]string{
+								cluster.ID("network1"): {"a"},
+							},
+						},
+					},
+				}, model.EventUpdate)
+			}
+			svcList := federationmodel.ServiceListMessage{}
+			dec := json.NewDecoder(resp.Body)
+			for i := 0; i < len(tc.expectedWatchEvents); i++ {
+				var e federationmodel.WatchEvent
+				err := dec.Decode(&e)
+				if err != nil {
+					if err == io.EOF {
+						break
+					}
+					t.Fatal(err)
+				}
+				if diff := cmp.Diff(&e, tc.expectedWatchEvents[i], ignoreChecksum); diff != "" {
+					t.Fatalf("comparison failed, -got +want:\n%s", diff)
+				}
+
+				if e.Service == nil {
+					svcList = getServiceList(t, s.Addr(), tc.remoteName)
+				} else if e.Action == federationmodel.ActionAdd {
+					svcList.Services = append(svcList.Services, e.Service)
+				} else if e.Action == federationmodel.ActionUpdate {
+					for i, svc := range svcList.Services {
+						if svc.Name == e.Service.Name {
+							svcList.Services[i] = e.Service
+							break
+						}
+					}
+				} else if e.Action == federationmodel.ActionDelete {
+					for i, svc := range svcList.Services {
+						if svc.Name == e.Service.Name {
+							svcList.Services = append(svcList.Services[:i], svcList.Services[i+1:]...)
+							break
+						}
+					}
+				}
+				if e.Checksum != svcList.GenerateChecksum() {
+					t.Fatalf("checksum mismatch, expected %d but got %d", svcList.GenerateChecksum(), e.Checksum)
+				}
+			}
+		})
+	}
+}
diff --git a/pkg/servicemesh/maistra.mk b/pkg/servicemesh/maistra.mk
index b3617199e4..08b0839421 100644
--- a/pkg/servicemesh/maistra.mk
+++ b/pkg/servicemesh/maistra.mk
@@ -15,6 +15,8 @@
 client_gen = client-gen
 lister_gen = lister-gen
 informer_gen = informer-gen
+deepcopy_gen = deepcopy-gen
+controller_gen = controller-gen
 
 kube_base_output_package = istio.io/istio/pkg/servicemesh
 kube_api_base_package = $(kube_base_output_package)/apis
@@ -53,11 +55,18 @@ maistra-gen-k8s-client:
 	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages_v1) --output-package $(kube_clientset_package_v1) -h $(kube_go_header_text)
 	@$(lister_gen) --input-dirs $(kube_api_packages_v1) --output-package $(kube_listers_package_v1) -h $(kube_go_header_text)
 	@$(informer_gen) --input-dirs $(kube_api_packages_v1) --versioned-clientset-package $(kube_clientset_package_v1)/$(kube_clientset_name) --listers-package $(kube_listers_package_v1) --output-package $(kube_informers_package_v1) -h $(kube_go_header_text)
-	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages_v1alpha1) --output-package $(kube_clientset_package_v1alpha1) -h $(kube_go_header_text)
-	@$(lister_gen) --input-dirs $(kube_api_packages_v1alpha1) --output-package $(kube_listers_package_v1alpha1) -h $(kube_go_header_text)
-	@$(informer_gen) --input-dirs $(kube_api_packages_v1alpha1) --versioned-clientset-package $(kube_clientset_package_v1alpha1)/$(kube_clientset_name) --listers-package $(kube_listers_package_v1alpha1) --output-package $(kube_informers_package_v1alpha1) -h $(kube_go_header_text)
+	@$(deepcopy_gen) -i  $(kube_api_packages_v1alpha1) -O zz_generated.deepcopy -h $(kube_go_header_text)
+	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages_v1alpha1) --output-package $(kube_clientset_package_v1alpha1) -h $(kube_go_header_text) --plural-exceptions ServiceExports:ServiceExports
+	@$(lister_gen) --input-dirs $(kube_api_packages_v1alpha1) --output-package $(kube_listers_package_v1alpha1) -h $(kube_go_header_text) --plural-exceptions ServiceExports:ServiceExports
+	@$(informer_gen) --input-dirs $(kube_api_packages_v1alpha1) --versioned-clientset-package $(kube_clientset_package_v1alpha1)/$(kube_clientset_name) --listers-package $(kube_listers_package_v1alpha1) --output-package $(kube_informers_package_v1alpha1) -h $(kube_go_header_text) --plural-exceptions ServiceExports:ServiceExports
 	@$(move_generated)
 
+# this is manual for now, but should be moved into a separate maistra/api project
+.PHONY: maistra-gen-k8s-client
+maistra-gen-crd-resources:
+	@$(controller_gen) crd paths=./pkg/servicemesh/apis/servicemesh/v1alpha1/ crd:preserveUnknownFields=false,crdVersions=v1beta1 output:dir=./manifests/charts/base/crds
+	@sed -i -e '/---/d' ./manifests/charts/base/crds/maistra.io_*.yaml
+
 .PHONY: vendor
 vendor:
 	@echo "updating vendor"
diff --git a/vendor/github.com/cenkalti/backoff/.gitignore b/vendor/github.com/cenkalti/backoff/.gitignore
new file mode 100644
index 0000000000..00268614f0
diff --git a/vendor/github.com/cenkalti/backoff/.travis.yml b/vendor/github.com/cenkalti/backoff/.travis.yml
new file mode 100644
index 0000000000..47a6a46ec2
diff --git a/vendor/github.com/cenkalti/backoff/LICENSE b/vendor/github.com/cenkalti/backoff/LICENSE
new file mode 100644
index 0000000000..89b8179965
diff --git a/vendor/github.com/cenkalti/backoff/README.md b/vendor/github.com/cenkalti/backoff/README.md
new file mode 100644
index 0000000000..55ebc98fc2
diff --git a/vendor/github.com/cenkalti/backoff/backoff.go b/vendor/github.com/cenkalti/backoff/backoff.go
new file mode 100644
index 0000000000..3676ee405d
diff --git a/vendor/github.com/cenkalti/backoff/context.go b/vendor/github.com/cenkalti/backoff/context.go
new file mode 100644
index 0000000000..7706faa2b6
diff --git a/vendor/github.com/cenkalti/backoff/exponential.go b/vendor/github.com/cenkalti/backoff/exponential.go
new file mode 100644
index 0000000000..a031a65979
diff --git a/vendor/github.com/cenkalti/backoff/retry.go b/vendor/github.com/cenkalti/backoff/retry.go
new file mode 100644
index 0000000000..e936a506f8
diff --git a/vendor/github.com/cenkalti/backoff/ticker.go b/vendor/github.com/cenkalti/backoff/ticker.go
new file mode 100644
index 0000000000..e41084b0ef
diff --git a/vendor/github.com/cenkalti/backoff/tries.go b/vendor/github.com/cenkalti/backoff/tries.go
new file mode 100644
index 0000000000..cfeefd9b76
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/LICENSE b/vendor/github.com/mitchellh/hashstructure/v2/LICENSE
new file mode 100644
index 0000000000..a3866a291f
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/README.md b/vendor/github.com/mitchellh/hashstructure/v2/README.md
new file mode 100644
index 0000000000..cb4efd6a44
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/errors.go b/vendor/github.com/mitchellh/hashstructure/v2/errors.go
new file mode 100644
index 0000000000..44b8951478
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/go.mod b/vendor/github.com/mitchellh/hashstructure/v2/go.mod
new file mode 100644
index 0000000000..7f7736ce06
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/hashstructure.go b/vendor/github.com/mitchellh/hashstructure/v2/hashstructure.go
new file mode 100644
index 0000000000..8078952821
diff --git a/vendor/github.com/mitchellh/hashstructure/v2/include.go b/vendor/github.com/mitchellh/hashstructure/v2/include.go
new file mode 100644
index 0000000000..702d35415d
-- 
2.35.3

