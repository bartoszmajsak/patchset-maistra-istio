From 448a65f824e56febba86f661b8647318415c52a2 Mon Sep 17 00:00:00 2001
From: Rob Cernich <rcernich@redhat.com>
Date: Thu, 3 Jun 2021 12:07:03 +0200
Subject: [federation] MAISTRA-2309 create CRD for FederationStatus (#348)

Signed-off-by: rcernich <rcernich@redhat.com>
---
 bin/update_maistra_deps.sh                    |   1 +
 go.sum                                        |   2 -
 .../crds/maistra.io_federationstatuses.yaml   | 195 +++++
 .../charts/base/files/gen-istio-cluster.yaml  | 203 ++++-
 manifests/charts/base/templates/crds.yaml     |   1 +
 manifests/charts/base/templates/role.yaml     |   5 +-
 pilot/pkg/bootstrap/server.go                 |   2 +
 .../serviceregistry/federation/controller.go  |  34 +-
 .../federation/discovery/controller.go        |  15 +-
 .../federation/discovery/controller_test.go   |  28 +-
 .../federation/discovery/discovery.go         |  10 +-
 pkg/servicemesh/federation/federation.go      |  10 +
 pkg/servicemesh/federation/server/server.go   |  40 +-
 .../federation/server/server_test.go          |  60 +-
 pkg/servicemesh/federation/status/handler.go  | 448 +++++++++++
 pkg/servicemesh/federation/status/manager.go  | 251 +++++++
 .../federation/status/manager_test.go         | 699 ++++++++++++++++++
 17 files changed, 1979 insertions(+), 25 deletions(-)
 create mode 100644 manifests/charts/base/crds/maistra.io_federationstatuses.yaml
 create mode 100644 pkg/servicemesh/federation/status/handler.go
 create mode 100644 pkg/servicemesh/federation/status/manager.go
 create mode 100644 pkg/servicemesh/federation/status/manager_test.go

diff --git a/bin/update_maistra_deps.sh b/bin/update_maistra_deps.sh
index e3fab1ddd4..a6e90011f5 100755
--- a/bin/update_maistra_deps.sh
+++ b/bin/update_maistra_deps.sh
@@ -37,6 +37,7 @@ popd
 # cp "${dir}"/manifests/* manifests/charts/base/crds
 
 cp "${dir}"/manifests/maistra.io_meshfederations.yaml manifests/charts/base/crds
+cp "${dir}"/manifests/maistra.io_federationstatuses.yaml manifests/charts/base/crds
 cp "${dir}"/manifests/maistra.io_serviceexports.yaml manifests/charts/base/crds
 cp "${dir}"/manifests/maistra.io_serviceimports.yaml manifests/charts/base/crds
 cp "${dir}"/manifests/maistra.io_servicemeshextensions.yaml manifests/charts/base/crds
diff --git a/go.sum b/go.sum
index a5c4a33a13..23e1e2ba93 100644
--- a/go.sum
+++ b/go.sum
@@ -2056,8 +2056,6 @@ k8s.io/utils v0.0.0-20210819203725-bdf08cb9a70a/go.mod h1:jPW/WVKK9YHAvNhRxK0md/
 k8s.io/utils v0.0.0-20210820185131-d34e5cb4466e/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
 k8s.io/utils v0.0.0-20210930125809-cb0fa318a74b h1:wxEMGetGMur3J1xuGLQY7GEQYg9bZxKn3tKo5k/eYcs=
 k8s.io/utils v0.0.0-20210930125809-cb0fa318a74b/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
-maistra.io/api v0.0.0-20210519155434-9f28759d3cb8 h1:qQ8fsWOX9Kpt4S5MyZGID5MN52QmYKSnKhXoIrSjbkU=
-maistra.io/api v0.0.0-20210519155434-9f28759d3cb8/go.mod h1:DoQHGC9UUk0r2B+Tc4N33u5BGyKT9/xaWWawIqMTs4o=
 maistra.io/api v0.0.0-20210601141927-1cbee4cb8ce8 h1:hBSNtXLQFFH27vJQvblel28HFClrJxVHlVKK9g69auE=
 maistra.io/api v0.0.0-20210601141927-1cbee4cb8ce8/go.mod h1:Os/zrIv6nsjgC43UAo17FFv+fvYlzANUWIpNNZEZ/KE=
 oras.land/oras-go v0.4.0/go.mod h1:VJcU+VE4rkclUbum5C0O7deEZbBYnsnpbGSACwTjOcg=
diff --git a/manifests/charts/base/crds/maistra.io_federationstatuses.yaml b/manifests/charts/base/crds/maistra.io_federationstatuses.yaml
new file mode 100644
index 0000000000..654aabb44c
--- /dev/null
+++ b/manifests/charts/base/crds/maistra.io_federationstatuses.yaml
@@ -0,0 +1,195 @@
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: (devel)
+  creationTimestamp: null
+  name: federationstatuses.maistra.io
+spec:
+  group: maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: FederationStatus
+    listKind: FederationStatusList
+    plural: federationstatuses
+    singular: federationstatus
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: FederationStatus is the Schema for reporting the status of a MeshFederation. The name of the FederationStatus will match the name of the istiod pod to which it is associated.  There will be one FederationStatus resource for each istiod pod.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: Spec is unused
+          type: object
+        status:
+          description: Status of the mesh federations
+          properties:
+            meshes:
+              description: Meshes represents the status of each federated mesh.  The key represents the name of the MeshFederation resource configuring federation for with a remote mesh (as namespace/name).
+              items:
+                description: FederationStatusDetails provides details about a particular federated mesh.
+                properties:
+                  discovery:
+                    description: Discovery provides details about the connection to the remote mesh.
+                    properties:
+                      remotes:
+                        description: Remotes represents details related to the inbound connections remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    type: object
+                  exports:
+                    description: Exports provides details about the services exported by this mesh.
+                    items:
+                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
+                      properties:
+                        exportedName:
+                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                          type: string
+                        localService:
+                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                          properties:
+                            hostname:
+                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                              type: string
+                            name:
+                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                              type: string
+                            namespace:
+                              description: Namespace represents the namespace within which the service resides.
+                              type: string
+                          required:
+                          - hostname
+                          - name
+                          - namespace
+                          type: object
+                      required:
+                      - exportedName
+                      - localService
+                      type: object
+                    type: array
+                  imports:
+                    description: Imports provides details about the services imported by this mesh.
+                    items:
+                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
+                      properties:
+                        exportedName:
+                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                          type: string
+                        localService:
+                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                          properties:
+                            hostname:
+                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                              type: string
+                            name:
+                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                              type: string
+                            namespace:
+                              description: Namespace represents the namespace within which the service resides.
+                              type: string
+                          required:
+                          - hostname
+                          - name
+                          - namespace
+                          type: object
+                      required:
+                      - exportedName
+                      - localService
+                      type: object
+                    type: array
+                  mesh:
+                    description: Mesh is the mesh to which this status applies.  This maps to a MeshFederation resource.
+                    type: string
+                required:
+                - discovery
+                - exports
+                - imports
+                - mesh
+                type: object
+              nullable: true
+              type: array
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/files/gen-istio-cluster.yaml b/manifests/charts/base/files/gen-istio-cluster.yaml
index 6f61267f3b..ca6f9f59a8 100644
--- a/manifests/charts/base/files/gen-istio-cluster.yaml
+++ b/manifests/charts/base/files/gen-istio-cluster.yaml
@@ -5993,6 +5993,204 @@ spec:
     storage: true
 ---
 
+---
+# Source: crds/maistra.io_federationstatuses.yaml
+
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: (devel)
+  creationTimestamp: null
+  name: federationstatuses.maistra.io
+spec:
+  group: maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: FederationStatus
+    listKind: FederationStatusList
+    plural: federationstatuses
+    singular: federationstatus
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: FederationStatus is the Schema for reporting the status of a MeshFederation. The name of the FederationStatus will match the name of the istiod pod to which it is associated.  There will be one FederationStatus resource for each istiod pod.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: Spec is unused
+          type: object
+        status:
+          description: Status of the mesh federations
+          properties:
+            meshes:
+              description: Meshes represents the status of each federated mesh.  The key represents the name of the MeshFederation resource configuring federation for with a remote mesh (as namespace/name).
+              items:
+                description: FederationStatusDetails provides details about a particular federated mesh.
+                properties:
+                  discovery:
+                    description: Discovery provides details about the connection to the remote mesh.
+                    properties:
+                      remotes:
+                        description: Remotes represents details related to the inbound connections remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    type: object
+                  exports:
+                    description: Exports provides details about the services exported by this mesh.
+                    items:
+                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
+                      properties:
+                        exportedName:
+                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                          type: string
+                        localService:
+                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                          properties:
+                            hostname:
+                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                              type: string
+                            name:
+                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                              type: string
+                            namespace:
+                              description: Namespace represents the namespace within which the service resides.
+                              type: string
+                          required:
+                          - hostname
+                          - name
+                          - namespace
+                          type: object
+                      required:
+                      - exportedName
+                      - localService
+                      type: object
+                    type: array
+                  imports:
+                    description: Imports provides details about the services imported by this mesh.
+                    items:
+                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
+                      properties:
+                        exportedName:
+                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                          type: string
+                        localService:
+                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                          properties:
+                            hostname:
+                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                              type: string
+                            name:
+                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                              type: string
+                            namespace:
+                              description: Namespace represents the namespace within which the service resides.
+                              type: string
+                          required:
+                          - hostname
+                          - name
+                          - namespace
+                          type: object
+                      required:
+                      - exportedName
+                      - localService
+                      type: object
+                    type: array
+                  mesh:
+                    description: Mesh is the mesh to which this status applies.  This maps to a MeshFederation resource.
+                    type: string
+                required:
+                - discovery
+                - exports
+                - imports
+                - mesh
+                type: object
+              nullable: true
+              type: array
+          type: object
+      type: object
+  version: v1alpha1
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
+
 ---
 # Source: crds/maistra.io_meshfederations.yaml
 
@@ -6774,8 +6972,11 @@ rules:
 
 # For MeshFederation support
 - apiGroups: ["maistra.io"]
-  resources: ["meshfederations", "meshfederations/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
+  resources: ["meshfederations", "meshfederations/status", "federationstatuses", "federationstatuses/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
   verbs: ["get", "list", "watch", "patch", "update"]
+- apiGroups: ["maistra.io"]
+  resources: ["federationstatuses", "federationstatuses/status"]
+  verbs: ["create"]
 ---
 # Source: base/templates/rolebinding.yaml
 # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
diff --git a/manifests/charts/base/templates/crds.yaml b/manifests/charts/base/templates/crds.yaml
index c10c5216cb..bfffba287a 100644
--- a/manifests/charts/base/templates/crds.yaml
+++ b/manifests/charts/base/templates/crds.yaml
@@ -2,6 +2,7 @@
 {{ .Files.Get "crds/crd-all.gen.yaml" }}
 {{ .Files.Get "crds/crd-operator.yaml" }}
 {{ .Files.Get "crds/maistra.io_meshfederations.yaml" }}
+{{ .Files.Get "crds/maistra.io_federationstatuses.yaml" }}
 {{ .Files.Get "crds/maistra.io_serviceexports.yaml" }}
 {{ .Files.Get "crds/maistra.io_serviceimports.yaml" }}
 {{ .Files.Get "crds/maistra.io_servicemeshextensions.yaml" }}
diff --git a/manifests/charts/base/templates/role.yaml b/manifests/charts/base/templates/role.yaml
index c3feba4c2d..06c93712aa 100644
--- a/manifests/charts/base/templates/role.yaml
+++ b/manifests/charts/base/templates/role.yaml
@@ -26,5 +26,8 @@ rules:
 
 # For MeshFederation support
 - apiGroups: ["maistra.io"]
-  resources: ["meshfederations", "meshfederations/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
+  resources: ["meshfederations", "meshfederations/status", "federationstatuses", "federationstatuses/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
   verbs: ["get", "list", "watch", "patch", "update"]
+- apiGroups: ["maistra.io"]
+  resources: ["federationstatuses", "federationstatuses/status"]
+  verbs: ["create"]
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index a7f1fd34b0..fa564d86d2 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -291,6 +291,8 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 				Env:               s.environment,
 				XDSUpdater:        s.XDSServer,
 				ServiceController: s.ServiceController(),
+				IstiodNamespace:   args.Namespace,
+				IstiodPodName:     args.PodName,
 			})
 			if err != nil {
 				return nil, fmt.Errorf("error initializing federation: %v", err)
diff --git a/pilot/pkg/serviceregistry/federation/controller.go b/pilot/pkg/serviceregistry/federation/controller.go
index 21a908de3a..9849a3dcb9 100644
--- a/pilot/pkg/serviceregistry/federation/controller.go
+++ b/pilot/pkg/serviceregistry/federation/controller.go
@@ -42,6 +42,7 @@ import (
 	"istio.io/istio/pkg/network"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/istio/pkg/servicemesh/federation/status"
 	"istio.io/pkg/log"
 )
 
@@ -72,9 +73,10 @@ type Controller struct {
 
 	logger *log.Scope
 
-	kubeClient  kube.Client
-	configStore model.ConfigStoreCache
-	xdsUpdater  model.XDSUpdater
+	kubeClient    kube.Client
+	statusHandler status.Handler
+	configStore   model.ConfigStoreCache
+	xdsUpdater    model.XDSUpdater
 
 	localDomainSuffix   string
 	defaultDomainSuffix string
@@ -110,6 +112,7 @@ type Options struct {
 	Network        string
 	Namespace      string
 	KubeClient     kube.Client
+	StatusHandler  status.Handler
 	ConfigStore    model.ConfigStoreCache
 	XDSUpdater     model.XDSUpdater
 	ResyncPeriod   time.Duration
@@ -152,6 +155,7 @@ func NewController(opt Options, mesh *v1alpha1.MeshFederation, defaultImportConf
 		serviceStore:        map[host.Name]*model.Service{},
 		instanceStore:       map[host.Name][]*model.ServiceInstance{},
 		kubeClient:          opt.KubeClient,
+		statusHandler:       opt.StatusHandler,
 		configStore:         opt.ConfigStore,
 		xdsUpdater:          opt.XDSUpdater,
 		resyncPeriod:        opt.ResyncPeriod,
@@ -423,6 +427,7 @@ func (c *Controller) convertServices(serviceList *federationmodel.ServiceListMes
 	for key, existing := range oldImports {
 		if _, exists := c.imports[key]; !exists {
 			updatedConfigs := c.deleteService(&federationmodel.ServiceMessage{ServiceKey: key}, existing)
+			c.statusHandler.ImportRemoved(key.Hostname)
 			for key, value := range updatedConfigs {
 				allUpdatedConfigs[key] = value
 			}
@@ -576,6 +581,8 @@ func (c *Controller) handleEvent(e *federationmodel.WatchEvent) {
 		return
 	}
 
+	c.statusHandler.WatchEventReceived()
+
 	unlockIt := true
 	c.storeLock.Lock()
 	defer func() {
@@ -635,6 +642,7 @@ func (c *Controller) handleEvent(e *federationmodel.WatchEvent) {
 		}
 	case federationmodel.ActionDelete:
 		updatedConfigs = c.deleteService(e.Service, existing)
+		c.statusHandler.ImportRemoved(e.Service.Hostname)
 	}
 	if len(updatedConfigs) > 0 {
 		c.logger.Debugf("pushing XDS config for services: %+v", updatedConfigs)
@@ -664,6 +672,7 @@ func (c *Controller) addService(service *federationmodel.ServiceMessage) (map[mo
 		Attributes: model.ServiceAttributes{Name: service.Name, Namespace: service.Namespace},
 	})
 	if importedName == nil {
+		c.statusHandler.ImportAdded(federationmodel.ServiceKey{}, service.Hostname)
 		c.logger.Debugf("skipping import of service %+v, as it does not match an import filter", service.ServiceKey)
 		return nil, nil
 	}
@@ -693,6 +702,8 @@ func (c *Controller) addService(service *federationmodel.ServiceMessage) (map[mo
 		Namespace: localService.Attributes.Namespace,
 	}] = struct{}{}
 
+	c.statusHandler.ImportAdded(*importedName, service.Hostname)
+
 	return updatedConfigs, nil
 }
 
@@ -706,6 +717,7 @@ func (c *Controller) updateService(service *federationmodel.ServiceMessage, exis
 		Attributes: model.ServiceAttributes{Name: service.Name, Namespace: service.Namespace},
 	})
 	if importedName == nil {
+		c.statusHandler.ImportUpdated(federationmodel.ServiceKey{}, service.Hostname)
 		if existing != nil {
 			c.logger.Debugf("deleting import for service %+v, as it no longer matches an import filter", service.ServiceKey)
 			return c.deleteService(service, existing), nil
@@ -759,6 +771,8 @@ func (c *Controller) updateService(service *federationmodel.ServiceMessage, exis
 		Namespace: localService.Attributes.Namespace,
 	}] = struct{}{}
 
+	c.statusHandler.ImportUpdated(*importedName, service.Hostname)
+
 	return updatedConfigs, nil
 }
 
@@ -834,6 +848,7 @@ func (c *Controller) removeServiceFromStore(service federationmodel.ServiceKey)
 }
 
 func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-chan struct{}) error {
+	c.statusHandler.WatchInitiated()
 	url := c.discoveryURL + "/watch"
 	req, err := http.NewRequest(http.MethodGet, url, nil)
 	if err != nil {
@@ -842,6 +857,15 @@ func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-ch
 	}
 	req.Header.Add("discovery-address", c.networkAddress)
 	resp, err := http.DefaultClient.Do(req)
+	defer func() {
+		status := ""
+		if resp != nil {
+			status = resp.Status
+		} else if err != nil {
+			status = err.Error()
+		}
+		c.statusHandler.WatchTerminated(status)
+	}()
 	if err != nil {
 		return err
 	}
@@ -849,10 +873,13 @@ func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-ch
 		return fmt.Errorf("status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
 	}
 
+	c.statusHandler.Watching()
+
 	// connection was established successfully. reset backoffPolicy
 	c.backoffPolicy.Reset()
 
 	dec := json.NewDecoder(resp.Body)
+	defer resp.Body.Close()
 	for {
 		select {
 		case <-stopCh:
@@ -876,6 +903,7 @@ func (c *Controller) resync() uint64 {
 	c.updateGateways(svcList)
 	if svcList != nil {
 		c.convertServices(svcList)
+		c.statusHandler.FullSyncComplete()
 		return svcList.Checksum
 	}
 	return 0
diff --git a/pkg/servicemesh/federation/discovery/controller.go b/pkg/servicemesh/federation/discovery/controller.go
index 0bb347b8d2..7b00bf97d0 100644
--- a/pkg/servicemesh/federation/discovery/controller.go
+++ b/pkg/servicemesh/federation/discovery/controller.go
@@ -23,6 +23,7 @@ import (
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/types"
 	utilerrors "k8s.io/apimachinery/pkg/util/errors"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
@@ -41,6 +42,7 @@ import (
 	memberroll "istio.io/istio/pkg/servicemesh/controller"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/servicemesh/federation/server"
+	"istio.io/istio/pkg/servicemesh/federation/status"
 )
 
 const controllerName = "federation-discovery-controller"
@@ -52,6 +54,7 @@ type Options struct {
 	Env               *model.Environment
 	ConfigStore       model.ConfigStoreCache
 	FederationManager server.FederationManager
+	StatusManager     status.Manager
 	LocalNetwork      string
 	LocalClusterID    string
 }
@@ -65,6 +68,7 @@ type Controller struct {
 	cs                maistraclient.Interface
 	env               *model.Environment
 	federationManager server.FederationManager
+	statusManager     status.Manager
 	sc                *aggregate.Controller
 	xds               model.XDSUpdater
 	mu                sync.Mutex
@@ -134,6 +138,7 @@ func internalNewController(cs maistraclient.Interface, mrc memberroll.MemberRoll
 		stopChannels:      make(map[cluster.ID]chan struct{}),
 		xds:               opt.XDSUpdater,
 		federationManager: opt.FederationManager,
+		statusManager:     opt.StatusManager,
 	}
 	internalController := kubecontroller.NewController(kubecontroller.Options{
 		Informer:     informer,
@@ -162,6 +167,9 @@ func (c *Controller) HasSynced() bool {
 func (c *Controller) reconcile(resourceName string) error {
 	c.Logger.Debugf("Reconciling MeshFederation %s", resourceName)
 	defer func() {
+		if err := c.statusManager.PushStatus(); err != nil {
+			c.Logger.Errorf("error pushing FederationStatus for mesh %s: %s", resourceName, err)
+		}
 		c.Logger.Debugf("Completed reconciliation of MeshFederation %s", resourceName)
 	}()
 
@@ -243,7 +251,9 @@ func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederati
 			c.Logger.Errorf("error retrieving ServiceImports associated with MeshFederation %s: %s", instance.Name, err)
 			return err
 		}
-		if err := c.federationManager.AddMeshFederation(instance, exportConfig); err != nil {
+
+		statusHandler := c.statusManager.FederationAdded(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
+		if err := c.federationManager.AddMeshFederation(instance, exportConfig, statusHandler); err != nil {
 			return err
 		}
 
@@ -262,6 +272,7 @@ func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederati
 			UseDirectCalls: instance.Spec.Security != nil && instance.Spec.Security.AllowDirectOutbound,
 			KubeClient:     c.kubeClient,
 			ConfigStore:    c.ConfigStoreCache,
+			StatusHandler:  statusHandler,
 			XDSUpdater:     c.xds,
 			ResyncPeriod:   time.Minute * 5,
 			DomainSuffix:   c.env.DomainSuffix,
@@ -314,6 +325,8 @@ func (c *Controller) delete(ctx context.Context, instance *v1alpha1.MeshFederati
 		allErrors = append(allErrors, err)
 	}
 
+	c.statusManager.FederationDeleted(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
+
 	return utilerrors.NewAggregate(allErrors)
 }
 
diff --git a/pkg/servicemesh/federation/discovery/controller_test.go b/pkg/servicemesh/federation/discovery/controller_test.go
index a804e91d18..c0540ffd6f 100644
--- a/pkg/servicemesh/federation/discovery/controller_test.go
+++ b/pkg/servicemesh/federation/discovery/controller_test.go
@@ -22,6 +22,7 @@ import (
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/api/meta"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/watch"
 	"maistra.io/api/client/versioned/fake"
 	maistrav1alpha1 "maistra.io/api/core/v1alpha1"
@@ -36,18 +37,36 @@ import (
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/servicemesh/federation/common"
+	"istio.io/istio/pkg/servicemesh/federation/status"
 )
 
 type fakeManager struct{}
 
-func (m *fakeManager) AddMeshFederation(mesh *maistrav1alpha1.MeshFederation, exports *maistrav1alpha1.ServiceExports) error {
+func (m *fakeManager) AddMeshFederation(_ *maistrav1alpha1.MeshFederation, _ *maistrav1alpha1.ServiceExports, _ status.Handler) error {
 	return nil
 }
-func (m *fakeManager) DeleteMeshFederation(name string) {}
-func (m *fakeManager) UpdateExportsForMesh(exports *maistrav1alpha1.ServiceExports) error {
+func (m *fakeManager) DeleteMeshFederation(_ string) {}
+func (m *fakeManager) UpdateExportsForMesh(_ *maistrav1alpha1.ServiceExports) error {
+	return nil
+}
+func (m *fakeManager) DeleteExportsForMesh(_ string) {}
+
+type fakeStatusManager struct{}
+
+func (m *fakeStatusManager) FederationAdded(mesh types.NamespacedName) status.Handler {
+	return nil
+}
+
+func (m *fakeStatusManager) FederationDeleted(mesh types.NamespacedName) {
+}
+
+func (m *fakeStatusManager) HandlerFor(mesh types.NamespacedName) status.Handler {
+	return nil
+}
+
+func (m *fakeStatusManager) PushStatus() error {
 	return nil
 }
-func (m *fakeManager) DeleteExportsForMesh(name string) {}
 
 func TestValidOptions(t *testing.T) {
 	opt := Options{
@@ -167,6 +186,7 @@ func TestReconcile(t *testing.T) {
 		XDSUpdater:        options.xdsUpdater,
 		Env:               options.env,
 		FederationManager: &fakeManager{},
+		StatusManager:     &fakeStatusManager{},
 		ConfigStore:       configmemory.NewController(configmemory.Make(Schemas)),
 	})
 
diff --git a/pkg/servicemesh/federation/discovery/discovery.go b/pkg/servicemesh/federation/discovery/discovery.go
index f0598e58b9..7668687391 100644
--- a/pkg/servicemesh/federation/discovery/discovery.go
+++ b/pkg/servicemesh/federation/discovery/discovery.go
@@ -270,8 +270,8 @@ func serviceAddressPort(addr string) (string, string) {
 	return addr, "80"
 }
 
-func (c *Controller) discoveryHostname(base string) string {
-	return base + ".federation.dummy.domain"
+func (c *Controller) discoveryHostname(instance *v1alpha1.MeshFederation) string {
+	return fmt.Sprintf("discovery.%s.svc.%s.local", instance.Namespace, instance.Name)
 }
 
 func (c *Controller) discoveryService(instance *v1alpha1.MeshFederation) *config.Config {
@@ -292,7 +292,7 @@ func (c *Controller) discoveryService(instance *v1alpha1.MeshFederation) *config
 		},
 		Spec: &rawnetworking.ServiceEntry{
 			Hosts: []string{
-				c.discoveryHostname(name),
+				c.discoveryHostname(instance),
 			},
 			Location: rawnetworking.ServiceEntry_MESH_EXTERNAL,
 			Ports: []*rawnetworking.Port{
@@ -438,7 +438,7 @@ func (c *Controller) discoveryVirtualService(
 	}
 	ingressGatewayName := fmt.Sprintf("%s/%s-ingress", instance.Namespace, name)
 	egressGatewayName := fmt.Sprintf("%s/%s-egress", instance.Namespace, name)
-	discoveryService := c.discoveryHostname(name)
+	discoveryService := c.discoveryHostname(instance)
 	discoveryHost := instance.Spec.NetworkAddress
 	discoveryPort := common.DefaultDiscoveryPort
 	vs := &config.Config{
@@ -565,7 +565,7 @@ func (c *Controller) discoveryVirtualService(
 func (c *Controller) discoveryDestinationRule(instance *v1alpha1.MeshFederation) *config.Config {
 	// DestinationRule to configure mTLS for outbound discovery requests
 	name := discoveryResourceName(instance)
-	discoveryHost := c.discoveryHostname(name)
+	discoveryHost := c.discoveryHostname(instance)
 	discoveryPort := common.DefaultDiscoveryPort
 	dr := &config.Config{
 		Meta: config.Meta{
diff --git a/pkg/servicemesh/federation/federation.go b/pkg/servicemesh/federation/federation.go
index f466f91c52..89254b5a9e 100644
--- a/pkg/servicemesh/federation/federation.go
+++ b/pkg/servicemesh/federation/federation.go
@@ -17,6 +17,7 @@ package federation
 import (
 	"fmt"
 
+	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/errors"
 
 	"istio.io/istio/pilot/pkg/config/memory"
@@ -28,6 +29,7 @@ import (
 	"istio.io/istio/pkg/servicemesh/federation/exports"
 	"istio.io/istio/pkg/servicemesh/federation/imports"
 	"istio.io/istio/pkg/servicemesh/federation/server"
+	"istio.io/istio/pkg/servicemesh/federation/status"
 	"istio.io/pkg/log"
 )
 
@@ -56,6 +58,8 @@ type Options struct {
 	ServiceController *aggregate.Controller
 	LocalNetwork      string
 	LocalClusterID    string
+	IstiodNamespace   string
+	IstiodPodName     string
 }
 
 type Federation struct {
@@ -70,6 +74,11 @@ func New(opt Options) (*Federation, error) {
 	if err := opt.validate(); err != nil {
 		return nil, err
 	}
+	name := types.NamespacedName{Name: opt.IstiodPodName, Namespace: opt.IstiodNamespace}
+	statusManager, err := status.NewManager(name, opt.KubeClient)
+	if err != nil {
+		return nil, err
+	}
 	configStore := newConfigStore()
 	server, err := server.NewServer(server.Options{
 		BindAddress: opt.BindAddress,
@@ -103,6 +112,7 @@ func New(opt Options) (*Federation, error) {
 		Env:               opt.Env,
 		ConfigStore:       configStore,
 		FederationManager: server,
+		StatusManager:     statusManager,
 	})
 	if err != nil {
 		return nil, err
diff --git a/pkg/servicemesh/federation/server/server.go b/pkg/servicemesh/federation/server/server.go
index 8805c09d29..eebe985add 100644
--- a/pkg/servicemesh/federation/server/server.go
+++ b/pkg/servicemesh/federation/server/server.go
@@ -34,6 +34,7 @@ import (
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/istio/pkg/servicemesh/federation/status"
 	"istio.io/pkg/log"
 )
 
@@ -49,7 +50,7 @@ type Options struct {
 }
 
 type FederationManager interface {
-	AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports) error
+	AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports, statusHandler status.Handler) error
 	DeleteMeshFederation(name string)
 	UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error
 	DeleteExportsForMesh(name string)
@@ -120,7 +121,7 @@ func (s *Server) ingressServiceName(mesh *v1alpha1.MeshFederation) string {
 	return fmt.Sprintf("%s.%s.svc.%s", mesh.Spec.Gateways.Ingress.Name, mesh.Namespace, s.env.DomainSuffix)
 }
 
-func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports) error {
+func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports, statusHandler status.Handler) error {
 	exportConfig := common.NewServiceExporter(exports, s.defaultExportConfig, exportDomainSuffix(mesh.Name))
 
 	untypedMeshServer, ok := s.meshes.Load(mesh.Name)
@@ -133,6 +134,7 @@ func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alp
 		env:                      s.env,
 		mesh:                     mesh,
 		exportConfig:             exportConfig,
+		statusHandler:            statusHandler,
 		configStore:              s.configStore,
 		ingressService:           s.ingressServiceName(mesh),
 		currentServices:          make(map[federationmodel.ServiceKey]*federationmodel.ServiceMessage),
@@ -205,6 +207,8 @@ func (s *Server) handleServiceList(response http.ResponseWriter, request *http.R
 		response.WriteHeader(500)
 		return
 	}
+	connection := getClientConnectionKey(request)
+	mesh.statusHandler.FullSyncSent(connection)
 }
 
 func (s *Server) handleWatch(response http.ResponseWriter, request *http.Request) {
@@ -214,7 +218,7 @@ func (s *Server) handleWatch(response http.ResponseWriter, request *http.Request
 		response.WriteHeader(400)
 		return
 	}
-	mesh.handleWatch(response)
+	mesh.handleWatch(response, request)
 }
 
 func (s *Server) Run(stopCh <-chan struct{}) {
@@ -316,7 +320,8 @@ type meshServer struct {
 	mesh         *v1alpha1.MeshFederation
 	exportConfig *common.ServiceExporter
 
-	configStore model.ConfigStoreCache
+	statusHandler status.Handler
+	configStore   model.ConfigStoreCache
 
 	ingressService  string
 	gatewaySAs      []string
@@ -401,12 +406,23 @@ func (s *meshServer) handleServiceList(response http.ResponseWriter) {
 	}
 }
 
-func (s *meshServer) handleWatch(response http.ResponseWriter) {
+func getClientConnectionKey(request *http.Request) string {
+	forwardedIPs := strings.Split(request.Header.Get("X-Forwarded-For"), ",")
+	if len(forwardedIPs) > 0 {
+		return strings.TrimSpace(forwardedIPs[0])
+	}
+	return request.RemoteAddr
+}
+
+func (s *meshServer) handleWatch(response http.ResponseWriter, request *http.Request) {
 	watch := make(chan *federationmodel.WatchEvent)
 	s.watchMut.Lock()
 	s.currentWatches = append(s.currentWatches, watch)
 	s.watchMut.Unlock()
+	connection := getClientConnectionKey(request)
+	s.statusHandler.RemoteWatchAccepted(connection)
 	defer func() {
+		s.statusHandler.RemoteWatchTerminated(connection)
 		s.watchMut.Lock()
 		for i, w := range s.currentWatches {
 			if w == watch {
@@ -426,7 +442,12 @@ func (s *meshServer) handleWatch(response http.ResponseWriter) {
 	}
 	flusher.Flush()
 	for {
-		event := <-watch
+		var event *federationmodel.WatchEvent
+		select {
+		case event = <-watch:
+		case <-request.Context().Done():
+			return
+		}
 		respBytes, err := json.Marshal(event)
 		if err != nil {
 			s.logger.Errorf("error marshaling watch event: %s", err)
@@ -443,6 +464,7 @@ func (s *meshServer) handleWatch(response http.ResponseWriter) {
 			return
 		}
 		flusher.Flush()
+		s.statusHandler.WatchEventSent(connection)
 	}
 }
 
@@ -486,6 +508,9 @@ func (s *meshServer) resync() {
 			s.addService(svcKey, svcMessage)
 		}
 	}
+	if err := s.statusHandler.Flush(); err != nil {
+		s.logger.Errorf("error updating federation export status for mesh %s: %s", s.mesh.Name, err)
+	}
 }
 
 // s must be lock()ed
@@ -587,6 +612,7 @@ func (s *meshServer) addService(svc federationmodel.ServiceKey, msg *federationm
 		Action:  federationmodel.ActionAdd,
 		Service: msg,
 	}
+	s.statusHandler.ExportAdded(svc, msg.Hostname)
 	s.pushWatchEvent(e)
 }
 
@@ -598,6 +624,7 @@ func (s *meshServer) updateService(svc federationmodel.ServiceKey, msg *federati
 		Action:  federationmodel.ActionUpdate,
 		Service: msg,
 	}
+	s.statusHandler.ExportUpdated(svc, msg.Hostname)
 	s.pushWatchEvent(e)
 }
 
@@ -612,6 +639,7 @@ func (s *meshServer) deleteService(svc federationmodel.ServiceKey, msg *federati
 		Action:  federationmodel.ActionDelete,
 		Service: msg,
 	}
+	s.statusHandler.ExportRemoved(svc)
 	s.pushWatchEvent(e)
 }
 
diff --git a/pkg/servicemesh/federation/server/server_test.go b/pkg/servicemesh/federation/server/server_test.go
index 8b18b8ba69..892f825b33 100644
--- a/pkg/servicemesh/federation/server/server_test.go
+++ b/pkg/servicemesh/federation/server/server_test.go
@@ -35,6 +35,62 @@ import (
 
 var ignoreChecksum = cmp.FilterPath(func(p cmp.Path) bool { return p.String() == "Checksum" }, cmp.Ignore())
 
+type fakeStatusHandler struct{}
+
+// Outbound connections
+func (m *fakeStatusHandler) WatchInitiated() {
+}
+
+func (m *fakeStatusHandler) Watching() {
+}
+
+func (m *fakeStatusHandler) WatchEventReceived() {
+}
+
+func (m *fakeStatusHandler) FullSyncComplete() {
+}
+
+func (m *fakeStatusHandler) WatchTerminated(status string) {
+}
+
+// Inbound connections
+func (m *fakeStatusHandler) RemoteWatchAccepted(source string) {
+}
+
+func (m *fakeStatusHandler) WatchEventSent(source string) {
+}
+
+func (m *fakeStatusHandler) FullSyncSent(source string) {
+}
+
+func (m *fakeStatusHandler) RemoteWatchTerminated(source string) {
+}
+
+// Exports
+func (m *fakeStatusHandler) ExportAdded(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *fakeStatusHandler) ExportUpdated(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *fakeStatusHandler) ExportRemoved(service federationmodel.ServiceKey) {
+}
+
+// Imports
+func (m *fakeStatusHandler) ImportAdded(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *fakeStatusHandler) ImportUpdated(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *fakeStatusHandler) ImportRemoved(exportedName string) {
+}
+
+// Write status
+func (m *fakeStatusHandler) Flush() error {
+	return nil
+}
+
 func TestServiceList(t *testing.T) {
 	federation := &v1alpha1.MeshFederation{
 		ObjectMeta: v1.ObjectMeta{
@@ -371,7 +427,7 @@ func TestServiceList(t *testing.T) {
 			go s.Run(stopCh)
 			defer close(stopCh)
 			s.resyncNetworkGateways()
-			s.AddMeshFederation(federation, tc.serviceExports)
+			s.AddMeshFederation(federation, tc.serviceExports, &fakeStatusHandler{})
 			for _, e := range tc.serviceEvents {
 				s.UpdateService(e.svc, e.event)
 			}
@@ -690,7 +746,7 @@ func TestWatch(t *testing.T) {
 			go s.Run(stopCh)
 			defer close(stopCh)
 			s.resyncNetworkGateways()
-			s.AddMeshFederation(federation, tc.serviceExports)
+			s.AddMeshFederation(federation, tc.serviceExports, &fakeStatusHandler{})
 			req, err := http.NewRequest("GET", "http://"+s.Addr()+"/watch/"+tc.remoteName, nil)
 			if err != nil {
 				t.Fatal(err)
diff --git a/pkg/servicemesh/federation/status/handler.go b/pkg/servicemesh/federation/status/handler.go
new file mode 100644
index 0000000000..878da4fe2b
--- /dev/null
+++ b/pkg/servicemesh/federation/status/handler.go
@@ -0,0 +1,448 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package status
+
+import (
+	"reflect"
+	"sort"
+	"strings"
+	"sync"
+	"time"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"maistra.io/api/core/v1alpha1"
+
+	"istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/pkg/log"
+)
+
+const (
+	// used to prune old remote connection statuses from the status, e.g. if a
+	// pod was deleted, etc.
+	staleRemoteStatusDuration = 5 * time.Minute
+)
+
+func newHandler(manager *manager, mesh types.NamespacedName) *handler {
+	return &handler{
+		manager:   manager,
+		mesh:      mesh,
+		logger:    manager.logger.WithLabels("mesh", mesh.String()),
+		discovery: map[string]*v1alpha1.DiscoveryRemoteStatus{},
+		exports:   map[v1alpha1.ServiceKey]v1alpha1.MeshServiceMapping{},
+		imports:   map[string]v1alpha1.MeshServiceMapping{},
+		status: v1alpha1.FederationStatusDetails{
+			Mesh:    mesh.String(),
+			Exports: []v1alpha1.MeshServiceMapping{},
+			Imports: []v1alpha1.MeshServiceMapping{},
+		},
+	}
+}
+
+type handler struct {
+	mu      sync.Mutex
+	manager *manager
+	mesh    types.NamespacedName
+	logger  *log.Scope
+
+	discovery map[string]*v1alpha1.DiscoveryRemoteStatus
+	exports   map[v1alpha1.ServiceKey]v1alpha1.MeshServiceMapping
+	imports   map[string]v1alpha1.MeshServiceMapping
+
+	discoveryDirty bool
+	exportsDirty   bool
+	importsDirty   bool
+	dirty          bool
+
+	status v1alpha1.FederationStatusDetails
+}
+
+var _ Handler = (*handler)(nil)
+
+// Outbound connections
+func (h *handler) WatchInitiated() {
+	h.logger.Debugf("%s.WatchInitiated()", h.mesh)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	h.status.Discovery.Watch.Connected = false
+	h.status.Discovery.Watch.LastConnected = metav1.Now()
+
+	h.dirty = true
+
+	// we don't flush on initiation, as we expect either a Watching() or
+	// WatchTerminated() immediately following this
+}
+
+func (h *handler) Watching() {
+	h.logger.Debugf("%s.Watching()", h.mesh)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		h.status.Discovery.Watch.Connected = true
+
+		h.dirty = true
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+func (h *handler) WatchEventReceived() {
+	h.logger.Debugf("%s.WatchEventReceived()", h.mesh)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	h.status.Discovery.Watch.LastEvent = metav1.Now()
+
+	h.dirty = true
+}
+
+func (h *handler) FullSyncComplete() {
+	h.logger.Debugf("%s.FullSyncComplete()", h.mesh)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		h.status.Discovery.Watch.LastFullSync = metav1.Now()
+
+		h.dirty = true
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+func (h *handler) WatchTerminated(status string) {
+	h.logger.Debugf("%s.WatchTerminated(%s)", h.mesh, status)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		if h.status.Discovery.Watch.Connected {
+			// only update the disconnect time if we successfully connected
+			h.status.Discovery.Watch.LastDisconnect = metav1.Now()
+		}
+		h.status.Discovery.Watch.Connected = false
+		h.status.Discovery.Watch.LastDisconnectStatus = status
+
+		h.dirty = true
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+// Inbound connections
+func (h *handler) RemoteWatchAccepted(source string) {
+	h.logger.Debugf("%s.RemoteWatchAccepted(%s)", h.mesh, source)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		remoteStatus, ok := h.discovery[source]
+		if ok {
+			h.logger.Debugf("RemoteWatchAccepted called when watch status already exists: %s", source)
+		} else {
+			remoteStatus = &v1alpha1.DiscoveryRemoteStatus{
+				Source: source,
+			}
+			h.discovery[source] = remoteStatus
+		}
+		remoteStatus.Connected = true
+		remoteStatus.LastConnected = metav1.Now()
+
+		h.discoveryDirty = true
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+func (h *handler) WatchEventSent(source string) {
+	h.logger.Debugf("%s.WatchEventSent(%s)", h.mesh, source)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	if remoteStatus, ok := h.discovery[source]; !ok {
+		h.logger.Debugf("WatchEventSent called when no status exists: %s", source)
+	} else {
+		remoteStatus.LastEvent = metav1.Now()
+		h.discoveryDirty = true
+	}
+}
+
+func (h *handler) FullSyncSent(source string) {
+	h.logger.Debugf("%s.FullSyncSent(%s)", h.mesh, source)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		if remoteStatus, ok := h.discovery[source]; !ok {
+			h.logger.Debugf("skipping FullSyncSent event: no status for source %s", source)
+		} else {
+			remoteStatus.LastFullSync = metav1.Now()
+			h.discoveryDirty = true
+		}
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+func (h *handler) RemoteWatchTerminated(source string) {
+	h.logger.Debugf("%s.RemoteWatchTerminated(%s)", h.mesh, source)
+
+	func() {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+
+		remoteStatus, ok := h.discovery[source]
+		if !ok {
+			h.logger.Debugf("RemoteWatchTerminated called when no status exists: %s", source)
+			return
+		}
+
+		remoteStatus.Connected = false
+		remoteStatus.LastDisconnect = metav1.Now()
+
+		h.discoveryDirty = true
+	}()
+
+	if err := h.Flush(); err != nil {
+		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+	}
+}
+
+func statusServiceKeyFor(service model.ServiceKey) v1alpha1.ServiceKey {
+	return v1alpha1.ServiceKey{
+		Name:      service.Name,
+		Namespace: service.Namespace,
+		Hostname:  service.Hostname,
+	}
+}
+
+func statusMappingFor(service model.ServiceKey, exportedName string) v1alpha1.MeshServiceMapping {
+	return v1alpha1.MeshServiceMapping{
+		LocalService: statusServiceKeyFor(service),
+		ExportedName: exportedName,
+	}
+}
+
+// Exports
+func (h *handler) ExportAdded(service model.ServiceKey, exportedName string) {
+	h.logger.Debugf("%s.ExportAdded(%+v, %s)", h.mesh, service, exportedName)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	mapping := statusMappingFor(service, exportedName)
+	if existing, ok := h.exports[mapping.LocalService]; ok {
+		h.logger.Debugf("ExportAdded called when export mapping already exists: existing=%+v, new=%+v", existing, mapping)
+		if reflect.DeepEqual(existing, mapping) {
+			return
+		}
+	}
+	h.exports[mapping.LocalService] = mapping
+	h.exportsDirty = true
+}
+
+func (h *handler) ExportUpdated(service model.ServiceKey, exportedName string) {
+	h.logger.Debugf("%s.ExportUpdated(%+v, %s)", h.mesh, service, exportedName)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	mapping := statusMappingFor(service, exportedName)
+	if existing, ok := h.exports[mapping.LocalService]; !ok {
+		h.logger.Debugf("ExportUpdated called when export mapping does not exist: %+v", mapping.LocalService)
+	} else if reflect.DeepEqual(existing, mapping) {
+		return
+	}
+	h.exports[mapping.LocalService] = mapping
+	h.exportsDirty = true
+}
+
+func (h *handler) ExportRemoved(service model.ServiceKey) {
+	h.logger.Debugf("%s.ExportRemoved(%+v)", h.mesh, service)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	key := statusServiceKeyFor(service)
+	if _, ok := h.exports[key]; !ok {
+		h.logger.Debugf("ExportRemoved called when export mapping does not exist: %+v", key)
+		return
+	}
+	delete(h.exports, key)
+	h.exportsDirty = true
+}
+
+// Imports
+func (h *handler) ImportAdded(service model.ServiceKey, exportedName string) {
+	h.logger.Debugf("%s.ImportAdded(%+v, %s)", h.mesh, service, exportedName)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	mapping := statusMappingFor(service, exportedName)
+	if existing, ok := h.imports[mapping.ExportedName]; ok {
+		h.logger.Debugf("ImportAdded called when import mapping already exists: existing=%+v, new=%+v", existing, mapping)
+		if reflect.DeepEqual(existing, mapping) {
+			return
+		}
+	}
+	h.imports[mapping.ExportedName] = mapping
+	h.importsDirty = true
+}
+
+func (h *handler) ImportUpdated(service model.ServiceKey, exportedName string) {
+	h.logger.Debugf("%s.ImportUpdated(%+v, %s)", h.mesh, service, exportedName)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	mapping := statusMappingFor(service, exportedName)
+	if existing, ok := h.imports[mapping.ExportedName]; !ok {
+		h.logger.Debugf("ImportUpdated called when import mapping does not exist: %s", mapping.ExportedName)
+	} else if reflect.DeepEqual(existing, mapping) {
+		return
+	}
+	h.imports[mapping.ExportedName] = mapping
+	h.importsDirty = true
+}
+
+func (h *handler) ImportRemoved(exportedName string) {
+	h.logger.Debugf("%s.ImportRemoved(%s)", h.mesh, exportedName)
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	if _, ok := h.imports[exportedName]; !ok {
+		h.logger.Debugf("ImportRemoved called when import mapping does not exist: %s", exportedName)
+		return
+	}
+	delete(h.imports, exportedName)
+	h.importsDirty = true
+}
+
+func (h *handler) isDirty() bool {
+	return h.dirty || h.exportsDirty || h.importsDirty || h.discoveryDirty
+}
+
+func (h *handler) pruneOldRemotes() {
+	var connections []string
+	for connection, status := range h.discovery {
+		if status.Connected || metav1.Now().Sub(status.LastDisconnect.Time) < staleRemoteStatusDuration {
+			continue
+		}
+		h.logger.Debugf("removing stale remote watch status for connection from %s", connection)
+		connections = append(connections, connection)
+	}
+	h.discoveryDirty = h.discoveryDirty || len(connections) > 0
+	for _, connection := range connections {
+		delete(h.discovery, connection)
+	}
+}
+
+// Write status
+func (h *handler) Flush() error {
+	push := func() bool {
+		h.mu.Lock()
+		defer h.mu.Unlock()
+		h.pruneOldRemotes()
+		return h.isDirty()
+	}()
+
+	if push {
+		return h.manager.PushStatus()
+	}
+	return nil
+}
+
+func (h *handler) currentStatus() *v1alpha1.FederationStatusDetails {
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	h.pruneOldRemotes()
+	if !h.isDirty() {
+		// nothing to do
+		return h.status.DeepCopy()
+	}
+
+	// see if we need to update the export status
+	if h.exportsDirty {
+		exports := []v1alpha1.MeshServiceMapping{}
+		for _, mapping := range h.exports {
+			exports = append(exports, mapping)
+		}
+		sort.Slice(exports, func(i, j int) bool {
+			diff := strings.Compare(exports[i].LocalService.Namespace, exports[j].LocalService.Namespace)
+			if diff == 0 {
+				diff = strings.Compare(exports[i].LocalService.Name, exports[j].LocalService.Name)
+				if diff == 0 {
+					// we really shouldn't ever get here, as there should never be an overlap of namespace/name
+					diff = strings.Compare(exports[i].ExportedName, exports[j].ExportedName)
+				}
+			}
+			return diff < 0
+		})
+		h.status.Exports = exports
+		h.exportsDirty = false
+	}
+
+	// see if we need to update the import status
+	if h.importsDirty {
+		imports := []v1alpha1.MeshServiceMapping{}
+		for _, mapping := range h.imports {
+			imports = append(imports, mapping)
+		}
+		sort.Slice(imports, func(i, j int) bool { return strings.Compare(imports[i].ExportedName, imports[j].ExportedName) < 0 })
+		h.status.Imports = imports
+		h.importsDirty = false
+	}
+
+	// see if we need to update the discovery status
+	if h.discoveryDirty {
+		var remoteStatuses []v1alpha1.DiscoveryRemoteStatus
+		for _, status := range h.discovery {
+			remoteStatuses = append(remoteStatuses, *status)
+		}
+		sort.Slice(remoteStatuses,
+			func(i, j int) bool {
+				return strings.Compare(remoteStatuses[i].Source, remoteStatuses[j].Source) < 0
+			})
+		h.status.Discovery.Remotes = remoteStatuses
+		h.discoveryDirty = false
+	}
+
+	h.dirty = false
+
+	return h.status.DeepCopy()
+}
diff --git a/pkg/servicemesh/federation/status/manager.go b/pkg/servicemesh/federation/status/manager.go
new file mode 100644
index 0000000000..ed38ef5505
--- /dev/null
+++ b/pkg/servicemesh/federation/status/manager.go
@@ -0,0 +1,251 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package status
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"sort"
+	"strings"
+	"sync"
+
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/api/meta"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/strategicpatch"
+	maistraclient "maistra.io/api/client/versioned"
+	"maistra.io/api/core/v1alpha1"
+
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/federation/common"
+	"istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/pkg/log"
+)
+
+var federationStatusPatchMetadata strategicpatch.LookupPatchMeta
+
+func init() {
+	var err error
+	federationStatusPatchMetadata, err = strategicpatch.NewPatchMetaFromStruct(&v1alpha1.FederationStatus{})
+	if err != nil {
+		panic("error creating strategicpatch.LookupPatchMeta for use with FederationStatus resources")
+	}
+}
+
+type Manager interface {
+	FederationAdded(mesh types.NamespacedName) Handler
+	FederationDeleted(mesh types.NamespacedName)
+	HandlerFor(mesh types.NamespacedName) Handler
+	PushStatus() error
+}
+
+type Handler interface {
+	// Outbound connections
+	WatchInitiated()
+	Watching()
+	WatchEventReceived()
+	FullSyncComplete()
+	WatchTerminated(status string)
+
+	// Inbound connections
+	RemoteWatchAccepted(source string)
+	WatchEventSent(source string)
+	FullSyncSent(source string)
+	RemoteWatchTerminated(source string)
+
+	// Exports
+	ExportAdded(service model.ServiceKey, exportedName string)
+	ExportUpdated(service model.ServiceKey, exportedName string)
+	ExportRemoved(service model.ServiceKey)
+
+	// Imports
+	ImportAdded(service model.ServiceKey, exportedName string)
+	ImportUpdated(service model.ServiceKey, exportedName string)
+	ImportRemoved(exportedName string)
+
+	// Write status
+	Flush() error
+}
+
+func NewManager(name types.NamespacedName, kubeClient kube.Client) (Manager, error) {
+	cs, err := maistraclient.NewForConfig(kubeClient.RESTConfig())
+	if err != nil {
+		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
+	}
+
+	return newManager(name, kubeClient, cs), nil
+}
+
+func newManager(name types.NamespacedName, kubeClient kube.Client, cs maistraclient.Interface) *manager {
+	return &manager{
+		client:   kubeClient,
+		cs:       cs,
+		logger:   common.Logger.WithLabels("component", "federation-status"),
+		name:     name,
+		handlers: map[types.NamespacedName]*handler{},
+		status:   v1alpha1.FederationStatusStatus{Meshes: []v1alpha1.FederationStatusDetails{}},
+	}
+}
+
+type manager struct {
+	mu     sync.Mutex
+	client kube.Client
+	cs     maistraclient.Interface
+	logger *log.Scope
+
+	name types.NamespacedName
+
+	handlers map[types.NamespacedName]*handler
+
+	status                v1alpha1.FederationStatusStatus
+	missingCRDErrorLogged bool
+}
+
+var _ Manager = (*manager)(nil)
+
+func (m *manager) FederationAdded(mesh types.NamespacedName) Handler {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+
+	if handler, exists := m.handlers[mesh]; exists {
+		m.logger.Debugf("already have a handler for mesh %s", mesh)
+		return handler
+	}
+	handler := newHandler(m, mesh)
+	m.handlers[mesh] = handler
+	return handler
+}
+
+func (m *manager) FederationDeleted(mesh types.NamespacedName) {
+	func() {
+		m.mu.Lock()
+		defer m.mu.Unlock()
+
+		if _, exists := m.handlers[mesh]; !exists {
+			m.logger.Debugf("deleting unknown handler for mesh %s", mesh)
+		}
+		delete(m.handlers, mesh)
+	}()
+
+	if err := m.PushStatus(); err != nil {
+		m.logger.Errorf("unexpected error updating FederationStatus for %s", m.name.String())
+	}
+}
+
+func (m *manager) HandlerFor(mesh types.NamespacedName) Handler {
+	handler, exists := m.handlers[mesh]
+	if !exists {
+		m.logger.Debugf("handler for mesh %s does not exist", mesh.String())
+		return nil
+	}
+	return handler
+}
+
+func (m *manager) PushStatus() error {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+
+	newStatus := &v1alpha1.FederationStatus{
+		Status: v1alpha1.FederationStatusStatus{Meshes: []v1alpha1.FederationStatusDetails{}},
+	}
+	for _, handler := range m.handlers {
+		newStatus.Status.Meshes = append(newStatus.Status.Meshes, *handler.currentStatus())
+	}
+	sort.Slice(newStatus.Status.Meshes,
+		func(i, j int) bool {
+			return strings.Compare(newStatus.Status.Meshes[i].Mesh, newStatus.Status.Meshes[j].Mesh) < 0
+		})
+
+	newBytes, err := json.Marshal(newStatus)
+	if err != nil {
+		return err
+	}
+	oldBytes, err := json.Marshal(&v1alpha1.FederationStatus{
+		Status: m.status,
+	})
+	if err != nil {
+		return err
+	}
+
+	m.logger.Debugf("old bytes:\n%s\n", string(oldBytes))
+	m.logger.Debugf("new bytes:\n%s\n", string(newBytes))
+
+	patch, err := strategicpatch.CreateTwoWayMergePatchUsingLookupPatchMeta(oldBytes, newBytes, federationStatusPatchMetadata)
+	if err != nil {
+		return err
+	}
+
+	m.logger.Debugf("status patch:\n%s\n", string(patch))
+
+	if len(patch) == 0 || string(patch) == "{}" {
+		// nothing to patch
+		return nil
+	}
+
+	fedStatus, err := m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
+		Patch(context.TODO(), m.name.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status")
+	if err == nil {
+		m.missingCRDErrorLogged = false
+		m.status = *fedStatus.Status.DeepCopy()
+		return nil
+	} else if meta.IsNoMatchError(err) {
+		// The FederationStatus resource is not installed.  We won't error in this case.
+		if !m.missingCRDErrorLogged {
+			m.logger.Errorf("status will not be updated: FederationStatus CRD is not installed")
+			// prevent spamming the logs
+			m.missingCRDErrorLogged = true
+		}
+		return nil
+	} else if !(errors.IsGone(err) || errors.IsNotFound(err)) {
+		return err
+	}
+
+	// if we get here, it means the resource doesn't exist
+	pilotPod, err := m.client.KubeInformer().Core().V1().Pods().Lister().Pods(m.name.Namespace).Get(m.name.Name)
+	if err != nil {
+		// this should really _never_ happen unless the POD_* env is incorrect.  we're running in the pod!
+		return err
+	}
+	controller := true
+	newFedStatus := &v1alpha1.FederationStatus{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      m.name.Name,
+			Namespace: m.name.Namespace,
+			OwnerReferences: []metav1.OwnerReference{
+				{
+					APIVersion: "v1",
+					Kind:       "Pod",
+					Name:       m.name.Name,
+					UID:        pilotPod.GetUID(),
+					Controller: &controller,
+				},
+			},
+		},
+		Status: *m.status.DeepCopy(),
+	}
+	_, err = m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
+		Create(context.TODO(), newFedStatus, metav1.CreateOptions{})
+	if err == nil {
+		// we can't create status, so we need to apply it separately
+		fedStatus, err = m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
+			Patch(context.TODO(), m.name.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status")
+		if err == nil {
+			m.status = *fedStatus.Status.DeepCopy()
+		}
+	}
+	return err
+}
diff --git a/pkg/servicemesh/federation/status/manager_test.go b/pkg/servicemesh/federation/status/manager_test.go
new file mode 100644
index 0000000000..5c65f45a27
--- /dev/null
+++ b/pkg/servicemesh/federation/status/manager_test.go
@@ -0,0 +1,699 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package status
+
+import (
+	"context"
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+	corev1 "k8s.io/api/core/v1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	maistraclient "maistra.io/api/client/versioned"
+	"maistra.io/api/client/versioned/fake"
+	"maistra.io/api/core/v1alpha1"
+
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/federation/model"
+)
+
+var ignoreTimestamps = cmp.FilterPath(func(p cmp.Path) bool {
+	switch p.Last().String() {
+	case ".LastConnected", ".LastDisconnect", ".LastEvent", ".LastFullSync":
+		return true
+	}
+	return false
+}, cmp.Ignore())
+
+func TestStatusManager(t *testing.T) {
+	const (
+		namespace = "test-namespace"
+		name      = "test"
+	)
+	testCases := []struct {
+		name       string
+		mesh       types.NamespacedName
+		events     []func(h Handler)
+		status     []v1alpha1.FederationStatusStatus
+		assertions []func(t *testing.T, status *v1alpha1.FederationStatusStatus)
+	}{
+		{
+			name: "initial-status",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+		},
+		{
+			name: "watch-init-connect-error",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.WatchInitiated()
+					h.Flush()
+				},
+				func(h Handler) {
+					h.WatchTerminated("503")
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				nil,
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Watch.LastConnected.IsZero() {
+						t.Errorf("expected LastConnected to be updated")
+					}
+				},
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Watch: v1alpha1.DiscoveryWatchStatus{
+									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+										Connected: false,
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Watch: v1alpha1.DiscoveryWatchStatus{
+									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+										Connected:            false,
+										LastDisconnectStatus: "503",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-init-connect-success",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.WatchInitiated()
+					h.Flush()
+				},
+				func(h Handler) {
+					h.Watching()
+				},
+				func(h Handler) {
+					h.WatchTerminated("200")
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				nil,
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Watch.LastConnected.IsZero() {
+						t.Errorf("expected LastConnected to be updated")
+					}
+				},
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Watch.LastDisconnect.IsZero() {
+						t.Errorf("expected LastDisconnect to be updated")
+					}
+				},
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Watch: v1alpha1.DiscoveryWatchStatus{
+									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+										Connected: false,
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Watch: v1alpha1.DiscoveryWatchStatus{
+									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+										Connected: true,
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Watch: v1alpha1.DiscoveryWatchStatus{
+									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+										Connected:            false,
+										LastDisconnectStatus: "200",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-remote",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.RemoteWatchAccepted("10.10.10.10")
+				},
+				func(h Handler) {
+					h.WatchEventSent("10.10.10.10")
+				},
+				func(h Handler) {
+					h.FullSyncSent("10.10.10.10")
+				},
+				func(h Handler) {
+					h.RemoteWatchTerminated("10.10.10.10")
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Remotes[0].LastConnected.IsZero() {
+						t.Errorf("expected LastConnected to be updated")
+					}
+				},
+				nil,
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					// full sync causes a push, so we can also verify that an event was seen
+					if status.Meshes[0].Discovery.Remotes[0].LastEvent.IsZero() {
+						t.Errorf("expected LastEvent to be updated")
+					}
+					if status.Meshes[0].Discovery.Remotes[0].LastFullSync.IsZero() {
+						t.Errorf("expected LastFullSync to be updated")
+					}
+				},
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Remotes[0].LastDisconnect.IsZero() {
+						t.Errorf("expected LastDisconnect to be updated")
+					}
+				},
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Remotes: []v1alpha1.DiscoveryRemoteStatus{
+									{
+										Source: "10.10.10.10",
+										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+											Connected: true,
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Remotes: []v1alpha1.DiscoveryRemoteStatus{
+									{
+										Source: "10.10.10.10",
+										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+											Connected: true,
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Remotes: []v1alpha1.DiscoveryRemoteStatus{
+									{
+										Source: "10.10.10.10",
+										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+											Connected: true,
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Discovery: v1alpha1.MeshDiscoveryStatus{
+								Remotes: []v1alpha1.DiscoveryRemoteStatus{
+									{
+										Source: "10.10.10.10",
+										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
+											Connected: false,
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-export-added-updated-deleted",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.ExportAdded(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						},
+						"exported-service.exported-namespace.svc.mesh.local")
+					h.Flush()
+				},
+				func(h Handler) {
+					h.ExportUpdated(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						},
+						"updated-exported-service.exported-namespace.svc.mesh.local")
+					h.Flush()
+				},
+				func(h Handler) {
+					h.ExportRemoved(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						})
+					h.Flush()
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				nil, nil, nil,
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{
+								{
+									LocalService: v1alpha1.ServiceKey{
+										Name:      "real-service",
+										Namespace: "real-namespace",
+										Hostname:  "real-service.real-namespace.svc.cluster.local",
+									},
+									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{
+								{
+									LocalService: v1alpha1.ServiceKey{
+										Name:      "real-service",
+										Namespace: "real-namespace",
+										Hostname:  "real-service.real-namespace.svc.cluster.local",
+									},
+									ExportedName: "updated-exported-service.exported-namespace.svc.mesh.local",
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-export-added-updated-deleted-no-flush",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.ExportAdded(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						},
+						"exported-service.exported-namespace.svc.mesh.local")
+				},
+				func(h Handler) {
+					h.ExportUpdated(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						},
+						"updated-exported-service.exported-namespace.svc.mesh.local")
+				},
+				func(h Handler) {
+					h.ExportRemoved(
+						model.ServiceKey{
+							Name:      "real-service",
+							Namespace: "real-namespace",
+							Hostname:  "real-service.real-namespace.svc.cluster.local",
+						})
+				},
+				func(h Handler) {
+					h.Flush()
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				nil, nil, nil, nil,
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-import-added-updated-deleted",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportAdded(
+						model.ServiceKey{
+							Name:      "local-service",
+							Namespace: "local-namespace",
+							Hostname:  "local-service.local-namespace.svc.test-mesh.local",
+						},
+						"exported-service.exported-namespace.svc.mesh.local")
+					h.Flush()
+				},
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportUpdated(
+						model.ServiceKey{},
+						"exported-service.exported-namespace.svc.mesh.local")
+					h.Flush()
+				},
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportRemoved("exported-service.exported-namespace.svc.mesh.local")
+					h.Flush()
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+						t.Errorf("expected LastEvent to be updated")
+					}
+				},
+				nil, nil,
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{
+								{
+									LocalService: v1alpha1.ServiceKey{
+										Name:      "local-service",
+										Namespace: "local-namespace",
+										Hostname:  "local-service.local-namespace.svc.test-mesh.local",
+									},
+									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Exports: []v1alpha1.MeshServiceMapping{},
+							Imports: []v1alpha1.MeshServiceMapping{
+								{
+									LocalService: v1alpha1.ServiceKey{},
+									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+								},
+							},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "watch-import-added-updated-deleted-no-flush",
+			mesh: types.NamespacedName{Namespace: namespace, Name: name},
+			events: []func(h Handler){
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportAdded(
+						model.ServiceKey{
+							Name:      "local-service",
+							Namespace: "local-namespace",
+							Hostname:  "local-service.local-namespace.svc.test-mesh.local",
+						},
+						"exported-service.exported-namespace.svc.mesh.local")
+				},
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportUpdated(
+						model.ServiceKey{},
+						"exported-service.exported-namespace.svc.mesh.local")
+				},
+				func(h Handler) {
+					h.WatchEventReceived()
+					h.ImportRemoved("exported-service.exported-namespace.svc.mesh.local")
+				},
+				func(h Handler) {
+					h.FullSyncComplete()
+				},
+			},
+			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					if !status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+						t.Errorf("did not expect LastEvent to be updated")
+					}
+					if !status.Meshes[0].Discovery.Watch.LastFullSync.IsZero() {
+						t.Errorf("did not expect LastFullSync to be updated")
+					}
+				},
+				nil, nil,
+				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+					// this should have been updated in one of the previous events
+					if status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+						t.Errorf("expected LastEvent to be updated")
+					}
+					if status.Meshes[0].Discovery.Watch.LastFullSync.IsZero() {
+						t.Errorf("expected LastFullSync to be updated")
+					}
+				},
+			},
+			status: []v1alpha1.FederationStatusStatus{
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+				{
+					Meshes: []v1alpha1.FederationStatusDetails{
+						{
+							Mesh:    namespace + "/" + name,
+							Imports: []v1alpha1.MeshServiceMapping{},
+							Exports: []v1alpha1.MeshServiceMapping{},
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			// verify test is setup correctly
+			if len(tc.status) != len(tc.events) || len(tc.assertions) != len(tc.events) {
+				t.Fatalf("number of status elements and asserts must equal the number of events")
+			}
+			name := v1.ObjectMeta{Name: "istiod-test", Namespace: namespace, UID: "12345"}
+			kubeClient := kube.NewFakeClient(&corev1.Pod{
+				ObjectMeta: name,
+			})
+			stop := make(chan struct{})
+			defer func() { close(stop) }()
+			go kubeClient.KubeInformer().Core().V1().Pods().Informer().Run(stop)
+			for !kubeClient.KubeInformer().Core().V1().Pods().Informer().HasSynced() {
+			}
+			cs := fake.NewSimpleClientset()
+			manager := newManager(types.NamespacedName{Name: name.Name, Namespace: name.Namespace}, kubeClient, cs)
+			manager.FederationAdded(tc.mesh)
+			manager.PushStatus()
+			verifyStatus(t, cs, name, &v1alpha1.FederationStatusStatus{
+				Meshes: []v1alpha1.FederationStatusDetails{
+					{
+						Mesh:    tc.mesh.Namespace + "/" + tc.mesh.Name,
+						Exports: []v1alpha1.MeshServiceMapping{},
+						Imports: []v1alpha1.MeshServiceMapping{},
+					},
+				},
+			}, nil)
+
+			handler := manager.HandlerFor(types.NamespacedName{Namespace: tc.mesh.Namespace, Name: tc.mesh.Name})
+			if handler == nil {
+				t.Fatalf("nil handler for %s/%s", name.Namespace, name.Name)
+			}
+			for index, f := range tc.events {
+				f(handler)
+				verifyStatus(t, cs, name, &tc.status[index], tc.assertions[index])
+			}
+
+			manager.FederationDeleted(tc.mesh)
+			verifyStatus(t, cs, name, &v1alpha1.FederationStatusStatus{}, nil)
+		})
+	}
+}
+
+func verifyStatus(t *testing.T, cs maistraclient.Interface, name v1.ObjectMeta, expected *v1alpha1.FederationStatusStatus,
+	assert func(*testing.T, *v1alpha1.FederationStatusStatus)) {
+	t.Helper()
+
+	actual, err := cs.CoreV1alpha1().FederationStatuses(name.Namespace).Get(context.TODO(), name.Name, v1.GetOptions{})
+	if err != nil {
+		t.Errorf("unexpected error retrieving FederationStatus %s/%s", name.Namespace, name.Name)
+		return
+	}
+	if diff := cmp.Diff(&actual.Status, expected, ignoreTimestamps); diff != "" {
+		t.Errorf("comparison failed, -got +want:\n%s", diff)
+	}
+	if assert != nil {
+		assert(t, &actual.Status)
+	}
+}
-- 
2.31.1

