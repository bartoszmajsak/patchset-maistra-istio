From 53a78a1139f6ea111a7c0e17ea7a2228dd241735 Mon Sep 17 00:00:00 2001
From: rcernich <rcernich@redhat.com>
Date: Tue, 15 Jun 2021 18:57:08 +0200
Subject: [federation] Federation fixes and improvements

MAISTRA-2423 update federation api to v1

Signed-off-by: rcernich <rcernich@redhat.com>

MAISTRA-2424 minor updates to federation api

Signed-off-by: rcernich <rcernich@redhat.com>

MAISTRA-2427 configure locality info on imported services

Signed-off-by: rcernich <rcernich@redhat.com>

Cherry-pick multi-root support (#387)

* Update go-control-plane to v0.9.9

* Support multiple roots

Squashed commit, contains:
- MAISTRA-2325 Distribute trust bundles over SDS
- MAISTRA-2390 Push trust bundle updates through xDS (#357)

MAISTRA-2425 move spec.security.certificateChain to ConfigMap reference; add ability to specify ports for service and discovery (#392)

Signed-off-by: rcernich <rcernich@redhat.com>

MAISTRA-2426 move FederationStatus into MeshFederation (#393)

Signed-off-by: rcernich <rcernich@redhat.com>

MAISTRA-2513 federation API refinements

Signed-off-by: rcernich <rcernich@redhat.com>

[federation] MAISTRA-2237 Encrypt service discovery traffic (#411)

MAISTRA-2610 Prefix federation discovery endpoints with /v1/ (#422)

MAISTRA-2297 Support updates of federation resources (#417)

MAISTRA-2375: Do not create automatic routes for Federation Gateways

Remove a redundant call

`setHostname()` is already being called within `NameForService()`

see
https://github.com/maistra/istio/blob/21ee900cf8825711f70d88dc97afcf6862ed2626/pkg/servicemesh/federation/common/namemapping.go
lines 83, 120, 129

Remove techPreview.meshConfig from PoC example

It's set by default now.

MAISTRA-2611 Fix deletion of service exports to federated mesh (#421)

Fix test

MAISTRA-2658 Ensure ImportedServiceSet.status.importedServices is never nil (#437)

* MAISTRA-2658 Ensure ImportedServiceSet.status.importedServices is never nil

* Fix test

MAISTRA-2682 Fix watch mechanism in federation (#439)

Previously, no events were read from the watch response, because the read started with an endless loop that waited for data to be available in the decoder's buffer. This never happened, because the buffer is only written to when you call decoder.Decode(); this function was never called because the code waited for the buffer to have data.

MAISTRA-2683 Properly close incoming watch connections when shutting down (#440)

Log actual error returned by pollServices() (#441)

Previously, instead of the actual error, only the following error message was logged: "expected condition not met".

MAISTRA-2439: Prevent federation from exporting services that are not visible to the federation gateway (#432)

By taking into consideration the service annotation
`networking.istio.io/exportTo`.

This annotation restricts where this service is visible: https://istio.io/latest/docs/reference/config/annotations/

If a service is not reachable from the federation gateway namespace due
to this annotation, it should not be exported.

MAISTRA-2617: Do not watch all namespaces in Extensions controller (#425)

When using MemberRoll, we should rely on it to provide the list
of namespaces to watch. If not using it, defaults to command line
arguments.

This fixes an istiod startup error as seen in the logs:
```
github.com/maistra/xns-informer/pkg/informers/informer.go:204: Failed to watch *v1.ServiceMeshExtension: failed to list *v1.ServiceMeshExtension: servicemeshextensions.maistra.io is forbidden: User "system:serviceaccount:i1:istiod-service-account-basic" cannot list resource "servicemeshextensions" in API group "maistra.io" at the cluster scope
```
---
 bin/update_maistra_deps.sh                    |   7 +-
 common/config/.golangci-format.yml            |   2 +
 go.mod                                        |   3 +-
 go.sum                                        |  34 +-
 ...ation.maistra.io_exportedservicesets.yaml} |  79 +-
 ...ration.maistra.io_importedservicesets.yaml | 134 +++
 ...ederation.maistra.io_servicemeshpeers.yaml | 283 +++++++
 .../crds/maistra.io_federationstatuses.yaml   | 195 -----
 .../base/crds/maistra.io_meshfederations.yaml | 112 ---
 .../base/crds/maistra.io_serviceimports.yaml  |  87 --
 .../maistra.io_servicemeshextensions.yaml     |   2 +-
 .../charts/base/files/gen-istio-cluster.yaml  | 774 +++++++++--------
 manifests/charts/base/templates/role.yaml     |   7 +-
 .../istio-discovery/files/gen-istio.yaml      |  22 +
 .../istio-discovery/templates/federation.yaml |  21 +
 pilot/pkg/bootstrap/server.go                 |  75 +-
 .../grpcgen/testdata/xds_bootstrap.json       |   2 +-
 .../serviceregistry/federation/controller.go  | 469 +++++++----
 .../pkg/serviceregistry/federation/routing.go |   2 +-
 pilot/pkg/xds/tbds.go                         |  71 ++
 pilot/pkg/xds/v3/model.go                     |   7 +
 pkg/istio-agent/xds_proxy.go                  |  53 ++
 pkg/kube/controller/controller.go             |   6 +-
 pkg/security/security.go                      |   2 +
 .../controller/extension/controller.go        |   5 +-
 pkg/servicemesh/extension/apply_extension.go  |   2 +-
 pkg/servicemesh/federation/common/const.go    |   9 +-
 pkg/servicemesh/federation/common/exports.go  |  20 +-
 pkg/servicemesh/federation/common/imports.go  |  12 +-
 .../federation/common/namemapping.go          |  33 +-
 pkg/servicemesh/federation/common/options.go  |  20 +
 .../federation/common/resources.go            | 108 +++
 pkg/servicemesh/federation/common/testing.go  |  73 ++
 pkg/servicemesh/federation/common/util.go     |  24 +
 .../federation/discovery/controller.go        | 219 +++--
 .../federation/discovery/controller_test.go   | 224 +++--
 .../federation/discovery/discovery.go         | 374 +++++----
 .../federation/example/config-poc/cleanup.sh  |  19 +-
 .../federation/example/config-poc/common.sh   |  54 ++
 .../example/config-poc/export/configmap.yaml  |   8 +
 .../config-poc/export/exportedserviceset.yaml |  21 +
 .../config-poc/export/meshfederation.yaml     |  14 -
 .../config-poc/export/serviceexports.yaml     |  23 -
 .../config-poc/export/servicemeshpeer.yaml    |  23 +
 .../example/config-poc/export/smcp.yaml       |  37 +-
 .../example/config-poc/import/configmap.yaml  |   8 +
 .../config-poc/import/importedserviceset.yaml |  16 +
 .../config-poc/import/meshfederation.yaml     |  14 -
 .../config-poc/import/serviceimports.yaml     |  17 -
 .../config-poc/import/servicemeshpeer.yaml    |  23 +
 .../example/config-poc/import/smcp.yaml       |  37 +-
 .../federation/example/config-poc/install.sh  | 196 +++--
 .../federation/exports/controller.go          |  75 +-
 pkg/servicemesh/federation/federation.go      |  61 +-
 pkg/servicemesh/federation/federation_test.go |  17 +-
 .../federation/imports/controller.go          |  97 +--
 pkg/servicemesh/federation/model/model.go     |   4 +
 pkg/servicemesh/federation/server/routing.go  |  10 +-
 pkg/servicemesh/federation/server/server.go   |  86 +-
 .../federation/server/server_test.go          | 471 ++++++++---
 pkg/servicemesh/federation/status/handler.go  | 317 +++++--
 pkg/servicemesh/federation/status/manager.go  | 198 ++---
 .../federation/status/manager_test.go         | 661 +++++++++------
 security/pkg/nodeagent/cache/secretcache.go   |  47 ++
 security/pkg/nodeagent/sds/sdsservice.go      |  68 +-
 .../externalversions/core/interface.go        |   2 +-
 .../externalversions/core/v1/interface.go     |   2 +-
 .../core/v1/servicemeshcontrolplane.go        |   2 +-
 .../core/v1/servicemeshextension.go           |   2 +-
 .../core/v1/servicemeshmember.go              |   2 +-
 .../core/v1/servicemeshmemberroll.go          |   2 +-
 .../core/v1alpha1/federationstatus.go         |  88 --
 .../core/v1alpha1/interface.go                |  30 +-
 .../core/v1alpha1/meshfederation.go           |  88 --
 .../core/v1alpha1/serviceexports.go           |  88 --
 .../core/v1alpha1/serviceimports.go           |  88 --
 .../core/v1alpha1/servicemeshextension.go     |   2 +-
 .../externalversions/core/v2/interface.go     |   2 +-
 .../core/v2/servicemeshcontrolplane.go        |   2 +-
 .../informers/externalversions/factory.go     |   8 +-
 .../externalversions/federation/interface.go  |  44 +
 .../federation/v1/exportedserviceset.go       |  88 ++
 .../federation/v1/importedserviceset.go       |  88 ++
 .../federation/v1/interface.go                |  57 ++
 .../federation/v1/servicemeshpeer.go          |  88 ++
 .../informers/externalversions/generic.go     |  19 +-
 .../internalinterfaces/factory_interfaces.go  |   2 +-
 .../listers/core/v1/expansion_generated.go    |   2 +-
 .../core/v1/servicemeshcontrolplane.go        |   2 +-
 .../listers/core/v1/servicemeshextension.go   |   2 +-
 .../listers/core/v1/servicemeshmember.go      |   2 +-
 .../listers/core/v1/servicemeshmemberroll.go  |   2 +-
 .../core/v1alpha1/expansion_generated.go      |  34 +-
 .../listers/core/v1alpha1/federationstatus.go |  97 ---
 .../listers/core/v1alpha1/meshfederation.go   |  97 ---
 .../listers/core/v1alpha1/serviceexports.go   |  97 ---
 .../listers/core/v1alpha1/serviceimports.go   |  97 ---
 .../core/v1alpha1/servicemeshextension.go     |   2 +-
 .../listers/core/v2/expansion_generated.go    |   2 +-
 .../core/v2/servicemeshcontrolplane.go        |   2 +-
 .../federation/v1/expansion_generated.go      |  41 +
 .../federation/v1/exportedserviceset.go       |  97 +++
 .../federation/v1/importedserviceset.go       |  97 +++
 .../listers/federation/v1/servicemeshpeer.go  |  97 +++
 .../api/client/versioned/clientset.go         |  16 +-
 vendor/maistra.io/api/client/versioned/doc.go |   2 +-
 .../versioned/fake/clientset_generated.go     |  14 +-
 .../api/client/versioned/fake/doc.go          |   2 +-
 .../api/client/versioned/fake/register.go     |   4 +-
 .../api/client/versioned/scheme/doc.go        |   2 +-
 .../api/client/versioned/scheme/register.go   |   4 +-
 .../versioned/typed/core/v1/core_client.go    |   2 +-
 .../api/client/versioned/typed/core/v1/doc.go |   2 +-
 .../versioned/typed/core/v1/fake/doc.go       |   2 +-
 .../typed/core/v1/fake/fake_core_client.go    |   2 +-
 .../v1/fake/fake_servicemeshcontrolplane.go   |   6 +-
 .../core/v1/fake/fake_servicemeshextension.go |   6 +-
 .../core/v1/fake/fake_servicemeshmember.go    |   6 +-
 .../v1/fake/fake_servicemeshmemberroll.go     |   6 +-
 .../typed/core/v1/generated_expansion.go      |   2 +-
 .../typed/core/v1/servicemeshcontrolplane.go  |   2 +-
 .../typed/core/v1/servicemeshextension.go     |   2 +-
 .../typed/core/v1/servicemeshmember.go        |   2 +-
 .../typed/core/v1/servicemeshmemberroll.go    |   2 +-
 .../typed/core/v1alpha1/core_client.go        |  22 +-
 .../versioned/typed/core/v1alpha1/doc.go      |   2 +-
 .../versioned/typed/core/v1alpha1/fake/doc.go |   2 +-
 .../core/v1alpha1/fake/fake_core_client.go    |  18 +-
 .../v1alpha1/fake/fake_federationstatus.go    | 140 ----
 .../core/v1alpha1/fake/fake_meshfederation.go | 140 ----
 .../core/v1alpha1/fake/fake_serviceexports.go | 140 ----
 .../core/v1alpha1/fake/fake_serviceimports.go | 140 ----
 .../fake/fake_servicemeshextension.go         |   6 +-
 .../typed/core/v1alpha1/federationstatus.go   | 193 -----
 .../core/v1alpha1/generated_expansion.go      |  10 +-
 .../typed/core/v1alpha1/meshfederation.go     | 193 -----
 .../typed/core/v1alpha1/serviceexports.go     | 193 -----
 .../typed/core/v1alpha1/serviceimports.go     | 193 -----
 .../core/v1alpha1/servicemeshextension.go     |   2 +-
 .../versioned/typed/core/v2/core_client.go    |   2 +-
 .../api/client/versioned/typed/core/v2/doc.go |   2 +-
 .../versioned/typed/core/v2/fake/doc.go       |   2 +-
 .../typed/core/v2/fake/fake_core_client.go    |   2 +-
 .../v2/fake/fake_servicemeshcontrolplane.go   |   6 +-
 .../typed/core/v2/generated_expansion.go      |   2 +-
 .../typed/core/v2/servicemeshcontrolplane.go  |   2 +-
 .../versioned/typed/federation/v1/doc.go      |  18 +
 .../typed/federation/v1/exportedserviceset.go | 193 +++++
 .../versioned/typed/federation/v1/fake/doc.go |  18 +
 .../v1/fake/fake_exportedserviceset.go        | 140 ++++
 .../v1/fake/fake_federation_client.go         |  46 +
 .../v1/fake/fake_importedserviceset.go        | 140 ++++
 .../v1/fake/fake_servicemeshpeer.go           | 140 ++++
 .../typed/federation/v1/federation_client.go  |  97 +++
 .../federation/v1/generated_expansion.go      |  23 +
 .../typed/federation/v1/importedserviceset.go | 193 +++++
 .../typed/federation/v1/servicemeshpeer.go    | 193 +++++
 .../api/client/xnsinformer/core/interface.go  |  61 ++
 .../client/xnsinformer/core/v1/interface.go   |  65 ++
 .../core/v1/servicemeshcontrolplane.go        |  93 +++
 .../core/v1/servicemeshextension.go           |  93 +++
 .../xnsinformer/core/v1/servicemeshmember.go  |  93 +++
 .../core/v1/servicemeshmemberroll.go          |  93 +++
 .../xnsinformer/core/v1alpha1/interface.go    |  44 +
 .../core/v1alpha1/servicemeshextension.go     |  93 +++
 .../client/xnsinformer/core/v2/interface.go   |  44 +
 .../core/v2/servicemeshcontrolplane.go        |  93 +++
 .../api/client/xnsinformer/factory.go         | 186 +++++
 .../xnsinformer/federation/interface.go       |  45 +
 .../federation/v1/exportedserviceset.go       |  93 +++
 .../federation/v1/importedserviceset.go       |  93 +++
 .../xnsinformer/federation/v1/interface.go    |  58 ++
 .../federation/v1/servicemeshpeer.go          |  93 +++
 .../api/client/xnsinformer/generic.go         |  85 ++
 .../internalinterfaces/factory_interfaces.go  |  38 +
 .../api/core/v1/zz_generated.deepcopy.go      |   1 +
 .../api/core/v1alpha1/conversion_generated.go |  45 +-
 .../core/v1alpha1/federationstatus_types.go   | 174 ----
 .../api/core/v1alpha1/groupversion_info.go    |   4 -
 .../api/core/v1alpha1/meshfederation_types.go | 165 ----
 .../core/v1alpha1/zz_generated.deepcopy.go    | 709 +---------------
 .../api/core/v2/zz_generated.deepcopy.go      |   1 +
 vendor/maistra.io/api/federation/v1/doc.go    |  16 +
 .../v1/exportedserviceset_types.go}           |  43 +-
 .../api/federation/v1/groupversion_info.go    |  49 ++
 .../v1}/import_export_mapping.go              |  41 +-
 .../v1/importedserviceset_types.go}           |  56 +-
 .../federation/v1/servicemeshpeer_types.go    | 223 +++++
 .../federation/v1/zz_generated.deepcopy.go    | 646 ++++++++++++++
 .../api/security/v1/trustbundle.pb.go         | 789 ++++++++++++++++++
 .../api/security/v1/trustbundle.proto         |  38 +
 .../security/v1/trustbundle_deepcopy.gen.go   |  78 ++
 vendor/modules.txt                            |  18 +-
 193 files changed, 9300 insertions(+), 5716 deletions(-)
 rename manifests/charts/base/crds/{maistra.io_serviceexports.yaml => federation.maistra.io_exportedservicesets.yaml} (66%)
 create mode 100644 manifests/charts/base/crds/federation.maistra.io_importedservicesets.yaml
 create mode 100644 manifests/charts/base/crds/federation.maistra.io_servicemeshpeers.yaml
 delete mode 100644 manifests/charts/base/crds/maistra.io_federationstatuses.yaml
 delete mode 100644 manifests/charts/base/crds/maistra.io_meshfederations.yaml
 delete mode 100644 manifests/charts/base/crds/maistra.io_serviceimports.yaml
 create mode 100644 manifests/charts/istio-control/istio-discovery/templates/federation.yaml
 create mode 100644 pilot/pkg/xds/tbds.go
 create mode 100644 pkg/servicemesh/federation/common/resources.go
 create mode 100644 pkg/servicemesh/federation/common/testing.go
 create mode 100644 pkg/servicemesh/federation/example/config-poc/common.sh
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/configmap.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/exportedserviceset.yaml
 delete mode 100644 pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
 delete mode 100644 pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/export/servicemeshpeer.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/configmap.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/importedserviceset.yaml
 delete mode 100644 pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
 delete mode 100644 pkg/servicemesh/federation/example/config-poc/import/serviceimports.yaml
 create mode 100644 pkg/servicemesh/federation/example/config-poc/import/servicemeshpeer.yaml
 delete mode 100644 vendor/maistra.io/api/client/informers/externalversions/core/v1alpha1/federationstatus.go
 delete mode 100644 vendor/maistra.io/api/client/informers/externalversions/core/v1alpha1/meshfederation.go
 delete mode 100644 vendor/maistra.io/api/client/informers/externalversions/core/v1alpha1/serviceexports.go
 delete mode 100644 vendor/maistra.io/api/client/informers/externalversions/core/v1alpha1/serviceimports.go
 create mode 100644 vendor/maistra.io/api/client/informers/externalversions/federation/interface.go
 create mode 100644 vendor/maistra.io/api/client/informers/externalversions/federation/v1/exportedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/informers/externalversions/federation/v1/importedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/informers/externalversions/federation/v1/interface.go
 create mode 100644 vendor/maistra.io/api/client/informers/externalversions/federation/v1/servicemeshpeer.go
 delete mode 100644 vendor/maistra.io/api/client/listers/core/v1alpha1/federationstatus.go
 delete mode 100644 vendor/maistra.io/api/client/listers/core/v1alpha1/meshfederation.go
 delete mode 100644 vendor/maistra.io/api/client/listers/core/v1alpha1/serviceexports.go
 delete mode 100644 vendor/maistra.io/api/client/listers/core/v1alpha1/serviceimports.go
 create mode 100644 vendor/maistra.io/api/client/listers/federation/v1/expansion_generated.go
 create mode 100644 vendor/maistra.io/api/client/listers/federation/v1/exportedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/listers/federation/v1/importedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/listers/federation/v1/servicemeshpeer.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/fake/fake_federationstatus.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/fake/fake_meshfederation.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/fake/fake_serviceexports.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/fake/fake_serviceimports.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/federationstatus.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/meshfederation.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/serviceexports.go
 delete mode 100644 vendor/maistra.io/api/client/versioned/typed/core/v1alpha1/serviceimports.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/doc.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/exportedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/doc.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_exportedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_federation_client.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_importedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_servicemeshpeer.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/federation_client.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/generated_expansion.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/importedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/versioned/typed/federation/v1/servicemeshpeer.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshcontrolplane.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshextension.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmember.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmemberroll.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/servicemeshextension.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v2/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/core/v2/servicemeshcontrolplane.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/factory.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/federation/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/federation/v1/exportedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/federation/v1/importedserviceset.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/federation/v1/interface.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/federation/v1/servicemeshpeer.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/generic.go
 create mode 100644 vendor/maistra.io/api/client/xnsinformer/internalinterfaces/factory_interfaces.go
 delete mode 100644 vendor/maistra.io/api/core/v1alpha1/federationstatus_types.go
 delete mode 100644 vendor/maistra.io/api/core/v1alpha1/meshfederation_types.go
 create mode 100644 vendor/maistra.io/api/federation/v1/doc.go
 rename vendor/maistra.io/api/{core/v1alpha1/serviceexports_types.go => federation/v1/exportedserviceset_types.go} (56%)
 create mode 100644 vendor/maistra.io/api/federation/v1/groupversion_info.go
 rename vendor/maistra.io/api/{core/v1alpha1 => federation/v1}/import_export_mapping.go (61%)
 rename vendor/maistra.io/api/{core/v1alpha1/serviceimports_types.go => federation/v1/importedserviceset_types.go} (58%)
 create mode 100644 vendor/maistra.io/api/federation/v1/servicemeshpeer_types.go
 create mode 100644 vendor/maistra.io/api/federation/v1/zz_generated.deepcopy.go
 create mode 100644 vendor/maistra.io/api/security/v1/trustbundle.pb.go
 create mode 100644 vendor/maistra.io/api/security/v1/trustbundle.proto
 create mode 100644 vendor/maistra.io/api/security/v1/trustbundle_deepcopy.gen.go

diff --git a/bin/update_maistra_deps.sh b/bin/update_maistra_deps.sh
index a6e90011f5..cad3da9882 100755
--- a/bin/update_maistra_deps.sh
+++ b/bin/update_maistra_deps.sh
@@ -36,10 +36,9 @@ popd
 # rm -f manifests/charts/base/crds/maistra*
 # cp "${dir}"/manifests/* manifests/charts/base/crds
 
-cp "${dir}"/manifests/maistra.io_meshfederations.yaml manifests/charts/base/crds
-cp "${dir}"/manifests/maistra.io_federationstatuses.yaml manifests/charts/base/crds
-cp "${dir}"/manifests/maistra.io_serviceexports.yaml manifests/charts/base/crds
-cp "${dir}"/manifests/maistra.io_serviceimports.yaml manifests/charts/base/crds
+cp "${dir}"/manifests/federation.maistra.io_servicemeshpeers.yaml manifests/charts/base/crds
+cp "${dir}"/manifests/federation.maistra.io_exportedservicesets.yaml manifests/charts/base/crds
+cp "${dir}"/manifests/federation.maistra.io_importedservicesets.yaml manifests/charts/base/crds
 cp "${dir}"/manifests/maistra.io_servicemeshextensions.yaml manifests/charts/base/crds
 
 rm -rf "${dir}"
diff --git a/common/config/.golangci-format.yml b/common/config/.golangci-format.yml
index 15da25a300..9ff1bbf03e 100644
--- a/common/config/.golangci-format.yml
+++ b/common/config/.golangci-format.yml
@@ -30,6 +30,8 @@ run:
   skip-files:
   - ".*\\.pb\\.go"
   - ".*\\.gen\\.go"
+  # This file requires a custom import order for side effects (https://github.com/grpc/grpc-go/issues/4124)
+  - pilot/pkg/networking/grpcgen/grpcgen_test.go
 
 linters:
   disable-all: true
diff --git a/go.mod b/go.mod
index caa5fe22f2..b38084e13f 100644
--- a/go.mod
+++ b/go.mod
@@ -26,7 +26,6 @@ require (
 	github.com/cenkalti/backoff/v4 v4.1.1
 	github.com/census-instrumentation/opencensus-proto v0.3.0
 	github.com/cheggaaa/pb/v3 v3.0.8
-	github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4
 	github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1
 	github.com/containernetworking/cni v1.0.1
 	github.com/containernetworking/plugins v1.0.1
@@ -109,7 +108,7 @@ require (
 	k8s.io/kube-openapi v0.0.0-20211020163157-7327e2aaee2b
 	k8s.io/kubectl v0.22.2
 	k8s.io/utils v0.0.0-20210930125809-cb0fa318a74b
-	maistra.io/api v0.0.0-20210609174032-f933bad53927
+	maistra.io/api v0.0.0-20220301154558-8f6a12a9464b
 	sigs.k8s.io/controller-runtime v0.10.2
 	sigs.k8s.io/gateway-api v0.4.0
 	sigs.k8s.io/mcs-api v0.1.0
diff --git a/go.sum b/go.sum
index ecb19852cd..e68552774c 100644
--- a/go.sum
+++ b/go.sum
@@ -158,6 +158,7 @@ github.com/Shopify/logrus-bugsnag v0.0.0-20171204204709-577dee27f20d/go.mod h1:H
 github.com/VividCortex/ewma v1.1.1 h1:MnEK4VOv6n0RSY4vtRe3h11qjxL3+t0B8yOL8iMXdcM=
 github.com/VividCortex/ewma v1.1.1/go.mod h1:2Tkkvm3sRDVXaiyucHiACn4cqf7DpdyLvmxzcbUokwA=
 github.com/agnivade/levenshtein v1.0.1/go.mod h1:CURSv5d9Uaml+FovSIICkLbAUZ9S4RqaHDIsdSBg7lM=
+github.com/ahmetb/gen-crd-api-reference-docs v0.2.0/go.mod h1:P/XzJ+c2+khJKNKABcm2biRwk2QAuwbLf8DlXuaL7WM=
 github.com/ahmetb/gen-crd-api-reference-docs v0.3.0/go.mod h1:TdjdkYhlOifCQWPs1UdTma97kQQMozf5h26hTuG70u8=
 github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
 github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
@@ -486,6 +487,7 @@ github.com/go-logfmt/logfmt v0.5.0 h1:TrB8swr/68K7m9CcGut2g3UOihhbcbiMAYiuTXdEih
 github.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=
 github.com/go-logr/logr v0.1.0/go.mod h1:ixOQHD9gLJUVQQ2ZOR7zLEifBX6tGkNJF4QyIY7sIas=
 github.com/go-logr/logr v0.2.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=
+github.com/go-logr/logr v0.2.1/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=
 github.com/go-logr/logr v0.4.0 h1:K7/B1jt6fIBQVd4Owv2MqGQClcgf0R266+7C/QjRcLc=
 github.com/go-logr/logr v0.4.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=
 github.com/go-logr/zapr v0.1.0/go.mod h1:tabnROwaDl0UNxkVeFRbY8bwB37GwRv0P8lg6aAiEnk=
@@ -841,6 +843,7 @@ github.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN
 github.com/mailru/easyjson v0.7.0/go.mod h1:KAzv3t3aY1NaHWoQz1+4F1ccyAH66Jk7yos7ldAVICs=
 github.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=
 github.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
+github.com/maistra/xns-informer v0.0.0-20210707160032-977ec17e2e0e/go.mod h1:Bwe3VRiuXlSXu8MktDkmbrFcmSDysxuoOra542o0Ljk=
 github.com/maistra/xns-informer v0.0.0-20220301142458-d7b9519d1378 h1:98m9pi+S27+hRD2y4FLuvD5Eu6KJRkD0HVUdw++fF2o=
 github.com/maistra/xns-informer v0.0.0-20220301142458-d7b9519d1378/go.mod h1:0ZUF4kjow/MlN7Gp6OY7w2qBsWSG4MDBNxUp1VSSs/A=
 github.com/markbates/errx v1.1.0/go.mod h1:PLa46Oex9KNbVDZhKel8v1OT7hD5JZ2eI7AHhA0wswc=
@@ -1409,6 +1412,7 @@ golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/
 golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
+golang.org/x/net v0.0.0-20200904194848-62affa334b73/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20201006153459-a7d1128ccaa0/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
 golang.org/x/net v0.0.0-20201010224723-4f7140c49acb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
 golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
@@ -1612,6 +1616,7 @@ golang.org/x/tools v0.0.0-20181030000716-a0a13e073c7b/go.mod h1:n7NCudcB/nEzxVGm
 golang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20190125232054-d66bd3c5d5a6/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20190213192042-740235f6c0d8/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
 golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
 golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
@@ -1663,6 +1668,7 @@ golang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc
 golang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
 golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=
 golang.org/x/tools v0.0.0-20200918232735-d647fc253266/go.mod h1:z6u4i615ZeAfBE4XtMziQW1fSVJXACjjbWkB/mvPzlU=
+golang.org/x/tools v0.0.0-20200930213115-e57f6d466a48/go.mod h1:z6u4i615ZeAfBE4XtMziQW1fSVJXACjjbWkB/mvPzlU=
 golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
 golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
 golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
@@ -1825,6 +1831,7 @@ google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8
 google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
 google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
 google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
+google.golang.org/grpc v1.28.1/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
 google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
 google.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
 google.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
@@ -1916,10 +1923,13 @@ honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWh
 honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
 honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
 honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
+istio.io/api v0.0.0-20210503211644-902e709f95c4/go.mod h1:88HN3o1fSD1jo+Z1WTLlJfMm9biopur6Ct9BFKjiB64=
 istio.io/api v0.0.0-20211213163208-276abc55e8b6 h1:SaELFVO+BXztVVenqmpKmz+2hyuV5mPWoDfUJNX3c6o=
 istio.io/api v0.0.0-20211213163208-276abc55e8b6/go.mod h1:lavaUNsnT7RGyMFNOGgV5XvOgP3fkTSZkxP/0H/ISt4=
+istio.io/client-go v0.0.0-20210503213042-e6eb157f0d81/go.mod h1:LAkylvGs/+IEUnUXfYqMS5y0lLx45ruBTds327AdmIQ=
 istio.io/client-go v1.12.2-0.20211213163610-ffa18a1c9657 h1:AXDVUh0uSJge52IgeWVXohu+eBQrsKegARIJI78Gytc=
 istio.io/client-go v1.12.2-0.20211213163610-ffa18a1c9657/go.mod h1:u30/VQQ/pSpJ4IuY4ZzCZ2RqP31EOl4YaH0KcjQxb0M=
+istio.io/gogo-genproto v0.0.0-20190930162913-45029607206a/go.mod h1:OzpAts7jljZceG4Vqi5/zXy/pOg1b209T3jb7Nv5wIs=
 istio.io/gogo-genproto v0.0.0-20210113155706-4daf5697332f/go.mod h1:6BwTZRNbWS570wHX/uR1Wqk5e0157TofTAUMzT7N4+s=
 istio.io/gogo-genproto v0.0.0-20211206163843-5eda25c96270 h1:0917ISaYHtA+SaMcCYU1fieCLnWSZ/gVqNNAAVXhed4=
 istio.io/gogo-genproto v0.0.0-20211206163843-5eda25c96270/go.mod h1:6BwTZRNbWS570wHX/uR1Wqk5e0157TofTAUMzT7N4+s=
@@ -1929,7 +1939,7 @@ k8s.io/api v0.18.2/go.mod h1:SJCWI7OLzhZSvbY7U8zwNl9UA4o1fizoug34OV/2r78=
 k8s.io/api v0.18.4/go.mod h1:lOIQAKYgai1+vz9J7YcDZwC26Z0zQewYOGWdyIPUUQ4=
 k8s.io/api v0.18.6/go.mod h1:eeyxr+cwCjMdLAmr2W3RyDI0VvTawSg/3RFFBEnmZGI=
 k8s.io/api v0.19.0/go.mod h1:I1K45XlvTrDjmj5LoM5LuP/KYrhWbjUKT/SoPG0qTjw=
-k8s.io/api v0.19.3/go.mod h1:VF+5FT1B74Pw3KxMdKyinLo+zynBaMBiAfGMuldcNDs=
+k8s.io/api v0.19.2/go.mod h1:IQpK0zFQ1xc5iNIQPqzgoOwuFugaYHK4iCknlAQP9nI=
 k8s.io/api v0.20.1/go.mod h1:KqwcCVogGxQY3nBlRpwt+wpAMF/KjaCc7RpywacvqUo=
 k8s.io/api v0.20.2/go.mod h1:d7n6Ehyzx+S+cE3VhTGfVNNqtGc/oL9DCdYYahlurV8=
 k8s.io/api v0.20.4/go.mod h1:++lNL1AJMkDymriNniQsWRkMDzRaX2Y/POTUi8yvqYQ=
@@ -1946,11 +1956,12 @@ k8s.io/apiextensions-apiserver v0.21.3/go.mod h1:kl6dap3Gd45+21Jnh6utCx8Z2xxLm8L
 k8s.io/apiextensions-apiserver v0.22.1/go.mod h1:HeGmorjtRmRLE+Q8dJu6AYRoZccvCMsghwS8XTUYb2c=
 k8s.io/apiextensions-apiserver v0.22.2 h1:zK7qI8Ery7j2CaN23UCFaC1hj7dMiI87n01+nKuewd4=
 k8s.io/apiextensions-apiserver v0.22.2/go.mod h1:2E0Ve/isxNl7tWLSUDgi6+cmwHi5fQRdwGVCxbC+KFA=
+k8s.io/apimachinery v0.18.1/go.mod h1:9SnR/e11v5IbyPCGbvJViimtJ0SwHG4nfZFjU77ftcA=
 k8s.io/apimachinery v0.18.2/go.mod h1:9SnR/e11v5IbyPCGbvJViimtJ0SwHG4nfZFjU77ftcA=
 k8s.io/apimachinery v0.18.4/go.mod h1:OaXp26zu/5J7p0f92ASynJa1pZo06YlV9fG7BoWbCko=
 k8s.io/apimachinery v0.18.6/go.mod h1:OaXp26zu/5J7p0f92ASynJa1pZo06YlV9fG7BoWbCko=
 k8s.io/apimachinery v0.19.0/go.mod h1:DnPGDnARWFvYa3pMHgSxtbZb7gpzzAZ1pTfaUNDVlmA=
-k8s.io/apimachinery v0.19.3/go.mod h1:DnPGDnARWFvYa3pMHgSxtbZb7gpzzAZ1pTfaUNDVlmA=
+k8s.io/apimachinery v0.19.2/go.mod h1:DnPGDnARWFvYa3pMHgSxtbZb7gpzzAZ1pTfaUNDVlmA=
 k8s.io/apimachinery v0.20.1/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
 k8s.io/apimachinery v0.20.2/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
 k8s.io/apimachinery v0.20.4/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
@@ -1976,7 +1987,7 @@ k8s.io/client-go v0.18.2/go.mod h1:Xcm5wVGXX9HAA2JJ2sSBUn3tCJ+4SVlCbl2MNNv+CIU=
 k8s.io/client-go v0.18.4/go.mod h1:f5sXwL4yAZRkAtzOxRWUhA/N8XzGCb+nPZI8PfobZ9g=
 k8s.io/client-go v0.18.6/go.mod h1:/fwtGLjYMS1MaM5oi+eXhKwG+1UHidUEXRh6cNsdO0Q=
 k8s.io/client-go v0.19.0/go.mod h1:H9E/VT95blcFQnlyShFgnFT9ZnJOAceiUHM3MlRC+mU=
-k8s.io/client-go v0.19.3/go.mod h1:+eEMktZM+MG0KO+PTkci8xnbCZHvj9TqR6Q1XDUIJOM=
+k8s.io/client-go v0.19.2/go.mod h1:S5wPhCqyDNAlzM9CnEdgTGV4OqhsW3jGO1UM1epwfJA=
 k8s.io/client-go v0.20.1/go.mod h1:/zcHdt1TeWSd5HoUe6elJmHSQ6uLLgp4bIJHVEuy+/Y=
 k8s.io/client-go v0.20.4/go.mod h1:LiMv25ND1gLUdBeYxBIwKpkSC5IsozMMmOOeSJboP+k=
 k8s.io/client-go v0.20.6/go.mod h1:nNQMnOvEUEsOzRRFIIkdmYOjAZrC8bgq0ExboWSU1I0=
@@ -1989,7 +2000,8 @@ k8s.io/code-generator v0.18.2/go.mod h1:+UHX5rSbxmR8kzS+FAv7um6dtYrZokQvjHpDSYRV
 k8s.io/code-generator v0.18.4/go.mod h1:TgNEVx9hCyPGpdtCWA34olQYLkh3ok9ar7XfSsr8b6c=
 k8s.io/code-generator v0.18.6/go.mod h1:TgNEVx9hCyPGpdtCWA34olQYLkh3ok9ar7XfSsr8b6c=
 k8s.io/code-generator v0.19.0/go.mod h1:moqLn7w0t9cMs4+5CQyxnfA/HV8MF6aAVENF+WZZhgk=
-k8s.io/code-generator v0.19.3/go.mod h1:moqLn7w0t9cMs4+5CQyxnfA/HV8MF6aAVENF+WZZhgk=
+k8s.io/code-generator v0.19.2/go.mod h1:moqLn7w0t9cMs4+5CQyxnfA/HV8MF6aAVENF+WZZhgk=
+k8s.io/code-generator v0.20.1/go.mod h1:UsqdF+VX4PU2g46NC2JRs4gc+IfrctnwHb76RNbWHJg=
 k8s.io/code-generator v0.21.3/go.mod h1:K3y0Bv9Cz2cOW2vXUrNZlFbflhuPvuadW6JdnN6gGKo=
 k8s.io/code-generator v0.22.0/go.mod h1:eV77Y09IopzeXOJzndrDyCI88UBok2h6WxAlBwpxa+o=
 k8s.io/code-generator v0.22.1/go.mod h1:eV77Y09IopzeXOJzndrDyCI88UBok2h6WxAlBwpxa+o=
@@ -2014,6 +2026,8 @@ k8s.io/gengo v0.0.0-20190128074634-0689ccc1d7d6/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8
 k8s.io/gengo v0.0.0-20200114144118-36b2048a9120/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20200428234225-8167cfdcfc14/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
+k8s.io/gengo v0.0.0-20200728071708-7794989d0000/go.mod h1:aG2eeomYfcUw8sE3fa7YdkjgnGtyY56TjZlaJJ0ZoWo=
+k8s.io/gengo v0.0.0-20201113003025-83324d819ded/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20201203183100-97869a43a9d9/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20201214224949-b6c5ce23f027/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20210813121822-485abfe95c7c/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
@@ -2034,6 +2048,7 @@ k8s.io/klog/v2 v2.10.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=
 k8s.io/kube-openapi v0.0.0-20200121204235-bf4fb3bd569c/go.mod h1:GRQhZsXIAJ1xR0C9bd8UpWHZ5plfAS9fzPjJuQ6JL3E=
 k8s.io/kube-openapi v0.0.0-20200410145947-61e04a5be9a6/go.mod h1:GRQhZsXIAJ1xR0C9bd8UpWHZ5plfAS9fzPjJuQ6JL3E=
 k8s.io/kube-openapi v0.0.0-20200805222855-6aeccd4b50c6/go.mod h1:UuqjUnNftUyPE5H64/qeyjQoUZhGpeFDVdxjTeEVN2o=
+k8s.io/kube-openapi v0.0.0-20200831175022-64514a1d5d59/go.mod h1:UuqjUnNftUyPE5H64/qeyjQoUZhGpeFDVdxjTeEVN2o=
 k8s.io/kube-openapi v0.0.0-20201113171705-d219536bb9fd/go.mod h1:WOJ3KddDSol4tAGcJo0Tvi+dK12EcqSLqcWsryKMpfM=
 k8s.io/kube-openapi v0.0.0-20210305001622-591a79e4bda7/go.mod h1:wXW5VT87nVfh/iLV8FpR2uDvrFyomxbtb1KivDbvPTE=
 k8s.io/kube-openapi v0.0.0-20210421082810-95288971da7e/go.mod h1:vHXdDvt9+2spS2Rx9ql3I8tycm3H9FDfdUoIuKCefvw=
@@ -2056,10 +2071,8 @@ k8s.io/utils v0.0.0-20210819203725-bdf08cb9a70a/go.mod h1:jPW/WVKK9YHAvNhRxK0md/
 k8s.io/utils v0.0.0-20210820185131-d34e5cb4466e/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
 k8s.io/utils v0.0.0-20210930125809-cb0fa318a74b h1:wxEMGetGMur3J1xuGLQY7GEQYg9bZxKn3tKo5k/eYcs=
 k8s.io/utils v0.0.0-20210930125809-cb0fa318a74b/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
-maistra.io/api v0.0.0-20210601141927-1cbee4cb8ce8 h1:hBSNtXLQFFH27vJQvblel28HFClrJxVHlVKK9g69auE=
-maistra.io/api v0.0.0-20210601141927-1cbee4cb8ce8/go.mod h1:Os/zrIv6nsjgC43UAo17FFv+fvYlzANUWIpNNZEZ/KE=
-maistra.io/api v0.0.0-20210609174032-f933bad53927 h1:6HvkPG7FLx1mFsUVn2MgJQ/QGcSvXhUwzFKilOACf8k=
-maistra.io/api v0.0.0-20210609174032-f933bad53927/go.mod h1:Os/zrIv6nsjgC43UAo17FFv+fvYlzANUWIpNNZEZ/KE=
+maistra.io/api v0.0.0-20220301154558-8f6a12a9464b h1:BxzFHBRoPPFTqh//J9LE6wWJhT5eZU+7V3qZegFFH1g=
+maistra.io/api v0.0.0-20220301154558-8f6a12a9464b/go.mod h1:SZ10GvT+vvHarnUsyGCOo1XcOE+wGwTC+1l0VXZ0Gac=
 oras.land/oras-go v0.4.0/go.mod h1:VJcU+VE4rkclUbum5C0O7deEZbBYnsnpbGSACwTjOcg=
 rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
 rsc.io/letsencrypt v0.0.3/go.mod h1:buyQKZ6IXrRnB7TdkHP0RyEybLx18HHyOSoTyoOLqNY=
@@ -2071,12 +2084,12 @@ sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.15/go.mod h1:LEScyz
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.19/go.mod h1:LEScyzhFmoF5pso/YSeBstl57mOzx9xlU9n85RGrDQg=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.22/go.mod h1:LEScyzhFmoF5pso/YSeBstl57mOzx9xlU9n85RGrDQg=
 sigs.k8s.io/controller-runtime v0.6.1/go.mod h1:XRYBPdbf5XJu9kpS84VJiZ7h/u1hF3gEORz0efEja7A=
-sigs.k8s.io/controller-runtime v0.6.3/go.mod h1:WlZNXcM0++oyaQt4B7C2lEE5JYRs8vJUzRP4N4JpdAY=
+sigs.k8s.io/controller-runtime v0.6.2/go.mod h1:vhcq/rlnENJ09SIRp3EveTaZ0yqH526hjf9iJdbUJ/E=
 sigs.k8s.io/controller-runtime v0.9.6/go.mod h1:q6PpkM5vqQubEKUKOM6qr06oXGzOBcCby1DA9FbyZeA=
 sigs.k8s.io/controller-runtime v0.10.2 h1:jW8qiY+yMnnPx6O9hu63tgcwaKzd1yLYui+mpvClOOc=
 sigs.k8s.io/controller-runtime v0.10.2/go.mod h1:CQp8eyUQZ/Q7PJvnIrB6/hgfTC1kBkGylwsLgOQi1WY=
 sigs.k8s.io/controller-tools v0.3.0/go.mod h1:enhtKGfxZD1GFEoMgP8Fdbu+uKQ/cq1/WGJhdVChfvI=
-sigs.k8s.io/controller-tools v0.4.1/go.mod h1:G9rHdZMVlBDocIxGkK3jHLWqcTMNvveypYJwrvYKjWU=
+sigs.k8s.io/controller-tools v0.4.0/go.mod h1:G9rHdZMVlBDocIxGkK3jHLWqcTMNvveypYJwrvYKjWU=
 sigs.k8s.io/controller-tools v0.6.2/go.mod h1:oaeGpjXn6+ZSEIQkUe/+3I40PNiDYp9aeawbt3xTgJ8=
 sigs.k8s.io/gateway-api v0.4.0 h1:07IJkTt21NetZTHtPKJk2I4XIgDN4BAlTIq1wK7V11o=
 sigs.k8s.io/gateway-api v0.4.0/go.mod h1:r3eiNP+0el+NTLwaTfOrCNXy8TukC+dIM3ggc+fbNWk=
@@ -2089,6 +2102,7 @@ sigs.k8s.io/kustomize/kyaml v0.11.0 h1:9KhiCPKaVyuPcgOLJXkvytOvjMJLoxpjodiycb4gH
 sigs.k8s.io/kustomize/kyaml v0.11.0/go.mod h1:GNMwjim4Ypgp/MueD3zXHLRJEjz7RvtPae0AwlvEMFM=
 sigs.k8s.io/mcs-api v0.1.0 h1:edDbg0oRGfXw8TmZjKYep06LcJLv/qcYLidejnUp0PM=
 sigs.k8s.io/mcs-api v0.1.0/go.mod h1:gGiAryeFNB4GBsq2LBmVqSgKoobLxt+p7ii/WG5QYYw=
+sigs.k8s.io/service-apis v0.1.0-rc2.0.20201112213625-c0375b7fa81f/go.mod h1:QkiV/PnK7YbN5zqYqXnh5wByTTT1LYJ5scwdIs62qWs=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0-20200116222232-67a7b8c61874/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
 sigs.k8s.io/structured-merge-diff/v4 v4.0.1/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
diff --git a/manifests/charts/base/crds/maistra.io_serviceexports.yaml b/manifests/charts/base/crds/federation.maistra.io_exportedservicesets.yaml
similarity index 66%
rename from manifests/charts/base/crds/maistra.io_serviceexports.yaml
rename to manifests/charts/base/crds/federation.maistra.io_exportedservicesets.yaml
index c2cbb32817..6ff179e6c2 100644
--- a/manifests/charts/base/crds/maistra.io_serviceexports.yaml
+++ b/manifests/charts/base/crds/federation.maistra.io_exportedservicesets.yaml
@@ -1,25 +1,26 @@
 
+---
 apiVersion: apiextensions.k8s.io/v1beta1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: (devel)
+    controller-gen.kubebuilder.io/version: v0.4.1
   creationTimestamp: null
-  name: serviceexports.maistra.io
+  name: exportedservicesets.federation.maistra.io
 spec:
-  group: maistra.io
+  group: federation.maistra.io
   names:
-    kind: ServiceExports
-    listKind: ServiceExportsList
-    plural: serviceexports
-    singular: serviceexports
+    kind: ExportedServiceSet
+    listKind: ExportedServiceSetList
+    plural: exportedservicesets
+    singular: exportedserviceset
   preserveUnknownFields: false
   scope: Namespaced
   subresources:
     status: {}
   validation:
     openAPIV3Schema:
-      description: ServiceExport is the Schema for configuring exported services.  The name of the ServiceExports resource must match the name of a MeshFederation resource defining the remote mesh to which the services will be exported.
+      description: ExportedServiceSet is the Schema for configuring exported services.  The name of the ExportedServiceSet resource must match the name of a ServiceMeshPeer resource defining the remote mesh to which the services will be exported.
       properties:
         apiVersion:
           description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
@@ -32,8 +33,8 @@ spec:
         spec:
           description: Spec defines rules for matching services to be exported.
           properties:
-            exports:
-              description: Exports are the rules that determine which services are exported from the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
+            exportRules:
+              description: ExportRules are the rules that determine which services are exported from the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
               items:
                 properties:
                   labelSelector:
@@ -51,12 +52,9 @@ spec:
                                   type: string
                               type: object
                             name:
-                              properties:
-                                name:
-                                  type: string
-                                namespace:
-                                  type: string
-                              type: object
+                              type: string
+                            namespace:
+                              type: string
                           type: object
                         type: array
                       namespace:
@@ -104,12 +102,9 @@ spec:
                             type: string
                         type: object
                       name:
-                        properties:
-                          name:
-                            type: string
-                          namespace:
-                            type: string
-                        type: object
+                        type: string
+                      namespace:
+                        type: string
                     type: object
                   type:
                     description: Type of rule.  One of Name or Label.
@@ -120,11 +115,47 @@ spec:
               type: array
           type: object
         status:
+          properties:
+            exportedServices:
+              description: Exports provides details about the services exported by this mesh.
+              items:
+                description: PeerServiceMapping represents the name mapping between an exported service and its local counterpart.
+                properties:
+                  exportedName:
+                    description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                    type: string
+                  localService:
+                    description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                    properties:
+                      hostname:
+                        description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                        type: string
+                      name:
+                        description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                        type: string
+                      namespace:
+                        description: Namespace represents the namespace within which the service resides.
+                        type: string
+                    required:
+                    - hostname
+                    - name
+                    - namespace
+                    type: object
+                required:
+                - exportedName
+                - localService
+                type: object
+              type: array
+              x-kubernetes-list-map-keys:
+              - exportedName
+              x-kubernetes-list-type: map
+          required:
+          - exportedServices
           type: object
       type: object
-  version: v1alpha1
+  version: v1
   versions:
-  - name: v1alpha1
+  - name: v1
     served: true
     storage: true
 status:
diff --git a/manifests/charts/base/crds/federation.maistra.io_importedservicesets.yaml b/manifests/charts/base/crds/federation.maistra.io_importedservicesets.yaml
new file mode 100644
index 0000000000..76d65c24ed
--- /dev/null
+++ b/manifests/charts/base/crds/federation.maistra.io_importedservicesets.yaml
@@ -0,0 +1,134 @@
+
+---
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.4.1
+  creationTimestamp: null
+  name: importedservicesets.federation.maistra.io
+spec:
+  group: federation.maistra.io
+  names:
+    kind: ImportedServiceSet
+    listKind: ImportedServiceSetList
+    plural: importedservicesets
+    singular: importedserviceset
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: ImportedServiceSet is the Schema for configuring imported services.  The name of the ImportedServiceSet resource must match the name of a ServiceMeshPeer resource defining the remote mesh from which the services will be imported.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: Spec defines rules for matching services to be imported.
+          properties:
+            domainSuffix:
+              description: 'DomainSuffix specifies the domain suffix to be applies to imported services.  If no domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.svc.<mesh-name>-imports.local If a domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.<domain-suffix>'
+              type: string
+            importRules:
+              description: ImportRules are the rules that determine which services are imported to the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
+              items:
+                properties:
+                  domainSuffix:
+                    description: DomainSuffix applies the specified suffix to services imported by this rule.  The behavior is identical to that of ImportedServiceSetSpec.DomainSuffix.
+                    type: string
+                  importAsLocal:
+                    description: ImportAsLocal imports the service as a local service in the mesh.  For example, if an exported service, foo/bar is imported as some-ns/service, the service will be imported as service.some-ns.svc.cluster.local in the some-ns namespace.  If a service of this name already exists in the mesh, the imported service's endpoints will be aggregated with any other workloads associated with the service.  This setting overrides DomainSuffix.
+                    type: boolean
+                  nameSelector:
+                    description: NameSelector provides a simple name matcher for importing services in the mesh.
+                    properties:
+                      alias:
+                        properties:
+                          name:
+                            type: string
+                          namespace:
+                            type: string
+                        type: object
+                      name:
+                        type: string
+                      namespace:
+                        type: string
+                    type: object
+                  type:
+                    description: Type of rule.  Only Name type is supported.
+                    type: string
+                required:
+                - type
+                type: object
+              type: array
+            locality:
+              description: Locality within which imported services should be associated.
+              properties:
+                region:
+                  description: Region within which imported services are located.
+                  type: string
+                subzone:
+                  description: Subzone within which imported services are located.  If Subzone is specified, Zone must also be specified.
+                  type: string
+                zone:
+                  description: Zone within which imported services are located.  If Zone is specified, Region must also be specified.
+                  type: string
+              type: object
+          type: object
+        status:
+          properties:
+            importedServices:
+              description: Imports provides details about the services imported by this mesh.
+              items:
+                description: PeerServiceMapping represents the name mapping between an exported service and its local counterpart.
+                properties:
+                  exportedName:
+                    description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                    type: string
+                  localService:
+                    description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                    properties:
+                      hostname:
+                        description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                        type: string
+                      name:
+                        description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                        type: string
+                      namespace:
+                        description: Namespace represents the namespace within which the service resides.
+                        type: string
+                    required:
+                    - hostname
+                    - name
+                    - namespace
+                    type: object
+                required:
+                - exportedName
+                - localService
+                type: object
+              type: array
+              x-kubernetes-list-map-keys:
+              - exportedName
+              x-kubernetes-list-type: map
+          required:
+          - importedServices
+          type: object
+      type: object
+  version: v1
+  versions:
+  - name: v1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/crds/federation.maistra.io_servicemeshpeers.yaml b/manifests/charts/base/crds/federation.maistra.io_servicemeshpeers.yaml
new file mode 100644
index 0000000000..d0d5cdc7e8
--- /dev/null
+++ b/manifests/charts/base/crds/federation.maistra.io_servicemeshpeers.yaml
@@ -0,0 +1,283 @@
+
+---
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.4.1
+  creationTimestamp: null
+  name: servicemeshpeers.federation.maistra.io
+spec:
+  group: federation.maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: ServiceMeshPeer
+    listKind: ServiceMeshPeerList
+    plural: servicemeshpeers
+    singular: servicemeshpeer
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: ServiceMeshPeer is the Schema for joining two meshes together.  The resource name will be used to identify the 'cluster' to which imported services belong.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: ServiceMeshPeerSpec configures details required to support federation with another service mesh.
+          properties:
+            gateways:
+              description: Gateways configures the gateways used to facilitate ingress and egress with the other mesh.
+              properties:
+                egress:
+                  description: Gateway through which outbound federated service traffic will travel. This is not required if AllowDirectOutbound is set to true.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+                ingress:
+                  description: Gateway through which inbound federated service traffic will travel.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+              type: object
+            remote:
+              description: Remote configures details related to the remote mesh with which this mesh is federating.
+              properties:
+                addresses:
+                  description: Addresses are the addresses to which discovery and service requests should be sent (i.e. the addresses of ingress gateways on the remote mesh).  These may be specified as resolveable DNS names or IP addresses.
+                  items:
+                    type: string
+                  type: array
+                discoveryPort:
+                  description: DiscoveryPort is the port on which the addresses are handling discovery requests.  Defaults to 8188, if unspecified.
+                  format: int32
+                  type: integer
+                servicePort:
+                  description: ServicePort is the port on which the addresses are handling service requests.  Defaults to 15443, if unspecified.
+                  format: int32
+                  type: integer
+              type: object
+            security:
+              description: Security configures details for securing communication with the other mesh.
+              properties:
+                certificateChain:
+                  description: Name of ConfigMap containing certificate chain to be used to validate the remote.  This is also used to validate certificates used by the remote services (both client and server certificates).  The name of the entry should be root-cert.pem.  If unspecified, it will look for a ConfigMap named <meshfederation-name>-ca-root-cert, e.g. if this resource is named mesh1, it will look for a ConfigMap named mesh1-ca-root-cert.
+                  properties:
+                    apiGroup:
+                      description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
+                      type: string
+                    kind:
+                      description: Kind is the type of resource being referenced
+                      type: string
+                    name:
+                      description: Name is the name of resource being referenced
+                      type: string
+                  required:
+                  - kind
+                  - name
+                  type: object
+                clientID:
+                  description: ClientID of the remote mesh.  This is used to authenticate incoming requrests from the remote mesh's discovery client.
+                  type: string
+                trustDomain:
+                  description: TrustDomain of remote mesh.
+                  type: string
+              type: object
+          type: object
+        status:
+          description: ServiceMeshPeerStatus provides information related to the other mesh.
+          properties:
+            discoveryStatus:
+              description: DiscoveryStatus represents the discovery status of each pilot/istiod pod in the mesh.
+              properties:
+                active:
+                  description: Active represents the pilot/istiod pods actively watching the other mesh for discovery.
+                  items:
+                    description: PodPeerDiscoveryStatus provides discovery details related to a specific pilot/istiod pod.
+                    properties:
+                      pod:
+                        description: Pod is the pod name to which these details apply.  This maps to a a pilot/istiod pod.
+                        type: string
+                      remotes:
+                        description: Remotes represents details related to the inbound connections from remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                        x-kubernetes-list-map-keys:
+                        - source
+                        x-kubernetes-list-type: map
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    required:
+                    - pod
+                    type: object
+                  nullable: true
+                  type: array
+                  x-kubernetes-list-map-keys:
+                  - pod
+                  x-kubernetes-list-type: map
+                inactive:
+                  description: Inactive represents the pilot/istiod pods not actively watching the other mesh for discovery.
+                  items:
+                    description: PodPeerDiscoveryStatus provides discovery details related to a specific pilot/istiod pod.
+                    properties:
+                      pod:
+                        description: Pod is the pod name to which these details apply.  This maps to a a pilot/istiod pod.
+                        type: string
+                      remotes:
+                        description: Remotes represents details related to the inbound connections from remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                        x-kubernetes-list-map-keys:
+                        - source
+                        x-kubernetes-list-type: map
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    required:
+                    - pod
+                    type: object
+                  nullable: true
+                  type: array
+                  x-kubernetes-list-map-keys:
+                  - pod
+                  x-kubernetes-list-type: map
+              type: object
+          type: object
+      type: object
+  version: v1
+  versions:
+  - name: v1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_federationstatuses.yaml b/manifests/charts/base/crds/maistra.io_federationstatuses.yaml
deleted file mode 100644
index 654aabb44c..0000000000
--- a/manifests/charts/base/crds/maistra.io_federationstatuses.yaml
+++ /dev/null
@@ -1,195 +0,0 @@
-
-apiVersion: apiextensions.k8s.io/v1beta1
-kind: CustomResourceDefinition
-metadata:
-  annotations:
-    controller-gen.kubebuilder.io/version: (devel)
-  creationTimestamp: null
-  name: federationstatuses.maistra.io
-spec:
-  group: maistra.io
-  names:
-    categories:
-    - maistra-io
-    kind: FederationStatus
-    listKind: FederationStatusList
-    plural: federationstatuses
-    singular: federationstatus
-  preserveUnknownFields: false
-  scope: Namespaced
-  subresources:
-    status: {}
-  validation:
-    openAPIV3Schema:
-      description: FederationStatus is the Schema for reporting the status of a MeshFederation. The name of the FederationStatus will match the name of the istiod pod to which it is associated.  There will be one FederationStatus resource for each istiod pod.
-      properties:
-        apiVersion:
-          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
-          type: string
-        kind:
-          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
-          type: string
-        metadata:
-          type: object
-        spec:
-          description: Spec is unused
-          type: object
-        status:
-          description: Status of the mesh federations
-          properties:
-            meshes:
-              description: Meshes represents the status of each federated mesh.  The key represents the name of the MeshFederation resource configuring federation for with a remote mesh (as namespace/name).
-              items:
-                description: FederationStatusDetails provides details about a particular federated mesh.
-                properties:
-                  discovery:
-                    description: Discovery provides details about the connection to the remote mesh.
-                    properties:
-                      remotes:
-                        description: Remotes represents details related to the inbound connections remote meshes.
-                        items:
-                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
-                          properties:
-                            connected:
-                              description: Connected identfies an active connection with the remote mesh.
-                              type: boolean
-                            lastConnected:
-                              description: LastConnected represents the last time a connection with the remote mesh was successful.
-                              format: date-time
-                              type: string
-                            lastDisconnect:
-                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
-                              format: date-time
-                              type: string
-                            lastDisconnectStatus:
-                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
-                              type: string
-                            lastEvent:
-                              description: LastEvent represents the last time an event was received from the remote mesh.
-                              format: date-time
-                              type: string
-                            lastFullSync:
-                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
-                              format: date-time
-                              type: string
-                            source:
-                              description: Source represents the source of the remote watch.
-                              type: string
-                          required:
-                          - connected
-                          - source
-                          type: object
-                        type: array
-                      watch:
-                        description: Watch represents details related to the outbound connection to the remote mesh.
-                        properties:
-                          connected:
-                            description: Connected identfies an active connection with the remote mesh.
-                            type: boolean
-                          lastConnected:
-                            description: LastConnected represents the last time a connection with the remote mesh was successful.
-                            format: date-time
-                            type: string
-                          lastDisconnect:
-                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
-                            format: date-time
-                            type: string
-                          lastDisconnectStatus:
-                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
-                            type: string
-                          lastEvent:
-                            description: LastEvent represents the last time an event was received from the remote mesh.
-                            format: date-time
-                            type: string
-                          lastFullSync:
-                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
-                            format: date-time
-                            type: string
-                        required:
-                        - connected
-                        type: object
-                    type: object
-                  exports:
-                    description: Exports provides details about the services exported by this mesh.
-                    items:
-                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
-                      properties:
-                        exportedName:
-                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
-                          type: string
-                        localService:
-                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
-                          properties:
-                            hostname:
-                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
-                              type: string
-                            name:
-                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
-                              type: string
-                            namespace:
-                              description: Namespace represents the namespace within which the service resides.
-                              type: string
-                          required:
-                          - hostname
-                          - name
-                          - namespace
-                          type: object
-                      required:
-                      - exportedName
-                      - localService
-                      type: object
-                    type: array
-                  imports:
-                    description: Imports provides details about the services imported by this mesh.
-                    items:
-                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
-                      properties:
-                        exportedName:
-                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
-                          type: string
-                        localService:
-                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
-                          properties:
-                            hostname:
-                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
-                              type: string
-                            name:
-                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
-                              type: string
-                            namespace:
-                              description: Namespace represents the namespace within which the service resides.
-                              type: string
-                          required:
-                          - hostname
-                          - name
-                          - namespace
-                          type: object
-                      required:
-                      - exportedName
-                      - localService
-                      type: object
-                    type: array
-                  mesh:
-                    description: Mesh is the mesh to which this status applies.  This maps to a MeshFederation resource.
-                    type: string
-                required:
-                - discovery
-                - exports
-                - imports
-                - mesh
-                type: object
-              nullable: true
-              type: array
-          type: object
-      type: object
-  version: v1alpha1
-  versions:
-  - name: v1alpha1
-    served: true
-    storage: true
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_meshfederations.yaml b/manifests/charts/base/crds/maistra.io_meshfederations.yaml
deleted file mode 100644
index 4f42ff127e..0000000000
--- a/manifests/charts/base/crds/maistra.io_meshfederations.yaml
+++ /dev/null
@@ -1,112 +0,0 @@
-
-apiVersion: apiextensions.k8s.io/v1beta1
-kind: CustomResourceDefinition
-metadata:
-  annotations:
-    controller-gen.kubebuilder.io/version: (devel)
-  creationTimestamp: null
-  name: meshfederations.maistra.io
-spec:
-  group: maistra.io
-  names:
-    categories:
-    - maistra-io
-    kind: MeshFederation
-    listKind: MeshFederationList
-    plural: meshfederations
-    singular: meshfederation
-  preserveUnknownFields: false
-  scope: Namespaced
-  subresources:
-    status: {}
-  validation:
-    openAPIV3Schema:
-      description: MeshFederation is the Schema for joining two meshes together.  The resource name will be used to identify the 'cluster' to which imported services belong.
-      properties:
-        apiVersion:
-          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
-          type: string
-        kind:
-          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
-          type: string
-        metadata:
-          type: object
-        spec:
-          description: TODO
-          properties:
-            gateways:
-              properties:
-                egress:
-                  description: Gateway through which outbound federated service traffic will travel. This is not required if AllowDirectOutbound is set to true.
-                  properties:
-                    name:
-                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
-                      type: string
-                  type: object
-                ingress:
-                  description: Gateway through which inbound federated service traffic will travel.
-                  properties:
-                    name:
-                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
-                      type: string
-                  type: object
-              type: object
-            networkAddress:
-              description: 'NetworkAddress is the address used to communicate with the external mesh. Port 15443 will be used for service traffic and port 8188 will be used for service discovery. XXX: should this be an array?'
-              type: string
-            security:
-              properties:
-                allowDirectInbound:
-                  description: 'AllowDirectInbound determines whether or not external service invocations will be terminated at the ingress gateway. XXX: should this also be configurable per exported service?'
-                  type: boolean
-                allowDirectOutbound:
-                  description: 'AllowDirectOutbound determines whether or not external service invocations will be proxied through and terminated at the egress gateway XXX: should this also be configurable per imported service?'
-                  type: boolean
-                certificateChain:
-                  description: 'Name of secret containing certificate chain to be used to validate the remote.  This is also used to validate certificates used by the remote services (both client and server certificates). XXX: maybe this is only used to initiate a connection, with the actual certs stored in the status field, as retrieved from the remote mesh, or maybe this identifies an endpoint used to retrieve a cert chain, a la jwks'
-                  type: string
-                clientID:
-                  description: ClientID of the remote mesh.  This is used to authenticate incoming requrests from the remote mesh's discovery client.
-                  type: string
-                trustDomain:
-                  description: TrustDomain of remote mesh.
-                  type: string
-              type: object
-          type: object
-        status:
-          description: TODO
-          properties:
-            conditions:
-              items:
-                properties:
-                  lastTransitionTime:
-                    description: Last time the condition transitioned from one status to another.
-                    format: date-time
-                    type: string
-                  message:
-                    description: Human-readable message indicating details about the last transition.
-                    type: string
-                  reason:
-                    description: Unique, single-word, CamelCase reason for the condition's last transition.
-                    type: string
-                  status:
-                    description: The status of this condition. Can be True, False or Unknown.
-                    type: string
-                  type:
-                    description: The type of this condition.
-                    type: string
-                type: object
-              type: array
-          type: object
-      type: object
-  version: v1alpha1
-  versions:
-  - name: v1alpha1
-    served: true
-    storage: true
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_serviceimports.yaml b/manifests/charts/base/crds/maistra.io_serviceimports.yaml
deleted file mode 100644
index 1164af4283..0000000000
--- a/manifests/charts/base/crds/maistra.io_serviceimports.yaml
+++ /dev/null
@@ -1,87 +0,0 @@
-
-apiVersion: apiextensions.k8s.io/v1beta1
-kind: CustomResourceDefinition
-metadata:
-  annotations:
-    controller-gen.kubebuilder.io/version: (devel)
-  creationTimestamp: null
-  name: serviceimports.maistra.io
-spec:
-  group: maistra.io
-  names:
-    kind: ServiceImports
-    listKind: ServiceImportsList
-    plural: serviceimports
-    singular: serviceimports
-  preserveUnknownFields: false
-  scope: Namespaced
-  subresources:
-    status: {}
-  validation:
-    openAPIV3Schema:
-      description: ServiceImports is the Schema for configuring imported services.  The name of the ServiceImports resource must match the name of a MeshFederation resource defining the remote mesh from which the services will be imported.
-      properties:
-        apiVersion:
-          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
-          type: string
-        kind:
-          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
-          type: string
-        metadata:
-          type: object
-        spec:
-          description: Spec defines rules for matching services to be imported.
-          properties:
-            domainSuffix:
-              description: 'DomainSuffix specifies the domain suffix to be applies to imported services.  If no domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.svc.<mesh-name>-imports.local If a domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.<domain-suffix>'
-              type: string
-            imports:
-              description: Imports are the rules that determine which services are imported to the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
-              items:
-                properties:
-                  domainSuffix:
-                    description: DomainSuffix applies the specified suffix to services imported by this rule.  The behavior is identical to that of ServiceImportsSpec.DomainSuffix.
-                    type: string
-                  importAsLocal:
-                    description: ImportAsLocal imports the service as a local service in the mesh.  For example, if an exported service, foo/bar is imported as some-ns/service, the service will be imported as service.some-ns.svc.cluster.local in the some-ns namespace.  If a service of this name already exists in the mesh, the imported service's endpoints will be aggregated with any other workloads associated with the service.  This setting overrides DomainSuffix.
-                    type: boolean
-                  nameSelector:
-                    description: NameSelector provides a simple name matcher for importing services in the mesh.
-                    properties:
-                      alias:
-                        properties:
-                          name:
-                            type: string
-                          namespace:
-                            type: string
-                        type: object
-                      name:
-                        properties:
-                          name:
-                            type: string
-                          namespace:
-                            type: string
-                        type: object
-                    type: object
-                  type:
-                    description: Type of rule.  Only Name type is supported.
-                    type: string
-                required:
-                - type
-                type: object
-              type: array
-          type: object
-        status:
-          type: object
-      type: object
-  version: v1alpha1
-  versions:
-  - name: v1alpha1
-    served: true
-    storage: true
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
diff --git a/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml b/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
index e64c48d1d2..7f4de0c952 100644
--- a/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
+++ b/manifests/charts/base/crds/maistra.io_servicemeshextensions.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1beta1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: (devel)
+    controller-gen.kubebuilder.io/version: v0.4.1
   creationTimestamp: null
   name: servicemeshextensions.maistra.io
 spec:
diff --git a/manifests/charts/base/files/gen-istio-cluster.yaml b/manifests/charts/base/files/gen-istio-cluster.yaml
index c5af337d4e..69281d8404 100644
--- a/manifests/charts/base/files/gen-istio-cluster.yaml
+++ b/manifests/charts/base/files/gen-istio-cluster.yaml
@@ -5994,342 +5994,30 @@ spec:
 ---
 
 ---
-# Source: crds/maistra.io_federationstatuses.yaml
-
-apiVersion: apiextensions.k8s.io/v1beta1
-kind: CustomResourceDefinition
-metadata:
-  annotations:
-    controller-gen.kubebuilder.io/version: (devel)
-  creationTimestamp: null
-  name: federationstatuses.maistra.io
-spec:
-  group: maistra.io
-  names:
-    categories:
-    - maistra-io
-    kind: FederationStatus
-    listKind: FederationStatusList
-    plural: federationstatuses
-    singular: federationstatus
-  preserveUnknownFields: false
-  scope: Namespaced
-  subresources:
-    status: {}
-  validation:
-    openAPIV3Schema:
-      description: FederationStatus is the Schema for reporting the status of a MeshFederation. The name of the FederationStatus will match the name of the istiod pod to which it is associated.  There will be one FederationStatus resource for each istiod pod.
-      properties:
-        apiVersion:
-          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
-          type: string
-        kind:
-          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
-          type: string
-        metadata:
-          type: object
-        spec:
-          description: Spec is unused
-          type: object
-        status:
-          description: Status of the mesh federations
-          properties:
-            meshes:
-              description: Meshes represents the status of each federated mesh.  The key represents the name of the MeshFederation resource configuring federation for with a remote mesh (as namespace/name).
-              items:
-                description: FederationStatusDetails provides details about a particular federated mesh.
-                properties:
-                  discovery:
-                    description: Discovery provides details about the connection to the remote mesh.
-                    properties:
-                      remotes:
-                        description: Remotes represents details related to the inbound connections remote meshes.
-                        items:
-                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
-                          properties:
-                            connected:
-                              description: Connected identfies an active connection with the remote mesh.
-                              type: boolean
-                            lastConnected:
-                              description: LastConnected represents the last time a connection with the remote mesh was successful.
-                              format: date-time
-                              type: string
-                            lastDisconnect:
-                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
-                              format: date-time
-                              type: string
-                            lastDisconnectStatus:
-                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
-                              type: string
-                            lastEvent:
-                              description: LastEvent represents the last time an event was received from the remote mesh.
-                              format: date-time
-                              type: string
-                            lastFullSync:
-                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
-                              format: date-time
-                              type: string
-                            source:
-                              description: Source represents the source of the remote watch.
-                              type: string
-                          required:
-                          - connected
-                          - source
-                          type: object
-                        type: array
-                      watch:
-                        description: Watch represents details related to the outbound connection to the remote mesh.
-                        properties:
-                          connected:
-                            description: Connected identfies an active connection with the remote mesh.
-                            type: boolean
-                          lastConnected:
-                            description: LastConnected represents the last time a connection with the remote mesh was successful.
-                            format: date-time
-                            type: string
-                          lastDisconnect:
-                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
-                            format: date-time
-                            type: string
-                          lastDisconnectStatus:
-                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
-                            type: string
-                          lastEvent:
-                            description: LastEvent represents the last time an event was received from the remote mesh.
-                            format: date-time
-                            type: string
-                          lastFullSync:
-                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
-                            format: date-time
-                            type: string
-                        required:
-                        - connected
-                        type: object
-                    type: object
-                  exports:
-                    description: Exports provides details about the services exported by this mesh.
-                    items:
-                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
-                      properties:
-                        exportedName:
-                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
-                          type: string
-                        localService:
-                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
-                          properties:
-                            hostname:
-                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
-                              type: string
-                            name:
-                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
-                              type: string
-                            namespace:
-                              description: Namespace represents the namespace within which the service resides.
-                              type: string
-                          required:
-                          - hostname
-                          - name
-                          - namespace
-                          type: object
-                      required:
-                      - exportedName
-                      - localService
-                      type: object
-                    type: array
-                  imports:
-                    description: Imports provides details about the services imported by this mesh.
-                    items:
-                      description: MeshServiceMapping represents the name mapping between an exported service and its local counterpart.
-                      properties:
-                        exportedName:
-                          description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
-                          type: string
-                        localService:
-                          description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
-                          properties:
-                            hostname:
-                              description: Hostname represents fully qualified domain name (FQDN) used to access the service.
-                              type: string
-                            name:
-                              description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
-                              type: string
-                            namespace:
-                              description: Namespace represents the namespace within which the service resides.
-                              type: string
-                          required:
-                          - hostname
-                          - name
-                          - namespace
-                          type: object
-                      required:
-                      - exportedName
-                      - localService
-                      type: object
-                    type: array
-                  mesh:
-                    description: Mesh is the mesh to which this status applies.  This maps to a MeshFederation resource.
-                    type: string
-                required:
-                - discovery
-                - exports
-                - imports
-                - mesh
-                type: object
-              nullable: true
-              type: array
-          type: object
-      type: object
-  version: v1alpha1
-  versions:
-  - name: v1alpha1
-    served: true
-    storage: true
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
+# Source: crds/federation.maistra.io_exportedservicesets.yaml
 
 ---
-# Source: crds/maistra.io_meshfederations.yaml
-
 apiVersion: apiextensions.k8s.io/v1beta1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: (devel)
+    controller-gen.kubebuilder.io/version: v0.4.1
   creationTimestamp: null
-  name: meshfederations.maistra.io
+  name: exportedservicesets.federation.maistra.io
 spec:
-  group: maistra.io
+  group: federation.maistra.io
   names:
-    categories:
-    - maistra-io
-    kind: MeshFederation
-    listKind: MeshFederationList
-    plural: meshfederations
-    singular: meshfederation
+    kind: ExportedServiceSet
+    listKind: ExportedServiceSetList
+    plural: exportedservicesets
+    singular: exportedserviceset
   preserveUnknownFields: false
   scope: Namespaced
   subresources:
     status: {}
   validation:
     openAPIV3Schema:
-      description: MeshFederation is the Schema for joining two meshes together.  The resource name will be used to identify the 'cluster' to which imported services belong.
-      properties:
-        apiVersion:
-          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
-          type: string
-        kind:
-          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
-          type: string
-        metadata:
-          type: object
-        spec:
-          description: TODO
-          properties:
-            gateways:
-              properties:
-                egress:
-                  description: Gateway through which outbound federated service traffic will travel. This is not required if AllowDirectOutbound is set to true.
-                  properties:
-                    name:
-                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
-                      type: string
-                  type: object
-                ingress:
-                  description: Gateway through which inbound federated service traffic will travel.
-                  properties:
-                    name:
-                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
-                      type: string
-                  type: object
-              type: object
-            networkAddress:
-              description: 'NetworkAddress is the address used to communicate with the external mesh. Port 15443 will be used for service traffic and port 8188 will be used for service discovery. XXX: should this be an array?'
-              type: string
-            security:
-              properties:
-                allowDirectInbound:
-                  description: 'AllowDirectInbound determines whether or not external service invocations will be terminated at the ingress gateway. XXX: should this also be configurable per exported service?'
-                  type: boolean
-                allowDirectOutbound:
-                  description: 'AllowDirectOutbound determines whether or not external service invocations will be proxied through and terminated at the egress gateway XXX: should this also be configurable per imported service?'
-                  type: boolean
-                certificateChain:
-                  description: 'Name of secret containing certificate chain to be used to validate the remote.  This is also used to validate certificates used by the remote services (both client and server certificates). XXX: maybe this is only used to initiate a connection, with the actual certs stored in the status field, as retrieved from the remote mesh, or maybe this identifies an endpoint used to retrieve a cert chain, a la jwks'
-                  type: string
-                clientID:
-                  description: ClientID of the remote mesh.  This is used to authenticate incoming requrests from the remote mesh's discovery client.
-                  type: string
-                trustDomain:
-                  description: TrustDomain of remote mesh.
-                  type: string
-              type: object
-          type: object
-        status:
-          description: TODO
-          properties:
-            conditions:
-              items:
-                properties:
-                  lastTransitionTime:
-                    description: Last time the condition transitioned from one status to another.
-                    format: date-time
-                    type: string
-                  message:
-                    description: Human-readable message indicating details about the last transition.
-                    type: string
-                  reason:
-                    description: Unique, single-word, CamelCase reason for the condition's last transition.
-                    type: string
-                  status:
-                    description: The status of this condition. Can be True, False or Unknown.
-                    type: string
-                  type:
-                    description: The type of this condition.
-                    type: string
-                type: object
-              type: array
-          type: object
-      type: object
-  version: v1alpha1
-  versions:
-  - name: v1alpha1
-    served: true
-    storage: true
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
-
----
-# Source: crds/maistra.io_serviceexports.yaml
-
-apiVersion: apiextensions.k8s.io/v1beta1
-kind: CustomResourceDefinition
-metadata:
-  annotations:
-    controller-gen.kubebuilder.io/version: (devel)
-  creationTimestamp: null
-  name: serviceexports.maistra.io
-spec:
-  group: maistra.io
-  names:
-    kind: ServiceExports
-    listKind: ServiceExportsList
-    plural: serviceexports
-    singular: serviceexports
-  preserveUnknownFields: false
-  scope: Namespaced
-  subresources:
-    status: {}
-  validation:
-    openAPIV3Schema:
-      description: ServiceExport is the Schema for configuring exported services.  The name of the ServiceExports resource must match the name of a MeshFederation resource defining the remote mesh to which the services will be exported.
+      description: ExportedServiceSet is the Schema for configuring exported services.  The name of the ExportedServiceSet resource must match the name of a ServiceMeshPeer resource defining the remote mesh to which the services will be exported.
       properties:
         apiVersion:
           description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
@@ -6342,8 +6030,8 @@ spec:
         spec:
           description: Spec defines rules for matching services to be exported.
           properties:
-            exports:
-              description: Exports are the rules that determine which services are exported from the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
+            exportRules:
+              description: ExportRules are the rules that determine which services are exported from the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
               items:
                 properties:
                   labelSelector:
@@ -6361,12 +6049,9 @@ spec:
                                   type: string
                               type: object
                             name:
-                              properties:
-                                name:
-                                  type: string
-                                namespace:
-                                  type: string
-                              type: object
+                              type: string
+                            namespace:
+                              type: string
                           type: object
                         type: array
                       namespace:
@@ -6414,12 +6099,9 @@ spec:
                             type: string
                         type: object
                       name:
-                        properties:
-                          name:
-                            type: string
-                          namespace:
-                            type: string
-                        type: object
+                        type: string
+                      namespace:
+                        type: string
                     type: object
                   type:
                     description: Type of rule.  One of Name or Label.
@@ -6430,11 +6112,47 @@ spec:
               type: array
           type: object
         status:
+          properties:
+            exportedServices:
+              description: Exports provides details about the services exported by this mesh.
+              items:
+                description: PeerServiceMapping represents the name mapping between an exported service and its local counterpart.
+                properties:
+                  exportedName:
+                    description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                    type: string
+                  localService:
+                    description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                    properties:
+                      hostname:
+                        description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                        type: string
+                      name:
+                        description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                        type: string
+                      namespace:
+                        description: Namespace represents the namespace within which the service resides.
+                        type: string
+                    required:
+                    - hostname
+                    - name
+                    - namespace
+                    type: object
+                required:
+                - exportedName
+                - localService
+                type: object
+              type: array
+              x-kubernetes-list-map-keys:
+              - exportedName
+              x-kubernetes-list-type: map
+          required:
+          - exportedServices
           type: object
       type: object
-  version: v1alpha1
+  version: v1
   versions:
-  - name: v1alpha1
+  - name: v1
     served: true
     storage: true
 status:
@@ -6445,29 +6163,30 @@ status:
   storedVersions: []
 
 ---
-# Source: crds/maistra.io_serviceimports.yaml
+# Source: crds/federation.maistra.io_importedservicesets.yaml
 
+---
 apiVersion: apiextensions.k8s.io/v1beta1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: (devel)
+    controller-gen.kubebuilder.io/version: v0.4.1
   creationTimestamp: null
-  name: serviceimports.maistra.io
+  name: importedservicesets.federation.maistra.io
 spec:
-  group: maistra.io
+  group: federation.maistra.io
   names:
-    kind: ServiceImports
-    listKind: ServiceImportsList
-    plural: serviceimports
-    singular: serviceimports
+    kind: ImportedServiceSet
+    listKind: ImportedServiceSetList
+    plural: importedservicesets
+    singular: importedserviceset
   preserveUnknownFields: false
   scope: Namespaced
   subresources:
     status: {}
   validation:
     openAPIV3Schema:
-      description: ServiceImports is the Schema for configuring imported services.  The name of the ServiceImports resource must match the name of a MeshFederation resource defining the remote mesh from which the services will be imported.
+      description: ImportedServiceSet is the Schema for configuring imported services.  The name of the ImportedServiceSet resource must match the name of a ServiceMeshPeer resource defining the remote mesh from which the services will be imported.
       properties:
         apiVersion:
           description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
@@ -6483,12 +6202,12 @@ spec:
             domainSuffix:
               description: 'DomainSuffix specifies the domain suffix to be applies to imported services.  If no domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.svc.<mesh-name>-imports.local If a domain suffix is specified, imported services will be named as follows:    <imported-name>.<imported-namespace>.<domain-suffix>'
               type: string
-            imports:
-              description: Imports are the rules that determine which services are imported to the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
+            importRules:
+              description: ImportRules are the rules that determine which services are imported to the mesh.  The list is processed in order and the first spec in the list that applies to a service is the one that will be applied.  This allows more specific selectors to be placed before more general selectors.
               items:
                 properties:
                   domainSuffix:
-                    description: DomainSuffix applies the specified suffix to services imported by this rule.  The behavior is identical to that of ServiceImportsSpec.DomainSuffix.
+                    description: DomainSuffix applies the specified suffix to services imported by this rule.  The behavior is identical to that of ImportedServiceSetSpec.DomainSuffix.
                     type: string
                   importAsLocal:
                     description: ImportAsLocal imports the service as a local service in the mesh.  For example, if an exported service, foo/bar is imported as some-ns/service, the service will be imported as service.some-ns.svc.cluster.local in the some-ns namespace.  If a service of this name already exists in the mesh, the imported service's endpoints will be aggregated with any other workloads associated with the service.  This setting overrides DomainSuffix.
@@ -6504,12 +6223,9 @@ spec:
                             type: string
                         type: object
                       name:
-                        properties:
-                          name:
-                            type: string
-                          namespace:
-                            type: string
-                        type: object
+                        type: string
+                      namespace:
+                        type: string
                     type: object
                   type:
                     description: Type of rule.  Only Name type is supported.
@@ -6518,13 +6234,348 @@ spec:
                 - type
                 type: object
               type: array
+            locality:
+              description: Locality within which imported services should be associated.
+              properties:
+                region:
+                  description: Region within which imported services are located.
+                  type: string
+                subzone:
+                  description: Subzone within which imported services are located.  If Subzone is specified, Zone must also be specified.
+                  type: string
+                zone:
+                  description: Zone within which imported services are located.  If Zone is specified, Region must also be specified.
+                  type: string
+              type: object
           type: object
         status:
+          properties:
+            importedServices:
+              description: Imports provides details about the services imported by this mesh.
+              items:
+                description: PeerServiceMapping represents the name mapping between an exported service and its local counterpart.
+                properties:
+                  exportedName:
+                    description: ExportedName represents the fully qualified domain name (FQDN) of an exported service.  For an exporting mesh, this is the name that is exported to the remote mesh. For an importing mesh, this would be the name of the service exported by the remote mesh.
+                    type: string
+                  localService:
+                    description: LocalService represents the service in the local (i.e. this) mesh. For an exporting mesh, this would be the service being exported. For an importing mesh, this would be the imported service.
+                    properties:
+                      hostname:
+                        description: Hostname represents fully qualified domain name (FQDN) used to access the service.
+                        type: string
+                      name:
+                        description: Name represents the simple name of the service, e.g. the metadata.name field of a kubernetes Service.
+                        type: string
+                      namespace:
+                        description: Namespace represents the namespace within which the service resides.
+                        type: string
+                    required:
+                    - hostname
+                    - name
+                    - namespace
+                    type: object
+                required:
+                - exportedName
+                - localService
+                type: object
+              type: array
+              x-kubernetes-list-map-keys:
+              - exportedName
+              x-kubernetes-list-type: map
+          required:
+          - importedServices
           type: object
       type: object
-  version: v1alpha1
+  version: v1
   versions:
-  - name: v1alpha1
+  - name: v1
+    served: true
+    storage: true
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
+
+---
+# Source: crds/federation.maistra.io_servicemeshpeers.yaml
+
+---
+apiVersion: apiextensions.k8s.io/v1beta1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.4.1
+  creationTimestamp: null
+  name: servicemeshpeers.federation.maistra.io
+spec:
+  group: federation.maistra.io
+  names:
+    categories:
+    - maistra-io
+    kind: ServiceMeshPeer
+    listKind: ServiceMeshPeerList
+    plural: servicemeshpeers
+    singular: servicemeshpeer
+  preserveUnknownFields: false
+  scope: Namespaced
+  subresources:
+    status: {}
+  validation:
+    openAPIV3Schema:
+      description: ServiceMeshPeer is the Schema for joining two meshes together.  The resource name will be used to identify the 'cluster' to which imported services belong.
+      properties:
+        apiVersion:
+          description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+          type: string
+        kind:
+          description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+          type: string
+        metadata:
+          type: object
+        spec:
+          description: ServiceMeshPeerSpec configures details required to support federation with another service mesh.
+          properties:
+            gateways:
+              description: Gateways configures the gateways used to facilitate ingress and egress with the other mesh.
+              properties:
+                egress:
+                  description: Gateway through which outbound federated service traffic will travel. This is not required if AllowDirectOutbound is set to true.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+                ingress:
+                  description: Gateway through which inbound federated service traffic will travel.
+                  properties:
+                    name:
+                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?'
+                      type: string
+                  type: object
+              type: object
+            remote:
+              description: Remote configures details related to the remote mesh with which this mesh is federating.
+              properties:
+                addresses:
+                  description: Addresses are the addresses to which discovery and service requests should be sent (i.e. the addresses of ingress gateways on the remote mesh).  These may be specified as resolveable DNS names or IP addresses.
+                  items:
+                    type: string
+                  type: array
+                discoveryPort:
+                  description: DiscoveryPort is the port on which the addresses are handling discovery requests.  Defaults to 8188, if unspecified.
+                  format: int32
+                  type: integer
+                servicePort:
+                  description: ServicePort is the port on which the addresses are handling service requests.  Defaults to 15443, if unspecified.
+                  format: int32
+                  type: integer
+              type: object
+            security:
+              description: Security configures details for securing communication with the other mesh.
+              properties:
+                certificateChain:
+                  description: Name of ConfigMap containing certificate chain to be used to validate the remote.  This is also used to validate certificates used by the remote services (both client and server certificates).  The name of the entry should be root-cert.pem.  If unspecified, it will look for a ConfigMap named <meshfederation-name>-ca-root-cert, e.g. if this resource is named mesh1, it will look for a ConfigMap named mesh1-ca-root-cert.
+                  properties:
+                    apiGroup:
+                      description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
+                      type: string
+                    kind:
+                      description: Kind is the type of resource being referenced
+                      type: string
+                    name:
+                      description: Name is the name of resource being referenced
+                      type: string
+                  required:
+                  - kind
+                  - name
+                  type: object
+                clientID:
+                  description: ClientID of the remote mesh.  This is used to authenticate incoming requrests from the remote mesh's discovery client.
+                  type: string
+                trustDomain:
+                  description: TrustDomain of remote mesh.
+                  type: string
+              type: object
+          type: object
+        status:
+          description: ServiceMeshPeerStatus provides information related to the other mesh.
+          properties:
+            discoveryStatus:
+              description: DiscoveryStatus represents the discovery status of each pilot/istiod pod in the mesh.
+              properties:
+                active:
+                  description: Active represents the pilot/istiod pods actively watching the other mesh for discovery.
+                  items:
+                    description: PodPeerDiscoveryStatus provides discovery details related to a specific pilot/istiod pod.
+                    properties:
+                      pod:
+                        description: Pod is the pod name to which these details apply.  This maps to a a pilot/istiod pod.
+                        type: string
+                      remotes:
+                        description: Remotes represents details related to the inbound connections from remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                        x-kubernetes-list-map-keys:
+                        - source
+                        x-kubernetes-list-type: map
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    required:
+                    - pod
+                    type: object
+                  nullable: true
+                  type: array
+                  x-kubernetes-list-map-keys:
+                  - pod
+                  x-kubernetes-list-type: map
+                inactive:
+                  description: Inactive represents the pilot/istiod pods not actively watching the other mesh for discovery.
+                  items:
+                    description: PodPeerDiscoveryStatus provides discovery details related to a specific pilot/istiod pod.
+                    properties:
+                      pod:
+                        description: Pod is the pod name to which these details apply.  This maps to a a pilot/istiod pod.
+                        type: string
+                      remotes:
+                        description: Remotes represents details related to the inbound connections from remote meshes.
+                        items:
+                          description: DiscoveryRemoteStatus represents details related to an inbound connection from a remote mesh.
+                          properties:
+                            connected:
+                              description: Connected identfies an active connection with the remote mesh.
+                              type: boolean
+                            lastConnected:
+                              description: LastConnected represents the last time a connection with the remote mesh was successful.
+                              format: date-time
+                              type: string
+                            lastDisconnect:
+                              description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                              format: date-time
+                              type: string
+                            lastDisconnectStatus:
+                              description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                              type: string
+                            lastEvent:
+                              description: LastEvent represents the last time an event was received from the remote mesh.
+                              format: date-time
+                              type: string
+                            lastFullSync:
+                              description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                              format: date-time
+                              type: string
+                            source:
+                              description: Source represents the source of the remote watch.
+                              type: string
+                          required:
+                          - connected
+                          - source
+                          type: object
+                        type: array
+                        x-kubernetes-list-map-keys:
+                        - source
+                        x-kubernetes-list-type: map
+                      watch:
+                        description: Watch represents details related to the outbound connection to the remote mesh.
+                        properties:
+                          connected:
+                            description: Connected identfies an active connection with the remote mesh.
+                            type: boolean
+                          lastConnected:
+                            description: LastConnected represents the last time a connection with the remote mesh was successful.
+                            format: date-time
+                            type: string
+                          lastDisconnect:
+                            description: LastDisconnect represents the last time the connection with the remote mesh was disconnected.
+                            format: date-time
+                            type: string
+                          lastDisconnectStatus:
+                            description: LastDisconnectStatus is the status returned the last time the connection with the remote mesh was terminated.
+                            type: string
+                          lastEvent:
+                            description: LastEvent represents the last time an event was received from the remote mesh.
+                            format: date-time
+                            type: string
+                          lastFullSync:
+                            description: LastFullSync represents the last time a full sync was performed with the remote mesh.
+                            format: date-time
+                            type: string
+                        required:
+                        - connected
+                        type: object
+                    required:
+                    - pod
+                    type: object
+                  nullable: true
+                  type: array
+                  x-kubernetes-list-map-keys:
+                  - pod
+                  x-kubernetes-list-type: map
+              type: object
+          type: object
+      type: object
+  version: v1
+  versions:
+  - name: v1
     served: true
     storage: true
 status:
@@ -6541,7 +6592,7 @@ apiVersion: apiextensions.k8s.io/v1beta1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: (devel)
+    controller-gen.kubebuilder.io/version: v0.4.1
   creationTimestamp: null
   name: servicemeshextensions.maistra.io
 spec:
@@ -6980,12 +7031,9 @@ rules:
   verbs: ["create", "get", "watch", "list", "update", "delete"]
 
 # For MeshFederation support
-- apiGroups: ["maistra.io"]
-  resources: ["meshfederations", "meshfederations/status", "federationstatuses", "federationstatuses/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
+- apiGroups: ["federation.maistra.io"]
+  resources: ["servicemeshpeers", "servicemeshpeers/status", "exportedservicesets", "exportedservicesets/status", "importedservicesets", "importedservicesets/status"]
   verbs: ["get", "list", "watch", "patch", "update"]
-- apiGroups: ["maistra.io"]
-  resources: ["federationstatuses", "federationstatuses/status"]
-  verbs: ["create"]
 ---
 # Source: base/templates/rolebinding.yaml
 # -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
diff --git a/manifests/charts/base/templates/role.yaml b/manifests/charts/base/templates/role.yaml
index 06c93712aa..3b3376bba6 100644
--- a/manifests/charts/base/templates/role.yaml
+++ b/manifests/charts/base/templates/role.yaml
@@ -25,9 +25,6 @@ rules:
   verbs: ["create", "get", "watch", "list", "update", "delete"]
 
 # For MeshFederation support
-- apiGroups: ["maistra.io"]
-  resources: ["meshfederations", "meshfederations/status", "federationstatuses", "federationstatuses/status", "serviceexports", "serviceexports/status", "serviceimports", "serviceimports/status"]
+- apiGroups: ["federation.maistra.io"]
+  resources: ["servicemeshpeers", "servicemeshpeers/status", "exportedservicesets", "exportedservicesets/status", "importedservicesets", "importedservicesets/status"]
   verbs: ["get", "list", "watch", "patch", "update"]
-- apiGroups: ["maistra.io"]
-  resources: ["federationstatuses", "federationstatuses/status"]
-  verbs: ["create"]
diff --git a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
index 562c7a3a52..dcf8d02c34 100644
--- a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
+++ b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
@@ -1745,6 +1745,28 @@ spec:
 # Removed paths for legacy and default selectors since a revision tag
 # is inherently created from a specific revision
 ---
+# Source: istiod/templates/federation.yaml
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: istiod
+  namespace: istio-system
+  labels:
+    istio.io/rev: default
+    install.operator.istio.io/owning-resource: unknown
+    operator.istio.io/component: "Pilot"
+    app: istiod
+    istio: pilot
+    release: istio
+spec:
+  host: istiod.istio-system.svc.cluster.local
+  trafficPolicy:
+    portLevelSettings:
+    - port:
+        number: 8188
+      tls:
+        mode: SIMPLE
+---
 # Source: istiod/templates/telemetryv2_1.10.yaml
 # Note: http stats filter is wasm enabled only in sidecars.
 apiVersion: networking.istio.io/v1alpha3
diff --git a/manifests/charts/istio-control/istio-discovery/templates/federation.yaml b/manifests/charts/istio-control/istio-discovery/templates/federation.yaml
new file mode 100644
index 0000000000..ed7ed59aa8
--- /dev/null
+++ b/manifests/charts/istio-control/istio-discovery/templates/federation.yaml
@@ -0,0 +1,21 @@
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: istiod{{- if not (eq .Values.revision "") }}-{{ .Values.revision }}{{- end }}
+  namespace: {{ .Release.Namespace }}
+  labels:
+    istio.io/rev: {{ .Values.revision | default "default" }}
+    install.operator.istio.io/owning-resource: {{ .Values.ownerName | default "unknown" }}
+    operator.istio.io/component: "Pilot"
+    app: istiod
+    istio: pilot
+    release: {{ .Release.Name }}
+spec:
+  host: istiod{{- if not (eq .Values.revision "") }}-{{ .Values.revision }}{{- end }}.{{ .Release.Namespace }}.svc.cluster.local
+  trafficPolicy:
+    portLevelSettings:
+    - port:
+        number: 8188
+      tls:
+        mode: SIMPLE
+---
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index fa564d86d2..7d1ea3ef06 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -73,7 +73,6 @@ import (
 	"istio.io/istio/pkg/security"
 	"istio.io/istio/pkg/servicemesh/controller/extension"
 	"istio.io/istio/pkg/servicemesh/federation"
-	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/spiffe"
 	"istio.io/istio/security/pkg/k8s/chiron"
 	"istio.io/istio/security/pkg/pki/ca"
@@ -273,27 +272,62 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 		return nil, err
 	}
 
+	// Parse and validate Istiod Address.
+	istiodHost, _, err := e.GetDiscoveryAddress()
+	if err != nil {
+		return nil, err
+	}
+
+	// Create Istiod certs and setup watches.
+	if err := s.initIstiodCerts(args, string(istiodHost)); err != nil {
+		return nil, err
+	}
+
 	// federation support must be initialized before config and service controllers
 	if features.EnableFederation {
 		if s.kubeClient == nil {
 			log.Errorf("could not initialize federation discovery server: kubeClient is nil")
 		} else {
-			var err error
-			s.federation, err = federation.New(federation.Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient:   s.kubeClient,
-					ResyncPeriod: args.RegistryOptions.KubeOptions.ResyncPeriod,
-					Namespace:    args.RegistryOptions.ClusterRegistriesNamespace,
+			peerCertVerifier, err := s.createPeerCertVerifier(args.ServerOptions.TLSOptions)
+			if err != nil {
+				return nil, err
+			}
+			if peerCertVerifier == nil {
+				panic("No peerCertVerifier")
+			}
+			tlsCfg := &tls.Config{
+				GetCertificate: s.getIstiodCertificate,
+				ClientAuth:     tls.VerifyClientCertIfGiven,
+				ClientCAs:      peerCertVerifier.GetGeneralCertPool(),
+				VerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {
+					err := peerCertVerifier.VerifyPeerCert(rawCerts, verifiedChains)
+					if err != nil {
+						log.Infof("Could not verify certificate: %v", err)
+					}
+					return err
 				},
-				LocalClusterID:    s.clusterID.String(),
-				LocalNetwork:      features.NetworkName,
-				BindAddress:       args.ServerOptions.FederationAddr,
-				Env:               s.environment,
-				XDSUpdater:        s.XDSServer,
-				ServiceController: s.ServiceController(),
-				IstiodNamespace:   args.Namespace,
-				IstiodPodName:     args.PodName,
+				MinVersion:       tls_features.TLSMinProtocolVersion.GetGoTLSProtocolVersion(),
+				MaxVersion:       tls_features.TLSMaxProtocolVersion.GetGoTLSProtocolVersion(),
+				CipherSuites:     tls_features.TLSCipherSuites.GetGoTLSCipherSuites(),
+				CurvePreferences: tls_features.TLSECDHCurves.GetGoTLSECDHCurves(),
+			}
+
+			s.federation, err = federation.New(federation.Options{
+				KubeClient:          s.kubeClient,
+				ResyncPeriod:        args.RegistryOptions.KubeOptions.ResyncPeriod,
+				FederationNamespace: args.RegistryOptions.ClusterRegistriesNamespace,
+				LocalClusterID:      s.clusterID.String(),
+				LocalNetwork:        features.NetworkName,
+				BindAddress:         args.ServerOptions.FederationAddr,
+				Env:                 s.environment,
+				XDSUpdater:          s.XDSServer,
+				ServiceController:   s.ServiceController(),
+				IstiodNamespace:     args.Namespace,
+				IstiodPodName:       args.PodName,
+				TLSConfig:           tlsCfg,
 			})
+			s.XDSServer.Generators[v3.TrustBundleType] = &xds.TbdsGenerator{TrustBundleProvider: s.federation}
+
 			if err != nil {
 				return nil, fmt.Errorf("error initializing federation: %v", err)
 			}
@@ -318,17 +352,6 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 		return nil, err
 	}
 
-	// Parse and validate Istiod Address.
-	istiodHost, _, err := e.GetDiscoveryAddress()
-	if err != nil {
-		return nil, err
-	}
-
-	// Create Istiod certs and setup watches.
-	if err := s.initIstiodCerts(args, string(istiodHost)); err != nil {
-		return nil, err
-	}
-
 	// Secure gRPC Server must be initialized after CA is created as may use a Citadel generated cert.
 	if err := s.initSecureDiscoveryService(args); err != nil {
 		return nil, fmt.Errorf("error initializing secure gRPC Listener: %v", err)
diff --git a/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json b/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
index 0e9c9a49ce..f2bd858b38 100644
--- a/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
+++ b/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
@@ -13,4 +13,4 @@
       "NAMESPACE": "default"
     }
   }
-}
+}
\ No newline at end of file
diff --git a/pilot/pkg/serviceregistry/federation/controller.go b/pilot/pkg/serviceregistry/federation/controller.go
index 9849a3dcb9..d197b9834c 100644
--- a/pilot/pkg/serviceregistry/federation/controller.go
+++ b/pilot/pkg/serviceregistry/federation/controller.go
@@ -15,17 +15,21 @@
 package federation
 
 import (
+	"context"
 	"encoding/json"
 	"fmt"
+	"io"
 	"net"
 	"net/http"
+	"reflect"
 	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
 
 	"github.com/cenkalti/backoff"
-	"maistra.io/api/core/v1alpha1"
+	corev1 "k8s.io/api/core/v1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/api/label"
 	"istio.io/istio/pilot/pkg/model"
@@ -43,6 +47,7 @@ import (
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
 	"istio.io/istio/pkg/servicemesh/federation/status"
+	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/pkg/log"
 )
 
@@ -52,24 +57,21 @@ var (
 	_ serviceregistry.Instance = &Controller{}
 )
 
-const (
-	federationPort = common.FederationPort
-)
-
 // Controller aggregates data across different registries and monitors for changes
 type Controller struct {
-	networkAddress string
-	egressService  string
-	egressName     string
-	discoveryURL   string
-	useDirectCalls bool
-	namespace      string
-	localClusterID cluster.ID
-	localNetworkID network.ID
-	clusterID      cluster.ID
-	networkID      network.ID
-	resyncPeriod   time.Duration
-	backoffPolicy  *backoff.ExponentialBackOff
+	remote               v1.ServiceMeshPeerRemote
+	egressService        string
+	egressName           string
+	discoveryURL         string
+	discoveryServiceName string
+	useDirectCalls       bool
+	namespace            string
+	localClusterID       cluster.ID
+	localNetworkID       network.ID
+	clusterID            cluster.ID
+	networkID            network.ID
+	resyncPeriod         time.Duration
+	backoffPolicy        *backoff.ExponentialBackOff
 
 	logger *log.Scope
 
@@ -80,8 +82,10 @@ type Controller struct {
 
 	localDomainSuffix   string
 	defaultDomainSuffix string
-	defaultNameMapper   common.NameMapper
 	importNameMapper    common.NameMapper
+	defaultLocality     *v1.ImportedServiceLocality
+	importLocality      *v1.ImportedServiceLocality
+	locality            *v1.ImportedServiceLocality
 
 	storeLock      sync.RWMutex
 	imports        map[federationmodel.ServiceKey]*existingImport
@@ -92,7 +96,13 @@ type Controller struct {
 	egressSAs      []string
 
 	lastMessage *federationmodel.ServiceListMessage
-	stopped     int32
+	started     int32
+
+	cancelWatch context.CancelFunc
+	watchEvents chan *federationmodel.WatchEvent
+
+	peerConfigGeneration   int64
+	importConfigGeneration int64
 }
 
 type existingImport struct {
@@ -101,16 +111,11 @@ type existingImport struct {
 }
 
 type Options struct {
-	NetworkAddress string
-	EgressService  string
-	EgressName     string
-	UseDirectCalls bool
 	DomainSuffix   string
 	LocalClusterID string
 	LocalNetwork   string
 	ClusterID      string
 	Network        string
-	Namespace      string
 	KubeClient     kube.Client
 	StatusHandler  status.Handler
 	ConfigStore    model.ConfigStoreCache
@@ -118,7 +123,7 @@ type Options struct {
 	ResyncPeriod   time.Duration
 }
 
-func defaultDomainSuffixForMesh(mesh *v1alpha1.MeshFederation) string {
+func defaultDomainSuffixForMesh(mesh *v1.ServiceMeshPeer) string {
 	return fmt.Sprintf("svc.%s-imports.local", mesh.Name)
 }
 
@@ -129,57 +134,131 @@ func localDomainSuffix(domainSuffix string) string {
 	return "svc." + domainSuffix
 }
 
+func mergeLocality(locality *v1.ImportedServiceLocality, defaults *v1.ImportedServiceLocality) *v1.ImportedServiceLocality {
+	merged := v1.ImportedServiceLocality{}
+	if defaults == nil {
+		defaults = &v1.ImportedServiceLocality{}
+		if locality == nil {
+			return nil
+		}
+	} else if locality != nil {
+		merged = *locality
+	}
+	if merged.Subzone == "" && defaults.Subzone != "" {
+		merged.Subzone = defaults.Subzone
+	}
+	if merged.Zone == "" && defaults.Zone != "" {
+		merged.Zone = defaults.Zone
+	}
+	if merged.Region == "" && defaults.Region != "" {
+		merged.Region = defaults.Region
+	}
+	if merged.Subzone != "" && (merged.Zone == "" || merged.Region == "") {
+		// cannot have subzone specified without region and zone
+		return nil
+	} else if merged.Zone != "" && merged.Region == "" {
+		// cannot have zone specified without region
+		return nil
+	}
+	return &merged
+}
+
 // NewController creates a new Aggregate controller
-func NewController(opt Options, mesh *v1alpha1.MeshFederation, defaultImportConfig, importConfig *v1alpha1.ServiceImports) *Controller {
+func NewController(opt Options, mesh *v1.ServiceMeshPeer, importConfig *v1.ImportedServiceSet) *Controller {
 	backoffPolicy := backoff.NewExponentialBackOff()
 	backoffPolicy.MaxElapsedTime = 0
 	localDomainSuffix := localDomainSuffix(opt.DomainSuffix)
-	defaultDomainSuffix := defaultDomainSuffixForMesh(mesh)
-	defaultNameMapper := common.NewServiceImporter(defaultImportConfig, nil, defaultDomainSuffix, localDomainSuffix)
-	return &Controller{
-		discoveryURL:        fmt.Sprintf("%s://%s:%d", common.DiscoveryScheme, opt.EgressService, common.DefaultDiscoveryPort),
-		egressService:       opt.EgressService,
-		egressName:          opt.EgressName,
-		networkAddress:      opt.NetworkAddress,
-		useDirectCalls:      opt.UseDirectCalls,
-		namespace:           opt.Namespace,
-		localClusterID:      cluster.ID(opt.LocalClusterID),
-		localNetworkID:      network.ID(opt.LocalNetwork),
-		clusterID:           cluster.ID(opt.ClusterID),
-		networkID:           network.ID(opt.Network),
-		localDomainSuffix:   localDomainSuffix,
-		defaultDomainSuffix: defaultDomainSuffix,
-		defaultNameMapper:   defaultNameMapper,
-		importNameMapper:    common.NewServiceImporter(importConfig, defaultNameMapper, defaultDomainSuffix, localDomainSuffix),
-		imports:             map[federationmodel.ServiceKey]*existingImport{},
-		serviceStore:        map[host.Name]*model.Service{},
-		instanceStore:       map[host.Name][]*model.ServiceInstance{},
-		kubeClient:          opt.KubeClient,
-		statusHandler:       opt.StatusHandler,
-		configStore:         opt.ConfigStore,
-		xdsUpdater:          opt.XDSUpdater,
-		resyncPeriod:        opt.ResyncPeriod,
-		backoffPolicy:       backoffPolicy,
-		logger:              common.Logger.WithLabels("component", "federation-registry"),
-	}
-}
-
-func (c *Controller) UpdateImportConfig(importConfig *v1alpha1.ServiceImports) {
-	func() {
+	c := &Controller{
+		localClusterID:    cluster.ID(opt.LocalClusterID),
+		localNetworkID:    network.ID(opt.LocalNetwork),
+		clusterID:         cluster.ID(opt.ClusterID),
+		networkID:         network.ID(opt.Network),
+		localDomainSuffix: localDomainSuffix,
+		imports:           map[federationmodel.ServiceKey]*existingImport{},
+		serviceStore:      map[host.Name]*model.Service{},
+		instanceStore:     map[host.Name][]*model.ServiceInstance{},
+		kubeClient:        opt.KubeClient,
+		statusHandler:     opt.StatusHandler,
+		configStore:       opt.ConfigStore,
+		xdsUpdater:        opt.XDSUpdater,
+		resyncPeriod:      opt.ResyncPeriod,
+		backoffPolicy:     backoffPolicy,
+		logger:            common.Logger.WithLabels("component", "federation-registry"),
+		watchEvents:       make(chan *federationmodel.WatchEvent),
+	}
+	c.UpdatePeerConfig(mesh)
+	c.UpdateImportConfig(importConfig)
+	return c
+}
+
+// UpdatePeerConfig updates all settings derived from the ServiceMeshPeer resource.
+// It will also restart the watch if the controller is already running.
+func (c *Controller) UpdatePeerConfig(peerConfig *v1.ServiceMeshPeer) {
+	if func() bool {
+		c.storeLock.RLock()
+		defer c.storeLock.RUnlock()
+		return c.peerConfigGeneration == peerConfig.Generation
+	}() {
+		return
+	}
+
+	restartWatch := func() bool {
 		c.storeLock.Lock()
 		defer c.storeLock.Unlock()
-		c.importNameMapper = common.NewServiceImporter(importConfig, c.defaultNameMapper, c.defaultDomainSuffix, c.localDomainSuffix)
+
+		restartWatch := false
+
+		c.discoveryServiceName = common.DiscoveryServiceHostname(peerConfig)
+		c.defaultDomainSuffix = defaultDomainSuffixForMesh(peerConfig)
+		c.namespace = peerConfig.Namespace
+		c.useDirectCalls = peerConfig.Spec.Security.AllowDirectOutbound
+		if c.egressName != peerConfig.Spec.Gateways.Egress.Name {
+			c.egressName = peerConfig.Spec.Gateways.Egress.Name
+			c.egressService = fmt.Sprintf("%s.%s.%s",
+				peerConfig.Spec.Gateways.Egress.Name, c.namespace, c.localDomainSuffix)
+			c.discoveryURL = fmt.Sprintf("%s://%s:%d", common.DiscoveryScheme, c.egressService, common.DefaultDiscoveryPort)
+			restartWatch = true
+		}
+
+		if !reflect.DeepEqual(c.remote, peerConfig.Spec.Remote) {
+			c.remote = peerConfig.Spec.Remote
+			restartWatch = true
+		}
+
+		c.peerConfigGeneration = peerConfig.Generation
+
+		return restartWatch
 	}()
-	c.resync()
+	if c.hasStarted() && restartWatch {
+		c.RestartWatch()
+	}
 }
 
-func (c *Controller) UpdateDefaultImportConfig(importConfig *v1alpha1.ServiceImports) {
+// UpdateImportConfig updates the import rules that are used to select services for
+// import into the mesh and rewrite their names.
+func (c *Controller) UpdateImportConfig(importConfig *v1.ImportedServiceSet) {
+	if func() bool {
+		if importConfig == nil {
+			return false
+		}
+		c.storeLock.RLock()
+		defer c.storeLock.RUnlock()
+		return c.importConfigGeneration == importConfig.Generation
+	}() {
+		return
+	}
 	func() {
 		c.storeLock.Lock()
 		defer c.storeLock.Unlock()
-		c.importNameMapper.UpdateDefaultMapper(common.NewServiceImporter(importConfig, nil, c.defaultDomainSuffix, c.localDomainSuffix))
+		c.importNameMapper = common.NewServiceImporter(importConfig, nil, c.defaultDomainSuffix, c.localDomainSuffix)
+		if importConfig == nil {
+			c.importLocality = nil
+		} else {
+			c.importLocality = importConfig.Spec.Locality
+			c.importConfigGeneration = importConfig.Generation
+		}
+		c.locality = mergeLocality(c.importLocality, c.defaultLocality)
 	}()
-	c.resync()
 }
 
 func (c *Controller) Cluster() cluster.ID {
@@ -190,42 +269,34 @@ func (c *Controller) Provider() provider.ID {
 	return provider.Federation
 }
 
-func (c *Controller) NetworkAddress() string {
-	return c.networkAddress
-}
-
-func (c *Controller) pollServices() *federationmodel.ServiceListMessage {
-	url := c.discoveryURL + "/services/"
+func (c *Controller) pollServices() (*federationmodel.ServiceListMessage, error) {
+	url := c.discoveryURL + "/v1/services/"
 	req, err := http.NewRequest(http.MethodGet, url, nil)
 	if err != nil {
-		c.logger.Errorf("Failed to create request: '%s': %s", url, err)
-		return nil
+		return nil, fmt.Errorf("failed to create request: '%s': %s", url, err)
 	}
-	req.Header.Add("discovery-address", c.networkAddress)
+	req.Header.Add("discovery-service", c.discoveryServiceName)
+	req.Header.Add("remote", fmt.Sprint(common.RemoteChecksum(c.remote)))
 	resp, err := http.DefaultClient.Do(req)
 	if err != nil {
-		c.logger.Errorf("Failed to GET URL: '%s': %s", url, err)
-		return nil
+		return nil, fmt.Errorf("failed to GET URL: '%s': %s", url, err)
 	}
 	if resp.StatusCode != http.StatusOK {
-		c.logger.Errorf("status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
-		return nil
+		return nil, fmt.Errorf("status code is not OK: %v (%s)", resp.StatusCode, resp.Status)
 	}
 
 	respBytes := []byte{}
 	_, err = resp.Body.Read(respBytes)
 	if err != nil {
-		c.logger.Errorf("Failed to read response body from URL '%s': %s", url, err)
-		return nil
+		return nil, fmt.Errorf("failed to read response body from URL '%s': %s", url, err)
 	}
 
 	var serviceList federationmodel.ServiceListMessage
 	err = json.NewDecoder(resp.Body).Decode(&serviceList)
 	if err != nil {
-		c.logger.Errorf("Failed to unmarshal response bytes: %s", err)
-		return nil
+		return nil, fmt.Errorf("failed to unmarshal response bytes: %s", err)
 	}
-	return &serviceList
+	return &serviceList, nil
 }
 
 func (c *Controller) convertExportedService(s *federationmodel.ServiceMessage) (*model.Service, []*model.ServiceInstance) {
@@ -234,8 +305,17 @@ func (c *Controller) convertExportedService(s *federationmodel.ServiceMessage) (
 		serviceVisibility = visibility.Public
 	}
 	serviceName := fmt.Sprintf("%s.%s.%s.remote", s.Name, s.Namespace, c.clusterID)
-	return c.createService(s, serviceName, c.namespace, s.Hostname, c.clusterID,
-		c.networkID, serviceVisibility, c.gatewayStore, s.ServiceAccounts)
+	return c.createService(createServiceOptions{
+		service:           s,
+		serviceName:       serviceName,
+		serviceNamespace:  c.namespace,
+		hostname:          s.Hostname,
+		clusterID:         c.clusterID,
+		networkID:         c.networkID,
+		serviceVisibility: serviceVisibility,
+		networkGateways:   c.gatewayStore,
+		sas:               s.ServiceAccounts,
+	})
 }
 
 func (c *Controller) convertToLocalService(s *federationmodel.ServiceMessage,
@@ -248,35 +328,57 @@ func (c *Controller) convertToLocalService(s *federationmodel.ServiceMessage,
 	}
 	// XXX: make this configurable
 	serviceVisibility := visibility.Public
-	return c.createService(s, serviceName, serviceNamespace, importedName.Hostname,
-		c.clusterID, c.localNetworkID, serviceVisibility, c.egressGateways, c.egressSAs)
+	return c.createService(createServiceOptions{
+		service:           s,
+		serviceName:       serviceName,
+		serviceNamespace:  serviceNamespace,
+		hostname:          importedName.Hostname,
+		clusterID:         c.clusterID,
+		networkID:         c.localNetworkID,
+		serviceVisibility: serviceVisibility,
+		networkGateways:   c.egressGateways,
+		sas:               c.egressSAs,
+		locality:          c.locality,
+	})
+}
+
+type createServiceOptions struct {
+	service           *federationmodel.ServiceMessage
+	serviceName       string
+	serviceNamespace  string
+	hostname          string
+	clusterID         cluster.ID
+	networkID         network.ID
+	serviceVisibility visibility.Instance
+	networkGateways   []model.NetworkGateway
+	sas               []string
+	locality          *v1.ImportedServiceLocality
 }
 
-func (c *Controller) createService(s *federationmodel.ServiceMessage, serviceName, serviceNamespace, hostname string, clusterID cluster.ID, network network.ID,
-	serviceVisibility visibility.Instance, networkGateways []model.NetworkGateway, sas []string) (*model.Service, []*model.ServiceInstance) {
+func (c *Controller) createService(opts createServiceOptions) (*model.Service, []*model.ServiceInstance) {
 	instances := []*model.ServiceInstance{}
 	svc := &model.Service{
 		Attributes: model.ServiceAttributes{
 			ServiceRegistry: provider.Federation,
-			Name:            serviceName,
-			Namespace:       serviceNamespace,
+			Name:            opts.serviceName,
+			Namespace:       opts.serviceNamespace,
 			ExportTo: map[visibility.Instance]bool{
-				serviceVisibility: true,
+				opts.serviceVisibility: true,
 			},
 			Labels: labels.Instance{
-				label.TopologyCluster.Name:           clusterID.String(),
-				label.TopologyNetwork.Name:           network.String(),
-				model.IstioCanonicalServiceLabelName: serviceName,
+				label.TopologyCluster.Name:           opts.clusterID.String(),
+				label.TopologyNetwork.Name:           opts.networkID.String(),
+				model.IstioCanonicalServiceLabelName: opts.serviceName,
 			},
 		},
 		CreationTime:    time.Now(),
 		Resolution:      model.ClientSideLB,
 		DefaultAddress:  constants.UnspecifiedIP,
-		Hostname:        host.Name(hostname),
+		Hostname:        host.Name(opts.hostname),
 		Ports:           model.PortList{},
-		ServiceAccounts: append([]string(nil), sas...),
+		ServiceAccounts: append([]string(nil), opts.sas...),
 	}
-	for _, port := range s.ServicePorts {
+	for _, port := range opts.service.ServicePorts {
 		svc.Ports = append(svc.Ports, &model.Port{
 			Name:     port.Name,
 			Port:     port.Port,
@@ -284,36 +386,47 @@ func (c *Controller) createService(s *federationmodel.ServiceMessage, serviceNam
 		})
 	}
 
-	baseWorkloadName := serviceName
-	if !strings.Contains(serviceName, c.clusterID.String()) {
-		baseWorkloadName = fmt.Sprintf("%s-%s", serviceName, c.clusterID)
+	baseWorkloadName := opts.serviceName
+	if !strings.Contains(opts.serviceName, c.clusterID.String()) {
+		baseWorkloadName = fmt.Sprintf("%s-%s", opts.serviceName, c.clusterID)
+	}
+	localityLabel := ""
+	if opts.locality != nil && opts.locality.Region != "" {
+		localityLabel = fmt.Sprintf("%s/%s/%s", opts.locality.Region, opts.locality.Zone, opts.locality.Subzone)
 	}
 	for _, port := range svc.Ports {
-		for gatewayIndex, networkGateway := range networkGateways {
+		for gatewayIndex, networkGateway := range opts.networkGateways {
 			c.logger.Debugf("adding endpoint for imported service: addr=%s, port=%d, host=%s",
 				networkGateway.Addr, networkGateway.Port, svc.Hostname)
-			instances = append(instances, &model.ServiceInstance{
+			instance := &model.ServiceInstance{
 				Service:     svc,
 				ServicePort: port,
 				Endpoint: &model.IstioEndpoint{
 					Address:      networkGateway.Addr,
 					EndpointPort: networkGateway.Port,
 					Labels: labels.Instance{
-						label.TopologyCluster.Name:                   clusterID.String(),
-						label.TopologyNetwork.Name:                   network.String(),
-						model.IstioCanonicalServiceLabelName:         serviceName,
-						model.IstioCanonicalServiceRevisionLabelName: clusterID.String(),
+						label.TopologyCluster.Name:                   opts.clusterID.String(),
+						label.TopologyNetwork.Name:                   opts.networkID.String(),
+						model.IstioCanonicalServiceLabelName:         opts.serviceName,
+						model.IstioCanonicalServiceRevisionLabelName: opts.clusterID.String(),
 					},
-					Network: network,
+					Network: opts.networkID,
 					Locality: model.Locality{
-						ClusterID: clusterID,
+						ClusterID: opts.clusterID,
 					},
 					ServicePortName: port.Name,
 					TLSMode:         model.IstioMutualTLSModeLabel,
-					Namespace:       serviceNamespace,
+					Namespace:       opts.serviceNamespace,
 					WorkloadName:    fmt.Sprintf("%s-%d", baseWorkloadName, gatewayIndex),
 				},
-			})
+			}
+			if opts.locality != nil {
+				instance.Endpoint.Labels[label.TopologySubzone.Name] = opts.locality.Subzone
+				instance.Endpoint.Labels[corev1.LabelZoneFailureDomainStable] = opts.locality.Zone
+				instance.Endpoint.Labels[corev1.LabelZoneRegionStable] = opts.locality.Region
+				instance.Endpoint.Locality.Label = localityLabel
+			}
+			instances = append(instances, instance)
 		}
 	}
 	return svc, instances
@@ -321,17 +434,23 @@ func (c *Controller) createService(s *federationmodel.ServiceMessage, serviceNam
 
 func (c *Controller) gatewayForNetworkAddress() []model.NetworkGateway {
 	var gateways []model.NetworkGateway
-	addrs, err := c.getIPAddrsForHostOrIP(c.networkAddress)
-	if err != nil {
-		c.logger.Errorf("error resolving IP addr for federation network %s: %v", c.networkAddress, err)
-	} else {
-		c.logger.Debugf("adding gateway %s endpoints for cluster %s", c.networkAddress, c.clusterID)
-		for _, ip := range addrs {
-			c.logger.Debugf("adding gateway %s endpoint %s for cluster %s", c.networkAddress, ip, c.clusterID)
-			gateways = append(gateways, model.NetworkGateway{
-				Addr: ip,
-				Port: federationPort,
-			})
+	remotePort := c.remote.ServicePort
+	if remotePort == 0 {
+		remotePort = common.DefaultFederationPort
+	}
+	for _, address := range c.remote.Addresses {
+		addrs, err := c.getIPAddrsForHostOrIP(address)
+		if err != nil {
+			c.logger.Errorf("error resolving IP addr for federation network %s: %v", address, err)
+		} else {
+			c.logger.Debugf("adding gateway %s endpoints for cluster %s", address, c.clusterID)
+			for _, ip := range addrs {
+				c.logger.Debugf("adding gateway %s endpoint %s for cluster %s", address, ip, c.clusterID)
+				gateways = append(gateways, model.NetworkGateway{
+					Addr: ip,
+					Port: uint32(remotePort),
+				})
+			}
 		}
 	}
 	return gateways
@@ -383,7 +502,7 @@ func (c *Controller) getEgressServiceAddrs() ([]model.NetworkGateway, []string)
 	var sas []string
 	for _, subset := range endpoints.Subsets {
 		for index, address := range subset.Addresses {
-			if subset.Ports[index].Port == common.FederationPort {
+			if subset.Ports[index].Port == common.DefaultFederationPort {
 				ips, err := c.getIPAddrsForHostOrIP(address.IP)
 				if err != nil {
 					c.logger.Errorf("error converting to IP address from %s: %s", address.IP, err)
@@ -392,7 +511,7 @@ func (c *Controller) getEgressServiceAddrs() ([]model.NetworkGateway, []string)
 				for _, ip := range ips {
 					addrs = append(addrs, model.NetworkGateway{
 						Addr: ip,
-						Port: federationPort,
+						Port: uint32(common.DefaultFederationPort),
 					})
 					sas = append(sas, serviceAccountByIP[ip])
 				}
@@ -531,30 +650,19 @@ func (c *Controller) GetProxyWorkloadLabels(proxy *model.Proxy) labels.Collectio
 
 // Run starts all the controllers
 func (c *Controller) Run(stop <-chan struct{}) {
-	eventCh := make(chan *federationmodel.WatchEvent)
 	refreshTicker := time.NewTicker(c.resyncPeriod)
 	defer refreshTicker.Stop()
-	c.resync()
-	go func() {
-		for !c.hasStopped() {
-			c.logger.Info("starting watch")
-			err := c.watch(eventCh, stop)
-			if err != nil {
-				c.logger.Errorf("watch failed: %s", err)
-				time.Sleep(c.backoffPolicy.NextBackOff())
-			} else {
-				return
-			}
-		}
-	}()
+	c.startWatch()
+	atomic.StoreInt32(&c.started, 1)
 	for {
 		select {
 		case <-stop:
 			c.logger.Info("Federation Controller terminated")
+			c.stopWatch()
 			c.stop()
 			return
-		case e := <-eventCh:
-			c.logger.Debugf("watch event received: %s service %s", e.Action, e.Service.Name)
+		case e := <-c.watchEvents:
+			c.logger.Debugf("watch event received: %v", e)
 			c.handleEvent(e)
 		case <-refreshTicker.C:
 			c.logger.Debugf("performing full resync for cluster %s", c.clusterID)
@@ -563,12 +671,18 @@ func (c *Controller) Run(stop <-chan struct{}) {
 	}
 }
 
+func (c *Controller) RestartWatch() {
+	c.logger.Infof("restarting watch for cluster %s", c.clusterID)
+	c.stopWatch()
+	c.startWatch()
+}
+
 func (c *Controller) stop() {
-	atomic.StoreInt32(&c.stopped, 1)
+	atomic.StoreInt32(&c.started, 0)
 }
 
-func (c *Controller) hasStopped() bool {
-	return atomic.LoadInt32(&c.stopped) != 0
+func (c *Controller) hasStarted() bool {
+	return atomic.LoadInt32(&c.started) == 1
 }
 
 func (c *Controller) handleEvent(e *federationmodel.WatchEvent) {
@@ -847,16 +961,59 @@ func (c *Controller) removeServiceFromStore(service federationmodel.ServiceKey)
 	return svc
 }
 
-func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-chan struct{}) error {
+func (c *Controller) startWatch() {
+	var ctx context.Context
+	var cancelCtx context.CancelFunc
+	ctx, cancelCtx = context.WithCancel(context.Background())
+	c.cancelWatch = cancelCtx
+	go func() {
+		defer func() {
+			cancelCtx() // cleans up resources when watch is closed gracefully
+			c.logger.Info("watch stopped")
+		}()
+		for ctx.Err() != context.Canceled {
+			c.logger.Info("starting watch")
+			err := c.watch(ctx, c.watchEvents)
+			if err != nil {
+				if err == context.Canceled {
+					c.logger.Info("watch cancelled")
+					return
+				}
+				c.logger.Errorf("watch failed: %s", err)
+
+				// sleep, but still honor context cancellation
+				select {
+				case <-ctx.Done():
+					c.logger.Info("watch cancelled")
+					return
+				case <-time.After(c.backoffPolicy.NextBackOff()):
+					// start watch again after backoff
+				}
+			} else {
+				c.backoffPolicy.Reset()
+				c.logger.Info("watch closed")
+			}
+		}
+	}()
+}
+
+func (c *Controller) stopWatch() {
+	if c.cancelWatch != nil {
+		c.cancelWatch()
+	}
+}
+
+func (c *Controller) watch(ctx context.Context, eventCh chan *federationmodel.WatchEvent) error {
 	c.statusHandler.WatchInitiated()
-	url := c.discoveryURL + "/watch"
+	url := c.discoveryURL + "/v1/watch"
 	req, err := http.NewRequest(http.MethodGet, url, nil)
 	if err != nil {
 		c.logger.Errorf("Failed to create request: '%s': %s", url, err)
 		return nil
 	}
-	req.Header.Add("discovery-address", c.networkAddress)
-	resp, err := http.DefaultClient.Do(req)
+	req.Header.Add("discovery-service", c.discoveryServiceName)
+	req.Header.Add("remote", fmt.Sprint(common.RemoteChecksum(c.remote)))
+	resp, err := http.DefaultClient.Do(req.WithContext(ctx))
 	defer func() {
 		status := ""
 		if resp != nil {
@@ -875,20 +1032,19 @@ func (c *Controller) watch(eventCh chan *federationmodel.WatchEvent, stopCh <-ch
 
 	c.statusHandler.Watching()
 
-	// connection was established successfully. reset backoffPolicy
+	// connection was established successfully. reset backoffPolicy and resync
 	c.backoffPolicy.Reset()
+	c.resync()
 
 	dec := json.NewDecoder(resp.Body)
 	defer resp.Body.Close()
 	for {
-		select {
-		case <-stopCh:
-			return nil
-		default:
-		}
 		var e federationmodel.WatchEvent
 		err := dec.Decode(&e)
 		if err != nil {
+			if err == io.EOF {
+				return nil // server closed the connection gracefully
+			}
 			return err
 		}
 		eventCh <- &e
@@ -899,7 +1055,16 @@ func (c *Controller) resync() uint64 {
 	c.storeLock.Lock()
 	defer c.storeLock.Unlock()
 	c.logger.Debugf("performing full resync")
-	svcList := c.pollServices()
+	var err error
+	var svcList *federationmodel.ServiceListMessage
+	err = retry.UntilSuccess(func() error {
+		svcList, err = c.pollServices()
+		return err
+	}, retry.Delay(time.Second), retry.Timeout(2*time.Minute))
+	if err != nil {
+		c.logger.Warnf("resync failed: %s", err)
+		return 0
+	}
 	c.updateGateways(svcList)
 	if svcList != nil {
 		c.convertServices(svcList)
diff --git a/pilot/pkg/serviceregistry/federation/routing.go b/pilot/pkg/serviceregistry/federation/routing.go
index 8c711c9c4f..7613d3d270 100644
--- a/pilot/pkg/serviceregistry/federation/routing.go
+++ b/pilot/pkg/serviceregistry/federation/routing.go
@@ -112,7 +112,7 @@ func (c *Controller) gatewayForImport(remote, local federationmodel.ServiceKey)
 					},
 					Port: &rawnetworking.Port{
 						Name:     "tls-federation",
-						Number:   uint32(common.FederationPort),
+						Number:   uint32(common.DefaultFederationPort),
 						Protocol: "TLS",
 					},
 					Tls: &rawnetworking.ServerTLSSettings{
diff --git a/pilot/pkg/xds/tbds.go b/pilot/pkg/xds/tbds.go
new file mode 100644
index 0000000000..4255f0654d
--- /dev/null
+++ b/pilot/pkg/xds/tbds.go
@@ -0,0 +1,71 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package xds
+
+import (
+	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	v1 "maistra.io/api/security/v1"
+
+	"istio.io/istio/pilot/pkg/model"
+	fedmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/istio/pkg/util/gogo"
+)
+
+// TbdsGenerator generates trust bundle configuration for proxies to consume
+type TbdsGenerator struct {
+	TrustBundleProvider fedmodel.TrustBundleProvider
+}
+
+var _ model.XdsResourceGenerator = &TbdsGenerator{}
+
+func tbdsNeedsPush(req *model.PushRequest) bool {
+	if req == nil {
+		return true
+	}
+
+	if !req.Full {
+		return false
+	}
+
+	if len(req.ConfigsUpdated) == 0 {
+		return true
+	}
+
+	return false
+}
+
+// Generate returns protobuf containing TrustBundle for given proxy
+func (e *TbdsGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *model.WatchedResource,
+	req *model.PushRequest) (model.Resources, model.XdsLogDetails, error) {
+	if !tbdsNeedsPush(req) {
+		return nil, model.DefaultXdsLogDetails, nil
+	}
+	if e.TrustBundleProvider == nil {
+		return nil, model.DefaultXdsLogDetails, nil
+	}
+	tb := &v1.TrustBundleResponse{}
+	trustBundles := e.TrustBundleProvider.GetTrustBundles()
+	if len(trustBundles) == 0 {
+		return nil, model.DefaultXdsLogDetails, nil
+	}
+	for td, cert := range trustBundles {
+		tb.TrustBundles = append(tb.TrustBundles, &v1.TrustBundle{
+			TrustDomain: td,
+			RootCert:    cert,
+		})
+	}
+	resources := model.Resources{&discovery.Resource{Resource: gogo.MessageToAny(tb)}}
+	return resources, model.DefaultXdsLogDetails, nil
+}
diff --git a/pilot/pkg/xds/v3/model.go b/pilot/pkg/xds/v3/model.go
index 6f1be92708..798ab17a73 100644
--- a/pilot/pkg/xds/v3/model.go
+++ b/pilot/pkg/xds/v3/model.go
@@ -31,6 +31,9 @@ const (
 	SecretType                 = resource.SecretType
 	ExtensionConfigurationType = resource.ExtensionConfigType
 
+	// maistra xDS
+	TrustBundleType = "type.googleapis.com/maistra.security.v1.TrustBundleResponse"
+
 	NameTableType   = apiTypePrefix + "istio.networking.nds.v1.NameTable"
 	HealthInfoType  = apiTypePrefix + "istio.v1.HealthInformation"
 	ProxyConfigType = apiTypePrefix + "istio.mesh.v1alpha1.ProxyConfig"
@@ -61,6 +64,8 @@ func GetShortType(typeURL string) string {
 		return "PCDS"
 	case ExtensionConfigurationType:
 		return "ECDS"
+	case TrustBundleType:
+		return "TBDS"
 	default:
 		return typeURL
 	}
@@ -87,6 +92,8 @@ func GetMetricType(typeURL string) string {
 		return "ecds"
 	case BootstrapType:
 		return "bds"
+	case TrustBundleType:
+		return "tbds"
 	default:
 		return typeURL
 	}
diff --git a/pkg/istio-agent/xds_proxy.go b/pkg/istio-agent/xds_proxy.go
index 51766751e1..e8056f7f53 100644
--- a/pkg/istio-agent/xds_proxy.go
+++ b/pkg/istio-agent/xds_proxy.go
@@ -32,6 +32,7 @@ import (
 
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 	gogotypes "github.com/gogo/protobuf/types"
+	"github.com/golang/protobuf/ptypes"
 	"go.uber.org/atomic"
 	google_rpc "google.golang.org/genproto/googleapis/rpc/status"
 	"google.golang.org/grpc"
@@ -41,6 +42,7 @@ import (
 	"google.golang.org/grpc/metadata"
 	"google.golang.org/grpc/reflection"
 	any "google.golang.org/protobuf/types/known/anypb"
+	v1 "maistra.io/api/security/v1"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/cmd/pilot-agent/status/ready"
@@ -56,7 +58,9 @@ import (
 	"istio.io/istio/pkg/util/gogo"
 	"istio.io/istio/pkg/util/protomarshal"
 	"istio.io/istio/pkg/wasm"
+	"istio.io/istio/security/pkg/nodeagent/cache"
 	"istio.io/istio/security/pkg/nodeagent/caclient"
+	nodeagentutil "istio.io/istio/security/pkg/nodeagent/util"
 	"istio.io/istio/security/pkg/pki/util"
 	"istio.io/pkg/log"
 )
@@ -107,6 +111,8 @@ type XdsProxy struct {
 	// Wasm cache and ecds channel are used to replace wasm remote load with local file.
 	wasmCache wasm.Cache
 
+	secretCache *cache.SecretManagerClient
+
 	// ecds version and nonce uses atomic only to prevent race in testing.
 	// In reality there should not be race as istiod will only have one
 	// in flight update for each type of resource.
@@ -149,6 +155,7 @@ func initXdsProxy(ia *Agent) (*XdsProxy, error) {
 		xdsHeaders:            ia.cfg.XDSHeaders,
 		xdsUdsPath:            ia.cfg.XdsUdsPath,
 		wasmCache:             wasm.NewLocalFileCache(constants.IstioDataDir, wasm.DefaultWasmModulePurgeInterval, wasm.DefaultWasmModuleExpiry),
+		secretCache:           ia.secretCache,
 		proxyAddresses:        ia.cfg.ProxyIPAddresses,
 		downstreamGrpcOptions: ia.cfg.DownstreamGrpcOptions,
 	}
@@ -358,6 +365,12 @@ func (p *XdsProxy) handleStream(downstream adsStream) error {
 				if initialRequest != nil {
 					con.sendRequest(initialRequest)
 				}
+
+				// fire off an initial TBDS request
+				con.requestsChan <- &discovery.DiscoveryRequest{
+					TypeUrl: v3.TrustBundleType,
+				}
+
 				p.connectedMutex.RUnlock()
 				initialRequestsSent = true
 			}
@@ -511,6 +524,46 @@ func (p *XdsProxy) handleUpstreamResponse(con *ProxyConnection) {
 					// Otherwise, forward ECDS resource update directly to Envoy.
 					forwardToEnvoy(con, resp)
 				}
+			case v3.TrustBundleType:
+				if len(resp.Resources) == 0 {
+					log.Error("empty response")
+					continue
+				}
+				var tb v1.TrustBundleResponse
+				if err := ptypes.UnmarshalAny(resp.Resources[0], &tb); err != nil { // nolint
+					proxyLog.Errorf("failed to unmarshall trust bundles: %v", err)
+					continue
+				}
+				trustBundles := map[string][]byte{}
+				proxyLog.Debugf("received new trust bundles: %v", tb.TrustBundles)
+				expireTime := time.Date(3000, 1, 1, 1, 1, 1, 1, time.Now().Location())
+				for _, bundle := range tb.TrustBundles {
+					certBytes := []byte(bundle.RootCert)
+					certExpireTime, err := nodeagentutil.ParseCertAndGetExpiryTimestamp(certBytes)
+					if err != nil {
+						proxyLog.Errorf("failed to extract expiration time in the certificate loaded from file: %v", err)
+					} else if certExpireTime.Before(expireTime) {
+						expireTime = certExpireTime
+					}
+					trustBundles[bundle.TrustDomain] = certBytes
+				}
+
+				if p.secretCache == nil {
+					proxyLog.Error("failed to access secret cache")
+					continue
+				}
+				if len(trustBundles) == 0 {
+					trustBundles = nil
+				}
+				p.secretCache.SetTrustBundles(trustBundles, expireTime)
+
+				// Send ACK
+				con.requestsChan <- &discovery.DiscoveryRequest{
+					VersionInfo:   resp.VersionInfo,
+					TypeUrl:       v3.TrustBundleType,
+					ResponseNonce: resp.Nonce,
+				}
+
 			default:
 				if strings.HasPrefix(resp.TypeUrl, "istio.io/debug") {
 					p.forwardToTap(resp)
diff --git a/pkg/kube/controller/controller.go b/pkg/kube/controller/controller.go
index f51df62598..95f584deb7 100644
--- a/pkg/kube/controller/controller.go
+++ b/pkg/kube/controller/controller.go
@@ -105,7 +105,7 @@ func (c *Controller) Start(stopChan <-chan struct{}) {
 	t0 := time.Now()
 	c.Logger.Info("Starting controller")
 
-	go c.informer.Run(stopChan)
+	c.RunInformer(stopChan)
 
 	cache.WaitForCacheSync(stopChan, c.HasSynced)
 	c.Logger.Infof("Controller synced in %s", time.Since(t0))
@@ -114,6 +114,10 @@ func (c *Controller) Start(stopChan <-chan struct{}) {
 	wait.Until(c.worker, c.resyncPeriod, stopChan)
 }
 
+func (c *Controller) RunInformer(stopChan <-chan struct{}) {
+	go c.informer.Run(stopChan)
+}
+
 func (c *Controller) HasSynced() bool {
 	return c.informer.HasSynced()
 }
diff --git a/pkg/security/security.go b/pkg/security/security.go
index c1cf9b48f6..093c24576b 100644
--- a/pkg/security/security.go
+++ b/pkg/security/security.go
@@ -298,6 +298,8 @@ type SecretItem struct {
 
 	RootCert []byte
 
+	TrustBundles map[string][]byte
+
 	// ResourceName passed from envoy SDS discovery request.
 	// "ROOTCA" for root cert request, "default" for key/cert request.
 	ResourceName string
diff --git a/pkg/servicemesh/controller/extension/controller.go b/pkg/servicemesh/controller/extension/controller.go
index 77f84b39fb..dbbf3dded9 100644
--- a/pkg/servicemesh/controller/extension/controller.go
+++ b/pkg/servicemesh/controller/extension/controller.go
@@ -57,9 +57,12 @@ func NewControllerFromConfigFile(kubeConfig string, namespaces []string, mrc mem
 		return nil, err
 	}
 
-	namespaceSet := xnsinformers.NewNamespaceSet(namespaces...)
+	namespaceSet := xnsinformers.NewNamespaceSet()
 	if mrc != nil {
 		mrc.Register(namespaceSet, "extensions-controller")
+	} else {
+		// No MemberRoll configured, set namespaces based on args.
+		namespaceSet.SetNamespaces(namespaces...)
 	}
 
 	newInformer := func(namespace string) cache.SharedIndexInformer {
diff --git a/pkg/servicemesh/extension/apply_extension.go b/pkg/servicemesh/extension/apply_extension.go
index 709d32737e..2e3d8fc16a 100644
--- a/pkg/servicemesh/extension/apply_extension.go
+++ b/pkg/servicemesh/extension/apply_extension.go
@@ -17,7 +17,7 @@ package extension
 import (
 	"fmt"
 
-	udpa "github.com/cncf/udpa/go/udpa/type/v1"
+	udpa "github.com/cncf/xds/go/udpa/type/v1"
 	xdslistener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	hcm_filter "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	xdsutil "github.com/envoyproxy/go-control-plane/pkg/wellknown"
diff --git a/pkg/servicemesh/federation/common/const.go b/pkg/servicemesh/federation/common/const.go
index 567d9e5506..720be13873 100644
--- a/pkg/servicemesh/federation/common/const.go
+++ b/pkg/servicemesh/federation/common/const.go
@@ -21,10 +21,11 @@ import (
 )
 
 const (
-	DiscoveryScheme      = "http"
-	DefaultDiscoveryPort = 8188
-	DefaultResyncPeriod  = 60 * time.Second
-	FederationPort       = 15443
+	DiscoveryScheme               = "http"
+	DefaultDiscoveryPort          = 8188
+	DefaultResyncPeriod           = 60 * time.Second
+	DefaultFederationPort         = 15443
+	DefaultFederationRootCertName = "root-cert.pem"
 )
 
 var Logger = log.RegisterScope("federation", "federation", 0)
diff --git a/pkg/servicemesh/federation/common/exports.go b/pkg/servicemesh/federation/common/exports.go
index 2bfe1aab2b..47e06fb70e 100644
--- a/pkg/servicemesh/federation/common/exports.go
+++ b/pkg/servicemesh/federation/common/exports.go
@@ -17,7 +17,7 @@ package common
 import (
 	"sync"
 
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
@@ -33,7 +33,7 @@ type ServiceExporter struct {
 
 var _ NameMapper = (*ServiceExporter)(nil)
 
-func NewServiceExporter(exportConfig *v1alpha1.ServiceExports, defaultMapper *ServiceExporter, domainSuffix string) *ServiceExporter {
+func NewServiceExporter(exportConfig *v1.ExportedServiceSet, defaultMapper *ServiceExporter, domainSuffix string) *ServiceExporter {
 	return &ServiceExporter{
 		domainSuffix:  domainSuffix,
 		exportConfig:  convertServiceExportsToNameMapper(exportConfig, domainSuffix),
@@ -41,14 +41,14 @@ func NewServiceExporter(exportConfig *v1alpha1.ServiceExports, defaultMapper *Se
 	}
 }
 
-func convertServiceExportsToNameMapper(serviceExports *v1alpha1.ServiceExports, domainSuffix string) []NameMapper {
+func convertServiceExportsToNameMapper(serviceExports *v1.ExportedServiceSet, domainSuffix string) []NameMapper {
 	if serviceExports == nil {
 		return nil
 	}
 	var exportConfig []NameMapper
-	for index, rule := range serviceExports.Spec.Exports {
+	for index, rule := range serviceExports.Spec.ExportRules {
 		switch rule.Type {
-		case v1alpha1.LabelSelectorType:
+		case v1.LabelSelectorType:
 			if rule.LabelSelector == nil {
 				Logger.Errorf("skipping rule %d in ServiceExports %s/%s: null labelSelector", index, serviceExports.Namespace, serviceExports.Name)
 				continue
@@ -60,7 +60,7 @@ func convertServiceExportsToNameMapper(serviceExports *v1alpha1.ServiceExports,
 			} else {
 				exportConfig = append(exportConfig, matcher)
 			}
-		case v1alpha1.NameSelectorType:
+		case v1.NameSelectorType:
 			if rule.NameSelector == nil {
 				Logger.Errorf("skipping rule %d in ServiceExports %s/%s: null nameSelector", index, serviceExports.Namespace, serviceExports.Name)
 				continue
@@ -87,13 +87,13 @@ func (se *ServiceExporter) NameForService(svc *model.Service) *federationmodel.S
 	defer se.mu.RUnlock()
 	for _, matcher := range se.exportConfig {
 		if name := matcher.NameForService(svc); name != nil {
-			setHostname(name, se.domainSuffix)
 			return name
 		}
 	}
-	if name := se.defaultMapper.NameForService(svc); name != nil {
-		setHostname(name, se.domainSuffix)
-		return name
+	if se.defaultMapper != nil {
+		if name := se.defaultMapper.NameForService(svc); name != nil {
+			return name
+		}
 	}
 	return nil
 }
diff --git a/pkg/servicemesh/federation/common/imports.go b/pkg/servicemesh/federation/common/imports.go
index 6722bf7bd2..7b572fba5c 100644
--- a/pkg/servicemesh/federation/common/imports.go
+++ b/pkg/servicemesh/federation/common/imports.go
@@ -17,7 +17,7 @@ package common
 import (
 	"sync"
 
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/model"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
@@ -32,7 +32,7 @@ type ServiceImporter struct {
 
 var _ NameMapper = (*ServiceImporter)(nil)
 
-func NewServiceImporter(importConfig *v1alpha1.ServiceImports, defaultMapper NameMapper, defaultDomainSuffix, localDomainSuffix string) *ServiceImporter {
+func NewServiceImporter(importConfig *v1.ImportedServiceSet, defaultMapper NameMapper, defaultDomainSuffix, localDomainSuffix string) *ServiceImporter {
 	return &ServiceImporter{
 		domainSuffix:  defaultDomainSuffix,
 		importConfig:  convertServiceImportsToNameMapper(importConfig, defaultDomainSuffix, localDomainSuffix),
@@ -40,7 +40,7 @@ func NewServiceImporter(importConfig *v1alpha1.ServiceImports, defaultMapper Nam
 	}
 }
 
-func convertServiceImportsToNameMapper(serviceImports *v1alpha1.ServiceImports, defaultDomainSuffix, localDomainSuffix string) []NameMapper {
+func convertServiceImportsToNameMapper(serviceImports *v1.ImportedServiceSet, defaultDomainSuffix, localDomainSuffix string) []NameMapper {
 	if serviceImports == nil {
 		return nil
 	}
@@ -48,8 +48,8 @@ func convertServiceImportsToNameMapper(serviceImports *v1alpha1.ServiceImports,
 		defaultDomainSuffix = serviceImports.Spec.DomainSuffix
 	}
 	var importConfig []NameMapper
-	for index, rule := range serviceImports.Spec.Imports {
-		if rule.Type != v1alpha1.NameSelectorType {
+	for index, rule := range serviceImports.Spec.ImportRules {
+		if rule.Type != v1.NameSelectorType {
 			Logger.Errorf("skipping rule %d in ServiceImports %s/%s: unknown selector type %s",
 				rule.Type, index, serviceImports.Namespace, serviceImports.Name)
 			continue
@@ -60,7 +60,7 @@ func convertServiceImportsToNameMapper(serviceImports *v1alpha1.ServiceImports,
 		}
 		ruleDomainSuffix := rule.DomainSuffix
 		if rule.ImportAsLocal {
-			if rule.NameSelector.Alias == nil || rule.NameSelector.Alias.Namespace == "" || rule.NameSelector.Alias.Namespace == v1alpha1.MatchAny {
+			if rule.NameSelector.Alias == nil || rule.NameSelector.Alias.Namespace == "" || rule.NameSelector.Alias.Namespace == v1.MatchAny {
 				Logger.Errorf("skipping rule %d in ServiceImports %s/%s: cannot use importAsLocal without setting a fixed namespace alias",
 					index, serviceImports.Namespace, serviceImports.Name)
 				continue
diff --git a/pkg/servicemesh/federation/common/namemapping.go b/pkg/servicemesh/federation/common/namemapping.go
index 31a1600be2..e3d4fec136 100644
--- a/pkg/servicemesh/federation/common/namemapping.go
+++ b/pkg/servicemesh/federation/common/namemapping.go
@@ -19,7 +19,7 @@ import (
 
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/labels"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/model"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
@@ -34,48 +34,47 @@ func setHostname(name *federationmodel.ServiceKey, domainSuffix string) {
 
 type NameMapper interface {
 	NameForService(svc *model.Service) *federationmodel.ServiceKey
-	UpdateDefaultMapper(defaults NameMapper)
 }
 
 type nameMatcher struct {
 	domainSuffix string
-	match        v1alpha1.ServiceName
-	alias        *v1alpha1.ServiceName
+	match        v1.ServiceName
+	alias        *v1.ServiceName
 }
 
 var _ NameMapper = (*nameMatcher)(nil)
 
-func newNameMatcher(mapping *v1alpha1.ServiceNameMapping, domainSuffix string) NameMapper {
-	var alias *v1alpha1.ServiceName
+func newNameMatcher(mapping *v1.ServiceNameMapping, domainSuffix string) NameMapper {
+	var alias *v1.ServiceName
 	// if it's nil or matches anything, it may as well be nil
 	if mapping.Alias == nil ||
-		((mapping.Alias.Namespace == v1alpha1.MatchAny || mapping.Alias.Namespace == "") &&
-			(mapping.Alias.Name == v1alpha1.MatchAny || mapping.Alias.Name == "")) {
+		((mapping.Alias.Namespace == v1.MatchAny || mapping.Alias.Namespace == "") &&
+			(mapping.Alias.Name == v1.MatchAny || mapping.Alias.Name == "")) {
 		alias = nil
 	} else {
 		alias = mapping.Alias.DeepCopy()
 	}
 	return &nameMatcher{
 		domainSuffix: domainSuffix,
-		match:        mapping.Name,
+		match:        mapping.ServiceName,
 		alias:        alias,
 	}
 }
 
 func (m *nameMatcher) NameForService(svc *model.Service) *federationmodel.ServiceKey {
-	if (m.match.Namespace == "" || m.match.Namespace == v1alpha1.MatchAny || m.match.Namespace == svc.Attributes.Namespace) &&
-		(m.match.Name == "" || m.match.Name == v1alpha1.MatchAny || m.match.Name == svc.Attributes.Name) {
+	if (m.match.Namespace == "" || m.match.Namespace == v1.MatchAny || m.match.Namespace == svc.Attributes.Namespace) &&
+		(m.match.Name == "" || m.match.Name == v1.MatchAny || m.match.Name == svc.Attributes.Name) {
 		name := &federationmodel.ServiceKey{}
 		if m.alias == nil {
 			name.Namespace = svc.Attributes.Namespace
 			name.Name = svc.Attributes.Name
 		} else {
-			if m.alias.Namespace == v1alpha1.MatchAny || m.alias.Namespace == "" {
+			if m.alias.Namespace == v1.MatchAny || m.alias.Namespace == "" {
 				name.Namespace = svc.Attributes.Namespace
 			} else {
 				name.Namespace = m.alias.Namespace
 			}
-			if m.alias.Name == v1alpha1.MatchAny || m.alias.Name == "" {
+			if m.alias.Name == v1.MatchAny || m.alias.Name == "" {
 				name.Name = svc.Attributes.Name
 			} else {
 				name.Name = m.alias.Name
@@ -87,8 +86,6 @@ func (m *nameMatcher) NameForService(svc *model.Service) *federationmodel.Servic
 	return nil
 }
 
-func (m *nameMatcher) UpdateDefaultMapper(_ NameMapper) {}
-
 type labelMatcher struct {
 	domainSuffix string
 	namespace    string
@@ -98,7 +95,7 @@ type labelMatcher struct {
 
 var _ NameMapper = (*labelMatcher)(nil)
 
-func newLabelMatcher(labelSelector *v1alpha1.ServiceImportExportLabelelector, domainSuffix string) (NameMapper, error) {
+func newLabelMatcher(labelSelector *v1.ServiceImportExportLabelSelector, domainSuffix string) (NameMapper, error) {
 	selector, err := metav1.LabelSelectorAsSelector(&labelSelector.Selector)
 	if err != nil {
 		return nil, err
@@ -116,7 +113,7 @@ func newLabelMatcher(labelSelector *v1alpha1.ServiceImportExportLabelelector, do
 }
 
 func (m *labelMatcher) NameForService(svc *model.Service) *federationmodel.ServiceKey {
-	if (m.namespace == "" || m.namespace == v1alpha1.MatchAny || m.namespace == svc.Attributes.Namespace) &&
+	if (m.namespace == "" || m.namespace == v1.MatchAny || m.namespace == svc.Attributes.Namespace) &&
 		m.selector.Matches(labels.Set(svc.Attributes.Labels)) {
 		for _, alias := range m.aliases {
 			if name := alias.NameForService(svc); name != nil {
@@ -134,5 +131,3 @@ func (m *labelMatcher) NameForService(svc *model.Service) *federationmodel.Servi
 	}
 	return nil
 }
-
-func (m *labelMatcher) UpdateDefaultMapper(_ NameMapper) {}
diff --git a/pkg/servicemesh/federation/common/options.go b/pkg/servicemesh/federation/common/options.go
index 6f5fcceca9..75de691b93 100644
--- a/pkg/servicemesh/federation/common/options.go
+++ b/pkg/servicemesh/federation/common/options.go
@@ -15,13 +15,33 @@
 package common
 
 import (
+	"fmt"
 	"time"
 
+	"k8s.io/apimachinery/pkg/util/errors"
+	maistraclient "maistra.io/api/client/versioned"
+
 	"istio.io/istio/pkg/kube"
 )
 
 type ControllerOptions struct {
 	KubeClient   kube.Client
+	MaistraCS    maistraclient.Interface
 	ResyncPeriod time.Duration
 	Namespace    string
 }
+
+func (opt ControllerOptions) validate() error {
+	var allErrors []error
+	if opt.KubeClient == nil {
+		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	}
+	if opt.MaistraCS == nil {
+		allErrors = append(allErrors, fmt.Errorf("the MaistraCS field must not be nil"))
+	}
+	if opt.ResyncPeriod == 0 {
+		opt.ResyncPeriod = DefaultResyncPeriod
+		Logger.WithLabels("component", "ControllerOptions").Infof("ResyncPeriod not specified, defaulting to %s", opt.ResyncPeriod)
+	}
+	return errors.NewAggregate(allErrors)
+}
diff --git a/pkg/servicemesh/federation/common/resources.go b/pkg/servicemesh/federation/common/resources.go
new file mode 100644
index 0000000000..b52f5fd48e
--- /dev/null
+++ b/pkg/servicemesh/federation/common/resources.go
@@ -0,0 +1,108 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package common
+
+import (
+	"reflect"
+
+	maistrainformersfederationv1 "maistra.io/api/client/informers/externalversions/federation/v1"
+	maistraclient "maistra.io/api/client/versioned"
+	maistraxnsinformer "maistra.io/api/client/xnsinformer"
+
+	"istio.io/istio/pkg/kube"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+)
+
+type ResourceManager interface {
+	MaistraClientSet() maistraclient.Interface
+	KubeClient() kube.Client
+	PeerInformer() maistrainformersfederationv1.ServiceMeshPeerInformer
+	ExportsInformer() maistrainformersfederationv1.ExportedServiceSetInformer
+	ImportsInformer() maistrainformersfederationv1.ImportedServiceSetInformer
+	Start(stopCh <-chan struct{})
+	HasSynced() bool
+	WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool
+}
+
+func NewResourceManager(opts ControllerOptions, mrc memberroll.MemberRollController) (ResourceManager, error) {
+	if err := opts.validate(); err != nil {
+		return nil, err
+	}
+
+	var informerFactory maistraxnsinformer.SharedInformerFactory
+	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
+	if mrc != nil && false {
+		informerFactory = maistraxnsinformer.NewSharedInformerFactoryWithOptions(opts.MaistraCS, opts.ResyncPeriod, maistraxnsinformer.WithNamespaces())
+		mrc.Register(informerFactory, "federation")
+	} else {
+		informerFactory = maistraxnsinformer.NewSharedInformerFactoryWithOptions(opts.MaistraCS, opts.ResyncPeriod, maistraxnsinformer.WithNamespaces(opts.Namespace))
+	}
+	rm := &resourceManager{
+		mcs:  opts.MaistraCS,
+		kc:   opts.KubeClient,
+		inff: informerFactory,
+		pi:   informerFactory.Federation().V1().ServiceMeshPeers(),
+		sei:  informerFactory.Federation().V1().ExportedServiceSets(),
+		sii:  informerFactory.Federation().V1().ImportedServiceSets(),
+	}
+	// create the informers now, so they're registered with the factory
+	rm.pi.Informer()
+	rm.sei.Informer()
+	rm.sii.Informer()
+	return rm, nil
+}
+
+type resourceManager struct {
+	mcs  maistraclient.Interface
+	kc   kube.Client
+	inff maistraxnsinformer.SharedInformerFactory
+	pi   maistrainformersfederationv1.ServiceMeshPeerInformer
+	sei  maistrainformersfederationv1.ExportedServiceSetInformer
+	sii  maistrainformersfederationv1.ImportedServiceSetInformer
+}
+
+var _ ResourceManager = (*resourceManager)(nil)
+
+func (rm *resourceManager) MaistraClientSet() maistraclient.Interface {
+	return rm.mcs
+}
+
+func (rm *resourceManager) KubeClient() kube.Client {
+	return rm.kc
+}
+
+func (rm *resourceManager) Start(stopCh <-chan struct{}) {
+	rm.inff.Start(stopCh)
+}
+
+func (rm *resourceManager) HasSynced() bool {
+	return rm.pi.Informer().HasSynced() && rm.sei.Informer().HasSynced() && rm.sii.Informer().HasSynced()
+}
+
+func (rm *resourceManager) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
+	return rm.inff.WaitForCacheSync(stopCh)
+}
+
+func (rm *resourceManager) PeerInformer() maistrainformersfederationv1.ServiceMeshPeerInformer {
+	return rm.pi
+}
+
+func (rm *resourceManager) ExportsInformer() maistrainformersfederationv1.ExportedServiceSetInformer {
+	return rm.sei
+}
+
+func (rm *resourceManager) ImportsInformer() maistrainformersfederationv1.ImportedServiceSetInformer {
+	return rm.sii
+}
diff --git a/pkg/servicemesh/federation/common/testing.go b/pkg/servicemesh/federation/common/testing.go
new file mode 100644
index 0000000000..52565363a8
--- /dev/null
+++ b/pkg/servicemesh/federation/common/testing.go
@@ -0,0 +1,73 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package common
+
+import federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+
+type FakeStatusHandler struct{}
+
+// Outbound connections
+func (m *FakeStatusHandler) WatchInitiated() {
+}
+
+func (m *FakeStatusHandler) Watching() {
+}
+
+func (m *FakeStatusHandler) WatchEventReceived() {
+}
+
+func (m *FakeStatusHandler) FullSyncComplete() {
+}
+
+func (m *FakeStatusHandler) WatchTerminated(status string) {
+}
+
+// Inbound connections
+func (m *FakeStatusHandler) RemoteWatchAccepted(source string) {
+}
+
+func (m *FakeStatusHandler) WatchEventSent(source string) {
+}
+
+func (m *FakeStatusHandler) FullSyncSent(source string) {
+}
+
+func (m *FakeStatusHandler) RemoteWatchTerminated(source string) {
+}
+
+// Exports
+func (m *FakeStatusHandler) ExportAdded(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *FakeStatusHandler) ExportUpdated(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *FakeStatusHandler) ExportRemoved(service federationmodel.ServiceKey) {
+}
+
+// Imports
+func (m *FakeStatusHandler) ImportAdded(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *FakeStatusHandler) ImportUpdated(service federationmodel.ServiceKey, exportedName string) {
+}
+
+func (m *FakeStatusHandler) ImportRemoved(exportedName string) {
+}
+
+// Write status
+func (m *FakeStatusHandler) Flush() error {
+	return nil
+}
diff --git a/pkg/servicemesh/federation/common/util.go b/pkg/servicemesh/federation/common/util.go
index 0d91dbfb58..ce128e85e1 100644
--- a/pkg/servicemesh/federation/common/util.go
+++ b/pkg/servicemesh/federation/common/util.go
@@ -15,13 +15,29 @@
 package common
 
 import (
+	"fmt"
+
+	"github.com/mitchellh/hashstructure/v2"
 	corev1 "k8s.io/api/core/v1"
 	kubelabels "k8s.io/apimachinery/pkg/labels"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/spiffe"
 )
 
+// DiscoveryServiceHostname returns the hostname used to represent a remote's
+// discovery service in the local mesh.
+func DiscoveryServiceHostname(instance *v1.ServiceMeshPeer) string {
+	return fmt.Sprintf("discovery.%s.svc.%s.local", instance.Namespace, instance.Name)
+}
+
+// DefaultFederationCARootResourceName is the default name used for the resource
+// containing the root CA for a remote mesh.
+func DefaultFederationCARootResourceName(instance *v1.ServiceMeshPeer) string {
+	return fmt.Sprintf("%s-ca-root-cert", instance.Name)
+}
+
 // EndpointsForService returns the Endpoints for the named service.
 func EndpointsForService(client kube.Client, name, namespace string) (*corev1.Endpoints, error) {
 	return client.KubeInformer().Core().V1().Endpoints().Lister().Endpoints(namespace).Get(name)
@@ -56,3 +72,11 @@ func ServiceAccountsForService(client kube.Client, name, namespace string) (map[
 	}
 	return serviceAccountByIP, nil
 }
+
+func RemoteChecksum(remote v1.ServiceMeshPeerRemote) uint64 {
+	checksum, err := hashstructure.Hash(remote, hashstructure.FormatV2, &hashstructure.HashOptions{SlicesAsSets: true})
+	if err != nil {
+		return 0
+	}
+	return checksum
+}
diff --git a/pkg/servicemesh/federation/discovery/controller.go b/pkg/servicemesh/federation/discovery/controller.go
index 7b00bf97d0..edb2b30ba4 100644
--- a/pkg/servicemesh/federation/discovery/controller.go
+++ b/pkg/servicemesh/federation/discovery/controller.go
@@ -19,17 +19,12 @@ import (
 	"sync"
 	"time"
 
-	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
 	utilerrors "k8s.io/apimachinery/pkg/util/errors"
-	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
-	maistrainformers "maistra.io/api/client/informers/externalversions/core/v1alpha1"
-	maistraclient "maistra.io/api/client/versioned"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry"
@@ -37,9 +32,7 @@ import (
 	federationregistry "istio.io/istio/pilot/pkg/serviceregistry/federation"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/kube"
 	kubecontroller "istio.io/istio/pkg/kube/controller"
-	memberroll "istio.io/istio/pkg/servicemesh/controller"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/servicemesh/federation/server"
 	"istio.io/istio/pkg/servicemesh/federation/status"
@@ -48,7 +41,8 @@ import (
 const controllerName = "federation-discovery-controller"
 
 type Options struct {
-	common.ControllerOptions
+	ResourceManager   common.ResourceManager
+	ResyncPeriod      time.Duration
 	ServiceController *aggregate.Controller
 	XDSUpdater        model.XDSUpdater
 	Env               *model.Environment
@@ -64,8 +58,7 @@ type Controller struct {
 	model.ConfigStoreCache
 	localNetwork      string
 	localClusterID    string
-	kubeClient        kube.Client
-	cs                maistraclient.Interface
+	rm                common.ResourceManager
 	env               *model.Environment
 	federationManager server.FederationManager
 	statusManager     status.Manager
@@ -73,6 +66,7 @@ type Controller struct {
 	xds               model.XDSUpdater
 	mu                sync.Mutex
 	stopChannels      map[cluster.ID]chan struct{}
+	trustBundles      map[string]string
 }
 
 var (
@@ -86,69 +80,30 @@ func NewController(opt Options) (*Controller, error) {
 		return nil, err
 	}
 
-	cs, err := maistraclient.NewForConfig(opt.KubeClient.RESTConfig())
-	if err != nil {
-		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
-	}
-
-	mrc := opt.KubeClient.GetMemberRoll()
-
-	return internalNewController(cs, mrc, opt), nil
-}
-
-// allows using a fake client set for testing purposes
-func internalNewController(cs maistraclient.Interface, mrc memberroll.MemberRollController, opt Options) *Controller {
 	logger := common.Logger.WithLabels("component", controllerName)
-	var informer cache.SharedIndexInformer
-	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
-	if mrc != nil && false {
-		newInformer := func(namespace string) cache.SharedIndexInformer {
-			return cache.NewSharedIndexInformer(
-				&cache.ListWatch{
-					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-						return cs.CoreV1alpha1().MeshFederations(namespace).List(context.TODO(), options)
-					},
-					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-						return cs.CoreV1alpha1().MeshFederations(namespace).Watch(context.TODO(), options)
-					},
-				},
-				&v1alpha1.MeshFederation{},
-				opt.ResyncPeriod,
-				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
-			)
-		}
-
-		namespaceSet := xnsinformers.NewNamespaceSet()
-		informer = xnsinformers.NewMultiNamespaceInformer(namespaceSet, opt.ResyncPeriod, newInformer)
-		mrc.Register(namespaceSet, controllerName)
-	} else {
-		informer = maistrainformers.NewMeshFederationInformer(
-			cs, opt.Namespace, opt.ResyncPeriod,
-			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-	}
 
 	controller := &Controller{
 		ConfigStoreCache:  opt.ConfigStore,
 		localClusterID:    opt.LocalClusterID,
 		localNetwork:      opt.LocalNetwork,
-		kubeClient:        opt.KubeClient,
-		cs:                cs,
+		rm:                opt.ResourceManager,
 		env:               opt.Env,
 		sc:                opt.ServiceController,
 		stopChannels:      make(map[cluster.ID]chan struct{}),
 		xds:               opt.XDSUpdater,
 		federationManager: opt.FederationManager,
 		statusManager:     opt.StatusManager,
+		trustBundles:      map[string]string{},
 	}
 	internalController := kubecontroller.NewController(kubecontroller.Options{
-		Informer:     informer,
+		Informer:     opt.ResourceManager.PeerInformer().Informer(),
 		Logger:       logger,
 		ResyncPeriod: opt.ResyncPeriod,
 		Reconciler:   controller.reconcile,
 	})
 	controller.Controller = internalController
 
-	return controller
+	return controller, nil
 }
 
 func (c *Controller) Run(stopChan <-chan struct{}) {
@@ -164,13 +119,17 @@ func (c *Controller) HasSynced() bool {
 	return c.Controller.HasSynced()
 }
 
+func (c *Controller) RunInformer(stopChan <-chan struct{}) {
+	// no-op, informer is started by the shared factory in Federation.Start()
+}
+
 func (c *Controller) reconcile(resourceName string) error {
-	c.Logger.Debugf("Reconciling MeshFederation %s", resourceName)
+	c.Logger.Debugf("Reconciling ServiceMeshPeer %s", resourceName)
 	defer func() {
 		if err := c.statusManager.PushStatus(); err != nil {
 			c.Logger.Errorf("error pushing FederationStatus for mesh %s: %s", resourceName, err)
 		}
-		c.Logger.Debugf("Completed reconciliation of MeshFederation %s", resourceName)
+		c.Logger.Debugf("Completed reconciliation of ServiceMeshPeer %s", resourceName)
 	}()
 
 	ctx := context.TODO()
@@ -179,26 +138,20 @@ func (c *Controller) reconcile(resourceName string) error {
 	if err != nil {
 		c.Logger.Errorf("error splitting resource name: %s", resourceName)
 	}
-	instance, err := c.cs.CoreV1alpha1().MeshFederations(namespace).Get(
-		ctx, name, metav1.GetOptions{
-			TypeMeta: metav1.TypeMeta{
-				Kind:       "MeshFederation",
-				APIVersion: v1alpha1.SchemeGroupVersion.String(),
-			},
-		})
+	instance, err := c.rm.PeerInformer().Lister().ServiceMeshPeers(namespace).Get(name)
 	if err != nil {
 		if apierrors.IsNotFound(err) || apierrors.IsGone(err) {
 			// Request object not found, could have been deleted after reconcile request.
 			// Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
 			// Return and don't requeue
-			err = c.delete(ctx, &v1alpha1.MeshFederation{
+			err = c.delete(ctx, &v1.ServiceMeshPeer{
 				ObjectMeta: metav1.ObjectMeta{
 					Name:      name,
 					Namespace: namespace,
 				},
 			})
 			if err == nil {
-				c.Logger.Info("MeshFederation deleted")
+				c.Logger.Info("ServiceMeshPeer deleted")
 			}
 		}
 		// Error reading the object
@@ -208,69 +161,56 @@ func (c *Controller) reconcile(resourceName string) error {
 	return c.update(ctx, instance)
 }
 
-func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederation) error {
+func (c *Controller) update(ctx context.Context, instance *v1.ServiceMeshPeer) error {
 	registry := c.getRegistry(cluster.ID(instance.Name))
+	if instance.Spec.Security.TrustDomain != "" && instance.Spec.Security.TrustDomain != c.env.Mesh().GetTrustDomain() {
+		rootCert, err := c.getRootCertForMesh(instance)
+		if err != nil {
+			return err
+		}
+		c.updateRootCert(instance.Spec.Security.TrustDomain, rootCert)
+	}
 
-	egressGatewayService := fmt.Sprintf("%s.%s.svc.%s",
-		instance.Spec.Gateways.Egress.Name, instance.Namespace, c.env.DomainSuffix)
+	if err := c.createDiscoveryResources(ctx, instance, c.env.Mesh()); err != nil {
+		return err
+	}
+
+	importConfig, err := c.rm.ImportsInformer().Lister().ImportedServiceSets(instance.Namespace).Get(instance.Name)
+	if err != nil && !(apierrors.IsNotFound(err) || apierrors.IsGone(err)) {
+		c.Logger.Errorf("error retrieving ServiceImports associated with ServiceMeshPeer %s: %s", instance.Name, err)
+		return err
+	}
 
 	// check for existing registry
 	if registry != nil {
-		// if there's an existing registry
-		// make sure it's one of ours
+		// if there's an existing registry, make sure it's one of ours
 		if registry.Provider() != provider.Federation {
 			return fmt.Errorf(
 				"cannot create Federation registry for %s, registry exists and belongs to another provider (%s)",
 				instance.Name, registry.Provider())
 		}
-		// check to see if it needs updating
-		// TODO: support updates
 		if federationRegistry, ok := registry.(*federationregistry.Controller); ok {
-			if federationRegistry.NetworkAddress() != instance.Spec.NetworkAddress {
-				// TODO: support updates
-				c.Logger.Warnf("updating NetworkAddress for MeshFederation (%s) is not supported", instance.Name)
-			}
+			c.Logger.Debugf("updating settings for ServiceMeshPeer %s", instance.Name)
+			federationRegistry.UpdatePeerConfig(instance)
+			federationRegistry.UpdateImportConfig(importConfig)
 		} else {
 			return fmt.Errorf("registry %s is not a Federation registry (type=%T)", instance.Name, registry)
 		}
 	} else {
 		// if there's no existing registry
-		c.Logger.Infof("Creating export handler for Federation to %s", instance.Name)
-		exportConfig, err := c.cs.CoreV1alpha1().ServiceExports(instance.Namespace).Get(context.TODO(), instance.Name, metav1.GetOptions{})
+		exportConfig, err := c.rm.ExportsInformer().Lister().ExportedServiceSets(instance.Namespace).Get(instance.Name)
 		if err != nil && !(apierrors.IsNotFound(err) || apierrors.IsGone(err)) {
-			c.Logger.Errorf("error retrieving ServiceExports associated with MeshFederation %s: %s", instance.Name, err)
+			c.Logger.Errorf("error retrieving ServiceExports associated with ServiceMeshPeer %s: %s", instance.Name, err)
 			return err
 		}
-		defaultImportConfig, err := c.cs.CoreV1alpha1().ServiceImports(instance.Namespace).Get(context.TODO(), "default", metav1.GetOptions{})
-		if err != nil && !(apierrors.IsNotFound(err) || apierrors.IsGone(err)) {
-			c.Logger.Errorf("error retrieving default ServiceImports associated with MeshFederation %s: %s", instance.Name, err)
+		statusHandler := c.statusManager.PeerAdded(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
+		if err := c.federationManager.AddPeer(instance, exportConfig, statusHandler); err != nil {
 			return err
 		}
-		importConfig, err := c.cs.CoreV1alpha1().ServiceImports(instance.Namespace).Get(context.TODO(), instance.Name, metav1.GetOptions{})
-		if err != nil && !(apierrors.IsNotFound(err) || apierrors.IsGone(err)) {
-			c.Logger.Errorf("error retrieving ServiceImports associated with MeshFederation %s: %s", instance.Name, err)
-			return err
-		}
-
-		statusHandler := c.statusManager.FederationAdded(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
-		if err := c.federationManager.AddMeshFederation(instance, exportConfig, statusHandler); err != nil {
-			return err
-		}
-
-		c.Logger.Infof("Creating Istio resources for Federation discovery from %s", instance.Name)
-		if err := c.createDiscoveryResources(ctx, instance, c.env.Mesh()); err != nil {
-			return err
-		}
-
-		c.Logger.Infof("Initializing Federation service registry for %q at %s", instance.Name, instance.Spec.NetworkAddress)
+		c.Logger.Infof("initializing Federation service registry for %q at %s", instance.Name, instance.Spec.Remote.Addresses)
 		// create a registry instance
 		options := federationregistry.Options{
-			NetworkAddress: instance.Spec.NetworkAddress,
-			EgressName:     instance.Spec.Gateways.Egress.Name,
-			EgressService:  egressGatewayService,
-			Namespace:      instance.Namespace,
-			UseDirectCalls: instance.Spec.Security != nil && instance.Spec.Security.AllowDirectOutbound,
-			KubeClient:     c.kubeClient,
+			KubeClient:     c.rm.KubeClient(),
 			ConfigStore:    c.ConfigStoreCache,
 			StatusHandler:  statusHandler,
 			XDSUpdater:     c.xds,
@@ -281,7 +221,7 @@ func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederati
 			ClusterID:      instance.Name,
 			Network:        fmt.Sprintf("network-%s", instance.Name),
 		}
-		registry = federationregistry.NewController(options, instance, defaultImportConfig, importConfig)
+		registry = federationregistry.NewController(options, instance, importConfig)
 		// register the new instance
 		c.sc.AddRegistry(registry)
 
@@ -295,10 +235,15 @@ func (c *Controller) update(ctx context.Context, instance *v1alpha1.MeshFederati
 	return nil
 }
 
-func (c *Controller) delete(ctx context.Context, instance *v1alpha1.MeshFederation) error {
+func (c *Controller) delete(ctx context.Context, instance *v1.ServiceMeshPeer) error {
 	var allErrors []error
 	// delete the server
-	c.federationManager.DeleteMeshFederation(instance.Name)
+	c.federationManager.DeletePeer(instance.Name)
+
+	// delete trust bundle
+	if instance.Spec.Security.TrustDomain != "" {
+		c.updateRootCert(instance.Spec.Security.TrustDomain, "")
+	}
 
 	// delete the registry
 	registry := c.getRegistry(cluster.ID(instance.Name))
@@ -325,7 +270,7 @@ func (c *Controller) delete(ctx context.Context, instance *v1alpha1.MeshFederati
 		allErrors = append(allErrors, err)
 	}
 
-	c.statusManager.FederationDeleted(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
+	c.statusManager.PeerDeleted(types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace})
 
 	return utilerrors.NewAggregate(allErrors)
 }
@@ -341,8 +286,8 @@ func (c *Controller) getRegistry(clusterID cluster.ID) serviceregistry.Instance
 
 func (opt Options) validate() error {
 	var allErrors []error
-	if opt.KubeClient == nil {
-		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	if opt.ResourceManager == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ResourceManager field must not be nil"))
 	}
 	if opt.ServiceController == nil {
 		allErrors = append(allErrors, fmt.Errorf("the ServiceController field must not be nil"))
@@ -362,3 +307,55 @@ func (opt Options) validate() error {
 	}
 	return utilerrors.NewAggregate(allErrors)
 }
+
+func (c *Controller) getRootCertForMesh(instance *v1.ServiceMeshPeer) (string, error) {
+	if instance == nil {
+		return "", nil
+	}
+	name := instance.Spec.Security.CertificateChain.Name
+	if name == "" {
+		name = common.DefaultFederationCARootResourceName(instance)
+	}
+	entryKey := common.DefaultFederationRootCertName
+	switch instance.Spec.Security.CertificateChain.Kind {
+	case "", "ConfigMap":
+		cm, err := c.rm.KubeClient().KubeInformer().Core().V1().ConfigMaps().Lister().ConfigMaps(instance.Namespace).Get(name)
+		if err != nil {
+			return "", err
+		}
+		if cert, exists := cm.Data[entryKey]; exists {
+			return cert, nil
+		}
+		return "", fmt.Errorf("missing entry %s in ConfigMap %s/%s", entryKey, instance.Namespace, name)
+	default:
+		return "", fmt.Errorf("unknown Kind for CertificateChain object reference: %s", instance.Spec.Security.CertificateChain.Kind)
+	}
+}
+
+func (c *Controller) updateRootCert(trustDomain string, rootCert string) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if rootCert == "" {
+		delete(c.trustBundles, trustDomain)
+	} else if existingCert, ok := c.trustBundles[trustDomain]; !ok || existingCert != rootCert {
+		c.trustBundles[trustDomain] = rootCert
+	} else {
+		// we didn't update the trust bundles, so we return early without pushing
+		return
+	}
+	c.xds.ConfigUpdate(&model.PushRequest{
+		Full:   true,
+		Reason: []model.TriggerReason{model.GlobalUpdate},
+	})
+}
+
+func (c *Controller) GetTrustBundles() map[string]string {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	// make a copy
+	ret := map[string]string{}
+	for td, cert := range c.trustBundles {
+		ret[td] = cert
+	}
+	return ret
+}
diff --git a/pkg/servicemesh/federation/discovery/controller_test.go b/pkg/servicemesh/federation/discovery/controller_test.go
index c0540ffd6f..b0b8f53efd 100644
--- a/pkg/servicemesh/federation/discovery/controller_test.go
+++ b/pkg/servicemesh/federation/discovery/controller_test.go
@@ -16,16 +16,18 @@ package discovery
 import (
 	"context"
 	"fmt"
+	"reflect"
 	"testing"
 	"time"
 
 	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/api/meta"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
-	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/client-go/tools/cache"
+	maistrainformersfederationv1 "maistra.io/api/client/informers/externalversions/federation/v1"
+	maistraclient "maistra.io/api/client/versioned"
 	"maistra.io/api/client/versioned/fake"
-	maistrav1alpha1 "maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/api/mesh/v1alpha1"
 	configmemory "istio.io/istio/pilot/pkg/config/memory"
@@ -42,37 +44,73 @@ import (
 
 type fakeManager struct{}
 
-func (m *fakeManager) AddMeshFederation(_ *maistrav1alpha1.MeshFederation, _ *maistrav1alpha1.ServiceExports, _ status.Handler) error {
+func (m *fakeManager) AddPeer(_ *v1.ServiceMeshPeer, _ *v1.ExportedServiceSet, _ status.Handler) error {
 	return nil
 }
-func (m *fakeManager) DeleteMeshFederation(_ string) {}
-func (m *fakeManager) UpdateExportsForMesh(_ *maistrav1alpha1.ServiceExports) error {
+func (m *fakeManager) DeletePeer(_ string) {}
+func (m *fakeManager) UpdateExportsForMesh(_ *v1.ExportedServiceSet) error {
 	return nil
 }
 func (m *fakeManager) DeleteExportsForMesh(_ string) {}
 
 type fakeStatusManager struct{}
 
-func (m *fakeStatusManager) FederationAdded(mesh types.NamespacedName) status.Handler {
-	return nil
+func (m *fakeStatusManager) IsLeader() bool {
+	return true
+}
+
+func (m *fakeStatusManager) PeerAdded(mesh types.NamespacedName) status.Handler {
+	return &common.FakeStatusHandler{}
 }
 
-func (m *fakeStatusManager) FederationDeleted(mesh types.NamespacedName) {
+func (m *fakeStatusManager) PeerDeleted(mesh types.NamespacedName) {
 }
 
 func (m *fakeStatusManager) HandlerFor(mesh types.NamespacedName) status.Handler {
-	return nil
+	return &common.FakeStatusHandler{}
 }
 
 func (m *fakeStatusManager) PushStatus() error {
 	return nil
 }
 
+type fakeResourceManager struct{}
+
+func (m *fakeResourceManager) MaistraClientSet() maistraclient.Interface {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) KubeClient() kube.Client {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) PeerInformer() maistrainformersfederationv1.ServiceMeshPeerInformer {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) ExportsInformer() maistrainformersfederationv1.ExportedServiceSetInformer {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) ImportsInformer() maistrainformersfederationv1.ImportedServiceSetInformer {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) Start(stopCh <-chan struct{}) {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) HasSynced() bool {
+	panic("not implemented") // TODO: Implement
+}
+
+func (m *fakeResourceManager) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
+	panic("not implemented") // TODO: Implement
+}
+
 func TestValidOptions(t *testing.T) {
 	opt := Options{
-		ControllerOptions: common.ControllerOptions{
-			KubeClient: kube.NewFakeClient(),
-		},
+		ResourceManager:   &fakeResourceManager{},
 		ServiceController: &aggregate.Controller{},
 		XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 		Env:               &model.Environment{},
@@ -89,11 +127,9 @@ func TestInvalidOptions(t *testing.T) {
 		opt  Options
 	}{
 		{
-			name: "client",
+			name: "resource-manager",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: nil,
-				},
+				ResourceManager:   nil,
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               &model.Environment{},
@@ -102,9 +138,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "service-controller",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				ResourceManager:   &fakeResourceManager{},
 				ServiceController: nil,
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               &model.Environment{},
@@ -113,9 +147,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "xds-updater",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				ResourceManager:   &fakeResourceManager{},
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        nil,
 				Env:               &model.Environment{},
@@ -124,9 +156,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "env",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				ResourceManager:   &fakeResourceManager{},
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               nil,
@@ -174,14 +204,33 @@ func newTestOptions(discoveryAddress string) options {
 }
 
 func TestReconcile(t *testing.T) {
+	name := "test"
+	namespace := "test"
 	resyncPeriod := 30 * time.Second
 	options := newTestOptions("test.address")
-	controller := internalNewController(fake.NewSimpleClientset(), nil, Options{
-		ControllerOptions: common.ControllerOptions{
-			KubeClient:   kube.NewFakeClient(),
-			ResyncPeriod: resyncPeriod,
-			Namespace:    "",
+	kubeClient := kube.NewFakeClient(
+		&corev1.ConfigMap{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "dummy",
+				Namespace: namespace,
+			},
+			Data: map[string]string{
+				"root-cert.pem": "dummy-cert-pem",
+			},
 		},
+	)
+	rm, err := common.NewResourceManager(common.ControllerOptions{
+		KubeClient:   kubeClient,
+		MaistraCS:    fake.NewSimpleClientset(),
+		ResyncPeriod: resyncPeriod,
+		Namespace:    namespace,
+	}, nil)
+	if err != nil {
+		t.Fatalf("unable to create ResourceManager: %s", err)
+	}
+	controller, err := NewController(Options{
+		ResourceManager:   rm,
+		ResyncPeriod:      resyncPeriod,
 		ServiceController: options.serviceController,
 		XDSUpdater:        options.xdsUpdater,
 		Env:               options.env,
@@ -189,17 +238,20 @@ func TestReconcile(t *testing.T) {
 		StatusManager:     &fakeStatusManager{},
 		ConfigStore:       configmemory.NewController(configmemory.Make(Schemas)),
 	})
+	if err != nil {
+		t.Fatalf("unable to create Controller: %s", err)
+	}
 
-	name := "test"
-	namespace := "test"
-	federation := &maistrav1alpha1.MeshFederation{
+	federation := &v1.ServiceMeshPeer{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      name,
 			Namespace: namespace,
 		},
-		Spec: maistrav1alpha1.MeshFederationSpec{
-			NetworkAddress: "test.mesh",
-			Gateways: maistrav1alpha1.MeshFederationGateways{
+		Spec: v1.ServiceMeshPeerSpec{
+			Remote: v1.ServiceMeshPeerRemote{
+				Addresses: []string{"test.mesh"},
+			},
+			Gateways: v1.ServiceMeshPeerGateways{
 				Ingress: corev1.LocalObjectReference{
 					Name: "test-ingress",
 				},
@@ -207,45 +259,47 @@ func TestReconcile(t *testing.T) {
 					Name: "test-egress",
 				},
 			},
-			Security: &maistrav1alpha1.MeshFederationSecurity{
-				ClientID:            "cluster.local/ns/test-mesh/sa/test-egress-service-account",
-				TrustDomain:         "test.local",
-				CertificateChain:    "dummy",
+			Security: v1.ServiceMeshPeerSecurity{
+				ClientID:    "cluster.local/ns/test-mesh/sa/test-egress-service-account",
+				TrustDomain: "test.local",
+				CertificateChain: corev1.TypedLocalObjectReference{
+					Name: "dummy",
+				},
 				AllowDirectInbound:  false,
 				AllowDirectOutbound: false,
 			},
 		},
 	}
-	cs := controller.cs
-	fedwatch, err := cs.CoreV1alpha1().MeshFederations(namespace).Watch(context.TODO(), metav1.ListOptions{})
-	if err != nil {
-		t.Errorf("failed to watch for MeshFederation")
-		return
+	stopCh := make(chan struct{})
+	defer close(stopCh)
+	go rm.Start(stopCh)
+	go kubeClient.KubeInformer().Core().V1().ConfigMaps().Informer().Run(stopCh)
+	for !kubeClient.KubeInformer().Core().V1().ConfigMaps().Informer().HasSynced() {
 	}
-	newFederation, err := cs.CoreV1alpha1().MeshFederations(namespace).Create(context.TODO(), federation, metav1.CreateOptions{})
+	fedAdded := make(chan struct{})
+	fedDeleted := make(chan struct{})
+	rm.PeerInformer().Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
+		AddFunc: func(obj interface{}) {
+			close(fedAdded)
+		},
+		DeleteFunc: func(obj interface{}) {
+			close(fedDeleted)
+		},
+	})
+	cs := rm.MaistraClientSet()
+	newFederation, err := cs.FederationV1().ServiceMeshPeers(namespace).Create(context.TODO(), federation, metav1.CreateOptions{})
 	if err != nil {
-		t.Errorf("failed to create MeshFederation")
-		fedwatch.Stop()
+		t.Errorf("failed to create ServiceMeshPeer")
 		return
 	}
 	// wait for object to show up
-	func() {
-		defer fedwatch.Stop()
-		select {
-		case event := <-fedwatch.ResultChan():
-			if event.Type == watch.Added {
-				metaObj, _ := meta.Accessor(event.Object)
-				if metaObj != nil && metaObj.GetName() == name && metaObj.GetNamespace() == namespace {
-					break
-				}
-			}
-			t.Errorf("unexpected watch event: %#v", event)
-		case <-time.After(5 * time.Second):
-			t.Errorf("timed out waiting for watch event")
-		}
-	}()
+	select {
+	case <-fedAdded:
+	case <-time.After(5 * time.Second):
+		t.Fatalf("timed out waiting for watch event")
+	}
 	if err := controller.reconcile(fmt.Sprintf("%s/%s", namespace, name)); err != nil {
-		t.Errorf("unexpected error reconciling new MeshFederation: %#v", err)
+		t.Fatalf("unexpected error reconciling new ServiceMeshPeer: %s", err)
 	}
 	// verify registry has been created
 	if controller.getRegistry(cluster.ID(newFederation.Name)) == nil {
@@ -257,7 +311,11 @@ func TestReconcile(t *testing.T) {
 		t.Errorf("resource doesn't exist")
 	}
 	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
-		discoveryResourceName(federation), namespace); resource == nil {
+		discoveryEgressResourceName(federation), namespace); resource == nil {
+		t.Errorf("resource doesn't exist")
+	}
+	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+		discoveryIngressResourceName(federation), namespace); resource == nil {
 		t.Errorf("resource doesn't exist")
 	}
 	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
@@ -269,7 +327,7 @@ func TestReconcile(t *testing.T) {
 		t.Errorf("resource doesn't exist")
 	}
 	if resource := controller.Get(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
-		discoveryResourceName(federation), namespace); resource == nil {
+		discoveryEgressResourceName(federation), namespace); resource == nil {
 		t.Errorf("resource doesn't exist")
 	}
 	if resource := controller.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
@@ -278,36 +336,20 @@ func TestReconcile(t *testing.T) {
 	}
 
 	// now delete
-	fedwatch, err = cs.CoreV1alpha1().MeshFederations(namespace).Watch(context.TODO(), metav1.ListOptions{})
-	if err != nil {
-		t.Errorf("failed to watch for MeshFederation")
-		return
-	}
-	if err = cs.CoreV1alpha1().MeshFederations(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{}); err != nil {
-		t.Errorf("error deleting MeshFederation")
-		fedwatch.Stop()
+	if err = cs.FederationV1().ServiceMeshPeers(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{}); err != nil {
+		t.Errorf("error deleting ServiceMeshPeer")
 		return
 	}
 
 	// wait for deletion to show up
-	func() {
-		defer fedwatch.Stop()
-		select {
-		case event := <-fedwatch.ResultChan():
-			if event.Type == watch.Deleted {
-				metaObj, _ := meta.Accessor(event.Object)
-				if metaObj != nil && metaObj.GetName() == name && metaObj.GetNamespace() == namespace {
-					break
-				}
-			}
-			t.Errorf("unexpected watch event: %#v", event)
-		case <-time.After(5 * time.Second):
-			t.Errorf("timed out waiting for watch event")
-		}
-	}()
+	select {
+	case <-fedDeleted:
+	case <-time.After(5 * time.Second):
+		t.Fatalf("timed out waiting for watch event")
+	}
 
 	if err := controller.reconcile(fmt.Sprintf("%s/%s", namespace, name)); err != nil {
-		t.Errorf("unexpected error reconciling new MeshFederation: %#v", err)
+		t.Errorf("unexpected error reconciling new ServiceMeshPeer: %#v", err)
 	}
 	// verify registry has been deleted
 	if controller.getRegistry(cluster.ID(newFederation.Name)) != nil {
diff --git a/pkg/servicemesh/federation/discovery/discovery.go b/pkg/servicemesh/federation/discovery/discovery.go
index 7668687391..f5dd4f87e1 100644
--- a/pkg/servicemesh/federation/discovery/discovery.go
+++ b/pkg/servicemesh/federation/discovery/discovery.go
@@ -21,12 +21,13 @@ import (
 	"strings"
 
 	utilerrors "k8s.io/apimachinery/pkg/util/errors"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	meshv1alpha1 "istio.io/api/mesh/v1alpha1"
 	rawnetworking "istio.io/api/networking/v1alpha3"
 	rawsecurity "istio.io/api/security/v1beta1"
 	rawtype "istio.io/api/type/v1beta1"
+	"istio.io/istio/pilot/pkg/config/kube/ior"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -44,28 +45,25 @@ func init() {
 	Schemas = schemasBuilder.Build()
 }
 
+const generationAnnotation = "reconciledGeneration"
+
 var Schemas collection.Schemas
 
 // only to facilitate processing errors from the store
-type storeErrorChecker struct {
-	s string
-}
+type notFoundErrorChecker struct{}
 
-func (e *storeErrorChecker) Error() string {
-	return e.s
+func (e *notFoundErrorChecker) Error() string {
+	return "item not found"
 }
 
-func (e *storeErrorChecker) Is(other error) bool {
-	return other.Error() == e.s
+func (e *notFoundErrorChecker) Is(other error) bool {
+	return other.Error() == "item not found" || strings.HasSuffix(other.Error(), "does not exist")
 }
 
-var (
-	memoryStoreErrNotFound      = &storeErrorChecker{"item not found"}
-	memoryStoreErrAlreadyExists = &storeErrorChecker{"item already exists"}
-)
+var memoryStoreErrNotFound = &notFoundErrorChecker{}
 
 func (c *Controller) deleteDiscoveryResources(
-	_ context.Context, instance *v1alpha1.MeshFederation) error {
+	_ context.Context, instance *v1.ServiceMeshPeer) error {
 	c.Logger.Infof("deleting discovery resources for Federation cluster %s", instance.Name)
 	var allErrors []error
 	rootName := discoveryResourceName(instance)
@@ -74,38 +72,44 @@ func (c *Controller) deleteDiscoveryResources(
 	// XXX: the only errors possible on delete are "does not exist" and "unknown
 	// type", so maybe we should just skip error checking?
 	if err := c.Delete(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
-		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery Service %s for Federation cluster %s: %v",
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(memoryStoreErrNotFound, err) {
+		c.Logger.Errorf("error deleting discovery Service %s for Federation cluster %s: %s",
 			rootName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
 	if err := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
-		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery VirtualService %s for Federation cluster %s: %v",
-			rootName, instance.Name, err)
+		ingressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		c.Logger.Errorf("error deleting discovery ingress VirtualService %s for Federation cluster %s: %s",
+			ingressName, instance.Name, err)
+		allErrors = append(allErrors, err)
+	}
+	if err := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+		egressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		c.Logger.Errorf("error deleting discovery egress VirtualService %s for Federation cluster %s: %s",
+			egressName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
 	if err := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
-		ingressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery ingress Gateway %s for Federation cluster %s: %v",
+		ingressName, instance.Namespace, nil); err != nil && !errors.Is(memoryStoreErrNotFound, err) {
+		c.Logger.Errorf("error deleting discovery ingress Gateway %s for Federation cluster %s: %s",
 			ingressName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
 	if err := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
-		egressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery egress Gateway %s for Federation cluster %s: %v",
+		egressName, instance.Namespace, nil); err != nil && !errors.Is(memoryStoreErrNotFound, err) {
+		c.Logger.Errorf("error deleting discovery egress Gateway %s for Federation cluster %s: %s",
 			egressName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
 	if err := c.Delete(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
-		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery DestinationRule %s for Federation cluster %s: %v",
-			rootName, instance.Name, err)
+		egressName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
+		c.Logger.Errorf("error deleting discovery DestinationRule %s for Federation cluster %s: %s",
+			egressName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
 	if err := c.Delete(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
-		rootName, instance.Namespace, nil); err != nil && !errors.Is(err, memoryStoreErrNotFound) {
-		c.Logger.Errorf("error deleting discovery AuthorizationPolicy %s for Federation cluster %s: %v",
+		rootName, instance.Namespace, nil); err != nil && !errors.Is(memoryStoreErrNotFound, err) {
+		c.Logger.Errorf("error deleting discovery AuthorizationPolicy %s for Federation cluster %s: %s",
 			rootName, instance.Name, err)
 		allErrors = append(allErrors, err)
 	}
@@ -113,174 +117,193 @@ func (c *Controller) deleteDiscoveryResources(
 }
 
 func (c *Controller) createDiscoveryResources(
-	_ context.Context, instance *v1alpha1.MeshFederation, meshConfig *meshv1alpha1.MeshConfig) (err error) {
-	var s, ap, dr, ig, eg, vs *config.Config
+	_ context.Context, instance *v1.ServiceMeshPeer, meshConfig *meshv1alpha1.MeshConfig) (err error) {
+	var s, ap, dr, ig, eg, evs, ivs *config.Config
 
 	defer func() {
 		if err != nil {
-			c.Logger.Errorf("error creating discovery configuration for Federation cluster %s: %v", instance.Name, err)
+			c.Logger.Errorf("error creating discovery configuration for Federation cluster %s: %s", instance.Name, err)
 			c.Logger.Infof("rolling back discovery Service for %s", instance.Name)
 			if s != nil {
 				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
 					s.Name, s.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery Service %s: %v", s.Name, newErr)
+					c.Logger.Errorf("error deleting discovery Service %s: %s", s.Name, newErr)
 				}
 			}
 			c.Logger.Infof("rolling back discovery AuthorizationPolicy for Federation cluster %s", instance.Name)
 			if ap != nil {
 				if newErr := c.Delete(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
 					ap.Name, ap.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery AuthorizationPolicy %s: %v", ap.Name, newErr)
+					c.Logger.Errorf("error deleting discovery AuthorizationPolicy %s: %s", ap.Name, newErr)
 				}
 			}
 			if dr != nil {
 				c.Logger.Infof("rolling back discovery DestinationRule for Federation cluster %s", instance.Name)
 				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
 					dr.Name, dr.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery DestinationRule %s: %v", dr.Name, newErr)
+					c.Logger.Errorf("error deleting discovery DestinationRule %s: %s", dr.Name, newErr)
 				}
 			}
 			if ig != nil {
 				c.Logger.Infof("rolling back discovery ingress Gateway for Federation cluster %s", instance.Name)
 				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
 					ig.Name, ig.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery ingress Gateway %s: %v", ig.Name, newErr)
+					c.Logger.Errorf("error deleting discovery ingress Gateway %s: %s", ig.Name, newErr)
 				}
 			}
 			if eg != nil {
 				c.Logger.Infof("rolling back discovery egress Gateway for Federation cluster %s", instance.Name)
 				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
 					eg.Name, eg.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery ingress Gateway %s: %v", eg.Name, newErr)
+					c.Logger.Errorf("error deleting discovery egress Gateway %s: %s", eg.Name, newErr)
+				}
+			}
+			if evs != nil {
+				c.Logger.Infof("rolling back discovery egress VirtualService for Federation cluster %s", instance.Name)
+				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+					evs.Name, evs.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					c.Logger.Errorf("error deleting discovery egress VirtualService %s: %s", evs.Name, newErr)
 				}
 			}
-			if vs != nil {
-				c.Logger.Infof("rolling back discovery VirtualService for Federation cluster %s", instance.Name)
+			if ivs != nil {
+				c.Logger.Infof("rolling back discovery ingress VirtualService for Federation cluster %s", instance.Name)
 				if newErr := c.Delete(collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
-					vs.Name, vs.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
-					c.Logger.Errorf("error deleting discovery VirtualService %s: %v", vs.Name, newErr)
+					ivs.Name, ivs.Namespace, nil); newErr != nil && !errors.Is(newErr, memoryStoreErrNotFound) {
+					c.Logger.Errorf("error deleting discovery ingress VirtualService %s: %s", ivs.Name, newErr)
 				}
 			}
 		}
 	}()
 
 	s = c.discoveryService(instance)
-	_, err = c.Create(*s)
+	err = c.upsertConfig(*s)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			s = nil
-			return
-		}
+		s = nil
 	}
 
 	ap = c.discoveryAuthorizationPolicy(instance)
-	_, err = c.Create(*ap)
+	err = c.upsertConfig(*ap)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			ap = nil
-			return
-		}
+		ap = nil
 	}
 
 	dr = c.discoveryDestinationRule(instance)
-	_, err = c.Create(*dr)
+	err = c.upsertConfig(*dr)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			dr = nil
-			return
-		}
+		dr = nil
 	}
 
 	ig = c.discoveryIngressGateway(instance)
-	_, err = c.Create(*ig)
+	err = c.upsertConfig(*ig)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			ig = nil
-			return
-		}
+		ig = nil
 	}
 
 	eg = c.discoveryEgressGateway(instance)
-	_, err = c.Create(*eg)
+	err = c.upsertConfig(*eg)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			return
-		}
+		eg = nil
 	}
 
-	vs = c.discoveryVirtualService(instance, meshConfig)
-	_, err = c.Create(*vs)
+	evs = c.discoveryEgressVirtualService(instance)
+	err = c.upsertConfig(*evs)
 	if err != nil {
-		if errors.Is(err, memoryStoreErrAlreadyExists) {
-			// XXX: We don't support upgrade, so ignore this for now
-			err = nil
-		} else {
-			vs = nil
-			return
-		}
+		evs = nil
 	}
 
+	ivs = c.discoveryIngressVirtualService(instance, meshConfig)
+	err = c.upsertConfig(*ivs)
+	if err != nil {
+		ivs = nil
+	}
 	return
 }
 
-func discoveryResourceName(instance *v1alpha1.MeshFederation) string {
+func (c *Controller) upsertConfig(cfg config.Config) (err error) {
+	existing := c.Get(cfg.GroupVersionKind, cfg.Name, cfg.Namespace)
+	if existing == nil {
+		_, err = c.Create(cfg)
+		if err != nil {
+			return err
+		}
+	} else if existing.Annotations[generationAnnotation] != cfg.Annotations[generationAnnotation] {
+		_, err = c.Update(cfg)
+		if err != nil {
+			// don't trigger roll back
+			c.Logger.Errorf("error updating resource %s: %s", cfg.Name, err)
+			err = nil
+		}
+	}
+	return err
+}
+
+func discoveryResourceName(instance *v1.ServiceMeshPeer) string {
 	return fmt.Sprintf("federation-discovery-%s", instance.Name)
 }
 
-func discoveryEgressResourceName(instance *v1alpha1.MeshFederation) string {
+func discoveryEgressResourceName(instance *v1.ServiceMeshPeer) string {
 	return fmt.Sprintf("%s-egress", discoveryResourceName(instance))
 }
 
-func discoveryIngressResourceName(instance *v1alpha1.MeshFederation) string {
+func discoveryIngressResourceName(instance *v1.ServiceMeshPeer) string {
 	return fmt.Sprintf("%s-ingress", discoveryResourceName(instance))
 }
 
-func federationIngressLabels(instance *v1alpha1.MeshFederation) map[string]string {
+func federationIngressLabels(instance *v1.ServiceMeshPeer) map[string]string {
 	return map[string]string{
 		"service.istio.io/canonical-name": instance.Spec.Gateways.Ingress.Name,
 	}
 }
 
-func federationEgressLabels(instance *v1alpha1.MeshFederation) map[string]string {
+func federationEgressLabels(instance *v1.ServiceMeshPeer) map[string]string {
 	return map[string]string{
 		"service.istio.io/canonical-name": instance.Spec.Gateways.Egress.Name,
 	}
 }
 
-func serviceAddressPort(addr string) (string, string) {
+func istiodServiceAddress(addr string) string {
 	portIndex := strings.Index(addr, ":")
 	if portIndex >= 0 {
-		return addr[:portIndex], addr[portIndex:]
+		return addr[:portIndex]
 	}
-	return addr, "80"
+	return addr
 }
 
-func (c *Controller) discoveryHostname(instance *v1alpha1.MeshFederation) string {
-	return fmt.Sprintf("discovery.%s.svc.%s.local", instance.Namespace, instance.Name)
-}
-
-func (c *Controller) discoveryService(instance *v1alpha1.MeshFederation) *config.Config {
+func (c *Controller) discoveryService(instance *v1.ServiceMeshPeer) *config.Config {
 	// This is used for routing out of the egress gateway, primarily to configure mtls for discovery and
 	// to give the gateway an endpoint to route to (i.e. it creates a cluster with an endpoint in the gateway).
 	// This should turn into a service entry for the other mesh's network.
 	name := discoveryResourceName(instance)
-	discoveryHost := instance.Spec.NetworkAddress
-	discoveryPort := common.DefaultDiscoveryPort
+	discoveryPort := instance.Spec.Remote.DiscoveryPort
+	if discoveryPort == 0 {
+		discoveryPort = common.DefaultDiscoveryPort
+	}
+	serviceSpec := &rawnetworking.ServiceEntry{
+		Hosts: []string{
+			common.DiscoveryServiceHostname(instance),
+		},
+		Location: rawnetworking.ServiceEntry_MESH_EXTERNAL,
+		Ports: []*rawnetworking.Port{
+			{
+				Name:       "https-discovery",
+				Number:     uint32(discoveryPort),
+				Protocol:   "HTTPS",
+				TargetPort: uint32(discoveryPort),
+			},
+		},
+		Resolution: rawnetworking.ServiceEntry_DNS,
+		ExportTo: []string{
+			".",
+		},
+	}
+	for _, address := range instance.Spec.Remote.Addresses {
+		serviceSpec.Endpoints = append(serviceSpec.Endpoints, &rawnetworking.WorkloadEntry{
+			Address: address,
+			Ports: map[string]uint32{
+				"https-discovery": uint32(discoveryPort),
+			},
+		})
+	}
 	service := &config.Config{
 		Meta: config.Meta{
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Serviceentries.Resource().GroupVersionKind(),
@@ -289,38 +312,16 @@ func (c *Controller) discoveryService(instance *v1alpha1.MeshFederation) *config
 			Labels: map[string]string{
 				"topology.istio.io/network": fmt.Sprintf("network-%s", instance.Name),
 			},
-		},
-		Spec: &rawnetworking.ServiceEntry{
-			Hosts: []string{
-				c.discoveryHostname(instance),
-			},
-			Location: rawnetworking.ServiceEntry_MESH_EXTERNAL,
-			Ports: []*rawnetworking.Port{
-				{
-					Name:       "https-discovery",
-					Number:     uint32(8188),
-					Protocol:   "HTTPS",
-					TargetPort: uint32(8188),
-				},
-			},
-			Resolution: rawnetworking.ServiceEntry_DNS,
-			Endpoints: []*rawnetworking.WorkloadEntry{
-				{
-					Address: discoveryHost,
-					Ports: map[string]uint32{
-						"https-discovery": uint32(discoveryPort),
-					},
-				},
-			},
-			ExportTo: []string{
-				".",
+			Annotations: map[string]string{
+				generationAnnotation: fmt.Sprintf("%d", instance.Generation),
 			},
 		},
+		Spec: serviceSpec,
 	}
 	return service
 }
 
-func (c *Controller) discoveryIngressGateway(instance *v1alpha1.MeshFederation) *config.Config {
+func (c *Controller) discoveryIngressGateway(instance *v1.ServiceMeshPeer) *config.Config {
 	// Gateway definition for handling inbound discovery requests
 	name := discoveryIngressResourceName(instance)
 	discoveryPort := common.DefaultDiscoveryPort
@@ -329,6 +330,10 @@ func (c *Controller) discoveryIngressGateway(instance *v1alpha1.MeshFederation)
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
 			Name:             name,
 			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation:            fmt.Sprintf("%d", instance.Generation),
+				ior.ShouldManageRouteAnnotation: "false",
+			},
 		},
 		Spec: &rawnetworking.Gateway{
 			Selector: federationIngressLabels(instance),
@@ -353,7 +358,7 @@ func (c *Controller) discoveryIngressGateway(instance *v1alpha1.MeshFederation)
 	return gateway
 }
 
-func (c *Controller) discoveryEgressGateway(instance *v1alpha1.MeshFederation) *config.Config {
+func (c *Controller) discoveryEgressGateway(instance *v1.ServiceMeshPeer) *config.Config {
 	// Gateway definition for routing outbound discovery.  This is used to terminate source mtls for discovery.
 	name := discoveryEgressResourceName(instance)
 	egressGatewayServiceName := fmt.Sprintf("%s.%s.svc.%s",
@@ -364,6 +369,10 @@ func (c *Controller) discoveryEgressGateway(instance *v1alpha1.MeshFederation) *
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
 			Name:             name,
 			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation:            fmt.Sprintf("%d", instance.Generation),
+				ior.ShouldManageRouteAnnotation: "false",
+			},
 		},
 		Spec: &rawnetworking.Gateway{
 			Selector: federationEgressLabels(instance),
@@ -386,7 +395,7 @@ func (c *Controller) discoveryEgressGateway(instance *v1alpha1.MeshFederation) *
 	return gateway
 }
 
-func (c *Controller) discoveryAuthorizationPolicy(instance *v1alpha1.MeshFederation) *config.Config {
+func (c *Controller) discoveryAuthorizationPolicy(instance *v1.ServiceMeshPeer) *config.Config {
 	// AuthorizationPolicy used to restrict inbound discovery requests to known clients.
 	name := discoveryResourceName(instance)
 	discoveryPort := common.DefaultDiscoveryPort
@@ -395,6 +404,9 @@ func (c *Controller) discoveryAuthorizationPolicy(instance *v1alpha1.MeshFederat
 			GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
 			Name:             name,
 			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation: fmt.Sprintf("%d", instance.Generation),
+			},
 		},
 		Spec: &rawsecurity.AuthorizationPolicy{
 			Selector: &rawtype.WorkloadSelector{
@@ -428,31 +440,31 @@ func (c *Controller) discoveryAuthorizationPolicy(instance *v1alpha1.MeshFederat
 	return ap
 }
 
-func (c *Controller) discoveryVirtualService(
-	instance *v1alpha1.MeshFederation, meshConfig *meshv1alpha1.MeshConfig) *config.Config {
+func (c *Controller) discoveryEgressVirtualService(instance *v1.ServiceMeshPeer) *config.Config {
 	// VirtualService used to route inbound and outbound discovery requests.
-	name := discoveryResourceName(instance)
-	istiodService, _ := serviceAddressPort(meshConfig.DefaultConfig.DiscoveryAddress)
-	if svcIndex := strings.LastIndex(istiodService, ".svc"); svcIndex >= 0 {
-		istiodService = istiodService[:svcIndex] + ".svc." + c.env.DomainSuffix
-	}
-	ingressGatewayName := fmt.Sprintf("%s/%s-ingress", instance.Namespace, name)
-	egressGatewayName := fmt.Sprintf("%s/%s-egress", instance.Namespace, name)
-	discoveryService := c.discoveryHostname(instance)
-	discoveryHost := instance.Spec.NetworkAddress
+	name := discoveryEgressResourceName(instance)
+	egressGatewayName := fmt.Sprintf("%s/%s", instance.Namespace, name)
+	egressGatewayService := fmt.Sprintf("%s.%s.svc.%s", instance.Spec.Gateways.Egress.Name, instance.Namespace, c.env.DomainSuffix)
+	discoveryService := common.DiscoveryServiceHostname(instance)
 	discoveryPort := common.DefaultDiscoveryPort
+	remoteDiscoveryPort := discoveryPort
+	if instance.Spec.Remote.DiscoveryPort > 0 {
+		remoteDiscoveryPort = int(instance.Spec.Remote.DiscoveryPort)
+	}
 	vs := &config.Config{
 		Meta: config.Meta{
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
 			Name:             name,
 			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation: fmt.Sprintf("%d", instance.Generation),
+			},
 		},
 		Spec: &rawnetworking.VirtualService{
 			Hosts: []string{
-				"*",
+				egressGatewayService,
 			},
 			Gateways: []string{
-				ingressGatewayName,
 				egressGatewayName,
 			},
 			ExportTo: []string{
@@ -461,20 +473,22 @@ func (c *Controller) discoveryVirtualService(
 			Http: []*rawnetworking.HTTPRoute{
 				{
 					// Outbound discovery requests
-					Name: fmt.Sprintf("%s-egress", name),
+					Name: name,
 					Match: []*rawnetworking.HTTPMatchRequest{
 						{
-							Gateways: []string{
-								egressGatewayName,
-							},
+							Port: uint32(discoveryPort),
 							Headers: map[string]*rawnetworking.StringMatch{
-								"discovery-address": {
+								"discovery-service": {
+									MatchType: &rawnetworking.StringMatch_Exact{
+										Exact: discoveryService,
+									},
+								},
+								"remote": {
 									MatchType: &rawnetworking.StringMatch_Exact{
-										Exact: discoveryHost,
+										Exact: fmt.Sprint(common.RemoteChecksum(instance.Spec.Remote)),
 									},
 								},
 							},
-							Port: uint32(discoveryPort),
 						},
 					},
 					Rewrite: &rawnetworking.HTTPRewrite{
@@ -486,7 +500,7 @@ func (c *Controller) discoveryVirtualService(
 							Destination: &rawnetworking.Destination{
 								Host: discoveryService,
 								Port: &rawnetworking.PortSelector{
-									Number: uint32(discoveryPort),
+									Number: uint32(remoteDiscoveryPort),
 								},
 								// to configure mtls appropriately
 								Subset: name,
@@ -494,6 +508,42 @@ func (c *Controller) discoveryVirtualService(
 						},
 					},
 				},
+			},
+		},
+	}
+	return vs
+}
+
+func (c *Controller) discoveryIngressVirtualService(
+	instance *v1.ServiceMeshPeer, meshConfig *meshv1alpha1.MeshConfig) *config.Config {
+	// VirtualService used to route inbound and outbound discovery requests.
+	name := discoveryIngressResourceName(instance)
+	istiodService := istiodServiceAddress(meshConfig.DefaultConfig.DiscoveryAddress)
+	if svcIndex := strings.LastIndex(istiodService, ".svc"); svcIndex >= 0 {
+		istiodService = istiodService[:svcIndex] + ".svc." + c.env.DomainSuffix
+	}
+	ingressGatewayName := fmt.Sprintf("%s/%s", instance.Namespace, name)
+	discoveryPort := common.DefaultDiscoveryPort
+	vs := &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             name,
+			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation: fmt.Sprintf("%d", instance.Generation),
+			},
+		},
+		Spec: &rawnetworking.VirtualService{
+			Hosts: []string{
+				"*",
+			},
+			Gateways: []string{
+				ingressGatewayName,
+			},
+			ExportTo: []string{
+				".",
+			},
+			Http: []*rawnetworking.HTTPRoute{
 				{
 					// inbound descovery /services/ requests
 					Name: fmt.Sprintf("%s-ingress-services", name),
@@ -505,14 +555,14 @@ func (c *Controller) discoveryVirtualService(
 							Port: uint32(discoveryPort),
 							Uri: &rawnetworking.StringMatch{
 								MatchType: &rawnetworking.StringMatch_Exact{
-									Exact: "/services/",
+									Exact: "/v1/services/",
 								},
 							},
 						},
 					},
 					Rewrite: &rawnetworking.HTTPRewrite{
 						Authority: istiodService,
-						Uri:       "/services/" + instance.Name,
+						Uri:       "/v1/services/" + instance.Name,
 					},
 					Route: []*rawnetworking.HTTPRouteDestination{
 						{
@@ -536,14 +586,14 @@ func (c *Controller) discoveryVirtualService(
 							Port: uint32(discoveryPort),
 							Uri: &rawnetworking.StringMatch{
 								MatchType: &rawnetworking.StringMatch_Exact{
-									Exact: "/watch",
+									Exact: "/v1/watch",
 								},
 							},
 						},
 					},
 					Rewrite: &rawnetworking.HTTPRewrite{
 						Authority: istiodService,
-						Uri:       "/watch/" + instance.Name,
+						Uri:       "/v1/watch/" + instance.Name,
 					},
 					Route: []*rawnetworking.HTTPRouteDestination{
 						{
@@ -562,16 +612,22 @@ func (c *Controller) discoveryVirtualService(
 	return vs
 }
 
-func (c *Controller) discoveryDestinationRule(instance *v1alpha1.MeshFederation) *config.Config {
+func (c *Controller) discoveryDestinationRule(instance *v1.ServiceMeshPeer) *config.Config {
 	// DestinationRule to configure mTLS for outbound discovery requests
-	name := discoveryResourceName(instance)
-	discoveryHost := c.discoveryHostname(instance)
-	discoveryPort := common.DefaultDiscoveryPort
+	name := discoveryEgressResourceName(instance)
+	discoveryHost := common.DiscoveryServiceHostname(instance)
+	discoveryPort := instance.Spec.Remote.DiscoveryPort
+	if discoveryPort == 0 {
+		discoveryPort = common.DefaultDiscoveryPort
+	}
 	dr := &config.Config{
 		Meta: config.Meta{
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
 			Name:             name,
 			Namespace:        instance.Namespace,
+			Annotations: map[string]string{
+				generationAnnotation: fmt.Sprintf("%d", instance.Generation),
+			},
 		},
 		Spec: &rawnetworking.DestinationRule{
 			// the "fake" discovery service
diff --git a/pkg/servicemesh/federation/example/config-poc/cleanup.sh b/pkg/servicemesh/federation/example/config-poc/cleanup.sh
index 02ae38baad..abb1c6c14e 100755
--- a/pkg/servicemesh/federation/example/config-poc/cleanup.sh
+++ b/pkg/servicemesh/federation/example/config-poc/cleanup.sh
@@ -14,12 +14,15 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-oc delete -n mesh1-system meshfederation/mesh2
-oc delete -n mesh2-system meshfederation/mesh1
+# shellcheck disable=SC1091
+source common.sh
 
-oc delete project mesh1-system
-oc delete project mesh2-system
-# oc delete project mesh1-exports
-# oc delete project mesh2-imports
-oc delete project mesh1-bookinfo
-oc delete project mesh2-bookinfo
+oc1 delete -n mesh1-system servicemeshpeer/mesh2
+oc2 delete -n mesh2-system servicemeshpeer/mesh1
+
+oc1 delete project mesh1-system
+oc2 delete project mesh2-system
+# oc1 delete project mesh1-exports
+# oc2 delete project mesh2-imports
+oc1 delete project mesh1-bookinfo
+oc2 delete project mesh2-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/common.sh b/pkg/servicemesh/federation/example/config-poc/common.sh
new file mode 100644
index 0000000000..df77127aa6
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/common.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+
+# Copyright Red Hat, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http:#www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+if [ ! -f "${MESH1_KUBECONFIG}" ] || [ ! -f "${MESH2_KUBECONFIG}" ]; then
+  echo "Environment variables MESH1_KUBECONFIG and/or MESH2_KUBECONFIG aren't set."
+  echo "Please point each to the kubeconfig file of the cluster you want to deploy"
+  echo "the federated service meshes to. The first cluster exports services;"
+  echo "the second imports them."
+  echo
+  echo "NOTE: You can use a single cluster by pointing both environment variables"
+  echo "to the same file. The meshes and apps are always deployed in different"
+  echo "namespaces (mesh1-system, mesh1-bookinfo, mesh2-system, mesh2-bookinfo),"
+  echo "so there are no conflicts."
+  exit 1
+fi
+
+oc1() {
+  if [ -f "${MESH1_KUBECONFIG}" ]; then
+    oc --kubeconfig="${MESH1_KUBECONFIG}" "$@"
+  else
+    oc "$@"
+  fi
+}
+
+oc2() {
+  if [ -f "${MESH2_KUBECONFIG}" ]; then
+    oc --kubeconfig="${MESH2_KUBECONFIG}" "$@"
+  else
+    oc "$@"
+  fi
+}
+
+log() {
+  echo
+  echo "##### $*"
+}
+
+log "Using the following kubeconfig files:
+mesh1: ${MESH1_KUBECONFIG}
+mesh2: ${MESH2_KUBECONFIG}"
+
diff --git a/pkg/servicemesh/federation/example/config-poc/export/configmap.yaml b/pkg/servicemesh/federation/example/config-poc/export/configmap.yaml
new file mode 100644
index 0000000000..416bbb2551
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/configmap.yaml
@@ -0,0 +1,8 @@
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: mesh2-ca-root-cert
+  namespace: mesh1-system
+data:
+  root-cert.pem: |-
+    {{MESH2_CERT}}
diff --git a/pkg/servicemesh/federation/example/config-poc/export/exportedserviceset.yaml b/pkg/servicemesh/federation/example/config-poc/export/exportedserviceset.yaml
new file mode 100644
index 0000000000..93371ae94a
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/exportedserviceset.yaml
@@ -0,0 +1,21 @@
+apiVersion: federation.maistra.io/v1
+kind: ExportedServiceSet
+metadata:
+  name: mesh2
+  namespace: mesh1-system
+spec:
+  exportRules:
+  - type: NameSelector
+    nameSelector:
+      namespace: mesh1-bookinfo
+      name: ratings
+      alias:
+        namespace: bookinfo
+        name: ratings
+  - type: NameSelector
+    nameSelector:
+      namespace: mesh1-bookinfo
+      name: mongodb
+      alias:
+        namespace: bookinfo
+        name: mongodb
diff --git a/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml b/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
deleted file mode 100644
index ac9df3375b..0000000000
--- a/pkg/servicemesh/federation/example/config-poc/export/meshfederation.yaml
+++ /dev/null
@@ -1,14 +0,0 @@
-apiVersion: maistra.io/v1alpha1
-kind: MeshFederation
-metadata:
-  name: mesh2
-  namespace: mesh1-system
-spec:
-  networkAddress: federation-ingress.mesh2-system.svc.cluster.local
-  gateways:
-    ingress:
-      name: federation-ingress
-    egress:
-      name: federation-egress
-  security:
-    clientID: cluster.local/ns/mesh2-system/sa/federation-egress-service-account
diff --git a/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml b/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
deleted file mode 100644
index 09ecbe5d61..0000000000
--- a/pkg/servicemesh/federation/example/config-poc/export/serviceexports.yaml
+++ /dev/null
@@ -1,23 +0,0 @@
-apiVersion: maistra.io/v1alpha1
-kind: ServiceExports
-metadata:
-  name: mesh2
-  namespace: mesh1-system
-spec:
-  exports:
-  - type: Name
-    nameSelector:
-      name:
-        namespace: mesh1-bookinfo
-        name: ratings
-      alias:
-        namespace: bookinfo
-        name: ratings
-  - type: Name
-    nameSelector:
-      name:
-        namespace: mesh1-bookinfo
-        name: mongodb
-      alias:
-        namespace: bookinfo
-        name: mongodb
diff --git a/pkg/servicemesh/federation/example/config-poc/export/servicemeshpeer.yaml b/pkg/servicemesh/federation/example/config-poc/export/servicemeshpeer.yaml
new file mode 100644
index 0000000000..7677c720b6
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/export/servicemeshpeer.yaml
@@ -0,0 +1,23 @@
+apiVersion: federation.maistra.io/v1
+kind: ServiceMeshPeer
+metadata:
+  name: mesh2
+  namespace: mesh1-system
+spec:
+  remote:
+    addresses:
+    - {{MESH2_ADDRESS}}
+    discoveryPort: {{MESH2_DISCOVERY_PORT}}
+    servicePort: {{MESH2_SERVICE_PORT}}
+  gateways:
+    ingress:
+      name: mesh2-ingress
+    egress:
+      name: mesh2-egress
+  security:
+    trustDomain: mesh2.local
+    clientID: mesh2.local/ns/mesh2-system/sa/mesh1-egress-service-account
+    # same as default, if certificateChain is omitted
+    certificateChain:
+      kind: ConfigMap
+      name: mesh2-ca-root-cert
diff --git a/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml b/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
index 6656049665..6db12d4d8e 100644
--- a/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
+++ b/pkg/servicemesh/federation/example/config-poc/export/smcp.yaml
@@ -5,18 +5,18 @@ metadata:
   namespace: mesh1-system
 spec:
   version: v2.1
-  cluster:
-    name: cluster1
-    network: network1
   runtime:
     defaults:
       container:
+        # for testing, to ensure we're always using the latest dev image
         imagePullPolicy: Always
   addons:
     grafana:
       enabled: true
     kiali:
       enabled: true
+    prometheus:
+      enabled: true
   tracing:
     type: Jaeger
     sampling: 10000
@@ -24,27 +24,25 @@ spec:
     accessLogging:
       file:
         name: /dev/stdout
-  techPreview:
-    meshConfig:
-      defaultConfig:
-        holdApplicationUntilProxyStarts: false
-        proxyMetadata:
-          ISTIO_META_DNS_CAPTURE: "true"
-          PROXY_XDS_VIA_AGENT: "true"
   gateways:
     additionalEgress:
-      federation-egress:
+      # egress gateway definition for sending requests from mesh2
+      mesh2-egress:
         enabled: true
         requestedNetworkView:
+        # we want to view services on mesh2's network
         - network-mesh2
         routerMode: sni-dnat
         service:
           metadata:
             labels:
-              federation.maistra.io/proxy: mesh2
+              # to prevent mesh2-egress's service from including default egress pods
+              federation.maistra.io/egress-for: mesh2
           ports:
+          # required for sending service requests to mesh2
           - port: 15443
             name: tls
+          # required for sending discovery requests to mesh2
           - port: 8188
             name: http-discovery
         runtime:
@@ -59,17 +57,24 @@ spec:
                 memory: 128Mi
               limits: {}
     additionalIngress:
-      federation-ingress:
+      # ingress gateway definition for handing requests from mesh2
+      mesh2-ingress:
         enabled: true
         routerMode: sni-dnat
         service:
           type: LoadBalancer
           metadata:
             labels:
-              federation.maistra.io/proxy: mesh2
+              # to prevent mesh2-ingress's service from including default ingress pods
+              federation.maistra.io/ingress-for: mesh2
+            annotations:
+              # use the network load balancer on AWS
+              service.beta.kubernetes.io/aws-load-balancer-type: nlb
           ports:
+          # required for handling service requests from mesh2
           - port: 15443
             name: tls
+          # required for handing discovery requests from mesh2
           - port: 8188
             name: https-discovery
         runtime:
@@ -83,3 +88,7 @@ spec:
                 cpu: 10m
                 memory: 128Mi
               limits: {}
+  security:
+    trust:
+      # unique trust domain for this mesh, mesh1
+      domain: mesh1.local
diff --git a/pkg/servicemesh/federation/example/config-poc/import/configmap.yaml b/pkg/servicemesh/federation/example/config-poc/import/configmap.yaml
new file mode 100644
index 0000000000..fec454406c
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/configmap.yaml
@@ -0,0 +1,8 @@
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: mesh1-ca-root-cert
+  namespace: mesh2-system
+data:
+  root-cert.pem: |-
+    {{MESH1_CERT}}
diff --git a/pkg/servicemesh/federation/example/config-poc/import/importedserviceset.yaml b/pkg/servicemesh/federation/example/config-poc/import/importedserviceset.yaml
new file mode 100644
index 0000000000..2ce6e317c5
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/importedserviceset.yaml
@@ -0,0 +1,16 @@
+apiVersion: federation.maistra.io/v1
+kind: ImportedServiceSet
+metadata:
+  name: mesh1
+  namespace: mesh2-system
+spec:
+  importRules:
+    - type: NameSelector
+      # Set to true to aggregate remote endpoint with local services.
+      # When true, services will be imported as <name>.mesh2-bookinfo.svc.cluster.local
+      importAsLocal: false
+      nameSelector:
+        namespace: bookinfo
+        alias:
+          # services will be imported as <name>.mesh2-bookinfo.svc.mesh1-imports.local
+          namespace: mesh2-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml b/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
deleted file mode 100644
index 46af8e6bfa..0000000000
--- a/pkg/servicemesh/federation/example/config-poc/import/meshfederation.yaml
+++ /dev/null
@@ -1,14 +0,0 @@
-apiVersion: maistra.io/v1alpha1
-kind: MeshFederation
-metadata:
-  name: mesh1
-  namespace: mesh2-system
-spec:
-  networkAddress: federation-ingress.mesh1-system.svc.cluster.local
-  gateways:
-    ingress:
-      name: federation-ingress
-    egress:
-      name: federation-egress
-  security:
-    clientID: cluster.local/ns/mesh1-system/sa/federation-egress-service-account
diff --git a/pkg/servicemesh/federation/example/config-poc/import/serviceimports.yaml b/pkg/servicemesh/federation/example/config-poc/import/serviceimports.yaml
deleted file mode 100644
index f325c0e3aa..0000000000
--- a/pkg/servicemesh/federation/example/config-poc/import/serviceimports.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
-apiVersion: maistra.io/v1alpha1
-kind: ServiceImports
-metadata:
-  name: mesh1
-  namespace: mesh2-system
-spec:
-  imports:
-    - type: Name
-      nameSelector:
-        # Set to true to aggregate remote endpoint with local services.
-        # When true, services will be imported as <name>.mesh2-bookinfo.svc.cluster.local
-        importAsLocal: false
-        name:
-          namespace: bookinfo
-        alias:
-          # services will be imported as <name>.mesh2-bookinfo.svc.mesh1-imports.local
-          namespace: mesh2-bookinfo
diff --git a/pkg/servicemesh/federation/example/config-poc/import/servicemeshpeer.yaml b/pkg/servicemesh/federation/example/config-poc/import/servicemeshpeer.yaml
new file mode 100644
index 0000000000..70904aa401
--- /dev/null
+++ b/pkg/servicemesh/federation/example/config-poc/import/servicemeshpeer.yaml
@@ -0,0 +1,23 @@
+apiVersion: federation.maistra.io/v1
+kind: ServiceMeshPeer
+metadata:
+  name: mesh1
+  namespace: mesh2-system
+spec:
+  remote:
+    addresses:
+    - {{MESH1_ADDRESS}}
+    discoveryPort: {{MESH1_DISCOVERY_PORT}}
+    servicePort: {{MESH1_SERVICE_PORT}}
+  gateways:
+    ingress:
+      name: mesh1-ingress
+    egress:
+      name: mesh1-egress
+  security:
+    trustDomain: mesh1.local
+    clientID: mesh1.local/ns/mesh1-system/sa/mesh2-egress-service-account
+    # same as default, if certificateChain is omitted
+    certificateChain:
+      kind: ConfigMap
+      name: mesh1-ca-root-cert
diff --git a/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml b/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
index 1aef5fa966..7ee06af73d 100644
--- a/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
+++ b/pkg/servicemesh/federation/example/config-poc/import/smcp.yaml
@@ -5,18 +5,18 @@ metadata:
   namespace: mesh2-system
 spec:
   version: v2.1
-  cluster:
-    name: cluster2
-    network: network2
   runtime:
     defaults:
       container:
+        # for testing, to ensure we're always using the latest dev image
         imagePullPolicy: Always
   addons:
     grafana:
       enabled: true
     kiali:
       enabled: true
+    prometheus:
+      enabled: true
   tracing:
     type: Jaeger
     sampling: 10000
@@ -24,27 +24,25 @@ spec:
     accessLogging:
       file:
         name: /dev/stdout
-  techPreview:
-    meshConfig:
-      defaultConfig:
-        holdApplicationUntilProxyStarts: false
-        proxyMetadata:
-          ISTIO_META_DNS_CAPTURE: "true"
-          PROXY_XDS_VIA_AGENT: "true"
   gateways:
     additionalEgress:
-      federation-egress:
+      # egress gateway definition for sending requests from mesh1
+      mesh1-egress:
         enabled: true
         requestedNetworkView:
+        # we want to view services on mesh1's network
         - network-mesh1
         routerMode: sni-dnat
         service:
           metadata:
             labels:
-              federation.maistra.io/proxy: mesh1
+              # to prevent mesh1-egress's service from including default egress pods
+              federation.maistra.io/egress-for: mesh1
           ports:
+          # required for sending service requests to mesh1
           - port: 15443
             name: tls
+          # required for sending discovery requests to mesh1
           - port: 8188
             name: http-discovery
         runtime:
@@ -59,17 +57,24 @@ spec:
                 memory: 128Mi
               limits: {}
     additionalIngress:
-      federation-ingress:
+      # ingress gateway definition for handing requests from mesh1
+      mesh1-ingress:
         enabled: true
         routerMode: sni-dnat
         service:
           type: LoadBalancer
           metadata:
             labels:
-              federation.maistra.io/proxy: mesh1
+              # to prevent mesh1-ingress's service from including default ingress pods
+              federation.maistra.io/ingress-for: mesh1
+            annotations:
+              # use the network load balancer on AWS
+              service.beta.kubernetes.io/aws-load-balancer-type: nlb
           ports:
+          # required for handling service requests from mesh1
           - port: 15443
             name: tls
+          # required for handing discovery requests from mesh1
           - port: 8188
             name: https-discovery
         runtime:
@@ -83,3 +88,7 @@ spec:
                 cpu: 10m
                 memory: 128Mi
               limits: {}
+  security:
+    trust:
+      # unique trust domain for this mesh, mesh2
+      domain: mesh2.local
diff --git a/pkg/servicemesh/federation/example/config-poc/install.sh b/pkg/servicemesh/federation/example/config-poc/install.sh
index 089da91db0..d161245f3a 100755
--- a/pkg/servicemesh/federation/example/config-poc/install.sh
+++ b/pkg/servicemesh/federation/example/config-poc/install.sh
@@ -14,55 +14,147 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-echo "Creating projects for mesh1"
-oc new-project mesh1-system || true
-oc new-project mesh1-bookinfo || true
-
-echo "Creating CA Secret for mesh1"
-oc create secret generic cacerts -n mesh1-system --from-file ./cacerts/
-
-echo "Installing control plane for mesh1"
-oc create -f export/smcp.yaml
-oc create -f export/smmr.yaml
-
-echo "Creating projects for mesh2"
-oc new-project mesh2-system || true
-oc new-project mesh2-bookinfo || true
-
-echo "Creating CA Secret for mesh2"
-oc create secret generic cacerts -n mesh2-system --from-file ./cacerts/
-
-echo "Installing control plane for mesh2"
-oc create -f import/smcp.yaml
-oc create -f import/smmr.yaml
-
-echo "Waiting for mesh1 installation to complete"
-oc wait --for condition=Ready -n mesh1-system smmr/default --timeout 180s
-
-echo "Enabling federation for mesh1"
-oc create -f export/meshfederation.yaml
-oc create -f export/serviceexports.yaml
-
-echo "Waiting for mesh2 installation to complete"
-oc wait --for condition=Ready -n mesh2-system smmr/default --timeout 180s
-
-echo "Enabling federation mesh2"
-oc create -f import/meshfederation.yaml
-oc create -f import/serviceimports.yaml
-
-echo "Installing mongodb k8s Service for mesh2"
-oc create -f import/mongodb-service.yaml
-
-echo "Installing VirtualServices for mesh2"
-oc create -f examples/mongodb-remote-virtualservice.yaml
-oc create -f examples/ratings-split-virtualservice.yaml
-
-echo "Please install bookinfo into mesh1-bookinfo and mesh2-bookinfo"
-echo "For the tcp example, install bookinfo-db into mesh1-bookinfo and"
-echo "bookinfo-ratings-v2 into mesh2-bookinfo, for example:"
-echo "    oc create -n mesh1-bookinfo bookinfo-db.yaml"
-echo "    oc create -n mesh2-bookinfo bookinfo-ratings-v2.yaml"
-echo ""
-echo "The meshes are configured to split ratings traffic in mesh2-bookinfo"
-echo "between mesh1 and mesh2.  The ratings-v2 service in mesh2 is configured to"
-echo "use the mongodb service in mesh1."
+set -e
+
+# shellcheck disable=SC1091
+source common.sh
+
+log "Creating projects for mesh1"
+oc1 new-project mesh1-system || true
+oc1 new-project mesh1-bookinfo || true
+
+log "Installing control plane for mesh1"
+oc1 apply -f export/smcp.yaml
+oc1 apply -f export/smmr.yaml
+
+log "Creating projects for mesh2"
+oc2 new-project mesh2-system || true
+oc2 new-project mesh2-bookinfo || true
+
+log "Installing control plane for mesh2"
+oc2 apply -f import/smcp.yaml
+oc2 apply -f import/smmr.yaml
+
+log "Waiting for mesh1 installation to complete"
+oc1 wait --for condition=Ready -n mesh1-system smmr/default --timeout 300s
+
+log "Waiting for mesh2 installation to complete"
+oc2 wait --for condition=Ready -n mesh2-system smmr/default --timeout 300s
+
+log "Retrieving root certificates"
+MESH1_CERT=$(oc1 get configmap -n mesh1-system istio-ca-root-cert -o jsonpath='{.data.root-cert\.pem}' | sed ':a;N;$!ba;s/\n/\\\n    /g')
+MESH2_CERT=$(oc2 get configmap -n mesh2-system istio-ca-root-cert -o jsonpath='{.data.root-cert\.pem}' | sed ':a;N;$!ba;s/\n/\\\n    /g')
+
+MESH1_DISCOVERY_PORT="8188"
+MESH1_SERVICE_PORT="15443"
+MESH2_DISCOVERY_PORT="8188"
+MESH2_SERVICE_PORT="15443"
+
+log "Retrieving ingress addresses"
+if [ "${MESH1_KUBECONFIG}" == "${MESH2_KUBECONFIG}" ]; then
+  echo "Single cluster detected; using cluster-local service for ingress"
+  MESH1_ADDRESS=mesh2-ingress.mesh1-system.svc.cluster.local
+  MESH2_ADDRESS=mesh1-ingress.mesh2-system.svc.cluster.local
+  echo MESH1_ADDRESS=${MESH1_ADDRESS}
+  echo MESH2_ADDRESS=${MESH2_ADDRESS}
+else
+  echo "Two clusters detected; using load-balancer service for ingress"
+  MESH1_ADDRESS=$(oc1 -n mesh1-system get svc mesh2-ingress -o jsonpath="{.status.loadBalancer.ingress[].ip}")
+  if [ -z "$MESH1_ADDRESS" ]; then
+    echo "No loadBalancer.ingress.ip found in service mesh2-ingress; trying hostname"
+    MESH1_ADDRESS=$(oc1 -n mesh1-system get svc mesh2-ingress -o jsonpath="{.status.loadBalancer.ingress[].hostname}")
+    if [ -z "$MESH1_ADDRESS" ]; then
+      echo "LoadBalancer service mesh2-ingress has no externally reachable ip or hostname; falling back to node ports"
+      MESH1_ADDRESS=$(oc1 get nodes -o json | jq -r '.items[0].status.addresses[] | select (.type == "Hostname") | .address')
+      MESH1_DISCOVERY_PORT=$(oc1 -n mesh1-system get svc mesh2-ingress -o json | jq '.spec.ports[] | select (.name == "https-discovery") | .nodePort')
+      MESH1_SERVICE_PORT=$(oc1 -n mesh1-system get svc mesh2-ingress -o json | jq '.spec.ports[] | select (.name == "tls") | .nodePort')
+      if [ -z "$MESH1_ADDRESS" ]; then
+        echo "FATAL: Could not determine address for mesh2-ingress in mesh1"
+        exit 1
+      fi
+    fi
+  fi
+  echo MESH1_ADDRESS="${MESH1_ADDRESS}"
+  echo MESH1_DISCOVERY_PORT="${MESH1_DISCOVERY_PORT}"
+  echo MESH1_SERVICE_PORT="${MESH1_SERVICE_PORT}"
+
+  MESH2_ADDRESS=$(oc2 -n mesh2-system get svc mesh1-ingress -o jsonpath="{.status.loadBalancer.ingress[].ip}")
+  if [ -z "$MESH2_ADDRESS" ]; then
+    echo "No loadBalancer.ingress.ip found in service mesh1-ingress; trying hostname"
+    MESH2_ADDRESS=$(oc2 -n mesh2-system get svc mesh1-ingress -o jsonpath="{.status.loadBalancer.ingress[].hostname}")
+    if [ -z "$MESH2_ADDRESS" ]; then
+      echo "LoadBalancer service mesh1-ingress has no externally reachable ip or hostname; falling back to node ports"
+      MESH2_ADDRESS=$(oc2 get nodes -o json | jq -r '.items[0].status.addresses[] | select (.type == "Hostname") | .address')
+      MESH2_DISCOVERY_PORT=$(oc2 -n mesh2-system get svc mesh1-ingress -o json | jq '.spec.ports[] | select (.name == "https-discovery") | .nodePort')
+      MESH2_SERVICE_PORT=$(oc2 -n mesh2-system get svc mesh1-ingress -o json | jq '.spec.ports[] | select (.name == "tls") | .nodePort')
+      if [ -z "$MESH2_ADDRESS" ]; then
+        echo "FATAL: Could not determine address for mesh1-ingress in mesh2"
+        exit 1
+      fi
+    fi
+  fi
+  echo MESH2_ADDRESS="${MESH2_ADDRESS}"
+  echo MESH2_DISCOVERY_PORT="${MESH2_DISCOVERY_PORT}"
+  echo MESH2_SERVICE_PORT="${MESH2_SERVICE_PORT}"
+fi
+
+log "Enabling federation for mesh1"
+sed "s:{{MESH2_CERT}}:$MESH2_CERT:g" export/configmap.yaml | oc1 apply -f -
+sed -e "s:{{MESH2_ADDRESS}}:$MESH2_ADDRESS:g" -e "s:{{MESH2_DISCOVERY_PORT}}:$MESH2_DISCOVERY_PORT:g" -e "s:{{MESH2_SERVICE_PORT}}:$MESH2_SERVICE_PORT:g" export/servicemeshpeer.yaml | oc1 apply -f -
+oc1 apply -f export/exportedserviceset.yaml
+
+log "Enabling federation for mesh2"
+sed "s:{{MESH1_CERT}}:$MESH1_CERT:g" import/configmap.yaml | oc2 apply -f -
+sed -e "s:{{MESH1_ADDRESS}}:$MESH1_ADDRESS:g" -e "s:{{MESH1_DISCOVERY_PORT}}:$MESH1_DISCOVERY_PORT:g" -e "s:{{MESH1_SERVICE_PORT}}:$MESH1_SERVICE_PORT:g" import/servicemeshpeer.yaml | oc2 apply -f -
+oc2 apply -f import/importedserviceset.yaml
+
+log "Installing bookinfo in mesh1"
+oc1 -n mesh1-bookinfo apply -f ../../../../../samples/bookinfo/platform/kube/bookinfo.yaml
+oc1 -n mesh1-bookinfo apply -f ../../../../../samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml
+oc1 -n mesh1-bookinfo apply -f ../../../../../samples/bookinfo/platform/kube/bookinfo-db.yaml
+oc1 -n mesh1-bookinfo apply -f ../../../../../samples/bookinfo/networking/destination-rule-all.yaml
+
+log "Installing bookinfo in mesh2"
+oc2 -n mesh2-bookinfo apply -f ../../../../../samples/bookinfo/platform/kube/bookinfo.yaml
+oc2 -n mesh2-bookinfo apply -f ../../../../../samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml
+oc2 -n mesh2-bookinfo apply -f ../../../../../samples/bookinfo/networking/bookinfo-gateway.yaml
+oc2 -n mesh2-bookinfo apply -f ../../../../../samples/bookinfo/networking/destination-rule-all.yaml
+oc2 -n mesh2-bookinfo apply -f ../../../../../samples/bookinfo/networking/virtual-service-reviews-v3.yaml
+
+log "Installing mongodb k8s Service for mesh2"
+oc2 apply -f import/mongodb-service.yaml
+
+log "Installing VirtualServices for mesh2"
+oc2 apply -f examples/mongodb-remote-virtualservice.yaml
+oc2 apply -f examples/ratings-split-virtualservice.yaml
+
+log "INSTALLATION COMPLETE
+
+Two service mesh control planes and two bookinfo applications are now installed.
+The first cluster (mesh1) contains the namespace mesh1-system and mesh1-bookinfo.
+The second cluster (mesh2) contains mesh2-system and mesh2-bookinfo.
+Mesh1 exports services, mesh2 imports them.
+
+The meshes are configured to split ratings traffic in mesh2-bookinfo between
+mesh1 and mesh2. The ratings-v2 service in mesh2 is configured to use the
+mongodb service in mesh1.
+
+Run the following command in the mesh1 cluster to check the connection status:
+
+  oc -n mesh1-system get servicemeshpeer mesh2 -o json | jq .status
+
+Run the following command to check the connection status in mesh2:
+
+  oc -n mesh2-system get servicemeshpeer mesh1 -o json | jq .status
+
+Check if services from mesh1 are imported into mesh2:
+
+  oc -n mesh2-system get importedservicesets mesh1 -o json | jq .status
+
+To see federation in action, use the bookinfo app in mesh2. For example:
+
+  1. Run this command in the mesh1 cluster: oc logs -n mesh1-bookinfo deploy/ratings-v2 -f
+  2. Run this command in the mesh2 cluster: oc logs -n mesh2-bookinfo deploy/ratings-v2 -f
+  3. Open http://$(oc2 -n mesh2-system get route istio-ingressgateway -o json | jq -r .spec.host)/productpage
+  4. Refresh the page several times and observe requests hitting either the mesh1 or the mesh2 cluster.
+"
diff --git a/pkg/servicemesh/federation/exports/controller.go b/pkg/servicemesh/federation/exports/controller.go
index 880d584437..ecb84d7faa 100644
--- a/pkg/servicemesh/federation/exports/controller.go
+++ b/pkg/servicemesh/federation/exports/controller.go
@@ -15,40 +15,34 @@
 package exports
 
 import (
-	"context"
 	"fmt"
+	"time"
 
-	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/errors"
-	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
-	maistrainformers "maistra.io/api/client/informers/externalversions/core/v1alpha1"
-	maistraclient "maistra.io/api/client/versioned"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	kubecontroller "istio.io/istio/pkg/kube/controller"
-	memberroll "istio.io/istio/pkg/servicemesh/controller"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 )
 
 const controllerName = "federation-exports-controller"
 
 type ServiceExportManager interface {
-	UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error
+	UpdateExportsForMesh(exports *v1.ExportedServiceSet) error
 	DeleteExportsForMesh(name string)
 }
 
 type Options struct {
-	common.ControllerOptions
+	ResourceManager      common.ResourceManager
+	ResyncPeriod         time.Duration
 	ServiceExportManager ServiceExportManager
 }
 
 type Controller struct {
 	*kubecontroller.Controller
-	cs            maistraclient.Interface
+	rm            common.ResourceManager
 	exportManager ServiceExportManager
 }
 
@@ -58,64 +52,25 @@ func NewController(opt Options) (*Controller, error) {
 		return nil, fmt.Errorf("invalid Options specified for federation export controller: %s", err)
 	}
 
-	cs, err := maistraclient.NewForConfig(opt.KubeClient.RESTConfig())
-	if err != nil {
-		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
-	}
-
-	mrc := opt.KubeClient.GetMemberRoll()
-
-	return internalNewController(cs, mrc, opt), nil
-}
-
-// allows using a fake client set for testing purposes
-func internalNewController(cs maistraclient.Interface, mrc memberroll.MemberRollController, opt Options) *Controller {
 	logger := common.Logger.WithLabels("component", controllerName)
-	var informer cache.SharedIndexInformer
-	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
-	if mrc != nil && false {
-		newInformer := func(namespace string) cache.SharedIndexInformer {
-			return cache.NewSharedIndexInformer(
-				&cache.ListWatch{
-					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-						return cs.CoreV1alpha1().ServiceExports(namespace).List(context.TODO(), options)
-					},
-					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-						return cs.CoreV1alpha1().ServiceExports(namespace).Watch(context.TODO(), options)
-					},
-				},
-				&v1alpha1.MeshFederation{},
-				opt.ResyncPeriod,
-				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
-			)
-		}
-
-		namespaceSet := xnsinformers.NewNamespaceSet()
-		informer = xnsinformers.NewMultiNamespaceInformer(namespaceSet, opt.ResyncPeriod, newInformer)
-		mrc.Register(namespaceSet, controllerName)
-	} else {
-		informer = maistrainformers.NewServiceExportsInformer(
-			cs, opt.Namespace, opt.ResyncPeriod,
-			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-	}
 
 	controller := &Controller{
-		cs:            cs,
+		rm:            opt.ResourceManager,
 		exportManager: opt.ServiceExportManager,
 	}
 	internalController := kubecontroller.NewController(kubecontroller.Options{
-		Informer:     informer,
+		Informer:     opt.ResourceManager.ExportsInformer().Informer(),
 		Logger:       logger,
 		ResyncPeriod: opt.ResyncPeriod,
 		Reconciler:   controller.reconcile,
 	})
 	controller.Controller = internalController
 
-	return controller
+	return controller, nil
 }
 
-func (c *Controller) HasSynced() bool {
-	return c.Controller.HasSynced()
+func (c *Controller) RunInformer(stopChan <-chan struct{}) {
+	// no-op, informer is started by the shared factory in Federation.Start()
 }
 
 func (c *Controller) reconcile(resourceName string) error {
@@ -124,13 +79,11 @@ func (c *Controller) reconcile(resourceName string) error {
 		c.Logger.Debugf("Completed reconciliation of ServiceExports %s", resourceName)
 	}()
 
-	ctx := context.TODO()
-
 	namespace, name, err := cache.SplitMetaNamespaceKey(resourceName)
 	if err != nil {
 		c.Logger.Errorf("error splitting resource name: %s", resourceName)
 	}
-	instance, err := c.cs.CoreV1alpha1().ServiceExports(namespace).Get(ctx, name, metav1.GetOptions{})
+	instance, err := c.rm.ExportsInformer().Lister().ExportedServiceSets(namespace).Get(name)
 	if err != nil {
 		if apierrors.IsNotFound(err) || apierrors.IsGone(err) {
 			// Request object not found, could have been deleted after reconcile request.
@@ -148,8 +101,8 @@ func (c *Controller) reconcile(resourceName string) error {
 
 func (opt Options) validate() error {
 	var allErrors []error
-	if opt.KubeClient == nil {
-		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	if opt.ResourceManager == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ResourceManager field must not be nil"))
 	}
 	if opt.ServiceExportManager == nil {
 		allErrors = append(allErrors, fmt.Errorf("the ServiceExportManager field must not be nil"))
diff --git a/pkg/servicemesh/federation/federation.go b/pkg/servicemesh/federation/federation.go
index 89254b5a9e..5b3354a904 100644
--- a/pkg/servicemesh/federation/federation.go
+++ b/pkg/servicemesh/federation/federation.go
@@ -15,15 +15,20 @@
 package federation
 
 import (
+	"crypto/tls"
 	"fmt"
+	"time"
 
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/errors"
+	maistraclient "maistra.io/api/client/versioned"
 
 	"istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/leaderelection"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/servicemesh/federation/discovery"
 	"istio.io/istio/pkg/servicemesh/federation/exports"
@@ -51,15 +56,18 @@ func init() {
 var schemas collection.Schemas
 
 type Options struct {
-	common.ControllerOptions
-	BindAddress       string
-	Env               *model.Environment
-	XDSUpdater        model.XDSUpdater
-	ServiceController *aggregate.Controller
-	LocalNetwork      string
-	LocalClusterID    string
-	IstiodNamespace   string
-	IstiodPodName     string
+	KubeClient          kube.Client
+	FederationNamespace string
+	ResyncPeriod        time.Duration
+	BindAddress         string
+	Env                 *model.Environment
+	XDSUpdater          model.XDSUpdater
+	ServiceController   *aggregate.Controller
+	LocalNetwork        string
+	LocalClusterID      string
+	IstiodNamespace     string
+	IstiodPodName       string
+	TLSConfig           *tls.Config
 }
 
 type Federation struct {
@@ -68,45 +76,64 @@ type Federation struct {
 	exportController    *exports.Controller
 	importController    *imports.Controller
 	discoveryController *discovery.Controller
+	leaderElection      *leaderelection.LeaderElection
 }
 
 func New(opt Options) (*Federation, error) {
 	if err := opt.validate(); err != nil {
 		return nil, err
 	}
-	name := types.NamespacedName{Name: opt.IstiodPodName, Namespace: opt.IstiodNamespace}
-	statusManager, err := status.NewManager(name, opt.KubeClient)
+	cs, err := maistraclient.NewForConfig(opt.KubeClient.RESTConfig())
+	if err != nil {
+		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
+	}
+	return internalNew(opt, cs)
+}
+
+func internalNew(opt Options, cs maistraclient.Interface) (*Federation, error) {
+	resourceManager, err := common.NewResourceManager(common.ControllerOptions{
+		KubeClient:   opt.KubeClient,
+		MaistraCS:    cs,
+		ResyncPeriod: opt.ResyncPeriod,
+		Namespace:    opt.FederationNamespace,
+	}, opt.KubeClient.GetMemberRoll())
 	if err != nil {
 		return nil, err
 	}
+	leaderElection := leaderelection.NewLeaderElection(opt.IstiodNamespace, opt.IstiodPodName, "servicemesh-federation", "test", opt.KubeClient)
+	name := types.NamespacedName{Name: opt.IstiodPodName, Namespace: opt.IstiodNamespace}
+	statusManager := status.NewManager(name, resourceManager, leaderElection)
 	configStore := newConfigStore()
 	server, err := server.NewServer(server.Options{
 		BindAddress: opt.BindAddress,
 		Env:         opt.Env,
 		Network:     opt.LocalNetwork,
 		ConfigStore: configStore,
+		TLSConfig:   opt.TLSConfig,
 	})
 	if err != nil {
 		return nil, err
 	}
 	exportController, err := exports.NewController(exports.Options{
-		ControllerOptions:    opt.ControllerOptions,
+		ResourceManager:      resourceManager,
+		ResyncPeriod:         opt.ResyncPeriod,
 		ServiceExportManager: server,
 	})
 	if err != nil {
 		return nil, err
 	}
 	importController, err := imports.NewController(imports.Options{
-		ControllerOptions: opt.ControllerOptions,
+		ResourceManager:   resourceManager,
+		ResyncPeriod:      opt.ResyncPeriod,
 		ServiceController: opt.ServiceController,
 	})
 	if err != nil {
 		return nil, err
 	}
 	discoveryController, err := discovery.NewController(discovery.Options{
+		ResourceManager:   resourceManager,
 		LocalClusterID:    opt.LocalClusterID,
 		LocalNetwork:      opt.LocalNetwork,
-		ControllerOptions: opt.ControllerOptions,
 		ServiceController: opt.ServiceController,
 		XDSUpdater:        opt.XDSUpdater,
 		Env:               opt.Env,
@@ -124,6 +151,7 @@ func New(opt Options) (*Federation, error) {
 		exportController:    exportController,
 		importController:    importController,
 		discoveryController: discoveryController,
+		leaderElection:      leaderElection,
 	}
 	return federation, nil
 }
@@ -141,6 +169,7 @@ func (f *Federation) RegisterServiceHandlers(serviceController *aggregate.Contro
 }
 
 func (f *Federation) StartControllers(stopCh <-chan struct{}) {
+	go f.leaderElection.Run(stopCh)
 	go f.exportController.Start(stopCh)
 	go f.importController.Start(stopCh)
 	f.discoveryController.Start(stopCh)
@@ -154,6 +183,10 @@ func (f *Federation) StartServer(stopCh <-chan struct{}) {
 	f.server.Run(stopCh)
 }
 
+func (f *Federation) GetTrustBundles() map[string]string {
+	return f.discoveryController.GetTrustBundles()
+}
+
 func (opt Options) validate() error {
 	var allErrors []error
 	if opt.KubeClient == nil {
diff --git a/pkg/servicemesh/federation/federation_test.go b/pkg/servicemesh/federation/federation_test.go
index 19ff27d32a..9915e52be1 100644
--- a/pkg/servicemesh/federation/federation_test.go
+++ b/pkg/servicemesh/federation/federation_test.go
@@ -21,7 +21,6 @@ import (
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/servicemesh/federation/common"
 )
 
 func TestInvalidOptions(t *testing.T) {
@@ -32,9 +31,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "client",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: nil,
-				},
+				KubeClient:        nil,
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               &model.Environment{},
@@ -43,9 +40,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "service-controller",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				KubeClient:        kube.NewFakeClient(),
 				ServiceController: nil,
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               &model.Environment{},
@@ -54,9 +49,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "xds-updater",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				KubeClient:        kube.NewFakeClient(),
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        nil,
 				Env:               &model.Environment{},
@@ -65,9 +58,7 @@ func TestInvalidOptions(t *testing.T) {
 		{
 			name: "env",
 			opt: Options{
-				ControllerOptions: common.ControllerOptions{
-					KubeClient: kube.NewFakeClient(),
-				},
+				KubeClient:        kube.NewFakeClient(),
 				ServiceController: &aggregate.Controller{},
 				XDSUpdater:        &v1alpha3.FakeXdsUpdater{},
 				Env:               nil,
diff --git a/pkg/servicemesh/federation/imports/controller.go b/pkg/servicemesh/federation/imports/controller.go
index 8ebfa701a7..345861f23f 100644
--- a/pkg/servicemesh/federation/imports/controller.go
+++ b/pkg/servicemesh/federation/imports/controller.go
@@ -15,38 +15,32 @@
 package imports
 
 import (
-	"context"
 	"fmt"
+	"time"
 
-	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/errors"
-	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
-	maistrainformers "maistra.io/api/client/informers/externalversions/core/v1alpha1"
-	maistraclient "maistra.io/api/client/versioned"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	"istio.io/istio/pilot/pkg/serviceregistry/federation"
-	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	kubecontroller "istio.io/istio/pkg/kube/controller"
-	memberroll "istio.io/istio/pkg/servicemesh/controller"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 )
 
 const controllerName = "federation-imports-controller"
 
 type Options struct {
-	common.ControllerOptions
+	ResourceManager   common.ResourceManager
+	ResyncPeriod      time.Duration
 	ServiceController *aggregate.Controller
 }
 
 type Controller struct {
 	*kubecontroller.Controller
-	cs                maistraclient.Interface
+	rm                common.ResourceManager
 	serviceController *aggregate.Controller
 }
 
@@ -56,64 +50,25 @@ func NewController(opt Options) (*Controller, error) {
 		return nil, fmt.Errorf("invalid Options specified for federation import controller: %s", err)
 	}
 
-	cs, err := maistraclient.NewForConfig(opt.KubeClient.RESTConfig())
-	if err != nil {
-		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
-	}
-
-	mrc := opt.KubeClient.GetMemberRoll()
-
-	return internalNewController(cs, mrc, opt), nil
-}
-
-// allows using a fake client set for testing purposes
-func internalNewController(cs maistraclient.Interface, mrc memberroll.MemberRollController, opt Options) *Controller {
 	logger := common.Logger.WithLabels("component", controllerName)
-	var informer cache.SharedIndexInformer
-	// Currently, we only watch istio system namespace for MeshFederation resources, which is why this block is disabled.
-	if mrc != nil && false {
-		newInformer := func(namespace string) cache.SharedIndexInformer {
-			return cache.NewSharedIndexInformer(
-				&cache.ListWatch{
-					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-						return cs.CoreV1alpha1().ServiceImports(namespace).List(context.TODO(), options)
-					},
-					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-						return cs.CoreV1alpha1().ServiceImports(namespace).Watch(context.TODO(), options)
-					},
-				},
-				&v1alpha1.MeshFederation{},
-				opt.ResyncPeriod,
-				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
-			)
-		}
-
-		namespaceSet := xnsinformers.NewNamespaceSet()
-		informer = xnsinformers.NewMultiNamespaceInformer(namespaceSet, opt.ResyncPeriod, newInformer)
-		mrc.Register(namespaceSet, controllerName)
-	} else {
-		informer = maistrainformers.NewServiceImportsInformer(
-			cs, opt.Namespace, opt.ResyncPeriod,
-			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-	}
 
 	controller := &Controller{
-		cs:                cs,
+		rm:                opt.ResourceManager,
 		serviceController: opt.ServiceController,
 	}
 	internalController := kubecontroller.NewController(kubecontroller.Options{
-		Informer:     informer,
+		Informer:     controller.rm.ImportsInformer().Informer(),
 		Logger:       logger,
 		ResyncPeriod: opt.ResyncPeriod,
 		Reconciler:   controller.reconcile,
 	})
 	controller.Controller = internalController
 
-	return controller
+	return controller, nil
 }
 
-func (c *Controller) HasSynced() bool {
-	return c.Controller.HasSynced()
+func (c *Controller) RunInformer(stopChan <-chan struct{}) {
+	// no-op, informer is started by the shared factory in Federation.Start()
 }
 
 func (c *Controller) reconcile(resourceName string) error {
@@ -122,13 +77,11 @@ func (c *Controller) reconcile(resourceName string) error {
 		c.Logger.Debugf("Completed reconciliation of ServiceImports %s", resourceName)
 	}()
 
-	ctx := context.TODO()
-
 	namespace, name, err := cache.SplitMetaNamespaceKey(resourceName)
 	if err != nil {
 		c.Logger.Errorf("error splitting resource name: %s", resourceName)
 	}
-	instance, err := c.cs.CoreV1alpha1().ServiceImports(namespace).Get(ctx, name, metav1.GetOptions{})
+	instance, err := c.rm.ImportsInformer().Lister().ImportedServiceSets(namespace).Get(name)
 	if err != nil {
 		if apierrors.IsNotFound(err) || apierrors.IsGone(err) {
 			// Request object not found, could have been deleted after reconcile request.
@@ -146,7 +99,7 @@ func (c *Controller) reconcile(resourceName string) error {
 }
 
 func (c *Controller) deleteImportsForMesh(namespace, name string) {
-	c.updateImportsForMesh(&v1alpha1.ServiceImports{
+	c.updateImportsForMesh(&v1.ImportedServiceSet{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      name,
 			Namespace: namespace,
@@ -154,22 +107,12 @@ func (c *Controller) deleteImportsForMesh(namespace, name string) {
 	})
 }
 
-func (c *Controller) updateImportsForMesh(instance *v1alpha1.ServiceImports) {
-	if instance.Name == "default" {
-		for _, registry := range c.serviceController.GetRegistries() {
-			if registry.Provider() == provider.Federation {
-				if federationRegistry, ok := registry.(*federation.Controller); ok {
-					federationRegistry.UpdateDefaultImportConfig(instance)
-				}
-			}
-		}
-	} else {
-		for _, registry := range c.serviceController.GetRegistries() {
-			if registry.Cluster().String() == instance.Name {
-				if federationRegistry, ok := registry.(*federation.Controller); ok {
-					federationRegistry.UpdateImportConfig(instance)
-					break
-				}
+func (c *Controller) updateImportsForMesh(instance *v1.ImportedServiceSet) {
+	for _, registry := range c.serviceController.GetRegistries() {
+		if registry.Cluster().String() == instance.Name {
+			if federationRegistry, ok := registry.(*federation.Controller); ok {
+				federationRegistry.UpdateImportConfig(instance)
+				break
 			}
 		}
 	}
@@ -177,8 +120,8 @@ func (c *Controller) updateImportsForMesh(instance *v1alpha1.ServiceImports) {
 
 func (opt Options) validate() error {
 	var allErrors []error
-	if opt.KubeClient == nil {
-		allErrors = append(allErrors, fmt.Errorf("the KubeClient field must not be nil"))
+	if opt.ResourceManager == nil {
+		allErrors = append(allErrors, fmt.Errorf("the ResourceManager field must not be nil"))
 	}
 	if opt.ServiceController == nil {
 		allErrors = append(allErrors, fmt.Errorf("the ServiceController field must not be nil"))
diff --git a/pkg/servicemesh/federation/model/model.go b/pkg/servicemesh/federation/model/model.go
index 7d759ac773..8f64cf2392 100644
--- a/pkg/servicemesh/federation/model/model.go
+++ b/pkg/servicemesh/federation/model/model.go
@@ -72,3 +72,7 @@ func (s *ServiceMessage) GenerateChecksum() uint64 {
 	}
 	return checksum
 }
+
+type TrustBundleProvider interface {
+	GetTrustBundles() map[string]string
+}
diff --git a/pkg/servicemesh/federation/server/routing.go b/pkg/servicemesh/federation/server/routing.go
index 8634dae0b3..94d7636cc5 100644
--- a/pkg/servicemesh/federation/server/routing.go
+++ b/pkg/servicemesh/federation/server/routing.go
@@ -24,6 +24,7 @@ import (
 	rawnetworking "istio.io/api/networking/v1alpha3"
 	rawsecurity "istio.io/api/security/v1beta1"
 	rawtype "istio.io/api/type/v1beta1"
+	"istio.io/istio/pilot/pkg/config/kube/ior"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -126,7 +127,7 @@ func (s *meshServer) createOrUpdateAuthorizationPolicy(target *federationmodel.S
 	name := fmt.Sprintf("federation-exports-%s", s.mesh.Name)
 	rawAP := s.configStore.Get(collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(), name, s.mesh.Namespace)
 	if rawAP == nil {
-		if s.mesh.Spec.Security == nil || s.mesh.Spec.Security.ClientID == "" {
+		if s.mesh.Spec.Security.ClientID == "" {
 			s.logger.Errorf("no ClientID specified for MeshFederation %s/%s: AuthorizationPolicy for exported services will not be created",
 				s.mesh.Namespace, s.mesh.Name)
 			return nil
@@ -162,7 +163,7 @@ func (s *meshServer) createOrUpdateAuthorizationPolicy(target *federationmodel.S
 										target.Hostname,
 									},
 									Ports: []string{
-										strconv.FormatInt(common.FederationPort, 10),
+										strconv.FormatInt(common.DefaultFederationPort, 10),
 									},
 								},
 							},
@@ -197,7 +198,7 @@ func (s *meshServer) createOrUpdateAuthorizationPolicy(target *federationmodel.S
 func (s *meshServer) gatewayForExport(source federationmodel.ServiceKey, target *federationmodel.ServiceMessage) *config.Config {
 	resourceName := createResourceName(s.mesh.Name, source)
 	mode := rawnetworking.ServerTLSSettings_ISTIO_MUTUAL
-	if s.mesh.Spec.Security != nil && s.mesh.Spec.Security.AllowDirectInbound {
+	if s.mesh.Spec.Security.AllowDirectInbound {
 		// XXX: this will not work, as the exported services will have a different domain suffix
 		// for example, svc.mesh2.local as opposed to svc.cluster.local
 		mode = rawnetworking.ServerTLSSettings_AUTO_PASSTHROUGH
@@ -207,6 +208,7 @@ func (s *meshServer) gatewayForExport(source federationmodel.ServiceKey, target
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Gateways.Resource().GroupVersionKind(),
 			Name:             resourceName,
 			Namespace:        s.mesh.Namespace,
+			Annotations:      map[string]string{ior.ShouldManageRouteAnnotation: "false"},
 		},
 		Spec: &rawnetworking.Gateway{
 			Selector: map[string]string{
@@ -221,7 +223,7 @@ func (s *meshServer) gatewayForExport(source federationmodel.ServiceKey, target
 					},
 					Port: &rawnetworking.Port{
 						Name:     "tls-federation",
-						Number:   uint32(common.FederationPort),
+						Number:   uint32(common.DefaultFederationPort),
 						Protocol: "TLS",
 					},
 					Tls: &rawnetworking.ServerTLSSettings{
diff --git a/pkg/servicemesh/federation/server/server.go b/pkg/servicemesh/federation/server/server.go
index eebe985add..7f6a9aa224 100644
--- a/pkg/servicemesh/federation/server/server.go
+++ b/pkg/servicemesh/federation/server/server.go
@@ -16,6 +16,7 @@ package server
 
 import (
 	"context"
+	"crypto/tls"
 	"encoding/json"
 	"fmt"
 	"net"
@@ -28,10 +29,11 @@ import (
 	"github.com/gorilla/mux"
 	hashstructure "github.com/mitchellh/hashstructure/v2"
 	"k8s.io/apimachinery/pkg/util/errors"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/visibility"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
 	"istio.io/istio/pkg/servicemesh/federation/status"
@@ -47,12 +49,13 @@ type Options struct {
 	Env         *model.Environment
 	Network     string
 	ConfigStore model.ConfigStoreCache
+	TLSConfig   *tls.Config
 }
 
 type FederationManager interface {
-	AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports, statusHandler status.Handler) error
-	DeleteMeshFederation(name string)
-	UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error
+	AddPeer(mesh *v1.ServiceMeshPeer, exports *v1.ExportedServiceSet, statusHandler status.Handler) error
+	DeletePeer(name string)
+	UpdateExportsForMesh(exports *v1.ExportedServiceSet) error
 	DeleteExportsForMesh(name string)
 }
 
@@ -67,8 +70,7 @@ type Server struct {
 
 	configStore model.ConfigStoreCache
 
-	defaultExportConfig *common.ServiceExporter
-	meshes              *sync.Map
+	meshes *sync.Map
 
 	// XXX: we need to decide if we really want to allow this or not.
 	// Gateway configuration is managed explicitly through the MeshFederation
@@ -96,6 +98,7 @@ func NewServer(opt Options) (*Server, error) {
 		httpServer: &http.Server{
 			ReadTimeout:    10 * time.Second,
 			MaxHeaderBytes: 1 << 20,
+			TLSConfig:      opt.TLSConfig,
 		},
 		configStore: opt.ConfigStore,
 		meshes:      &sync.Map{},
@@ -103,8 +106,8 @@ func NewServer(opt Options) (*Server, error) {
 		listener:    listener,
 	}
 	mux := mux.NewRouter()
-	mux.HandleFunc("/services/{mesh}", fed.handleServiceList)
-	mux.HandleFunc("/watch/{mesh}", fed.handleWatch)
+	mux.HandleFunc("/v1/services/{mesh}", fed.handleServiceList)
+	mux.HandleFunc("/v1/watch/{mesh}", fed.handleWatch)
 	fed.httpServer.Handler = mux
 	return fed, nil
 }
@@ -117,12 +120,12 @@ func exportDomainSuffix(mesh string) string {
 	return fmt.Sprintf("svc.%s-exports.local", mesh)
 }
 
-func (s *Server) ingressServiceName(mesh *v1alpha1.MeshFederation) string {
+func (s *Server) ingressServiceName(mesh *v1.ServiceMeshPeer) string {
 	return fmt.Sprintf("%s.%s.svc.%s", mesh.Spec.Gateways.Ingress.Name, mesh.Namespace, s.env.DomainSuffix)
 }
 
-func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alpha1.ServiceExports, statusHandler status.Handler) error {
-	exportConfig := common.NewServiceExporter(exports, s.defaultExportConfig, exportDomainSuffix(mesh.Name))
+func (s *Server) AddPeer(mesh *v1.ServiceMeshPeer, exports *v1.ExportedServiceSet, statusHandler status.Handler) error {
+	exportConfig := common.NewServiceExporter(exports, nil, exportDomainSuffix(mesh.Name))
 
 	untypedMeshServer, ok := s.meshes.Load(mesh.Name)
 	if untypedMeshServer != nil && ok {
@@ -145,7 +148,7 @@ func (s *Server) AddMeshFederation(mesh *v1alpha1.MeshFederation, exports *v1alp
 	return nil
 }
 
-func (s *Server) DeleteMeshFederation(name string) {
+func (s *Server) DeletePeer(name string) {
 	ms, ok := s.meshes.Load(name)
 	s.meshes.Delete(name)
 	if ms == nil || !ok {
@@ -154,12 +157,13 @@ func (s *Server) DeleteMeshFederation(name string) {
 	ms.(*meshServer).stop()
 }
 
-func (s *Server) UpdateExportsForMesh(exports *v1alpha1.ServiceExports) error {
+func (s *Server) UpdateExportsForMesh(exports *v1.ExportedServiceSet) error {
 	untypedMeshServer, ok := s.meshes.Load(exports.Name)
 	if untypedMeshServer == nil || !ok {
-		return fmt.Errorf("cannot update exporter for non-existent federation: %s", exports.Name)
+		// not really an error; ExportedServiceSet might just be created earlier than ServiceMeshPeer
+		return nil
 	}
-	untypedMeshServer.(*meshServer).updateExportConfig(common.NewServiceExporter(exports, s.defaultExportConfig, exportDomainSuffix(exports.Name)))
+	untypedMeshServer.(*meshServer).updateExportConfig(common.NewServiceExporter(exports, nil, exportDomainSuffix(exports.Name)))
 	return nil
 }
 
@@ -224,7 +228,7 @@ func (s *Server) handleWatch(response http.ResponseWriter, request *http.Request
 func (s *Server) Run(stopCh <-chan struct{}) {
 	s.logger.Infof("starting federation service discovery at %s", s.Addr())
 	go func() {
-		_ = s.httpServer.Serve(s.listener)
+		_ = s.httpServer.ServeTLS(s.listener, "", "")
 	}()
 	<-stopCh
 	_ = s.httpServer.Shutdown(context.TODO())
@@ -317,7 +321,7 @@ type meshServer struct {
 
 	env *model.Environment
 
-	mesh         *v1alpha1.MeshFederation
+	mesh         *v1.ServiceMeshPeer
 	exportConfig *common.ServiceExporter
 
 	statusHandler status.Handler
@@ -338,7 +342,7 @@ func (s *meshServer) updateExportConfig(exportConfig *common.ServiceExporter) {
 	s.resync()
 }
 
-func (s *meshServer) getServiceHostName(exportedName *v1alpha1.ServiceName) string {
+func (s *meshServer) getServiceHostName(exportedName *v1.ServiceName) string {
 	return fmt.Sprintf("%s.%s.svc.%s-exports.local", exportedName.Name, exportedName.Namespace, s.mesh.Name)
 }
 
@@ -350,7 +354,7 @@ func (s *meshServer) getServiceMessage(svc *model.Service, exportedName *federat
 		ServiceKey:   *exportedName,
 		ServicePorts: make([]*federationmodel.ServicePort, 0),
 	}
-	addServiceSAs := s.mesh.Spec.Security != nil && s.mesh.Spec.Security.AllowDirectInbound
+	addServiceSAs := s.mesh.Spec.Security.AllowDirectInbound
 	if addServiceSAs {
 		ret.ServiceAccounts = append([]string(nil), svc.ServiceAccounts...)
 	} else {
@@ -415,7 +419,7 @@ func getClientConnectionKey(request *http.Request) string {
 }
 
 func (s *meshServer) handleWatch(response http.ResponseWriter, request *http.Request) {
-	watch := make(chan *federationmodel.WatchEvent)
+	watch := make(chan *federationmodel.WatchEvent, 10)
 	s.watchMut.Lock()
 	s.currentWatches = append(s.currentWatches, watch)
 	s.watchMut.Unlock()
@@ -445,7 +449,12 @@ func (s *meshServer) handleWatch(response http.ResponseWriter, request *http.Req
 		var event *federationmodel.WatchEvent
 		select {
 		case event = <-watch:
+			if event == nil {
+				s.logger.Debugf("watch handler: watch closed")
+				return
+			}
 		case <-request.Context().Done():
+			s.logger.Debugf("watch handler: request context closed")
 			return
 		}
 		respBytes, err := json.Marshal(event)
@@ -468,6 +477,25 @@ func (s *meshServer) handleWatch(response http.ResponseWriter, request *http.Req
 	}
 }
 
+// checkServiceExportTo checks the service's `exportTo` field and returns
+// whether this service is reachable from the SMP object.
+func (s *meshServer) checkServiceExportTo(svc *model.Service) bool {
+	if len(svc.Attributes.ExportTo) == 0 {
+		return true
+	}
+	if value, exists := svc.Attributes.ExportTo[visibility.Public]; exists && value {
+		return true
+	}
+	if value, exists := svc.Attributes.ExportTo[visibility.Private]; exists && value && s.mesh.Namespace == svc.Attributes.Namespace {
+		return true
+	}
+	if value, exists := svc.Attributes.ExportTo[visibility.Instance(s.mesh.Namespace)]; exists && value {
+		return true
+	}
+
+	return false
+}
+
 func (s *meshServer) resync() {
 	s.Lock()
 	defer s.Unlock()
@@ -485,12 +513,24 @@ func (s *meshServer) resync() {
 			s.logger.Debugf("skipping external service: %s", svc.Hostname)
 			continue
 		}
+		svcKey := serviceKeyForService(svc)
 		svcMessage := s.getServiceMessage(svc, s.exportConfig.NameForService(svc))
 		if svcMessage == nil {
+			if existingSvc, found := s.currentServices[svcKey]; found {
+				s.logger.Debugf("export for service %+v as %+v deleted", svcKey, existingSvc.ServiceKey)
+				s.deleteService(svcKey, existingSvc)
+				continue
+			}
 			s.logger.Debugf("skipping export of service %+v, as it does not match any export filter", serviceKeyForService(svc))
 			continue
 		}
-		svcKey := serviceKeyForService(svc)
+
+		if !s.checkServiceExportTo(svc) {
+			s.logger.Debugf("skipping export of service %s/%s as its `exportTo` field prevents reachability from the gateway",
+				svc.Attributes.Namespace, svc.Attributes.Name)
+			continue
+		}
+
 		if existingSvc, found := s.currentServices[svcKey]; found {
 			if existingSvc.GenerateChecksum() == svcMessage.GenerateChecksum() {
 				continue
@@ -516,7 +556,7 @@ func (s *meshServer) resync() {
 // s must be lock()ed
 func (s *meshServer) updateGatewayServiceAccounts() bool {
 	oldSAs := s.gatewaySAs
-	if s.mesh.Spec.Security != nil && s.mesh.Spec.Security.AllowDirectInbound {
+	if s.mesh.Spec.Security.AllowDirectInbound {
 		// access is direct to the service, so we'll be using the service's SAs
 		s.gatewaySAs = nil
 		return len(oldSAs) > 0
@@ -529,7 +569,7 @@ func (s *meshServer) updateGatewayServiceAccounts() bool {
 		return false
 	}
 	s.gatewaySAs = append([]string(nil), gatewayService.ServiceAccounts...)
-	for _, si := range s.env.InstancesByPort(gatewayService, common.FederationPort, nil) {
+	for _, si := range s.env.InstancesByPort(gatewayService, common.DefaultFederationPort, nil) {
 		s.gatewaySAs = append(s.gatewaySAs, si.Endpoint.ServiceAccount)
 	}
 	sort.Slice(s.gatewaySAs, func(i, j int) bool { return strings.Compare(s.gatewaySAs[i], s.gatewaySAs[j]) < 0 })
diff --git a/pkg/servicemesh/federation/server/server_test.go b/pkg/servicemesh/federation/server/server_test.go
index 892f825b33..1817531dc1 100644
--- a/pkg/servicemesh/federation/server/server_test.go
+++ b/pkg/servicemesh/federation/server/server_test.go
@@ -15,104 +15,64 @@
 package server
 
 import (
+	"crypto/tls"
 	"encoding/json"
 	"io"
 	"io/ioutil"
 	"net/http"
+	"path/filepath"
 	"testing"
+	"time"
 
 	"github.com/google/go-cmp/cmp"
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"maistra.io/api/core/v1alpha1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	v1 "maistra.io/api/federation/v1"
 
 	configmemory "istio.io/istio/pilot/pkg/config/memory"
 	"istio.io/istio/pilot/pkg/model"
 	serviceregistrymemory "istio.io/istio/pilot/pkg/serviceregistry/memory"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/servicemesh/federation/common"
 	federationmodel "istio.io/istio/pkg/servicemesh/federation/model"
+	istioenv "istio.io/istio/pkg/test/env"
 )
 
-var ignoreChecksum = cmp.FilterPath(func(p cmp.Path) bool { return p.String() == "Checksum" }, cmp.Ignore())
-
-type fakeStatusHandler struct{}
-
-// Outbound connections
-func (m *fakeStatusHandler) WatchInitiated() {
-}
-
-func (m *fakeStatusHandler) Watching() {
-}
-
-func (m *fakeStatusHandler) WatchEventReceived() {
-}
-
-func (m *fakeStatusHandler) FullSyncComplete() {
-}
-
-func (m *fakeStatusHandler) WatchTerminated(status string) {
-}
-
-// Inbound connections
-func (m *fakeStatusHandler) RemoteWatchAccepted(source string) {
-}
-
-func (m *fakeStatusHandler) WatchEventSent(source string) {
-}
-
-func (m *fakeStatusHandler) FullSyncSent(source string) {
-}
-
-func (m *fakeStatusHandler) RemoteWatchTerminated(source string) {
-}
-
-// Exports
-func (m *fakeStatusHandler) ExportAdded(service federationmodel.ServiceKey, exportedName string) {
-}
-
-func (m *fakeStatusHandler) ExportUpdated(service federationmodel.ServiceKey, exportedName string) {
-}
-
-func (m *fakeStatusHandler) ExportRemoved(service federationmodel.ServiceKey) {
-}
-
-// Imports
-func (m *fakeStatusHandler) ImportAdded(service federationmodel.ServiceKey, exportedName string) {
-}
-
-func (m *fakeStatusHandler) ImportUpdated(service federationmodel.ServiceKey, exportedName string) {
-}
-
-func (m *fakeStatusHandler) ImportRemoved(exportedName string) {
-}
-
-// Write status
-func (m *fakeStatusHandler) Flush() error {
-	return nil
-}
+var (
+	ignoreChecksum = cmp.FilterPath(func(p cmp.Path) bool { return p.String() == "Checksum" }, cmp.Ignore())
+	httpsClient    = http.Client{
+		Transport: &http.Transport{
+			TLSClientConfig: &tls.Config{
+				InsecureSkipVerify: true,
+			},
+		},
+		Timeout: time.Second,
+	}
+)
 
 func TestServiceList(t *testing.T) {
-	federation := &v1alpha1.MeshFederation{
-		ObjectMeta: v1.ObjectMeta{
+	federation := &v1.ServiceMeshPeer{
+		ObjectMeta: metav1.ObjectMeta{
 			Name:      "test-remote",
 			Namespace: "istio-system-test",
 		},
-		Spec: v1alpha1.MeshFederationSpec{
-			Security: &v1alpha1.MeshFederationSecurity{
+		Spec: v1.ServiceMeshPeerSpec{
+			Security: v1.ServiceMeshPeerSecurity{
 				ClientID: "federation-egress.other-mesh.svc.cluster.local",
 			},
 		},
 	}
-	exportAllServices := &v1alpha1.ServiceExports{
-		ObjectMeta: v1.ObjectMeta{
+	exportAllServices := &v1.ExportedServiceSet{
+		ObjectMeta: metav1.ObjectMeta{
 			Name:      "test-remote",
 			Namespace: "istio-system-test",
 		},
-		Spec: v1alpha1.ServiceExportsSpec{
-			Exports: []v1alpha1.ServiceExportRule{
+		Spec: v1.ExportedServiceSetSpec{
+			ExportRules: []v1.ExportedServiceRule{
 				{
-					Type:         v1alpha1.NameSelectorType,
-					NameSelector: &v1alpha1.ServiceNameMapping{},
+					Type:         v1.NameSelectorType,
+					NameSelector: &v1.ServiceNameMapping{},
 				},
 			},
 		},
@@ -120,8 +80,8 @@ func TestServiceList(t *testing.T) {
 	testCases := []struct {
 		name           string
 		remoteName     string
-		defaultExports *v1alpha1.ServiceExports
-		serviceExports *v1alpha1.ServiceExports
+		defaultExports *v1.ExportedServiceSet
+		serviceExports *v1.ExportedServiceSet
 		services       []*model.Service
 		serviceEvents  []struct {
 			event model.Event
@@ -140,21 +100,21 @@ func TestServiceList(t *testing.T) {
 		{
 			name:       "exported service, no gateway",
 			remoteName: "test-remote",
-			serviceExports: &v1alpha1.ServiceExports{
-				ObjectMeta: v1.ObjectMeta{
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
 					Name:      "test-remote",
 					Namespace: "istio-system-test",
 				},
-				Spec: v1alpha1.ServiceExportsSpec{
-					Exports: []v1alpha1.ServiceExportRule{
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
 						{
-							Type: v1alpha1.NameSelectorType,
-							NameSelector: &v1alpha1.ServiceNameMapping{
-								Name: v1alpha1.ServiceName{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
 									Namespace: "bookinfo",
 									Name:      "productpage",
 								},
-								Alias: &v1alpha1.ServiceName{
+								Alias: &v1.ServiceName{
 									Namespace: "federation",
 									Name:      "service",
 								},
@@ -223,21 +183,21 @@ func TestServiceList(t *testing.T) {
 		{
 			name:       "exported service + gateway",
 			remoteName: "test-remote",
-			serviceExports: &v1alpha1.ServiceExports{
-				ObjectMeta: v1.ObjectMeta{
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
 					Name:      "test-remote",
 					Namespace: "istio-system-test",
 				},
-				Spec: v1alpha1.ServiceExportsSpec{
-					Exports: []v1alpha1.ServiceExportRule{
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
 						{
-							Type: v1alpha1.NameSelectorType,
-							NameSelector: &v1alpha1.ServiceNameMapping{
-								Name: v1alpha1.ServiceName{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
 									Namespace: "bookinfo",
 									Name:      "productpage",
 								},
-								Alias: &v1alpha1.ServiceName{
+								Alias: &v1.ServiceName{
 									Namespace: "federation",
 									Name:      "service",
 								},
@@ -408,6 +368,206 @@ func TestServiceList(t *testing.T) {
 				},
 			},
 		},
+		{
+			name:       "exportTo - service invisible",
+			remoteName: "test-remote",
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
+						{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+						ExportTo: map[visibility.Instance]bool{
+							visibility.None: true,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{},
+		},
+		{
+			name:       "exportTo - service private",
+			remoteName: "test-remote",
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
+						{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+						ExportTo: map[visibility.Instance]bool{
+							visibility.Private: true,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{},
+		},
+		{
+			name:       "exportTo - service private to the same namespace",
+			remoteName: "test-remote",
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
+						{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
+									Namespace: "istio-system-test",
+									Name:      "productpage",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "istio-system-test",
+						ExportTo: map[visibility.Instance]bool{
+							visibility.Private: true,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				Services: []*federationmodel.ServiceMessage{
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "productpage",
+							Namespace: "istio-system-test",
+							Hostname:  "productpage.istio-system-test.svc.test-remote-exports.local",
+						},
+					},
+				},
+			},
+		},
+		{
+			name:       "exportTo - foreign namespace",
+			remoteName: "test-remote",
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
+						{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+						ExportTo: map[visibility.Instance]bool{
+							visibility.Instance("foreign-namespace"): true,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{},
+		},
+		{
+			name:       "exportTo - same namespace as control plane",
+			remoteName: "test-remote",
+			serviceExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-remote",
+					Namespace: "istio-system-test",
+				},
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
+						{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
+									Namespace: "bookinfo",
+									Name:      "productpage",
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+						ExportTo: map[visibility.Instance]bool{
+							visibility.Instance("istio-system-test"): true,
+						},
+					},
+				},
+			},
+			expectedMessage: federationmodel.ServiceListMessage{
+				Services: []*federationmodel.ServiceMessage{
+					{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "productpage",
+							Namespace: "bookinfo",
+							Hostname:  "productpage.bookinfo.svc.test-remote-exports.local",
+						},
+					},
+				},
+			},
+		},
 	}
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
@@ -416,18 +576,12 @@ func TestServiceList(t *testing.T) {
 			env := &model.Environment{
 				ServiceDiscovery: serviceDiscovery,
 			}
-
-			s, _ := NewServer(Options{
-				BindAddress: "127.0.0.1:0",
-				Env:         env,
-				Network:     "network1",
-				ConfigStore: configmemory.NewController(configmemory.Make(Schemas)),
-			})
+			s := createServer(env)
 			stopCh := make(chan struct{})
 			go s.Run(stopCh)
 			defer close(stopCh)
 			s.resyncNetworkGateways()
-			s.AddMeshFederation(federation, tc.serviceExports, &fakeStatusHandler{})
+			s.AddPeer(federation, tc.serviceExports, &common.FakeStatusHandler{})
 			for _, e := range tc.serviceEvents {
 				s.UpdateService(e.svc, e.event)
 			}
@@ -443,8 +597,27 @@ func TestServiceList(t *testing.T) {
 	}
 }
 
+func createServer(env *model.Environment) *Server {
+	cert, _ := tls.LoadX509KeyPair(
+		filepath.Join(istioenv.IstioSrc, "./tests/testdata/certs/pilot/cert-chain.pem"),
+		filepath.Join(istioenv.IstioSrc, "./tests/testdata/certs/pilot/key.pem"))
+
+	s, _ := NewServer(Options{
+		BindAddress: "127.0.0.1:0",
+		Env:         env,
+		Network:     "network1",
+		ConfigStore: configmemory.NewController(configmemory.Make(Schemas)),
+		TLSConfig: &tls.Config{
+			Certificates: []tls.Certificate{
+				cert,
+			},
+		},
+	})
+	return s
+}
+
 func getServiceList(t *testing.T, addr, remoteName string) federationmodel.ServiceListMessage {
-	resp, err := http.Get("http://" + addr + "/services/" + remoteName)
+	resp, err := httpsClient.Get("https://" + addr + "/v1/services/" + remoteName)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -464,32 +637,32 @@ func getServiceList(t *testing.T, addr, remoteName string) federationmodel.Servi
 }
 
 func TestWatch(t *testing.T) {
-	federation := &v1alpha1.MeshFederation{
-		ObjectMeta: v1.ObjectMeta{
+	federation := &v1.ServiceMeshPeer{
+		ObjectMeta: metav1.ObjectMeta{
 			Name:      "test-remote",
 			Namespace: "istio-system-test",
 		},
-		Spec: v1alpha1.MeshFederationSpec{
-			Security: &v1alpha1.MeshFederationSecurity{
+		Spec: v1.ServiceMeshPeerSpec{
+			Security: v1.ServiceMeshPeerSecurity{
 				ClientID: "federation-egress.other-mesh.svc.cluster.local",
 			},
 		},
 	}
-	exportProductPage := &v1alpha1.ServiceExports{
-		ObjectMeta: v1.ObjectMeta{
+	exportProductPage := &v1.ExportedServiceSet{
+		ObjectMeta: metav1.ObjectMeta{
 			Name:      "test-remote",
 			Namespace: "istio-system-test",
 		},
-		Spec: v1alpha1.ServiceExportsSpec{
-			Exports: []v1alpha1.ServiceExportRule{
+		Spec: v1.ExportedServiceSetSpec{
+			ExportRules: []v1.ExportedServiceRule{
 				{
-					Type: v1alpha1.NameSelectorType,
-					NameSelector: &v1alpha1.ServiceNameMapping{
-						Name: v1alpha1.ServiceName{
+					Type: v1.NameSelectorType,
+					NameSelector: &v1.ServiceNameMapping{
+						ServiceName: v1.ServiceName{
 							Namespace: "bookinfo",
 							Name:      "productpage",
 						},
-						Alias: &v1alpha1.ServiceName{
+						Alias: &v1.ServiceName{
 							Namespace: "federation",
 							Name:      "service",
 						},
@@ -501,9 +674,9 @@ func TestWatch(t *testing.T) {
 	testCases := []struct {
 		name           string
 		remoteName     string
-		defaultExports *v1alpha1.ServiceExports
-		serviceExports *v1alpha1.ServiceExports
-		updatedExports *v1alpha1.ServiceExports
+		defaultExports *v1.ExportedServiceSet
+		serviceExports *v1.ExportedServiceSet
+		updatedExports *v1.ExportedServiceSet
 		services       []*model.Service
 		serviceEvents  []struct {
 			event model.Event
@@ -593,21 +766,21 @@ func TestWatch(t *testing.T) {
 			name:           "no gateways, service exported name changes, filtered service",
 			remoteName:     "test-remote",
 			serviceExports: exportProductPage,
-			updatedExports: &v1alpha1.ServiceExports{
-				ObjectMeta: v1.ObjectMeta{
+			updatedExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
 					Name:      "test-remote",
 					Namespace: "istio-system-test",
 				},
-				Spec: v1alpha1.ServiceExportsSpec{
-					Exports: []v1alpha1.ServiceExportRule{
+				Spec: v1.ExportedServiceSetSpec{
+					ExportRules: []v1.ExportedServiceRule{
 						{
-							Type: v1alpha1.NameSelectorType,
-							NameSelector: &v1alpha1.ServiceNameMapping{
-								Name: v1alpha1.ServiceName{
+							Type: v1.NameSelectorType,
+							NameSelector: &v1.ServiceNameMapping{
+								ServiceName: v1.ServiceName{
 									Namespace: "bookinfo",
 									Name:      "productpage",
 								},
-								Alias: &v1alpha1.ServiceName{
+								Alias: &v1.ServiceName{
 									Namespace: "cluster",
 									Name:      "service",
 								},
@@ -727,6 +900,52 @@ func TestWatch(t *testing.T) {
 				},
 			},
 		},
+		{
+			name:           "service export removed",
+			remoteName:     "test-remote",
+			serviceExports: exportProductPage,
+			updatedExports: &v1.ExportedServiceSet{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "test-remote",
+				},
+			},
+			services: []*model.Service{
+				{
+					Hostname: "productpage.bookinfo.svc.cluster.local",
+					Attributes: model.ServiceAttributes{
+						Name:      "productpage",
+						Namespace: "bookinfo",
+					},
+					Ports: model.PortList{
+						&model.Port{
+							Name:     "https",
+							Protocol: protocol.HTTPS,
+							Port:     443,
+						},
+					},
+				},
+			},
+			serviceEvents: nil,
+			expectedWatchEvents: []*federationmodel.WatchEvent{
+				{
+					Action: federationmodel.ActionDelete,
+					Service: &federationmodel.ServiceMessage{
+						ServiceKey: federationmodel.ServiceKey{
+							Name:      "service",
+							Namespace: "federation",
+							Hostname:  "service.federation.svc.test-remote-exports.local",
+						},
+						ServicePorts: []*federationmodel.ServicePort{
+							{
+								Name:     "https",
+								Port:     443,
+								Protocol: "HTTPS",
+							},
+						},
+					},
+				},
+			},
+		},
 	}
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
@@ -735,23 +954,17 @@ func TestWatch(t *testing.T) {
 			env := &model.Environment{
 				ServiceDiscovery: serviceDiscovery,
 			}
-
-			s, _ := NewServer(Options{
-				BindAddress: "127.0.0.1:0",
-				Env:         env,
-				Network:     "network1",
-				ConfigStore: configmemory.NewController(configmemory.Make(Schemas)),
-			})
+			s := createServer(env)
 			stopCh := make(chan struct{})
 			go s.Run(stopCh)
 			defer close(stopCh)
 			s.resyncNetworkGateways()
-			s.AddMeshFederation(federation, tc.serviceExports, &fakeStatusHandler{})
-			req, err := http.NewRequest("GET", "http://"+s.Addr()+"/watch/"+tc.remoteName, nil)
+			s.AddPeer(federation, tc.serviceExports, &common.FakeStatusHandler{})
+			req, err := http.NewRequest("GET", "https://"+s.Addr()+"/v1/watch/"+tc.remoteName, nil)
 			if err != nil {
 				t.Fatal(err)
 			}
-			resp, err := http.DefaultClient.Do(req)
+			resp, err := httpsClient.Do(req)
 			if err != nil {
 				t.Fatal(err)
 			}
diff --git a/pkg/servicemesh/federation/status/handler.go b/pkg/servicemesh/federation/status/handler.go
index 878da4fe2b..b3192123f1 100644
--- a/pkg/servicemesh/federation/status/handler.go
+++ b/pkg/servicemesh/federation/status/handler.go
@@ -15,15 +15,20 @@
 package status
 
 import (
+	"context"
+	"encoding/json"
 	"reflect"
 	"sort"
 	"strings"
 	"sync"
 	"time"
 
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
-	"maistra.io/api/core/v1alpha1"
+	utilerrors "k8s.io/apimachinery/pkg/util/errors"
+	"k8s.io/apimachinery/pkg/util/strategicpatch"
+	v1 "maistra.io/api/federation/v1"
 
 	"istio.io/istio/pkg/servicemesh/federation/model"
 	"istio.io/pkg/log"
@@ -37,17 +42,18 @@ const (
 
 func newHandler(manager *manager, mesh types.NamespacedName) *handler {
 	return &handler{
-		manager:   manager,
-		mesh:      mesh,
-		logger:    manager.logger.WithLabels("mesh", mesh.String()),
-		discovery: map[string]*v1alpha1.DiscoveryRemoteStatus{},
-		exports:   map[v1alpha1.ServiceKey]v1alpha1.MeshServiceMapping{},
-		imports:   map[string]v1alpha1.MeshServiceMapping{},
-		status: v1alpha1.FederationStatusDetails{
-			Mesh:    mesh.String(),
-			Exports: []v1alpha1.MeshServiceMapping{},
-			Imports: []v1alpha1.MeshServiceMapping{},
-		},
+		manager:        manager,
+		mesh:           mesh,
+		logger:         manager.logger.WithLabels("peer", mesh.String()),
+		discovery:      map[string]*v1.DiscoveryRemoteStatus{},
+		exports:        map[v1.ServiceKey]v1.PeerServiceMapping{},
+		exportsStatus:  []v1.PeerServiceMapping{},
+		imports:        map[string]v1.PeerServiceMapping{},
+		importsStatus:  []v1.PeerServiceMapping{},
+		discoveryDirty: true,
+		watchDirty:     true,
+		exportsDirty:   true,
+		importsDirty:   true,
 	}
 }
 
@@ -57,16 +63,18 @@ type handler struct {
 	mesh    types.NamespacedName
 	logger  *log.Scope
 
-	discovery map[string]*v1alpha1.DiscoveryRemoteStatus
-	exports   map[v1alpha1.ServiceKey]v1alpha1.MeshServiceMapping
-	imports   map[string]v1alpha1.MeshServiceMapping
+	discovery map[string]*v1.DiscoveryRemoteStatus
+	exports   map[v1.ServiceKey]v1.PeerServiceMapping
+	imports   map[string]v1.PeerServiceMapping
 
 	discoveryDirty bool
 	exportsDirty   bool
 	importsDirty   bool
-	dirty          bool
+	watchDirty     bool
 
-	status v1alpha1.FederationStatusDetails
+	discoveryStatus v1.PeerDiscoveryStatus
+	exportsStatus   []v1.PeerServiceMapping
+	importsStatus   []v1.PeerServiceMapping
 }
 
 var _ Handler = (*handler)(nil)
@@ -78,10 +86,10 @@ func (h *handler) WatchInitiated() {
 	h.mu.Lock()
 	defer h.mu.Unlock()
 
-	h.status.Discovery.Watch.Connected = false
-	h.status.Discovery.Watch.LastConnected = metav1.Now()
+	h.discoveryStatus.Watch.Connected = false
+	h.discoveryStatus.Watch.LastConnected = metav1.Now()
 
-	h.dirty = true
+	h.watchDirty = true
 
 	// we don't flush on initiation, as we expect either a Watching() or
 	// WatchTerminated() immediately following this
@@ -94,13 +102,13 @@ func (h *handler) Watching() {
 		h.mu.Lock()
 		defer h.mu.Unlock()
 
-		h.status.Discovery.Watch.Connected = true
+		h.discoveryStatus.Watch.Connected = true
 
-		h.dirty = true
+		h.watchDirty = true
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
@@ -110,9 +118,9 @@ func (h *handler) WatchEventReceived() {
 	h.mu.Lock()
 	defer h.mu.Unlock()
 
-	h.status.Discovery.Watch.LastEvent = metav1.Now()
+	h.discoveryStatus.Watch.LastEvent = metav1.Now()
 
-	h.dirty = true
+	h.watchDirty = true
 }
 
 func (h *handler) FullSyncComplete() {
@@ -122,13 +130,13 @@ func (h *handler) FullSyncComplete() {
 		h.mu.Lock()
 		defer h.mu.Unlock()
 
-		h.status.Discovery.Watch.LastFullSync = metav1.Now()
+		h.discoveryStatus.Watch.LastFullSync = metav1.Now()
 
-		h.dirty = true
+		h.watchDirty = true
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
@@ -139,18 +147,18 @@ func (h *handler) WatchTerminated(status string) {
 		h.mu.Lock()
 		defer h.mu.Unlock()
 
-		if h.status.Discovery.Watch.Connected {
+		if h.discoveryStatus.Watch.Connected {
 			// only update the disconnect time if we successfully connected
-			h.status.Discovery.Watch.LastDisconnect = metav1.Now()
+			h.discoveryStatus.Watch.LastDisconnect = metav1.Now()
 		}
-		h.status.Discovery.Watch.Connected = false
-		h.status.Discovery.Watch.LastDisconnectStatus = status
+		h.discoveryStatus.Watch.Connected = false
+		h.discoveryStatus.Watch.LastDisconnectStatus = status
 
-		h.dirty = true
+		h.watchDirty = true
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
@@ -166,7 +174,7 @@ func (h *handler) RemoteWatchAccepted(source string) {
 		if ok {
 			h.logger.Debugf("RemoteWatchAccepted called when watch status already exists: %s", source)
 		} else {
-			remoteStatus = &v1alpha1.DiscoveryRemoteStatus{
+			remoteStatus = &v1.DiscoveryRemoteStatus{
 				Source: source,
 			}
 			h.discovery[source] = remoteStatus
@@ -178,7 +186,7 @@ func (h *handler) RemoteWatchAccepted(source string) {
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
@@ -212,7 +220,7 @@ func (h *handler) FullSyncSent(source string) {
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
@@ -236,20 +244,20 @@ func (h *handler) RemoteWatchTerminated(source string) {
 	}()
 
 	if err := h.Flush(); err != nil {
-		h.logger.Errorf("error updating status for MeshFederation %s: %s", h.mesh, err)
+		h.logger.Errorf("error updating status for ServiceMeshPeer %s: %s", h.mesh, err)
 	}
 }
 
-func statusServiceKeyFor(service model.ServiceKey) v1alpha1.ServiceKey {
-	return v1alpha1.ServiceKey{
+func statusServiceKeyFor(service model.ServiceKey) v1.ServiceKey {
+	return v1.ServiceKey{
 		Name:      service.Name,
 		Namespace: service.Namespace,
 		Hostname:  service.Hostname,
 	}
 }
 
-func statusMappingFor(service model.ServiceKey, exportedName string) v1alpha1.MeshServiceMapping {
-	return v1alpha1.MeshServiceMapping{
+func statusMappingFor(service model.ServiceKey, exportedName string) v1.PeerServiceMapping {
+	return v1.PeerServiceMapping{
 		LocalService: statusServiceKeyFor(service),
 		ExportedName: exportedName,
 	}
@@ -352,8 +360,10 @@ func (h *handler) ImportRemoved(exportedName string) {
 	h.importsDirty = true
 }
 
-func (h *handler) isDirty() bool {
-	return h.dirty || h.exportsDirty || h.importsDirty || h.discoveryDirty
+func (h *handler) shouldPush() (bool, bool) {
+	// only push exports/imports if we're the leader
+	isLeader := h.manager.IsLeader()
+	return h.watchDirty || h.discoveryDirty || (isLeader && (h.exportsDirty || h.importsDirty)), isLeader
 }
 
 func (h *handler) pruneOldRemotes() {
@@ -373,32 +383,19 @@ func (h *handler) pruneOldRemotes() {
 
 // Write status
 func (h *handler) Flush() error {
-	push := func() bool {
-		h.mu.Lock()
-		defer h.mu.Unlock()
-		h.pruneOldRemotes()
-		return h.isDirty()
-	}()
-
-	if push {
-		return h.manager.PushStatus()
-	}
-	return nil
-}
-
-func (h *handler) currentStatus() *v1alpha1.FederationStatusDetails {
 	h.mu.Lock()
 	defer h.mu.Unlock()
-
 	h.pruneOldRemotes()
-	if !h.isDirty() {
-		// nothing to do
-		return h.status.DeepCopy()
+	push, isLeader := h.shouldPush()
+
+	if !push {
+		h.logger.Debugf("no status changes to push")
+		return nil
 	}
 
 	// see if we need to update the export status
 	if h.exportsDirty {
-		exports := []v1alpha1.MeshServiceMapping{}
+		var exports []v1.PeerServiceMapping
 		for _, mapping := range h.exports {
 			exports = append(exports, mapping)
 		}
@@ -413,24 +410,24 @@ func (h *handler) currentStatus() *v1alpha1.FederationStatusDetails {
 			}
 			return diff < 0
 		})
-		h.status.Exports = exports
+		h.exportsStatus = exports
 		h.exportsDirty = false
 	}
 
 	// see if we need to update the import status
 	if h.importsDirty {
-		imports := []v1alpha1.MeshServiceMapping{}
+		var imports []v1.PeerServiceMapping
 		for _, mapping := range h.imports {
 			imports = append(imports, mapping)
 		}
 		sort.Slice(imports, func(i, j int) bool { return strings.Compare(imports[i].ExportedName, imports[j].ExportedName) < 0 })
-		h.status.Imports = imports
+		h.importsStatus = imports
 		h.importsDirty = false
 	}
 
 	// see if we need to update the discovery status
 	if h.discoveryDirty {
-		var remoteStatuses []v1alpha1.DiscoveryRemoteStatus
+		var remoteStatuses []v1.DiscoveryRemoteStatus
 		for _, status := range h.discovery {
 			remoteStatuses = append(remoteStatuses, *status)
 		}
@@ -438,11 +435,191 @@ func (h *handler) currentStatus() *v1alpha1.FederationStatusDetails {
 			func(i, j int) bool {
 				return strings.Compare(remoteStatuses[i].Source, remoteStatuses[j].Source) < 0
 			})
-		h.status.Discovery.Remotes = remoteStatuses
+		h.discoveryStatus.Remotes = remoteStatuses
 		h.discoveryDirty = false
 	}
 
-	h.dirty = false
+	mf, err := h.manager.rm.PeerInformer().Lister().ServiceMeshPeers(h.mesh.Namespace).Get(h.mesh.Name)
+	if err != nil {
+		if apierrors.IsGone(err) || apierrors.IsNotFound(err) {
+			h.logger.Debugf("could not locate ServiceMeshPeer %s for status update", h.mesh)
+			return nil
+		}
+		return err
+	}
+	oldStatus := mf.Status.DeepCopy()
+	newStatus := &v1.ServiceMeshPeerStatus{}
+
+	newStatus.DiscoveryStatus = oldStatus.DeepCopy().DiscoveryStatus
+	if h.discoveryStatus.Watch.Connected {
+		newStatus.DiscoveryStatus.Active = h.setDiscoveryStatus(newStatus.DiscoveryStatus.Active, h.discoveryStatus)
+		newStatus.DiscoveryStatus.Inactive = h.clearDiscoveryStatus(newStatus.DiscoveryStatus.Inactive)
+	} else {
+		newStatus.DiscoveryStatus.Inactive = h.setDiscoveryStatus(newStatus.DiscoveryStatus.Inactive, h.discoveryStatus)
+		newStatus.DiscoveryStatus.Active = h.clearDiscoveryStatus(newStatus.DiscoveryStatus.Active)
+	}
+
+	var allErrors []error
+	if isLeader {
+		// clean up deleted pods
+		newStatus.DiscoveryStatus.Inactive = h.removeDeadPods(newStatus.DiscoveryStatus.Inactive)
+		newStatus.DiscoveryStatus.Active = h.removeDeadPods(newStatus.DiscoveryStatus.Active)
+		if err := h.patchExports(); err != nil && !(apierrors.IsGone(err) || apierrors.IsNotFound(err)) {
+			allErrors = append(allErrors, err)
+		}
+		if err := h.patchImports(); err != nil && !(apierrors.IsGone(err) || apierrors.IsNotFound(err)) {
+			allErrors = append(allErrors, err)
+		}
+	}
+
+	// XXX: the created patch does not merge properly and can cause duplicate entries in discovery status
+	patch, err := h.createPatch(&v1.ServiceMeshPeer{Status: *newStatus}, &v1.ServiceMeshPeer{Status: *oldStatus}, peerStatusPatchMetadata)
+	if err != nil {
+		return err
+	}
+
+	h.logger.Debugf("status patch: %s", string(patch))
+
+	if len(patch) == 0 || string(patch) == "{}" {
+		// nothing to patch
+		h.logger.Debugf("no status updates for ServiceMeshPeer %s", h.mesh)
+		return nil
+	}
+	_, err = h.manager.rm.MaistraClientSet().FederationV1().ServiceMeshPeers(h.mesh.Namespace).Patch(context.TODO(), h.mesh.Name,
+		types.MergePatchType, patch, metav1.PatchOptions{}, "status")
+	if err != nil && !(apierrors.IsGone(err) || apierrors.IsNotFound(err)) {
+		return utilerrors.NewAggregate(append(allErrors, err))
+	}
+	h.watchDirty = false
+	return utilerrors.NewAggregate(allErrors)
+}
+
+func (h *handler) patchExports() error {
+	exportSet, err := h.manager.rm.ExportsInformer().Lister().ExportedServiceSets(h.mesh.Namespace).Get(h.mesh.Name)
+	if err != nil {
+		if (apierrors.IsGone(err) || apierrors.IsNotFound(err)) && len(h.exports) == 0 {
+			h.logger.Debugf("could not locate ExportedServiceSet %s for status update", h.mesh)
+			return nil
+		}
+		return err
+	}
+
+	exportedServices := h.exportsStatus
+	if exportedServices == nil {
+		exportedServices = []v1.PeerServiceMapping{}
+	}
+	patch, err := h.createPatch(
+		&v1.ExportedServiceSet{Status: v1.ExportedServiceSetStatus{ExportedServices: exportedServices}},
+		&v1.ExportedServiceSet{Status: exportSet.DeepCopy().Status},
+		exportStatusPatchMetadata)
+	if err != nil {
+		return err
+	}
+
+	if len(patch) == 0 || string(patch) == "{}" {
+		// nothing to patch
+		h.logger.Debugf("no status updates for ExportedServiceSet %s", h.mesh)
+		return nil
+	}
+
+	if _, err := h.manager.rm.MaistraClientSet().FederationV1().ExportedServiceSets(h.mesh.Namespace).
+		Patch(context.TODO(), h.mesh.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status"); err != nil {
+		if !(apierrors.IsGone(err) || apierrors.IsNotFound(err)) {
+			return err
+		}
+	}
+	return nil
+}
+
+func (h *handler) patchImports() error {
+	importSet, err := h.manager.rm.ImportsInformer().Lister().ImportedServiceSets(h.mesh.Namespace).Get(h.mesh.Name)
+	if err != nil {
+		if (apierrors.IsGone(err) || apierrors.IsNotFound(err)) && len(h.exports) == 0 {
+			h.logger.Debugf("could not locate ImportedServiceSet %s for status update", h.mesh)
+			return nil
+		}
+		return err
+	}
+
+	importedServices := h.importsStatus
+	if importedServices == nil {
+		importedServices = []v1.PeerServiceMapping{}
+	}
+	patch, err := h.createPatch(
+		&v1.ImportedServiceSet{Status: v1.ImportedServiceSetStatus{ImportedServices: importedServices}},
+		&v1.ImportedServiceSet{Status: importSet.DeepCopy().Status},
+		importStatusPatchMetadata)
+	if err != nil {
+		return err
+	}
+
+	if len(patch) == 0 || string(patch) == "{}" {
+		// nothing to patch
+		h.logger.Debugf("no status updates for ImportedServiceSet %s", h.mesh)
+		return nil
+	}
+
+	if _, err := h.manager.rm.MaistraClientSet().FederationV1().ImportedServiceSets(h.mesh.Namespace).
+		Patch(context.TODO(), h.mesh.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status"); err != nil {
+		if !(apierrors.IsGone(err) || apierrors.IsNotFound(err)) {
+			return err
+		}
+	}
+	return nil
+}
+
+func (h *handler) createPatch(newObj, oldObj interface{}, metadata strategicpatch.LookupPatchMeta) ([]byte, error) {
+	newBytes, err := json.Marshal(newObj)
+	if err != nil {
+		return nil, err
+	}
+	oldBytes, err := json.Marshal(oldObj)
+	if err != nil {
+		return nil, err
+	}
+
+	h.logger.Debugf("old bytes: %s", string(oldBytes))
+	h.logger.Debugf("new bytes: %s", string(newBytes))
 
-	return h.status.DeepCopy()
+	patch, err := strategicpatch.CreateTwoWayMergePatchUsingLookupPatchMeta(oldBytes, newBytes, metadata)
+	if err != nil {
+		return nil, err
+	}
+	return patch, nil
+}
+
+func (h *handler) setDiscoveryStatus(statuses []v1.PodPeerDiscoveryStatus, newStatus v1.PeerDiscoveryStatus) []v1.PodPeerDiscoveryStatus {
+	count := len(statuses)
+	index := sort.Search(count, func(i int) bool { return statuses[i].Pod == h.manager.name.Name })
+	if index < count {
+		status := statuses[index]
+		status.PeerDiscoveryStatus = newStatus
+		statuses[index] = status
+		return statuses
+	}
+	statuses = append(statuses, v1.PodPeerDiscoveryStatus{Pod: h.manager.name.Name, PeerDiscoveryStatus: newStatus})
+	sort.Slice(statuses, func(i, j int) bool { return strings.Compare(statuses[i].Pod, statuses[j].Pod) < 0 })
+	return statuses
+}
+
+func (h *handler) clearDiscoveryStatus(statuses []v1.PodPeerDiscoveryStatus) []v1.PodPeerDiscoveryStatus {
+	count := len(statuses)
+	index := sort.Search(count, func(i int) bool { return statuses[i].Pod == h.manager.name.Name })
+	if index < count {
+		return append(statuses[:index], statuses[index+1:]...)
+	}
+	return statuses
+}
+
+func (h *handler) removeDeadPods(statuses []v1.PodPeerDiscoveryStatus) []v1.PodPeerDiscoveryStatus {
+	var filteredStatuses []v1.PodPeerDiscoveryStatus
+	for index, status := range statuses {
+		// XXX: this shouldn't be necessary, but patching isn't working correctly
+		if index == 0 || statuses[index].Pod != statuses[index-1].Pod {
+			if _, err := h.manager.rm.KubeClient().KubeInformer().Core().V1().Pods().Lister().Pods(h.manager.name.Namespace).Get(status.Pod); err == nil {
+				filteredStatuses = append(filteredStatuses, status)
+			}
+		}
+	}
+	return filteredStatuses
 }
diff --git a/pkg/servicemesh/federation/status/manager.go b/pkg/servicemesh/federation/status/manager.go
index ed38ef5505..09c74231d3 100644
--- a/pkg/servicemesh/federation/status/manager.go
+++ b/pkg/servicemesh/federation/status/manager.go
@@ -15,41 +15,43 @@
 package status
 
 import (
-	"context"
-	"encoding/json"
-	"fmt"
-	"sort"
-	"strings"
 	"sync"
 
-	"k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/api/meta"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/errors"
 	"k8s.io/apimachinery/pkg/util/strategicpatch"
-	maistraclient "maistra.io/api/client/versioned"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
-	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pilot/pkg/leaderelection"
 	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/servicemesh/federation/model"
 	"istio.io/pkg/log"
 )
 
-var federationStatusPatchMetadata strategicpatch.LookupPatchMeta
+var (
+	peerStatusPatchMetadata   strategicpatch.LookupPatchMeta
+	exportStatusPatchMetadata strategicpatch.LookupPatchMeta
+	importStatusPatchMetadata strategicpatch.LookupPatchMeta
+)
 
 func init() {
 	var err error
-	federationStatusPatchMetadata, err = strategicpatch.NewPatchMetaFromStruct(&v1alpha1.FederationStatus{})
-	if err != nil {
-		panic("error creating strategicpatch.LookupPatchMeta for use with FederationStatus resources")
+	if peerStatusPatchMetadata, err = strategicpatch.NewPatchMetaFromStruct(&v1.ServiceMeshPeer{}); err != nil {
+		panic("error creating strategicpatch.LookupPatchMeta for use with ServiceMeshPeer resources")
+	}
+	if exportStatusPatchMetadata, err = strategicpatch.NewPatchMetaFromStruct(&v1.ExportedServiceSet{}); err != nil {
+		panic("error creating strategicpatch.LookupPatchMeta for use with ExportedServiceSet resources")
+	}
+	if importStatusPatchMetadata, err = strategicpatch.NewPatchMetaFromStruct(&v1.ImportedServiceSet{}); err != nil {
+		panic("error creating strategicpatch.LookupPatchMeta for use with ImportedServiceSet resources")
 	}
 }
 
 type Manager interface {
-	FederationAdded(mesh types.NamespacedName) Handler
-	FederationDeleted(mesh types.NamespacedName)
+	PeerAdded(mesh types.NamespacedName) Handler
+	PeerDeleted(mesh types.NamespacedName)
 	HandlerFor(mesh types.NamespacedName) Handler
+	IsLeader() bool
 	PushStatus() error
 }
 
@@ -81,43 +83,53 @@ type Handler interface {
 	Flush() error
 }
 
-func NewManager(name types.NamespacedName, kubeClient kube.Client) (Manager, error) {
-	cs, err := maistraclient.NewForConfig(kubeClient.RESTConfig())
-	if err != nil {
-		return nil, fmt.Errorf("error creating ClientSet for ServiceMesh: %v", err)
-	}
-
-	return newManager(name, kubeClient, cs), nil
-}
-
-func newManager(name types.NamespacedName, kubeClient kube.Client, cs maistraclient.Interface) *manager {
-	return &manager{
-		client:   kubeClient,
-		cs:       cs,
-		logger:   common.Logger.WithLabels("component", "federation-status"),
-		name:     name,
-		handlers: map[types.NamespacedName]*handler{},
-		status:   v1alpha1.FederationStatusStatus{Meshes: []v1alpha1.FederationStatusDetails{}},
+func NewManager(name types.NamespacedName, rm common.ResourceManager, leaderElection *leaderelection.LeaderElection) Manager {
+	manager := &manager{
+		rm:             rm,
+		logger:         common.Logger.WithLabels("component", "federation-status"),
+		name:           name,
+		leaderElection: leaderElection,
+		handlers:       map[types.NamespacedName]*handler{},
 	}
+	leaderElection.AddRunFunction(manager.BecomeLeader)
+	return manager
 }
 
 type manager struct {
 	mu     sync.Mutex
-	client kube.Client
-	cs     maistraclient.Interface
+	rm     common.ResourceManager
 	logger *log.Scope
 
 	name types.NamespacedName
 
 	handlers map[types.NamespacedName]*handler
 
-	status                v1alpha1.FederationStatusStatus
-	missingCRDErrorLogged bool
+	leaderElection *leaderelection.LeaderElection
+	isLeader       bool
 }
 
 var _ Manager = (*manager)(nil)
 
-func (m *manager) FederationAdded(mesh types.NamespacedName) Handler {
+func (m *manager) BecomeLeader(stop <-chan struct{}) {
+	func() {
+		m.mu.Lock()
+		defer m.mu.Unlock()
+		m.isLeader = true
+	}()
+	_ = m.PushStatus()
+	<-stop
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	m.isLeader = false
+}
+
+func (m *manager) IsLeader() bool {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	return m.isLeader
+}
+
+func (m *manager) PeerAdded(mesh types.NamespacedName) Handler {
 	m.mu.Lock()
 	defer m.mu.Unlock()
 
@@ -130,7 +142,7 @@ func (m *manager) FederationAdded(mesh types.NamespacedName) Handler {
 	return handler
 }
 
-func (m *manager) FederationDeleted(mesh types.NamespacedName) {
+func (m *manager) PeerDeleted(mesh types.NamespacedName) {
 	func() {
 		m.mu.Lock()
 		defer m.mu.Unlock()
@@ -140,10 +152,6 @@ func (m *manager) FederationDeleted(mesh types.NamespacedName) {
 		}
 		delete(m.handlers, mesh)
 	}()
-
-	if err := m.PushStatus(); err != nil {
-		m.logger.Errorf("unexpected error updating FederationStatus for %s", m.name.String())
-	}
 }
 
 func (m *manager) HandlerFor(mesh types.NamespacedName) Handler {
@@ -156,96 +164,20 @@ func (m *manager) HandlerFor(mesh types.NamespacedName) Handler {
 }
 
 func (m *manager) PushStatus() error {
-	m.mu.Lock()
-	defer m.mu.Unlock()
-
-	newStatus := &v1alpha1.FederationStatus{
-		Status: v1alpha1.FederationStatusStatus{Meshes: []v1alpha1.FederationStatusDetails{}},
-	}
-	for _, handler := range m.handlers {
-		newStatus.Status.Meshes = append(newStatus.Status.Meshes, *handler.currentStatus())
-	}
-	sort.Slice(newStatus.Status.Meshes,
-		func(i, j int) bool {
-			return strings.Compare(newStatus.Status.Meshes[i].Mesh, newStatus.Status.Meshes[j].Mesh) < 0
-		})
-
-	newBytes, err := json.Marshal(newStatus)
-	if err != nil {
-		return err
-	}
-	oldBytes, err := json.Marshal(&v1alpha1.FederationStatus{
-		Status: m.status,
-	})
-	if err != nil {
-		return err
-	}
-
-	m.logger.Debugf("old bytes:\n%s\n", string(oldBytes))
-	m.logger.Debugf("new bytes:\n%s\n", string(newBytes))
-
-	patch, err := strategicpatch.CreateTwoWayMergePatchUsingLookupPatchMeta(oldBytes, newBytes, federationStatusPatchMetadata)
-	if err != nil {
-		return err
-	}
-
-	m.logger.Debugf("status patch:\n%s\n", string(patch))
-
-	if len(patch) == 0 || string(patch) == "{}" {
-		// nothing to patch
-		return nil
-	}
-
-	fedStatus, err := m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
-		Patch(context.TODO(), m.name.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status")
-	if err == nil {
-		m.missingCRDErrorLogged = false
-		m.status = *fedStatus.Status.DeepCopy()
-		return nil
-	} else if meta.IsNoMatchError(err) {
-		// The FederationStatus resource is not installed.  We won't error in this case.
-		if !m.missingCRDErrorLogged {
-			m.logger.Errorf("status will not be updated: FederationStatus CRD is not installed")
-			// prevent spamming the logs
-			m.missingCRDErrorLogged = true
+	handlers := func() []*handler {
+		m.mu.Lock()
+		defer m.mu.Unlock()
+		var handlers []*handler
+		for _, handler := range m.handlers {
+			handlers = append(handlers, handler)
 		}
-		return nil
-	} else if !(errors.IsGone(err) || errors.IsNotFound(err)) {
-		return err
-	}
-
-	// if we get here, it means the resource doesn't exist
-	pilotPod, err := m.client.KubeInformer().Core().V1().Pods().Lister().Pods(m.name.Namespace).Get(m.name.Name)
-	if err != nil {
-		// this should really _never_ happen unless the POD_* env is incorrect.  we're running in the pod!
-		return err
-	}
-	controller := true
-	newFedStatus := &v1alpha1.FederationStatus{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      m.name.Name,
-			Namespace: m.name.Namespace,
-			OwnerReferences: []metav1.OwnerReference{
-				{
-					APIVersion: "v1",
-					Kind:       "Pod",
-					Name:       m.name.Name,
-					UID:        pilotPod.GetUID(),
-					Controller: &controller,
-				},
-			},
-		},
-		Status: *m.status.DeepCopy(),
-	}
-	_, err = m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
-		Create(context.TODO(), newFedStatus, metav1.CreateOptions{})
-	if err == nil {
-		// we can't create status, so we need to apply it separately
-		fedStatus, err = m.cs.CoreV1alpha1().FederationStatuses(m.name.Namespace).
-			Patch(context.TODO(), m.name.Name, types.MergePatchType, patch, metav1.PatchOptions{}, "status")
-		if err == nil {
-			m.status = *fedStatus.Status.DeepCopy()
+		return handlers
+	}()
+	var allErrors []error
+	for _, handler := range handlers {
+		if err := handler.Flush(); err != nil {
+			allErrors = append(allErrors, err)
 		}
 	}
-	return err
+	return errors.NewAggregate(allErrors)
 }
diff --git a/pkg/servicemesh/federation/status/manager_test.go b/pkg/servicemesh/federation/status/manager_test.go
index 5c65f45a27..f84c6bc13f 100644
--- a/pkg/servicemesh/federation/status/manager_test.go
+++ b/pkg/servicemesh/federation/status/manager_test.go
@@ -17,17 +17,22 @@ package status
 import (
 	"context"
 	"testing"
+	"time"
 
 	"github.com/google/go-cmp/cmp"
 	corev1 "k8s.io/api/core/v1"
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/client-go/tools/cache"
 	maistraclient "maistra.io/api/client/versioned"
 	"maistra.io/api/client/versioned/fake"
-	"maistra.io/api/core/v1alpha1"
+	v1 "maistra.io/api/federation/v1"
 
+	"istio.io/istio/pilot/pkg/leaderelection"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/federation/common"
 	"istio.io/istio/pkg/servicemesh/federation/model"
+	"istio.io/pkg/log"
 )
 
 var ignoreTimestamps = cmp.FilterPath(func(p cmp.Path) bool {
@@ -43,12 +48,21 @@ func TestStatusManager(t *testing.T) {
 		namespace = "test-namespace"
 		name      = "test"
 	)
+	istiodName := metav1.ObjectMeta{Name: "istiod-test", Namespace: namespace, UID: "12345"}
+	meshName := metav1.ObjectMeta{
+		Name:      name,
+		Namespace: namespace,
+	}
 	testCases := []struct {
-		name       string
-		mesh       types.NamespacedName
-		events     []func(h Handler)
-		status     []v1alpha1.FederationStatusStatus
-		assertions []func(t *testing.T, status *v1alpha1.FederationStatusStatus)
+		name   string
+		mesh   types.NamespacedName
+		events []func(h Handler)
+		status []struct {
+			peer    v1.ServiceMeshPeerStatus
+			exports v1.ExportedServiceSetStatus
+			imports v1.ImportedServiceSetStatus
+		}
+		assertions []func(t *testing.T, status *v1.ServiceMeshPeerStatus)
 	}{
 		{
 			name: "initial-status",
@@ -66,25 +80,31 @@ func TestStatusManager(t *testing.T) {
 					h.WatchTerminated("503")
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
 				nil,
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Watch.LastConnected.IsZero() {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if status.DiscoveryStatus.Inactive[0].Watch.LastConnected.IsZero() {
 						t.Errorf("expected LastConnected to be updated")
 					}
 				},
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Watch: v1alpha1.DiscoveryWatchStatus{
-									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-										Connected: false,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Watch: v1.DiscoveryWatchStatus{
+											DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+												Connected: false,
+											},
+										},
 									},
 								},
 							},
@@ -92,16 +112,18 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Watch: v1alpha1.DiscoveryWatchStatus{
-									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-										Connected:            false,
-										LastDisconnectStatus: "503",
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Watch: v1.DiscoveryWatchStatus{
+											DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+												Connected:            false,
+												LastDisconnectStatus: "503",
+											},
+										},
 									},
 								},
 							},
@@ -125,30 +147,36 @@ func TestStatusManager(t *testing.T) {
 					h.WatchTerminated("200")
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
 				nil,
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Watch.LastConnected.IsZero() {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if status.DiscoveryStatus.Active[0].Watch.LastConnected.IsZero() {
 						t.Errorf("expected LastConnected to be updated")
 					}
 				},
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Watch.LastDisconnect.IsZero() {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if status.DiscoveryStatus.Inactive[0].Watch.LastDisconnect.IsZero() {
 						t.Errorf("expected LastDisconnect to be updated")
 					}
 				},
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Watch: v1alpha1.DiscoveryWatchStatus{
-									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-										Connected: false,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Watch: v1.DiscoveryWatchStatus{
+											DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+												Connected: false,
+											},
+										},
 									},
 								},
 							},
@@ -156,15 +184,17 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Watch: v1alpha1.DiscoveryWatchStatus{
-									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-										Connected: true,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Active: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Watch: v1.DiscoveryWatchStatus{
+											DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+												Connected: true,
+											},
+										},
 									},
 								},
 							},
@@ -172,16 +202,18 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Watch: v1alpha1.DiscoveryWatchStatus{
-									DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-										Connected:            false,
-										LastDisconnectStatus: "200",
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Watch: v1.DiscoveryWatchStatus{
+											DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+												Connected:            false,
+												LastDisconnectStatus: "200",
+											},
+										},
 									},
 								},
 							},
@@ -207,41 +239,47 @@ func TestStatusManager(t *testing.T) {
 					h.RemoteWatchTerminated("10.10.10.10")
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Remotes[0].LastConnected.IsZero() {
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if status.DiscoveryStatus.Inactive[0].Remotes[0].LastConnected.IsZero() {
 						t.Errorf("expected LastConnected to be updated")
 					}
 				},
 				nil,
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
 					// full sync causes a push, so we can also verify that an event was seen
-					if status.Meshes[0].Discovery.Remotes[0].LastEvent.IsZero() {
+					if status.DiscoveryStatus.Inactive[0].Remotes[0].LastEvent.IsZero() {
 						t.Errorf("expected LastEvent to be updated")
 					}
-					if status.Meshes[0].Discovery.Remotes[0].LastFullSync.IsZero() {
+					if status.DiscoveryStatus.Inactive[0].Remotes[0].LastFullSync.IsZero() {
 						t.Errorf("expected LastFullSync to be updated")
 					}
 				},
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Remotes[0].LastDisconnect.IsZero() {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if status.DiscoveryStatus.Inactive[0].Remotes[0].LastDisconnect.IsZero() {
 						t.Errorf("expected LastDisconnect to be updated")
 					}
 				},
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Remotes: []v1alpha1.DiscoveryRemoteStatus{
-									{
-										Source: "10.10.10.10",
-										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-											Connected: true,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Remotes: []v1.DiscoveryRemoteStatus{
+											{
+												Source: "10.10.10.10",
+												DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+													Connected: true,
+												},
+											},
 										},
 									},
 								},
@@ -250,17 +288,19 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Remotes: []v1alpha1.DiscoveryRemoteStatus{
-									{
-										Source: "10.10.10.10",
-										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-											Connected: true,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Remotes: []v1.DiscoveryRemoteStatus{
+											{
+												Source: "10.10.10.10",
+												DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+													Connected: true,
+												},
+											},
 										},
 									},
 								},
@@ -269,17 +309,19 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Remotes: []v1alpha1.DiscoveryRemoteStatus{
-									{
-										Source: "10.10.10.10",
-										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-											Connected: true,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Remotes: []v1.DiscoveryRemoteStatus{
+											{
+												Source: "10.10.10.10",
+												DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+													Connected: true,
+												},
+											},
 										},
 									},
 								},
@@ -288,17 +330,19 @@ func TestStatusManager(t *testing.T) {
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Discovery: v1alpha1.MeshDiscoveryStatus{
-								Remotes: []v1alpha1.DiscoveryRemoteStatus{
-									{
-										Source: "10.10.10.10",
-										DiscoveryConnectionStatus: v1alpha1.DiscoveryConnectionStatus{
-											Connected: false,
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+									PeerDiscoveryStatus: v1.PeerDiscoveryStatus{
+										Remotes: []v1.DiscoveryRemoteStatus{
+											{
+												Source: "10.10.10.10",
+												DiscoveryConnectionStatus: v1.DiscoveryConnectionStatus{
+													Connected: false,
+												},
+											},
 										},
 									},
 								},
@@ -342,52 +386,68 @@ func TestStatusManager(t *testing.T) {
 					h.Flush()
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
 				nil, nil, nil,
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
 								{
-									LocalService: v1alpha1.ServiceKey{
-										Name:      "real-service",
-										Namespace: "real-namespace",
-										Hostname:  "real-service.real-namespace.svc.cluster.local",
-									},
-									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+									Pod: istiodName.Name,
+								},
+							},
+						},
+					},
+					exports: v1.ExportedServiceSetStatus{
+						ExportedServices: []v1.PeerServiceMapping{
+							{
+								LocalService: v1.ServiceKey{
+									Name:      "real-service",
+									Namespace: "real-namespace",
+									Hostname:  "real-service.real-namespace.svc.cluster.local",
 								},
+								ExportedName: "exported-service.exported-namespace.svc.mesh.local",
 							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
 								{
-									LocalService: v1alpha1.ServiceKey{
-										Name:      "real-service",
-										Namespace: "real-namespace",
-										Hostname:  "real-service.real-namespace.svc.cluster.local",
-									},
-									ExportedName: "updated-exported-service.exported-namespace.svc.mesh.local",
+									Pod: istiodName.Name,
+								},
+							},
+						},
+					},
+					exports: v1.ExportedServiceSetStatus{
+						ExportedServices: []v1.PeerServiceMapping{
+							{
+								LocalService: v1.ServiceKey{
+									Name:      "real-service",
+									Namespace: "real-namespace",
+									Hostname:  "real-service.real-namespace.svc.cluster.local",
 								},
+								ExportedName: "updated-exported-service.exported-namespace.svc.mesh.local",
 							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
@@ -427,43 +487,55 @@ func TestStatusManager(t *testing.T) {
 					h.Flush()
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
 				nil, nil, nil, nil,
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
@@ -497,53 +569,70 @@ func TestStatusManager(t *testing.T) {
 					h.Flush()
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if len(status.DiscoveryStatus.Inactive) == 0 ||
+						(len(status.DiscoveryStatus.Inactive) > 0 && status.DiscoveryStatus.Inactive[0].Watch.LastEvent.IsZero()) {
 						t.Errorf("expected LastEvent to be updated")
 					}
 				},
 				nil, nil,
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
 								{
-									LocalService: v1alpha1.ServiceKey{
-										Name:      "local-service",
-										Namespace: "local-namespace",
-										Hostname:  "local-service.local-namespace.svc.test-mesh.local",
-									},
-									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+									Pod: istiodName.Name,
 								},
 							},
 						},
 					},
+					imports: v1.ImportedServiceSetStatus{
+						ImportedServices: []v1.PeerServiceMapping{
+							{
+								LocalService: v1.ServiceKey{
+									Name:      "local-service",
+									Namespace: "local-namespace",
+									Hostname:  "local-service.local-namespace.svc.test-mesh.local",
+								},
+								ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+							},
+						},
+					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Exports: []v1alpha1.MeshServiceMapping{},
-							Imports: []v1alpha1.MeshServiceMapping{
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
 								{
-									LocalService: v1alpha1.ServiceKey{},
-									ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+									Pod: istiodName.Name,
 								},
 							},
 						},
 					},
+					imports: v1.ImportedServiceSetStatus{
+						ImportedServices: []v1.PeerServiceMapping{
+							{
+								LocalService: v1.ServiceKey{},
+								ExportedName: "exported-service.exported-namespace.svc.mesh.local",
+							},
+						},
+					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
@@ -577,117 +666,167 @@ func TestStatusManager(t *testing.T) {
 					h.FullSyncComplete()
 				},
 			},
-			assertions: []func(t *testing.T, status *v1alpha1.FederationStatusStatus){
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
-					if !status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+			assertions: []func(t *testing.T, status *v1.ServiceMeshPeerStatus){
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
+					if !status.DiscoveryStatus.Inactive[0].Watch.LastEvent.IsZero() {
 						t.Errorf("did not expect LastEvent to be updated")
 					}
-					if !status.Meshes[0].Discovery.Watch.LastFullSync.IsZero() {
+					if !status.DiscoveryStatus.Inactive[0].Watch.LastFullSync.IsZero() {
 						t.Errorf("did not expect LastFullSync to be updated")
 					}
 				},
 				nil, nil,
-				func(t *testing.T, status *v1alpha1.FederationStatusStatus) {
+				func(t *testing.T, status *v1.ServiceMeshPeerStatus) {
 					// this should have been updated in one of the previous events
-					if status.Meshes[0].Discovery.Watch.LastEvent.IsZero() {
+					if status.DiscoveryStatus.Inactive[0].Watch.LastEvent.IsZero() {
 						t.Errorf("expected LastEvent to be updated")
 					}
-					if status.Meshes[0].Discovery.Watch.LastFullSync.IsZero() {
+					if status.DiscoveryStatus.Inactive[0].Watch.LastFullSync.IsZero() {
 						t.Errorf("expected LastFullSync to be updated")
 					}
 				},
 			},
-			status: []v1alpha1.FederationStatusStatus{
+			status: []struct {
+				peer    v1.ServiceMeshPeerStatus
+				exports v1.ExportedServiceSetStatus
+				imports v1.ImportedServiceSetStatus
+			}{
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 				{
-					Meshes: []v1alpha1.FederationStatusDetails{
-						{
-							Mesh:    namespace + "/" + name,
-							Imports: []v1alpha1.MeshServiceMapping{},
-							Exports: []v1alpha1.MeshServiceMapping{},
+					peer: v1.ServiceMeshPeerStatus{
+						DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+							Inactive: []v1.PodPeerDiscoveryStatus{
+								{
+									Pod: istiodName.Name,
+								},
+							},
 						},
 					},
 				},
 			},
 		},
 	}
+	logOpts := log.DefaultOptions()
+	logOpts.SetOutputLevel("federation", log.DebugLevel)
+	logOpts.JSONEncoding = false
+	log.Configure(logOpts)
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
 			// verify test is setup correctly
 			if len(tc.status) != len(tc.events) || len(tc.assertions) != len(tc.events) {
 				t.Fatalf("number of status elements and asserts must equal the number of events")
 			}
-			name := v1.ObjectMeta{Name: "istiod-test", Namespace: namespace, UID: "12345"}
 			kubeClient := kube.NewFakeClient(&corev1.Pod{
-				ObjectMeta: name,
+				ObjectMeta: istiodName,
 			})
 			stop := make(chan struct{})
 			defer func() { close(stop) }()
 			go kubeClient.KubeInformer().Core().V1().Pods().Informer().Run(stop)
 			for !kubeClient.KubeInformer().Core().V1().Pods().Informer().HasSynced() {
 			}
-			cs := fake.NewSimpleClientset()
-			manager := newManager(types.NamespacedName{Name: name.Name, Namespace: name.Namespace}, kubeClient, cs)
-			manager.FederationAdded(tc.mesh)
-			manager.PushStatus()
-			verifyStatus(t, cs, name, &v1alpha1.FederationStatusStatus{
-				Meshes: []v1alpha1.FederationStatusDetails{
-					{
-						Mesh:    tc.mesh.Namespace + "/" + tc.mesh.Name,
-						Exports: []v1alpha1.MeshServiceMapping{},
-						Imports: []v1alpha1.MeshServiceMapping{},
+			cs := fake.NewSimpleClientset(
+				&v1.ExportedServiceSet{ObjectMeta: metav1.ObjectMeta{Name: tc.mesh.Name, Namespace: tc.mesh.Namespace}},
+				&v1.ImportedServiceSet{ObjectMeta: metav1.ObjectMeta{Name: tc.mesh.Name, Namespace: tc.mesh.Namespace}})
+			rm, err := common.NewResourceManager(common.ControllerOptions{
+				KubeClient:   kubeClient,
+				MaistraCS:    cs,
+				ResyncPeriod: 1 * time.Millisecond,
+			}, nil)
+			if err != nil {
+				t.Fatalf("error creating ResourceManager: %s", err)
+			}
+			stopChan := make(chan struct{})
+			defer close(stopChan)
+			go rm.Start(stopChan)
+			cs.FederationV1().ServiceMeshPeers(namespace).Create(context.TODO(), &v1.ServiceMeshPeer{
+				ObjectMeta: meshName,
+			}, metav1.CreateOptions{})
+			leaderStarted := make(chan struct{})
+			le := leaderelection.NewLeaderElection(istiodName.Namespace, istiodName.Name, "test", "test", kubeClient)
+			manager := NewManager(types.NamespacedName{Name: istiodName.Name, Namespace: istiodName.Namespace}, rm, le)
+			le.AddRunFunction(func(stop <-chan struct{}) {
+				cache.WaitForCacheSync(stopChan, manager.IsLeader)
+				close(leaderStarted)
+			})
+			go le.Run(stopChan)
+			select {
+			case <-leaderStarted:
+			case <-time.After(30 * time.Second):
+				close(stopChan)
+				t.Fatalf("timed out waiting for leader election")
+			}
+			for !rm.ExportsInformer().Informer().HasSynced() ||
+				!rm.ImportsInformer().Informer().HasSynced() ||
+				!rm.PeerInformer().Informer().HasSynced() {
+			}
+			manager.PeerAdded(tc.mesh)
+			if err := manager.PushStatus(); err != nil {
+				t.Fatalf("error updating initial status: %s", err)
+			}
+			verifyPeerStatus(t, cs, tc.mesh, &v1.ServiceMeshPeerStatus{
+				DiscoveryStatus: v1.ServiceMeshPeerDiscoveryStatus{
+					Inactive: []v1.PodPeerDiscoveryStatus{
+						{
+							Pod: istiodName.Name,
+						},
 					},
 				},
 			}, nil)
 
 			handler := manager.HandlerFor(types.NamespacedName{Namespace: tc.mesh.Namespace, Name: tc.mesh.Name})
 			if handler == nil {
-				t.Fatalf("nil handler for %s/%s", name.Namespace, name.Name)
+				t.Fatalf("nil handler for %s/%s", tc.mesh.Namespace, tc.mesh.Name)
 			}
 			for index, f := range tc.events {
+				t.Logf("processing event %d", index)
 				f(handler)
-				verifyStatus(t, cs, name, &tc.status[index], tc.assertions[index])
+				verifyPeerStatus(t, cs, tc.mesh, &tc.status[index].peer, tc.assertions[index])
+				verifyExportStatus(t, cs, tc.mesh, &tc.status[index].exports)
+				verifyImportStatus(t, cs, tc.mesh, &tc.status[index].imports)
 			}
-
-			manager.FederationDeleted(tc.mesh)
-			verifyStatus(t, cs, name, &v1alpha1.FederationStatusStatus{}, nil)
 		})
 	}
 }
 
-func verifyStatus(t *testing.T, cs maistraclient.Interface, name v1.ObjectMeta, expected *v1alpha1.FederationStatusStatus,
-	assert func(*testing.T, *v1alpha1.FederationStatusStatus)) {
+func verifyPeerStatus(t *testing.T, cs maistraclient.Interface, name types.NamespacedName, expected *v1.ServiceMeshPeerStatus,
+	assert func(*testing.T, *v1.ServiceMeshPeerStatus)) {
 	t.Helper()
 
-	actual, err := cs.CoreV1alpha1().FederationStatuses(name.Namespace).Get(context.TODO(), name.Name, v1.GetOptions{})
+	actual, err := cs.FederationV1().ServiceMeshPeers(name.Namespace).Get(context.TODO(), name.Name, metav1.GetOptions{})
 	if err != nil {
-		t.Errorf("unexpected error retrieving FederationStatus %s/%s", name.Namespace, name.Name)
+		t.Errorf("unexpected error retrieving ServiceMeshPeer %s/%s: %s", name.Namespace, name.Name, err)
 		return
 	}
 	if diff := cmp.Diff(&actual.Status, expected, ignoreTimestamps); diff != "" {
@@ -697,3 +836,37 @@ func verifyStatus(t *testing.T, cs maistraclient.Interface, name v1.ObjectMeta,
 		assert(t, &actual.Status)
 	}
 }
+
+func verifyExportStatus(t *testing.T, cs maistraclient.Interface, name types.NamespacedName,
+	expected *v1.ExportedServiceSetStatus) {
+	t.Helper()
+
+	actual, err := cs.FederationV1().ExportedServiceSets(name.Namespace).Get(context.TODO(), name.Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("unexpected error retrieving ExportedServiceSet %s/%s: %s", name.Namespace, name.Name, err)
+		return
+	}
+	if expected.ExportedServices == nil {
+		expected.ExportedServices = []v1.PeerServiceMapping{}
+	}
+	if diff := cmp.Diff(&actual.Status, expected, ignoreTimestamps); diff != "" {
+		t.Errorf("comparison failed, -got +want:\n%s", diff)
+	}
+}
+
+func verifyImportStatus(t *testing.T, cs maistraclient.Interface, name types.NamespacedName,
+	expected *v1.ImportedServiceSetStatus) {
+	t.Helper()
+
+	actual, err := cs.FederationV1().ImportedServiceSets(name.Namespace).Get(context.TODO(), name.Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("unexpected error retrieving ImportedServiceSet %s/%s: %s", name.Namespace, name.Name, err)
+		return
+	}
+	if expected.ImportedServices == nil {
+		expected.ImportedServices = []v1.PeerServiceMapping{}
+	}
+	if diff := cmp.Diff(&actual.Status, expected, ignoreTimestamps); diff != "" {
+		t.Errorf("comparison failed, -got +want:\n%s", diff)
+	}
+}
diff --git a/security/pkg/nodeagent/cache/secretcache.go b/security/pkg/nodeagent/cache/secretcache.go
index c547bf9d13..14589dbcb7 100644
--- a/security/pkg/nodeagent/cache/secretcache.go
+++ b/security/pkg/nodeagent/cache/secretcache.go
@@ -124,6 +124,10 @@ type secretCache struct {
 	mu       sync.RWMutex
 	workload *security.SecretItem
 	certRoot []byte
+
+	// Read/Write to trustBundleMap and trustBundleExpireTime should use getRootCertByTrustDomain() and setRootCertByTrustDomain().
+	trustBundleMap        map[string][]byte
+	trustBundleExpireTime time.Time
 }
 
 // GetRoot returns cached root cert and cert expiration time. This method is thread safe.
@@ -243,6 +247,30 @@ func (sc *SecretManagerClient) getCachedSecret(resourceName string) (secret *sec
 	return nil
 }
 
+func (sc *SecretManagerClient) GetTrustBundles() (trustBundles map[string][]byte, earliestExpiry time.Time) {
+	sc.cache.mu.RLock()
+	trustBundles = sc.cache.trustBundleMap
+	earliestExpiry = sc.cache.trustBundleExpireTime
+	if trustBundles != nil && sc.cache.certRoot != nil {
+		trustBundles[sc.configOptions.TrustDomain] = sc.cache.certRoot
+	}
+	sc.cache.mu.RUnlock()
+	return trustBundles, earliestExpiry
+}
+
+func (sc *SecretManagerClient) SetTrustBundles(trustBundles map[string][]byte, earliestExpiry time.Time) {
+	sc.cache.mu.Lock()
+	trustBundlesUpdated := !compareTrustBundles(sc.cache.trustBundleMap, trustBundles)
+	if trustBundlesUpdated {
+		sc.cache.trustBundleMap = trustBundles
+		sc.cache.trustBundleExpireTime = earliestExpiry
+	}
+	sc.cache.mu.Unlock()
+	if trustBundlesUpdated {
+		sc.CallUpdateCallback(security.RootCertReqResourceName)
+	}
+}
+
 // GenerateSecret passes the cached secret to SDS.StreamSecrets and SDS.FetchSecret.
 func (sc *SecretManagerClient) GenerateSecret(resourceName string) (secret *security.SecretItem, err error) {
 	cacheLog.Debugf("generate secret %q", resourceName)
@@ -606,6 +634,11 @@ func (sc *SecretManagerClient) generateNewSecret(resourceName string) (*security
 		rootCertPEM = []byte(certChainPEM[len(certChainPEM)-1])
 	}
 
+	trustBundles, trustBundleExpiry := sc.GetTrustBundles()
+	if trustBundles != nil && trustBundleExpiry.Before(expireTime) {
+		expireTime = trustBundleExpiry
+	}
+
 	return &security.SecretItem{
 		CertificateChain: certChain,
 		PrivateKey:       keyPEM,
@@ -613,6 +646,7 @@ func (sc *SecretManagerClient) generateNewSecret(resourceName string) (*security
 		CreatedTime:      time.Now(),
 		ExpireTime:       expireTime,
 		RootCert:         rootCertPEM,
+		TrustBundles:     trustBundles,
 	}, nil
 }
 
@@ -760,3 +794,16 @@ func (sc *SecretManagerClient) mergeConfigTrustBundle(rootCerts []string) []byte
 	}
 	return anchorBytes
 }
+
+// returns true if trust bundles are the same
+func compareTrustBundles(a map[string][]byte, b map[string][]byte) bool {
+	if len(a) != len(b) {
+		return false
+	}
+	for k, v := range a {
+		if string(b[k]) != string(v) {
+			return false
+		}
+	}
+	return true
+}
diff --git a/security/pkg/nodeagent/sds/sdsservice.go b/security/pkg/nodeagent/sds/sdsservice.go
index 3ac84d6fd9..9d3d0f76f3 100644
--- a/security/pkg/nodeagent/sds/sdsservice.go
+++ b/security/pkg/nodeagent/sds/sdsservice.go
@@ -207,37 +207,63 @@ func toEnvoySecret(s *security.SecretItem, caRootPath string) *tls.Secret {
 	secret := &tls.Secret{
 		Name: s.ResourceName,
 	}
-	cfg := security.SdsCertificateConfig{}
-	ok := false
-	if s.ResourceName == security.FileRootSystemCACert {
-		cfg, ok = security.SdsCertificateConfigFromResourceNameForOSCACert(caRootPath)
-	} else {
-		cfg, ok = security.SdsCertificateConfigFromResourceName(s.ResourceName)
-	}
-	if s.ResourceName == security.RootCertReqResourceName || (ok && cfg.IsRootCertificate()) {
+
+	if s.TrustBundles != nil {
+		spiffeValidatorConfig := &tls.SPIFFECertValidatorConfig{}
+		for trustDomain, rootCert := range s.TrustBundles {
+			spiffeValidatorConfig.TrustDomains = append(
+				spiffeValidatorConfig.TrustDomains,
+				&tls.SPIFFECertValidatorConfig_TrustDomain{
+					Name: trustDomain,
+					TrustBundle: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: rootCert,
+						},
+					},
+				},
+			)
+		}
 		secret.Type = &tls.Secret_ValidationContext{
 			ValidationContext: &tls.CertificateValidationContext{
-				TrustedCa: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: s.RootCert,
-					},
+				CustomValidatorConfig: &core.TypedExtensionConfig{
+					Name:        "envoy.tls.cert_validator.spiffe",
+					TypedConfig: util.MessageToAny(spiffeValidatorConfig),
 				},
 			},
 		}
 	} else {
-		secret.Type = &tls.Secret_TlsCertificate{
-			TlsCertificate: &tls.TlsCertificate{
-				CertificateChain: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: s.CertificateChain,
+		cfg := security.SdsCertificateConfig{}
+		ok := false
+		if s.ResourceName == security.FileRootSystemCACert {
+			cfg, ok = security.SdsCertificateConfigFromResourceNameForOSCACert(caRootPath)
+		} else {
+			cfg, ok = security.SdsCertificateConfigFromResourceName(s.ResourceName)
+		}
+		if s.ResourceName == security.RootCertReqResourceName || (ok && cfg.IsRootCertificate()) {
+			secret.Type = &tls.Secret_ValidationContext{
+				ValidationContext: &tls.CertificateValidationContext{
+					TrustedCa: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.RootCert,
+						},
 					},
 				},
-				PrivateKey: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: s.PrivateKey,
+			}
+		} else {
+			secret.Type = &tls.Secret_TlsCertificate{
+				TlsCertificate: &tls.TlsCertificate{
+					CertificateChain: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.CertificateChain,
+						},
+					},
+					PrivateKey: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.PrivateKey,
+						},
 					},
 				},
-			},
+			}
 		}
 	}
 
diff --git a/vendor/maistra.io/api/client/informers/externalversions/federation/interface.go b/vendor/maistra.io/api/client/informers/externalversions/federation/interface.go
new file mode 100644
index 0000000000..12efb7bccb
diff --git a/vendor/maistra.io/api/client/informers/externalversions/federation/v1/exportedserviceset.go b/vendor/maistra.io/api/client/informers/externalversions/federation/v1/exportedserviceset.go
new file mode 100644
index 0000000000..97fb3b4278
diff --git a/vendor/maistra.io/api/client/informers/externalversions/federation/v1/importedserviceset.go b/vendor/maistra.io/api/client/informers/externalversions/federation/v1/importedserviceset.go
new file mode 100644
index 0000000000..62bd57d1d9
diff --git a/vendor/maistra.io/api/client/informers/externalversions/federation/v1/interface.go b/vendor/maistra.io/api/client/informers/externalversions/federation/v1/interface.go
new file mode 100644
index 0000000000..2a085c9075
diff --git a/vendor/maistra.io/api/client/informers/externalversions/federation/v1/servicemeshpeer.go b/vendor/maistra.io/api/client/informers/externalversions/federation/v1/servicemeshpeer.go
new file mode 100644
index 0000000000..164c32dfd7
diff --git a/vendor/maistra.io/api/client/listers/federation/v1/expansion_generated.go b/vendor/maistra.io/api/client/listers/federation/v1/expansion_generated.go
new file mode 100644
index 0000000000..67d6acf2ed
diff --git a/vendor/maistra.io/api/client/listers/federation/v1/exportedserviceset.go b/vendor/maistra.io/api/client/listers/federation/v1/exportedserviceset.go
new file mode 100644
index 0000000000..71c4571ddf
diff --git a/vendor/maistra.io/api/client/listers/federation/v1/importedserviceset.go b/vendor/maistra.io/api/client/listers/federation/v1/importedserviceset.go
new file mode 100644
index 0000000000..0987837308
diff --git a/vendor/maistra.io/api/client/listers/federation/v1/servicemeshpeer.go b/vendor/maistra.io/api/client/listers/federation/v1/servicemeshpeer.go
new file mode 100644
index 0000000000..61f4d502e6
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/doc.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/doc.go
new file mode 100644
index 0000000000..4f64357b1f
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/exportedserviceset.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/exportedserviceset.go
new file mode 100644
index 0000000000..1cfe4352e5
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/doc.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/doc.go
new file mode 100644
index 0000000000..52886aa70f
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_exportedserviceset.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_exportedserviceset.go
new file mode 100644
index 0000000000..88d530bb6a
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_federation_client.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_federation_client.go
new file mode 100644
index 0000000000..a7401b4cdb
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_importedserviceset.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_importedserviceset.go
new file mode 100644
index 0000000000..73937b4cad
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_servicemeshpeer.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/fake/fake_servicemeshpeer.go
new file mode 100644
index 0000000000..992244b64d
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/federation_client.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/federation_client.go
new file mode 100644
index 0000000000..2db522854d
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/generated_expansion.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/generated_expansion.go
new file mode 100644
index 0000000000..1536004a0e
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/importedserviceset.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/importedserviceset.go
new file mode 100644
index 0000000000..81150afa22
diff --git a/vendor/maistra.io/api/client/versioned/typed/federation/v1/servicemeshpeer.go b/vendor/maistra.io/api/client/versioned/typed/federation/v1/servicemeshpeer.go
new file mode 100644
index 0000000000..2c01776505
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/interface.go b/vendor/maistra.io/api/client/xnsinformer/core/interface.go
new file mode 100644
index 0000000000..a5b8af573a
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1/interface.go b/vendor/maistra.io/api/client/xnsinformer/core/v1/interface.go
new file mode 100644
index 0000000000..b04f0b54e7
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshcontrolplane.go b/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshcontrolplane.go
new file mode 100644
index 0000000000..7c68b4e3ac
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshextension.go b/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshextension.go
new file mode 100644
index 0000000000..b1aaf7fcff
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmember.go b/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmember.go
new file mode 100644
index 0000000000..a343ea28ea
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmemberroll.go b/vendor/maistra.io/api/client/xnsinformer/core/v1/servicemeshmemberroll.go
new file mode 100644
index 0000000000..6de95e1e18
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/interface.go b/vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/interface.go
new file mode 100644
index 0000000000..c13ecd36c2
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/servicemeshextension.go b/vendor/maistra.io/api/client/xnsinformer/core/v1alpha1/servicemeshextension.go
new file mode 100644
index 0000000000..d394b2a087
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v2/interface.go b/vendor/maistra.io/api/client/xnsinformer/core/v2/interface.go
new file mode 100644
index 0000000000..feda36d710
diff --git a/vendor/maistra.io/api/client/xnsinformer/core/v2/servicemeshcontrolplane.go b/vendor/maistra.io/api/client/xnsinformer/core/v2/servicemeshcontrolplane.go
new file mode 100644
index 0000000000..6450d716e6
diff --git a/vendor/maistra.io/api/client/xnsinformer/factory.go b/vendor/maistra.io/api/client/xnsinformer/factory.go
new file mode 100644
index 0000000000..04640d2b62
diff --git a/vendor/maistra.io/api/client/xnsinformer/federation/interface.go b/vendor/maistra.io/api/client/xnsinformer/federation/interface.go
new file mode 100644
index 0000000000..3e09b62336
diff --git a/vendor/maistra.io/api/client/xnsinformer/federation/v1/exportedserviceset.go b/vendor/maistra.io/api/client/xnsinformer/federation/v1/exportedserviceset.go
new file mode 100644
index 0000000000..95ce43d020
diff --git a/vendor/maistra.io/api/client/xnsinformer/federation/v1/importedserviceset.go b/vendor/maistra.io/api/client/xnsinformer/federation/v1/importedserviceset.go
new file mode 100644
index 0000000000..d0d777d1dc
diff --git a/vendor/maistra.io/api/client/xnsinformer/federation/v1/interface.go b/vendor/maistra.io/api/client/xnsinformer/federation/v1/interface.go
new file mode 100644
index 0000000000..d73f213592
diff --git a/vendor/maistra.io/api/client/xnsinformer/federation/v1/servicemeshpeer.go b/vendor/maistra.io/api/client/xnsinformer/federation/v1/servicemeshpeer.go
new file mode 100644
index 0000000000..06c1e68dc7
diff --git a/vendor/maistra.io/api/client/xnsinformer/generic.go b/vendor/maistra.io/api/client/xnsinformer/generic.go
new file mode 100644
index 0000000000..e109dd721d
diff --git a/vendor/maistra.io/api/client/xnsinformer/internalinterfaces/factory_interfaces.go b/vendor/maistra.io/api/client/xnsinformer/internalinterfaces/factory_interfaces.go
new file mode 100644
index 0000000000..9032d99a39
diff --git a/vendor/maistra.io/api/federation/v1/doc.go b/vendor/maistra.io/api/federation/v1/doc.go
new file mode 100644
index 0000000000..a61fe85165
diff --git a/vendor/maistra.io/api/federation/v1/groupversion_info.go b/vendor/maistra.io/api/federation/v1/groupversion_info.go
new file mode 100644
index 0000000000..c9c8001308
diff --git a/vendor/maistra.io/api/federation/v1/servicemeshpeer_types.go b/vendor/maistra.io/api/federation/v1/servicemeshpeer_types.go
new file mode 100644
index 0000000000..f976f66aeb
diff --git a/vendor/maistra.io/api/federation/v1/zz_generated.deepcopy.go b/vendor/maistra.io/api/federation/v1/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..2ebc8a6322
diff --git a/vendor/maistra.io/api/security/v1/trustbundle.pb.go b/vendor/maistra.io/api/security/v1/trustbundle.pb.go
new file mode 100644
index 0000000000..bf7e274057
diff --git a/vendor/maistra.io/api/security/v1/trustbundle.proto b/vendor/maistra.io/api/security/v1/trustbundle.proto
new file mode 100644
index 0000000000..8040e0ad98
diff --git a/vendor/maistra.io/api/security/v1/trustbundle_deepcopy.gen.go b/vendor/maistra.io/api/security/v1/trustbundle_deepcopy.gen.go
new file mode 100644
index 0000000000..fd8fb18e89
-- 
2.31.1

