From bfb881a1e3d505772af7db334f71c5246aadb1de Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Tue, 15 Mar 2022 10:00:40 -0700
Subject: 1.12: Fix VS regression (#37924)

* Add tests for virtual services (istio#37747)

* Revert selecting virtual services (#37813)

* Revert "Added selecting virtualservice (#33764)"

This reverts commit dea2be520667359e0f44e7d1db24b01f26b16741.

* Expand tests

* fmt

* add more tests

* More tests

* 1 more test

* remove dupl

* Add the selection back

* Refactor to generic

* wip

* Add tests for HTTP route

* Fix log line

(cherry picked from commit 2a38aca26bf6d41dbd93ff9f3089eb1918d69a6e)

* Add note
---
 pilot/pkg/networking/core/v1alpha3/fake.go    |  17 +-
 .../pkg/networking/core/v1alpha3/httproute.go |  61 +-
 .../core/v1alpha3/httproute_test.go           | 207 +++++-
 .../networking/core/v1alpha3/route/route.go   |  18 +-
 .../core/v1alpha3/sidecar_simulation_test.go  | 659 ++++++++++++++++++
 pilot/test/xdstest/extract.go                 |  17 +
 releasenotes/notes/vs-regression.yaml         |   8 +
 7 files changed, 967 insertions(+), 20 deletions(-)
 create mode 100644 releasenotes/notes/vs-regression.yaml

diff --git a/pilot/pkg/networking/core/v1alpha3/fake.go b/pilot/pkg/networking/core/v1alpha3/fake.go
index e33852387f..7c1f0db7b5 100644
--- a/pilot/pkg/networking/core/v1alpha3/fake.go
+++ b/pilot/pkg/networking/core/v1alpha3/fake.go
@@ -73,6 +73,9 @@ type TestOptions struct {
 	// Additional ConfigStoreCache to use
 	ConfigStoreCaches []model.ConfigStoreCache
 
+	// CreateConfigStore defines a function that, given a ConfigStoreCache, returns another ConfigStoreCache to use
+	CreateConfigStore func(c model.ConfigStoreCache) model.ConfigStoreCache
+
 	// ConfigGen plugins to use. If not set, all default plugins will be used
 	Plugins []plugin.Plugin
 
@@ -107,10 +110,13 @@ func NewConfigGenTest(t test.Failer, opts TestOptions) *ConfigGenTest {
 	})
 
 	configs := getConfigs(t, opts)
-	configStore := memory.MakeSkipValidation(collections.Pilot)
+	configStore := memory.MakeSkipValidation(collections.PilotGatewayAPI)
 
 	cc := memory.NewSyncController(configStore)
 	controllers := []model.ConfigStoreCache{cc}
+	if opts.CreateConfigStore != nil {
+		controllers = append(controllers, opts.CreateConfigStore(cc))
+	}
 	controllers = append(controllers, opts.ConfigStoreCaches...)
 	configController, _ := configaggregate.MakeWriteableCache(controllers, cc)
 
@@ -259,7 +265,8 @@ func (f *ConfigGenTest) Clusters(p *model.Proxy) []*cluster.Cluster {
 func (f *ConfigGenTest) DeltaClusters(
 	p *model.Proxy,
 	configUpdated map[model.ConfigKey]struct{},
-	watched *model.WatchedResource) ([]*cluster.Cluster, []string, bool) {
+	watched *model.WatchedResource,
+) ([]*cluster.Cluster, []string, bool) {
 	raw, removed, _, delta := f.ConfigGen.BuildDeltaClusters(p,
 		&model.PushRequest{
 			Push: f.PushContext(), ConfigsUpdated: configUpdated,
@@ -324,7 +331,7 @@ func getConfigs(t test.Failer, opts TestOptions) []config.Config {
 		t0 := time.Now()
 		configs, _, err := crd.ParseInputs(configStr)
 		if err != nil {
-			t.Fatalf("failed to read config: %v", err)
+			t.Fatalf("failed to read config: %v: %v", err, configStr)
 		}
 		// setup default namespace if not defined
 		for _, c := range configs {
@@ -333,7 +340,9 @@ func getConfigs(t test.Failer, opts TestOptions) []config.Config {
 			}
 			// Set creation timestamp to same time for all of them for consistency.
 			// If explicit setting is needed it can be set in the yaml
-			c.CreationTimestamp = t0
+			if c.CreationTimestamp.IsZero() {
+				c.CreationTimestamp = t0
+			}
 			cfgs = append(cfgs, c)
 		}
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index 01952b1f80..fa2966d4e7 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -48,7 +48,8 @@ const (
 func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 	node *model.Proxy,
 	req *model.PushRequest,
-	routeNames []string) ([]*discovery.Resource, model.XdsLogDetails) {
+	routeNames []string,
+) ([]*discovery.Resource, model.XdsLogDetails) {
 	routeConfigurations := make([]*discovery.Resource, 0)
 
 	efw := req.Push.EnvoyFilters(node)
@@ -100,7 +101,8 @@ func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 // buildSidecarInboundHTTPRouteConfig builds the route config with a single wildcard virtual host on the inbound path
 // TODO: trace decorators, inbound timeouts
 func (configgen *ConfigGeneratorImpl) buildSidecarInboundHTTPRouteConfig(
-	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string) *route.RouteConfiguration {
+	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string,
+) *route.RouteConfiguration {
 	traceOperation := util.TraceOperation(string(instance.Service.Hostname), instance.ServicePort.Port)
 	defaultRoute := istio_route.BuildDefaultHTTPInboundRoute(clusterName, traceOperation)
 
@@ -217,11 +219,53 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundHTTPRouteConfig(
 	return resource, false
 }
 
+// TODO: merge with IstioEgressListenerWrapper.selectVirtualServices
+// selectVirtualServices selects the virtual services by matching given services' host names.
+func selectVirtualServices(virtualServices []config.Config, servicesByName map[host.Name]*model.Service) []config.Config {
+	out := make([]config.Config, 0)
+	for _, c := range virtualServices {
+		rule := c.Spec.(*networking.VirtualService)
+		var match bool
+
+		// Selection algorithm:
+		// virtualservices have a list of hosts in the API spec
+		// if any host in the list matches one service hostname, select the virtual service
+		// and break out of the loop.
+		for _, h := range rule.Hosts {
+			// TODO: This is a bug. VirtualServices can have many hosts
+			// while the user might be importing only a single host
+			// We need to generate a new VirtualService with just the matched host
+			if servicesByName[host.Name(h)] != nil {
+				match = true
+				break
+			}
+
+			for svcHost := range servicesByName {
+				if host.Name(h).Matches(svcHost) {
+					match = true
+					break
+				}
+			}
+
+			if match {
+				break
+			}
+		}
+
+		if match {
+			out = append(out, c)
+		}
+	}
+
+	return out
+}
+
 func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext,
 	routeName string,
 	listenerPort int,
 	efKeys []string,
-	xdsCache model.XdsCache) ([]*route.VirtualHost, *discovery.Resource, *istio_route.Cache) {
+	xdsCache model.XdsCache,
+) ([]*route.VirtualHost, *discovery.Resource, *istio_route.Cache) {
 	var virtualServices []config.Config
 	var services []*model.Service
 
@@ -273,12 +317,6 @@ func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext
 		}
 	}
 
-	// This is hack to keep consistent with previous behavior.
-	if listenerPort != 80 {
-		// only select virtualServices that matches a service
-		virtualServices = model.SelectVirtualServices(virtualServices, hostsByNamespace)
-	}
-
 	var routeCache *istio_route.Cache
 
 	if listenerPort > 0 {
@@ -306,6 +344,11 @@ func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext
 		}
 	}
 
+	// This is hack to keep consistent with previous behavior.
+	if listenerPort != 80 {
+		// only select virtualServices that matches a service
+		virtualServices = selectVirtualServices(virtualServices, servicesByName)
+	}
 	// Get list of virtual services bound to the mesh gateway
 	virtualHostWrappers := istio_route.BuildSidecarVirtualHostWrapper(routeCache, node, push, servicesByName, virtualServices, listenerPort)
 
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute_test.go b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
index 83cdee0d66..cf3949912f 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
@@ -899,6 +899,24 @@ func TestSidecarOutboundHTTPRouteConfig(t *testing.T) {
 			registryOnly: false,
 		},
 
+		{
+			name:                  "sidecar config with allow any and virtual service includes non existing service",
+			routeName:             "80",
+			sidecarConfig:         sidecarConfigWithAllowAny,
+			virtualServiceConfigs: []*config.Config{&virtualService6},
+			expectedHosts: map[string]map[string]bool{
+				// does not include `match-no-service`
+				"test-private.com:80": {
+					"test-private.com": true, "test-private.com:80": true, "9.9.9.9": true, "9.9.9.9:80": true,
+				},
+				"match-no-service.not-default:80": {"match-no-service.not-default": true, "match-no-service.not-default:80": true},
+				"allow_any": {
+					"*": true,
+				},
+			},
+			registryOnly: false,
+		},
+
 		{
 			name:                  "wildcard egress importing from all namespaces: 9999",
 			routeName:             "9999",
@@ -1224,9 +1242,196 @@ func TestSidecarOutboundHTTPRouteConfig(t *testing.T) {
 	}
 }
 
+func TestSelectVirtualService(t *testing.T) {
+	services := []*model.Service{
+		buildHTTPService("bookinfo.com", visibility.Public, wildcardIP, "default", 9999, 70),
+		buildHTTPService("private.com", visibility.Private, wildcardIP, "default", 9999, 80),
+		buildHTTPService("test.com", visibility.Public, "8.8.8.8", "not-default", 8080),
+		buildHTTPService("test-private.com", visibility.Private, "9.9.9.9", "not-default", 80, 70),
+		buildHTTPService("test-private-2.com", visibility.Private, "9.9.9.10", "not-default", 60),
+		buildHTTPService("test-headless.com", visibility.Public, wildcardIP, "not-default", 8888),
+	}
+
+	servicesByName := make(map[host.Name]*model.Service, len(services))
+	for _, svc := range services {
+		servicesByName[svc.Hostname] = svc
+	}
+
+	virtualServiceSpec1 := &networking.VirtualService{
+		Hosts:    []string{"test-private-2.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							// Subset: "some-subset",
+							Host: "example.org",
+							Port: &networking.PortSelector{
+								Number: 61,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec2 := &networking.VirtualService{
+		Hosts:    []string{"test-private-2.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 62,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec3 := &networking.VirtualService{
+		Hosts:    []string{"test-private-3.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 63,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec4 := &networking.VirtualService{
+		Hosts:    []string{"test-headless.com", "example.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 64,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec5 := &networking.VirtualService{
+		Hosts:    []string{"test-svc.testns.svc.cluster.local"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test-svc.testn.svc.cluster.local",
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec6 := &networking.VirtualService{
+		Hosts:    []string{"match-no-service"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "non-exist-service",
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualService1 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme2-v1",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec1,
+	}
+	virtualService2 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v2",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec2,
+	}
+	virtualService3 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec3,
+	}
+	virtualService4 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v4",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec4,
+	}
+	virtualService5 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec5,
+	}
+	virtualService6 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec6,
+	}
+	configs := selectVirtualServices(
+		[]config.Config{virtualService1, virtualService2, virtualService3, virtualService4, virtualService5, virtualService6},
+		servicesByName)
+	expectedVS := []string{virtualService1.Name, virtualService2.Name, virtualService4.Name}
+	if len(expectedVS) != len(configs) {
+		t.Fatalf("Unexpected virtualService, got %d, epxected %d", len(configs), len(expectedVS))
+	}
+	for i, config := range configs {
+		if config.Name != expectedVS[i] {
+			t.Fatalf("Unexpected virtualService, got %s, epxected %s", config.Name, expectedVS[i])
+		}
+	}
+}
+
 func testSidecarRDSVHosts(t *testing.T, services []*model.Service,
 	sidecarConfig *config.Config, virtualServices []*config.Config, routeName string,
-	expectedHosts map[string]map[string]bool, expectedRoutes int, registryOnly bool) {
+	expectedHosts map[string]map[string]bool, expectedRoutes int, registryOnly bool,
+) {
 	t.Helper()
 	p := &fakePlugin{}
 	configgen := NewConfigGenerator([]plugin.Plugin{p}, &model.DisabledCache{})
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route.go b/pilot/pkg/networking/core/v1alpha3/route/route.go
index 65cd6ee909..13f63bbc66 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route.go
@@ -88,7 +88,8 @@ type VirtualHostWrapper struct {
 // service registry. Services are indexed by FQDN hostnames.
 // The list of Services is also passed to allow maintaining consistent ordering.
 func BuildSidecarVirtualHostWrapper(routeCache *Cache, node *model.Proxy, push *model.PushContext, serviceRegistry map[host.Name]*model.Service,
-	virtualServices []config.Config, listenPort int) []VirtualHostWrapper {
+	virtualServices []config.Config, listenPort int,
+) []VirtualHostWrapper {
 	out := make([]VirtualHostWrapper, 0)
 
 	// dependentDestinationRules includes all the destinationrules referenced by the virtualservices, which have consistent hash policy.
@@ -155,7 +156,8 @@ func BuildSidecarVirtualHostWrapper(routeCache *Cache, node *model.Proxy, push *
 // separateVSHostsAndServices splits the virtual service hosts into Services (if they are found in the registry) and
 // plain non-registry hostnames
 func separateVSHostsAndServices(virtualService config.Config,
-	serviceRegistry map[host.Name]*model.Service) ([]string, []*model.Service) {
+	serviceRegistry map[host.Name]*model.Service,
+) ([]string, []*model.Service) {
 	rule := virtualService.Spec.(*networking.VirtualService)
 	hosts := make([]string, 0)
 	servicesInVirtualService := make([]*model.Service, 0)
@@ -1198,7 +1200,8 @@ func translateFault(in *networking.HTTPFaultInjection) *xdshttpfault.HTTPFault {
 }
 
 func portLevelSettingsConsistentHash(dst *networking.Destination,
-	pls []*networking.TrafficPolicy_PortTrafficPolicy) *networking.LoadBalancerSettings_ConsistentHashLB {
+	pls []*networking.TrafficPolicy_PortTrafficPolicy,
+) *networking.LoadBalancerSettings_ConsistentHashLB {
 	if dst.Port != nil {
 		portNumber := dst.GetPort().GetNumber()
 		for _, setting := range pls {
@@ -1258,7 +1261,8 @@ func consistentHashToHashPolicy(consistentHash *networking.LoadBalancerSettings_
 }
 
 func getHashForService(node *model.Proxy, push *model.PushContext,
-	svc *model.Service, port *model.Port) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
+	svc *model.Service, port *model.Port,
+) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
 	if push == nil {
 		return nil, nil
 	}
@@ -1284,7 +1288,8 @@ func getHashForService(node *model.Proxy, push *model.PushContext,
 
 func GetConsistentHashForVirtualService(push *model.PushContext, node *model.Proxy,
 	virtualService config.Config,
-	serviceRegistry map[host.Name]*model.Service) map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB {
+	serviceRegistry map[host.Name]*model.Service,
+) map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB {
 	hashByDestination := map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB{}
 	for _, httpRoute := range virtualService.Spec.(*networking.VirtualService).Http {
 		for _, destination := range httpRoute.Route {
@@ -1307,7 +1312,8 @@ func GetConsistentHashForVirtualService(push *model.PushContext, node *model.Pro
 
 // GetHashForHTTPDestination return the ConsistentHashLB and the DestinationRule associated with HTTP route destination.
 func GetHashForHTTPDestination(push *model.PushContext, node *model.Proxy, dst *networking.HTTPRouteDestination,
-	configNamespace string) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
+	configNamespace string,
+) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
 	if push == nil {
 		return nil, nil
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
index 1e928e23ad..bda93ee85f 100644
--- a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
@@ -40,6 +40,7 @@ import (
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/pkg/util/protomarshal"
 )
 
@@ -1307,3 +1308,661 @@ func TestLoop(t *testing.T) {
 		},
 	})
 }
+
+const (
+	TimeOlder = "2019-01-01T00:00:00Z"
+	TimeBase  = "2020-01-01T00:00:00Z"
+	TimeNewer = "2021-01-01T00:00:00Z"
+)
+
+type Configer interface {
+	Config(variant string) string
+}
+
+type vsArgs struct {
+	Namespace string
+	Match     string
+	Dest      string
+	Port      int
+	PortMatch int
+	Time      string
+}
+
+func (args vsArgs) Config(variant string) string {
+	if args.Time == "" {
+		args.Time = TimeBase
+	}
+
+	return tmpl.MustEvaluate(`apiVersion: networking.istio.io/v1alpha3
+kind: VirtualService
+metadata:
+  name: "{{.Namespace}}{{.Match | replace "*" "wild"}}{{.Dest}}"
+  namespace: {{.Namespace}}
+  creationTimestamp: "{{.Time}}"
+spec:
+  hosts:
+  - "{{.Match}}"
+  http:
+  - route:
+    - destination:
+        host: {{.Dest}}
+{{ with .Port }}
+        port:
+          number: {{.}}
+{{ end }}
+{{ with .PortMatch }}
+    match:
+    - port: {{.}}
+{{ end }}
+`, args)
+}
+
+type scArgs struct {
+	Namespace string
+	Egress    []string
+}
+
+func (args scArgs) Config(variant string) string {
+	return tmpl.MustEvaluate(`apiVersion: networking.istio.io/v1alpha3
+kind: Sidecar
+metadata:
+  name: "{{.Namespace}}"
+  namespace: "{{.Namespace}}"
+spec:
+  egress:
+  - hosts:
+{{- range $val := .Egress }}
+    - "{{$val}}"
+{{- end }}
+`, args)
+}
+
+func TestSidecarRoutes(t *testing.T) {
+	knownServices := `
+apiVersion: networking.istio.io/v1alpha3
+kind: ServiceEntry
+metadata:
+  name: known-default.example.com
+  namespace: default
+spec:
+  hosts:
+  - known-default.example.com
+  addresses:
+  - 2.0.0.0
+  endpoints:
+  - address: 1.0.0.0
+  resolution: STATIC
+  ports:
+  - name: http
+    number: 80
+    protocol: HTTP
+  - name: http-other
+    number: 8080
+    protocol: HTTP
+---
+apiVersion: networking.istio.io/v1alpha3
+kind: ServiceEntry
+metadata:
+  name: alt-known-default.example.com
+  namespace: default
+spec:
+  hosts:
+  - alt-known-default.example.com
+  addresses:
+  - 2.0.0.1
+  endpoints:
+  - address: 1.0.0.1
+  resolution: STATIC
+  ports:
+  - name: http
+    number: 80
+    protocol: HTTP
+  - name: http-other
+    number: 8080
+    protocol: HTTP
+---
+apiVersion: networking.istio.io/v1alpha3
+kind: ServiceEntry
+metadata:
+  name: not-default.example.org
+  namespace: not-default
+spec:
+  hosts:
+  - not-default.example.org
+  addresses:
+  - 2.0.0.2
+  endpoints:
+  - address: 1.0.0.2
+  resolution: STATIC
+  ports:
+  - name: http
+    number: 80
+    protocol: HTTP
+  - name: http-other
+    number: 8080
+    protocol: HTTP
+---
+`
+	proxy := func(ns string) *model.Proxy {
+		return &model.Proxy{ConfigNamespace: ns}
+	}
+	cases := []struct {
+		name      string
+		cfg       []Configer
+		proxy     *model.Proxy
+		routeName string
+		expected  map[string][]string
+	}{
+		// Port 80 has special cases as there is defaulting logic around this port
+		{
+			name: "simple port 80",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "simple port 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "8080",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "unknown port 80",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "foo.com",
+				Dest:      "foo.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"foo.com": {"outbound|80||foo.com"},
+			},
+		},
+		{
+			name: "unknown port 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "foo.com",
+				Dest:      "foo.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "8080",
+			// For unknown services, we only will add a route to the port 80
+			expected: map[string][]string{
+				"default.com": nil,
+			},
+		},
+		{
+			name: "unknown port 8080 match 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "foo.com",
+				Dest:      "foo.com",
+				PortMatch: 8080,
+			}},
+			proxy:     proxy("default"),
+			routeName: "8080",
+			// For unknown services, we only will add a route to the port 80
+			expected: map[string][]string{
+				"foo.com": nil,
+			},
+		},
+		{
+			name: "unknown port 8080 dest 8080 ",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "foo.com",
+				Dest:      "foo.com",
+				Port:      8080,
+			}},
+			proxy:     proxy("default"),
+			routeName: "8080",
+			// For unknown services, we only will add a route to the port 80
+			expected: map[string][]string{
+				"default.com": nil,
+			},
+		},
+		{
+			name: "producer rule port 80",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "producer rule port 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "8080",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "consumer rule port 80",
+			cfg: []Configer{vsArgs{
+				Namespace: "not-default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "consumer rule port 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "not-default",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "8080",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "arbitrary rule port 80",
+			cfg: []Configer{vsArgs{
+				Namespace: "arbitrary",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "arbitrary rule port 8080",
+			cfg: []Configer{vsArgs{
+				Namespace: "arbitrary",
+				Match:     "known-default.example.com",
+				Dest:      "alt-known-default.example.com",
+			}},
+			proxy:     proxy("not-default"),
+			routeName: "8080",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+		},
+		{
+			name: "multiple rules 80",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "arbitrary",
+					Match:     "known-default.example.com",
+					Dest:      "arbitrary.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "default.example.com",
+					Time:      TimeBase,
+				},
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "known-default.example.com",
+					Dest:      "not-default.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Oldest wins
+				"known-default.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "multiple rules 8080",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "arbitrary",
+					Match:     "known-default.example.com",
+					Dest:      "arbitrary.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "default.example.com",
+					Time:      TimeBase,
+				},
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "known-default.example.com",
+					Dest:      "not-default.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("not-default"),
+			routeName: "8080",
+			expected: map[string][]string{
+				// Oldest wins
+				"known-default.example.com": {"outbound|8080||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard random",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "*.unknown.example.com",
+				Dest:      "arbitrary.example.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// match no VS, get default config
+				"alt-known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+				"known-default.example.com":     {"outbound|80||known-default.example.com"},
+				// Wildcard doesn't match any known services, insert it as-is
+				"*.unknown.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard match with sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/*.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||arbitrary.example.com"},
+				"known-default.example.com":     {"outbound|80||arbitrary.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard first then explicit",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"}, // oldest wins
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "explicit first then wildcard",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeNewer,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeOlder,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||explicit.example.com"}, // oldest wins
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit with sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"default/known-default.example.com", "default/alt-known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Even though we did not import `*.example.com`, the VS attaches
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "explicit first then wildcard with sidecar cross namespace",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"default/known-default.example.com", "default/alt-known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Similar to above, but now the older wildcard VS is in a complete different namespace which we don't import
+				"alt-known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+				"known-default.example.com":     {"outbound|80||explicit.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit cross namespace",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Wildcard is older, so it wins, even though it is cross namespace
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit unknown",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.tld",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "example.tld",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// wildcard does not match
+				"known-default.example.com": {"outbound|80||known-default.example.com"},
+				// Even though its less exact, this wildcard wins
+				"*.tld":         {"outbound|80||wild.example.com"},
+				"*.example.tld": nil,
+			},
+		},
+		{
+			name: "explicit match with wildcard sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "arbitrary.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/*.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"arbitrary.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard match with explicit sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "sidecar filter",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "explicit.example.com",
+					Dest:      "explicit.example.com",
+				},
+				scArgs{
+					Namespace: "not-default",
+					Egress:    []string{"not-default/*.example.com", "not-default/not-default.example.org"},
+				},
+			},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// even though there is an *.example.com, since we do not import it we should create a wildcard matcher
+				"*.example.com": {"outbound|80||arbitrary.example.com"},
+				// We did not import this, shouldn't show up
+				"explicit.example.com": nil,
+			},
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			cfg := knownServices
+			for _, tc := range tt.cfg {
+				cfg = cfg + "\n---\n" + tc.Config("")
+			}
+			s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{ConfigString: cfg})
+			sim := simulation.NewSimulation(t, s, s.SetupProxy(tt.proxy))
+			xdstest.ValidateListeners(t, sim.Listeners)
+			xdstest.ValidateRouteConfigurations(t, sim.Routes)
+			r := xdstest.ExtractRouteConfigurations(sim.Routes)
+			vh := r[tt.routeName]
+			if vh == nil {
+				t.Fatalf("route %q not found, have %v", tt.routeName, xdstest.MapKeys(r))
+			}
+			gotHosts := xdstest.ExtractVirtualHosts(r[tt.routeName])
+			exp := tt.expected
+			for wk, wv := range exp {
+				got := gotHosts[wk]
+				if !reflect.DeepEqual(wv, got) {
+					t.Errorf("%v: wanted %v, got %v (had %v)", wk, wv, got, xdstest.MapKeys(gotHosts))
+				}
+			}
+		})
+	}
+}
diff --git a/pilot/test/xdstest/extract.go b/pilot/test/xdstest/extract.go
index acb0096b4b..e95c5d4e2a 100644
--- a/pilot/test/xdstest/extract.go
+++ b/pilot/test/xdstest/extract.go
@@ -136,6 +136,23 @@ func ExtractListener(name string, ll []*listener.Listener) *listener.Listener {
 	return nil
 }
 
+func ExtractVirtualHosts(rc *route.RouteConfiguration) map[string][]string {
+	res := map[string][]string{}
+	for _, vh := range rc.GetVirtualHosts() {
+		var dests []string
+		for _, r := range vh.Routes {
+			if dc := r.GetRoute().GetCluster(); dc != "" {
+				dests = append(dests, dc)
+			}
+		}
+		sort.Strings(dests)
+		for _, d := range vh.Domains {
+			res[d] = dests
+		}
+	}
+	return res
+}
+
 func ExtractRouteConfigurations(rc []*route.RouteConfiguration) map[string]*route.RouteConfiguration {
 	res := map[string]*route.RouteConfiguration{}
 	for _, l := range rc {
diff --git a/releasenotes/notes/vs-regression.yaml b/releasenotes/notes/vs-regression.yaml
new file mode 100644
index 0000000000..99c1ad30a2
--- /dev/null
+++ b/releasenotes/notes/vs-regression.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+- 37691
+releaseNotes:
+- |
+  **Fixed** an issue causing some cross-namespace VirtualServices to be incorrectly ignored after upgrading to Istio 1.12+.
-- 
2.31.1

