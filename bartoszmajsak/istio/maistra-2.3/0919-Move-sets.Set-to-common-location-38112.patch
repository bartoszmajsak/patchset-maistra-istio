From d6e7919063351ecef8c2f12d28d7fd8ac8acfd4e Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Fri, 25 Mar 2022 08:10:22 -0700
Subject: Move sets.Set to common location (#38112)

Also cleaning it up a bit and modifying a number of callsites to use it.
---
 istioctl/pkg/writer/envoy/configdump/route.go |  6 +-
 operator/pkg/component/component.go           |  2 +-
 operator/pkg/controlplane/control_plane.go    |  4 +-
 pilot/pkg/config/aggregate/config.go          | 14 ++--
 pilot/pkg/config/file/store.go                |  5 +-
 pilot/pkg/config/kube/gateway/controller.go   | 10 +--
 pilot/pkg/config/kube/gateway/conversion.go   |  8 +-
 .../config/kube/gateway/conversion_test.go    |  4 +-
 pilot/pkg/credentials/kube/secrets_test.go    |  4 +-
 pilot/pkg/features/pilot.go                   |  4 +-
 pilot/pkg/grpc/grpc.go                        |  4 +-
 pilot/pkg/model/config.go                     |  5 +-
 pilot/pkg/model/envoyfilter.go                |  2 +-
 pilot/pkg/model/gateway.go                    |  8 +-
 pilot/pkg/model/network.go                    |  4 +-
 pilot/pkg/model/network_test.go               |  4 +-
 pilot/pkg/model/push_context.go               | 18 ++---
 pilot/pkg/model/service.go                    |  4 +-
 pilot/pkg/model/telemetry.go                  | 12 +--
 pilot/pkg/model/virtualservice.go             |  6 +-
 pilot/pkg/model/xds_cache.go                  | 12 +--
 pilot/pkg/networking/core/v1alpha3/cluster.go |  6 +-
 .../core/v1alpha3/cluster_builder.go          |  2 +-
 .../extension_configuration_patch.go          |  4 +-
 .../v1alpha3/envoyfilter/listener_patch.go    |  4 +-
 .../core/v1alpha3/envoyfilter/rc_patch.go     |  4 +-
 .../core/v1alpha3/extension/wasmplugin.go     |  4 +-
 pilot/pkg/networking/core/v1alpha3/gateway.go |  4 +-
 .../pkg/networking/core/v1alpha3/httproute.go |  4 +-
 .../pkg/networking/core/v1alpha3/listener.go  |  4 +-
 pilot/pkg/networking/grpcgen/cds.go           |  4 +-
 pilot/pkg/networking/grpcgen/lds.go           |  8 +-
 pilot/pkg/networking/grpcgen/lds_test.go      | 40 +++++-----
 pilot/pkg/networking/plugin/authn/util.go     |  4 +-
 .../serviceregistry/kube/controller/pod.go    |  4 +-
 .../util/workloadinstances/map.go             |  6 +-
 pilot/pkg/simulation/traffic.go               |  6 +-
 pilot/pkg/status/distribution/reporter.go     | 13 ++--
 .../pkg/status/distribution/reporter_test.go  |  9 ++-
 pilot/pkg/trustbundle/trustbundle.go          | 10 +--
 pilot/pkg/xds/ads.go                          |  4 +-
 pilot/pkg/xds/ads_test.go                     |  6 +-
 pilot/pkg/xds/delta.go                        | 12 +--
 pilot/pkg/xds/deltatest.go                    | 20 ++---
 pilot/pkg/xds/discovery.go                    |  2 +-
 pilot/pkg/xds/eds.go                          |  2 +-
 pilot/pkg/xds/eds_test.go                     |  6 +-
 pilot/test/xdstest/extract.go                 |  4 +-
 pkg/bootstrap/config.go                       |  7 +-
 pkg/config/analysis/analyzer.go               |  4 +-
 .../analysis/analyzers/analyzers_test.go      | 10 +--
 .../analysis/analyzers/webhook/webhook.go     | 16 ++--
 pkg/config/analysis/local/istiod_analyze.go   |  7 +-
 pkg/config/mesh/mesh.go                       |  4 +-
 pkg/config/schema/codegen/collections.go      |  9 ++-
 pkg/config/security/security.go               |  4 +-
 pkg/config/validation/validation.go           | 22 +++---
 pkg/dns/client/dns.go                         | 19 ++---
 pkg/envoy/agent.go                            |  4 +-
 pkg/kube/inject/initializer.go                |  4 +-
 pkg/kube/inject/inject_test.go                |  6 +-
 pkg/kube/inject/webhook.go                    |  4 +-
 pkg/kube/multicluster/secretcontroller.go     |  4 +-
 .../multicluster/secretcontroller_test.go     |  4 +-
 pkg/security/mock.go                          |  4 +-
 .../components/echo/deployment/builder.go     | 14 ++--
 .../components/echo/echotest/filters.go       |  7 +-
 .../components/echo/namespacedname.go         |  2 +-
 pkg/test/framework/resource/settings.go       |  4 +-
 pkg/test/framework/suitecontext.go            | 13 ++--
 {pilot/pkg => pkg}/util/sets/string.go        | 73 +++++++++++++------
 {pilot/pkg => pkg}/util/sets/string_test.go   | 48 ++++++------
 pkg/wasm/cache.go                             |  4 +-
 security/pkg/nodeagent/cache/secretcache.go   |  4 +-
 .../caclient/providers/google-cas/client.go   | 18 ++---
 security/pkg/nodeagent/sds/sdsservice.go      |  6 +-
 tests/fuzz/regression_test.go                 |  6 +-
 tests/integration/pilot/common/routing.go     |  4 +-
 tests/integration/pilot/validation_test.go    | 29 ++++----
 .../telemetry/stackdriver/common.go           |  4 +-
 tools/bug-report/pkg/bugreport/bugreport.go   | 21 +++---
 tools/bug-report/pkg/filter/filter.go         | 30 ++------
 tools/bug-report/pkg/kubectlcmd/kubectlcmd.go |  9 ++-
 tools/docker-builder/main.go                  | 20 ++---
 tools/docker-builder/types.go                 |  8 +-
 .../pkg/builder/iptables_builder_impl.go      | 21 +++---
 .../pkg/dependencies/implementation.go        |  4 +-
 87 files changed, 414 insertions(+), 403 deletions(-)
 rename {pilot/pkg => pkg}/util/sets/string.go (71%)
 rename {pilot/pkg => pkg}/util/sets/string_test.go (80%)

diff --git a/istioctl/pkg/writer/envoy/configdump/route.go b/istioctl/pkg/writer/envoy/configdump/route.go
index c66b5c7947..cebd878e36 100644
--- a/istioctl/pkg/writer/envoy/configdump/route.go
+++ b/istioctl/pkg/writer/envoy/configdump/route.go
@@ -28,8 +28,8 @@
 
 	protio "istio.io/istio/istioctl/pkg/util/proto"
 	pilot_util "istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // RouteFilter is used to pass filter information into route based config writer print functions
@@ -111,8 +111,8 @@ func describeRouteDomains(domains []string) string {
 }
 
 func unexpandDomains(domains []string) []string {
-	unique := sets.NewSet(domains...)
-	shouldDelete := sets.NewSet()
+	unique := sets.NewWith(domains...)
+	shouldDelete := sets.New()
 	for _, h := range domains {
 		stripFull := strings.TrimSuffix(h, ".svc.cluster.local")
 		if _, f := unique[stripFull]; f && stripFull != h {
diff --git a/operator/pkg/component/component.go b/operator/pkg/component/component.go
index b743e6880c..f0fffe876f 100644
--- a/operator/pkg/component/component.go
+++ b/operator/pkg/component/component.go
@@ -31,7 +31,7 @@
 	"istio.io/istio/operator/pkg/patch"
 	"istio.io/istio/operator/pkg/tpath"
 	"istio.io/istio/operator/pkg/translate"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
diff --git a/operator/pkg/controlplane/control_plane.go b/operator/pkg/controlplane/control_plane.go
index d9a3a0aed8..61019a4fb3 100644
--- a/operator/pkg/controlplane/control_plane.go
+++ b/operator/pkg/controlplane/control_plane.go
@@ -24,7 +24,7 @@
 	"istio.io/istio/operator/pkg/name"
 	"istio.io/istio/operator/pkg/translate"
 	"istio.io/istio/operator/pkg/util"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // IstioControlPlane is an installation of an Istio control plane.
@@ -40,7 +40,7 @@ func NewIstioControlPlane(installSpec *v1alpha1.IstioOperatorSpec, translator *t
 	opts := &component.Options{
 		InstallSpec: installSpec,
 		Translator:  translator,
-		Filter:      sets.NewSet(filter...),
+		Filter:      sets.NewWith(filter...),
 	}
 	for _, c := range name.AllCoreComponentNames {
 		o := *opts
diff --git a/pilot/pkg/config/aggregate/config.go b/pilot/pkg/config/aggregate/config.go
index 5aed7719e0..91011507a5 100644
--- a/pilot/pkg/config/aggregate/config.go
+++ b/pilot/pkg/config/aggregate/config.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/util/sets"
 )
 
 var errorUnsupported = errors.New("unsupported operation: the config aggregator is read-only")
@@ -113,20 +114,19 @@ func (cr *store) List(typ config.GroupVersionKind, namespace string) ([]config.C
 	var errs *multierror.Error
 	var configs []config.Config
 	// Used to remove duplicated config
-	configMap := make(map[string]struct{})
+	configMap := sets.New()
 
 	for _, store := range cr.stores[typ] {
 		storeConfigs, err := store.List(typ, namespace)
 		if err != nil {
 			errs = multierror.Append(errs, err)
 		}
-		for _, config := range storeConfigs {
-			key := config.GroupVersionKind.Kind + config.Namespace + config.Name
-			if _, exist := configMap[key]; exist {
-				continue
+		for _, cfg := range storeConfigs {
+			key := cfg.GroupVersionKind.Kind + cfg.Namespace + cfg.Name
+			if !configMap.Contains(key) {
+				configs = append(configs, cfg)
+				configMap.Insert(key)
 			}
-			configs = append(configs, config)
-			configMap[key] = struct{}{}
 		}
 	}
 	return configs, errs.ErrorOrNil()
diff --git a/pilot/pkg/config/file/store.go b/pilot/pkg/config/file/store.go
index e2f4006b41..441cb5c82a 100644
--- a/pilot/pkg/config/file/store.go
+++ b/pilot/pkg/config/file/store.go
@@ -46,6 +46,7 @@
 	"istio.io/istio/pkg/config/schema/collection"
 	schemaresource "istio.io/istio/pkg/config/schema/resource"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -175,9 +176,9 @@ func (s *KubeSource) ContentNames() map[string]struct{} {
 	s.mu.Lock()
 	defer s.mu.Unlock()
 
-	result := make(map[string]struct{})
+	result := sets.New()
 	for n := range s.byFile {
-		result[n] = struct{}{}
+		result.Insert(n)
 	}
 
 	return result
diff --git a/pilot/pkg/config/kube/gateway/controller.go b/pilot/pkg/config/kube/gateway/controller.go
index 43f07b089b..cc8dad0dbb 100644
--- a/pilot/pkg/config/kube/gateway/controller.go
+++ b/pilot/pkg/config/kube/gateway/controller.go
@@ -33,12 +33,12 @@
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
 	"istio.io/istio/pilot/pkg/status"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/util/sets"
 	istiolog "istio.io/pkg/log"
 )
 
@@ -304,9 +304,9 @@ func (c *Controller) SecretAllowed(resourceName string, namespace string) bool {
 func (c *Controller) namespaceEvent(oldObj interface{}, newObj interface{}) {
 	// First, find all the label keys on the old/new namespace. We include NamespaceNameLabel
 	// since we have special logic to always allow this on namespace.
-	touchedNamespaceLabels := sets.NewSet(NamespaceNameLabel)
-	touchedNamespaceLabels.Insert(getLabelKeys(oldObj)...)
-	touchedNamespaceLabels.Insert(getLabelKeys(newObj)...)
+	touchedNamespaceLabels := sets.NewWith(NamespaceNameLabel)
+	touchedNamespaceLabels.InsertAll(getLabelKeys(oldObj)...)
+	touchedNamespaceLabels.InsertAll(getLabelKeys(newObj)...)
 
 	// Next, we find all keys our Gateways actually reference.
 	c.stateMu.RLock()
@@ -316,7 +316,7 @@ func (c *Controller) namespaceEvent(oldObj interface{}, newObj interface{}) {
 	// If there was any overlap, then a relevant namespace label may have changed, and we trigger a
 	// push A more exact check could actually determine if the label selection result actually changed.
 	// However, this is a much simpler approach that is likely to scale well enough for now.
-	if !intersection.Empty() && c.namespaceHandler != nil {
+	if !intersection.IsEmpty() && c.namespaceHandler != nil {
 		log.Debugf("namespace labels changed, triggering namespace handler: %v", intersection.UnsortedList())
 		c.namespaceHandler(config.Config{}, config.Config{}, model.EventUpdate)
 	}
diff --git a/pilot/pkg/config/kube/gateway/conversion.go b/pilot/pkg/config/kube/gateway/conversion.go
index 43f9593047..9c1e42c878 100644
--- a/pilot/pkg/config/kube/gateway/conversion.go
+++ b/pilot/pkg/config/kube/gateway/conversion.go
@@ -32,11 +32,11 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/model/credentials"
 	"istio.io/istio/pilot/pkg/model/kstatus"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const (
@@ -146,7 +146,7 @@ func convertReferencePolicies(r *KubernetesResources) map[Reference]map[Referenc
 				}
 				if _, f := res[fromKey][toKey]; !f {
 					res[fromKey][toKey] = &AllowedReferences{
-						AllowedNames: sets.NewSet(),
+						AllowedNames: sets.New(),
 					}
 				}
 				if to.Name != nil {
@@ -1175,7 +1175,7 @@ func convertGateways(r *KubernetesResources) ([]config.Config, map[parentKey]map
 	gwMap := map[parentKey]map[k8s.SectionName]*parentInfo{}
 	// namespaceLabelReferences keeps track of all namespace label keys referenced by Gateways. This is
 	// used to ensure we handle namespace updates for those keys.
-	namespaceLabelReferences := sets.NewSet()
+	namespaceLabelReferences := sets.New()
 	classes := getGatewayClasses(r)
 	for _, obj := range r.Gateway {
 		obj := obj
@@ -1213,7 +1213,7 @@ func convertGateways(r *KubernetesResources) ([]config.Config, map[parentKey]map
 		invalidListeners := []k8s.SectionName{}
 		for i, l := range kgw.Listeners {
 			i := i
-			namespaceLabelReferences.Insert(getNamespaceLabelReferences(l.AllowedRoutes)...)
+			namespaceLabelReferences.InsertAll(getNamespaceLabelReferences(l.AllowedRoutes)...)
 			server, ok := buildListener(r, obj, l, i)
 			if !ok {
 				invalidListeners = append(invalidListeners, l.Name)
diff --git a/pilot/pkg/config/kube/gateway/conversion_test.go b/pilot/pkg/config/kube/gateway/conversion_test.go
index ee82922bf8..c57a583e1b 100644
--- a/pilot/pkg/config/kube/gateway/conversion_test.go
+++ b/pilot/pkg/config/kube/gateway/conversion_test.go
@@ -33,7 +33,6 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/test/util"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config"
@@ -41,6 +40,7 @@
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/util/assert"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func TestConvertResources(t *testing.T) {
@@ -358,7 +358,7 @@ func splitOutput(configs []config.Config) OutputResources {
 
 func splitInput(configs []config.Config) *KubernetesResources {
 	out := &KubernetesResources{}
-	namespaces := sets.NewSet()
+	namespaces := sets.New()
 	for _, c := range configs {
 		namespaces.Insert(c.Namespace)
 		switch c.GroupVersionKind {
diff --git a/pilot/pkg/credentials/kube/secrets_test.go b/pilot/pkg/credentials/kube/secrets_test.go
index a57e891298..85d7888fe7 100644
--- a/pilot/pkg/credentials/kube/secrets_test.go
+++ b/pilot/pkg/credentials/kube/secrets_test.go
@@ -25,10 +25,10 @@
 	"k8s.io/client-go/kubernetes/fake"
 	k8stesting "k8s.io/client-go/testing"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	cluster2 "istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/multicluster"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func makeSecret(name string, data map[string]string) *corev1.Secret {
@@ -226,7 +226,7 @@ func errString(e error) string {
 }
 
 func allowIdentities(c kube.Client, identities ...string) {
-	allowed := sets.NewSet(identities...)
+	allowed := sets.NewWith(identities...)
 	c.Kube().(*fake.Clientset).Fake.PrependReactor("create", "subjectaccessreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
 		a := action.(k8stesting.CreateAction).GetObject().(*authorizationv1.SubjectAccessReview)
 		if allowed.Contains(a.Spec.User) {
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index bec070fcfd..755b9a6bbd 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -20,9 +20,9 @@
 
 	"google.golang.org/protobuf/types/known/durationpb"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/jwt"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/env"
 	"istio.io/pkg/log"
 )
@@ -617,7 +617,7 @@
 			"Comma separated list of potentially insecure kubeconfig authentication options that are allowed for multicluster authentication."+
 				"Support values: all authProviders (`gcp`, `azure`, `exec`, `openstack`), "+
 				"`clientKey`, `clientCertificate`, `tokenFile`, and `exec`.").Get()
-		return sets.NewSet(strings.Split(v, ",")...)
+		return sets.NewWith(strings.Split(v, ",")...)
 	}()
 
 	VerifySDSCertificate = env.RegisterBoolVar("VERIFY_SDS_CERTIFICATE", true,
diff --git a/pilot/pkg/grpc/grpc.go b/pilot/pkg/grpc/grpc.go
index 3b25ce1af0..3eedc68cbe 100644
--- a/pilot/pkg/grpc/grpc.go
+++ b/pilot/pkg/grpc/grpc.go
@@ -26,8 +26,8 @@
 	"google.golang.org/grpc/status"
 
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
 	istiokeepalive "istio.io/istio/pkg/keepalive"
+	"istio.io/istio/pkg/util/sets"
 )
 
 type SendHandler func() error
@@ -78,7 +78,7 @@ func ServerOptions(options *istiokeepalive.Options, interceptors ...grpc.UnarySe
 	return grpcOptions
 }
 
-var expectedGrpcFailureMessages = sets.NewSet(
+var expectedGrpcFailureMessages = sets.NewWith(
 	"client disconnected",
 	"error reading from server: EOF",
 	"transport is closing",
diff --git a/pilot/pkg/model/config.go b/pilot/pkg/model/config.go
index a5f2971dae..9964816dcd 100644
--- a/pilot/pkg/model/config.go
+++ b/pilot/pkg/model/config.go
@@ -30,6 +30,7 @@
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // Statically link protobuf descriptors from UDPA
@@ -91,11 +92,11 @@ func ConfigsOfKind(configs map[ConfigKey]struct{}, kind config.GroupVersionKind)
 
 // ConfigNamesOfKind extracts config names of the specified kind.
 func ConfigNamesOfKind(configs map[ConfigKey]struct{}, kind config.GroupVersionKind) map[string]struct{} {
-	ret := make(map[string]struct{})
+	ret := sets.New()
 
 	for conf := range configs {
 		if conf.Kind == kind {
-			ret[conf.Name] = struct{}{}
+			ret.Insert(conf.Name)
 		}
 	}
 
diff --git a/pilot/pkg/model/envoyfilter.go b/pilot/pkg/model/envoyfilter.go
index efe17bc3d0..04b3819c99 100644
--- a/pilot/pkg/model/envoyfilter.go
+++ b/pilot/pkg/model/envoyfilter.go
@@ -21,10 +21,10 @@
 	"google.golang.org/protobuf/proto"
 
 	networking "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/xds"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // EnvoyFilterWrapper is a wrapper for the EnvoyFilter api object with pre-processed data
diff --git a/pilot/pkg/model/gateway.go b/pilot/pkg/model/gateway.go
index c20e3c56a9..0160454cda 100644
--- a/pilot/pkg/model/gateway.go
+++ b/pilot/pkg/model/gateway.go
@@ -23,11 +23,11 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model/credentials"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/gateway"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/monitoring"
 )
 
@@ -140,8 +140,8 @@ func MergeGateways(gateways []gatewayWithInstances, proxy *Proxy, ps *PushContex
 	serversByRouteName := make(map[string][]*networking.Server)
 	tlsServerInfo := make(map[*networking.Server]*TLSServerInfo)
 	gatewayNameForServer := make(map[*networking.Server]string)
-	verifiedCertificateReferences := sets.NewSet()
-	http3AdvertisingRoutes := make(map[string]struct{})
+	verifiedCertificateReferences := sets.New()
+	http3AdvertisingRoutes := sets.New()
 	tlsHostsByPort := map[uint32]sets.Set{} // port -> host set
 	autoPassthrough := false
 
@@ -190,7 +190,7 @@ func MergeGateways(gateways []gatewayWithInstances, proxy *Proxy, ps *PushContex
 					// To avoid this, we need to make sure we don't have duplicated hosts, which will become
 					// SNI filter chain matches.
 					if tlsHostsByPort[resolvedPort] == nil {
-						tlsHostsByPort[resolvedPort] = sets.NewSet()
+						tlsHostsByPort[resolvedPort] = sets.New()
 					}
 					if duplicateHosts := CheckDuplicates(s.Hosts, tlsHostsByPort[resolvedPort]); len(duplicateHosts) != 0 {
 						log.Debugf("skipping server on gateway %s, duplicate host names: %v", gatewayName, duplicateHosts)
diff --git a/pilot/pkg/model/network.go b/pilot/pkg/model/network.go
index 96155fec04..9b2b2e73b9 100644
--- a/pilot/pkg/model/network.go
+++ b/pilot/pkg/model/network.go
@@ -26,9 +26,9 @@
 	"github.com/miekg/dns"
 
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // NetworkGateway is the gateway of a network
@@ -169,7 +169,7 @@ func (mgr *NetworkManager) reload() NetworkGatewaySet {
 func (mgr *NetworkManager) resolveHostnameGateways(gatewaySet map[NetworkGateway]struct{}) {
 	// filter the list of gateways to resolve
 	hostnameGateways := map[string][]NetworkGateway{}
-	names := sets.NewSet()
+	names := sets.New()
 	for gw := range gatewaySet {
 		if gwIP := net.ParseIP(gw.Addr); gwIP != nil {
 			continue
diff --git a/pilot/pkg/model/network_test.go b/pilot/pkg/model/network_test.go
index f85277e439..0e0354f09e 100644
--- a/pilot/pkg/model/network_test.go
+++ b/pilot/pkg/model/network_test.go
@@ -27,11 +27,11 @@
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/memory"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func TestGatewayHostnames(t *testing.T) {
@@ -42,7 +42,7 @@ func TestGatewayHostnames(t *testing.T) {
 	})
 
 	gwHost := "test.gw.istio.io"
-	dnsServer := newFakeDNSServer(":0", 1, sets.NewSet(gwHost))
+	dnsServer := newFakeDNSServer(":0", 1, sets.NewWith(gwHost))
 	model.NetworkGatewayTestDNSServers = []string{dnsServer.Server.PacketConn.LocalAddr().String()}
 	t.Cleanup(func() {
 		if err := dnsServer.Shutdown(); err != nil {
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 3dce6b4dc4..57d4f9bf48 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -31,7 +31,6 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
@@ -40,6 +39,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/monitoring"
 )
 
@@ -732,7 +732,7 @@ func (ps *PushContext) GatewayServices(proxy *Proxy) []*Service {
 	}
 
 	// host set.
-	hostsFromGateways := sets.NewSet()
+	hostsFromGateways := sets.New()
 	for _, gw := range proxy.MergedGateway.GatewayNameForServer {
 		for _, vsConfig := range ps.VirtualServicesForGateway(proxy.ConfigNamespace, gw) {
 			vs, ok := vsConfig.Spec.(*networking.VirtualService)
@@ -770,7 +770,7 @@ func (ps *PushContext) GatewayServices(proxy *Proxy) []*Service {
 // add services from MeshConfig.ExtensionProviders
 // TODO: include cluster from EnvoyFilter such as global ratelimit [demo](https://istio.io/latest/docs/tasks/policy-enforcement/rate-limit/#global-rate-limit)
 func getHostsFromMeshConfig(ps *PushContext) sets.Set {
-	hostsFromMeshConfig := sets.NewSet()
+	hostsFromMeshConfig := sets.New()
 
 	for _, prov := range ps.Mesh.ExtensionProviders {
 		switch p := prov.Provider.(type) {
@@ -1583,13 +1583,13 @@ func (ps *PushContext) initSidecarScopes(env *Environment) error {
 
 	sidecarConfigWithSelector := make([]config.Config, 0)
 	sidecarConfigWithoutSelector := make([]config.Config, 0)
-	sidecarsWithoutSelectorByNamespace := make(map[string]struct{})
+	sidecarsWithoutSelectorByNamespace := sets.New()
 	for _, sidecarConfig := range sidecarConfigs {
 		sidecar := sidecarConfig.Spec.(*networking.Sidecar)
 		if sidecar.WorkloadSelector != nil {
 			sidecarConfigWithSelector = append(sidecarConfigWithSelector, sidecarConfig)
 		} else {
-			sidecarsWithoutSelectorByNamespace[sidecarConfig.Namespace] = struct{}{}
+			sidecarsWithoutSelectorByNamespace.Insert(sidecarConfig.Namespace)
 			sidecarConfigWithoutSelector = append(sidecarConfigWithoutSelector, sidecarConfig)
 		}
 	}
@@ -2046,8 +2046,8 @@ func (gc GatewayContext) ResolveGatewayInstances(namespace string, gwsvcs []stri
 	for _, s := range servers {
 		ports[int(s.Port.Number)] = struct{}{}
 	}
-	foundInternal := sets.NewSet()
-	foundExternal := sets.NewSet()
+	foundInternal := sets.New()
+	foundExternal := sets.New()
 	warnings := []string{}
 	for _, g := range gwsvcs {
 		svc, f := gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)][namespace]
@@ -2072,13 +2072,13 @@ func (gc GatewayContext) ResolveGatewayInstances(namespace string, gwsvcs []stri
 				foundInternal.Insert(fmt.Sprintf("%s:%d", g, port))
 				// Fetch external IPs from all clusters
 				svc.Attributes.ClusterExternalAddresses.ForEach(func(c cluster.ID, externalIPs []string) {
-					foundExternal.Insert(externalIPs...)
+					foundExternal.InsertAll(externalIPs...)
 				})
 			} else {
 				if instancesEmpty(gc.ps.ServiceIndex.instancesByPort[svcKey]) {
 					warnings = append(warnings, fmt.Sprintf("no instances found for hostname %q", g))
 				} else {
-					hintPort := sets.NewSet()
+					hintPort := sets.New()
 					for _, instances := range gc.ps.ServiceIndex.instancesByPort[svcKey] {
 						for _, i := range instances {
 							if i.Endpoint.EndpointPort == uint32(port) {
diff --git a/pilot/pkg/model/service.go b/pilot/pkg/model/service.go
index 16b4382f55..54a70e2493 100644
--- a/pilot/pkg/model/service.go
+++ b/pilot/pkg/model/service.go
@@ -34,7 +34,6 @@
 	"istio.io/api/label"
 	"istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
@@ -42,6 +41,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/visibility"
 	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // Service describes an Istio service (e.g., catalog.mystore.com:8080)
@@ -819,7 +819,7 @@ func GetServiceAccounts(svc *Service, ports []int, discovery ServiceDiscovery) [
 			sa.Insert(si.Endpoint.ServiceAccount)
 		}
 	}
-	sa.Insert(svc.ServiceAccounts...)
+	sa.InsertAll(svc.ServiceAccounts...)
 
 	return sa.UnsortedList()
 }
diff --git a/pilot/pkg/model/telemetry.go b/pilot/pkg/model/telemetry.go
index ca19d25772..5ecb8e1720 100644
--- a/pilot/pkg/model/telemetry.go
+++ b/pilot/pkg/model/telemetry.go
@@ -34,10 +34,10 @@
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	tpb "istio.io/api/telemetry/v1alpha1"
 	"istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 	istiolog "istio.io/pkg/log"
 )
 
@@ -373,7 +373,7 @@ func (t *Telemetries) telemetryFilters(proxy *Proxy, class networking.ListenerCl
 
 	// The above result is in a nested map to deduplicate responses. This loses ordering, so we convert to
 	// a list to retain stable naming
-	allKeys := sets.NewSet(tml.UnsortedList()...)
+	allKeys := sets.NewWith(tml.UnsortedList()...)
 	for k := range tmm {
 		allKeys.Insert(k)
 	}
@@ -414,7 +414,7 @@ func (t *Telemetries) telemetryFilters(proxy *Proxy, class networking.ListenerCl
 // This currently is just the names of providers as there is no access logging configuration, but
 // in the future it will likely be extended
 func mergeLogs(logs []*tpb.AccessLogging, mesh *meshconfig.MeshConfig) (sets.Set, *tpb.AccessLogging_Filter) {
-	providers := sets.NewSet()
+	providers := sets.New()
 
 	if len(logs) == 0 {
 		for _, dp := range mesh.GetDefaultProviders().GetAccessLogging() {
@@ -435,7 +435,7 @@ func mergeLogs(logs []*tpb.AccessLogging, mesh *meshconfig.MeshConfig) (sets.Set
 			loggingFilter = m.Filter
 		}
 	}
-	inScopeProviders := sets.NewSet(providerNames...)
+	inScopeProviders := sets.NewWith(providerNames...)
 
 	parentProviders := mesh.GetDefaultProviders().GetAccessLogging()
 	for _, m := range logs {
@@ -517,10 +517,10 @@ type metricOverride struct {
 		}
 	}
 	// Record the names of all providers we should configure. Anything else we will ignore
-	inScopeProviders := sets.NewSet(providerNames...)
+	inScopeProviders := sets.NewWith(providerNames...)
 
 	parentProviders := mesh.GetDefaultProviders().GetMetrics()
-	disabledAllMetricsProviders := sets.NewSet()
+	disabledAllMetricsProviders := sets.New()
 	for _, m := range metrics {
 		providerNames := getProviderNames(m.Providers)
 		// If providers is not set, use parent's
diff --git a/pilot/pkg/model/virtualservice.go b/pilot/pkg/model/virtualservice.go
index bf39922b36..97c4fde98b 100644
--- a/pilot/pkg/model/virtualservice.go
+++ b/pilot/pkg/model/virtualservice.go
@@ -21,12 +21,12 @@
 	"google.golang.org/protobuf/proto"
 
 	networking "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // SelectVirtualServices selects the virtual services by matching given services' host names.
@@ -34,7 +34,7 @@
 func SelectVirtualServices(virtualServices []config.Config, hosts map[string][]host.Name) []config.Config {
 	importedVirtualServices := make([]config.Config, 0)
 
-	vsset := sets.NewSet()
+	vsset := sets.New()
 	addVirtualService := func(vs config.Config, hosts host.Names) {
 		vsname := vs.Name + "/" + vs.Namespace
 		rule := vs.Spec.(*networking.VirtualService)
@@ -467,7 +467,7 @@ func hasConflict(root, leaf *networking.HTTPMatchRequest) bool {
 		if len(root.Gateways) < len(leaf.Gateways) {
 			return true
 		}
-		rootGateway := sets.NewSet(root.Gateways...)
+		rootGateway := sets.NewWith(root.Gateways...)
 		for _, gw := range leaf.Gateways {
 			if !rootGateway.Contains(gw) {
 				return true
diff --git a/pilot/pkg/model/xds_cache.go b/pilot/pkg/model/xds_cache.go
index 5c00784c9c..9a97a8a9a4 100644
--- a/pilot/pkg/model/xds_cache.go
+++ b/pilot/pkg/model/xds_cache.go
@@ -25,8 +25,8 @@
 	"google.golang.org/protobuf/testing/protocmp"
 
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/monitoring"
 )
 
@@ -82,18 +82,18 @@ func size(cs int) {
 }
 
 func indexConfig(configIndex map[ConfigKey]sets.Set, k string, entry XdsCacheEntry) {
-	for _, config := range entry.DependentConfigs() {
-		if configIndex[config] == nil {
-			configIndex[config] = sets.NewSet()
+	for _, cfg := range entry.DependentConfigs() {
+		if configIndex[cfg] == nil {
+			configIndex[cfg] = sets.New()
 		}
-		configIndex[config].Insert(k)
+		configIndex[cfg].Insert(k)
 	}
 }
 
 func indexType(typeIndex map[config.GroupVersionKind]sets.Set, k string, entry XdsCacheEntry) {
 	for _, t := range entry.DependentTypes() {
 		if typeIndex[t] == nil {
-			typeIndex[t] = sets.NewSet()
+			typeIndex[t] = sets.New()
 		}
 		typeIndex[t].Insert(k)
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster.go b/pilot/pkg/networking/core/v1alpha3/cluster.go
index a8ea3bbc14..2393f8411c 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster.go
@@ -37,15 +37,15 @@
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/loadbalancer"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // deltaConfigTypes are used to detect changes and trigger delta calculations. When config updates has ONLY entries
 // in this map, then delta calculation is triggered.
-var deltaConfigTypes = sets.NewSet(gvk.ServiceEntry.Kind)
+var deltaConfigTypes = sets.NewWith(gvk.ServiceEntry.Kind)
 
 // getDefaultCircuitBreakerThresholds returns a copy of the default circuit breaker thresholds for the given traffic direction.
 func getDefaultCircuitBreakerThresholds() *cluster.CircuitBreakers_Thresholds {
@@ -101,7 +101,7 @@ func (configgen *ConfigGeneratorImpl) BuildDeltaClusters(proxy *model.Proxy, upd
 		// check with the name of our service (cluster names are in the format outbound|<port>||<hostname>.
 		_, _, svcHost, port := model.ParseSubsetKey(cluster)
 		if serviceClusters[string(svcHost)] == nil {
-			serviceClusters[string(svcHost)] = sets.NewSet()
+			serviceClusters[string(svcHost)] = sets.New()
 		}
 		serviceClusters[string(svcHost)].Insert(cluster)
 		if servicePorts[string(svcHost)] == nil {
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster_builder.go b/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
index 3fb0157313..86b7ffb3f9 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
@@ -41,7 +41,6 @@
 	"istio.io/istio/pilot/pkg/networking/util"
 	authn_model "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	istio_cluster "istio.io/istio/pkg/cluster"
@@ -50,6 +49,7 @@
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/network"
 	"istio.io/istio/pkg/security"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
diff --git a/pilot/pkg/networking/core/v1alpha3/envoyfilter/extension_configuration_patch.go b/pilot/pkg/networking/core/v1alpha3/envoyfilter/extension_configuration_patch.go
index 7c1535134d..1a5fb74f4b 100644
--- a/pilot/pkg/networking/core/v1alpha3/envoyfilter/extension_configuration_patch.go
+++ b/pilot/pkg/networking/core/v1alpha3/envoyfilter/extension_configuration_patch.go
@@ -20,7 +20,7 @@
 
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -30,7 +30,7 @@ func InsertedExtensionConfigurations(efw *model.EnvoyFilterWrapper, names []stri
 	if efw == nil {
 		return result
 	}
-	hasName := sets.NewSet(names...)
+	hasName := sets.NewWith(names...)
 	for _, p := range efw.Patches[networking.EnvoyFilter_EXTENSION_CONFIG] {
 		if p.Operation != networking.EnvoyFilter_Patch_ADD {
 			continue
diff --git a/pilot/pkg/networking/core/v1alpha3/envoyfilter/listener_patch.go b/pilot/pkg/networking/core/v1alpha3/envoyfilter/listener_patch.go
index 2793807533..b44bdd0b52 100644
--- a/pilot/pkg/networking/core/v1alpha3/envoyfilter/listener_patch.go
+++ b/pilot/pkg/networking/core/v1alpha3/envoyfilter/listener_patch.go
@@ -27,8 +27,8 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/util/runtime"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/xds"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -239,7 +239,7 @@ func mergeTransportSocketListener(fc *xdslistener.FilterChain, lp *model.EnvoyFi
 func patchNetworkFilters(patchContext networking.EnvoyFilter_PatchContext,
 	patches map[networking.EnvoyFilter_ApplyTo][]*model.EnvoyFilterConfigPatchWrapper,
 	listener *xdslistener.Listener, fc *xdslistener.FilterChain) {
-	removedFilters := sets.NewSet()
+	removedFilters := sets.New()
 	for i, filter := range fc.Filters {
 		if patchNetworkFilter(patchContext, patches, listener, fc, fc.Filters[i]) {
 			removedFilters.Insert(filter.Name)
diff --git a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
index 73695650a0..c0a80b8a91 100644
--- a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
+++ b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
@@ -24,7 +24,7 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/util/runtime"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -69,7 +69,7 @@ func ApplyRouteConfigurationPatches(
 func patchVirtualHosts(patchContext networking.EnvoyFilter_PatchContext,
 	patches map[networking.EnvoyFilter_ApplyTo][]*model.EnvoyFilterConfigPatchWrapper,
 	routeConfiguration *route.RouteConfiguration, portMap model.GatewayPortMap) {
-	removedVirtualHosts := sets.NewSet()
+	removedVirtualHosts := sets.New()
 	// first do removes/merges/replaces
 	for i := range routeConfiguration.VirtualHosts {
 		if patchVirtualHost(patchContext, patches, routeConfiguration, routeConfiguration.VirtualHosts, i, portMap) {
diff --git a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
index 84e442c58e..0b08a570e1 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
@@ -25,7 +25,7 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking"
 	securitymodel "istio.io/istio/pilot/pkg/security/model"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 
 	// include for registering wasm logging scope
 	_ "istio.io/istio/pkg/wasm"
@@ -147,7 +147,7 @@ func InsertedExtensionConfigurations(
 	if len(wasmPlugins) == 0 {
 		return result
 	}
-	hasName := sets.NewSet(names...)
+	hasName := sets.NewWith(names...)
 	for _, list := range wasmPlugins {
 		for _, p := range list {
 			if !hasName.Contains(p.ExtensionConfiguration.Name) {
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway.go b/pilot/pkg/networking/core/v1alpha3/gateway.go
index 18f8cc9047..5bc9ec9a2f 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway.go
@@ -39,7 +39,6 @@
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
 	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/gateway"
 	"istio.io/istio/pkg/config/host"
@@ -47,6 +46,7 @@
 	"istio.io/istio/pkg/config/security"
 	"istio.io/istio/pkg/proto"
 	"istio.io/istio/pkg/util/istiomultierror"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -1003,7 +1003,7 @@ func buildGatewayVirtualHostDomains(hostname string, port int) []string {
 func filteredGatewayCipherSuites(server *networking.Server) []string {
 	suites := server.Tls.CipherSuites
 	ret := make([]string, 0, len(suites))
-	validCiphers := sets.NewSet()
+	validCiphers := sets.New()
 	for _, s := range suites {
 		if security.IsValidCipherSuite(s) {
 			if !validCiphers.Contains(s) {
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index acc92f372e..9bdef0efb1 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -31,12 +31,12 @@
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/proto"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const (
@@ -407,7 +407,7 @@ func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext
 	for _, virtualHostWrapper := range virtualHostWrappers {
 		for _, svc := range virtualHostWrapper.Services {
 			name := util.DomainName(string(svc.Hostname), virtualHostWrapper.Port)
-			knownFQDN.Insert(name, string(svc.Hostname))
+			knownFQDN.InsertAll(name, string(svc.Hostname))
 		}
 	}
 
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index a4e9a66996..aca0ea7419 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -42,7 +42,6 @@
 	"istio.io/istio/pilot/pkg/networking/util"
 	authn_model "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pilot/pkg/xds/requestidextension"
 	"istio.io/istio/pkg/config"
@@ -51,6 +50,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/security"
 	"istio.io/istio/pkg/proto"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 	"istio.io/pkg/monitoring"
 )
@@ -203,7 +203,7 @@ func (configgen *ConfigGeneratorImpl) BuildListenerTLSContext(serverTLSSettings
 // Invalid cipher suites lead Envoy to NACKing. This filters the list down to just the supported set.
 func filteredSidecarCipherSuites(suites []string) []string {
 	ret := make([]string, 0, len(suites))
-	validCiphers := sets.NewSet()
+	validCiphers := sets.New()
 	for _, s := range suites {
 		if security.IsValidCipherSuite(s) {
 			if !validCiphers.Contains(s) {
diff --git a/pilot/pkg/networking/grpcgen/cds.go b/pilot/pkg/networking/grpcgen/cds.go
index 6328a7440f..991cc916ce 100644
--- a/pilot/pkg/networking/grpcgen/cds.go
+++ b/pilot/pkg/networking/grpcgen/cds.go
@@ -26,8 +26,8 @@
 	"istio.io/istio/pilot/pkg/model"
 	corexds "istio.io/istio/pilot/pkg/networking/core/v1alpha3"
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // BuildClusters handles a gRPC CDS request, used with the 'ApiListener' style of requests.
@@ -66,7 +66,7 @@ func newClusterFilter(names []string) map[string]sets.Set {
 		dir, _, hn, p := model.ParseSubsetKey(name)
 		defaultKey := model.BuildSubsetKey(dir, "", hn, p)
 		if _, ok := filter[defaultKey]; !ok {
-			filter[defaultKey] = sets.NewSet()
+			filter[defaultKey] = sets.New()
 		}
 		filter[defaultKey].Insert(name)
 	}
diff --git a/pilot/pkg/networking/grpcgen/lds.go b/pilot/pkg/networking/grpcgen/lds.go
index c0274959f9..d44784dedb 100644
--- a/pilot/pkg/networking/grpcgen/lds.go
+++ b/pilot/pkg/networking/grpcgen/lds.go
@@ -35,10 +35,10 @@
 	"istio.io/istio/pilot/pkg/security/authn"
 	"istio.io/istio/pilot/pkg/security/authn/factory"
 	authzmodel "istio.io/istio/pilot/pkg/security/authz/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/istio-agent/grpcxds"
+	"istio.io/istio/pkg/util/sets"
 )
 
 var supportedFilters = []*hcm.HttpFilter{
@@ -335,7 +335,7 @@ func (ln *listenerName) includesPort(port string) bool {
 func (f listenerNames) includes(s string) (listenerName, bool) {
 	if len(f) == 0 {
 		// filter is empty, include everything
-		return listenerName{RequestedNames: sets.NewSet(s)}, true
+		return listenerName{RequestedNames: sets.NewWith(s)}, true
 	}
 	n, ok := f[s]
 	return n, ok
@@ -356,7 +356,7 @@ func newListenerNameFilter(names []string, node *model.Proxy) listenerNames {
 	for _, name := range names {
 		// inbound, create a simple entry and move on
 		if strings.HasPrefix(name, grpcxds.ServerListenerNamePrefix) {
-			filter[name] = listenerName{RequestedNames: sets.NewSet(name)}
+			filter[name] = listenerName{RequestedNames: sets.NewWith(name)}
 			continue
 		}
 
@@ -376,7 +376,7 @@ func newListenerNameFilter(names []string, node *model.Proxy) listenerNames {
 		for _, name := range allNames {
 			ln, ok := filter[name]
 			if !ok {
-				ln = listenerName{RequestedNames: sets.NewSet()}
+				ln = listenerName{RequestedNames: sets.New()}
 			}
 			ln.RequestedNames.Insert(requestedName)
 
diff --git a/pilot/pkg/networking/grpcgen/lds_test.go b/pilot/pkg/networking/grpcgen/lds_test.go
index a788e0eb1b..0515893339 100644
--- a/pilot/pkg/networking/grpcgen/lds_test.go
+++ b/pilot/pkg/networking/grpcgen/lds_test.go
@@ -22,8 +22,8 @@
 	"github.com/google/go-cmp/cmp"
 
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/istio-agent/grpcxds"
+	"istio.io/istio/pkg/util/sets"
 )
 
 var node = &model.Proxy{DNSDomain: "ns.svc.cluster.local", Metadata: &model.NodeMetadata{Namespace: "ns"}}
@@ -38,20 +38,20 @@ func TestListenerNameFilter(t *testing.T) {
 			in: []string{"foo.com:80", "foo.com:443", "wildcard.com"},
 			want: listenerNames{
 				"foo.com": {
-					RequestedNames: sets.NewSet("foo.com"),
-					Ports:          sets.NewSet("80", "443"),
+					RequestedNames: sets.NewWith("foo.com"),
+					Ports:          sets.NewWith("80", "443"),
 				},
-				"wildcard.com": {RequestedNames: sets.NewSet("wildcard.com")},
+				"wildcard.com": {RequestedNames: sets.NewWith("wildcard.com")},
 			},
 		},
 		"plain-host clears port-map": {
 			in:   []string{"foo.com:80", "foo.com"},
-			want: listenerNames{"foo.com": {RequestedNames: sets.NewSet("foo.com")}},
+			want: listenerNames{"foo.com": {RequestedNames: sets.NewWith("foo.com")}},
 		},
 		"port-map stays clear": {
 			in: []string{"foo.com:80", "foo.com", "foo.com:443"},
 			want: listenerNames{"foo.com": {
-				RequestedNames: sets.NewSet("foo.com"),
+				RequestedNames: sets.NewWith("foo.com"),
 			}},
 		},
 		"special listeners preserved exactly": {
@@ -63,17 +63,17 @@ func TestListenerNameFilter(t *testing.T) {
 			},
 			want: listenerNames{
 				"foo.com": {
-					RequestedNames: sets.NewSet("foo.com"),
-					Ports:          sets.NewSet("80"),
+					RequestedNames: sets.NewWith("foo.com"),
+					Ports:          sets.NewWith("80"),
 				},
 				fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo:1234"): {
-					RequestedNames: sets.NewSet(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo:1234")),
+					RequestedNames: sets.NewWith(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo:1234")),
 				},
 				fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo"): {
-					RequestedNames: sets.NewSet(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo")),
+					RequestedNames: sets.NewWith(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "foo")),
 				},
 				fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "[::]:8076"): {
-					RequestedNames: sets.NewSet(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "[::]:8076")),
+					RequestedNames: sets.NewWith(fmt.Sprintf(grpcxds.ServerListenerNameTemplate, "[::]:8076")),
 				},
 			},
 			wantInbound: []string{
@@ -94,26 +94,26 @@ func TestListenerNameFilter(t *testing.T) {
 				"foo.ns.svc.cluster.local:83",
 			},
 			want: listenerNames{
-				"bar":        {RequestedNames: sets.NewSet("bar")},
-				"bar.ns":     {RequestedNames: sets.NewSet("bar.ns")},
-				"bar.ns.svc": {RequestedNames: sets.NewSet("bar.ns.svc")},
-				"bar.ns.svc.cluster.local": {RequestedNames: sets.NewSet(
+				"bar":        {RequestedNames: sets.NewWith("bar")},
+				"bar.ns":     {RequestedNames: sets.NewWith("bar.ns")},
+				"bar.ns.svc": {RequestedNames: sets.NewWith("bar.ns.svc")},
+				"bar.ns.svc.cluster.local": {RequestedNames: sets.NewWith(
 					"bar",
 					"bar.ns",
 					"bar.ns.svc",
 					"bar.ns.svc.cluster.local",
 				)},
-				"foo":        {RequestedNames: sets.NewSet("foo"), Ports: sets.NewSet("80")},
-				"foo.ns":     {RequestedNames: sets.NewSet("foo.ns"), Ports: sets.NewSet("81")},
-				"foo.ns.svc": {RequestedNames: sets.NewSet("foo.ns.svc"), Ports: sets.NewSet("82")},
+				"foo":        {RequestedNames: sets.NewWith("foo"), Ports: sets.NewWith("80")},
+				"foo.ns":     {RequestedNames: sets.NewWith("foo.ns"), Ports: sets.NewWith("81")},
+				"foo.ns.svc": {RequestedNames: sets.NewWith("foo.ns.svc"), Ports: sets.NewWith("82")},
 				"foo.ns.svc.cluster.local": {
-					RequestedNames: sets.NewSet(
+					RequestedNames: sets.NewWith(
 						"foo",
 						"foo.ns",
 						"foo.ns.svc",
 						"foo.ns.svc.cluster.local",
 					),
-					Ports: sets.NewSet("80", "81", "82", "83"),
+					Ports: sets.NewWith("80", "81", "82", "83"),
 				},
 			},
 		},
diff --git a/pilot/pkg/networking/plugin/authn/util.go b/pilot/pkg/networking/plugin/authn/util.go
index 5691e6629e..3abc075c79 100644
--- a/pilot/pkg/networking/plugin/authn/util.go
+++ b/pilot/pkg/networking/plugin/authn/util.go
@@ -17,7 +17,7 @@
 import (
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func TrustDomainsForValidation(meshConfig *meshconfig.MeshConfig) []string {
@@ -30,7 +30,7 @@ func TrustDomainsForValidation(meshConfig *meshconfig.MeshConfig) []string {
 }
 
 func dedupTrustDomains(tds []string) []string {
-	known := sets.NewSet()
+	known := sets.New()
 	deduped := make([]string, 0, len(tds))
 
 	for _, td := range tds {
diff --git a/pilot/pkg/serviceregistry/kube/controller/pod.go b/pilot/pkg/serviceregistry/kube/controller/pod.go
index 1ca73cec38..be1f0e2fb3 100644
--- a/pilot/pkg/serviceregistry/kube/controller/pod.go
+++ b/pilot/pkg/serviceregistry/kube/controller/pod.go
@@ -24,7 +24,7 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller/filter"
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // PodCache is an eventually consistent pod cache
@@ -239,7 +239,7 @@ func (pc *PodCache) queueEndpointEventOnPodArrival(key, ip string) {
 	pc.Lock()
 	defer pc.Unlock()
 	if _, f := pc.needResync[ip]; !f {
-		pc.needResync[ip] = sets.NewSet(key)
+		pc.needResync[ip] = sets.NewWith(key)
 	} else {
 		pc.needResync[ip].Insert(key)
 	}
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/map.go b/pilot/pkg/serviceregistry/util/workloadinstances/map.go
index d679f1704f..98c2035f0f 100644
--- a/pilot/pkg/serviceregistry/util/workloadinstances/map.go
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/map.go
@@ -15,7 +15,7 @@
 package workloadinstances
 
 import (
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // MultiValueMap represents a map where each key might be associated with
@@ -28,7 +28,7 @@ func (m MultiValueMap) Insert(key, value string) MultiValueMap {
 		values.Insert(value)
 		return m
 	}
-	m[key] = sets.NewSet(value)
+	m[key] = sets.NewWith(value)
 	return m
 }
 
@@ -36,7 +36,7 @@ func (m MultiValueMap) Insert(key, value string) MultiValueMap {
 func (m MultiValueMap) Delete(key, value string) MultiValueMap {
 	if values, exists := m[key]; exists {
 		values.Delete(value)
-		if values.Empty() {
+		if values.IsEmpty() {
 			delete(m, key)
 		}
 	}
diff --git a/pilot/pkg/simulation/traffic.go b/pilot/pkg/simulation/traffic.go
index 211a18085c..e0bcf301ce 100644
--- a/pilot/pkg/simulation/traffic.go
+++ b/pilot/pkg/simulation/traffic.go
@@ -34,12 +34,12 @@
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/pkg/xds"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pilot/test/xdstest"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/util/sets"
 )
 
 type Protocol string
@@ -62,7 +62,7 @@ func (c Call) IsHTTP() bool {
 	return httpProtocols.Contains(string(c.Protocol)) && (c.TLS == Plaintext || c.TLS == "")
 }
 
-var httpProtocols = sets.NewSet(string(HTTP), string(HTTP2))
+var httpProtocols = sets.NewWith(string(HTTP), string(HTTP2))
 
 var (
 	ErrNoListener          = errors.New("no listener matched")
@@ -536,7 +536,7 @@ func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultC
 	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetApplicationProtocols() == nil
 	}, func(fc *listener.FilterChainMatch) bool {
-		return sets.NewSet(fc.GetApplicationProtocols()...).Contains(input.Alpn)
+		return sets.NewWith(fc.GetApplicationProtocols()...).Contains(input.Alpn)
 	})
 	// We do not implement the "source" based filters as we do not use them
 	if len(chains) > 1 {
diff --git a/pilot/pkg/status/distribution/reporter.go b/pilot/pkg/status/distribution/reporter.go
index 689cb85f51..f7d06ec92a 100644
--- a/pilot/pkg/status/distribution/reporter.go
+++ b/pilot/pkg/status/distribution/reporter.go
@@ -31,6 +31,7 @@
 	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/ledger"
 )
 
@@ -52,7 +53,7 @@ type Reporter struct {
 	status map[string]string
 	// map from nonce to connection ids for which it is current
 	// using map[string]struct to approximate a hashset
-	reverseStatus          map[string]map[string]struct{}
+	reverseStatus          map[string]sets.Set
 	inProgressResources    map[string]*inProgressEntry
 	client                 v1.ConfigMapInterface
 	cm                     *corev1.ConfigMap
@@ -80,7 +81,7 @@ func (r *Reporter) Init(ledger ledger.Ledger, stop <-chan struct{}) {
 	}
 	r.distributionEventQueue = make(chan distributionEvent, 100_000)
 	r.status = make(map[string]string)
-	r.reverseStatus = make(map[string]map[string]struct{})
+	r.reverseStatus = make(map[string]sets.Set)
 	r.inProgressResources = make(map[string]*inProgressEntry)
 	go r.readFromEventQueue(stop)
 }
@@ -316,9 +317,9 @@ func (r *Reporter) processEvent(conID string, distributionType xds.EventType, no
 	// touch
 	r.status[key] = version
 	if _, ok := r.reverseStatus[version]; !ok {
-		r.reverseStatus[version] = make(map[string]struct{})
+		r.reverseStatus[version] = sets.New()
 	}
-	r.reverseStatus[version][key] = struct{}{}
+	r.reverseStatus[version].Insert(key)
 }
 
 // This is a helper function for keeping our reverseStatus map in step with status.
@@ -326,8 +327,8 @@ func (r *Reporter) processEvent(conID string, distributionType xds.EventType, no
 func (r *Reporter) deleteKeyFromReverseMap(key string) {
 	if old, ok := r.status[key]; ok {
 		if keys, ok := r.reverseStatus[old]; ok {
-			delete(keys, key)
-			if len(r.reverseStatus[old]) < 1 {
+			keys.Delete(key)
+			if keys.IsEmpty() {
 				delete(r.reverseStatus, old)
 			}
 		}
diff --git a/pilot/pkg/status/distribution/reporter_test.go b/pilot/pkg/status/distribution/reporter_test.go
index ce05881039..764e873d04 100644
--- a/pilot/pkg/status/distribution/reporter_test.go
+++ b/pilot/pkg/status/distribution/reporter_test.go
@@ -25,6 +25,7 @@
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/ledger"
 )
 
@@ -38,13 +39,13 @@ func TestStatusMaps(t *testing.T) {
 	RegisterTestingT(t)
 	x := struct{}{}
 	Expect(r.status).To(Equal(map[string]string{"conA~": "a", "conB~": "a", "conC~": "c", "conD~": "d"}))
-	Expect(r.reverseStatus).To(Equal(map[string]map[string]struct{}{"a": {"conA~": x, "conB~": x}, "c": {"conC~": x}, "d": {"conD~": x}}))
+	Expect(r.reverseStatus).To(Equal(map[string]sets.Set{"a": {"conA~": x, "conB~": x}, "c": {"conC~": x}, "d": {"conD~": x}}))
 	r.processEvent("conA", typ, "d")
 	Expect(r.status).To(Equal(map[string]string{"conA~": "d", "conB~": "a", "conC~": "c", "conD~": "d"}))
-	Expect(r.reverseStatus).To(Equal(map[string]map[string]struct{}{"a": {"conB~": x}, "c": {"conC~": x}, "d": {"conD~": x, "conA~": x}}))
+	Expect(r.reverseStatus).To(Equal(map[string]sets.Set{"a": {"conB~": x}, "c": {"conC~": x}, "d": {"conD~": x, "conA~": x}}))
 	r.RegisterDisconnect("conA", []xds.EventType{typ})
 	Expect(r.status).To(Equal(map[string]string{"conB~": "a", "conC~": "c", "conD~": "d"}))
-	Expect(r.reverseStatus).To(Equal(map[string]map[string]struct{}{"a": {"conB~": x}, "c": {"conC~": x}, "d": {"conD~": x}}))
+	Expect(r.reverseStatus).To(Equal(map[string]sets.Set{"a": {"conB~": x}, "c": {"conC~": x}, "d": {"conD~": x}}))
 }
 
 func initReporterWithoutStarting() (out Reporter) {
@@ -54,7 +55,7 @@ func initReporterWithoutStarting() (out Reporter) {
 	out.clock = clock.RealClock{} // TODO
 	out.UpdateInterval = 300 * time.Millisecond
 	out.cm = nil // TODO
-	out.reverseStatus = make(map[string]map[string]struct{})
+	out.reverseStatus = make(map[string]sets.Set)
 	out.status = make(map[string]string)
 	return
 }
diff --git a/pilot/pkg/trustbundle/trustbundle.go b/pilot/pkg/trustbundle/trustbundle.go
index 220d1ac7ab..c949c794a7 100644
--- a/pilot/pkg/trustbundle/trustbundle.go
+++ b/pilot/pkg/trustbundle/trustbundle.go
@@ -25,6 +25,7 @@
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -132,17 +133,16 @@ func verifyTrustAnchor(trustAnchor string) error {
 }
 
 func (tb *TrustBundle) mergeInternal() {
-	var ok bool
-	mergeCerts := []string{}
-	certMap := make(map[string]struct{})
+	var mergeCerts []string
+	certMap := sets.New()
 
 	tb.mutex.Lock()
 	defer tb.mutex.Unlock()
 
 	for _, configSource := range tb.sourceConfig {
 		for _, cert := range configSource.Certs {
-			if _, ok = certMap[cert]; !ok {
-				certMap[cert] = struct{}{}
+			if !certMap.Contains(cert) {
+				certMap.Insert(cert)
 				mergeCerts = append(mergeCerts, cert)
 			}
 		}
diff --git a/pilot/pkg/xds/ads.go b/pilot/pkg/xds/ads.go
index da1b3dacc9..d7fa409496 100644
--- a/pilot/pkg/xds/ads.go
+++ b/pilot/pkg/xds/ads.go
@@ -33,10 +33,10 @@
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
 	labelutil "istio.io/istio/pilot/pkg/serviceregistry/util/label"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/env"
 	istiolog "istio.io/pkg/log"
 )
@@ -939,7 +939,7 @@ func (conn *Connection) Watched(typeUrl string) *model.WatchedResource {
 func (conn *Connection) pushDetails() ([]*model.WatchedResource, sets.Set) {
 	conn.proxy.RLock()
 	defer conn.proxy.RUnlock()
-	typeUrls := sets.NewSet()
+	typeUrls := sets.New()
 	for k := range conn.proxy.WatchedResources {
 		typeUrls.Insert(k)
 	}
diff --git a/pilot/pkg/xds/ads_test.go b/pilot/pkg/xds/ads_test.go
index 2193fcc06e..7f2c94305e 100644
--- a/pilot/pkg/xds/ads_test.go
+++ b/pilot/pkg/xds/ads_test.go
@@ -24,7 +24,6 @@
 
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pilot/test/xdstest"
@@ -34,6 +33,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/test/util/retry"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const (
@@ -866,8 +866,8 @@ func TestEdsCache(t *testing.T) {
 	assertEndpoints := func(a *adsc.ADSC, addr ...string) {
 		t.Helper()
 		retry.UntilSuccessOrFail(t, func() error {
-			got := sets.NewSet(xdstest.ExtractEndpoints(a.GetEndpoints()["outbound|80||foo.com"])...)
-			want := sets.NewSet(addr...)
+			got := sets.NewWith(xdstest.ExtractEndpoints(a.GetEndpoints()["outbound|80||foo.com"])...)
+			want := sets.NewWith(addr...)
 
 			if !got.Equals(want) {
 				return fmt.Errorf("invalid endpoints, got %v want %v", got, addr)
diff --git a/pilot/pkg/xds/delta.go b/pilot/pkg/xds/delta.go
index 169df38b8a..bd40383d2c 100644
--- a/pilot/pkg/xds/delta.go
+++ b/pilot/pkg/xds/delta.go
@@ -29,8 +29,8 @@
 	istiogrpc "istio.io/istio/pilot/pkg/grpc"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
+	"istio.io/istio/pkg/util/sets"
 	istiolog "istio.io/pkg/log"
 )
 
@@ -434,8 +434,8 @@ func (s *DiscoveryServer) pushDeltaXds(con *Connection,
 		resp.RemovedResources = deletedRes
 	} else if req.Full {
 		// similar to sotw
-		subscribed := sets.NewSet(w.ResourceNames...)
-		subscribed.Delete(currentResources...)
+		subscribed := sets.NewWith(w.ResourceNames...)
+		subscribed.DeleteAll(currentResources...)
 		resp.RemovedResources = subscribed.SortedList()
 	}
 	if len(resp.RemovedResources) > 0 {
@@ -512,9 +512,9 @@ func deltaToSotwRequest(request *discovery.DeltaDiscoveryRequest) *discovery.Dis
 }
 
 func deltaWatchedResources(existing []string, request *discovery.DeltaDiscoveryRequest) []string {
-	res := sets.NewSet(existing...)
-	res.Insert(request.ResourceNamesSubscribe...)
-	res.Delete(request.ResourceNamesUnsubscribe...)
+	res := sets.NewWith(existing...)
+	res.InsertAll(request.ResourceNamesSubscribe...)
+	res.DeleteAll(request.ResourceNamesUnsubscribe...)
 	return res.SortedList()
 }
 
diff --git a/pilot/pkg/xds/deltatest.go b/pilot/pkg/xds/deltatest.go
index 3f379437f8..089501373f 100644
--- a/pilot/pkg/xds/deltatest.go
+++ b/pilot/pkg/xds/deltatest.go
@@ -22,11 +22,11 @@
 	"google.golang.org/protobuf/testing/protocmp"
 
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
+	"istio.io/istio/pkg/util/sets"
 )
 
-var knownOptimizationGaps = sets.NewSet(
+var knownOptimizationGaps = sets.NewWith(
 	"BlackHoleCluster",
 	"InboundPassthroughClusterIpv4",
 	"InboundPassthroughClusterIpv6",
@@ -64,12 +64,12 @@ func (s *DiscoveryServer) compareDiff(
 		curByName[v.Name] = v
 	}
 
-	watched := sets.NewSet(w.ResourceNames...)
+	watched := sets.NewWith(w.ResourceNames...)
 
 	details := fmt.Sprintf("last:%v sotw:%v delta:%v-%v", len(current), len(full), len(resp), len(deleted))
-	wantDeleted := sets.NewSet()
-	wantChanged := sets.NewSet()
-	wantUnchanged := sets.NewSet()
+	wantDeleted := sets.New()
+	wantChanged := sets.New()
+	wantUnchanged := sets.New()
 	for _, c := range current {
 		n := newByName[c.Name]
 		if n == nil {
@@ -93,11 +93,11 @@ func (s *DiscoveryServer) compareDiff(
 		}
 	}
 
-	gotDeleted := sets.NewSet()
+	gotDeleted := sets.New()
 	if usedDelta {
-		gotDeleted.Insert(deleted...)
+		gotDeleted.InsertAll(deleted...)
 	}
-	gotChanged := sets.NewSet()
+	gotChanged := sets.New()
 	for _, v := range resp {
 		gotChanged.Insert(v.Name)
 	}
@@ -141,7 +141,7 @@ func (s *DiscoveryServer) compareDiff(
 }
 
 func applyDelta(message model.Resources, resp *discovery.DeltaDiscoveryResponse) model.Resources {
-	deleted := sets.NewSet(resp.RemovedResources...)
+	deleted := sets.NewWith(resp.RemovedResources...)
 	byName := map[string]*discovery.Resource{}
 	for _, v := range resp.Resources {
 		byName[v.Name] = v
diff --git a/pilot/pkg/xds/discovery.go b/pilot/pkg/xds/discovery.go
index a4332fc9e5..749d935efb 100644
--- a/pilot/pkg/xds/discovery.go
+++ b/pilot/pkg/xds/discovery.go
@@ -38,10 +38,10 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	"istio.io/istio/pilot/pkg/serviceregistry/memory"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/security"
+	"istio.io/istio/pkg/util/sets"
 )
 
 var (
diff --git a/pilot/pkg/xds/eds.go b/pilot/pkg/xds/eds.go
index 9efb1bdfed..0634baca13 100644
--- a/pilot/pkg/xds/eds.go
+++ b/pilot/pkg/xds/eds.go
@@ -27,12 +27,12 @@
 	networking "istio.io/istio/pilot/pkg/networking/core/v1alpha3"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/loadbalancer"
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // PushType is an enumeration that decides what type push we should do when we get EDS update.
diff --git a/pilot/pkg/xds/eds_test.go b/pilot/pkg/xds/eds_test.go
index eed6b1efd0..611dcece2f 100644
--- a/pilot/pkg/xds/eds_test.go
+++ b/pilot/pkg/xds/eds_test.go
@@ -36,7 +36,6 @@
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pilot/test/xdstest"
@@ -45,6 +44,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -396,8 +396,8 @@ func TestEDSUnhealthyEndpoints(t *testing.T) {
 		// Validate that endpoints are pushed.
 		lbe := adscon.GetEndpoints()["outbound|53||unhealthy.svc.cluster.local"]
 		eh, euh := xdstest.ExtractHealthEndpoints(lbe)
-		gotHealthy := sets.NewSet(eh...).SortedList()
-		gotUnhealthy := sets.NewSet(euh...).SortedList()
+		gotHealthy := sets.NewWith(eh...).SortedList()
+		gotUnhealthy := sets.NewWith(euh...).SortedList()
 		if !reflect.DeepEqual(gotHealthy, healthy) {
 			t.Fatalf("did not get expected endpoints: got %v, want %v", gotHealthy, healthy)
 		}
diff --git a/pilot/test/xdstest/extract.go b/pilot/test/xdstest/extract.go
index 9d8f2f79ec..160b5b0a15 100644
--- a/pilot/test/xdstest/extract.go
+++ b/pilot/test/xdstest/extract.go
@@ -33,10 +33,10 @@
 	any "google.golang.org/protobuf/types/known/anypb"
 
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func ExtractRoutesFromListeners(ll []*listener.Listener) []string {
@@ -62,7 +62,7 @@ func ExtractRoutesFromListeners(ll []*listener.Listener) []string {
 
 // ExtractSecretResources fetches all referenced SDS resource names from a list of clusters and listeners
 func ExtractSecretResources(t test.Failer, rs []*any.Any) []string {
-	resourceNames := sets.NewSet()
+	resourceNames := sets.New()
 	for _, r := range rs {
 		switch r.TypeUrl {
 		case v3.ClusterType:
diff --git a/pkg/bootstrap/config.go b/pkg/bootstrap/config.go
index 31fd92976b..c41b5457a0 100644
--- a/pkg/bootstrap/config.go
+++ b/pkg/bootstrap/config.go
@@ -38,6 +38,7 @@
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/kube/labels"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/env"
 	"istio.io/pkg/log"
 )
@@ -728,11 +729,11 @@ func ParseDownwardAPI(i string) (map[string]string, error) {
 }
 
 func removeDuplicates(values []string) []string {
-	set := make(map[string]struct{})
+	set := sets.New()
 	newValues := make([]string, 0, len(values))
 	for _, v := range values {
-		if _, ok := set[v]; !ok {
-			set[v] = struct{}{}
+		if !set.Contains(v) {
+			set.Insert(v)
 			newValues = append(newValues, v)
 		}
 	}
diff --git a/pkg/config/analysis/analyzer.go b/pkg/config/analysis/analyzer.go
index 459d9684ec..40a7b2d046 100644
--- a/pkg/config/analysis/analyzer.go
+++ b/pkg/config/analysis/analyzer.go
@@ -15,9 +15,9 @@
 package analysis
 
 import (
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/analysis/scope"
 	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // Analyzer is an interface for analyzing configuration.
@@ -68,7 +68,7 @@ func (c *CombinedAnalyzer) Analyze(ctx Context) {
 // should be disabled. Any analyzers that require those output collections will be removed.
 // 2. The analyzer requires a collection not available in the current snapshot(s)
 func (c *CombinedAnalyzer) RemoveSkipped(schemas collection.Schemas) []string {
-	s := sets.NewSet()
+	s := sets.New()
 	for _, sc := range schemas.All() {
 		s.Insert(sc.Name().String())
 	}
diff --git a/pkg/config/analysis/analyzers/analyzers_test.go b/pkg/config/analysis/analyzers/analyzers_test.go
index 8914dcc5ba..ac2fcce1e0 100644
--- a/pkg/config/analysis/analyzers/analyzers_test.go
+++ b/pkg/config/analysis/analyzers/analyzers_test.go
@@ -45,6 +45,7 @@
 	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/util/sets"
 )
 
 type message struct {
@@ -725,18 +726,17 @@ func TestAnalyzersInAll(t *testing.T) {
 func TestAnalyzersHaveUniqueNames(t *testing.T) {
 	g := NewWithT(t)
 
-	existingNames := make(map[string]struct{})
+	existingNames := sets.New()
 	for _, a := range All() {
 		n := a.Metadata().Name
-		_, ok := existingNames[n]
 		// TODO (Nino-K): remove this condition once metadata is clean up
-		if ok == true && n == "schema.ValidationAnalyzer.ServiceEntry" {
+		if existingNames.Contains(n) && n == "schema.ValidationAnalyzer.ServiceEntry" {
 			continue
 		}
-		g.Expect(ok).To(BeFalse(), fmt.Sprintf("Analyzer name %q is used more than once. "+
+		g.Expect(existingNames.Contains(n)).To(BeFalse(), fmt.Sprintf("Analyzer name %q is used more than once. "+
 			"Analyzers should be registered in All() exactly once and have a unique name.", n))
 
-		existingNames[n] = struct{}{}
+		existingNames.Insert(n)
 	}
 }
 
diff --git a/pkg/config/analysis/analyzers/webhook/webhook.go b/pkg/config/analysis/analyzers/webhook/webhook.go
index 127d0c904e..3fe8712e56 100644
--- a/pkg/config/analysis/analyzers/webhook/webhook.go
+++ b/pkg/config/analysis/analyzers/webhook/webhook.go
@@ -23,12 +23,12 @@
 	klabels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/label"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/analysis"
 	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/util/sets"
 )
 
 var (
@@ -73,7 +73,7 @@ func (a *Analyzer) Analyze(context analysis.Context) {
 	// First, extract and index all webhooks we found
 	webhooks := map[string][]v1.MutatingWebhook{}
 	resources := map[string]*resource.Instance{}
-	revisions := sets.NewSet()
+	revisions := sets.New()
 	context.ForEach(webhookCol, func(resource *resource.Instance) bool {
 		wh := resource.Message.(*v1.MutatingWebhookConfiguration)
 		revs := extractRevisions(wh)
@@ -84,7 +84,7 @@ func (a *Analyzer) Analyze(context analysis.Context) {
 		for _, h := range wh.Webhooks {
 			resources[fmt.Sprintf("%v/%v", resource.Metadata.FullName.String(), h.Name)] = resource
 		}
-		revisions.Insert(revs...)
+		revisions.InsertAll(revs...)
 		return true
 	})
 
@@ -107,7 +107,7 @@ func (a *Analyzer) Analyze(context analysis.Context) {
 	// For each permutation, we check which webhooks it matches. It must match exactly 0 or 1!
 	for _, nl := range namespaceLabels {
 		for _, ol := range objectLabels {
-			matches := sets.NewSet()
+			matches := sets.New()
 			for name, whs := range webhooks {
 				for _, wh := range whs {
 					if selectorMatches(wh.NamespaceSelector, nl) && selectorMatches(wh.ObjectSelector, ol) {
@@ -117,7 +117,7 @@ func (a *Analyzer) Analyze(context analysis.Context) {
 			}
 			if len(matches) > 1 {
 				for match := range matches {
-					others := matches.Difference(sets.NewSet(match))
+					others := matches.Difference(sets.NewWith(match))
 					context.Report(webhookCol, msg.NewInvalidWebhook(resources[match],
 						fmt.Sprintf("Webhook overlaps with others: %v. This may cause injection to occur twice.", others.UnsortedList())))
 				}
@@ -156,7 +156,7 @@ func isIstioWebhook(wh *v1.MutatingWebhookConfiguration) bool {
 }
 
 func extractRevisions(wh *v1.MutatingWebhookConfiguration) []string {
-	revs := sets.NewSet()
+	revs := sets.New()
 	if r, f := wh.Labels[label.IoIstioRev.Name]; f {
 		revs.Insert(r)
 	}
@@ -168,7 +168,7 @@ func extractRevisions(wh *v1.MutatingWebhookConfiguration) []string {
 
 			for _, ls := range webhook.NamespaceSelector.MatchExpressions {
 				if ls.Key == label.IoIstioRev.Name {
-					revs.Insert(ls.Values...)
+					revs.InsertAll(ls.Values...)
 				}
 			}
 		}
@@ -179,7 +179,7 @@ func extractRevisions(wh *v1.MutatingWebhookConfiguration) []string {
 
 			for _, ls := range webhook.ObjectSelector.MatchExpressions {
 				if ls.Key == label.IoIstioRev.Name {
-					revs.Insert(ls.Values...)
+					revs.InsertAll(ls.Values...)
 				}
 			}
 		}
diff --git a/pkg/config/analysis/local/istiod_analyze.go b/pkg/config/analysis/local/istiod_analyze.go
index 7712f547cf..9e9f2b0030 100644
--- a/pkg/config/analysis/local/istiod_analyze.go
+++ b/pkg/config/analysis/local/istiod_analyze.go
@@ -46,6 +46,7 @@
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
 	kubelib "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // IstiodAnalyzer handles local analysis of k8s event sources, both live and file-based
@@ -388,9 +389,9 @@ func (sa *IstiodAnalyzer) addRunningKubeIstioConfigMapSource(client kubelib.Clie
 
 // copied from processing/snapshotter/analyzingdistributor.go
 func filterMessages(messages diag.Messages, namespaces map[resource.Namespace]struct{}, suppressions []AnalysisSuppression) diag.Messages {
-	nsNames := make(map[string]struct{})
+	nsNames := sets.New()
 	for k := range namespaces {
-		nsNames[k.String()] = struct{}{}
+		nsNames.Insert(k.String())
 	}
 
 	var msgs diag.Messages
@@ -401,7 +402,7 @@ func filterMessages(messages diag.Messages, namespaces map[resource.Namespace]st
 		// namespace). Also kept are cluster-level resources where the namespace is
 		// the empty string. If no such limit is specified, keep them all.
 		if len(namespaces) > 0 && m.Resource != nil && m.Resource.Origin.Namespace() != "" {
-			if _, ok := nsNames[m.Resource.Origin.Namespace().String()]; !ok {
+			if !nsNames.Contains(m.Resource.Origin.Namespace().String()) {
 				continue FilterMessages
 			}
 		}
diff --git a/pkg/config/mesh/mesh.go b/pkg/config/mesh/mesh.go
index 36dedffc9d..4961a2e0c0 100644
--- a/pkg/config/mesh/mesh.go
+++ b/pkg/config/mesh/mesh.go
@@ -27,10 +27,10 @@
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/validation"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // DefaultProxyConfig for individual proxies
@@ -237,7 +237,7 @@ func ApplyMeshConfig(yaml string, defaultConfig *meshconfig.MeshConfig) (*meshco
 		}
 	}
 
-	defaultConfig.TrustDomainAliases = sets.NewSet(append(defaultConfig.TrustDomainAliases, prevTrustDomainAliases...)...).SortedList()
+	defaultConfig.TrustDomainAliases = sets.NewWith(append(defaultConfig.TrustDomainAliases, prevTrustDomainAliases...)...).SortedList()
 
 	if err := validation.ValidateMeshConfig(defaultConfig); err != nil {
 		return nil, err
diff --git a/pkg/config/schema/codegen/collections.go b/pkg/config/schema/codegen/collections.go
index 14bd925edb..2f2f67492c 100644
--- a/pkg/config/schema/codegen/collections.go
+++ b/pkg/config/schema/codegen/collections.go
@@ -20,6 +20,7 @@
 	"strings"
 
 	"istio.io/istio/pkg/config/schema/ast"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const staticResourceTemplate = `
@@ -219,18 +220,18 @@ func StaticCollections(packageName string, m *ast.Metadata, filter func(name str
 		entries = append(entries, e)
 	}
 	// Single instance and sort names
-	names := make(map[string]struct{})
+	names := sets.New()
 
 	for _, r := range m.Resources {
 		if r.ProtoPackage != "" {
-			names[r.ProtoPackage] = struct{}{}
+			names.Insert(r.ProtoPackage)
 		}
 		if r.StatusProtoPackage != "" {
-			names[r.StatusProtoPackage] = struct{}{}
+			names.Insert(r.StatusProtoPackage)
 		}
 	}
 
-	packages := make([]packageImport, 0, len(names))
+	packages := make([]packageImport, 0, names.Len())
 	for p := range names {
 		packages = append(packages, packageImport{p, toImport(p)})
 	}
diff --git a/pkg/config/security/security.go b/pkg/config/security/security.go
index 4b32ed95f7..876561bdae 100644
--- a/pkg/config/security/security.go
+++ b/pkg/config/security/security.go
@@ -24,8 +24,8 @@
 
 	"github.com/hashicorp/go-multierror"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // JwksInfo provides values resulting from parsing a jwks URI.
@@ -186,7 +186,7 @@ func validateMapKey(key string) error {
 
 // ValidCipherSuites contains a list of all ciphers supported in Gateway.server.tls.cipherSuites
 // Extracted from: `bssl ciphers -openssl-name ALL | rg -v PSK`
-var ValidCipherSuites = sets.NewSet(
+var ValidCipherSuites = sets.NewWith(
 	"ECDHE-ECDSA-AES128-GCM-SHA256",
 	"ECDHE-RSA-AES128-GCM-SHA256",
 	"ECDHE-ECDSA-AES256-GCM-SHA384",
diff --git a/pkg/config/validation/validation.go b/pkg/config/validation/validation.go
index f920290ce6..eb1cacac56 100644
--- a/pkg/config/validation/validation.go
+++ b/pkg/config/validation/validation.go
@@ -48,7 +48,6 @@
 	type_beta "istio.io/api/type/v1beta1"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/util/constant"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/gateway"
@@ -60,6 +59,7 @@
 	"istio.io/istio/pkg/config/xds"
 	"istio.io/istio/pkg/kube/apimirror"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -561,9 +561,9 @@ func validateTLSOptions(tls *networking.ServerTLSSettings) (v Validation) {
 		return
 	}
 
-	invalidCiphers := sets.NewSet()
-	validCiphers := sets.NewSet()
-	duplicateCiphers := sets.NewSet()
+	invalidCiphers := sets.New()
+	validCiphers := sets.New()
+	duplicateCiphers := sets.New()
 	for _, cs := range tls.CipherSuites {
 		if !security.IsValidCipherSuite(cs) {
 			invalidCiphers.Insert(cs)
@@ -687,7 +687,7 @@ func(cfg config.Config) (Warning, error) {
 func validateExportTo(namespace string, exportTo []string, isServiceEntry bool) (errs error) {
 	if len(exportTo) > 0 {
 		// Make sure there are no duplicates
-		exportToMap := make(map[string]struct{})
+		exportToSet := sets.New()
 		for _, e := range exportTo {
 			key := e
 			if visibility.Instance(e) == visibility.Private {
@@ -695,7 +695,7 @@ func validateExportTo(namespace string, exportTo []string, isServiceEntry bool)
 				// can check for duplicates like ., namespace
 				key = namespace
 			}
-			if _, exists := exportToMap[key]; exists {
+			if exportToSet.Contains(key) {
 				if key != e {
 					errs = appendErrors(errs, fmt.Errorf("duplicate entries in exportTo: . and current namespace %s", namespace))
 				} else {
@@ -706,19 +706,19 @@ func validateExportTo(namespace string, exportTo []string, isServiceEntry bool)
 				// a service that is not even visible within the local namespace to anyone other
 				// than the proxies of that service.
 				if isServiceEntry && visibility.Instance(e) == visibility.None {
-					exportToMap[key] = struct{}{}
+					exportToSet.Insert(key)
 				} else {
 					if err := visibility.Instance(key).Validate(); err != nil {
 						errs = appendErrors(errs, err)
 					} else {
-						exportToMap[key] = struct{}{}
+						exportToSet.Insert(key)
 					}
 				}
 			}
 		}
 
 		// Make sure we have only one of . or *
-		if _, public := exportToMap[string(visibility.Public)]; public {
+		if exportToSet.Contains(string(visibility.Public)) {
 			// make sure that there are no other entries in the exportTo
 			// i.e. no point in saying ns1,ns2,*. Might as well say *
 			if len(exportTo) > 1 {
@@ -727,7 +727,7 @@ func validateExportTo(namespace string, exportTo []string, isServiceEntry bool)
 		}
 
 		// if this is a service entry, then we need to disallow * and ~ together. Or ~ and other namespaces
-		if _, none := exportToMap[string(visibility.None)]; none {
+		if exportToSet.Contains(string(visibility.None)) {
 			if len(exportTo) > 1 {
 				errs = appendErrors(errs, fmt.Errorf("cannot export service entry to no one (~) and someone"))
 			}
@@ -3651,7 +3651,7 @@ func validateWasmPluginVMConfig(vm *extensions.VmConfig) error {
 		return nil
 	}
 
-	keys := sets.NewSet()
+	keys := sets.New()
 	for _, env := range vm.Env {
 		if env == nil {
 			continue
diff --git a/pkg/dns/client/dns.go b/pkg/dns/client/dns.go
index 21b91cf3fb..5ee28b6a16 100644
--- a/pkg/dns/client/dns.go
+++ b/pkg/dns/client/dns.go
@@ -28,6 +28,7 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pkg/config/host"
 	dnsProto "istio.io/istio/pkg/dns/proto"
+	"istio.io/istio/pkg/util/sets"
 	istiolog "istio.io/pkg/log"
 )
 
@@ -192,14 +193,14 @@ func (h *LocalDNSServer) UpdateLookupTable(nt *dnsProto.NameTable) {
 		// if its a non-k8s host, store the host+. as the key with the pre-computed DNS RR records
 		// if its a k8s host, store all variants (i.e. shortname+., shortname+namespace+., fqdn+., etc.)
 		// shortname+. is only for hosts in current namespace
-		var altHosts map[string]struct{}
+		var altHosts sets.Set
 		if ni.Registry == string(provider.Kubernetes) {
 			altHosts = generateAltHosts(hostname, ni, h.proxyNamespace, h.proxyDomain, h.proxyDomainParts)
 		} else {
 			if !strings.HasSuffix(hostname, ".") {
 				hostname += "."
 			}
-			altHosts = map[string]struct{}{hostname: {}}
+			altHosts = sets.NewWith(hostname)
 		}
 		ipv4, ipv6 := separateIPtypes(ni.Ips)
 		if len(ipv6) == 0 && len(ipv4) == 0 {
@@ -415,28 +416,28 @@ func separateIPtypes(ips []string) (ipv4, ipv6 []net.IP) {
 
 func generateAltHosts(hostname string, nameinfo *dnsProto.NameTable_NameInfo, proxyNamespace, proxyDomain string,
 	proxyDomainParts []string,
-) map[string]struct{} {
-	out := make(map[string]struct{})
-	out[hostname+"."] = struct{}{}
+) sets.Set {
+	out := sets.New()
+	out.Insert(hostname + ".")
 	// do not generate alt hostnames if the service is in a different domain (i.e. cluster) than the proxy
 	// as we have no way to resolve conflicts on name.namespace entries across clusters of different domains
 	if proxyDomain == "" || !strings.HasSuffix(hostname, proxyDomain) {
 		return out
 	}
-	out[nameinfo.Shortname+"."+nameinfo.Namespace+"."] = struct{}{}
+	out.Insert(nameinfo.Shortname + "." + nameinfo.Namespace + ".")
 	if proxyNamespace == nameinfo.Namespace {
-		out[nameinfo.Shortname+"."] = struct{}{}
+		out.Insert(nameinfo.Shortname + ".")
 	}
 	// Do we need to generate entries for name.namespace.svc, name.namespace.svc.cluster, etc. ?
 	// If these are not that frequently used, then not doing so here will save some space and time
 	// as some people have very long proxy domains with multiple dots
 	// For now, we will generate just one more domain (which is usually the .svc piece).
-	out[nameinfo.Shortname+"."+nameinfo.Namespace+"."+proxyDomainParts[0]+"."] = struct{}{}
+	out.Insert(nameinfo.Shortname + "." + nameinfo.Namespace + "." + proxyDomainParts[0] + ".")
 
 	// Add any additional alt hostnames.
 	// nolint: staticcheck
 	for _, altHost := range nameinfo.AltHosts {
-		out[altHost+"."] = struct{}{}
+		out.Insert(altHost + ".")
 	}
 	return out
 }
diff --git a/pkg/envoy/agent.go b/pkg/envoy/agent.go
index c5527540f4..6c1d990bbe 100644
--- a/pkg/envoy/agent.go
+++ b/pkg/envoy/agent.go
@@ -22,8 +22,8 @@
 	"strings"
 	"time"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/http"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -36,7 +36,7 @@
 // NewAgent creates a new proxy agent for the proxy start-up and clean-up functions.
 func NewAgent(proxy Proxy, terminationDrainDuration, minDrainDuration time.Duration, localhost string,
 	adminPort, statusPort, prometheusPort int, exitOnZeroActiveConnections bool) *Agent {
-	knownIstioListeners := sets.NewSet(
+	knownIstioListeners := sets.NewWith(
 		fmt.Sprintf("listener.0.0.0.0_%d.downstream_cx_active", statusPort),
 		fmt.Sprintf("listener.0.0.0.0_%d.downstream_cx_active", prometheusPort),
 		"listener.admin.downstream_cx_active",
diff --git a/pkg/kube/inject/initializer.go b/pkg/kube/inject/initializer.go
index ea9584d48f..68723b94ed 100644
--- a/pkg/kube/inject/initializer.go
+++ b/pkg/kube/inject/initializer.go
@@ -22,8 +22,8 @@
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // IgnoredNamespaces contains the system namespaces referenced from Kubernetes:
@@ -34,7 +34,7 @@
 //    which improves the performance of the node heartbeats as the cluster scales.
 // "local-path-storage": Dynamically provisioning persistent local storage with Kubernetes.
 //    used with Kind cluster: https://github.com/rancher/local-path-provisioner
-var IgnoredNamespaces = sets.NewSet(
+var IgnoredNamespaces = sets.NewWith(
 	constants.KubeSystemNamespace,
 	constants.KubePublicNamespace,
 	constants.KubeNodeLeaseNamespace,
diff --git a/pkg/kube/inject/inject_test.go b/pkg/kube/inject/inject_test.go
index 813115c4c3..1ce47b2da9 100644
--- a/pkg/kube/inject/inject_test.go
+++ b/pkg/kube/inject/inject_test.go
@@ -37,11 +37,11 @@
 	opconfig "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/test/util"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // TestInjection tests both the mutating webhook and kube-inject. It does this by sharing the same input and output
@@ -318,7 +318,7 @@ type testCase struct {
 	}
 	// Keep track of tests we add options above
 	// We will search for all test files and skip these ones
-	alreadyTested := sets.NewSet()
+	alreadyTested := sets.New()
 	for _, t := range cases {
 		if t.want != "" {
 			alreadyTested.Insert(t.want)
@@ -336,7 +336,7 @@ type testCase struct {
 	// Automatically add any other test files in the folder. This ensures we don't
 	// forget to add to this list, that we don't have duplicates, etc
 	// Keep track of all golden files so we can ensure we don't have unused ones later
-	allOutputFiles := sets.NewSet()
+	allOutputFiles := sets.New()
 	for _, f := range files {
 		if strings.HasSuffix(f.Name(), ".injected") {
 			allOutputFiles.Insert(f.Name())
diff --git a/pkg/kube/inject/webhook.go b/pkg/kube/inject/webhook.go
index df5f8995b4..313b1a6745 100644
--- a/pkg/kube/inject/webhook.go
+++ b/pkg/kube/inject/webhook.go
@@ -46,10 +46,10 @@
 	opconfig "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/pilot/cmd/pilot-agent/status"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -675,7 +675,7 @@ func getPrometheusScrape(pod *corev1.Pod) bool {
 	return true
 }
 
-var prometheusAnnotations = sets.NewSet(
+var prometheusAnnotations = sets.NewWith(
 	prometheusPathAnnotation,
 	prometheusPortAnnotation,
 	prometheusScrapeAnnotation,
diff --git a/pkg/kube/multicluster/secretcontroller.go b/pkg/kube/multicluster/secretcontroller.go
index 89aa0b8ca6..f7fbecb898 100644
--- a/pkg/kube/multicluster/secretcontroller.go
+++ b/pkg/kube/multicluster/secretcontroller.go
@@ -36,10 +36,10 @@
 	"k8s.io/client-go/tools/clientcmd/api"
 
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 	"istio.io/pkg/monitoring"
 )
@@ -148,7 +148,7 @@ type ClusterStore struct {
 func newClustersStore() *ClusterStore {
 	return &ClusterStore{
 		remoteClusters: make(map[string]map[cluster.ID]*Cluster),
-		clusters:       sets.NewSet(),
+		clusters:       sets.New(),
 	}
 }
 
diff --git a/pkg/kube/multicluster/secretcontroller_test.go b/pkg/kube/multicluster/secretcontroller_test.go
index 10042682ed..fd1e1f47b6 100644
--- a/pkg/kube/multicluster/secretcontroller_test.go
+++ b/pkg/kube/multicluster/secretcontroller_test.go
@@ -28,10 +28,10 @@
 	"k8s.io/client-go/tools/clientcmd/api"
 
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/test/util/retry"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const secretNamespace string = "istio-system"
@@ -226,7 +226,7 @@ func TestSanitizeKubeConfig(t *testing.T) {
 		},
 		{
 			name:      "exec allowlist",
-			allowlist: sets.NewSet("exec"),
+			allowlist: sets.NewWith("exec"),
 			config: api.Config{
 				AuthInfos: map[string]*api.AuthInfo{
 					"default": {
diff --git a/pkg/security/mock.go b/pkg/security/mock.go
index 6abf0177ac..25dfb58db9 100644
--- a/pkg/security/mock.go
+++ b/pkg/security/mock.go
@@ -25,8 +25,8 @@
 	"google.golang.org/grpc/credentials"
 	"google.golang.org/grpc/peer"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/security/pkg/pki/util"
 	"istio.io/pkg/log"
 )
@@ -170,7 +170,7 @@ func checkCert(ctx context.Context, expected string) error {
 	if err != nil {
 		return fmt.Errorf("failed to extract IDs")
 	}
-	if !sets.NewSet(ids...).Contains(expected) {
+	if !sets.NewWith(ids...).Contains(expected) {
 		return fmt.Errorf("expected identity %q, got %v", expected, ids)
 	}
 
diff --git a/pkg/test/framework/components/echo/deployment/builder.go b/pkg/test/framework/components/echo/deployment/builder.go
index d43b8c8766..f3ae30c89e 100644
--- a/pkg/test/framework/components/echo/deployment/builder.go
+++ b/pkg/test/framework/components/echo/deployment/builder.go
@@ -25,7 +25,6 @@
 	"github.com/hashicorp/go-multierror"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/kube/inject"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -38,6 +37,7 @@
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/scopes"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // Builder for a group of collaborating Echo Instances. Once built, all Instances in the
@@ -212,7 +212,7 @@ func (b builder) injectionTemplates() (map[string]sets.Set, error) {
 
 	out := map[string]sets.Set{}
 	for _, c := range b.ctx.Clusters().Kube() {
-		out[c.Name()] = sets.NewSet()
+		out[c.Name()] = sets.New()
 		// TODO find a place to read revision(s) and avoid listing
 		cms, err := c.CoreV1().ConfigMaps(ns).List(context.TODO(), metav1.ListOptions{})
 		if err != nil {
@@ -220,7 +220,7 @@ func (b builder) injectionTemplates() (map[string]sets.Set, error) {
 		}
 
 		// take the intersection of the templates available from each revision in this cluster
-		intersection := sets.NewSet()
+		intersection := sets.New()
 		for _, item := range cms.Items {
 			if !strings.HasPrefix(item.Name, "istio-sidecar-injector") {
 				continue
@@ -230,13 +230,13 @@ func (b builder) injectionTemplates() (map[string]sets.Set, error) {
 				return nil, fmt.Errorf("failed parsing injection cm in %s: %v", c.Name(), err)
 			}
 			if data.RawTemplates != nil {
-				t := sets.NewSet()
+				t := sets.New()
 				for name := range data.RawTemplates {
 					t.Insert(name)
 				}
 				// either intersection has not been set or we intersect these templates
 				// with the current set.
-				if intersection.Empty() {
+				if intersection.IsEmpty() {
 					intersection = t
 				} else {
 					intersection = intersection.Intersection(t)
@@ -388,9 +388,9 @@ func (b builder) BuildOrFail(t test.Failer) echo.Instances {
 
 // validateTemplates returns true if the templates specified by inject.istio.io/templates on the config exist on c
 func (b builder) validateTemplates(config echo.Config, c cluster.Cluster) bool {
-	expected := sets.NewSet()
+	expected := sets.New()
 	for _, subset := range config.Subsets {
-		expected.Insert(parseList(subset.Annotations.Get(echo.SidecarInjectTemplates))...)
+		expected.InsertAll(parseList(subset.Annotations.Get(echo.SidecarInjectTemplates))...)
 	}
 	if b.templates == nil || b.templates[c.Name()] == nil {
 		return len(expected) == 0
diff --git a/pkg/test/framework/components/echo/echotest/filters.go b/pkg/test/framework/components/echo/echotest/filters.go
index c866919303..1bf6d08cd4 100644
--- a/pkg/test/framework/components/echo/echotest/filters.go
+++ b/pkg/test/framework/components/echo/echotest/filters.go
@@ -17,6 +17,7 @@
 import (
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
+	"istio.io/istio/pkg/util/sets"
 )
 
 type (
@@ -114,12 +115,12 @@ func oneRegularPodPerNamespace(exclude echo.Instances) Filter {
 		}
 
 		// Pick a single regular pod per namespace.
-		namespaces := make(map[string]struct{})
+		namespaces := sets.New()
 		var outServices echo.Services
 		for _, svc := range regularPods.Services() {
 			ns := svc.Config().Namespace.Name()
-			if _, ok := namespaces[ns]; !ok {
-				namespaces[ns] = struct{}{}
+			if !namespaces.Contains(ns) {
+				namespaces.Insert(ns)
 				outServices = append(outServices, svc)
 			}
 		}
diff --git a/pkg/test/framework/components/echo/namespacedname.go b/pkg/test/framework/components/echo/namespacedname.go
index 9bcb4e7984..834e28e8f3 100644
--- a/pkg/test/framework/components/echo/namespacedname.go
+++ b/pkg/test/framework/components/echo/namespacedname.go
@@ -18,8 +18,8 @@
 	"sort"
 	"strings"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // NamespacedName represents the full name of a service.
diff --git a/pkg/test/framework/resource/settings.go b/pkg/test/framework/resource/settings.go
index d08edadad0..efa1bbf254 100644
--- a/pkg/test/framework/resource/settings.go
+++ b/pkg/test/framework/resource/settings.go
@@ -24,9 +24,9 @@
 	"gopkg.in/yaml.v3"
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/label"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const (
@@ -157,7 +157,7 @@ func (s Settings) Skip(class string) bool {
 }
 
 func (s *Settings) SkipWorkloadClassesAsSet() sets.Set {
-	return sets.NewSet(s.SkipWorkloadClasses...)
+	return sets.NewWith(s.SkipWorkloadClasses...)
 }
 
 // RunDir is the name of the dir to output, for this particular run.
diff --git a/pkg/test/framework/suitecontext.go b/pkg/test/framework/suitecontext.go
index 4478baa76e..aa558a89ed 100644
--- a/pkg/test/framework/suitecontext.go
+++ b/pkg/test/framework/suitecontext.go
@@ -30,6 +30,7 @@
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/yml"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // suiteContext contains suite-level items used during runtime.
@@ -53,7 +54,7 @@ type suiteContext struct {
 	globalScope *scope
 
 	contextMu    sync.Mutex
-	contextNames map[string]struct{}
+	contextNames sets.Set
 
 	suiteLabels label.Set
 
@@ -76,7 +77,7 @@ func newSuiteContext(s *resource.Settings, envFn resource.EnvironmentFactory, la
 		workDir:      workDir,
 		FileWriter:   yml.NewFileWriter(workDir),
 		suiteLabels:  labels,
-		contextNames: make(map[string]struct{}),
+		contextNames: sets.New(),
 	}
 
 	env, err := envFn(c)
@@ -98,8 +99,8 @@ func (s *suiteContext) allocateContextID(prefix string) string {
 	candidate := prefix
 	discriminator := 0
 	for {
-		if _, found := s.contextNames[candidate]; !found {
-			s.contextNames[candidate] = struct{}{}
+		if !s.contextNames.Contains(candidate) {
+			s.contextNames.Insert(candidate)
 			return candidate
 		}
 
@@ -116,8 +117,8 @@ func (s *suiteContext) allocateResourceID(contextID string, r resource.Resource)
 	candidate := fmt.Sprintf("%s/[%s]", contextID, t.String())
 	discriminator := 0
 	for {
-		if _, found := s.contextNames[candidate]; !found {
-			s.contextNames[candidate] = struct{}{}
+		if !s.contextNames.Contains(candidate) {
+			s.contextNames.Insert(candidate)
 			return candidate
 		}
 
diff --git a/pilot/pkg/util/sets/string.go b/pkg/util/sets/string.go
similarity index 71%
rename from pilot/pkg/util/sets/string.go
rename to pkg/util/sets/string.go
index a26dc34112..4f6b8a4be4 100644
--- a/pilot/pkg/util/sets/string.go
+++ b/pkg/util/sets/string.go
@@ -18,27 +18,43 @@
 
 type Set map[string]struct{}
 
+// New returns a new empty Set.
+func New() Set {
+	return make(Set)
+}
+
+// NewWithLength returns an empty Set with the given length.
 func NewWithLength(l int) Set {
 	return make(Set, l)
 }
 
-// NewSet creates a Set from a list of values.
-func NewSet(items ...string) Set {
-	ss := make(Set, len(items))
-	ss.Insert(items...)
-	return ss
+// NewWith creates a new Set with the given items.
+func NewWith(items ...string) Set {
+	return NewWithLength(len(items)).InsertAll(items...)
+}
+
+// Insert adds the item to the set.
+func (s Set) Insert(item string) Set {
+	s[item] = struct{}{}
+	return s
 }
 
-// Insert adds items to the set.
-func (s Set) Insert(items ...string) Set {
+// InsertAll adds items to the set.
+func (s Set) InsertAll(items ...string) Set {
 	for _, item := range items {
 		s[item] = struct{}{}
 	}
 	return s
 }
 
-// Delete removes items from the set.
-func (s Set) Delete(items ...string) Set {
+// Delete removes the item from the set.
+func (s Set) Delete(item string) Set {
+	delete(s, item)
+	return s
+}
+
+// DeleteAll removes items from the set.
+func (s Set) DeleteAll(items ...string) Set {
 	for _, item := range items {
 		delete(s, item)
 	}
@@ -58,16 +74,22 @@ func (s Set) Merge(s2 Set) Set {
 	return s
 }
 
+// Copy this set.
+func (s Set) Copy() Set {
+	result := New()
+	for key := range s {
+		result.Insert(key)
+	}
+	return result
+}
+
 // Union returns a set of objects that are in s or s2
 // For example:
 // s = {a1, a2, a3}
 // s2 = {a1, a2, a4, a5}
 // s.Union(s2) = s2.Union(s) = {a1, a2, a3, a4, a5}
 func (s Set) Union(s2 Set) Set {
-	result := NewSet()
-	for key := range s {
-		result.Insert(key)
-	}
+	result := s.Copy()
 	for key := range s2 {
 		result.Insert(key)
 	}
@@ -81,9 +103,9 @@ func (s Set) Union(s2 Set) Set {
 // s.Difference(s2) = {a3}
 // s2.Difference(s) = {a4, a5}
 func (s Set) Difference(s2 Set) Set {
-	result := NewSet()
+	result := New()
 	for key := range s {
-		if _, exist := s2[key]; !exist {
+		if !s2.Contains(key) {
 			result.Insert(key)
 		}
 	}
@@ -96,9 +118,9 @@ func (s Set) Difference(s2 Set) Set {
 // s2 = {a1, a2, a4, a5}
 // s.Intersection(s2) = {a1, a2}
 func (s Set) Intersection(s2 Set) Set {
-	result := NewSet()
+	result := New()
 	for key := range s {
-		if _, exist := s2[key]; exist {
+		if s2.Contains(key) {
 			result.Insert(key)
 		}
 	}
@@ -112,12 +134,12 @@ func (s Set) Intersection(s2 Set) Set {
 // s.SupersetOf(s2) = false
 // s2.SupersetOf(s) = true
 func (s Set) SupersetOf(s2 Set) bool {
-	return len(s2.Difference(s)) == 0
+	return s2.Difference(s).IsEmpty()
 }
 
 // UnsortedList returns the slice with contents in random order.
 func (s Set) UnsortedList() []string {
-	res := make([]string, 0, len(s))
+	res := make([]string, 0, s.Len())
 	for key := range s {
 		res = append(res, key)
 	}
@@ -139,12 +161,12 @@ func (s Set) Contains(item string) bool {
 
 // Equals checks whether the given set is equal to the current set.
 func (s Set) Equals(other Set) bool {
-	if len(s) != len(other) {
+	if s.Len() != other.Len() {
 		return false
 	}
 
 	for key := range s {
-		if _, exists := other[key]; !exists {
+		if !other.Contains(key) {
 			return false
 		}
 	}
@@ -152,7 +174,12 @@ func (s Set) Equals(other Set) bool {
 	return true
 }
 
-// Empty returns whether the set is the empty set.
-func (s Set) Empty() bool {
+// Len returns the number of elements in this Set.
+func (s Set) Len() int {
+	return len(s)
+}
+
+// IsEmpty indicates whether the set is the empty set.
+func (s Set) IsEmpty() bool {
 	return len(s) == 0
 }
diff --git a/pilot/pkg/util/sets/string_test.go b/pkg/util/sets/string_test.go
similarity index 80%
rename from pilot/pkg/util/sets/string_test.go
rename to pkg/util/sets/string_test.go
index a7adf8a0f9..6438ee9ff2 100644
--- a/pilot/pkg/util/sets/string_test.go
+++ b/pkg/util/sets/string_test.go
@@ -23,7 +23,7 @@
 
 func TestNewSet(t *testing.T) {
 	elements := []string{"a", "b", "c"}
-	set := NewSet(elements...)
+	set := NewWith(elements...)
 
 	if len(set) != len(elements) {
 		t.Errorf("Expected length %d != %d", len(set), len(elements))
@@ -39,10 +39,10 @@ func TestNewSet(t *testing.T) {
 func TestUnion(t *testing.T) {
 	elements := []string{"a", "b", "c", "d"}
 	elements2 := []string{"a", "b", "e"}
-	want := NewSet("a", "b", "c", "d", "e")
+	want := NewWith("a", "b", "c", "d", "e")
 	for _, sets := range [][]Set{
-		{NewSet(elements...), NewSet(elements2...)},
-		{NewSet(elements2...), NewSet(elements...)},
+		{NewWith(elements...), NewWith(elements2...)},
+		{NewWith(elements2...), NewWith(elements...)},
 	} {
 		s1, s2 := sets[0], sets[1]
 		if got := s1.Union(s2); !got.Equals(want) {
@@ -53,10 +53,10 @@ func TestUnion(t *testing.T) {
 
 func TestDifference(t *testing.T) {
 	elements := []string{"a", "b", "c", "d"}
-	s1 := NewSet(elements...)
+	s1 := NewWith(elements...)
 
 	elements2 := []string{"a", "b", "e"}
-	s2 := NewSet(elements2...)
+	s2 := NewWith(elements2...)
 
 	d := s1.Difference(s2)
 
@@ -74,10 +74,10 @@ func TestDifference(t *testing.T) {
 
 func TestIntersection(t *testing.T) {
 	elements := []string{"a", "b", "d"}
-	s1 := NewSet(elements...)
+	s1 := NewWith(elements...)
 
 	elements2 := []string{"a", "b", "c"}
-	s2 := NewSet(elements2...)
+	s2 := NewWith(elements2...)
 
 	d := s1.Intersection(s2)
 
@@ -95,17 +95,17 @@ func TestIntersection(t *testing.T) {
 
 func TestSupersetOf(t *testing.T) {
 	elements := []string{"a", "b", "c", "d"}
-	s1 := NewSet(elements...)
+	s1 := NewWith(elements...)
 
 	elements2 := []string{"a", "b"}
-	s2 := NewSet(elements2...)
+	s2 := NewWith(elements2...)
 
 	if !s1.SupersetOf(s2) {
 		t.Errorf("%v should be superset of %v", s1.SortedList(), s2.SortedList())
 	}
 
-	s3 := NewSet()
-	if !NewSet().SupersetOf(s3) {
+	s3 := NewWith()
+	if !NewWith().SupersetOf(s3) {
 		fmt.Printf("%q\n", s3.SortedList()[0])
 		t.Errorf("%v should be superset of empty set", s1.SortedList())
 	}
@@ -126,20 +126,20 @@ func TestEquals(t *testing.T) {
 		},
 		{
 			"unequal length",
-			NewSet("test"),
-			NewSet("test", "test1"),
+			NewWith("test"),
+			NewWith("test", "test1"),
 			false,
 		},
 		{
 			"equal sets",
-			NewSet("test", "test1"),
-			NewSet("test", "test1"),
+			NewWith("test", "test1"),
+			NewWith("test", "test1"),
 			true,
 		},
 		{
 			"unequal sets",
-			NewSet("test", "test1"),
-			NewSet("test", "test2"),
+			NewWith("test", "test1"),
+			NewWith("test", "test2"),
 			false,
 		},
 	}
@@ -158,18 +158,18 @@ func TestMerge(t *testing.T) {
 		expected []string
 	}{
 		{
-			s1:       NewSet("a1", "a2"),
-			s2:       NewSet("a1", "a2"),
+			s1:       NewWith("a1", "a2"),
+			s2:       NewWith("a1", "a2"),
 			expected: []string{"a1", "a2"},
 		},
 		{
-			s1:       NewSet("a1", "a2", "a3"),
-			s2:       NewSet("a1", "a2"),
+			s1:       NewWith("a1", "a2", "a3"),
+			s2:       NewWith("a1", "a2"),
 			expected: []string{"a1", "a2", "a3"},
 		},
 		{
-			s1:       NewSet("a1", "a2"),
-			s2:       NewSet("a3", "a4"),
+			s1:       NewWith("a1", "a2"),
+			s2:       NewWith("a3", "a4"),
 			expected: []string{"a1", "a2", "a3", "a4"},
 		},
 	}
diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 95abc5aeb7..804083b2a6 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -28,7 +28,7 @@
 	"sync"
 	"time"
 
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -96,7 +96,7 @@ func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, in
 		purgeInterval:      purgeInterval,
 		wasmModuleExpiry:   moduleExpiry,
 		stopChan:           make(chan struct{}),
-		insecureRegistries: sets.NewSet(insecureRegistries...),
+		insecureRegistries: sets.NewWith(insecureRegistries...),
 	}
 	go func() {
 		cache.purge()
diff --git a/security/pkg/nodeagent/cache/secretcache.go b/security/pkg/nodeagent/cache/secretcache.go
index 6a4bd81446..62d1473ed2 100644
--- a/security/pkg/nodeagent/cache/secretcache.go
+++ b/security/pkg/nodeagent/cache/secretcache.go
@@ -29,11 +29,11 @@
 	"github.com/cenkalti/backoff/v4"
 	"github.com/fsnotify/fsnotify"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/file"
 	"istio.io/istio/pkg/queue"
 	"istio.io/istio/pkg/security"
 	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/security/pkg/monitoring"
 	nodeagentutil "istio.io/istio/security/pkg/nodeagent/util"
 	pkiutil "istio.io/istio/security/pkg/pki/util"
@@ -760,7 +760,7 @@ func (sc *SecretManagerClient) mergeConfigTrustBundle(rootCerts []string) []byte
 	sc.configTrustBundleMutex.RLock()
 	existingCerts := pkiutil.PemCertBytestoString(sc.configTrustBundle)
 	sc.configTrustBundleMutex.RUnlock()
-	anchors := sets.NewSet()
+	anchors := sets.New()
 	for _, cert := range existingCerts {
 		anchors.Insert(cert)
 	}
diff --git a/security/pkg/nodeagent/caclient/providers/google-cas/client.go b/security/pkg/nodeagent/caclient/providers/google-cas/client.go
index 32c896005a..1a8f803ba2 100644
--- a/security/pkg/nodeagent/caclient/providers/google-cas/client.go
+++ b/security/pkg/nodeagent/caclient/providers/google-cas/client.go
@@ -26,6 +26,7 @@
 	"k8s.io/apimachinery/pkg/util/rand"
 
 	"istio.io/istio/pkg/security"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -117,9 +118,7 @@ func (r *GoogleCASClient) CSRSign(csrPEM []byte, certValidTTLInSec int64) ([]str
 
 // GetRootCertBundle:  Get CA certs of the pool from Google CAS API endpoint
 func (r *GoogleCASClient) GetRootCertBundle() ([]string, error) {
-	rootCertMap := make(map[string]struct{})
-	trustbundle := []string{}
-	var err error
+	rootCertSet := sets.New()
 
 	ctx := context.Background()
 
@@ -129,22 +128,19 @@ func (r *GoogleCASClient) GetRootCertBundle() ([]string, error) {
 	resp, err := r.caClient.FetchCaCerts(ctx, req)
 	if err != nil {
 		googleCASClientLog.Errorf("error when getting root-certs from CAS pool: %v", err)
-		return trustbundle, err
+		return nil, err
 	}
 	for _, certChain := range resp.CaCerts {
 		certs := certChain.Certificates
 		rootCert := certs[len(certs)-1]
-		if _, ok := rootCertMap[rootCert]; !ok {
-			rootCertMap[rootCert] = struct{}{}
+		if !rootCertSet.Contains(rootCert) {
+			rootCertSet.Insert(rootCert)
 		}
 	}
 
-	for rootCert := range rootCertMap {
-		trustbundle = append(trustbundle, rootCert)
-	}
-	return trustbundle, nil
+	return rootCertSet.SortedList(), nil
 }
 
 func (r *GoogleCASClient) Close() {
-	r.caClient.Close()
+	_ = r.caClient.Close()
 }
diff --git a/security/pkg/nodeagent/sds/sdsservice.go b/security/pkg/nodeagent/sds/sdsservice.go
index a8a719d7e0..35821c06db 100644
--- a/security/pkg/nodeagent/sds/sdsservice.go
+++ b/security/pkg/nodeagent/sds/sdsservice.go
@@ -31,11 +31,11 @@
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/security"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -73,7 +73,7 @@ func NewXdsServer(stop chan struct{}, gen model.XdsResourceGenerator) *xds.Disco
 			return false
 		}
 
-		names := sets.NewSet(resources...)
+		names := sets.NewWith(resources...)
 		found := false
 		for name := range model.ConfigsOfKind(req.ConfigsUpdated, gvk.Secret) {
 			if names.Contains(name.Name) {
@@ -171,7 +171,7 @@ func (s *sdsservice) Generate(proxy *model.Proxy, w *model.WatchedResource, upda
 		return resp, pushLog(w.ResourceNames), err
 	}
 	names := []string{}
-	watched := sets.NewSet(w.ResourceNames...)
+	watched := sets.NewWith(w.ResourceNames...)
 	for i := range updates.ConfigsUpdated {
 		if i.Kind == gvk.Secret && watched.Contains(i.Name) {
 			names = append(names, i.Name)
diff --git a/tests/fuzz/regression_test.go b/tests/fuzz/regression_test.go
index 8a6698fbd3..1c717bc5a3 100644
--- a/tests/fuzz/regression_test.go
+++ b/tests/fuzz/regression_test.go
@@ -22,8 +22,8 @@
 	"testing"
 
 	"istio.io/istio/pilot/pkg/util/runtime"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // baseCases contains a few trivial test cases to do a very brief sanity check of a test
@@ -107,7 +107,7 @@ func walkMatch(root string, pattern *regexp.Regexp) ([]string, error) {
 }
 
 func TestFuzzers(t *testing.T) {
-	testedFuzzers := sets.NewSet()
+	testedFuzzers := sets.New()
 	cases := []struct {
 		name   string
 		fuzzer func([]byte) int
@@ -178,7 +178,7 @@ func TestFuzzers(t *testing.T) {
 		if err != nil {
 			t.Fatal(err)
 		}
-		allFuzzers := sets.NewSet(fuzzers...)
+		allFuzzers := sets.NewWith(fuzzers...)
 		if !allFuzzers.Equals(testedFuzzers) {
 			t.Fatalf("Not all fuzzers are tested! Missing %v", allFuzzers.Difference(testedFuzzers))
 		}
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 6cb991292c..e4c05fa91b 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -30,7 +30,6 @@
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/security"
@@ -50,6 +49,7 @@
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/tmpl"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tests/common/jwt"
 	ingressutil "istio.io/istio/tests/integration/security/sds_ingress/util"
 )
@@ -2027,7 +2027,7 @@ func(responses echoClient.Responses, rerr error) error {
 		hostnames[i] = r.Hostname
 	}
 	scopes.Framework.Infof("requests landed on hostnames: %v", hostnames)
-	unique := sets.NewSet(hostnames...).SortedList()
+	unique := sets.NewWith(hostnames...).SortedList()
 	if len(unique) != 1 {
 		return fmt.Errorf("excepted only one destination, got: %v", unique)
 	}
diff --git a/tests/integration/pilot/validation_test.go b/tests/integration/pilot/validation_test.go
index cf814934cd..716951bfa4 100644
--- a/tests/integration/pilot/validation_test.go
+++ b/tests/integration/pilot/validation_test.go
@@ -30,6 +30,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/util/yml"
+	"istio.io/istio/pkg/util/sets"
 )
 
 type testData string
@@ -157,17 +158,13 @@ func TestEnsureNoMissingCRDs(t *testing.T) {
 	// types that are no longer supported.
 	framework.NewTest(t).
 		Run(func(t framework.TestContext) {
-			ignored := make(map[string]struct{})
-			for _, ig := range ignoredCRDs {
-				ignored[ig] = struct{}{}
-			}
-
-			recognized := make(map[string]struct{})
+			ignored := sets.NewWith(ignoredCRDs...)
+			recognized := sets.New()
 
 			// TODO(jasonwzm) remove this after multi-version APIs are supported.
 			for _, r := range collections.Pilot.All() {
 				s := strings.Join([]string{r.Resource().Group(), r.Resource().Version(), r.Resource().Kind()}, "/")
-				recognized[s] = struct{}{}
+				recognized.Insert(s)
 			}
 			for _, gvk := range []string{
 				"networking.istio.io/v1beta1/Gateway",
@@ -176,7 +173,7 @@ func TestEnsureNoMissingCRDs(t *testing.T) {
 				"networking.istio.io/v1beta1/WorkloadEntry",
 				"networking.istio.io/v1beta1/Sidecar",
 			} {
-				recognized[gvk] = struct{}{}
+				recognized.Insert(gvk)
 			}
 			// These CRDs are validated outside of Istio
 			for _, gvk := range []string{
@@ -187,11 +184,11 @@ func TestEnsureNoMissingCRDs(t *testing.T) {
 				"gateway.networking.k8s.io/v1alpha2/TLSRoute",
 				"gateway.networking.k8s.io/v1alpha2/ReferencePolicy",
 			} {
-				delete(recognized, gvk)
+				recognized.Delete(gvk)
 			}
 
-			testedValid := make(map[string]struct{})
-			testedInvalid := make(map[string]struct{})
+			testedValid := sets.New()
+			testedInvalid := sets.New()
 			for _, te := range loadTestData(t) {
 				yamlBatch, err := te.load()
 				yamlParts := yml.SplitString(yamlBatch)
@@ -214,22 +211,22 @@ func TestEnsureNoMissingCRDs(t *testing.T) {
 
 					key := strings.Join([]string{apiVersion, kind}, "/")
 					if te.isValid() {
-						testedValid[key] = struct{}{}
+						testedValid.Insert(key)
 					} else {
-						testedInvalid[key] = struct{}{}
+						testedInvalid.Insert(key)
 					}
 				}
 			}
 
 			for rec := range recognized {
-				if _, found := ignored[rec]; found {
+				if ignored.Contains(rec) {
 					continue
 				}
 
-				if _, found := testedValid[rec]; !found {
+				if !testedValid.Contains(rec) {
 					t.Errorf("CRD does not have a positive validation test: %v", rec)
 				}
-				if _, found := testedInvalid[rec]; !found {
+				if !testedInvalid.Contains(rec) {
 					t.Errorf("CRD does not have a negative validation test: %v", rec)
 				}
 			}
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index cb0062e593..f8c3ef299a 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -32,7 +32,6 @@
 	monitoring "google.golang.org/genproto/googleapis/monitoring/v3"
 	"google.golang.org/protobuf/proto"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/env"
@@ -48,6 +47,7 @@
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tests/integration/telemetry"
 )
 
@@ -349,7 +349,7 @@ func logDiff(t test.Failer, tp string, query map[string]string, entries []map[st
 		return
 	}
 	allMismatches := []map[string]string{}
-	seen := sets.NewSet()
+	seen := sets.New()
 	for _, s := range entries {
 		b, _ := json.Marshal(s)
 		ss := string(b)
diff --git a/tools/bug-report/pkg/bugreport/bugreport.go b/tools/bug-report/pkg/bugreport/bugreport.go
index 3fdeb268eb..9675cd76af 100644
--- a/tools/bug-report/pkg/bugreport/bugreport.go
+++ b/tools/bug-report/pkg/bugreport/bugreport.go
@@ -35,6 +35,7 @@
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/inject"
 	"istio.io/istio/pkg/proxy"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tools/bug-report/pkg/archive"
 	cluster2 "istio.io/istio/tools/bug-report/pkg/cluster"
 	"istio.io/istio/tools/bug-report/pkg/common"
@@ -211,26 +212,22 @@ func dumpRevisionsAndVersions(resources *cluster2.Resources, kubeconfig, configC
 
 // getIstioRevisions returns a slice with all Istio revisions detected in the cluster.
 func getIstioRevisions(resources *cluster2.Resources) []string {
-	revMap := make(map[string]struct{})
+	revMap := sets.New()
 	for _, podLabels := range resources.Labels {
 		for label, value := range podLabels {
 			if label == istioRevisionLabel {
-				revMap[value] = struct{}{}
+				revMap.Insert(value)
 			}
 		}
 	}
-	var out []string
-	for k := range revMap {
-		out = append(out, k)
-	}
-	return out
+	return revMap.SortedList()
 }
 
 // getIstioVersions returns a mapping of revision to aggregated version string for Istio components and revision to
 // slice of versions for proxies. Any errors are embedded in the revision strings.
 func getIstioVersions(kubeconfig, configContext, istioNamespace string, revisions []string) (map[string]string, map[string][]string) {
 	istioVersions := make(map[string]string)
-	proxyVersionsMap := make(map[string]map[string]struct{})
+	proxyVersionsMap := make(map[string]sets.Set)
 	proxyVersions := make(map[string][]string)
 	for _, revision := range revisions {
 		istioVersions[revision] = getIstioVersion(kubeconfig, configContext, istioNamespace, revision)
@@ -241,14 +238,14 @@ func getIstioVersions(kubeconfig, configContext, istioNamespace string, revision
 		}
 		for _, pi := range *proxyInfo {
 			if proxyVersionsMap[revision] == nil {
-				proxyVersionsMap[revision] = make(map[string]struct{})
+				proxyVersionsMap[revision] = sets.New()
 			}
-			proxyVersionsMap[revision][pi.IstioVersion] = struct{}{}
+			proxyVersionsMap[revision].Insert(pi.IstioVersion)
 		}
 	}
 	for revision, vmap := range proxyVersionsMap {
-		for version := range vmap {
-			proxyVersions[revision] = append(proxyVersions[revision], version)
+		for v := range vmap {
+			proxyVersions[revision] = append(proxyVersions[revision], v)
 		}
 	}
 	return istioVersions, proxyVersions
diff --git a/tools/bug-report/pkg/filter/filter.go b/tools/bug-report/pkg/filter/filter.go
index 8eb296077b..a300d270b3 100644
--- a/tools/bug-report/pkg/filter/filter.go
+++ b/tools/bug-report/pkg/filter/filter.go
@@ -16,8 +16,8 @@
 
 import (
 	"fmt"
-	"sort"
 
+	"istio.io/istio/pkg/util/sets"
 	cluster2 "istio.io/istio/tools/bug-report/pkg/cluster"
 	"istio.io/istio/tools/bug-report/pkg/config"
 	"istio.io/istio/tools/bug-report/pkg/util/match"
@@ -32,33 +32,15 @@ func GetMatchingPaths(config *config.BugReportConfig, cluster *cluster2.Resource
 	if err != nil {
 		return nil, err
 	}
-	var out []string
-	for p := range paths {
-		out = append(out, p)
-	}
-	sort.Strings(out)
-
-	return out, nil
-}
-
-func mergeMaps(a, b map[string]struct{}) map[string]struct{} {
-	out := make(map[string]struct{})
-	for k := range a {
-		out[k] = struct{}{}
-	}
-	for k := range b {
-		out[k] = struct{}{}
-	}
-	return out
+	return paths.SortedList(), nil
 }
 
-func getMatchingPathsForSpec(config *config.BugReportConfig, cluster *cluster2.Resources) (map[string]struct{}, error) {
-	paths := make(map[string]struct{})
-	return getMatchingPathsForSpecImpl(config, cluster, cluster.Root, nil, paths)
+func getMatchingPathsForSpec(config *config.BugReportConfig, cluster *cluster2.Resources) (sets.Set, error) {
+	return getMatchingPathsForSpecImpl(config, cluster, cluster.Root, nil, sets.New())
 }
 
 func getMatchingPathsForSpecImpl(config *config.BugReportConfig, cluster *cluster2.Resources, node map[string]interface{},
-	path path.Path, matchingPaths map[string]struct{}) (map[string]struct{}, error) {
+	path path.Path, matchingPaths sets.Set) (sets.Set, error) {
 	for pe, n := range node {
 		np := append(path, pe)
 		if nn, ok := n.(map[string]interface{}); ok {
@@ -67,7 +49,7 @@ func getMatchingPathsForSpecImpl(config *config.BugReportConfig, cluster *cluste
 			if err != nil {
 				return nil, err
 			}
-			matchingPaths = mergeMaps(matchingPaths, mp)
+			matchingPaths = matchingPaths.Union(mp)
 			continue
 		}
 		// container name leaf
diff --git a/tools/bug-report/pkg/kubectlcmd/kubectlcmd.go b/tools/bug-report/pkg/kubectlcmd/kubectlcmd.go
index 7530aee76d..2a835d665c 100644
--- a/tools/bug-report/pkg/kubectlcmd/kubectlcmd.go
+++ b/tools/bug-report/pkg/kubectlcmd/kubectlcmd.go
@@ -27,6 +27,7 @@
 
 	"istio.io/istio/operator/pkg/util"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tools/bug-report/pkg/common"
 	"istio.io/pkg/log"
 )
@@ -46,7 +47,7 @@
 	logFetchLimitCh = make(chan struct{}, maxLogFetchConcurrency)
 
 	// runningTasks tracks the in-flight fetch operations for user feedback.
-	runningTasks   = make(map[string]struct{})
+	runningTasks   = sets.New()
 	runningTasksMu sync.RWMutex
 
 	// runningTasksTicker is the report interval for running tasks.
@@ -209,7 +210,7 @@ func Run(subcmds []string, opts *Options) (string, error) {
 func printRunningTasks() {
 	runningTasksMu.RLock()
 	defer runningTasksMu.RUnlock()
-	if len(runningTasks) == 0 {
+	if runningTasks.IsEmpty() {
 		return
 	}
 	common.LogAndPrintf("The following fetches are still running: \n")
@@ -223,12 +224,12 @@ func addRunningTask(task string) {
 	runningTasksMu.Lock()
 	defer runningTasksMu.Unlock()
 	log.Infof("STARTING %s", task)
-	runningTasks[task] = struct{}{}
+	runningTasks.Insert(task)
 }
 
 func removeRunningTask(task string) {
 	runningTasksMu.Lock()
 	defer runningTasksMu.Unlock()
 	log.Infof("COMPLETED %s", task)
-	delete(runningTasks, task)
+	runningTasks.Delete(task)
 }
diff --git a/tools/docker-builder/main.go b/tools/docker-builder/main.go
index 1bb6b1bfc8..7bbe4d6553 100644
--- a/tools/docker-builder/main.go
+++ b/tools/docker-builder/main.go
@@ -31,8 +31,8 @@
 	"golang.org/x/sync/errgroup"
 	"sigs.k8s.io/yaml"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	testenv "istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 	pkgversion "istio.io/pkg/version"
 )
@@ -60,7 +60,7 @@ func main() {
 	}
 }
 
-var privilegedHubs = sets.NewSet(
+var privilegedHubs = sets.NewWith(
 	"docker.io/istio",
 	"istio",
 	"gcr.io/istio-release",
@@ -84,7 +84,7 @@ func main() {
 			return fmt.Errorf("--push and --save are mutually exclusive")
 		}
 		_, inCI := os.LookupEnv("CI")
-		if args.Push && len(privilegedHubs.Intersection(sets.NewSet(args.Hubs...))) > 0 && !inCI {
+		if args.Push && len(privilegedHubs.Intersection(sets.NewWith(args.Hubs...))) > 0 && !inCI {
 			// Safety check against developer error. If they have a legitimate use case, they can set CI var
 			return fmt.Errorf("pushing to official registry only supported in CI")
 		}
@@ -146,8 +146,8 @@ func ReadPlan(a Args) (Args, error) {
 	if err := yaml.Unmarshal([]byte(input), &plan); err != nil {
 		return a, err
 	}
-	tgt := sets.NewSet(a.Targets...)
-	known := sets.NewSet()
+	tgt := sets.NewWith(a.Targets...)
+	known := sets.New()
 	for _, img := range plan.Images {
 		known.Insert(img.Name)
 	}
@@ -282,18 +282,18 @@ func ConstructBakeFile(a Args) (map[string]string, error) {
 	// Groups just bundles targets together to make them easier to work with
 	groups := map[string]Group{}
 
-	variants := sets.NewSet(a.Variants...)
+	variants := sets.NewWith(a.Variants...)
 	// hasDoubleDefault checks if we defined both DefaultVariant and PrimaryVariant. If we did, these
 	// are the same exact docker build, just requesting different tags. As an optimization, and to ensure
 	// byte-for-byte identical images, we will collapse these into a single build with multiple tags.
 	hasDoubleDefault := variants.Contains(DefaultVariant) && variants.Contains(PrimaryVariant)
 
-	allGroups := sets.NewSet()
+	allGroups := sets.New()
 	// Tar files builds a mapping of tar file name (when used with --save) -> alias for that
 	// If the value is "", the tar file exists but has no aliases
 	tarFiles := map[string]string{}
 
-	allDestinations := sets.NewSet()
+	allDestinations := sets.New()
 	for _, variant := range a.Variants {
 		for _, target := range a.Targets {
 			bp := a.Plan.Find(target)
@@ -344,7 +344,7 @@ func ConstructBakeFile(a Args) (map[string]string, error) {
 					}
 				}
 			}
-			allDestinations.Insert(t.Tags...)
+			allDestinations.InsertAll(t.Tags...)
 
 			// See https://docs.docker.com/engine/reference/commandline/buildx_build/#output
 			if args.Push {
@@ -458,7 +458,7 @@ func VerboseCommand(name string, arg ...string) *exec.Cmd {
 
 func StandardEnv(args Args) []string {
 	env := os.Environ()
-	if len(sets.NewSet(args.Targets...).Delete("proxyv2")) <= 1 {
+	if len(sets.NewWith(args.Targets...).Delete("proxyv2")) <= 1 {
 		// If we are building multiple, it is faster to build all binaries in a single invocation
 		// Otherwise, build just the single item. proxyv2 is special since it is always built separately with tag=agent.
 		// Ideally we would just always build the targets we need but our Makefile is not that smart
diff --git a/tools/docker-builder/types.go b/tools/docker-builder/types.go
index 0e258510d3..1bbd532210 100644
--- a/tools/docker-builder/types.go
+++ b/tools/docker-builder/types.go
@@ -22,8 +22,8 @@
 
 	"k8s.io/utils/env"
 
-	"istio.io/istio/pilot/pkg/util/sets"
 	testenv "istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -97,9 +97,9 @@ type BuildPlan struct {
 }
 
 func (p BuildPlan) Targets() []string {
-	tgts := sets.NewSet()
+	tgts := sets.New()
 	for _, img := range p.Images {
-		tgts.Insert(img.Targets...)
+		tgts.InsertAll(img.Targets...)
 	}
 	return tgts.SortedList()
 }
@@ -169,7 +169,7 @@ func DefaultArgs() Args {
 	if os.Getenv("INCLUDE_UNTAGGED_DEFAULT") == "true" {
 		// This legacy env var was to workaround the old build logic not being very smart
 		// In the new builder, we automagically detect this. So just insert the 'default' variant
-		cur := sets.NewSet(variants...)
+		cur := sets.NewWith(variants...)
 		cur.Insert(DefaultVariant)
 		variants = cur.SortedList()
 	}
diff --git a/tools/istio-iptables/pkg/builder/iptables_builder_impl.go b/tools/istio-iptables/pkg/builder/iptables_builder_impl.go
index cbaad5cd5a..db2493e2d8 100644
--- a/tools/istio-iptables/pkg/builder/iptables_builder_impl.go
+++ b/tools/istio-iptables/pkg/builder/iptables_builder_impl.go
@@ -18,6 +18,7 @@
 	"fmt"
 	"strings"
 
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tools/istio-iptables/pkg/config"
 	"istio.io/istio/tools/istio-iptables/pkg/constants"
 	"istio.io/istio/tools/istio-iptables/pkg/log"
@@ -147,17 +148,17 @@ func (rb *IptablesBuilder) AppendRuleV6(command log.Command, chain string, table
 }
 
 func (rb *IptablesBuilder) buildRules(command string, rules []*Rule) [][]string {
-	output := [][]string{}
-	chainTableLookupMap := make(map[string]struct{})
+	output := make([][]string, 0)
+	chainTableLookupSet := sets.New()
 	for _, r := range rules {
 		chainTable := fmt.Sprintf("%s:%s", r.chain, r.table)
 		// Create new chain if key: `chainTable` isn't present in map
-		if _, present := chainTableLookupMap[chainTable]; !present {
+		if !chainTableLookupSet.Contains(chainTable) {
 			// Ignore chain creation for built-in chains for iptables
 			if _, present := constants.BuiltInChainsMap[r.chain]; !present {
 				cmd := []string{command, "-t", r.table, "-N", r.chain}
 				output = append(output, cmd)
-				chainTableLookupMap[chainTable] = struct{}{}
+				chainTableLookupSet.Insert(chainTable)
 			}
 		}
 	}
@@ -180,11 +181,11 @@ func (rb *IptablesBuilder) constructIptablesRestoreContents(tableRulesMap map[st
 	var b strings.Builder
 	for table, rules := range tableRulesMap {
 		if len(rules) > 0 {
-			fmt.Fprintln(&b, "*", table)
+			_, _ = fmt.Fprintln(&b, "*", table)
 			for _, r := range rules {
-				fmt.Fprintln(&b, r)
+				_, _ = fmt.Fprintln(&b, r)
 			}
-			fmt.Fprintln(&b, "COMMIT")
+			_, _ = fmt.Fprintln(&b, "COMMIT")
 		}
 	}
 	return b.String()
@@ -197,15 +198,15 @@ func (rb *IptablesBuilder) buildRestore(rules []*Rule) string {
 		constants.MANGLE: {},
 	}
 
-	chainTableLookupMap := make(map[string]struct{})
+	chainTableLookupMap := sets.New()
 	for _, r := range rules {
 		chainTable := fmt.Sprintf("%s:%s", r.chain, r.table)
 		// Create new chain if key: `chainTable` isn't present in map
-		if _, present := chainTableLookupMap[chainTable]; !present {
+		if !chainTableLookupMap.Contains(chainTable) {
 			// Ignore chain creation for built-in chains for iptables
 			if _, present := constants.BuiltInChainsMap[r.chain]; !present {
 				tableRulesMap[r.table] = append(tableRulesMap[r.table], fmt.Sprintf("-N %s", r.chain))
-				chainTableLookupMap[chainTable] = struct{}{}
+				chainTableLookupMap.Insert(chainTable)
 			}
 		}
 	}
diff --git a/tools/istio-iptables/pkg/dependencies/implementation.go b/tools/istio-iptables/pkg/dependencies/implementation.go
index 72d0b6d120..7290998e38 100644
--- a/tools/istio-iptables/pkg/dependencies/implementation.go
+++ b/tools/istio-iptables/pkg/dependencies/implementation.go
@@ -25,7 +25,7 @@
 	"github.com/cenkalti/backoff/v4"
 	"github.com/spf13/viper"
 
-	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/util/sets"
 	"istio.io/istio/tools/istio-iptables/pkg/constants"
 	"istio.io/pkg/log"
 )
@@ -55,7 +55,7 @@
 }
 
 // XTablesCmds is the set of all the xtables-related commands currently supported.
-var XTablesCmds = sets.NewSet(
+var XTablesCmds = sets.NewWith(
 	constants.IPTABLES,
 	constants.IP6TABLES,
 	constants.IPTABLESRESTORE,
-- 
2.35.3

