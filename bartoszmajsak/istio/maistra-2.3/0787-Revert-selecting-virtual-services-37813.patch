From 2a38aca26bf6d41dbd93ff9f3089eb1918d69a6e Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Sun, 13 Mar 2022 18:20:52 -0700
Subject: Revert selecting virtual services (#37813)

* Revert "Added selecting virtualservice (#33764)"

This reverts commit dea2be520667359e0f44e7d1db24b01f26b16741.

* Expand tests

* fmt

* add more tests

* More tests

* 1 more test

* remove dupl

* Add the selection back

* Refactor to generic

* wip

* Add tests for HTTP route

* Fix log line
---
 pilot/pkg/networking/core/v1alpha3/fake.go    |  15 +-
 .../pkg/networking/core/v1alpha3/httproute.go |  61 +-
 .../core/v1alpha3/httproute_test.go           | 207 ++++++-
 .../networking/core/v1alpha3/route/route.go   |  21 +-
 .../core/v1alpha3/sidecar_simulation_test.go  | 549 +++++++++++++++---
 pilot/pkg/xds/fake.go                         |  18 +-
 6 files changed, 756 insertions(+), 115 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/fake.go b/pilot/pkg/networking/core/v1alpha3/fake.go
index dcb470d52b..7b0a14b439 100644
--- a/pilot/pkg/networking/core/v1alpha3/fake.go
+++ b/pilot/pkg/networking/core/v1alpha3/fake.go
@@ -74,6 +74,9 @@ type TestOptions struct {
 	// Additional ConfigStoreCache to use
 	ConfigStoreCaches []model.ConfigStoreCache
 
+	// CreateConfigStore defines a function that, given a ConfigStoreCache, returns another ConfigStoreCache to use
+	CreateConfigStore func(c model.ConfigStoreCache) model.ConfigStoreCache
+
 	// ConfigGen plugins to use. If not set, all default plugins will be used
 	Plugins []plugin.Plugin
 
@@ -108,10 +111,13 @@ func NewConfigGenTest(t test.Failer, opts TestOptions) *ConfigGenTest {
 	})
 
 	configs := getConfigs(t, opts)
-	configStore := memory.MakeSkipValidation(collections.Pilot)
+	configStore := memory.MakeSkipValidation(collections.PilotGatewayAPI)
 
 	cc := memory.NewSyncController(configStore)
 	controllers := []model.ConfigStoreCache{cc}
+	if opts.CreateConfigStore != nil {
+		controllers = append(controllers, opts.CreateConfigStore(cc))
+	}
 	controllers = append(controllers, opts.ConfigStoreCaches...)
 	configController, _ := configaggregate.MakeWriteableCache(controllers, cc)
 
@@ -264,7 +270,8 @@ func (f *ConfigGenTest) Clusters(p *model.Proxy) []*cluster.Cluster {
 func (f *ConfigGenTest) DeltaClusters(
 	p *model.Proxy,
 	configUpdated map[model.ConfigKey]struct{},
-	watched *model.WatchedResource) ([]*cluster.Cluster, []string, bool) {
+	watched *model.WatchedResource,
+) ([]*cluster.Cluster, []string, bool) {
 	raw, removed, _, delta := f.ConfigGen.BuildDeltaClusters(p,
 		&model.PushRequest{
 			Push: f.PushContext(), ConfigsUpdated: configUpdated,
@@ -338,7 +345,9 @@ func getConfigs(t test.Failer, opts TestOptions) []config.Config {
 			}
 			// Set creation timestamp to same time for all of them for consistency.
 			// If explicit setting is needed it can be set in the yaml
-			c.CreationTimestamp = t0
+			if c.CreationTimestamp.IsZero() {
+				c.CreationTimestamp = t0
+			}
 			cfgs = append(cfgs, c)
 		}
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index 12b7d2447f..acc92f372e 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -48,7 +48,8 @@
 func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 	node *model.Proxy,
 	req *model.PushRequest,
-	routeNames []string) ([]*discovery.Resource, model.XdsLogDetails) {
+	routeNames []string,
+) ([]*discovery.Resource, model.XdsLogDetails) {
 	routeConfigurations := make([]*discovery.Resource, 0)
 
 	efw := req.Push.EnvoyFilters(node)
@@ -100,7 +101,8 @@ func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 // buildSidecarInboundHTTPRouteConfig builds the route config with a single wildcard virtual host on the inbound path
 // TODO: trace decorators, inbound timeouts
 func (configgen *ConfigGeneratorImpl) buildSidecarInboundHTTPRouteConfig(
-	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string) *route.RouteConfiguration {
+	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string,
+) *route.RouteConfiguration {
 	traceOperation := util.TraceOperation(string(instance.Service.Hostname), instance.ServicePort.Port)
 	defaultRoute := istio_route.BuildDefaultHTTPInboundRoute(clusterName, traceOperation)
 
@@ -215,11 +217,53 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundHTTPRouteConfig(
 	return resource, false
 }
 
+// TODO: merge with IstioEgressListenerWrapper.selectVirtualServices
+// selectVirtualServices selects the virtual services by matching given services' host names.
+func selectVirtualServices(virtualServices []config.Config, servicesByName map[host.Name]*model.Service) []config.Config {
+	out := make([]config.Config, 0)
+	for _, c := range virtualServices {
+		rule := c.Spec.(*networking.VirtualService)
+		var match bool
+
+		// Selection algorithm:
+		// virtualservices have a list of hosts in the API spec
+		// if any host in the list matches one service hostname, select the virtual service
+		// and break out of the loop.
+		for _, h := range rule.Hosts {
+			// TODO: This is a bug. VirtualServices can have many hosts
+			// while the user might be importing only a single host
+			// We need to generate a new VirtualService with just the matched host
+			if servicesByName[host.Name(h)] != nil {
+				match = true
+				break
+			}
+
+			for svcHost := range servicesByName {
+				if host.Name(h).Matches(svcHost) {
+					match = true
+					break
+				}
+			}
+
+			if match {
+				break
+			}
+		}
+
+		if match {
+			out = append(out, c)
+		}
+	}
+
+	return out
+}
+
 func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext,
 	routeName string,
 	listenerPort int,
 	efKeys []string,
-	xdsCache model.XdsCache) ([]*route.VirtualHost, *discovery.Resource, *istio_route.Cache) {
+	xdsCache model.XdsCache,
+) ([]*route.VirtualHost, *discovery.Resource, *istio_route.Cache) {
 	var virtualServices []config.Config
 	var services []*model.Service
 
@@ -271,12 +315,6 @@ func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext
 		}
 	}
 
-	// This is hack to keep consistent with previous behavior.
-	if listenerPort != 80 {
-		// only select virtualServices that matches a service
-		virtualServices = model.SelectVirtualServices(virtualServices, hostsByNamespace)
-	}
-
 	var routeCache *istio_route.Cache
 
 	if listenerPort > 0 {
@@ -304,6 +342,11 @@ func BuildSidecarOutboundVirtualHosts(node *model.Proxy, push *model.PushContext
 		}
 	}
 
+	// This is hack to keep consistent with previous behavior.
+	if listenerPort != 80 {
+		// only select virtualServices that matches a service
+		virtualServices = selectVirtualServices(virtualServices, servicesByName)
+	}
 	// Get list of virtual services bound to the mesh gateway
 	virtualHostWrappers := istio_route.BuildSidecarVirtualHostWrapper(routeCache, node, push, servicesByName, virtualServices, listenerPort)
 
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute_test.go b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
index b8baa171bc..7e53574a1c 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
@@ -958,6 +958,24 @@ func TestSidecarOutboundHTTPRouteConfig(t *testing.T) {
 			registryOnly: false,
 		},
 
+		{
+			name:                  "sidecar config with allow any and virtual service includes non existing service",
+			routeName:             "80",
+			sidecarConfig:         sidecarConfigWithAllowAny,
+			virtualServiceConfigs: []*config.Config{&virtualService6},
+			expectedHosts: map[string]map[string]bool{
+				// does not include `match-no-service`
+				"test-private.com:80": {
+					"test-private.com": true, "test-private.com:80": true, "9.9.9.9": true, "9.9.9.9:80": true,
+				},
+				"match-no-service.not-default:80": {"match-no-service.not-default": true, "match-no-service.not-default:80": true},
+				"allow_any": {
+					"*": true,
+				},
+			},
+			registryOnly: false,
+		},
+
 		{
 			name:                  "wildcard egress importing from all namespaces: 9999",
 			routeName:             "9999",
@@ -1283,9 +1301,196 @@ func TestSidecarOutboundHTTPRouteConfig(t *testing.T) {
 	}
 }
 
+func TestSelectVirtualService(t *testing.T) {
+	services := []*model.Service{
+		buildHTTPService("bookinfo.com", visibility.Public, wildcardIP, "default", 9999, 70),
+		buildHTTPService("private.com", visibility.Private, wildcardIP, "default", 9999, 80),
+		buildHTTPService("test.com", visibility.Public, "8.8.8.8", "not-default", 8080),
+		buildHTTPService("test-private.com", visibility.Private, "9.9.9.9", "not-default", 80, 70),
+		buildHTTPService("test-private-2.com", visibility.Private, "9.9.9.10", "not-default", 60),
+		buildHTTPService("test-headless.com", visibility.Public, wildcardIP, "not-default", 8888),
+	}
+
+	servicesByName := make(map[host.Name]*model.Service, len(services))
+	for _, svc := range services {
+		servicesByName[svc.Hostname] = svc
+	}
+
+	virtualServiceSpec1 := &networking.VirtualService{
+		Hosts:    []string{"test-private-2.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							// Subset: "some-subset",
+							Host: "example.org",
+							Port: &networking.PortSelector{
+								Number: 61,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec2 := &networking.VirtualService{
+		Hosts:    []string{"test-private-2.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 62,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec3 := &networking.VirtualService{
+		Hosts:    []string{"test-private-3.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 63,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec4 := &networking.VirtualService{
+		Hosts:    []string{"test-headless.com", "example.com"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test.org",
+							Port: &networking.PortSelector{
+								Number: 64,
+							},
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec5 := &networking.VirtualService{
+		Hosts:    []string{"test-svc.testns.svc.cluster.local"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "test-svc.testn.svc.cluster.local",
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualServiceSpec6 := &networking.VirtualService{
+		Hosts:    []string{"match-no-service"},
+		Gateways: []string{"mesh"},
+		Http: []*networking.HTTPRoute{
+			{
+				Route: []*networking.HTTPRouteDestination{
+					{
+						Destination: &networking.Destination{
+							Host: "non-exist-service",
+						},
+						Weight: 100,
+					},
+				},
+			},
+		},
+	}
+	virtualService1 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme2-v1",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec1,
+	}
+	virtualService2 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v2",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec2,
+	}
+	virtualService3 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec3,
+	}
+	virtualService4 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v4",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec4,
+	}
+	virtualService5 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec5,
+	}
+	virtualService6 := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+			Name:             "acme-v3",
+			Namespace:        "not-default",
+		},
+		Spec: virtualServiceSpec6,
+	}
+	configs := selectVirtualServices(
+		[]config.Config{virtualService1, virtualService2, virtualService3, virtualService4, virtualService5, virtualService6},
+		servicesByName)
+	expectedVS := []string{virtualService1.Name, virtualService2.Name, virtualService4.Name}
+	if len(expectedVS) != len(configs) {
+		t.Fatalf("Unexpected virtualService, got %d, epxected %d", len(configs), len(expectedVS))
+	}
+	for i, config := range configs {
+		if config.Name != expectedVS[i] {
+			t.Fatalf("Unexpected virtualService, got %s, epxected %s", config.Name, expectedVS[i])
+		}
+	}
+}
+
 func testSidecarRDSVHosts(t *testing.T, services []*model.Service,
 	sidecarConfig *config.Config, virtualServices []*config.Config, routeName string,
-	expectedHosts map[string]map[string]bool, expectedRoutes int, registryOnly bool) {
+	expectedHosts map[string]map[string]bool, expectedRoutes int, registryOnly bool,
+) {
 	t.Helper()
 	p := &fakePlugin{}
 	configgen := NewConfigGenerator([]plugin.Plugin{p}, &model.DisabledCache{})
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route.go b/pilot/pkg/networking/core/v1alpha3/route/route.go
index 7abb75d2da..15d4c88253 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route.go
@@ -88,7 +88,8 @@ type VirtualHostWrapper struct {
 // service registry. Services are indexed by FQDN hostnames.
 // The list of Services is also passed to allow maintaining consistent ordering.
 func BuildSidecarVirtualHostWrapper(routeCache *Cache, node *model.Proxy, push *model.PushContext, serviceRegistry map[host.Name]*model.Service,
-	virtualServices []config.Config, listenPort int) []VirtualHostWrapper {
+	virtualServices []config.Config, listenPort int,
+) []VirtualHostWrapper {
 	out := make([]VirtualHostWrapper, 0)
 
 	// dependentDestinationRules includes all the destinationrules referenced by the virtualservices, which have consistent hash policy.
@@ -155,7 +156,8 @@ func BuildSidecarVirtualHostWrapper(routeCache *Cache, node *model.Proxy, push *
 // separateVSHostsAndServices splits the virtual service hosts into Services (if they are found in the registry) and
 // plain non-registry hostnames
 func separateVSHostsAndServices(virtualService config.Config,
-	serviceRegistry map[host.Name]*model.Service) ([]string, []*model.Service) {
+	serviceRegistry map[host.Name]*model.Service,
+) ([]string, []*model.Service) {
 	rule := virtualService.Spec.(*networking.VirtualService)
 	hosts := make([]string, 0)
 	servicesInVirtualService := make([]*model.Service, 0)
@@ -458,7 +460,8 @@ func applyHTTPRouteDestination(
 	authority string,
 	serviceRegistry map[host.Name]*model.Service,
 	listenerPort int,
-	hashByDestination map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB) {
+	hashByDestination map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB,
+) {
 	policy := in.Retries
 	if policy == nil {
 		// No VS policy set, use mesh defaults
@@ -1156,7 +1159,8 @@ func translateFault(in *networking.HTTPFaultInjection) *xdshttpfault.HTTPFault {
 }
 
 func portLevelSettingsConsistentHash(dst *networking.Destination,
-	pls []*networking.TrafficPolicy_PortTrafficPolicy) *networking.LoadBalancerSettings_ConsistentHashLB {
+	pls []*networking.TrafficPolicy_PortTrafficPolicy,
+) *networking.LoadBalancerSettings_ConsistentHashLB {
 	if dst.Port != nil {
 		portNumber := dst.GetPort().GetNumber()
 		for _, setting := range pls {
@@ -1216,7 +1220,8 @@ func consistentHashToHashPolicy(consistentHash *networking.LoadBalancerSettings_
 }
 
 func getHashForService(node *model.Proxy, push *model.PushContext,
-	svc *model.Service, port *model.Port) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
+	svc *model.Service, port *model.Port,
+) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
 	if push == nil {
 		return nil, nil
 	}
@@ -1242,7 +1247,8 @@ func getHashForService(node *model.Proxy, push *model.PushContext,
 
 func GetConsistentHashForVirtualService(push *model.PushContext, node *model.Proxy,
 	virtualService config.Config,
-	serviceRegistry map[host.Name]*model.Service) map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB {
+	serviceRegistry map[host.Name]*model.Service,
+) map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB {
 	hashByDestination := map[*networking.HTTPRouteDestination]*networking.LoadBalancerSettings_ConsistentHashLB{}
 	for _, httpRoute := range virtualService.Spec.(*networking.VirtualService).Http {
 		for _, destination := range httpRoute.Route {
@@ -1265,7 +1271,8 @@ func GetConsistentHashForVirtualService(push *model.PushContext, node *model.Pro
 
 // GetHashForHTTPDestination return the ConsistentHashLB and the DestinationRule associated with HTTP route destination.
 func GetHashForHTTPDestination(push *model.PushContext, node *model.Proxy, dst *networking.HTTPRouteDestination,
-	configNamespace string) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
+	configNamespace string,
+) (*networking.LoadBalancerSettings_ConsistentHashLB, *config.Config) {
 	if push == nil {
 		return nil, nil
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
index 13616d9b55..360d4cc74f 100644
--- a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
@@ -1403,7 +1403,8 @@ func TestInboundSidecarTLSModes(t *testing.T) {
 
 	mkCall := func(port int, protocol simulation.Protocol,
 		tls simulation.TLSMode, validations []simulation.CustomFilterChainValidation,
-		mTLSSecretConfigName string) simulation.Call {
+		mTLSSecretConfigName string,
+	) simulation.Call {
 		return simulation.Call{
 			Protocol:                  protocol,
 			Port:                      port,
@@ -1577,6 +1578,16 @@ func TestInboundSidecarTLSModes(t *testing.T) {
 	}
 }
 
+const (
+	TimeOlder = "2019-01-01T00:00:00Z"
+	TimeBase  = "2020-01-01T00:00:00Z"
+	TimeNewer = "2021-01-01T00:00:00Z"
+)
+
+type Configer interface {
+	Config(variant string) string
+}
+
 type vsArgs struct {
 	Namespace string
 	Match     string
@@ -1586,20 +1597,44 @@ type vsArgs struct {
 	Time      string
 }
 
-const (
-	TimeOlder = "2019-01-01T00:00:00Z"
-	TimeBase  = "2020-01-01T00:00:00Z"
-	TimeNewer = "2021-01-01T00:00:00Z"
-)
-
-func vs(t test.Failer, args vsArgs) string {
+func (args vsArgs) Config(variant string) string {
 	if args.Time == "" {
 		args.Time = TimeBase
 	}
-	return tmpl.EvaluateOrFail(t, `apiVersion: networking.istio.io/v1alpha3
+
+	if args.PortMatch != 0 {
+		// TODO(v0.4.2) test port match
+		variant = "virtualservice"
+	}
+	switch variant {
+	case "httproute":
+		return tmpl.MustEvaluate(`apiVersion: gateway.networking.k8s.io/v1alpha2
+kind: HTTPRoute
+metadata:
+  name: "{{.Namespace}}{{.Match | replace "*" "wild"}}{{.Dest}}"
+  namespace: {{.Namespace}}
+  creationTimestamp: "{{.Time}}"
+spec:
+  parentRefs:
+  - kind: Mesh
+    name: istio
+{{ with .PortMatch }}
+    port: {{.}}
+{{ end }}
+  hostnames:
+  - "{{.Match}}"
+  rules:
+  - backendRefs:
+    - kind: Hostname
+      group: networking.istio.io
+      name: {{.Dest}}
+      port: {{.Port | default 80}}
+`, args)
+	case "virtualservice":
+		return tmpl.MustEvaluate(`apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
 metadata:
-  name: "{{.Namespace}}{{.Match}}{{.Dest}}"
+  name: "{{.Namespace}}{{.Match | replace "*" "wild"}}{{.Dest}}"
   namespace: {{.Namespace}}
   creationTimestamp: "{{.Time}}"
 spec:
@@ -1617,11 +1652,33 @@ func vs(t test.Failer, args vsArgs) string {
     match:
     - port: {{.}}
 {{ end }}
----
+`, args)
+	default:
+		panic(variant + " unknown")
+	}
+}
+
+type scArgs struct {
+	Namespace string
+	Egress    []string
+}
+
+func (args scArgs) Config(variant string) string {
+	return tmpl.MustEvaluate(`apiVersion: networking.istio.io/v1alpha3
+kind: Sidecar
+metadata:
+  name: "{{.Namespace}}"
+  namespace: "{{.Namespace}}"
+spec:
+  egress:
+  - hosts:
+{{- range $val := .Egress }}
+    - "{{$val}}"
+{{- end }}
 `, args)
 }
 
-func TestVirtualService(t *testing.T) {
+func TestSidecarRoutes(t *testing.T) {
 	knownServices := `
 apiVersion: networking.istio.io/v1alpha3
 kind: ServiceEntry
@@ -1665,25 +1722,47 @@ func TestVirtualService(t *testing.T) {
     number: 8080
     protocol: HTTP
 ---
+apiVersion: networking.istio.io/v1alpha3
+kind: ServiceEntry
+metadata:
+  name: not-default.example.org
+  namespace: not-default
+spec:
+  hosts:
+  - not-default.example.org
+  addresses:
+  - 2.0.0.2
+  endpoints:
+  - address: 1.0.0.2
+  resolution: STATIC
+  ports:
+  - name: http
+    number: 80
+    protocol: HTTP
+  - name: http-other
+    number: 8080
+    protocol: HTTP
+---
 `
 	proxy := func(ns string) *model.Proxy {
 		return &model.Proxy{ConfigNamespace: ns}
 	}
 	cases := []struct {
-		name      string
-		cfg       string
-		proxy     *model.Proxy
-		routeName string
-		expected  map[string][]string
+		name            string
+		cfg             []Configer
+		proxy           *model.Proxy
+		routeName       string
+		expected        map[string][]string
+		expectedGateway map[string][]string
 	}{
 		// Port 80 has special cases as there is defaulting logic around this port
 		{
 			name: "simple port 80",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1692,24 +1771,27 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "simple port 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "8080",
 			expected: map[string][]string{
 				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
 			},
+			expectedGateway: map[string][]string{
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
 		},
 		{
 			name: "unknown port 80",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "foo.com",
 				Dest:      "foo.com",
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1718,53 +1800,55 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "unknown port 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "foo.com",
 				Dest:      "foo.com",
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "8080",
 			// For unknown services, we only will add a route to the port 80
-			expected: nil,
+			expected: map[string][]string{
+				"default.com": nil,
+			},
 		},
 		{
 			name: "unknown port 8080 match 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "foo.com",
 				Dest:      "foo.com",
 				PortMatch: 8080,
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "8080",
 			// For unknown services, we only will add a route to the port 80
-			// TODO even with port match?? that seems wrong!
-			//expected: map[string][]string{
-			//	"foo.com": {"outbound|8080||foo.com"},
-			//},
-			expected: nil,
+			expected: map[string][]string{
+				"foo.com": nil,
+			},
 		},
 		{
 			name: "unknown port 8080 dest 8080 ",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "foo.com",
 				Dest:      "foo.com",
 				Port:      8080,
-			}),
+			}},
 			proxy:     proxy("default"),
 			routeName: "8080",
 			// For unknown services, we only will add a route to the port 80
-			expected: nil,
+			expected: map[string][]string{
+				"default.com": nil,
+			},
 		},
 		{
 			name: "producer rule port 80",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1773,24 +1857,27 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "producer rule port 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "8080",
 			expected: map[string][]string{
 				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
 			},
+			expectedGateway: map[string][]string{ // No implicit port matching for gateway
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+			},
 		},
 		{
 			name: "consumer rule port 80",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "not-default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1799,26 +1886,27 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "consumer rule port 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "not-default",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "8080",
 			expected: map[string][]string{
-				// TODO(https://github.com/istio/istio/issues/37691)
-				//"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
-				"known-default.example.com": {"outbound|8080||known-default.example.com"},
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+			expectedGateway: map[string][]string{ // No implicit port matching for gateway
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
 			},
 		},
 		{
 			name: "arbitrary rule port 80",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "arbitrary",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1827,40 +1915,42 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "arbitrary rule port 8080",
-			cfg: vs(t, vsArgs{
+			cfg: []Configer{vsArgs{
 				Namespace: "arbitrary",
 				Match:     "known-default.example.com",
 				Dest:      "alt-known-default.example.com",
-			}),
+			}},
 			proxy:     proxy("not-default"),
 			routeName: "8080",
 			expected: map[string][]string{
-				// TODO(https://github.com/istio/istio/issues/37691)
-				//"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
-				"known-default.example.com": {"outbound|8080||known-default.example.com"},
+				"known-default.example.com": {"outbound|8080||alt-known-default.example.com"},
+			},
+			expectedGateway: map[string][]string{ // No implicit port matching for gateway
+				"known-default.example.com": {"outbound|80||alt-known-default.example.com"},
 			},
 		},
 		{
 			name: "multiple rules 80",
-			cfg: "" +
-				vs(t, vsArgs{
+			cfg: []Configer{
+				vsArgs{
 					Namespace: "arbitrary",
 					Match:     "known-default.example.com",
 					Dest:      "arbitrary.example.com",
 					Time:      TimeOlder,
-				}) +
-				vs(t, vsArgs{
+				},
+				vsArgs{
 					Namespace: "default",
 					Match:     "known-default.example.com",
 					Dest:      "default.example.com",
 					Time:      TimeBase,
-				}) +
-				vs(t, vsArgs{
+				},
+				vsArgs{
 					Namespace: "not-default",
 					Match:     "known-default.example.com",
 					Dest:      "not-default.example.com",
 					Time:      TimeNewer,
-				}),
+				},
+			},
 			proxy:     proxy("not-default"),
 			routeName: "80",
 			expected: map[string][]string{
@@ -1870,55 +1960,332 @@ func TestVirtualService(t *testing.T) {
 		},
 		{
 			name: "multiple rules 8080",
-			cfg: "" +
-				vs(t, vsArgs{
+			cfg: []Configer{
+				vsArgs{
 					Namespace: "arbitrary",
 					Match:     "known-default.example.com",
 					Dest:      "arbitrary.example.com",
 					Time:      TimeOlder,
-				}) +
-				vs(t, vsArgs{
+				},
+				vsArgs{
 					Namespace: "default",
 					Match:     "known-default.example.com",
 					Dest:      "default.example.com",
 					Time:      TimeBase,
-				}) +
-				vs(t, vsArgs{
+				},
+				vsArgs{
 					Namespace: "not-default",
 					Match:     "known-default.example.com",
 					Dest:      "not-default.example.com",
 					Time:      TimeNewer,
-				}),
+				},
+			},
 			proxy:     proxy("not-default"),
 			routeName: "8080",
 			expected: map[string][]string{
 				// Oldest wins
-				// TODO(https://github.com/istio/istio/issues/37691)
-				//"known-default.example.com": {"outbound|8080||arbitrary.example.com"},
-				"known-default.example.com": {"outbound|8080||default.example.com"},
+				"known-default.example.com": {"outbound|8080||arbitrary.example.com"},
+			},
+			expectedGateway: map[string][]string{ // No implicit port matching for gateway
+				"known-default.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard random",
+			cfg: []Configer{vsArgs{
+				Namespace: "default",
+				Match:     "*.unknown.example.com",
+				Dest:      "arbitrary.example.com",
+			}},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// match no VS, get default config
+				"alt-known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+				"known-default.example.com":     {"outbound|80||known-default.example.com"},
+				// Wildcard doesn't match any known services, insert it as-is
+				"*.unknown.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard match with sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/*.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||arbitrary.example.com"},
+				"known-default.example.com":     {"outbound|80||arbitrary.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard first then explicit",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"}, // oldest wins
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "explicit first then wildcard",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeNewer,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeOlder,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||explicit.example.com"}, // oldest wins
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit with sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"default/known-default.example.com", "default/alt-known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Even though we did not import `*.example.com`, the VS attaches
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "explicit first then wildcard with sidecar cross namespace",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.example.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"default/known-default.example.com", "default/alt-known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Similar to above, but now the older wildcard VS is in a complete different namespace which we don't import
+				"alt-known-default.example.com": {"outbound|80||alt-known-default.example.com"},
+				"known-default.example.com":     {"outbound|80||explicit.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit cross namespace",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.com",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "known-default.example.com",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// Wildcard is older, so it wins, even though it is cross namespace
+				"alt-known-default.example.com": {"outbound|80||wild.example.com"},
+				"known-default.example.com":     {"outbound|80||wild.example.com"},
+				// Matched an exact service, so we have no route for the wildcard
+				"*.example.com": nil,
+			},
+		},
+		{
+			name: "wildcard and explicit unknown",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.tld",
+					Dest:      "wild.example.com",
+					Time:      TimeOlder,
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "example.tld",
+					Dest:      "explicit.example.com",
+					Time:      TimeNewer,
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// wildcard does not match
+				"known-default.example.com": {"outbound|80||known-default.example.com"},
+				// Even though its less exact, this wildcard wins
+				"*.tld":         {"outbound|80||wild.example.com"},
+				"*.example.tld": nil,
+			},
+		},
+		{
+			name: "explicit match with wildcard sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "arbitrary.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/*.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"arbitrary.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "wildcard match with explicit sidecar",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				scArgs{
+					Namespace: "default",
+					Egress:    []string{"*/known-default.example.com"},
+				},
+			},
+			proxy:     proxy("default"),
+			routeName: "80",
+			expected: map[string][]string{
+				"known-default.example.com": {"outbound|80||arbitrary.example.com"},
+			},
+		},
+		{
+			name: "sidecar filter",
+			cfg: []Configer{
+				vsArgs{
+					Namespace: "not-default",
+					Match:     "*.example.com",
+					Dest:      "arbitrary.example.com",
+				},
+				vsArgs{
+					Namespace: "default",
+					Match:     "explicit.example.com",
+					Dest:      "explicit.example.com",
+				},
+				scArgs{
+					Namespace: "not-default",
+					Egress:    []string{"not-default/*.example.com", "not-default/not-default.example.org"},
+				},
+			},
+			proxy:     proxy("not-default"),
+			routeName: "80",
+			expected: map[string][]string{
+				// even though there is an *.example.com, since we do not import it we should create a wildcard matcher
+				"*.example.com": {"outbound|80||arbitrary.example.com"},
+				// We did not import this, shouldn't show up
+				"explicit.example.com": nil,
 			},
 		},
-		// TODO: add cases with sidecar scope
-		// Add cases with wildcards
-		// Especially import
 	}
-	for _, tt := range cases {
-		t.Run(tt.name, func(t *testing.T) {
-			s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{ConfigString: tt.cfg + knownServices})
-			sim := simulation.NewSimulation(t, s, s.SetupProxy(tt.proxy))
-			xdstest.ValidateListeners(t, sim.Listeners)
-			xdstest.ValidateRouteConfigurations(t, sim.Routes)
-			r := xdstest.ExtractRouteConfigurations(sim.Routes)
-			vh := r[tt.routeName]
-			if vh == nil {
-				t.Fatalf("route %q not found, have %v", tt.routeName, xdstest.MapKeys(r))
-			}
-			gotHosts := xdstest.ExtractVirtualHosts(r[tt.routeName])
-			for wk, wv := range tt.expected {
-				got := gotHosts[wk]
-				if !reflect.DeepEqual(wv, got) {
-					t.Errorf("%v: wanted %v, got %v (had %v)", wk, wv, got, xdstest.MapKeys(gotHosts))
-				}
+	for _, variant := range []string{"httproute", "virtualservice"} {
+		t.Run(variant, func(t *testing.T) {
+			for _, tt := range cases {
+				t.Run(tt.name, func(t *testing.T) {
+					cfg := knownServices
+					for _, tc := range tt.cfg {
+						cfg = cfg + "\n---\n" + tc.Config(variant)
+					}
+					s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{ConfigString: cfg})
+					sim := simulation.NewSimulation(t, s, s.SetupProxy(tt.proxy))
+					xdstest.ValidateListeners(t, sim.Listeners)
+					xdstest.ValidateRouteConfigurations(t, sim.Routes)
+					r := xdstest.ExtractRouteConfigurations(sim.Routes)
+					vh := r[tt.routeName]
+					if vh == nil {
+						t.Fatalf("route %q not found, have %v", tt.routeName, xdstest.MapKeys(r))
+					}
+					gotHosts := xdstest.ExtractVirtualHosts(r[tt.routeName])
+					exp := tt.expected
+					if variant == "httproute" && tt.expectedGateway != nil {
+						exp = tt.expectedGateway
+					}
+					for wk, wv := range exp {
+						got := gotHosts[wk]
+						if !reflect.DeepEqual(wv, got) {
+							t.Errorf("%v: wanted %v, got %v (had %v)", wk, wv, got, xdstest.MapKeys(gotHosts))
+						}
+					}
+				})
 			}
 		})
 	}
diff --git a/pilot/pkg/xds/fake.go b/pilot/pkg/xds/fake.go
index 2a4c38e397..c713b77db0 100644
--- a/pilot/pkg/xds/fake.go
+++ b/pilot/pkg/xds/fake.go
@@ -35,6 +35,7 @@
 	"k8s.io/client-go/tools/cache"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pilot/pkg/config/kube/gateway"
 	"istio.io/istio/pilot/pkg/config/kube/ingress"
 	"istio.io/istio/pilot/pkg/controller/workloadentry"
 	kubesecrets "istio.io/istio/pilot/pkg/credentials/kube"
@@ -210,6 +211,7 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 	})
 	defaultKubeClient.RunAndWait(stop)
 
+	var gwc *gateway.Controller
 	cg := v1alpha3.NewConfigGenTest(t, v1alpha3.TestOptions{
 		Configs:             opts.Configs,
 		ConfigString:        opts.ConfigString,
@@ -219,14 +221,22 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 		ServiceRegistries:   registries,
 		PushContextLock:     &s.updateMutex,
 		ConfigStoreCaches:   []model.ConfigStoreCache{ingr},
-		SkipRun:             true,
-		ClusterID:           defaultKubeController.Cluster(),
-		Services:            opts.Services,
-		Gateways:            opts.Gateways,
+		CreateConfigStore: func(c model.ConfigStoreCache) model.ConfigStoreCache {
+			g := gateway.NewController(defaultKubeClient, c, kube.Options{
+				DomainSuffix: "cluster.local",
+			})
+			gwc = g
+			return gwc
+		},
+		SkipRun:   true,
+		ClusterID: defaultKubeController.Cluster(),
+		Services:  opts.Services,
+		Gateways:  opts.Gateways,
 	})
 	cg.ServiceEntryRegistry.AppendServiceHandler(serviceHandler)
 	s.updateMutex.Lock()
 	s.Env = cg.Env()
+	s.Env.GatewayAPIController = gwc
 	if err := s.Env.InitNetworksManager(s); err != nil {
 		t.Fatal(err)
 	}
-- 
2.35.3

