From 26eafbd1d0e3a3dcd2f4bd8c77bca089fc499f38 Mon Sep 17 00:00:00 2001
From: Steven Landow <steven@stlcomputerservices.com>
Date: Tue, 11 Jan 2022 13:28:24 -0600
Subject: resolve gateway hostnames in control plane (#36422)

* resolve network gw names

Change-Id: Iff91ba55b01f2c8e90ccc9b93337551a882b7423

* lint

Change-Id: I3ea750e23919d92eebeca95b87d8d07f0947ee89

* allow hostname in validation

Change-Id: Ifd0ce69dca1c46b8970750f667996603890a2878
---
 pilot/pkg/bootstrap/server.go                 |   5 +-
 pilot/pkg/features/pilot.go                   |   3 +
 pilot/pkg/model/context.go                    |  14 +-
 pilot/pkg/model/network.go                    | 424 ++++++++++++++++--
 pilot/pkg/model/network_test.go               | 144 ++++++
 pilot/pkg/model/push_context.go               |   8 +-
 pilot/pkg/model/push_context_test.go          |   2 +
 pilot/pkg/model/service.go                    |   6 +-
 pilot/pkg/networking/core/v1alpha3/fake.go    |   3 +
 .../serviceregistry/aggregate/controller.go   |   2 +
 .../aggregate/controller_test.go              |  59 +--
 .../kube/controller/controller.go             |  50 +--
 .../kube/controller/network.go                | 203 +++++----
 .../kube/controller/network_test.go           | 179 ++++++++
 pilot/pkg/serviceregistry/memory/discovery.go |   6 +-
 pilot/pkg/serviceregistry/mock/discovery.go   |   2 +
 .../serviceentry/servicediscovery.go          |   2 +
 pilot/pkg/xds/debug.go                        |   4 +-
 pilot/pkg/xds/eds_sh_test.go                  |  22 +-
 pilot/pkg/xds/ep_filters_test.go              |   3 +
 pilot/pkg/xds/fake.go                         |  22 +-
 pilot/pkg/xds/mesh_network_test.go            |  53 ++-
 pkg/config/mesh/mesh.go                       |  27 --
 pkg/config/mesh/mesh_test.go                  |  49 --
 pkg/config/mesh/networks_watcher.go           |   5 +-
 pkg/config/validation/validation.go           |  10 +-
 pkg/config/validation/validation_test.go      |  25 ++
 releasenotes/notes/36422.yaml                 |  11 +
 28 files changed, 1037 insertions(+), 306 deletions(-)
 create mode 100644 pilot/pkg/model/network_test.go
 create mode 100644 pilot/pkg/serviceregistry/kube/controller/network_test.go
 create mode 100644 releasenotes/notes/36422.yaml

diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 9ed195f353..cd5adc9935 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -238,6 +238,9 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 	s.initMeshNetworks(args, s.fileWatcher)
 	s.initMeshHandlers()
 	s.environment.Init()
+	if err := s.environment.InitNetworksManager(s.XDSServer); err != nil {
+		return nil, err
+	}
 
 	// Options based on the current 'defaults' in istio.
 	caOpts := &caOptions{
@@ -1186,7 +1189,7 @@ func (s *Server) initMeshHandlers() {
 	s.environment.AddNetworksHandler(func() {
 		s.XDSServer.ConfigUpdate(&model.PushRequest{
 			Full:   true,
-			Reason: []model.TriggerReason{model.GlobalUpdate},
+			Reason: []model.TriggerReason{model.NetworksTrigger},
 		})
 	})
 }
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index bb4b205d48..03be09d653 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -544,6 +544,9 @@
 	MulticlusterHeadlessEnabled = env.RegisterBoolVar("ENABLE_MULTICLUSTER_HEADLESS", true,
 		"If true, the DNS name table for a headless service will resolve to same-network endpoints in any cluster.").Get()
 
+	ResolveHostnameGateways = env.RegisterBoolVar("RESOLVE_HOSTNAME_GATEWAYS", true,
+		"If true, hostnames in the LoadBalancer addresses of a Service will be resolved at the control plane for use in cross-network gateways.").Get()
+
 	CertSignerDomain = env.RegisterStringVar("CERT_SIGNER_DOMAIN", "", "The cert signer domain info").Get()
 
 	AutoReloadPluginCerts = env.RegisterBoolVar(
diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 031d2e60d0..ca26ea3b99 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -73,6 +73,8 @@ type Environment struct {
 	// service registries.
 	mesh.NetworksWatcher
 
+	NetworkManager *NetworkManager
+
 	// PushContext holds information during push generation. It is reset on config change, at the beginning
 	// of the pushAll. It will hold all errors and stats and possibly caches needed during the entire cache computation.
 	// DO NOT USE EXCEPT FOR TESTS AND HANDLING OF NEW CONNECTIONS.
@@ -123,13 +125,6 @@ func (e *Environment) AddMeshHandler(h func()) {
 	}
 }
 
-func (e *Environment) Networks() *meshconfig.MeshNetworks {
-	if e != nil && e.NetworksWatcher != nil {
-		return e.NetworksWatcher.Networks()
-	}
-	return nil
-}
-
 func (e *Environment) AddNetworksHandler(h func()) {
 	if e != nil && e.NetworksWatcher != nil {
 		e.NetworksWatcher.AddNetworksHandler(h)
@@ -160,6 +155,11 @@ func (e *Environment) Init() {
 	e.clusterLocalServices = NewClusterLocalProvider(e)
 }
 
+func (e *Environment) InitNetworksManager(updater XDSUpdater) (err error) {
+	e.NetworkManager, err = NewNetworkManager(e, updater)
+	return
+}
+
 func (e *Environment) ClusterLocal() ClusterLocalProvider {
 	return e.clusterLocalServices
 }
diff --git a/pilot/pkg/model/network.go b/pilot/pkg/model/network.go
index 44ec5d13a7..b88aa3629c 100644
--- a/pilot/pkg/model/network.go
+++ b/pilot/pkg/model/network.go
@@ -15,10 +15,18 @@
 package model
 
 import (
+	"math"
 	"net"
+	"reflect"
 	"sort"
 	"strings"
+	"sync"
+	"time"
 
+	"github.com/miekg/dns"
+
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/network"
 )
@@ -35,50 +43,93 @@ type NetworkGateway struct {
 	Port uint32
 }
 
+type NetworkGatewaysWatcher interface {
+	NetworkGateways() []NetworkGateway
+	AppendNetworkGatewayHandler(h func())
+}
+
+// NetworkGatewaysHandler can be embedded to easily implement NetworkGatewaysWatcher.
+type NetworkGatewaysHandler struct {
+	handlers []func()
+}
+
+func (ngh *NetworkGatewaysHandler) AppendNetworkGatewayHandler(h func()) {
+	ngh.handlers = append(ngh.handlers, h)
+}
+
+func (ngh *NetworkGatewaysHandler) NotifyGatewayHandlers() {
+	for _, handler := range ngh.handlers {
+		handler()
+	}
+}
+
 // NewNetworkManager creates a new NetworkManager from the Environment by merging
 // together the MeshNetworks and ServiceRegistry-specific gateways.
-func NewNetworkManager(env *Environment) *NetworkManager {
-	// Generate the a snapshot of the state of gateways by merging the contents of
+func NewNetworkManager(env *Environment, xdsUpdater XDSUpdater) (*NetworkManager, error) {
+	nameCache, err := newNetworkGatewayNameCache()
+	if err != nil {
+		return nil, err
+	}
+	mgr := &NetworkManager{env: env, NameCache: nameCache, xdsUpdater: xdsUpdater}
+	env.AddNetworksHandler(mgr.reloadAndPush)
+	env.AppendNetworkGatewayHandler(mgr.reloadAndPush)
+	nameCache.AppendNetworkGatewayHandler(mgr.reloadAndPush)
+	mgr.reload()
+	return mgr, nil
+}
+
+func (mgr *NetworkManager) reloadAndPush() {
+	mgr.mu.Lock()
+	defer mgr.mu.Unlock()
+	oldGateways := make(NetworkGatewaySet)
+	for _, gateway := range mgr.allGateways() {
+		oldGateways.Add(gateway)
+	}
+	changed := !mgr.reload().Equals(oldGateways)
+
+	if changed && mgr.xdsUpdater != nil {
+		log.Infof("gateways changed, triggering push")
+		mgr.xdsUpdater.ConfigUpdate(&PushRequest{Full: true, Reason: []TriggerReason{NetworksTrigger}})
+	}
+}
+
+func (mgr *NetworkManager) reload() NetworkGatewaySet {
+	log.Infof("reloading network gateways")
+
+	// Generate a snapshot of the state of gateways by merging the contents of
 	// MeshNetworks and the ServiceRegistries.
 
 	// Store all gateways in a set initially to eliminate duplicates.
-	gatewaySet := make(map[NetworkGateway]struct{})
+	gatewaySet := make(NetworkGatewaySet)
 
 	// First, load gateways from the static MeshNetworks config.
-	meshNetworks := env.Networks()
+	meshNetworks := mgr.env.Networks()
 	if meshNetworks != nil {
 		for nw, networkConf := range meshNetworks.Networks {
-			gws := networkConf.Gateways
-			for _, gw := range gws {
-				if gwIP := net.ParseIP(gw.GetAddress()); gwIP != nil {
-					gatewaySet[NetworkGateway{
-						Cluster: "", /* TODO(nmittler): Add Cluster to the API */
-						Network: network.ID(nw),
-						Addr:    gw.GetAddress(),
-						Port:    gw.Port,
-					}] = struct{}{}
-				} else {
-					log.Warnf("Failed parsing gateway address %s in MeshNetworks config. "+
-						"Hostnames are not supported for gateways",
-						gw.GetAddress())
+			for _, gw := range networkConf.Gateways {
+				if gw.GetAddress() == "" {
+					// registryServiceName addresses will be populated via kube service registry
+					continue
 				}
+				gatewaySet[NetworkGateway{
+					Cluster: "", /* TODO(nmittler): Add Cluster to the API */
+					Network: network.ID(nw),
+					Addr:    gw.GetAddress(),
+					Port:    gw.Port,
+				}] = struct{}{}
 			}
 		}
 	}
 
 	// Second, load registry-specific gateways.
-	for _, gw := range env.NetworkGateways() {
-		if gwIP := net.ParseIP(gw.Addr); gwIP != nil {
-			// - the internal map of label gateways - these get deleted if the service is deleted, updated if the ip changes etc.
-			// - the computed map from meshNetworks (triggered by reloadNetworkLookup, the ported logic from getGatewayAddresses)
-			gatewaySet[gw] = struct{}{}
-		} else {
-			log.Warnf("Failed parsing gateway address %s from Service Registry. "+
-				"Hostnames are not supported for gateways",
-				gw.Addr)
-		}
+	for _, gw := range mgr.env.NetworkGateways() {
+		// - the internal map of label gateways - these get deleted if the service is deleted, updated if the ip changes etc.
+		// - the computed map from meshNetworks (triggered by reloadNetworkLookup, the ported logic from getGatewayAddresses)
+		gatewaySet[gw] = struct{}{}
 	}
 
+	mgr.resolveHostnameGateways(gatewaySet)
+
 	// Now populate the maps by network and by network+cluster.
 	byNetwork := make(map[network.ID][]NetworkGateway)
 	byNetworkAndCluster := make(map[networkAndCluster][]NetworkGateway)
@@ -108,40 +159,103 @@ func NewNetworkManager(env *Environment) *NetworkManager {
 		lcmVal = lcm(lcmVal, num)
 	}
 
-	return &NetworkManager{
-		lcm:                 uint32(lcmVal),
-		byNetwork:           byNetwork,
-		byNetworkAndCluster: byNetworkAndCluster,
+	mgr.lcm = uint32(lcmVal)
+	mgr.byNetwork = byNetwork
+	mgr.byNetworkAndCluster = byNetworkAndCluster
+
+	return gatewaySet
+}
+
+func (mgr *NetworkManager) resolveHostnameGateways(gatewaySet map[NetworkGateway]struct{}) {
+	// filter the list of gateways to resolve
+	hostnameGateways := map[string][]NetworkGateway{}
+	names := sets.NewSet()
+	for gw := range gatewaySet {
+		if gwIP := net.ParseIP(gw.Addr); gwIP != nil {
+			continue
+		}
+		delete(gatewaySet, gw)
+		if !features.ResolveHostnameGateways {
+			log.Warnf("Failed parsing gateway address %s from Service Registry. "+
+				"Set RESOLVE_HOSTNAME_GATEWAYS on istiod to enable resolving hostnames in the control plane.",
+				gw.Addr)
+			continue
+		}
+		hostnameGateways[gw.Addr] = append(hostnameGateways[gw.Addr], gw)
+		names.Insert(gw.Addr)
+	}
+
+	// resolve each hostname
+	for host, addrs := range mgr.NameCache.Resolve(names) {
+		gwsForHost := hostnameGateways[host]
+		if len(addrs) == 0 {
+			log.Warnf("could not resolve hostname %q for %d gateways", host, len(gwsForHost))
+		}
+		// expand each resolved address into a NetworkGateway
+		for _, gw := range gwsForHost {
+			for _, resolved := range addrs {
+				// copy the base gateway to preserve the port/network, but update with the resolved IP
+				resolvedGw := gw
+				resolvedGw.Addr = resolved
+				gatewaySet[resolvedGw] = struct{}{}
+			}
+		}
 	}
 }
 
 // NetworkManager provides gateway details for accessing remote networks.
 type NetworkManager struct {
+	env *Environment
+	// exported for test
+	NameCache  *networkGatewayNameCache
+	xdsUpdater XDSUpdater
+
 	// least common multiple of gateway number of {per network, per cluster}
+	mu                  sync.RWMutex
 	lcm                 uint32
 	byNetwork           map[network.ID][]NetworkGateway
 	byNetworkAndCluster map[networkAndCluster][]NetworkGateway
 }
 
 func (mgr *NetworkManager) IsMultiNetworkEnabled() bool {
+	if mgr == nil {
+		return false
+	}
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
 	return len(mgr.byNetwork) > 0
 }
 
 // GetLBWeightScaleFactor returns the least common multiple of the number of gateways per network.
 func (mgr *NetworkManager) GetLBWeightScaleFactor() uint32 {
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
 	return mgr.lcm
 }
 
 func (mgr *NetworkManager) AllGateways() []NetworkGateway {
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
+	return mgr.allGateways()
+}
+
+func (mgr *NetworkManager) allGateways() []NetworkGateway {
+	if mgr.byNetwork == nil {
+		return nil
+	}
 	out := make([]NetworkGateway, 0)
 	for _, gateways := range mgr.byNetwork {
 		out = append(out, gateways...)
 	}
-
 	return SortGateways(out)
 }
 
 func (mgr *NetworkManager) GatewaysByNetwork() map[network.ID][]NetworkGateway {
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
+	if mgr.byNetwork == nil {
+		return nil
+	}
 	out := make(map[network.ID][]NetworkGateway)
 	for k, v := range mgr.byNetwork {
 		out[k] = append(make([]NetworkGateway, 0, len(v)), v...)
@@ -150,10 +264,20 @@ func (mgr *NetworkManager) GatewaysByNetwork() map[network.ID][]NetworkGateway {
 }
 
 func (mgr *NetworkManager) GatewaysForNetwork(nw network.ID) []NetworkGateway {
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
+	if mgr.byNetwork == nil {
+		return nil
+	}
 	return mgr.byNetwork[nw]
 }
 
 func (mgr *NetworkManager) GatewaysForNetworkAndCluster(nw network.ID, c cluster.ID) []NetworkGateway {
+	mgr.mu.RLock()
+	defer mgr.mu.RUnlock()
+	if mgr.byNetwork == nil {
+		return nil
+	}
 	return mgr.byNetworkAndCluster[networkAndClusterFor(nw, c)]
 }
 
@@ -202,3 +326,239 @@ func gcd(x, y int) int {
 func lcm(x, y int) int {
 	return x * y / gcd(x, y)
 }
+
+// NetworkGatewaySet is a helper to manage a set of NetworkGateway instances.
+type NetworkGatewaySet map[NetworkGateway]struct{}
+
+func (s NetworkGatewaySet) Equals(other NetworkGatewaySet) bool {
+	if len(s) != len(other) {
+		return false
+	}
+	// deepequal won't catch nil-map == empty map
+	if len(s) == 0 && len(other) == 0 {
+		return true
+	}
+	return reflect.DeepEqual(s, other)
+}
+
+func (s NetworkGatewaySet) Add(gw NetworkGateway) {
+	s[gw] = struct{}{}
+}
+
+func (s NetworkGatewaySet) AddAll(other NetworkGatewaySet) {
+	for gw := range other {
+		s.Add(gw)
+	}
+}
+
+func (s NetworkGatewaySet) ToArray() []NetworkGateway {
+	gws := make([]NetworkGateway, 0, len(s))
+	for gw := range s {
+		gws = append(gws, gw)
+	}
+
+	// Sort the array so that it's stable.
+	gws = SortGateways(gws)
+	return gws
+}
+
+// MinGatewayTTL is exported for testing
+var MinGatewayTTL = 30 * time.Second
+
+type networkGatewayNameCache struct {
+	NetworkGatewaysHandler
+	client *dnsClient
+
+	sync.Mutex
+	cache map[string]nameCacheEntry
+}
+
+type nameCacheEntry struct {
+	value  []string
+	expiry time.Time
+	timer  *time.Timer
+}
+
+func newNetworkGatewayNameCache() (*networkGatewayNameCache, error) {
+	c, err := newClient()
+	if err != nil {
+		return nil, err
+	}
+	return newNetworkGatewayNameCacheWithClient(c), nil
+}
+
+// newNetworkGatewayNameCacheWithClient exported for test
+func newNetworkGatewayNameCacheWithClient(c *dnsClient) *networkGatewayNameCache {
+	return &networkGatewayNameCache{client: c, cache: map[string]nameCacheEntry{}}
+}
+
+// Resolve takes a list of hostnames and returns a map of names to addresses
+func (n *networkGatewayNameCache) Resolve(names sets.Set) map[string][]string {
+	n.Lock()
+	defer n.Unlock()
+
+	n.cleanupWatches(names)
+
+	out := make(map[string][]string, len(names))
+	for name := range names {
+		out[name] = n.resolveFromCache(name)
+	}
+
+	return out
+}
+
+// cleanupWatches cancels any scheduled re-resolve for names we no longer care about
+func (n *networkGatewayNameCache) cleanupWatches(names sets.Set) {
+	for name, entry := range n.cache {
+		if names.Contains(name) {
+			continue
+		}
+		entry.timer.Stop()
+		delete(n.cache, name)
+	}
+}
+
+func (n *networkGatewayNameCache) resolveFromCache(name string) []string {
+	if entry, ok := n.cache[name]; ok && entry.expiry.After(time.Now()) {
+		return entry.value
+	}
+	// ideally this will not happen more than once for each name and the cache auto-updates in the background
+	// even if it does, this happens on the SotW ingestion path (kube or meshnetworks changes) and not xds push path.
+	return n.resolveAndCache(name)
+}
+
+func (n *networkGatewayNameCache) resolveAndCache(name string) []string {
+	if entry, ok := n.cache[name]; ok {
+		entry.timer.Stop()
+	}
+	delete(n.cache, name)
+	addrs, ttl := n.resolve(name)
+	// avoid excessive pushes due to small TTL
+	if ttl < MinGatewayTTL {
+		ttl = MinGatewayTTL
+	}
+	expiry := time.Now().Add(ttl)
+	n.cache[name] = nameCacheEntry{
+		value:  addrs,
+		expiry: expiry,
+		// TTL expires, try to refresh TODO should this be < ttl?
+		timer: time.AfterFunc(ttl, n.refreshAndNotify(name)),
+	}
+
+	return addrs
+}
+
+// refreshAndNotify is triggered via time.AfterFunc and will recursively schedule itself that way until timer is cleaned
+// up via cleanupWatches.
+func (n *networkGatewayNameCache) refreshAndNotify(name string) func() {
+	return func() {
+		log.Debugf("network gateways: refreshing DNS for %s", name)
+		n.Lock()
+		old := n.cache[name]
+		addrs := n.resolveAndCache(name)
+		n.Unlock()
+
+		if !stringSliceEqual(old.value, addrs) {
+			log.Debugf("network gateways: DNS for %s changed: %v -> %v", name, old.value, addrs)
+			n.NotifyGatewayHandlers()
+		}
+	}
+}
+
+// avoid import cycle
+func stringSliceEqual(a, b []string) bool {
+	if len(a) != len(b) {
+		return false
+	}
+
+	for i := range a {
+		if a[i] != b[i] {
+			return false
+		}
+	}
+
+	return true
+}
+
+// resolve gets all the A and AAAA records for the given name
+func (n *networkGatewayNameCache) resolve(name string) ([]string, time.Duration) {
+	// TODO figure out how to query only A + AAAA
+	res := n.client.Query(new(dns.Msg).SetQuestion(dns.Fqdn(name), dns.TypeANY))
+	if res == nil || len(res.Answer) == 0 {
+		return nil, 0
+	}
+	ttl := uint32(math.MaxUint32)
+	var out []string
+	for _, rr := range res.Answer {
+		switch v := rr.(type) {
+		case *dns.A:
+			out = append(out, v.A.String())
+		case *dns.AAAA:
+			// TODO may not always want ipv6t?
+			out = append(out, v.AAAA.String())
+		default:
+			// not a valid record, don't inspect TTL
+			continue
+		}
+		if nextTTL := rr.Header().Ttl; nextTTL < ttl {
+			ttl = nextTTL
+		}
+	}
+	sort.Strings(out)
+	return out, time.Duration(ttl)
+}
+
+// TODO share code with pkg/dns
+type dnsClient struct {
+	*dns.Client
+	resolvConfServers []string
+}
+
+// NetworkGatewayTestDNSServers if set will ignore resolv.conf and use the given DNS servers for tests.
+var NetworkGatewayTestDNSServers []string = nil
+
+func newClient() (*dnsClient, error) {
+	servers := NetworkGatewayTestDNSServers
+	if len(servers) == 0 {
+		dnsConfig, err := dns.ClientConfigFromFile("/etc/resolv.conf")
+		if err != nil {
+			return nil, err
+		}
+		if dnsConfig != nil {
+			for _, s := range dnsConfig.Servers {
+				servers = append(servers, net.JoinHostPort(s, dnsConfig.Port))
+			}
+		}
+		// TODO take search namespaces into account
+		// TODO what about /etc/hosts?
+	}
+
+	c := &dnsClient{
+		Client: &dns.Client{
+			DialTimeout:  5 * time.Second,
+			ReadTimeout:  5 * time.Second,
+			WriteTimeout: 5 * time.Second,
+		},
+	}
+	c.resolvConfServers = append(c.resolvConfServers, servers...)
+	return c, nil
+}
+
+func (c *dnsClient) Query(req *dns.Msg) *dns.Msg {
+	var response *dns.Msg
+	for _, upstream := range c.resolvConfServers {
+		cResponse, _, err := c.Exchange(req, upstream)
+		if err == nil {
+			response = cResponse
+			break
+		} else {
+			log.Infof("upstream dns failure: %v", err)
+		}
+	}
+	if response == nil {
+		response = new(dns.Msg)
+		response.SetReply(req)
+		response.Rcode = dns.RcodeServerFailure
+	}
+	return response
+}
diff --git a/pilot/pkg/model/network_test.go b/pilot/pkg/model/network_test.go
new file mode 100644
index 0000000000..ce3eef0a4d
--- /dev/null
+++ b/pilot/pkg/model/network_test.go
@@ -0,0 +1,144 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model_test
+
+import (
+	"fmt"
+	"net"
+	"reflect"
+	"sync"
+	"testing"
+	"time"
+
+	"github.com/miekg/dns"
+
+	meshconfig "istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/mock"
+	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pilot/pkg/xds"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/test/scopes"
+)
+
+func TestGatewayHostnames(t *testing.T) {
+	origMinGatewayTTL := model.MinGatewayTTL
+	model.MinGatewayTTL = 3 * time.Second
+	t.Cleanup(func() {
+		model.MinGatewayTTL = origMinGatewayTTL
+	})
+
+	gwHost := "test.gw.istio.io"
+	dnsServer := newFakeDNSServer(1, sets.NewSet(gwHost))
+	model.NetworkGatewayTestDNSServers = []string{"localhost:53"}
+	t.Cleanup(func() {
+		if err := dnsServer.Shutdown(); err != nil {
+			t.Logf("failed shutting down fake dns server")
+		}
+	})
+
+	meshNetworks := mesh.NewFixedNetworksWatcher(nil)
+	xdsUpdater := &xds.FakeXdsUpdater{Events: make(chan xds.FakeXdsEvent, 10)}
+	env := &model.Environment{NetworksWatcher: meshNetworks, ServiceDiscovery: &mock.ServiceDiscovery{}}
+	if err := env.InitNetworksManager(xdsUpdater); err != nil {
+		t.Fatal(err)
+	}
+
+	t.Run("initial resolution", func(t *testing.T) {
+		meshNetworks.SetNetworks(&meshconfig.MeshNetworks{Networks: map[string]*meshconfig.Network{
+			"nw0": {Gateways: []*meshconfig.Network_IstioNetworkGateway{{
+				Gw: &meshconfig.Network_IstioNetworkGateway_Address{
+					Address: gwHost,
+				},
+				Port: 15443,
+			}}},
+		}})
+		xdsUpdater.WaitDurationOrFail(t, model.MinGatewayTTL+5*time.Second, "xds")
+		gws := env.NetworkManager.AllGateways()
+		if !reflect.DeepEqual(gws, []model.NetworkGateway{{Network: "nw0", Addr: "10.0.0.0", Port: 15443}}) {
+			t.Fatalf("did not get expected gws: %v", gws)
+		}
+	})
+	t.Run("re-resolve after TTL", func(t *testing.T) {
+		if testing.Short() {
+			t.Skip()
+		}
+		// wait for TTL + 5 to get an XDS update
+		xdsUpdater.WaitDurationOrFail(t, model.MinGatewayTTL+5*time.Second, "xds")
+		// after the update, we should see the next gateway (10.0.0.1)
+		gws := env.NetworkManager.AllGateways()
+		if !reflect.DeepEqual(gws, []model.NetworkGateway{{Network: "nw0", Addr: "10.0.0.1", Port: 15443}}) {
+			t.Fatalf("did not get expected gws: %v", gws)
+		}
+	})
+	t.Run("forget", func(t *testing.T) {
+		meshNetworks.SetNetworks(nil)
+		xdsUpdater.WaitDurationOrFail(t, 5*time.Second, "xds")
+		if len(env.NetworkManager.AllGateways()) > 0 {
+			t.Fatalf("expected no gateways")
+		}
+	})
+}
+
+type fakeDNSServer struct {
+	*dns.Server
+	ttl uint32
+
+	mu sync.Mutex
+	// map fqdn hostname -> query count
+	hosts map[string]int
+}
+
+func newFakeDNSServer(ttl uint32, hosts sets.Set) *fakeDNSServer {
+	s := &fakeDNSServer{
+		Server: &dns.Server{Addr: ":53", Net: "udp"},
+		ttl:    ttl,
+		hosts:  make(map[string]int, len(hosts)),
+	}
+	s.Handler = s
+
+	for k := range hosts {
+		s.hosts[dns.Fqdn(k)] = 0
+	}
+
+	go func() {
+		if err := s.ListenAndServe(); err != nil {
+			scopes.Framework.Errorf("fake dns server error: %v", err)
+		}
+	}()
+	return s
+}
+
+func (s *fakeDNSServer) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+
+	msg := (&dns.Msg{}).SetReply(r)
+	switch r.Question[0].Qtype {
+	case dns.TypeA, dns.TypeANY:
+		domain := msg.Question[0].Name
+		c, ok := s.hosts[domain]
+		if ok {
+			s.hosts[domain]++
+			msg.Answer = append(msg.Answer, &dns.A{
+				Hdr: dns.RR_Header{Name: domain, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: s.ttl},
+				A:   net.ParseIP(fmt.Sprintf("10.0.0.%d", c)),
+			})
+		}
+	}
+	if err := w.WriteMsg(msg); err != nil {
+		scopes.Framework.Errorf("failed writing fake DNS response: %v", err)
+	}
+}
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 03790937b7..a3e4f97908 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -1097,8 +1097,7 @@ func (ps *PushContext) InitContext(env *Environment, oldPushContext *PushContext
 		}
 	}
 
-	// TODO: only do this when meshnetworks or gateway service changed
-	ps.initNetworkManager(env)
+	ps.networkMgr = env.NetworkManager
 
 	ps.clusterLocalHosts = env.ClusterLocal().GetClusterLocalHosts()
 
@@ -2092,11 +2091,6 @@ func instancesEmpty(m map[int][]*ServiceInstance) bool {
 	return true
 }
 
-// pre computes gateways for each network
-func (ps *PushContext) initNetworkManager(env *Environment) {
-	ps.networkMgr = NewNetworkManager(env)
-}
-
 func (ps *PushContext) NetworkManager() *NetworkManager {
 	return ps.networkMgr
 }
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index d06a226b60..71dcd1b222 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -1969,6 +1969,8 @@ func TestServiceWithExportTo(t *testing.T) {
 type localServiceDiscovery struct {
 	services         []*Service
 	serviceInstances []*ServiceInstance
+
+	NetworkGatewaysHandler
 }
 
 var _ ServiceDiscovery = &localServiceDiscovery{}
diff --git a/pilot/pkg/model/service.go b/pilot/pkg/model/service.go
index f79d52d798..7617b5a1ac 100644
--- a/pilot/pkg/model/service.go
+++ b/pilot/pkg/model/service.go
@@ -564,6 +564,8 @@ func (s *ServiceAttributes) DeepCopy() ServiceAttributes {
 // ServiceDiscovery enumerates Istio service instances.
 // nolint: lll
 type ServiceDiscovery interface {
+	NetworkGatewaysWatcher
+
 	// Services list declarations of all services in the system
 	Services() ([]*Service, error)
 
@@ -620,10 +622,6 @@ type ServiceDiscovery interface {
 	// Deprecated - service account tracking moved to XdsServer, incremental.
 	GetIstioServiceAccounts(svc *Service, ports []int) []string
 
-	// NetworkGateways returns a list of network gateways that can be used to access endpoints
-	// residing in this registry.
-	NetworkGateways() []NetworkGateway
-
 	// MCSServices returns information about the services that have been exported/imported via the
 	// Kubernetes Multi-Cluster Services (MCS) ServiceExport API. Only applies to services in
 	// Kubernetes clusters.
diff --git a/pilot/pkg/networking/core/v1alpha3/fake.go b/pilot/pkg/networking/core/v1alpha3/fake.go
index 6f4c19a4fd..c45fc638f5 100644
--- a/pilot/pkg/networking/core/v1alpha3/fake.go
+++ b/pilot/pkg/networking/core/v1alpha3/fake.go
@@ -169,6 +169,9 @@ func NewConfigGenTest(t test.Failer, opts TestOptions) *ConfigGenTest {
 	}
 	if !opts.SkipRun {
 		fake.Run()
+		if err := env.InitNetworksManager(&FakeXdsUpdater{}); err != nil {
+			t.Fatal(err)
+		}
 		env.PushContext = model.NewPushContext()
 		if err := env.PushContext.InitContext(env, nil, nil); err != nil {
 			t.Fatalf("Failed to initialize push context: %v", err)
diff --git a/pilot/pkg/serviceregistry/aggregate/controller.go b/pilot/pkg/serviceregistry/aggregate/controller.go
index c5be6f07f2..52e9bdd34b 100644
--- a/pilot/pkg/serviceregistry/aggregate/controller.go
+++ b/pilot/pkg/serviceregistry/aggregate/controller.go
@@ -50,6 +50,7 @@ type Controller struct {
 	running bool
 
 	handlers model.ControllerHandlers
+	model.NetworkGatewaysHandler
 }
 
 type registryEntry struct {
@@ -75,6 +76,7 @@ func (c *Controller) addRegistry(registry serviceregistry.Instance, stop <-chan
 	c.registries = append(c.registries, &registryEntry{Instance: registry, stop: stop})
 
 	// Observe the registry for events.
+	registry.AppendNetworkGatewayHandler(c.NotifyGatewayHandlers)
 	registry.AppendServiceHandler(c.handlers.NotifyServiceHandlers)
 	registry.AppendWorkloadHandler(c.handlers.NotifyWorkloadHandlers)
 }
diff --git a/pilot/pkg/serviceregistry/aggregate/controller_test.go b/pilot/pkg/serviceregistry/aggregate/controller_test.go
index 4bcdbdd6f8..2cbaa98872 100644
--- a/pilot/pkg/serviceregistry/aggregate/controller_test.go
+++ b/pilot/pkg/serviceregistry/aggregate/controller_test.go
@@ -391,14 +391,16 @@ func TestGetIstioServiceAccounts(t *testing.T) {
 func TestAddRegistry(t *testing.T) {
 	registries := []serviceregistry.Simple{
 		{
-			ProviderID: "registry1",
-			ClusterID:  "cluster1",
-			Controller: &mock.Controller{},
+			ProviderID:       "registry1",
+			ClusterID:        "cluster1",
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 		{
-			ProviderID: "registry2",
-			ClusterID:  "cluster2",
-			Controller: &mock.Controller{},
+			ProviderID:       "registry2",
+			ClusterID:        "cluster2",
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 	}
 	ctrl := NewController(Options{})
@@ -413,19 +415,22 @@ func TestAddRegistry(t *testing.T) {
 func TestGetDeleteRegistry(t *testing.T) {
 	registries := []serviceregistry.Simple{
 		{
-			ProviderID: "registry1",
-			ClusterID:  "cluster1",
-			Controller: &mock.Controller{},
+			ProviderID:       "registry1",
+			ClusterID:        "cluster1",
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 		{
-			ProviderID: "registry2",
-			ClusterID:  "cluster2",
-			Controller: &mock.Controller{},
+			ProviderID:       "registry2",
+			ClusterID:        "cluster2",
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 		{
-			ProviderID: "registry3",
-			ClusterID:  "cluster3",
-			Controller: &mock.Controller{},
+			ProviderID:       "registry3",
+			ClusterID:        "cluster3",
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 	}
 	wrapRegistry := func(r serviceregistry.Instance) serviceregistry.Instance {
@@ -457,20 +462,23 @@ func TestGetDeleteRegistry(t *testing.T) {
 
 func TestSkipSearchingRegistryForProxy(t *testing.T) {
 	cluster1 := serviceregistry.Simple{
-		ClusterID:  "cluster-1",
-		ProviderID: provider.Kubernetes,
-		Controller: &mock.Controller{},
+		ClusterID:        "cluster-1",
+		ProviderID:       provider.Kubernetes,
+		Controller:       &mock.Controller{},
+		ServiceDiscovery: &mock.ServiceDiscovery{},
 	}
 	cluster2 := serviceregistry.Simple{
-		ClusterID:  "cluster-2",
-		ProviderID: provider.Kubernetes,
-		Controller: &mock.Controller{},
+		ClusterID:        "cluster-2",
+		ProviderID:       provider.Kubernetes,
+		Controller:       &mock.Controller{},
+		ServiceDiscovery: &mock.ServiceDiscovery{},
 	}
 	// external registries may eventually be associated with a cluster
 	external := serviceregistry.Simple{
-		ClusterID:  "cluster-1",
-		ProviderID: provider.External,
-		Controller: &mock.Controller{},
+		ClusterID:        "cluster-1",
+		ProviderID:       provider.External,
+		Controller:       &mock.Controller{},
+		ServiceDiscovery: &mock.ServiceDiscovery{},
 	}
 
 	cases := []struct {
@@ -506,7 +514,8 @@ func runnableRegistry(name string) *RunnableRegistry {
 	return &RunnableRegistry{
 		Instance: serviceregistry.Simple{
 			ClusterID: cluster.ID(name), ProviderID: "test",
-			Controller: &mock.Controller{},
+			Controller:       &mock.Controller{},
+			ServiceDiscovery: &mock.ServiceDiscovery{},
 		},
 		running: atomic.NewBool(false),
 	}
diff --git a/pilot/pkg/serviceregistry/kube/controller/controller.go b/pilot/pkg/serviceregistry/kube/controller/controller.go
index 753b07c2a6..8d6b168c54 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller.go
@@ -22,7 +22,6 @@
 	"time"
 
 	"github.com/hashicorp/go-multierror"
-	"github.com/yl2chen/cidranger"
 	"go.uber.org/atomic"
 	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/api/meta"
@@ -280,18 +279,7 @@ type Controller struct {
 	// Stores a map of workload instance name/namespace to address
 	workloadInstancesIPsByName map[string]string
 
-	// CIDR ranger based on path-compressed prefix trie
-	ranger cidranger.Ranger
-
-	// Network name for to be used when the meshNetworks for registry nor network label on pod is specified
-	network network.ID
-	// Network name for the registry as specified by the MeshNetworks configmap
-	networkForRegistry network.ID
-	// tracks which services on which ports should act as a gateway for networkForRegistry
-	registryServiceNameGateways map[host.Name]uint32
-	// gateways for each network, indexed by the service that runs them so we clean them up later
-	networkGateways map[host.Name]map[network.ID]gatewaySet
-
+	multinetwork
 	// informerInit is set to true once the controller is running successfully. This ensures we do not
 	// return HasSynced=true before we are running
 	informerInit *atomic.Bool
@@ -305,20 +293,20 @@ type Controller struct {
 // Created by bootstrap and multicluster (see multicluster.Controller).
 func NewController(kubeClient kubelib.Client, options Options) *Controller {
 	c := &Controller{
-		opts:                        options,
-		client:                      kubeClient,
-		queue:                       queue.NewQueueWithID(1*time.Second, string(options.ClusterID)),
-		servicesMap:                 make(map[host.Name]*model.Service),
-		nodeSelectorsForServices:    make(map[host.Name]labels.Instance),
-		nodeInfoMap:                 make(map[string]kubernetesNode),
-		externalNameSvcInstanceMap:  make(map[host.Name][]*model.ServiceInstance),
-		workloadInstancesByIP:       make(map[string]*model.WorkloadInstance),
-		workloadInstancesIPsByName:  make(map[string]string),
-		registryServiceNameGateways: make(map[host.Name]uint32),
-		networkGateways:             make(map[host.Name]map[network.ID]gatewaySet),
-		informerInit:                atomic.NewBool(false),
-		beginSync:                   atomic.NewBool(false),
-		initialSync:                 atomic.NewBool(false),
+		opts:                       options,
+		client:                     kubeClient,
+		queue:                      queue.NewQueueWithID(1*time.Second, string(options.ClusterID)),
+		servicesMap:                make(map[host.Name]*model.Service),
+		nodeSelectorsForServices:   make(map[host.Name]labels.Instance),
+		nodeInfoMap:                make(map[string]kubernetesNode),
+		externalNameSvcInstanceMap: make(map[host.Name][]*model.ServiceInstance),
+		workloadInstancesByIP:      make(map[string]*model.WorkloadInstance),
+		workloadInstancesIPsByName: make(map[string]string),
+		informerInit:               atomic.NewBool(false),
+		beginSync:                  atomic.NewBool(false),
+		initialSync:                atomic.NewBool(false),
+
+		multinetwork: initMultinetwork(),
 	}
 
 	if features.EnableMCSHost {
@@ -550,11 +538,13 @@ func (c *Controller) deleteService(svc *model.Service) {
 	delete(c.servicesMap, svc.Hostname)
 	delete(c.nodeSelectorsForServices, svc.Hostname)
 	delete(c.externalNameSvcInstanceMap, svc.Hostname)
-	_, isNetworkGateway := c.networkGateways[svc.Hostname]
-	delete(c.networkGateways, svc.Hostname)
+	_, isNetworkGateway := c.networkGatewaysBySvc[svc.Hostname]
+	delete(c.networkGatewaysBySvc, svc.Hostname)
 	c.Unlock()
 
 	if isNetworkGateway {
+		c.NotifyGatewayHandlers()
+		// TODO trigger push via handler
 		// networks are different, we need to update all eds endpoints
 		c.opts.XDSUpdater.ConfigUpdate(&model.PushRequest{Full: true, Reason: []model.TriggerReason{model.NetworksTrigger}})
 	}
@@ -1228,7 +1218,7 @@ func (c *Controller) onSystemNamespaceEvent(obj interface{}, ev model.Event) err
 	// network changed, rarely happen
 	if oldDefaultNetwork != c.network {
 		// refresh pods/endpoints/services
-		c.onNetworkChanged()
+		c.onDefaultNetworkChange()
 	}
 	return nil
 }
diff --git a/pilot/pkg/serviceregistry/kube/controller/network.go b/pilot/pkg/serviceregistry/kube/controller/network.go
index c29fd058c7..590e6c4824 100644
--- a/pilot/pkg/serviceregistry/kube/controller/network.go
+++ b/pilot/pkg/serviceregistry/kube/controller/network.go
@@ -16,7 +16,6 @@
 
 import (
 	"net"
-	"reflect"
 	"strconv"
 
 	"github.com/yl2chen/cidranger"
@@ -28,6 +27,35 @@
 	"istio.io/istio/pkg/network"
 )
 
+type multinetwork struct {
+	// CIDR ranger based on path-compressed prefix trie
+	ranger cidranger.Ranger
+
+	// Network name for to be used when the meshNetworks fromRegistry nor network label on pod is specified
+	// This is defined by a topology.istio.io/network label on the system namespace.
+	network network.ID
+	// Network name for the registry as specified by the MeshNetworks configmap
+	networkForRegistry network.ID
+	// map of svc fqdn to partially built network gateways; the actual gateways will be built from these into networkGatewaysBySvc
+	// this map just enumerates which networks/ports each Service is a gateway for
+	registryServiceNameGateways map[host.Name][]model.NetworkGateway
+	// gateways for each service
+	networkGatewaysBySvc map[host.Name]model.NetworkGatewaySet
+	// implements NetworkGatewaysWatcher; we need to call c.NotifyGatewayHandlers when our gateways change
+	model.NetworkGatewaysHandler
+}
+
+func initMultinetwork() multinetwork {
+	return multinetwork{
+		// zero values are a workaround structcheck issue: https://github.com/golangci/golangci-lint/issues/826
+		ranger:                      nil,
+		network:                     "",
+		networkForRegistry:          "",
+		registryServiceNameGateways: make(map[host.Name][]model.NetworkGateway),
+		networkGatewaysBySvc:        make(map[host.Name]model.NetworkGatewaySet),
+	}
+}
+
 // namedRangerEntry for holding network's CIDR and name
 type namedRangerEntry struct {
 	name    network.ID
@@ -39,7 +67,8 @@ func (n namedRangerEntry) Network() net.IPNet {
 	return n.network
 }
 
-func (c *Controller) onNetworkChanged() {
+// onDefaultNetworkChange is fired if the default network is changed either via the namespace label or mesh-networks
+func (c *Controller) onDefaultNetworkChange() {
 	// the network for endpoints are computed when we process the events; this will fix the cache
 	// NOTE: this must run before the other network watcher handler that creates a force push
 	if err := c.syncPods(); err != nil {
@@ -55,7 +84,7 @@ func (c *Controller) onNetworkChanged() {
 // recomputes network gateways.
 func (c *Controller) reloadNetworkLookup() {
 	c.reloadMeshNetworks()
-	c.onNetworkChanged()
+	c.onDefaultNetworkChange()
 }
 
 // reloadMeshNetworks will read the mesh networks configuration to setup
@@ -67,7 +96,7 @@ func (c *Controller) reloadMeshNetworks() {
 	ranger := cidranger.NewPCTrieRanger()
 
 	c.networkForRegistry = ""
-	c.registryServiceNameGateways = map[host.Name]uint32{}
+	c.registryServiceNameGateways = make(map[host.Name][]model.NetworkGateway)
 
 	meshNetworks := c.opts.NetworksWatcher.Networks()
 	if meshNetworks == nil || len(meshNetworks.Networks) == 0 {
@@ -75,6 +104,7 @@ func (c *Controller) reloadMeshNetworks() {
 	}
 	for n, v := range meshNetworks.Networks {
 		// track endpoints items from this registry are a part of this network
+		fromRegistry := false
 		for _, ep := range v.Endpoints {
 			if ep.GetFromCidr() != "" {
 				_, nw, err := net.ParseCIDR(ep.GetFromCidr())
@@ -89,20 +119,29 @@ func (c *Controller) reloadMeshNetworks() {
 				_ = ranger.Insert(rangerEntry)
 			}
 			if ep.GetFromRegistry() != "" && cluster.ID(ep.GetFromRegistry()) == c.Cluster() {
-				if c.networkForRegistry != "" {
-					log.Warnf("multiple networks specify %s in fromRegistry, only first network %s will use %s",
-						c.Cluster(), c.networkForRegistry, c.Cluster())
-				} else {
-					c.networkForRegistry = network.ID(n)
-				}
+				fromRegistry = true
 			}
 		}
 
-		// track which services from this registry act as gateways for what networks
-		if c.networkForRegistry == network.ID(n) {
+		// fromRegistry field specified this cluster
+		if fromRegistry {
+			// treat endpoints in this cluster as part of this network
+			if c.networkForRegistry != "" {
+				log.Warnf("multiple networks specify %s in fromRegistry; endpoints from %s will continue to be treated as part of %s",
+					c.Cluster(), c.Cluster(), c.networkForRegistry)
+			} else {
+				c.networkForRegistry = network.ID(n)
+			}
+
+			// services in this registry matching the registryServiceName and port are part of this network
 			for _, gw := range v.Gateways {
 				if gwSvcName := gw.GetRegistryServiceName(); gwSvcName != "" {
-					c.registryServiceNameGateways[host.Name(gwSvcName)] = gw.Port
+					svc := host.Name(gwSvcName)
+					c.registryServiceNameGateways[svc] = append(c.registryServiceNameGateways[svc], model.NetworkGateway{
+						Network: network.ID(n),
+						Cluster: c.Cluster(),
+						Port:    gw.GetPort(),
+					})
 				}
 			}
 		}
@@ -115,33 +154,34 @@ func (c *Controller) NetworkGateways() []model.NetworkGateway {
 	c.RLock()
 	defer c.RUnlock()
 
-	if c.networkGateways == nil || len(c.networkGateways) == 0 {
+	if c.networkGatewaysBySvc == nil || len(c.networkGatewaysBySvc) == 0 {
 		return nil
 	}
 
 	// Merge all the gateways into a single set to eliminate duplicates.
-	out := make(gatewaySet)
-	for _, byNetwork := range c.networkGateways {
-		for _, gateways := range byNetwork {
-			out.addAll(gateways)
-		}
+	out := make(model.NetworkGatewaySet)
+	for _, gateways := range c.networkGatewaysBySvc {
+		out.AddAll(gateways)
 	}
 
-	return out.toArray()
+	return out.ToArray()
 }
 
 // extractGatewaysFromService checks if the service is a cross-network gateway
 // and if it is, updates the controller's gateways.
 func (c *Controller) extractGatewaysFromService(svc *model.Service) bool {
 	c.Lock()
-	defer c.Unlock()
-	return c.extractGatewaysInner(svc)
+	changed := c.extractGatewaysInner(svc)
+	c.Unlock()
+	if changed {
+		c.NotifyGatewayHandlers()
+	}
+	return changed
 }
 
 // reloadNetworkGateways performs extractGatewaysFromService for all services registered with the controller.
 func (c *Controller) reloadNetworkGateways() {
 	c.Lock()
-	defer c.Unlock()
 	gwsChanged := false
 	for _, svc := range c.servicesMap {
 		if c.extractGatewaysInner(svc) {
@@ -149,7 +189,10 @@ func (c *Controller) reloadNetworkGateways() {
 			break
 		}
 	}
+	c.Unlock()
 	if gwsChanged {
+		c.NotifyGatewayHandlers()
+		// TODO ConfigUpdate via gateway handler
 		c.opts.XDSUpdater.ConfigUpdate(&model.PushRequest{Full: true, Reason: []model.TriggerReason{model.NetworksTrigger}})
 	}
 }
@@ -157,75 +200,68 @@ func (c *Controller) reloadNetworkGateways() {
 // extractGatewaysInner performs the logic for extractGatewaysFromService without locking the controller.
 // Returns true if any gateways changed.
 func (c *Controller) extractGatewaysInner(svc *model.Service) bool {
-	gwPort, nw := c.getGatewayDetails(svc)
-	if gwPort == 0 || nw == "" {
-		// TODO detect if this previously had the gateway label so we can cleanup the old value
-		// not a gateway
-		return false
-	}
+	newGateways := make(model.NetworkGatewaySet)
 
-	if c.networkGateways[svc.Hostname] == nil {
-		c.networkGateways[svc.Hostname] = make(map[network.ID]gatewaySet)
-	}
-	// Create the entry for this network, if doesn't exist.
-	if c.networkGateways[svc.Hostname][nw] == nil {
-		c.networkGateways[svc.Hostname][nw] = make(gatewaySet)
+	// check if we have node port mappings
+	nodePortMap := make(map[uint32]uint32)
+	if svc.Attributes.ClusterExternalPorts != nil {
+		if npm, exists := svc.Attributes.ClusterExternalPorts[c.Cluster()]; exists {
+			nodePortMap = npm
+		}
 	}
 
-	newGateways := make(gatewaySet)
-
-	// TODO(landow) ClusterExternalAddresses doesn't need to get used outside of the kube controller, and spreads
-	// TODO(cont)   logic between ConvertService, extractGatewaysInner, and updateServiceNodePortAddresses.
-	if !svc.Attributes.ClusterExternalAddresses.IsEmpty() {
-		// check if we have node port mappings
-		if svc.Attributes.ClusterExternalPorts != nil {
-			if nodePortMap, exists := svc.Attributes.ClusterExternalPorts[c.Cluster()]; exists {
-				// what we now have is a service port. If there is a mapping for cluster external ports,
-				// look it up and get the node port for the remote port
-				if nodePort, exists := nodePortMap[gwPort]; exists {
-					gwPort = nodePort
-				}
+	gateways := c.getGatewayDetails(svc)
+
+	for _, addr := range svc.Attributes.ClusterExternalAddresses.GetAddressesFor(c.Cluster()) {
+		for _, gw := range gateways {
+			// what we now have is a service port. If there is a mapping for cluster external ports,
+			// look it up and get the node port for the remote port
+			if nodePort, exists := nodePortMap[gw.Port]; exists {
+				gw.Port = nodePort
 			}
-		}
-		ips := svc.Attributes.ClusterExternalAddresses.GetAddressesFor(c.Cluster())
-		for _, ip := range ips {
-			newGateways.add(model.NetworkGateway{
-				Cluster: c.Cluster(),
-				Network: nw,
-				Addr:    ip,
-				Port:    gwPort,
-			})
+
+			gw.Cluster = c.Cluster()
+			gw.Addr = addr
+			newGateways.Add(gw)
 		}
 	}
 
-	previousGateways := c.networkGateways[svc.Hostname][nw]
-	gatewaysChanged := !newGateways.equals(previousGateways)
-	c.networkGateways[svc.Hostname][nw] = newGateways
+	previousGateways := c.networkGatewaysBySvc[svc.Hostname]
+	gatewaysChanged := !newGateways.Equals(previousGateways)
+
+	if len(newGateways) > 0 {
+		c.networkGatewaysBySvc[svc.Hostname] = newGateways
+	} else {
+		delete(c.networkGatewaysBySvc, svc.Hostname)
+	}
 
 	return gatewaysChanged
 }
 
-// getGatewayDetails finds the port and network to use for cross-network traffic on the given service.
-// Zero values are returned if the service is not a cross-network gateway.
-func (c *Controller) getGatewayDetails(svc *model.Service) (uint32, network.ID) {
+// getGatewayDetails returns gateways without the address populated, only the network and (unmapped) port for a given service.
+func (c *Controller) getGatewayDetails(svc *model.Service) []model.NetworkGateway {
+	// TODO should we start checking if svc's Ports contain the gateway port?
+
 	// label based gateways
+	// TODO label based gateways could support being the gateway for multiple networks
 	if nw := svc.Attributes.Labels[label.TopologyNetwork.Name]; nw != "" {
 		if gwPortStr := svc.Attributes.Labels[IstioGatewayPortLabel]; gwPortStr != "" {
 			if gwPort, err := strconv.Atoi(gwPortStr); err == nil {
-				return uint32(gwPort), network.ID(nw)
+				return []model.NetworkGateway{{Port: uint32(gwPort), Network: network.ID(nw)}}
 			}
 			log.Warnf("could not parse %q for %s on %s/%s; defaulting to %d",
 				gwPortStr, IstioGatewayPortLabel, svc.Attributes.Namespace, svc.Attributes.Name, DefaultNetworkGatewayPort)
 		}
-		return DefaultNetworkGatewayPort, network.ID(nw)
+		return []model.NetworkGateway{{Port: DefaultNetworkGatewayPort, Network: network.ID(nw)}}
 	}
 
 	// meshNetworks registryServiceName+fromRegistry
-	if port, ok := c.registryServiceNameGateways[svc.Hostname]; ok {
-		return port, c.networkForRegistry
+	if gws, ok := c.registryServiceNameGateways[svc.Hostname]; ok {
+		out := append(make([]model.NetworkGateway, 0, len(gws)), gws...)
+		return out
 	}
 
-	return 0, ""
+	return nil
 }
 
 // updateServiceNodePortAddresses updates ClusterExternalAddresses for Services of nodePort type
@@ -270,34 +306,3 @@ func (c *Controller) getNodePortGatewayServices() []*model.Service {
 
 	return out
 }
-
-// gatewaySet is a helper to manage a set of NetworkGateway instances.
-type gatewaySet map[model.NetworkGateway]struct{}
-
-func (s gatewaySet) equals(other gatewaySet) bool {
-	if len(s) != len(other) {
-		return false
-	}
-	return reflect.DeepEqual(s, other)
-}
-
-func (s gatewaySet) add(gw model.NetworkGateway) {
-	s[gw] = struct{}{}
-}
-
-func (s gatewaySet) addAll(other gatewaySet) {
-	for gw := range other {
-		s.add(gw)
-	}
-}
-
-func (s gatewaySet) toArray() []model.NetworkGateway {
-	gws := make([]model.NetworkGateway, 0, len(s))
-	for gw := range s {
-		gws = append(gws, gw)
-	}
-
-	// Sort the array so that it's stable.
-	gws = model.SortGateways(gws)
-	return gws
-}
diff --git a/pilot/pkg/serviceregistry/kube/controller/network_test.go b/pilot/pkg/serviceregistry/kube/controller/network_test.go
new file mode 100644
index 0000000000..1da3389ff5
--- /dev/null
+++ b/pilot/pkg/serviceregistry/kube/controller/network_test.go
@@ -0,0 +1,179 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package controller
+
+import (
+	"context"
+	"fmt"
+	"sync"
+	"testing"
+	"time"
+
+	"go.uber.org/atomic"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	"istio.io/api/label"
+	meshconfig "istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/test/util/retry"
+)
+
+func TestNetworkUpdateTriggers(t *testing.T) {
+	meshNetworks := mesh.NewFixedNetworksWatcher(nil)
+	c, _ := NewFakeControllerWithOptions(FakeControllerOptions{ClusterID: "Kubernetes", NetworksWatcher: meshNetworks, DomainSuffix: "cluster.local"})
+	defer close(c.stop)
+	go func() {
+		c.Run(c.stop)
+	}()
+
+	if len(c.NetworkGateways()) != 0 {
+		t.Fatal("did not expect any gateways yet")
+	}
+
+	notified := atomic.NewBool(false)
+	var (
+		gwMu sync.Mutex
+		gws  []model.NetworkGateway
+	)
+	setGws := func(v []model.NetworkGateway) {
+		gwMu.Lock()
+		defer gwMu.Unlock()
+		gws = v
+	}
+	getGws := func() []model.NetworkGateway {
+		gwMu.Lock()
+		defer gwMu.Unlock()
+		return gws
+	}
+
+	c.AppendNetworkGatewayHandler(func() {
+		notified.Store(true)
+		setGws(c.NetworkGateways())
+	})
+	expectGateways := func(t *testing.T, expectedGws int) {
+		defer notified.Store(false)
+		// 1. wait for a notification
+		retry.UntilSuccessOrFail(t, func() error {
+			if !notified.Load() {
+				return fmt.Errorf("no gateway notify")
+			}
+			if n := len(getGws()); n != expectedGws {
+				return fmt.Errorf("expected %d gateways but got %d", expectedGws, n)
+			}
+			return nil
+		}, retry.Timeout(5*time.Second), retry.Delay(500*time.Millisecond))
+	}
+
+	t.Run("add meshnetworks", func(t *testing.T) {
+		addMeshNetworksFromRegistryGateway(t, c, meshNetworks)
+		expectGateways(t, 2)
+	})
+	fmt.Println(c.NetworkGateways())
+	t.Run("add labeled service", func(t *testing.T) {
+		addLabeledServiceGateway(t, c, "nw0")
+		expectGateways(t, 3)
+	})
+	t.Run("update labeled service network", func(t *testing.T) {
+		addLabeledServiceGateway(t, c, "nw1")
+		expectGateways(t, 3)
+	})
+	t.Run("remove labeled service", func(t *testing.T) {
+		removeLabeledServiceGateway(t, c)
+		expectGateways(t, 2)
+	})
+	t.Run("remove meshnetworks", func(t *testing.T) {
+		meshNetworks.SetNetworks(nil)
+		expectGateways(t, 0)
+	})
+}
+
+func addLabeledServiceGateway(t *testing.T, c *FakeController, nw string) {
+	ctx := context.TODO()
+
+	svc := &corev1.Service{
+		ObjectMeta: metav1.ObjectMeta{Name: "istio-labeled-gw", Namespace: "arbitrary-ns", Labels: map[string]string{
+			label.TopologyNetwork.Name: nw,
+		}},
+		Spec: corev1.ServiceSpec{
+			Type:  corev1.ServiceTypeLoadBalancer,
+			Ports: []corev1.ServicePort{{Port: 15443, Protocol: corev1.ProtocolTCP}},
+		},
+		Status: corev1.ServiceStatus{LoadBalancer: corev1.LoadBalancerStatus{Ingress: []corev1.LoadBalancerIngress{{
+			IP:    "2.3.4.6",
+			Ports: []corev1.PortStatus{{Port: 15443, Protocol: corev1.ProtocolTCP}},
+		}}}},
+	}
+
+	if _, err := c.client.CoreV1().Services("arbitrary-ns").Get(ctx, "istio-labeled-gw", metav1.GetOptions{}); err == nil {
+		// update
+		if _, err := c.client.CoreV1().Services("arbitrary-ns").Update(context.TODO(), svc, metav1.UpdateOptions{}); err != nil {
+			t.Fatal(err)
+		}
+	} else if errors.IsNotFound(err) {
+		// create
+		if _, err := c.client.CoreV1().Services("arbitrary-ns").Create(context.TODO(), svc, metav1.CreateOptions{}); err != nil {
+			t.Fatal(err)
+		}
+	} else {
+		t.Fatal(err)
+	}
+}
+
+func removeLabeledServiceGateway(t *testing.T, c *FakeController) {
+	err := c.client.CoreV1().Services("arbitrary-ns").Delete(context.TODO(), "istio-labeled-gw", metav1.DeleteOptions{})
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func addMeshNetworksFromRegistryGateway(t *testing.T, c *FakeController, watcher mesh.NetworksWatcher) {
+	_, err := c.client.CoreV1().Services("istio-system").Create(context.TODO(), &corev1.Service{
+		ObjectMeta: metav1.ObjectMeta{Name: "istio-meshnetworks-gw", Namespace: "istio-system"},
+		Spec: corev1.ServiceSpec{
+			Type:  corev1.ServiceTypeLoadBalancer,
+			Ports: []corev1.ServicePort{{Port: 15443, Protocol: corev1.ProtocolTCP}},
+		},
+		Status: corev1.ServiceStatus{LoadBalancer: corev1.LoadBalancerStatus{Ingress: []corev1.LoadBalancerIngress{{
+			IP:    "1.2.3.4",
+			Ports: []corev1.PortStatus{{Port: 15443, Protocol: corev1.ProtocolTCP}},
+		}}}},
+	}, metav1.CreateOptions{})
+	if err != nil {
+		t.Fatal(err)
+	}
+	watcher.SetNetworks(&meshconfig.MeshNetworks{Networks: map[string]*meshconfig.Network{
+		"nw0": {
+			Endpoints: []*meshconfig.Network_NetworkEndpoints{{
+				Ne: &meshconfig.Network_NetworkEndpoints_FromRegistry{FromRegistry: "Kubernetes"},
+			}},
+			Gateways: []*meshconfig.Network_IstioNetworkGateway{{
+				Port: 15443,
+				Gw:   &meshconfig.Network_IstioNetworkGateway_RegistryServiceName{RegistryServiceName: "istio-meshnetworks-gw.istio-system.svc.cluster.local"},
+			}},
+		},
+		"nw1": {
+			Endpoints: []*meshconfig.Network_NetworkEndpoints{{
+				Ne: &meshconfig.Network_NetworkEndpoints_FromRegistry{FromRegistry: "Kubernetes"},
+			}},
+			Gateways: []*meshconfig.Network_IstioNetworkGateway{{
+				Port: 15443,
+				Gw:   &meshconfig.Network_IstioNetworkGateway_RegistryServiceName{RegistryServiceName: "istio-meshnetworks-gw.istio-system.svc.cluster.local"},
+			}},
+		},
+	}})
+}
diff --git a/pilot/pkg/serviceregistry/memory/discovery.go b/pilot/pkg/serviceregistry/memory/discovery.go
index 14195d038e..b1a4115d78 100644
--- a/pilot/pkg/serviceregistry/memory/discovery.go
+++ b/pilot/pkg/serviceregistry/memory/discovery.go
@@ -54,8 +54,11 @@ func (c *ServiceController) HasSynced() bool { return true }
 
 // ServiceDiscovery is a mock discovery interface
 type ServiceDiscovery struct {
-	services        map[host.Name]*model.Service
+	services map[host.Name]*model.Service
+
 	networkGateways []model.NetworkGateway
+	model.NetworkGatewaysHandler
+
 	// EndpointShards table. Key is the fqdn of the service, ':', port
 	instancesByPortNum  map[string][]*model.ServiceInstance
 	instancesByPortName map[string][]*model.ServiceInstance
@@ -322,6 +325,7 @@ func (sd *ServiceDiscovery) GetIstioServiceAccounts(svc *model.Service, _ []int)
 
 func (sd *ServiceDiscovery) AddGateways(gws ...model.NetworkGateway) {
 	sd.networkGateways = append(sd.networkGateways, gws...)
+	sd.NotifyGatewayHandlers()
 }
 
 func (sd *ServiceDiscovery) NetworkGateways() []model.NetworkGateway {
diff --git a/pilot/pkg/serviceregistry/mock/discovery.go b/pilot/pkg/serviceregistry/mock/discovery.go
index 27eb6b3e10..6dff1fde4a 100644
--- a/pilot/pkg/serviceregistry/mock/discovery.go
+++ b/pilot/pkg/serviceregistry/mock/discovery.go
@@ -168,6 +168,8 @@ type ServiceDiscovery struct {
 	WantGetProxyServiceInstances  []*model.ServiceInstance
 	ServicesError                 error
 	GetProxyServiceInstancesError error
+
+	model.NetworkGatewaysHandler
 }
 
 // Services implements discovery interface
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
index a3c3b034d3..3d6443b878 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
@@ -93,6 +93,8 @@ type ServiceEntryStore struct {
 	getNetworkIDCb func(IP string, labels labels.Instance) network.ID
 
 	processServiceEntry bool
+
+	model.NetworkGatewaysHandler
 }
 
 type ServiceDiscoveryOption func(*ServiceEntryStore)
diff --git a/pilot/pkg/xds/debug.go b/pilot/pkg/xds/debug.go
index 0eaeae9c41..23e5fd73ee 100644
--- a/pilot/pkg/xds/debug.go
+++ b/pilot/pkg/xds/debug.go
@@ -858,9 +858,7 @@ func (s *DiscoveryServer) instancesz(w http.ResponseWriter, req *http.Request) {
 }
 
 func (s *DiscoveryServer) networkz(w http.ResponseWriter, _ *http.Request) {
-	// Merge the gateways from the service registries with those configured statically with MeshNetworks.
-	mgr := model.NewNetworkManager(s.Env)
-	writeJSON(w, mgr.AllGateways())
+	writeJSON(w, s.Env.NetworkManager.AllGateways())
 }
 
 func (s *DiscoveryServer) mcsz(w http.ResponseWriter, _ *http.Request) {
diff --git a/pilot/pkg/xds/eds_sh_test.go b/pilot/pkg/xds/eds_sh_test.go
index b7a8112781..07d59e91dc 100644
--- a/pilot/pkg/xds/eds_sh_test.go
+++ b/pilot/pkg/xds/eds_sh_test.go
@@ -61,7 +61,7 @@ func (r expectedResults) getAddrs() []string {
 // the Split Horizon EDS - all local endpoints + endpoint per remote network that also has
 // endpoints for the service.
 func TestSplitHorizonEds(t *testing.T) {
-	s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{})
+	s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{NetworksWatcher: mesh.NewFixedNetworksWatcher(nil)})
 
 	// Set up a cluster registry for network 1 with 1 instance for the service 'service5'
 	// Network has 1 gateway
@@ -80,6 +80,8 @@ func TestSplitHorizonEds(t *testing.T) {
 	s.Discovery.ConfigUpdate(&model.PushRequest{Full: true})
 	time.Sleep(time.Millisecond * 200) // give time for cache to clear
 
+	fmt.Println("gateways", s.Env().NetworkManager.AllGateways())
+
 	tests := []struct {
 		network   string
 		sidecarID string
@@ -270,11 +272,6 @@ func initRegistry(server *xds.FakeDiscoveryServer, networkNum int, gatewaysIP []
 	gws := make([]*meshconfig.Network_IstioNetworkGateway, 0)
 	for _, gatewayIP := range gatewaysIP {
 		if gatewayIP != "" {
-			if server.Env().Networks() == nil {
-				server.Env().NetworksWatcher = mesh.NewFixedNetworksWatcher(&meshconfig.MeshNetworks{
-					Networks: map[string]*meshconfig.Network{},
-				})
-			}
 			gw := &meshconfig.Network_IstioNetworkGateway{
 				Gw: &meshconfig.Network_IstioNetworkGateway_Address{
 					Address: gatewayIP,
@@ -328,14 +325,17 @@ func initRegistry(server *xds.FakeDiscoveryServer, networkNum int, gatewaysIP []
 }
 
 func addNetwork(server *xds.FakeDiscoveryServer, id network.ID, network *meshconfig.Network) {
-	meshNetworks := *server.Env().Networks()
+	meshNetworks := server.Env().Networks()
+	// copy old networks if they exist
 	c := map[string]*meshconfig.Network{}
-	for k, v := range meshNetworks.Networks {
-		c[k] = v
+	if meshNetworks != nil {
+		for k, v := range meshNetworks.Networks {
+			c[k] = v
+		}
 	}
+	// add the new one
 	c[string(id)] = network
-	meshNetworks.Networks = c
-	server.Env().SetNetworks(&meshNetworks)
+	server.Env().SetNetworks(&meshconfig.MeshNetworks{Networks: c})
 }
 
 func getLbEndpointAddrs(eps []*endpoint.LbEndpoint) []string {
diff --git a/pilot/pkg/xds/ep_filters_test.go b/pilot/pkg/xds/ep_filters_test.go
index 60a940730f..bfe20a159d 100644
--- a/pilot/pkg/xds/ep_filters_test.go
+++ b/pilot/pkg/xds/ep_filters_test.go
@@ -182,6 +182,7 @@ func (i LocLbEpInfo) getAddrs() []string {
 func TestEndpointsByNetworkFilter(t *testing.T) {
 	env := environment()
 	env.Init()
+	env.InitNetworksManager(nil)
 	// The tests below are calling the endpoints filter from each one of the
 	// networks and examines the returned filtered endpoints
 
@@ -563,6 +564,7 @@ func TestEndpointsByNetworkFilter_WithConfig(t *testing.T) {
 						}
 					}
 					env.Init()
+					env.InitNetworksManager(nil)
 					runNetworkFilterTest(t, env, pa.Tests)
 				})
 			}
@@ -599,6 +601,7 @@ func TestEndpointsByNetworkFilter_SkipLBWithHostname(t *testing.T) {
 
 	env.ServiceDiscovery = serviceDiscovery
 	env.Init()
+	env.InitNetworksManager(nil)
 	// Run the tests and ensure that the new gateway is never used.
 	runNetworkFilterTest(t, env, networkFiltered)
 }
diff --git a/pilot/pkg/xds/fake.go b/pilot/pkg/xds/fake.go
index e917678faa..dd5dc74cd7 100644
--- a/pilot/pkg/xds/fake.go
+++ b/pilot/pkg/xds/fake.go
@@ -223,6 +223,9 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 	cg.ServiceEntryRegistry.AppendServiceHandler(serviceHandler)
 	s.updateMutex.Lock()
 	s.Env = cg.Env()
+	if err := s.Env.InitNetworksManager(s); err != nil {
+		t.Fatal(err)
+	}
 	// Disable debounce to reduce test times
 	s.debounceOptions.debounceAfter = opts.DebounceTime
 	s.MemRegistry = cg.MemRegistry
@@ -312,6 +315,8 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 	// initialized.
 	s.ConfigUpdate(&model.PushRequest{Full: true})
 
+	processStartTime = time.Now()
+
 	// Wait until initial updates are committed
 	c := s.InboundUpdates.Load()
 	retry.UntilOrFail(t, func() bool {
@@ -535,6 +540,15 @@ func (fx *FakeXdsUpdater) RemoveShard(_ model.ShardKey) {
 	fx.ConfigUpdate(&model.PushRequest{Full: true})
 }
 
+func (fx *FakeXdsUpdater) WaitDurationOrFail(t test.Failer, duration time.Duration, types ...string) *FakeXdsEvent {
+	t.Helper()
+	got := fx.WaitDuration(duration, types...)
+	if got == nil {
+		t.Fatal("missing event")
+	}
+	return got
+}
+
 func (fx *FakeXdsUpdater) WaitOrFail(t test.Failer, types ...string) *FakeXdsEvent {
 	t.Helper()
 	got := fx.Wait(types...)
@@ -544,7 +558,7 @@ func (fx *FakeXdsUpdater) WaitOrFail(t test.Failer, types ...string) *FakeXdsEve
 	return got
 }
 
-func (fx *FakeXdsUpdater) Wait(types ...string) *FakeXdsEvent {
+func (fx *FakeXdsUpdater) WaitDuration(duration time.Duration, types ...string) *FakeXdsEvent {
 	for {
 		select {
 		case e := <-fx.Events:
@@ -554,8 +568,12 @@ func (fx *FakeXdsUpdater) Wait(types ...string) *FakeXdsEvent {
 				}
 			}
 			continue
-		case <-time.After(1 * time.Second):
+		case <-time.After(duration):
 			return nil
 		}
 	}
 }
+
+func (fx *FakeXdsUpdater) Wait(types ...string) *FakeXdsEvent {
+	return fx.WaitDuration(1*time.Second, types...)
+}
diff --git a/pilot/pkg/xds/mesh_network_test.go b/pilot/pkg/xds/mesh_network_test.go
index 7cfdc28d7f..ed9d9401ab 100644
--- a/pilot/pkg/xds/mesh_network_test.go
+++ b/pilot/pkg/xds/mesh_network_test.go
@@ -67,9 +67,11 @@ func TestNetworkGatewayUpdates(t *testing.T) {
 		kubeObjects = append(kubeObjects, objs...)
 		configObjects = append(configObjects, w.configs()...)
 	}
+	meshNetworks := mesh.NewFixedNetworksWatcher(nil)
 	s := NewFakeDiscoveryServer(t, FakeOptions{
 		KubernetesObjects: kubeObjects,
 		Configs:           configObjects,
+		NetworksWatcher:   meshNetworks,
 	})
 	for _, w := range workloads {
 		w.setupProxy(s)
@@ -79,7 +81,7 @@ func TestNetworkGatewayUpdates(t *testing.T) {
 		vm.Expect(pod, "10.10.10.10:8080")
 		vm.Test(t, s)
 	})
-	t.Run("gateway added", func(t *testing.T) {
+	t.Run("gateway added via label", func(t *testing.T) {
 		_, err := s.KubeClient().CoreV1().Services("istio-system").Create(context.TODO(), &corev1.Service{
 			ObjectMeta: metav1.ObjectMeta{
 				Name:      "istio-ingressgateway",
@@ -88,7 +90,10 @@ func TestNetworkGatewayUpdates(t *testing.T) {
 					label.TopologyNetwork.Name: "network-1",
 				},
 			},
-			Spec: corev1.ServiceSpec{Type: corev1.ServiceTypeLoadBalancer},
+			Spec: corev1.ServiceSpec{
+				Type:  corev1.ServiceTypeLoadBalancer,
+				Ports: []corev1.ServicePort{{Port: 15443, Protocol: corev1.ProtocolTCP}},
+			},
 			Status: corev1.ServiceStatus{
 				LoadBalancer: corev1.LoadBalancerStatus{Ingress: []corev1.LoadBalancerIngress{{IP: "3.3.3.3"}}},
 			},
@@ -99,11 +104,49 @@ func TestNetworkGatewayUpdates(t *testing.T) {
 		if err := retry.Until(func() bool {
 			return len(s.PushContext().NetworkManager().GatewaysForNetwork("network-1")) == 1
 		}); err != nil {
-			t.Fatal("push context did not reinitialize with gateways; xds event may not have been triggred")
+			t.Fatal("push context did not reinitialize with gateways; xds event may not have been triggered")
 		}
 		vm.Expect(pod, "3.3.3.3:15443")
 		vm.Test(t, s)
 	})
+
+	t.Run("gateway added via meshconfig", func(t *testing.T) {
+		_, err := s.KubeClient().CoreV1().Services("istio-system").Create(context.TODO(), &corev1.Service{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "istio-meshnetworks-gateway",
+				Namespace: "istio-system",
+			},
+			Spec: corev1.ServiceSpec{Type: corev1.ServiceTypeLoadBalancer},
+			Status: corev1.ServiceStatus{
+				LoadBalancer: corev1.LoadBalancerStatus{Ingress: []corev1.LoadBalancerIngress{{IP: "4.4.4.4"}}},
+			},
+		}, metav1.CreateOptions{})
+		meshNetworks.SetNetworks(&meshconfig.MeshNetworks{Networks: map[string]*meshconfig.Network{
+			"network-1": {
+				Endpoints: []*meshconfig.Network_NetworkEndpoints{
+					{
+						Ne: &meshconfig.Network_NetworkEndpoints_FromRegistry{FromRegistry: "Kubernetes"},
+					},
+				},
+				Gateways: []*meshconfig.Network_IstioNetworkGateway{{
+					Gw: &meshconfig.Network_IstioNetworkGateway_RegistryServiceName{
+						RegistryServiceName: "istio-meshnetworks-gateway.istio-system.svc.cluster.local",
+					},
+					Port: 15443,
+				}},
+			},
+		}})
+		if err != nil {
+			t.Fatal(err)
+		}
+		if err := retry.Until(func() bool {
+			return len(s.PushContext().NetworkManager().GatewaysForNetwork("network-1")) == 2
+		}); err != nil {
+			t.Fatal("push context did not reinitialize with gateways; xds event may not have been triggered")
+		}
+		vm.Expect(pod, "3.3.3.3:15443", "4.4.4.4:15443")
+		vm.Test(t, s)
+	})
 }
 
 func TestMeshNetworking(t *testing.T) {
@@ -403,7 +446,9 @@ func (w *workload) Test(t *testing.T, s *FakeDiscoveryServer) {
 			eps := xdstest.ExtractLoadAssignments(s.Endpoints(w.proxy))
 			for c, ips := range w.expectations {
 				if !listEqualUnordered(eps[c], ips) {
-					return fmt.Errorf("cluster %s, expected ips %v ,but got %v", c, ips, eps[c])
+					err := fmt.Errorf("cluster %s, expected ips %v ,but got %v", c, ips, eps[c])
+					fmt.Println(err)
+					return err
 				}
 			}
 			return nil
diff --git a/pkg/config/mesh/mesh.go b/pkg/config/mesh/mesh.go
index e2f9592e5d..f995dcbd9f 100644
--- a/pkg/config/mesh/mesh.go
+++ b/pkg/config/mesh/mesh.go
@@ -16,7 +16,6 @@
 
 import (
 	"fmt"
-	"net"
 	"os"
 	"time"
 
@@ -31,7 +30,6 @@
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/validation"
 	"istio.io/istio/pkg/util/gogoprotomarshal"
-	"istio.io/pkg/log"
 )
 
 // DefaultProxyConfig for individual proxies
@@ -326,28 +324,3 @@ func ReadMeshConfigData(filename string) (string, error) {
 	}
 	return string(yaml), nil
 }
-
-// ResolveHostsInNetworksConfig will go through the Gateways addresses for all
-// networks in the config and if it's not an IP address it will try to lookup
-// that hostname and replace it with the IP address in the config
-func ResolveHostsInNetworksConfig(config *meshconfig.MeshNetworks) {
-	if config == nil {
-		return
-	}
-	for _, n := range config.Networks {
-		for _, gw := range n.Gateways {
-			gwAddr := gw.GetAddress()
-			gwIP := net.ParseIP(gwAddr)
-			if gwIP == nil && len(gwAddr) != 0 {
-				addrs, err := net.LookupHost(gwAddr)
-				if err != nil {
-					log.Warnf("error resolving host %#v: %v", gw.GetAddress(), err)
-				} else {
-					gw.Gw = &meshconfig.Network_IstioNetworkGateway_Address{
-						Address: addrs[0],
-					}
-				}
-			}
-		}
-	}
-}
diff --git a/pkg/config/mesh/mesh_test.go b/pkg/config/mesh/mesh_test.go
index a113fdf36c..2326f2577c 100644
--- a/pkg/config/mesh/mesh_test.go
+++ b/pkg/config/mesh/mesh_test.go
@@ -401,52 +401,3 @@ func TestApplyMeshNetworksDefaults(t *testing.T) {
 	}
 	assert.Equal(t, got, &want)
 }
-
-func TestResolveHostsInNetworksConfig(t *testing.T) {
-	tests := []struct {
-		name     string
-		address  string
-		modified bool
-	}{
-		{
-			"Gateway with IP address",
-			"9.142.3.1",
-			false,
-		},
-		{
-			"Gateway with localhost address",
-			"localhost",
-			true,
-		},
-		{
-			"Gateway with empty address",
-			"",
-			false,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			config := &meshconfig.MeshNetworks{
-				Networks: map[string]*meshconfig.Network{
-					"network": {
-						Gateways: []*meshconfig.Network_IstioNetworkGateway{
-							{
-								Gw: &meshconfig.Network_IstioNetworkGateway_Address{
-									Address: tt.address,
-								},
-							},
-						},
-					},
-				},
-			}
-			mesh.ResolveHostsInNetworksConfig(config)
-			addrAfter := config.Networks["network"].Gateways[0].GetAddress()
-			if addrAfter == tt.address && tt.modified {
-				t.Fatalf("Expected network address to be modified but it's the same as before calling the function")
-			}
-			if addrAfter != tt.address && !tt.modified {
-				t.Fatalf("Expected network address not to be modified after calling the function")
-			}
-		})
-	}
-}
diff --git a/pkg/config/mesh/networks_watcher.go b/pkg/config/mesh/networks_watcher.go
index 92f06c968a..8aebf631e6 100644
--- a/pkg/config/mesh/networks_watcher.go
+++ b/pkg/config/mesh/networks_watcher.go
@@ -63,7 +63,6 @@ func NewNetworksWatcher(fileWatcher filewatcher.FileWatcher, filename string) (N
 		return nil, fmt.Errorf("failed to read mesh networks configuration from %q: %v", filename, err)
 	}
 
-	ResolveHostsInNetworksConfig(meshNetworks)
 	networksdump, _ := gogoprotomarshal.ToJSONWithIndent(meshNetworks, "   ")
 	log.Infof("mesh networks configuration: %s", networksdump)
 
@@ -86,6 +85,9 @@ func NewNetworksWatcher(fileWatcher filewatcher.FileWatcher, filename string) (N
 
 // Networks returns the latest network configuration for the mesh.
 func (w *InternalNetworkWatcher) Networks() *meshconfig.MeshNetworks {
+	if w == nil {
+		return nil
+	}
 	return (*meshconfig.MeshNetworks)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&w.networks))))
 }
 
@@ -95,7 +97,6 @@ func (w *InternalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetwor
 
 	w.mutex.Lock()
 	if !reflect.DeepEqual(meshNetworks, w.networks) {
-		ResolveHostsInNetworksConfig(meshNetworks)
 		networksdump, _ := gogoprotomarshal.ToJSONWithIndent(meshNetworks, "    ")
 		log.Infof("mesh networks configuration updated to: %s", networksdump)
 
diff --git a/pkg/config/validation/validation.go b/pkg/config/validation/validation.go
index e6c0397b2c..06d754bdd2 100644
--- a/pkg/config/validation/validation.go
+++ b/pkg/config/validation/validation.go
@@ -3331,6 +3331,7 @@ func getLocalityParam(locality string) (string, string, string, int, error) {
 
 // ValidateMeshNetworks validates meshnetworks.
 func ValidateMeshNetworks(meshnetworks *meshconfig.MeshNetworks) (errs error) {
+	// TODO validate using the same gateway on multiple networks?
 	for name, network := range meshnetworks.Networks {
 		if err := validateNetwork(network); err != nil {
 			errs = multierror.Append(errs, multierror.Prefix(err, fmt.Sprintf("invalid network %v:", name)))
@@ -3359,8 +3360,13 @@ func validateNetwork(network *meshconfig.Network) (errs error) {
 				errs = multierror.Append(errs, err)
 			}
 		case *meshconfig.Network_IstioNetworkGateway_Address:
-			if err := ValidateIPAddress(g.Address); err != nil {
-				errs = multierror.Append(errs, err)
+			if ipErr := ValidateIPAddress(g.Address); ipErr != nil {
+				if !features.ResolveHostnameGateways {
+					err := fmt.Errorf("%v (hostname is allowed if RESOLVE_HOSTNAME_GATEWAYS is enabled)", ipErr)
+					errs = multierror.Append(errs, err)
+				} else if fqdnErr := ValidateFQDN(g.Address); fqdnErr != nil {
+					errs = multierror.Append(fmt.Errorf("%v is not a valid IP address or DNS name", g.Address))
+				}
 			}
 		}
 		if err := ValidatePort(int(n.Port)); err != nil {
diff --git a/pkg/config/validation/validation_test.go b/pkg/config/validation/validation_test.go
index 52fc1262cc..f1c53fc541 100644
--- a/pkg/config/validation/validation_test.go
+++ b/pkg/config/validation/validation_test.go
@@ -6556,6 +6556,31 @@ func TestValidateMeshNetworks(t *testing.T) {
 			},
 			valid: true,
 		},
+		{
+			name: "Invalid Gateway Address",
+			mn: &meshconfig.MeshNetworks{
+				Networks: map[string]*meshconfig.Network{
+					"n1": {
+						Endpoints: []*meshconfig.Network_NetworkEndpoints{
+							{
+								Ne: &meshconfig.Network_NetworkEndpoints_FromRegistry{
+									FromRegistry: "Kubernetes",
+								},
+							},
+						},
+						Gateways: []*meshconfig.Network_IstioNetworkGateway{
+							{
+								Gw: &meshconfig.Network_IstioNetworkGateway_Address{
+									Address: "1nv@lidhostname",
+								},
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			valid: false,
+		},
 		{
 			name: "Invalid registry name",
 			mn: &meshconfig.MeshNetworks{
diff --git a/releasenotes/notes/36422.yaml b/releasenotes/notes/36422.yaml
new file mode 100644
index 0000000000..2a2aef951c
--- /dev/null
+++ b/releasenotes/notes/36422.yaml
@@ -0,0 +1,11 @@
+apiVersion: release-notes/v2
+kind: feature
+area: traffic-management
+issue:
+- 29359
+
+releaseNotes:
+- |
+  **Added** support for hostname-based multi-network gateways for east-west traffic. The hostname will be resolved in
+  the control plane and each of the IPs will be used as an endpoint. This behaviour can be disabled by setting
+  `RESOLVE_HOSTNAME_GATEWAYS=false` for istiod.
\ No newline at end of file
-- 
2.35.3

