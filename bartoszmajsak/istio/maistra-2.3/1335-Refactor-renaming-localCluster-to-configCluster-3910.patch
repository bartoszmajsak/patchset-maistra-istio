From ca050d08dd47b8c68be5f083ef1c7f56eee77931 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Sat, 28 May 2022 01:11:31 +0800
Subject: Refactor: renaming localCluster to configCluster (#39103)

* rename localCluster to primaryCluster

* rename primaryCluster to configCluster
---
 pilot/pkg/credentials/kube/multicluster.go | 16 ++++-----
 pkg/kube/multicluster/secretcontroller.go  | 38 +++++++++++-----------
 2 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/pilot/pkg/credentials/kube/multicluster.go b/pilot/pkg/credentials/kube/multicluster.go
index 9dfb46e5ef..b024c8eaa1 100644
--- a/pilot/pkg/credentials/kube/multicluster.go
+++ b/pilot/pkg/credentials/kube/multicluster.go
@@ -30,16 +30,16 @@
 type Multicluster struct {
 	remoteKubeControllers map[cluster.ID]*CredentialsController
 	m                     sync.Mutex // protects remoteKubeControllers
-	localCluster          cluster.ID
+	configCluster         cluster.ID
 	secretHandlers        []secretHandler
 }
 
 var _ credentials.MulticlusterController = &Multicluster{}
 
-func NewMulticluster(localCluster cluster.ID) *Multicluster {
+func NewMulticluster(configCluster cluster.ID) *Multicluster {
 	m := &Multicluster{
 		remoteKubeControllers: map[cluster.ID]*CredentialsController{},
-		localCluster:          localCluster,
+		configCluster:         configCluster,
 	}
 
 	return m
@@ -81,13 +81,13 @@ func (m *Multicluster) ForCluster(clusterID cluster.ID) (credentials.Controller,
 	agg := &AggregateController{}
 	agg.controllers = []*CredentialsController{}
 	agg.authController = m.remoteKubeControllers[clusterID]
-	if clusterID != m.localCluster {
-		// If the request cluster is not the local cluster, we will append it and use it for auth
-		// This means we will prioritize the proxy cluster, then the local cluster for credential lookup
+	if clusterID != m.configCluster {
+		// If the request cluster is not the config cluster, we will append it and use it for auth
+		// This means we will prioritize the proxy cluster, then the config cluster for credential lookup
 		// Authorization will always use the proxy cluster.
 		agg.controllers = append(agg.controllers, m.remoteKubeControllers[clusterID])
 	}
-	agg.controllers = append(agg.controllers, m.remoteKubeControllers[m.localCluster])
+	agg.controllers = append(agg.controllers, m.remoteKubeControllers[m.configCluster])
 	return agg, nil
 }
 
@@ -99,7 +99,7 @@ func (m *Multicluster) AddSecretHandler(h secretHandler) {
 }
 
 type AggregateController struct {
-	// controllers to use to look up certs. Generally this will consistent of the local (config) cluster
+	// controllers to use to look up certs. Generally this will consistent of the primary (config) cluster
 	// and a single remote cluster where the proxy resides
 	controllers    []*CredentialsController
 	authController *CredentialsController
diff --git a/pkg/kube/multicluster/secretcontroller.go b/pkg/kube/multicluster/secretcontroller.go
index 12728e4793..1292df2262 100644
--- a/pkg/kube/multicluster/secretcontroller.go
+++ b/pkg/kube/multicluster/secretcontroller.go
@@ -78,11 +78,11 @@ type ClusterHandler interface {
 
 // Controller is the controller implementation for Secret resources
 type Controller struct {
-	namespace          string
-	localClusterID     cluster.ID
-	localClusterClient kube.Client
-	queue              controllers.Queue
-	informer           cache.SharedIndexInformer
+	namespace           string
+	configClusterID     cluster.ID
+	configClusterClient kube.Client
+	queue               controllers.Queue
+	informer            cache.SharedIndexInformer
 
 	cs *ClusterStore
 
@@ -90,7 +90,7 @@ type Controller struct {
 }
 
 // NewController returns a new secret controller
-func NewController(kubeclientset kube.Client, namespace string, localClusterID cluster.ID) *Controller {
+func NewController(kubeclientset kube.Client, namespace string, clusterID cluster.ID) *Controller {
 	secretsInformer := cache.NewSharedIndexInformer(
 		&cache.ListWatch{
 			ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
@@ -110,11 +110,11 @@ func NewController(kubeclientset kube.Client, namespace string, localClusterID c
 	remoteClusters.Record(0.0)
 
 	controller := &Controller{
-		namespace:          namespace,
-		localClusterID:     localClusterID,
-		localClusterClient: kubeclientset,
-		cs:                 newClustersStore(),
-		informer:           secretsInformer,
+		namespace:           namespace,
+		configClusterID:     clusterID,
+		configClusterClient: kubeclientset,
+		cs:                  newClustersStore(),
+		informer:            secretsInformer,
 	}
 	controller.queue = controllers.NewQueue("multicluster secret", controllers.WithReconciler(controller.processItem))
 
@@ -128,11 +128,11 @@ func (c *Controller) AddHandler(h ClusterHandler) {
 
 // Run starts the controller until it receives a message over stopCh
 func (c *Controller) Run(stopCh <-chan struct{}) error {
-	// run handlers for the local cluster; do not store this *Cluster in the ClusterStore or give it a SyncTimeout
+	// run handlers for the config cluster; do not store this *Cluster in the ClusterStore or give it a SyncTimeout
 	// this is done outside the goroutine, we should block other Run/startFuncs until this is registered
-	localCluster := &Cluster{Client: c.localClusterClient, ID: c.localClusterID}
-	if err := c.handleAdd(localCluster, stopCh); err != nil {
-		return fmt.Errorf("failed initializing local cluster %s: %v", c.localClusterID, err)
+	configCluster := &Cluster{Client: c.configClusterClient, ID: c.configClusterID}
+	if err := c.handleAdd(configCluster, stopCh); err != nil {
+		return fmt.Errorf("failed initializing primary cluster %s: %v", c.configClusterID, err)
 	}
 	go func() {
 		t0 := time.Now()
@@ -320,8 +320,8 @@ func (c *Controller) addSecret(name types.NamespacedName, s *corev1.Secret) {
 	}
 
 	for clusterID, kubeConfig := range s.Data {
-		if cluster.ID(clusterID) == c.localClusterID {
-			log.Infof("ignoring cluster %v from secret %v as it would overwrite the local cluster", clusterID, secretKey)
+		if cluster.ID(clusterID) == c.configClusterID {
+			log.Infof("ignoring cluster %v from secret %v as it would overwrite the primary cluster", clusterID, secretKey)
 			continue
 		}
 
@@ -361,8 +361,8 @@ func (c *Controller) addSecret(name types.NamespacedName, s *corev1.Secret) {
 
 func (c *Controller) deleteSecret(secretKey string) {
 	for _, cluster := range c.cs.GetExistingClustersFor(secretKey) {
-		if cluster.ID == c.localClusterID {
-			log.Infof("ignoring delete cluster %v from secret %v as it would overwrite the local cluster", c.localClusterID, secretKey)
+		if cluster.ID == c.configClusterID {
+			log.Infof("ignoring delete cluster %v from secret %v as it would overwrite the primary cluster", c.configClusterID, secretKey)
 			continue
 		}
 		log.Infof("Deleting cluster_id=%v configured by secret=%v", cluster.ID, secretKey)
-- 
2.35.3

