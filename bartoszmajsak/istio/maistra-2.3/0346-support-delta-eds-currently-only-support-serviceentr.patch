From c34fbfa2db7137afb8786c652ec101d9c9ec7005 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Sat, 8 Jan 2022 01:16:45 +0800
Subject: support delta eds, currently only support serviceentry (#36610)

* support delta eds, currently only support serviceentry

* Make delta eds removed resources does not influence Sotw

* revert generateEndpoints

* Added test for delta eds
---
 pilot/pkg/xds/cds.go          |   4 +-
 pilot/pkg/xds/delta.go        |   2 +-
 pilot/pkg/xds/delta_test.go   |  33 ++++++
 pilot/pkg/xds/deltaadstest.go |   2 +-
 pilot/pkg/xds/eds.go          | 184 +++++++++++++++++++++++++---------
 5 files changed, 175 insertions(+), 50 deletions(-)

diff --git a/pilot/pkg/xds/cds.go b/pilot/pkg/xds/cds.go
index dccc8367fa..968d6fb488 100644
--- a/pilot/pkg/xds/cds.go
+++ b/pilot/pkg/xds/cds.go
@@ -24,7 +24,7 @@ type CdsGenerator struct {
 	Server *DiscoveryServer
 }
 
-var _ model.XdsResourceGenerator = &CdsGenerator{}
+var _ model.XdsDeltaResourceGenerator = &CdsGenerator{}
 
 // Map of all configs that do not impact CDS
 var skippedCdsConfigs = map[config.GroupVersionKind]struct{}{
@@ -81,7 +81,7 @@ func (c CdsGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *m
 
 // GenerateDeltas for CDS currently only builds deltas when services change. todo implement changes for DestinationRule, etc
 func (c CdsGenerator) GenerateDeltas(proxy *model.Proxy, push *model.PushContext, updates *model.PushRequest,
-	w *model.WatchedResource) (model.Resources, []string, model.XdsLogDetails, bool, error) {
+	w *model.WatchedResource) (model.Resources, model.DeletedResources, model.XdsLogDetails, bool, error) {
 	if !cdsNeedsPush(updates, proxy) {
 		return nil, nil, model.DefaultXdsLogDetails, false, nil
 	}
diff --git a/pilot/pkg/xds/delta.go b/pilot/pkg/xds/delta.go
index c562587abc..bfa59cb41b 100644
--- a/pilot/pkg/xds/delta.go
+++ b/pilot/pkg/xds/delta.go
@@ -441,7 +441,7 @@ func (s *DiscoveryServer) pushDeltaXds(con *Connection, push *model.PushContext,
 	case model.XdsResourceGenerator:
 		res, logdata, err = g.Generate(con.proxy, push, w, req)
 	}
-	if err != nil || res == nil {
+	if err != nil || (res == nil && deletedRes == nil) {
 		// If we have nothing to send, report that we got an ACK for this version.
 		if s.StatusReporter != nil {
 			s.StatusReporter.RegisterEvent(con.ConID, w.TypeUrl, push.LedgerVersion)
diff --git a/pilot/pkg/xds/delta_test.go b/pilot/pkg/xds/delta_test.go
index c9127bccb7..e52a7a0680 100644
--- a/pilot/pkg/xds/delta_test.go
+++ b/pilot/pkg/xds/delta_test.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pilot/test/xdstest"
+	"istio.io/istio/pkg/config/schema/gvk"
 )
 
 func TestDeltaAds(t *testing.T) {
@@ -101,4 +102,36 @@ func TestDeltaEDS(t *testing.T) {
 	if len(resp.RemovedResources) != 0 {
 		t.Fatalf("received unexpected removed eds resource %v", resp.RemovedResources)
 	}
+
+	// update svc, only send the eds for this service
+	s.Discovery.MemRegistry.AddHTTPService(edsIncSvc, "10.10.1.3", 8080)
+	s.Discovery.ConfigUpdate(&model.PushRequest{Full: true, ConfigsUpdated: map[model.ConfigKey]struct{}{{
+		Kind:      gvk.ServiceEntry,
+		Name:      edsIncSvc,
+		Namespace: "",
+	}: {}}})
+
+	resp = ads.ExpectResponse()
+	if len(resp.Resources) != 1 || resp.Resources[0].Name != "outbound|8080||"+edsIncSvc {
+		t.Fatalf("received unexpected eds resource %v", resp.Resources)
+	}
+	if len(resp.RemovedResources) != 0 {
+		t.Fatalf("received unexpected removed eds resource %v", resp.RemovedResources)
+	}
+
+	// delete svc, only send eds fot this service
+	s.Discovery.MemRegistry.RemoveService(edsIncSvc)
+	s.Discovery.ConfigUpdate(&model.PushRequest{Full: true, ConfigsUpdated: map[model.ConfigKey]struct{}{{
+		Kind:      gvk.ServiceEntry,
+		Name:      edsIncSvc,
+		Namespace: "",
+	}: {}}})
+
+	resp = ads.ExpectResponse()
+	if len(resp.RemovedResources) != 1 || resp.RemovedResources[0] != "outbound|8080||"+edsIncSvc {
+		t.Fatalf("received unexpected removed eds resource %v", resp.RemovedResources)
+	}
+	if len(resp.Resources) != 0 {
+		t.Fatalf("received unexpected eds resource %v", resp.Resources)
+	}
 }
diff --git a/pilot/pkg/xds/deltaadstest.go b/pilot/pkg/xds/deltaadstest.go
index e57b662853..46c2964dee 100644
--- a/pilot/pkg/xds/deltaadstest.go
+++ b/pilot/pkg/xds/deltaadstest.go
@@ -138,7 +138,7 @@ func (a *DeltaAdsTest) ExpectResponse() *discovery.DeltaDiscoveryResponse {
 	case <-time.After(a.timeout):
 		a.t.Fatalf("did not get response in time")
 	case resp := <-a.responses:
-		if resp == nil || len(resp.Resources) == 0 {
+		if resp == nil || (len(resp.Resources) == 0 && len(resp.RemovedResources) == 0) {
 			a.t.Fatalf("got empty response")
 		}
 		return resp
diff --git a/pilot/pkg/xds/eds.go b/pilot/pkg/xds/eds.go
index 4a764bc550..2fb4176b25 100644
--- a/pilot/pkg/xds/eds.go
+++ b/pilot/pkg/xds/eds.go
@@ -354,7 +354,7 @@ type EdsGenerator struct {
 	Server *DiscoveryServer
 }
 
-var _ model.XdsResourceGenerator = &EdsGenerator{}
+var _ model.XdsDeltaResourceGenerator = &EdsGenerator{}
 
 // Map of all configs that do not impact EDS
 var skippedEdsConfigs = map[config.GroupVersionKind]struct{}{
@@ -386,51 +386,8 @@ func (eds *EdsGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w
 	if !edsNeedsPush(req.ConfigsUpdated) {
 		return nil, model.DefaultXdsLogDetails, nil
 	}
-	var edsUpdatedServices map[string]struct{}
-	if !req.Full {
-		edsUpdatedServices = model.ConfigNamesOfKind(req.ConfigsUpdated, gvk.ServiceEntry)
-	}
-	resources := make(model.Resources, 0)
-	empty := 0
-
-	cached := 0
-	regenerated := 0
-	for _, clusterName := range w.ResourceNames {
-		if edsUpdatedServices != nil {
-			_, _, hostname, _ := model.ParseSubsetKey(clusterName)
-			if _, ok := edsUpdatedServices[string(hostname)]; !ok {
-				// Cluster was not updated, skip recomputing. This happens when we get an incremental update for a
-				// specific Hostname. On connect or for full push edsUpdatedServices will be empty.
-				continue
-			}
-		}
-		builder := NewEndpointBuilder(clusterName, proxy, push)
-		if marshalledEndpoint, f := eds.Server.Cache.Get(builder); f && !features.EnableUnsafeAssertions {
-			// We skip cache if assertions are enabled, so that the cache will assert our eviction logic is correct
-			resources = append(resources, marshalledEndpoint)
-			cached++
-		} else {
-			l := eds.Server.generateEndpoints(builder)
-			if l == nil {
-				continue
-			}
-			regenerated++
-
-			if len(l.Endpoints) == 0 {
-				empty++
-			}
-			resource := &discovery.Resource{
-				Name:     l.ClusterName,
-				Resource: util.MessageToAny(l),
-			}
-			resources = append(resources, resource)
-			eds.Server.Cache.Add(builder, req, resource)
-		}
-	}
-	return resources, model.XdsLogDetails{
-		Incremental:    len(edsUpdatedServices) != 0,
-		AdditionalInfo: fmt.Sprintf("empty:%v cached:%v/%v", empty, cached, cached+regenerated),
-	}, nil
+	resources, logDetails := eds.buildEndpoints(proxy, push, req, w)
+	return resources, logDetails, nil
 }
 
 func getOutlierDetectionAndLoadBalancerSettings(
@@ -484,3 +441,138 @@ func buildEmptyClusterLoadAssignment(clusterName string) *endpoint.ClusterLoadAs
 		ClusterName: clusterName,
 	}
 }
+
+func (eds *EdsGenerator) GenerateDeltas(proxy *model.Proxy, push *model.PushContext, req *model.PushRequest,
+	w *model.WatchedResource) (model.Resources, model.DeletedResources, model.XdsLogDetails, bool, error) {
+	if !edsNeedsPush(req.ConfigsUpdated) {
+		return nil, nil, model.DefaultXdsLogDetails, false, nil
+	}
+	if !shouldUseDeltaEds(req) {
+		resources, logDetails := eds.buildEndpoints(proxy, push, req, w)
+		return resources, nil, logDetails, false, nil
+	}
+
+	resources, removed, logs := eds.buildDeltaEndpoints(proxy, push, req, w)
+	return resources, removed, logs, true, nil
+}
+
+// deltaConfigTypes are used to detect changes and trigger delta calculations. When config updates has ONLY entries
+// in this map, then delta calculation is triggered.
+var deltaConfigTypes = sets.NewSet(gvk.ServiceEntry.Kind)
+
+func shouldUseDeltaEds(req *model.PushRequest) bool {
+	if !req.Full {
+		return false
+	}
+	if len(req.ConfigsUpdated) > 0 {
+		for k := range req.ConfigsUpdated {
+			if !deltaConfigTypes.Contains(k.Kind.Kind) {
+				return false
+			}
+		}
+		return true
+	}
+	return false
+}
+
+func (eds *EdsGenerator) buildEndpoints(proxy *model.Proxy,
+	push *model.PushContext,
+	req *model.PushRequest,
+	w *model.WatchedResource) (model.Resources, model.XdsLogDetails) {
+	var edsUpdatedServices map[string]struct{}
+	if !req.Full {
+		edsUpdatedServices = model.ConfigNamesOfKind(req.ConfigsUpdated, gvk.ServiceEntry)
+	}
+	resources := make(model.Resources, 0)
+	empty := 0
+	cached := 0
+	regenerated := 0
+	for _, clusterName := range w.ResourceNames {
+		if edsUpdatedServices != nil {
+			_, _, hostname, _ := model.ParseSubsetKey(clusterName)
+			if _, ok := edsUpdatedServices[string(hostname)]; !ok {
+				// Cluster was not updated, skip recomputing. This happens when we get an incremental update for a
+				// specific Hostname. On connect or for full push edsUpdatedServices will be empty.
+				continue
+			}
+		}
+		builder := NewEndpointBuilder(clusterName, proxy, push)
+		if marshalledEndpoint, f := eds.Server.Cache.Get(builder); f && !features.EnableUnsafeAssertions {
+			// We skip cache if assertions are enabled, so that the cache will assert our eviction logic is correct
+			resources = append(resources, marshalledEndpoint)
+			cached++
+		} else {
+			l := eds.Server.generateEndpoints(builder)
+			if l == nil {
+				continue
+			}
+			regenerated++
+
+			if len(l.Endpoints) == 0 {
+				empty++
+			}
+			resource := &discovery.Resource{
+				Name:     l.ClusterName,
+				Resource: util.MessageToAny(l),
+			}
+			resources = append(resources, resource)
+			eds.Server.Cache.Add(builder, req, resource)
+		}
+	}
+	return resources, model.XdsLogDetails{
+		Incremental:    len(edsUpdatedServices) != 0,
+		AdditionalInfo: fmt.Sprintf("empty:%v cached:%v/%v", empty, cached, cached+regenerated),
+	}
+}
+
+// TODO(@hzxuzhonghu): merge with buildEndpoints
+func (eds *EdsGenerator) buildDeltaEndpoints(proxy *model.Proxy,
+	push *model.PushContext,
+	req *model.PushRequest,
+	w *model.WatchedResource) (model.Resources, []string, model.XdsLogDetails) {
+	edsUpdatedServices := model.ConfigNamesOfKind(req.ConfigsUpdated, gvk.ServiceEntry)
+	var resources model.Resources
+	var removed []string
+	empty := 0
+	cached := 0
+	regenerated := 0
+
+	for _, clusterName := range w.ResourceNames {
+		// filter out eds that are not updated for clusters
+		_, _, hostname, _ := model.ParseSubsetKey(clusterName)
+		if _, ok := edsUpdatedServices[string(hostname)]; !ok {
+			continue
+		}
+
+		builder := NewEndpointBuilder(clusterName, proxy, push)
+		if marshalledEndpoint, f := eds.Server.Cache.Get(builder); f && !features.EnableUnsafeAssertions {
+			// We skip cache if assertions are enabled, so that the cache will assert our eviction logic is correct
+			resources = append(resources, marshalledEndpoint)
+			cached++
+		} else {
+			// if a service is not found, it means the cluster is removed
+			if builder.service == nil {
+				removed = append(removed, clusterName)
+				continue
+			}
+			l := eds.Server.generateEndpoints(builder)
+			if l == nil {
+				continue
+			}
+			regenerated++
+			if len(l.Endpoints) == 0 {
+				empty++
+			}
+			resource := &discovery.Resource{
+				Name:     l.ClusterName,
+				Resource: util.MessageToAny(l),
+			}
+			resources = append(resources, resource)
+			eds.Server.Cache.Add(builder, req, resource)
+		}
+	}
+	return resources, removed, model.XdsLogDetails{
+		Incremental:    len(edsUpdatedServices) != 0,
+		AdditionalInfo: fmt.Sprintf("empty:%v cached:%v/%v", empty, cached, cached+regenerated),
+	}
+}
-- 
2.35.3

