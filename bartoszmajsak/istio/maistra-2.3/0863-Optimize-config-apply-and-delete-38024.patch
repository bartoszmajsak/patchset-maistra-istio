From bdb4185dd321bc4e2a6afb3a3431a8a1a8b11463 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Mon, 21 Mar 2022 11:07:58 -0700
Subject: Optimize config apply and delete (#38024)

When pushing config to real clusters, each push can take several seconds. These times can stack pretty quickly when pushing a lot of config, which happens from some tests.

The new authz tests in https://github.com/istio/istio/pull/37914, push a lot of config at once. With this change, the config push time on GKE goes from ~1 minute to 5 seconds.
---
 pkg/kube/client.go                            |  57 ++++--
 .../components/echo/deployment/builder.go     |   2 +-
 .../components/echo/kube/deployment.go        |   8 +-
 .../framework/components/istio/eastwest.go    |   2 +-
 .../framework/components/istio/operator.go    |   4 +-
 pkg/test/framework/components/istio/util.go   |   4 +-
 .../components/opentelemetry/kube.go          |   6 +-
 .../framework/components/prometheus/kube.go   |   4 +-
 pkg/test/framework/components/zipkin/kube.go  |   6 +-
 pkg/test/framework/config.go                  | 177 +++++++++++-------
 pkg/test/framework/resource/context.go        |  45 +++--
 pkg/test/framework/scope.go                   |   4 +-
 tests/integration/helm/util.go                |   2 +-
 .../pilot/analysis/analysis_test.go           |  16 +-
 .../pilot/cni/cniversionskew_test.go          |   2 +-
 tests/integration/pilot/common/apps.go        |   6 +-
 tests/integration/pilot/common/traffic.go     |   4 +-
 .../integration/pilot/cross_revision_test.go  |   4 +-
 tests/integration/pilot/grpc_probe_test.go    |   6 +-
 tests/integration/pilot/gw_topology_test.go   |   4 +-
 tests/integration/pilot/ingress_test.go       |  40 ++--
 tests/integration/pilot/istioctl_test.go      |  10 +-
 tests/integration/pilot/locality_test.go      |   2 +-
 tests/integration/pilot/mcs/common/common.go  |   4 +-
 tests/integration/pilot/mirror_test.go        |   2 +-
 .../pilot/multi_version_revision_test.go      |   4 +-
 tests/integration/pilot/multicluster_test.go  |   8 +-
 .../pilot/proxyconfig/proxyconfig_test.go     |   4 +-
 .../pilot/revisioned_upgrade_test.go          |   2 +-
 .../security/authorization_test.go            |  56 +++---
 .../ca_custom_root/multi_root_test.go         |   2 +-
 .../ca_custom_root/secure_naming_test.go      |   2 +-
 .../trust_domain_alias_secure_naming_test.go  |   2 +-
 .../trust_domain_validation_test.go           |   2 +-
 .../mtls_strict_test.go                       |   4 +-
 .../egress_gateway_origination_test.go        |   4 +-
 .../file_mounted_certs/p2p_mtls_test.go       |   2 +-
 .../destination_rule_tls_test.go              |   4 +-
 .../egress_gateway_origination_test.go        |   6 +-
 tests/integration/security/fuzz/fuzz_test.go  |   8 +-
 .../security/https_jwt/https_jwt_test.go      |   8 +-
 tests/integration/security/jwt_test.go        |  16 +-
 .../security/mtls_healthcheck_test.go         |   2 +-
 .../pass_through_filter_chain_test.go         |   2 +-
 .../sds_istio_mutual_egress_test.go           |   4 +-
 .../security/sds_ingress/util/util.go         |   2 +-
 .../security/util/reachability/context.go     |   4 +-
 .../telemetry/outboundtrafficpolicy/helper.go |   6 +-
 .../telemetry/policy/envoy_ratelimit_test.go  |   8 +-
 .../api/stackdriver_filter_test.go            |   4 +-
 .../telemetry/stackdriver/common.go           |   4 +-
 .../stackdriver_filter_audit_test.go          |   2 +-
 .../stackdriver_filter_dry_run_test.go        |   2 +-
 .../telemetry/stackdriver/vm/main_test.go     |   4 +-
 .../telemetry/stackdriver/vm/vm_test.go       |   2 +-
 .../prometheus/api/stats_wasm_filter_test.go  |   4 +-
 .../customize_metrics_test.go                 |   4 +-
 .../prometheus/nullvm/accesslogs_test.go      |   2 +-
 .../stats/prometheus/nullvm/dashboard_test.go |   6 +-
 .../telemetry/stats/prometheus/stats.go       |   2 +-
 .../prometheus/wasm/bad_wasm_filter_test.go   |   2 +-
 61 files changed, 344 insertions(+), 277 deletions(-)

diff --git a/pkg/kube/client.go b/pkg/kube/client.go
index b80a366047..71788b1694 100644
--- a/pkg/kube/client.go
+++ b/pkg/kube/client.go
@@ -30,6 +30,7 @@
 
 	"github.com/hashicorp/go-multierror"
 	"go.uber.org/atomic"
+	"golang.org/x/sync/errgroup"
 	"google.golang.org/grpc/credentials"
 	v1 "k8s.io/api/core/v1"
 	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
@@ -97,7 +98,7 @@
 // clients using a shared config. It is expected that all of Istiod can share the same set of clients and
 // informers. Sharing informers is especially important for load on the API server/Istiod itself.
 type Client interface {
-	// TODO - stop embedding this, it will conflict with future additions. Use Kube() instead is preferred
+	// TODO: stop embedding this, it will conflict with future additions. Use Kube() instead is preferred
 	kubernetes.Interface
 	// RESTConfig returns the Kubernetes rest.Config used to configure the clients.
 	RESTConfig() *rest.Config
@@ -881,24 +882,28 @@ func (c *client) PodsForSelector(ctx context.Context, namespace string, labelSel
 }
 
 func (c *client) ApplyYAMLFiles(namespace string, yamlFiles ...string) error {
+	g, _ := errgroup.WithContext(context.TODO())
 	for _, f := range removeEmptyFiles(yamlFiles) {
-		if err := c.applyYAMLFile(namespace, false, f); err != nil {
-			return err
-		}
+		f := f
+		g.Go(func() error {
+			return c.applyYAMLFile(namespace, false, f)
+		})
 	}
-	return nil
+	return g.Wait()
 }
 
 func (c *client) ApplyYAMLFilesDryRun(namespace string, yamlFiles ...string) error {
+	g, _ := errgroup.WithContext(context.TODO())
 	for _, f := range removeEmptyFiles(yamlFiles) {
-		if err := c.applyYAMLFile(namespace, true, f); err != nil {
-			return err
-		}
+		f := f
+		g.Go(func() error {
+			return c.applyYAMLFile(namespace, true, f)
+		})
 	}
-	return nil
+	return g.Wait()
 }
 
-func (c *client) CreatePerRPCCredentials(ctx context.Context, tokenNamespace, tokenServiceAccount string, audiences []string,
+func (c *client) CreatePerRPCCredentials(_ context.Context, tokenNamespace, tokenServiceAccount string, audiences []string,
 	expirationSeconds int64) (credentials.PerRPCCredentials, error) {
 	return NewRPCCredentials(c, tokenNamespace, tokenServiceAccount, audiences, expirationSeconds, 60)
 }
@@ -971,17 +976,37 @@ func (c *client) applyYAMLFile(namespace string, dryRun bool, file string) error
 }
 
 func (c *client) DeleteYAMLFiles(namespace string, yamlFiles ...string) (err error) {
-	for _, f := range removeEmptyFiles(yamlFiles) {
-		err = multierror.Append(err, c.deleteFile(namespace, false, f)).ErrorOrNil()
+	yamlFiles = removeEmptyFiles(yamlFiles)
+
+	// Run each delete concurrently and collect the errors.
+	errs := make([]error, len(yamlFiles))
+	g, _ := errgroup.WithContext(context.TODO())
+	for i, f := range yamlFiles {
+		i, f := i, f
+		g.Go(func() error {
+			errs[i] = c.deleteFile(namespace, false, f)
+			return errs[i]
+		})
 	}
-	return err
+	_ = g.Wait()
+	return multierror.Append(nil, errs...).ErrorOrNil()
 }
 
 func (c *client) DeleteYAMLFilesDryRun(namespace string, yamlFiles ...string) (err error) {
-	for _, f := range removeEmptyFiles(yamlFiles) {
-		err = multierror.Append(err, c.deleteFile(namespace, true, f)).ErrorOrNil()
+	yamlFiles = removeEmptyFiles(yamlFiles)
+
+	// Run each delete concurrently and collect the errors.
+	errs := make([]error, len(yamlFiles))
+	g, _ := errgroup.WithContext(context.TODO())
+	for i, f := range yamlFiles {
+		i, f := i, f
+		g.Go(func() error {
+			errs[i] = c.deleteFile(namespace, true, f)
+			return errs[i]
+		})
 	}
-	return err
+	_ = g.Wait()
+	return multierror.Append(nil, errs...).ErrorOrNil()
 }
 
 func (c *client) deleteFile(namespace string, dryRun bool, file string) error {
diff --git a/pkg/test/framework/components/echo/deployment/builder.go b/pkg/test/framework/components/echo/deployment/builder.go
index f533ef74c8..3560374c83 100644
--- a/pkg/test/framework/components/echo/deployment/builder.go
+++ b/pkg/test/framework/components/echo/deployment/builder.go
@@ -322,7 +322,7 @@ func (b builder) deployServices() error {
 		svcYaml := svcYaml
 		ns := strings.Split(svcNs, ".")[1]
 		errG.Go(func() error {
-			return b.ctx.ConfigKube().YAML(svcYaml).Apply(ns, resource.NoCleanup)
+			return b.ctx.ConfigKube().YAML(ns, svcYaml).Apply(resource.NoCleanup)
 		})
 	}
 	return errG.Wait().ErrorOrNil()
diff --git a/pkg/test/framework/components/echo/kube/deployment.go b/pkg/test/framework/components/echo/kube/deployment.go
index 3d00d118ec..4a0045d104 100644
--- a/pkg/test/framework/components/echo/kube/deployment.go
+++ b/pkg/test/framework/components/echo/kube/deployment.go
@@ -493,7 +493,7 @@ func newDeployment(ctx resource.Context, cfg echo.Config) (*deployment, error) {
 	}
 
 	// Apply the deployment to the configured cluster.
-	if err = ctx.ConfigKube(cfg.Cluster).YAML(deploymentYAML).Apply(cfg.Namespace.Name(), resource.NoCleanup); err != nil {
+	if err = ctx.ConfigKube(cfg.Cluster).YAML(cfg.Namespace.Name(), deploymentYAML).Apply(resource.NoCleanup); err != nil {
 		return nil, fmt.Errorf("failed deploying echo %s to cluster %s: %v",
 			cfg.ClusterLocalFQDN(), cfg.Cluster.Name(), err)
 	}
@@ -543,7 +543,7 @@ func (d *deployment) WorkloadReady(w *workload) {
 
 	// Deploy the workload entry to the primary cluster. We will read WorkloadEntry across clusters.
 	wle := d.workloadEntryYAML(w)
-	if err := d.ctx.ConfigKube(d.cfg.Cluster.Primary()).YAML(wle).Apply(d.cfg.Namespace.Name(), resource.NoCleanup); err != nil {
+	if err := d.ctx.ConfigKube(d.cfg.Cluster.Primary()).YAML(d.cfg.Namespace.Name(), wle).Apply(resource.NoCleanup); err != nil {
 		log.Warnf("failed deploying echo WLE for %s/%s to primary cluster: %v",
 			d.cfg.Namespace.Name(),
 			d.cfg.Service,
@@ -557,7 +557,7 @@ func (d *deployment) WorkloadNotReady(w *workload) {
 	}
 
 	wle := d.workloadEntryYAML(w)
-	if err := d.ctx.ConfigKube(d.cfg.Cluster.Primary()).YAML(wle).Delete(d.cfg.Namespace.Name()); err != nil {
+	if err := d.ctx.ConfigKube(d.cfg.Cluster.Primary()).YAML(d.cfg.Namespace.Name(), wle).Delete(); err != nil {
 		log.Warnf("failed deleting echo WLE for %s/%s from primary cluster: %v",
 			d.cfg.Namespace.Name(),
 			d.cfg.Service,
@@ -737,7 +737,7 @@ func createVMConfig(ctx resource.Context, cfg echo.Config) error {
 
 	// Push the WorkloadGroup for auto-registration
 	if cfg.AutoRegisterVM {
-		if err := ctx.ConfigKube(cfg.Cluster).YAML(wg).Apply(cfg.Namespace.Name(), resource.NoCleanup); err != nil {
+		if err := ctx.ConfigKube(cfg.Cluster).YAML(cfg.Namespace.Name(), wg).Apply(resource.NoCleanup); err != nil {
 			return err
 		}
 	}
diff --git a/pkg/test/framework/components/istio/eastwest.go b/pkg/test/framework/components/istio/eastwest.go
index 36135d71da..a41b5cc808 100644
--- a/pkg/test/framework/components/istio/eastwest.go
+++ b/pkg/test/framework/components/istio/eastwest.go
@@ -143,5 +143,5 @@ func (i *operatorComponent) applyIstiodGateway(cluster cluster.Cluster, revision
 	if err != nil {
 		return fmt.Errorf("failed running template %s: %v", exposeIstiodGatewayRev, err)
 	}
-	return i.ctx.ConfigKube(cluster).YAML(out).Apply(i.settings.SystemNamespace)
+	return i.ctx.ConfigKube(cluster).YAML(i.settings.SystemNamespace, out).Apply()
 }
diff --git a/pkg/test/framework/components/istio/operator.go b/pkg/test/framework/components/istio/operator.go
index df7d977639..358f2d5331 100644
--- a/pkg/test/framework/components/istio/operator.go
+++ b/pkg/test/framework/components/istio/operator.go
@@ -201,7 +201,7 @@ func (i *operatorComponent) Close() error {
 func (i *operatorComponent) cleanupCluster(c cluster.Cluster, errG *multierror.Group) {
 	scopes.Framework.Infof("clean up cluster %s", c.Name())
 	errG.Go(func() (err error) {
-		if e := i.ctx.ConfigKube(c).YAML(removeCRDsSlice(i.installManifest[c.Name()])).Delete(""); e != nil {
+		if e := i.ctx.ConfigKube(c).YAML("", removeCRDsSlice(i.installManifest[c.Name()])).Delete(); e != nil {
 			err = multierror.Append(err, e)
 		}
 		// Cleanup all secrets and configmaps - these are dynamically created by tests and/or istiod so they are not captured above
@@ -829,7 +829,7 @@ func (i *operatorComponent) configureDirectAPIServiceAccessForCluster(ctx resour
 	if err != nil {
 		return fmt.Errorf("failed creating remote secret for cluster %s: %v", c.Name(), err)
 	}
-	if err := ctx.ConfigKube(clusters...).YAML(secret).Apply(cfg.SystemNamespace, resource.NoCleanup); err != nil {
+	if err := ctx.ConfigKube(clusters...).YAML(cfg.SystemNamespace, secret).Apply(resource.NoCleanup); err != nil {
 		return fmt.Errorf("failed applying remote secret to clusters: %v", err)
 	}
 	return nil
diff --git a/pkg/test/framework/components/istio/util.go b/pkg/test/framework/components/istio/util.go
index 688dd2ea5c..3917d85c88 100644
--- a/pkg/test/framework/components/istio/util.go
+++ b/pkg/test/framework/components/istio/util.go
@@ -63,7 +63,7 @@
 func waitForValidationWebhook(ctx resource.Context, cluster cluster.Cluster, cfg Config) error {
 	dummyValidationVirtualService := fmt.Sprintf(dummyValidationVirtualServiceTemplate, cfg.SystemNamespace)
 	defer func() {
-		e := ctx.ConfigKube(cluster).YAML(dummyValidationVirtualService).Delete("")
+		e := ctx.ConfigKube(cluster).YAML("", dummyValidationVirtualService).Delete()
 		if e != nil {
 			scopes.Framework.Warnf("error deleting dummy virtual service for waiting the validation webhook: %v", e)
 		}
@@ -71,7 +71,7 @@ func waitForValidationWebhook(ctx resource.Context, cluster cluster.Cluster, cfg
 
 	scopes.Framework.Info("Creating dummy virtual service to check for validation webhook readiness")
 	return retry.UntilSuccess(func() error {
-		err := ctx.ConfigKube(cluster).YAML(dummyValidationVirtualService).Apply("")
+		err := ctx.ConfigKube(cluster).YAML("", dummyValidationVirtualService).Apply()
 		if err == nil {
 			return nil
 		}
diff --git a/pkg/test/framework/components/opentelemetry/kube.go b/pkg/test/framework/components/opentelemetry/kube.go
index 03b4e9af6a..b15750fbb4 100644
--- a/pkg/test/framework/components/opentelemetry/kube.go
+++ b/pkg/test/framework/components/opentelemetry/kube.go
@@ -128,19 +128,19 @@ func install(ctx resource.Context, ns string) error {
 	if err != nil {
 		return err
 	}
-	return ctx.ConfigKube().YAML(y).Apply(ns)
+	return ctx.ConfigKube().YAML(ns, y).Apply()
 }
 
 func installServiceEntry(ctx resource.Context, ns, ingressAddr string) error {
 	// Setup remote access to zipkin in cluster
 	yaml := strings.ReplaceAll(remoteOtelEntry, "{INGRESS_DOMAIN}", ingressAddr)
-	if err := ctx.ConfigIstio().YAML(yaml).Apply(ns); err != nil {
+	if err := ctx.ConfigIstio().YAML(ns, yaml).Apply(); err != nil {
 		return err
 	}
 	// For all other clusters, add a service entry so that can access
 	// zipkin in cluster installed.
 	yaml = strings.ReplaceAll(extServiceEntry, "{INGRESS_DOMAIN}", ingressAddr)
-	if err := ctx.ConfigIstio().YAML(yaml).Apply(ns); err != nil {
+	if err := ctx.ConfigIstio().YAML(ns, yaml).Apply(); err != nil {
 		return err
 	}
 	return nil
diff --git a/pkg/test/framework/components/prometheus/kube.go b/pkg/test/framework/components/prometheus/kube.go
index be30169e6e..ffe138c6f8 100644
--- a/pkg/test/framework/components/prometheus/kube.go
+++ b/pkg/test/framework/components/prometheus/kube.go
@@ -73,11 +73,11 @@ func installPrometheus(ctx resource.Context, ns string) error {
 	if err != nil {
 		return err
 	}
-	if err := ctx.ConfigKube().YAML(yaml).Apply(ns, resource.NoCleanup); err != nil {
+	if err := ctx.ConfigKube().YAML(ns, yaml).Apply(resource.NoCleanup); err != nil {
 		return err
 	}
 	ctx.ConditionalCleanup(func() {
-		_ = ctx.ConfigKube().YAML(yaml).Delete(ns)
+		_ = ctx.ConfigKube().YAML(ns, yaml).Delete()
 	})
 	return nil
 }
diff --git a/pkg/test/framework/components/zipkin/kube.go b/pkg/test/framework/components/zipkin/kube.go
index 1adca68d1e..8439bfad20 100644
--- a/pkg/test/framework/components/zipkin/kube.go
+++ b/pkg/test/framework/components/zipkin/kube.go
@@ -161,18 +161,18 @@ func installZipkin(ctx resource.Context, ns string) error {
 	if err != nil {
 		return err
 	}
-	return ctx.ConfigKube().YAML(yaml).Apply(ns)
+	return ctx.ConfigKube().YAML(ns, yaml).Apply()
 }
 
 func installServiceEntry(ctx resource.Context, ns, ingressAddr string) error {
 	// Setup remote access to zipkin in cluster
 	yaml := strings.ReplaceAll(remoteZipkinEntry, "{INGRESS_DOMAIN}", ingressAddr)
-	err := ctx.ConfigIstio().YAML(yaml).Apply(ns)
+	err := ctx.ConfigIstio().YAML(ns, yaml).Apply()
 	if err != nil {
 		return err
 	}
 	yaml = strings.ReplaceAll(extServiceEntry, "{INGRESS_DOMAIN}", ingressAddr)
-	err = ctx.ConfigIstio().YAML(yaml).Apply(ns)
+	err = ctx.ConfigIstio().YAML(ns, yaml).Apply()
 	if err != nil {
 		return err
 	}
diff --git a/pkg/test/framework/config.go b/pkg/test/framework/config.go
index e8afb1cd5a..b34f807a43 100644
--- a/pkg/test/framework/config.go
+++ b/pkg/test/framework/config.go
@@ -15,11 +15,13 @@
 package framework
 
 import (
+	"context"
 	"fmt"
 	"strings"
 
 	"github.com/hashicorp/go-multierror"
 	"go.uber.org/atomic"
+	"golang.org/x/sync/errgroup"
 
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -52,43 +54,20 @@ func newConfigManager(ctx resource.Context, clusters cluster.Clusters) resource.
 // Note: go tests are distinct binaries per test suite, so this is the suite level number of calls
 var GlobalYAMLWrites = atomic.NewUint64(0)
 
-func (c *configManager) YAML(yamlText ...string) resource.Config {
-	return &yamlConfig{
-		configManager: c,
-		yamlText:      yamlText,
-	}
+func (c *configManager) YAML(ns string, yamlText ...string) resource.Config {
+	return newConfig(c).YAML(ns, yamlText...)
 }
 
-func (c *configManager) Eval(args interface{}, yamlTemplates ...string) resource.Config {
-	return c.YAML(tmpl.MustEvaluateAll(args, yamlTemplates...)...)
+func (c *configManager) Eval(ns string, args interface{}, yamlTemplates ...string) resource.Config {
+	return newConfig(c).Eval(ns, args, yamlTemplates...)
 }
 
-func (c *configManager) File(filePaths ...string) resource.Config {
-	yamlText, err := file.AsStringArray(filePaths...)
-	if err != nil {
-		panic(err)
-	}
-
-	return &yamlConfig{
-		configManager: c,
-		filePaths:     filePaths,
-		yamlText:      yamlText,
-	}
+func (c *configManager) File(ns string, filePaths ...string) resource.Config {
+	return newConfig(c).File(ns, filePaths...)
 }
 
-func (c *configManager) EvalFile(args interface{}, filePaths ...string) resource.Config {
-	yamlTemplates, err := file.AsStringArray(filePaths...)
-	if err != nil {
-		panic(err)
-	}
-
-	yamlText := tmpl.MustEvaluateAll(args, yamlTemplates...)
-
-	return &yamlConfig{
-		configManager: c,
-		filePaths:     filePaths,
-		yamlText:      yamlText,
-	}
+func (c *configManager) EvalFile(ns string, args interface{}, filePaths ...string) resource.Config {
+	return newConfig(c).EvalFile(ns, args, filePaths...)
 }
 
 func (c *configManager) applyYAML(cleanup bool, ns string, yamlText ...string) error {
@@ -103,22 +82,26 @@ func (c *configManager) applyYAML(cleanup bool, ns string, yamlText ...string) e
 		return err
 	}
 
+	g, _ := errgroup.WithContext(context.TODO())
 	for _, cl := range c.clusters {
 		cl := cl
-		scopes.Framework.Debugf("Applying to %s to namespace %v: %s", cl.StableName(), ns, strings.Join(yamlFiles, ", "))
-		if err := cl.ApplyYAMLFiles(ns, yamlFiles...); err != nil {
-			return fmt.Errorf("failed applying YAML to cluster %s: %v", cl.Name(), err)
-		}
-		if cleanup {
-			c.ctx.Cleanup(func() {
-				scopes.Framework.Debugf("Deleting from %s: %s", cl.StableName(), strings.Join(yamlFiles, ", "))
-				if err := cl.DeleteYAMLFiles(ns, yamlFiles...); err != nil {
-					scopes.Framework.Errorf("failed deleting YAML from cluster %s: %v", cl.Name(), err)
-				}
-			})
-		}
+		g.Go(func() error {
+			scopes.Framework.Debugf("Applying to %s to namespace %v: %s", cl.StableName(), ns, strings.Join(yamlFiles, ", "))
+			if err := cl.ApplyYAMLFiles(ns, yamlFiles...); err != nil {
+				return fmt.Errorf("failed applying YAML files %v to ns %s in cluster %s: %v", yamlFiles, ns, cl.Name(), err)
+			}
+			if cleanup {
+				c.ctx.Cleanup(func() {
+					scopes.Framework.Debugf("Deleting from %s: %s", cl.StableName(), strings.Join(yamlFiles, ", "))
+					if err := cl.DeleteYAMLFiles(ns, yamlFiles...); err != nil {
+						scopes.Framework.Errorf("failed deleting YAML files %v from ns %s in cluster %s: %v", yamlFiles, ns, cl.Name(), err)
+					}
+				})
+			}
+			return nil
+		})
 	}
-	return nil
+	return g.Wait()
 }
 
 func (c *configManager) deleteYAML(ns string, yamlText ...string) error {
@@ -132,12 +115,17 @@ func (c *configManager) deleteYAML(ns string, yamlText ...string) error {
 		return err
 	}
 
+	g, _ := errgroup.WithContext(context.TODO())
 	for _, c := range c.clusters {
-		if err := c.DeleteYAMLFiles(ns, yamlFiles...); err != nil {
-			return fmt.Errorf("failed deleting YAML from cluster %s: %v", c.Name(), err)
-		}
+		c := c
+		g.Go(func() error {
+			if err := c.DeleteYAMLFiles(ns, yamlFiles...); err != nil {
+				return fmt.Errorf("failed deleting YAML from cluster %s: %v", c.Name(), err)
+			}
+			return nil
+		})
 	}
-	return nil
+	return g.Wait()
 }
 
 func (c *configManager) WaitForConfig(ctx resource.Context, ns string, yamlText ...string) error {
@@ -182,60 +170,105 @@ func (c *configManager) WithFilePrefix(prefix string) resource.ConfigManager {
 	}
 }
 
-var _ resource.Config = &yamlConfig{}
+var _ resource.Config = &configImpl{}
+
+func newConfig(m *configManager) *configImpl {
+	return &configImpl{
+		configManager: m,
+		yamlText:      make(map[string][]string),
+	}
+}
 
-type yamlConfig struct {
+type configImpl struct {
 	*configManager
-	filePaths []string
-	yamlText  []string
+	yamlText map[string][]string
+}
+
+func (c *configImpl) YAML(ns string, yamlText ...string) resource.Config {
+	c.yamlText[ns] = append(c.yamlText[ns], yamlText...)
+	return c
 }
 
-func (c *yamlConfig) contentForError() []string {
-	// Use filename in the log if available.
-	if len(c.filePaths) > 0 {
-		return c.filePaths
+func (c *configImpl) File(ns string, paths ...string) resource.Config {
+	yamlText, err := file.AsStringArray(paths...)
+	if err != nil {
+		panic(err)
 	}
-	return c.yamlText
+
+	return c.YAML(ns, yamlText...)
+}
+
+func (c *configImpl) Eval(ns string, args interface{}, templates ...string) resource.Config {
+	return c.YAML(ns, tmpl.MustEvaluateAll(args, templates...)...)
 }
 
-func (c *yamlConfig) Apply(ns string, opts ...resource.ConfigOption) error {
+func (c *configImpl) EvalFile(ns string, args interface{}, paths ...string) resource.Config {
+	templates, err := file.AsStringArray(paths...)
+	if err != nil {
+		panic(err)
+	}
+
+	return c.Eval(ns, args, templates...)
+}
+
+func (c *configImpl) Apply(opts ...resource.ConfigOption) error {
 	// Apply the options.
 	options := resource.ConfigOptions{}
 	for _, o := range opts {
 		o(&options)
 	}
 
-	if err := c.applyYAML(!options.NoCleanup, ns, c.yamlText...); err != nil {
-		return fmt.Errorf("failed applying YAML %v: %v", c.contentForError(), err)
+	// Apply for each namespace concurrently.
+	g, _ := errgroup.WithContext(context.TODO())
+	for ns, y := range c.yamlText {
+		ns, y := ns, y
+		g.Go(func() error {
+			return c.applyYAML(!options.NoCleanup, ns, y...)
+		})
+	}
+
+	// Wait for all each apply to complete.
+	if err := g.Wait(); err != nil {
+		return err
 	}
 
 	if options.Wait {
-		if err := c.WaitForConfig(c.ctx, ns, c.yamlText...); err != nil {
-			// TODO(https://github.com/istio/istio/issues/37148) fail hard in this case
-			scopes.Framework.Warnf("(Ignored until https://github.com/istio/istio/issues/37148 is fixed) "+
-				"failed waiting for YAML %v: %v", c.contentForError(), err)
+		// TODO: wait for each namespace concurrently once WaitForConfig supports concurrency.
+		for ns, y := range c.yamlText {
+			if err := c.WaitForConfig(c.ctx, ns, y...); err != nil {
+				// TODO(https://github.com/istio/istio/issues/37148) fail hard in this case
+				scopes.Framework.Warnf("(Ignored until https://github.com/istio/istio/issues/37148 is fixed) "+
+					"failed waiting for YAML %v: %v", y, err)
+			}
 		}
 	}
 	return nil
 }
 
-func (c *yamlConfig) ApplyOrFail(t test.Failer, ns string, opts ...resource.ConfigOption) {
+func (c *configImpl) ApplyOrFail(t test.Failer, opts ...resource.ConfigOption) {
 	t.Helper()
-	if err := c.Apply(ns, opts...); err != nil {
+	if err := c.Apply(opts...); err != nil {
 		t.Fatal(err)
 	}
 }
 
-func (c *yamlConfig) Delete(ns string) error {
-	if err := c.deleteYAML(ns, c.yamlText...); err != nil {
-		return fmt.Errorf("failed deleting YAML %v: %v", c.contentForError(), err)
+func (c *configImpl) Delete() error {
+	// Delete for each namespace concurrently.
+	g, _ := errgroup.WithContext(context.TODO())
+	for ns, y := range c.yamlText {
+		ns, y := ns, y
+		g.Go(func() error {
+			return c.deleteYAML(ns, y...)
+		})
 	}
-	return nil
+
+	// Wait for all each delete to complete.
+	return g.Wait()
 }
 
-func (c *yamlConfig) DeleteOrFail(t test.Failer, ns string) {
+func (c *configImpl) DeleteOrFail(t test.Failer) {
 	t.Helper()
-	if err := c.Delete(ns); err != nil {
+	if err := c.Delete(); err != nil {
 		t.Fatal(err)
 	}
 }
diff --git a/pkg/test/framework/resource/context.go b/pkg/test/framework/resource/context.go
index 829f6118b1..6d4c274519 100644
--- a/pkg/test/framework/resource/context.go
+++ b/pkg/test/framework/resource/context.go
@@ -37,30 +37,39 @@ type ConfigOptions struct {
 	o.Wait = true
 }
 
-// Config that can be applied or deleted on the clusters contained within a ConfigManager.
+// ConfigFactory is a factory for creating new Config resources.
+type ConfigFactory interface {
+	// YAML adds YAML content to this config for the given namespace.
+	YAML(ns string, yamlText ...string) Config
+
+	// File reads the given YAML files and adds their content to this config
+	// for the given namespace.
+	File(ns string, paths ...string) Config
+
+	// Eval the same as YAML, but it evaluates the template parameters.
+	Eval(ns string, args interface{}, yamlText ...string) Config
+
+	// EvalFile the same as File, but it evaluates the template parameters.
+	EvalFile(ns string, args interface{}, paths ...string) Config
+}
+
+// Config builds a configuration that can be applied or deleted as a single
 type Config interface {
+	// ConfigFactory for appending to this Config
+	ConfigFactory
+
 	// Apply this config to all clusters within the ConfigManager
-	Apply(ns string, opts ...ConfigOption) error
-	ApplyOrFail(t test.Failer, ns string, opts ...ConfigOption)
+	Apply(opts ...ConfigOption) error
+	ApplyOrFail(t test.Failer, opts ...ConfigOption)
 
 	// Delete this config from all clusters within the ConfigManager
-	Delete(ns string) error
-	DeleteOrFail(t test.Failer, ns string)
+	Delete() error
+	DeleteOrFail(t test.Failer)
 }
 
 // ConfigManager is an interface for applying/deleting yaml resources.
 type ConfigManager interface {
-	// YAML creates a Config from the given YAML text.
-	YAML(yamlText ...string) Config
-
-	// File creates a Config from the given YAML files.
-	File(paths ...string) Config
-
-	// Eval the same as YAML, but it evaluates the template parameters.
-	Eval(args interface{}, yamlText ...string) Config
-
-	// EvalFile the same as File, but it evaluates the template parameters.
-	EvalFile(args interface{}, paths ...string) Config
+	ConfigFactory
 
 	// WithFilePrefix sets the prefix used for intermediate files.
 	WithFilePrefix(prefix string) ConfigManager
@@ -84,10 +93,10 @@ type Context interface {
 	// The Environment in which the tests run
 	Environment() Environment
 
-	// Mesh clusters in this Environment. There will always be at least one.
+	// Clusters in this Environment. There will always be at least one.
 	Clusters() cluster.Clusters
 
-	// All clusters in this Environment, including external control planes.
+	// AllClusters in this Environment, including external control planes.
 	AllClusters() cluster.Clusters
 
 	// Settings returns common settings
diff --git a/pkg/test/framework/scope.go b/pkg/test/framework/scope.go
index 7675f395c8..0e3a5b5aec 100644
--- a/pkg/test/framework/scope.go
+++ b/pkg/test/framework/scope.go
@@ -69,7 +69,7 @@ func (s *scope) add(r resource.Resource, id *resourceID) {
 	s.resources = append(s.resources, r)
 
 	if c, ok := r.(io.Closer); ok {
-		s.addCloser(c)
+		s.closers = append(s.closers, c)
 	}
 }
 
@@ -119,6 +119,8 @@ func (s *scope) get(ref interface{}) error {
 }
 
 func (s *scope) addCloser(c io.Closer) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
 	s.closers = append(s.closers, c)
 }
 
diff --git a/tests/integration/helm/util.go b/tests/integration/helm/util.go
index 48eaa8252d..f064ba05a6 100644
--- a/tests/integration/helm/util.go
+++ b/tests/integration/helm/util.go
@@ -213,7 +213,7 @@ func SetRevisionTag(ctx framework.TestContext, h *helm.Helm, fileSuffix, revisio
 		ctx.Fatalf("failed to install istio %s chart", DiscoveryChart)
 	}
 
-	err = ctx.ConfigIstio().YAML(template).Apply(IstioNamespace)
+	err = ctx.ConfigIstio().YAML(IstioNamespace, template).Apply()
 	if err != nil {
 		ctx.Fatalf("failed to apply templated revision tags yaml: %v", err)
 	}
diff --git a/tests/integration/pilot/analysis/analysis_test.go b/tests/integration/pilot/analysis/analysis_test.go
index 400b1624db..0d3242ed7a 100644
--- a/tests/integration/pilot/analysis/analysis_test.go
+++ b/tests/integration/pilot/analysis/analysis_test.go
@@ -53,7 +53,7 @@ func TestAnalysisWritesStatus(t *testing.T) {
 				Revision: "",
 				Labels:   nil,
 			})
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: v1
 kind: Service
 metadata:
@@ -67,9 +67,9 @@ func TestAnalysisWritesStatus(t *testing.T) {
     port: 15014
     protocol: TCP
     targetPort: 15014
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 			// Apply bad config (referencing invalid host)
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
 metadata:
@@ -82,13 +82,13 @@ func TestAnalysisWritesStatus(t *testing.T) {
   - route:
     - destination: 
         host: reviews
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 			// Status should report error
 			retry.UntilSuccessOrFail(t, func() error {
 				return expectVirtualServiceStatus(t, ns, true)
 			}, retry.Timeout(time.Minute*5))
 			// Apply config to make this not invalid
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
@@ -103,7 +103,7 @@ func TestAnalysisWritesStatus(t *testing.T) {
       protocol: HTTP
     hosts:
     - "*"
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 			// Status should no longer report error
 			retry.UntilSuccessOrFail(t, func() error {
 				return expectVirtualServiceStatus(t, ns, false)
@@ -123,14 +123,14 @@ func TestWorkloadEntryUpdatesStatus(t *testing.T) {
 			})
 
 			// create WorkloadEntry
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: WorkloadEntry
 metadata:
   name: vm-1
 spec:
   address: 127.0.0.1
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 
 			retry.UntilSuccessOrFail(t, func() error {
 				// we should expect an empty array not nil
diff --git a/tests/integration/pilot/cni/cniversionskew_test.go b/tests/integration/pilot/cni/cniversionskew_test.go
index 596deb03d8..6762c912a7 100644
--- a/tests/integration/pilot/cni/cniversionskew_test.go
+++ b/tests/integration/pilot/cni/cniversionskew_test.go
@@ -114,5 +114,5 @@ func installCNIOrFail(t framework.TestContext, ver string) {
 	if err != nil {
 		t.Fatalf("Failed to read CNI manifest %v", err)
 	}
-	t.ConfigIstio().YAML(config).ApplyOrFail(t, "")
+	t.ConfigIstio().YAML("", config).ApplyOrFail(t)
 }
diff --git a/tests/integration/pilot/common/apps.go b/tests/integration/pilot/common/apps.go
index eab94a7aa9..7931ca08ec 100644
--- a/tests/integration/pilot/common/apps.go
+++ b/tests/integration/pilot/common/apps.go
@@ -264,7 +264,7 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 		apps.DeltaXDS = match.ServiceName(model.NamespacedName{Name: DeltaSvc, Namespace: apps.Namespace.Name()}).GetMatches(echos)
 	}
 
-	if err := t.ConfigIstio().YAML(`
+	if err := t.ConfigIstio().YAML(apps.Namespace.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: Sidecar
 metadata:
@@ -274,7 +274,7 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
   - hosts:
     - "./*"
     - "istio-system/*"
-`).Apply(apps.Namespace.Name(), resource.NoCleanup); err != nil {
+`).Apply(resource.NoCleanup); err != nil {
 		return err
 	}
 
@@ -307,7 +307,7 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 	if err != nil {
 		return err
 	}
-	if err := t.ConfigIstio().YAML(se).Apply(apps.Namespace.Name(), resource.NoCleanup); err != nil {
+	if err := t.ConfigIstio().YAML(apps.Namespace.Name(), se).Apply(resource.NoCleanup); err != nil {
 		return err
 	}
 	return nil
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index 706e0df8d8..f599641d05 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -138,7 +138,7 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 				}
 				cfg := yml.MustApplyNamespace(t, tmpl.MustEvaluate(c.config, tmplData), namespace)
 				// we only apply to config clusters
-				return t.ConfigIstio().YAML(cfg).Apply("")
+				return t.ConfigIstio().YAML("", cfg).Apply()
 			}).
 			WithDefaultFilters().
 			FromMatch(match.And(c.sourceMatchers...)).
@@ -210,7 +210,7 @@ func (c TrafficTestCase) Run(t framework.TestContext, namespace string) {
 		if len(c.config) > 0 {
 			cfg := yml.MustApplyNamespace(t, c.config, namespace)
 			// we only apply to config clusters
-			t.ConfigIstio().YAML(cfg).ApplyOrFail(t, "")
+			t.ConfigIstio().YAML("", cfg).ApplyOrFail(t)
 		}
 
 		if c.call != nil && len(c.children) > 0 {
diff --git a/tests/integration/pilot/cross_revision_test.go b/tests/integration/pilot/cross_revision_test.go
index 0114aefba6..2c6263048d 100644
--- a/tests/integration/pilot/cross_revision_test.go
+++ b/tests/integration/pilot/cross_revision_test.go
@@ -58,7 +58,7 @@ func TestRevisionTraffic(t *testing.T) {
 				})
 			}
 			// Allow all namespaces so we do not hit passthrough cluster
-			t.ConfigIstio().YAML(`apiVersion: networking.istio.io/v1alpha3
+			t.ConfigIstio().YAML(apps.Namespace.Name(), `apiVersion: networking.istio.io/v1alpha3
 kind: Sidecar
 metadata:
   name: allow-cross-namespaces
@@ -68,7 +68,7 @@ func TestRevisionTraffic(t *testing.T) {
       app: a
   egress:
   - hosts:
-    - "*/*"`).ApplyOrFail(t, apps.Namespace.Name())
+    - "*/*"`).ApplyOrFail(t)
 			// create an echo instance in each revisioned namespace, all these echo
 			// instances will be injected with proxies from their respective versions
 			builder := deployment.New(t).WithClusters(t.Clusters()...)
diff --git a/tests/integration/pilot/grpc_probe_test.go b/tests/integration/pilot/grpc_probe_test.go
index 664d588254..c07be02a3e 100644
--- a/tests/integration/pilot/grpc_probe_test.go
+++ b/tests/integration/pilot/grpc_probe_test.go
@@ -18,7 +18,6 @@
 package pilot
 
 import (
-	"fmt"
 	"testing"
 	"time"
 
@@ -39,15 +38,14 @@ func TestGRPCProbe(t *testing.T) {
 
 			ns := namespace.NewOrFail(t, t, namespace.Config{Prefix: "grpc-probe", Inject: true})
 			// apply strict mtls
-			t.ConfigKube().YAML(fmt.Sprintf(`
+			t.ConfigKube().YAML(ns.Name(), `
 apiVersion: security.istio.io/v1beta1
 kind: PeerAuthentication
 metadata:
   name: grpc-probe-mtls
-  namespace: %s
 spec:
   mtls:
-    mode: STRICT`, ns.Name())).ApplyOrFail(t, ns.Name())
+    mode: STRICT`).ApplyOrFail(t)
 
 			for _, testCase := range []struct {
 				name     string
diff --git a/tests/integration/pilot/gw_topology_test.go b/tests/integration/pilot/gw_topology_test.go
index c8783daf5b..096c38f90a 100644
--- a/tests/integration/pilot/gw_topology_test.go
+++ b/tests/integration/pilot/gw_topology_test.go
@@ -48,7 +48,7 @@ func TestXFFGateway(t *testing.T) {
 			}
 
 			// we only apply to config clusters
-			t.ConfigIstio().Eval(templateParams, `apiVersion: v1
+			t.ConfigIstio().Eval(gatewayNs.Name(), templateParams, `apiVersion: v1
 kind: Service
 metadata:
   name: custom-gateway
@@ -90,7 +90,7 @@ func TestXFFGateway(t *testing.T) {
         image: auto
         imagePullPolicy: {{ .imagePullPolicy }}
 ---
-`).ApplyOrFail(t, gatewayNs.Name())
+`).ApplyOrFail(t)
 			cs := t.Clusters().Default().(*kubecluster.Cluster)
 			retry.UntilSuccessOrFail(t, func() error {
 				_, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(cs, gatewayNs.Name(), "istio=ingressgateway"))
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index e0ea3860bc..3ae3a63a5a 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -57,7 +57,7 @@ func TestGateway(t *testing.T) {
 			if !supportsCRDv1(t) {
 				t.Skip("Not supported; requires CRDv1 support.")
 			}
-			if err := t.ConfigIstio().File("testdata/gateway-api-crd.yaml").Apply("", resource.NoCleanup); err != nil {
+			if err := t.ConfigIstio().File("", "testdata/gateway-api-crd.yaml").Apply(resource.NoCleanup); err != nil {
 				t.Fatal(err)
 			}
 			ingressutil.CreateIngressKubeSecret(t, "test-gateway-cert-same", ingressutil.TLS, ingressutil.IngressCredentialA,
@@ -66,7 +66,7 @@ func TestGateway(t *testing.T) {
 				false, t.Clusters().Configs()...)
 
 			retry.UntilSuccessOrFail(t, func() error {
-				err := t.ConfigIstio().YAML(fmt.Sprintf(`
+				err := t.ConfigIstio().YAML("", fmt.Sprintf(`
 apiVersion: gateway.networking.k8s.io/v1alpha2
 kind: GatewayClass
 metadata:
@@ -123,11 +123,11 @@ func TestGateway(t *testing.T) {
       certificateRefs:
       - kind: Secret
         name: test-gateway-cert-same
----`, apps.Namespace.Name())).Apply("")
+---`, apps.Namespace.Name())).Apply()
 				return err
 			}, retry.Delay(time.Second*10), retry.Timeout(time.Second*90))
 			retry.UntilSuccessOrFail(t, func() error {
-				err := t.ConfigIstio().YAML(`
+				err := t.ConfigIstio().YAML(apps.Namespace.Name(), `
 apiVersion: gateway.networking.k8s.io/v1alpha2
 kind: HTTPRoute
 metadata:
@@ -184,7 +184,7 @@ func TestGateway(t *testing.T) {
     backendRefs:
     - name: b
       port: 80
-`).Apply(apps.Namespace.Name())
+`).Apply()
 				return err
 			}, retry.Delay(time.Second*10), retry.Timeout(time.Second*90))
 			for _, ingr := range apps.Ingresses {
@@ -244,7 +244,7 @@ func TestGateway(t *testing.T) {
 				})
 			}
 			t.NewSubTest("managed").Run(func(t framework.TestContext) {
-				t.ConfigIstio().YAML(`apiVersion: gateway.networking.k8s.io/v1alpha2
+				t.ConfigIstio().YAML(apps.Namespace.Name(), `apiVersion: gateway.networking.k8s.io/v1alpha2
 kind: Gateway
 metadata:
   name: gateway
@@ -267,7 +267,7 @@ func TestGateway(t *testing.T) {
   - backendRefs:
     - name: b
       port: 80
-`).ApplyOrFail(t, apps.Namespace.Name())
+`).ApplyOrFail(t)
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
 					Port:   echo.Port{ServicePort: 80},
 					Scheme: scheme.HTTP,
@@ -563,9 +563,9 @@ func TestIngress(t *testing.T) {
 					for _, c := range cases {
 						c := c
 						t.NewSubTest(c.name).Run(func(t framework.TestContext) {
-							if err := t.ConfigIstio().YAML(ingressClassConfig,
+							if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 								fmt.Sprintf(ingressConfigTemplate, "ingress", "istio-test", c.path, c.path, c.prefixPath)).
-								Apply(apps.Namespace.Name()); err != nil {
+								Apply(); err != nil {
 								t.Fatal(err)
 							}
 							c.call.Retry.Options = []retry.Option{
@@ -582,9 +582,9 @@ func TestIngress(t *testing.T) {
 				if !t.Environment().(*kube.Environment).Settings().LoadBalancerSupported {
 					t.Skip("ingress status not supported without load balancer")
 				}
-				if err := t.ConfigIstio().YAML(ingressClassConfig,
+				if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 					fmt.Sprintf(ingressConfigTemplate, "ingress", "istio-test", "/test", "/test", "/test")).
-					Apply(apps.Namespace.Name()); err != nil {
+					Apply(); err != nil {
 					t.Fatal(err)
 				}
 
@@ -628,9 +628,9 @@ func TestIngress(t *testing.T) {
 
 			// setup another ingress pointing to a different route; the ingress will have an ingress class that should be targeted at first
 			const updateIngressName = "update-test-ingress"
-			if err := t.ConfigIstio().YAML(ingressClassConfig,
+			if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 				fmt.Sprintf(ingressConfigTemplate, updateIngressName, "istio-test", "/update-test", "/update-test", "/update-test")).
-				Apply(apps.Namespace.Name()); err != nil {
+				Apply(); err != nil {
 				t.Fatal(err)
 			}
 			// these cases make sure that when new Ingress configs are applied our controller picks up on them
@@ -697,7 +697,7 @@ func TestIngress(t *testing.T) {
 			for _, c := range ingressUpdateCases {
 				c := c
 				updatedIngress := fmt.Sprintf(ingressConfigTemplate, updateIngressName, c.ingressClass, c.path, c.path, c.path)
-				t.ConfigIstio().YAML(updatedIngress).ApplyOrFail(t, apps.Namespace.Name())
+				t.ConfigIstio().YAML(apps.Namespace.Name(), updatedIngress).ApplyOrFail(t)
 				t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 					c.call.Retry.Options = []retry.Option{retry.Timeout(time.Minute)}
 					apps.Ingress.CallOrFail(t, c.call)
@@ -726,7 +726,7 @@ func TestCustomGateway(t *testing.T) {
 
 			t.NewSubTest("minimal").Run(func(t framework.TestContext) {
 				gatewayNs := namespace.NewOrFail(t, t, namespace.Config{Prefix: "custom-gateway-minimal"})
-				_ = t.ConfigIstio().Eval(templateParams, `apiVersion: v1
+				_ = t.ConfigIstio().Eval(gatewayNs.Name(), templateParams, `apiVersion: v1
 kind: Service
 metadata:
   name: custom-gateway
@@ -795,7 +795,7 @@ func TestCustomGateway(t *testing.T) {
         host: {{ .host }}
         port:
           number: 80
-`).Apply(gatewayNs.Name(), resource.NoCleanup)
+`).Apply(resource.NoCleanup)
 				cs := t.Clusters().Default().(*kubecluster.Cluster)
 				retry.UntilSuccessOrFail(t, func() error {
 					_, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(cs, gatewayNs.Name(), "istio=custom"))
@@ -843,7 +843,7 @@ func TestCustomGateway(t *testing.T) {
 					_, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(cs, gatewayNs.Name(), "istio=custom-gateway-helm"))
 					return err
 				}, retry.Timeout(time.Minute*2), retry.Delay(time.Millisecond*500))
-				_ = t.ConfigIstio().YAML(fmt.Sprintf(`apiVersion: networking.istio.io/v1alpha3
+				_ = t.ConfigIstio().YAML(gatewayNs.Name(), fmt.Sprintf(`apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
   name: app
@@ -873,7 +873,7 @@ func TestCustomGateway(t *testing.T) {
         host: %s
         port:
           number: 80
-`, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(gatewayNs.Name(), resource.NoCleanup)
+`, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
 					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
@@ -910,7 +910,7 @@ func TestCustomGateway(t *testing.T) {
 					_, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(cs, gatewayNs.Name(), "istio=helm-simple"))
 					return err
 				}, retry.Timeout(time.Minute*2), retry.Delay(time.Millisecond*500))
-				_ = t.ConfigIstio().YAML(fmt.Sprintf(`apiVersion: networking.istio.io/v1alpha3
+				_ = t.ConfigIstio().YAML(gatewayNs.Name(), fmt.Sprintf(`apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
 metadata:
   name: app
@@ -940,7 +940,7 @@ func TestCustomGateway(t *testing.T) {
         host: %s
         port:
           number: 80
-`, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(gatewayNs.Name(), resource.NoCleanup)
+`, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
 					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
diff --git a/tests/integration/pilot/istioctl_test.go b/tests/integration/pilot/istioctl_test.go
index 07d0193546..480682fbc4 100644
--- a/tests/integration/pilot/istioctl_test.go
+++ b/tests/integration/pilot/istioctl_test.go
@@ -73,7 +73,7 @@ func TestWait(t *testing.T) {
 				Prefix: "default",
 				Inject: true,
 			})
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
 metadata:
@@ -86,7 +86,7 @@ func TestWait(t *testing.T) {
   - route:
     - destination: 
         host: reviews
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{Cluster: t.Clusters().Default()})
 			istioCtl.InvokeOrFail(t, []string{"x", "wait", "-v", "VirtualService", "reviews." + ns.Name()})
 		})
@@ -146,7 +146,7 @@ func TestDescribe(t *testing.T) {
 	framework.NewTest(t).Features("usability.observability.describe").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			t.ConfigIstio().File("testdata/a.yaml").ApplyOrFail(t, apps.Namespace.Name())
+			t.ConfigIstio().File(apps.Namespace.Name(), "testdata/a.yaml").ApplyOrFail(t)
 
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 
@@ -474,8 +474,8 @@ func TestAuthZCheck(t *testing.T) {
 	framework.NewTest(t).Features("usability.observability.authz-check").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			t.ConfigIstio().File("testdata/authz-a.yaml").ApplyOrFail(t, apps.Namespace.Name())
-			t.ConfigIstio().File("testdata/authz-b.yaml").ApplyOrFail(t, i.Settings().SystemNamespace)
+			t.ConfigIstio().File(apps.Namespace.Name(), "testdata/authz-a.yaml").ApplyOrFail(t)
+			t.ConfigIstio().File(i.Settings().SystemNamespace, "testdata/authz-b.yaml").ApplyOrFail(t)
 
 			gwPod, err := i.IngressFor(t.Clusters().Default()).PodID(0)
 			if err != nil {
diff --git a/tests/integration/pilot/locality_test.go b/tests/integration/pilot/locality_test.go
index 6823ea7bbd..dcad009290 100644
--- a/tests/integration/pilot/locality_test.go
+++ b/tests/integration/pilot/locality_test.go
@@ -210,7 +210,7 @@ func TestLocality(t *testing.T) {
 				t.NewSubTest(tt.name).Run(func(t framework.TestContext) {
 					hostname := fmt.Sprintf("%s-fake-locality.example.com", strings.ToLower(strings.ReplaceAll(tt.name, "/", "-")))
 					tt.input.Host = hostname
-					t.ConfigIstio().YAML(runTemplate(t, localityTemplate, tt.input)).ApplyOrFail(t, apps.Namespace.Name())
+					t.ConfigIstio().YAML(apps.Namespace.Name(), runTemplate(t, localityTemplate, tt.input)).ApplyOrFail(t)
 					sendTrafficOrFail(t, apps.PodA[0], hostname, tt.expected)
 				})
 			}
diff --git a/tests/integration/pilot/mcs/common/common.go b/tests/integration/pilot/mcs/common/common.go
index 42ae285f83..d71ab92560 100644
--- a/tests/integration/pilot/mcs/common/common.go
+++ b/tests/integration/pilot/mcs/common/common.go
@@ -78,11 +78,11 @@ func InstallMCSCRDs(t resource.Context) error {
 
 			// Add/Update the CRD in this cluster...
 			if t.Settings().NoCleanup {
-				if err := t.ConfigKube(c).YAML(crdYAML).Apply("", resource.NoCleanup); err != nil {
+				if err := t.ConfigKube(c).YAML("", crdYAML).Apply(resource.NoCleanup); err != nil {
 					return err
 				}
 			} else {
-				if err := t.ConfigKube(c).YAML(crdYAML).Apply(""); err != nil {
+				if err := t.ConfigKube(c).YAML("", crdYAML).Apply(); err != nil {
 					return err
 				}
 			}
diff --git a/tests/integration/pilot/mirror_test.go b/tests/integration/pilot/mirror_test.go
index 56ed711024..e471dacecd 100644
--- a/tests/integration/pilot/mirror_test.go
+++ b/tests/integration/pilot/mirror_test.go
@@ -138,7 +138,7 @@ func runMirrorTest(t *testing.T, options mirrorTestOptions) {
 					}
 
 					// we only apply to config clusters
-					t.ConfigIstio().EvalFile(vsc, "testdata/traffic-mirroring-template.yaml").ApplyOrFail(t, apps.Namespace.Name())
+					t.ConfigIstio().EvalFile(apps.Namespace.Name(), vsc, "testdata/traffic-mirroring-template.yaml").ApplyOrFail(t)
 
 					for _, podA := range apps.PodA {
 						podA := podA
diff --git a/tests/integration/pilot/multi_version_revision_test.go b/tests/integration/pilot/multi_version_revision_test.go
index e9821fd3c6..58c983bdf2 100644
--- a/tests/integration/pilot/multi_version_revision_test.go
+++ b/tests/integration/pilot/multi_version_revision_test.go
@@ -69,7 +69,7 @@ func TestMultiVersionRevision(t *testing.T) {
 			configs := make(map[string]string)
 			t.ConditionalCleanup(func() {
 				for _, config := range configs {
-					_ = t.ConfigIstio().YAML(config).Delete("istio-system")
+					_ = t.ConfigIstio().YAML("istio-system", config).Delete()
 				}
 			})
 
@@ -169,7 +169,7 @@ func installRevisionOrFail(t framework.TestContext, version string, configs map[
 		t.Fatalf("could not read installation config: %v", err)
 	}
 	configs[version] = config
-	if err := t.ConfigIstio().YAML(config).Apply(i.Settings().SystemNamespace, resource.NoCleanup); err != nil {
+	if err := t.ConfigIstio().YAML(i.Settings().SystemNamespace, config).Apply(resource.NoCleanup); err != nil {
 		t.Fatal(err)
 	}
 }
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index 8e33a28542..ad839e9c00 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -109,7 +109,7 @@ func(t framework.TestContext) {
         subset: {{ .Config.Cluster.Name }}
 {{- end }}
 `, map[string]interface{}{"src": sources, "dst": to, "host": to.Config().ClusterLocalFQDN()})
-						t.ConfigIstio().YAML(cfg).ApplyOrFail(t, sources.Config().Namespace.Name())
+						t.ConfigIstio().YAML(sources.Config().Namespace.Name(), cfg).ApplyOrFail(t)
 					},
 				},
 			}
@@ -207,11 +207,11 @@ func TestBadRemoteSecret(t *testing.T) {
 					return err
 				}, retry.Timeout(15*time.Second))
 
-				t.ConfigKube().YAML(secret).ApplyOrFail(t, ns)
+				t.ConfigKube().YAML(ns, secret).ApplyOrFail(t)
 			}
 			// Test exec auth
 			// CreateRemoteSecret can never generate this, so create it manually
-			t.ConfigIstio().YAML(`apiVersion: v1
+			t.ConfigIstio().YAML(ns, `apiVersion: v1
 kind: Secret
 metadata:
   annotations:
@@ -241,7 +241,7 @@ func TestBadRemoteSecret(t *testing.T) {
           command: /bin/sh
           args: ["-c", "hello world!"]
 ---
-`).ApplyOrFail(t, ns)
+`).ApplyOrFail(t)
 
 			// create a new istiod pod using the template from the deployment, but not managed by the deployment
 			t.Logf("creating pod %s/%s", ns, pod)
diff --git a/tests/integration/pilot/proxyconfig/proxyconfig_test.go b/tests/integration/pilot/proxyconfig/proxyconfig_test.go
index 066dc8e24a..bf268bbcc0 100644
--- a/tests/integration/pilot/proxyconfig/proxyconfig_test.go
+++ b/tests/integration/pilot/proxyconfig/proxyconfig_test.go
@@ -205,7 +205,7 @@ func checkInjectedValues(t framework.TestContext, instances echo.Instances, valu
 
 func applyProxyConfigs(ctx framework.TestContext, configs []proxyConfigInstance) {
 	for _, config := range configs {
-		ctx.ConfigIstio().YAML(config.config).ApplyOrFail(ctx, config.namespace)
+		ctx.ConfigIstio().YAML(config.namespace, config.config).ApplyOrFail(ctx)
 	}
 	// TODO(Monkeyanator) give a few seconds for PC to propagate
 	// shouldn't be required but multicluster seems to have some issues with echo instance restart.
@@ -214,7 +214,7 @@ func applyProxyConfigs(ctx framework.TestContext, configs []proxyConfigInstance)
 
 func deleteProxyConfigs(ctx framework.TestContext, configs []proxyConfigInstance) {
 	for _, config := range configs {
-		ctx.ConfigIstio().YAML(config.config).DeleteOrFail(ctx, config.namespace)
+		ctx.ConfigIstio().YAML(config.namespace, config.config).DeleteOrFail(ctx)
 	}
 }
 
diff --git a/tests/integration/pilot/revisioned_upgrade_test.go b/tests/integration/pilot/revisioned_upgrade_test.go
index 093f3dfb1f..4da4a1381c 100644
--- a/tests/integration/pilot/revisioned_upgrade_test.go
+++ b/tests/integration/pilot/revisioned_upgrade_test.go
@@ -71,7 +71,7 @@ func testUpgradeFromVersion(t framework.TestContext, fromVersion string) {
 	configs := make(map[string]string)
 	t.ConditionalCleanup(func() {
 		for _, config := range configs {
-			_ = t.ConfigIstio().YAML(config).Delete("istio-system")
+			_ = t.ConfigIstio().YAML("istio-system", config).Delete()
 		}
 	})
 
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 9259c97611..6697da8915 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -59,11 +59,11 @@ func TestAuthorization_mTLS(t *testing.T) {
 			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			for _, to := range []echo.Instances{b, vm} {
 				to := to
-				t.ConfigIstio().EvalFile(map[string]string{
+				t.ConfigIstio().EvalFile(apps.Namespace1.Name(), map[string]string{
 					"Namespace":  apps.Namespace1.Name(),
 					"Namespace2": apps.Namespace2.Name(),
 					"dst":        to.Config().Service,
-				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, apps.Namespace1.Name(), resource.Wait)
+				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				for _, cluster := range t.Clusters() {
 					a := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
@@ -130,7 +130,7 @@ func TestAuthorization_JWT(t *testing.T) {
 					"Namespace2": apps.Namespace2.Name(),
 					"dst":        dst[0].Config().Service,
 				}
-				t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-jwt.yaml.tmpl").ApplyOrFail(t, ns.Name(), resource.Wait)
+				t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-jwt.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 				for _, srcCluster := range t.Clusters() {
 					a := match.And(match.Cluster(srcCluster), match.Namespace(ns.Name())).GetMatches(apps.A)
 					if len(a) == 0 {
@@ -264,13 +264,13 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 
 				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					applyPolicy := func(filename string, ns namespace.Instance) {
-						t.ConfigIstio().EvalFile(map[string]string{
+						t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 							"Namespace1":    ns1.Name(),
 							"Namespace2":    ns2.Name(),
 							"RootNamespace": rootns.Name(),
 							"b":             util.BSvc,
 							"c":             util.CSvc,
-						}, filename).ApplyOrFail(t, ns.Name(), resource.Wait)
+						}, filename).ApplyOrFail(t, resource.Wait)
 					}
 					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
 					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
@@ -310,13 +310,13 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 				// TODO(JimmyCYJ): Support multiple VMs in different namespaces for workload selector test and set c to service on VM.
 				t.NewSubTestf("VM From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					applyPolicy := func(filename string, ns namespace.Instance) {
-						t.ConfigIstio().EvalFile(map[string]string{
+						t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 							"Namespace1":    ns1.Name(),
 							"Namespace2":    ns2.Name(),
 							"RootNamespace": rootns.Name(),
 							"b":             util.VMSvc, // This is the only difference from standard args.
 							"c":             util.CSvc,
-						}, filename).ApplyOrFail(t, ns.Name(), resource.Wait)
+						}, filename).ApplyOrFail(t, resource.Wait)
 					}
 					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
 					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
@@ -355,13 +355,13 @@ func TestAuthorization_Deny(t *testing.T) {
 			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 
 			applyPolicy := func(filename string, ns namespace.Instance) {
-				t.ConfigIstio().EvalFile(map[string]string{
+				t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 					"Namespace":     ns.Name(),
 					"RootNamespace": rootns.Name(),
 					"b":             b[0].Config().Service,
 					"c":             c[0].Config().Service,
 					"vm":            vm[0].Config().Service,
-				}, filename).ApplyOrFail(t, ns.Name(), resource.Wait)
+				}, filename).ApplyOrFail(t, resource.Wait)
 			}
 			applyPolicy("testdata/authz/v1beta1-deny.yaml.tmpl", ns)
 			applyPolicy("testdata/authz/v1beta1-deny-ns-root.yaml.tmpl", rootns)
@@ -446,14 +446,14 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
 			d := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.D)
 			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
-			t.ConfigIstio().EvalFile(map[string]string{
+			t.ConfigIstio().EvalFile("", map[string]string{
 				"Namespace":  ns.Name(),
 				"Namespace2": ns2.Name(),
 				"b":          b[0].Config().Service,
 				"c":          c[0].Config().Service,
 				"d":          d[0].Config().Service,
 				"vm":         vm[0].Config().Service,
-			}, "testdata/authz/v1beta1-negative-match.yaml.tmpl").ApplyOrFail(t, "")
+			}, "testdata/authz/v1beta1-negative-match.yaml.tmpl").ApplyOrFail(t)
 
 			for _, srcCluster := range t.Clusters() {
 				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
@@ -558,11 +558,11 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			for _, dst := range []echo.Instances{b, vm} {
 				t.NewSubTestf("to %s/", dst[0].Config().Service).Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile("", map[string]string{
 						"Namespace":     ns.Name(),
 						"RootNamespace": rootns.Name(),
 						"dst":           dst[0].Config().Service,
-					}, "testdata/authz/v1beta1-ingress-gateway.yaml.tmpl").ApplyOrFail(t, "")
+					}, "testdata/authz/v1beta1-ingress-gateway.yaml.tmpl").ApplyOrFail(t)
 
 					ingr := ist.IngressFor(t.Clusters().Default())
 
@@ -747,11 +747,11 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 			// services running on a VM.
 			for _, a := range []echo.Instances{a, vm} {
 				t.NewSubTestf("to %s/", a[0].Config().Service).Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile("", map[string]string{
 						"Namespace":     ns.Name(),
 						"RootNamespace": rootns.Name(),
 						"a":             a[0].Config().Service,
-					}, "testdata/authz/v1beta1-egress-gateway.yaml.tmpl").ApplyOrFail(t, "")
+					}, "testdata/authz/v1beta1-egress-gateway.yaml.tmpl").ApplyOrFail(t)
 
 					cases := []struct {
 						name  string
@@ -921,7 +921,7 @@ func TestAuthorization_TCP(t *testing.T) {
 			e := match.Namespace(ns.Name()).GetMatches(apps.E)
 			t.NewSubTest("non-vms").
 				Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile("", map[string]string{
 						"Namespace":  ns.Name(),
 						"Namespace2": ns2.Name(),
 						"b":          b[0].Config().Service,
@@ -929,7 +929,7 @@ func TestAuthorization_TCP(t *testing.T) {
 						"d":          d[0].Config().Service,
 						"e":          e[0].Config().Service,
 						"a":          a[0].Config().Service,
-					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t, "")
+					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t)
 
 					cases := []func(testContext framework.TestContext){
 						// The policy on workload b denies request with path "/data" to port 8091:
@@ -985,7 +985,7 @@ func TestAuthorization_TCP(t *testing.T) {
 			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
 			t.NewSubTest("vms").
 				Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile("", map[string]string{
 						"Namespace":  ns.Name(),
 						"Namespace2": ns2.Name(),
 						"b":          b[0].Config().Service,
@@ -993,7 +993,7 @@ func TestAuthorization_TCP(t *testing.T) {
 						"d":          d[0].Config().Service,
 						"e":          e[0].Config().Service,
 						"a":          a[0].Config().Service,
-					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t, "")
+					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t)
 					cases := []func(testContext framework.TestContext){
 						// The policy on workload vm denies request to port 8091:
 						// - request to port http-8091 should be denied because the port is matched.
@@ -1062,7 +1062,7 @@ func TestAuthorization_Conditions(t *testing.T) {
 								"b":          util.BSvc,
 							}
 
-							t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-conditions.yaml.tmpl").ApplyOrFail(t, "")
+							t.ConfigIstio().EvalFile("", args, "testdata/authz/v1beta1-conditions.yaml.tmpl").ApplyOrFail(t)
 							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							newTestCase := func(from echo.Instance, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
@@ -1180,7 +1180,7 @@ func TestAuthorization_GRPC(t *testing.T) {
 								"c":         c[0].Config().Service,
 								"d":         d[0].Config().Service,
 							}
-							t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-grpc.yaml.tmpl").ApplyOrFail(t, ns.Name(), resource.Wait)
+							t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-grpc.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 							newTestCase := func(from echo.Instance, to echo.Target, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -1238,7 +1238,7 @@ func TestAuthorization_Path(t *testing.T) {
 							"Namespace": ns.Name(),
 							"a":         a[0].Config().Service,
 						}
-						t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-path.yaml.tmpl").ApplyOrFail(t, ns.Name(), resource.Wait)
+						t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-path.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 
 						newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
 							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
@@ -1302,22 +1302,22 @@ func TestAuthorization_Audit(t *testing.T) {
 
 			policy := func(filename string) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 						"b":             b[0].Config().Service,
 						"c":             c[0].Config().Service,
 						"d":             d[0].Config().Service,
 						"Namespace":     ns.Name(),
 						"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
-					}, filename).ApplyOrFail(t, ns.Name(), resource.Wait)
+					}, filename).ApplyOrFail(t, resource.Wait)
 				}
 			}
 
 			vmPolicy := func(filename string) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(map[string]string{
+					t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 						"Namespace": ns.Name(),
 						"dst":       vm[0].Config().Service,
-					}, filename).ApplyOrFail(t, ns.Name(), resource.Wait)
+					}, filename).ApplyOrFail(t, resource.Wait)
 				}
 			}
 
@@ -1391,7 +1391,7 @@ func TestAuthorization_Custom(t *testing.T) {
 			}
 
 			// Deploy and wait for the ext-authz server to be ready.
-			t.ConfigIstio().EvalFile(args, "../../../samples/extauthz/ext-authz.yaml").ApplyOrFail(t, ns.Name())
+			t.ConfigIstio().EvalFile(ns.Name(), args, "../../../samples/extauthz/ext-authz.yaml").ApplyOrFail(t)
 			if _, _, err := kube.WaitUntilServiceEndpointsAreReady(t.Clusters().Default(), ns.Name(), "ext-authz"); err != nil {
 				t.Fatalf("Wait for ext-authz server failed: %v", err)
 			}
@@ -1431,7 +1431,7 @@ func TestAuthorization_Custom(t *testing.T) {
     service: ext-authz-grpc.local
     port: 9000`, extService, extServiceWithNs))
 
-			t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-custom.yaml.tmpl").ApplyOrFail(t, "")
+			t.ConfigIstio().EvalFile("", args, "testdata/authz/v1beta1-custom.yaml.tmpl").ApplyOrFail(t)
 			ports := []echo.Port{
 				{
 					Name:         "tcp-8092",
diff --git a/tests/integration/security/ca_custom_root/multi_root_test.go b/tests/integration/security/ca_custom_root/multi_root_test.go
index cf89d185cb..98ab84cdc7 100644
--- a/tests/integration/security/ca_custom_root/multi_root_test.go
+++ b/tests/integration/security/ca_custom_root/multi_root_test.go
@@ -35,7 +35,7 @@ func TestMultiRootSetup(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			testNS := apps.Namespace
 
-			t.ConfigIstio().YAML(POLICY).ApplyOrFail(t, testNS.Name())
+			t.ConfigIstio().YAML(testNS.Name(), POLICY).ApplyOrFail(t)
 
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 07038da752..6fcde22cdf 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -171,7 +171,7 @@ func TestSecureNaming(t *testing.T) {
 						t.NewSubTest(tc.name).
 							Run(func(t framework.TestContext) {
 								dr := strings.ReplaceAll(tc.destinationRule, "NS", testNamespace.Name())
-								t.ConfigIstio().YAML(dr).ApplyOrFail(t, testNamespace.Name())
+								t.ConfigIstio().YAML(testNamespace.Name(), dr).ApplyOrFail(t)
 								// Verify mTLS works between a and b
 								opts := echo.CallOptions{
 									To: to,
diff --git a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
index baf83c6213..27c2c389c7 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
@@ -75,7 +75,7 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 			}
 			testNS := apps.Namespace
 
-			t.ConfigIstio().YAML(POLICY).ApplyOrFail(t, testNS.Name())
+			t.ConfigIstio().YAML(testNS.Name(), POLICY).ApplyOrFail(t)
 
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index d88fd1fb16..795c5ab3f5 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -102,7 +102,7 @@ func(ctx framework.TestContext) {
 
 			testNS := apps.Namespace
 
-			ctx.ConfigIstio().YAML(fmt.Sprintf(policy, testNS.Name())).ApplyOrFail(ctx, testNS.Name())
+			ctx.ConfigIstio().YAML(testNS.Name(), fmt.Sprintf(policy, testNS.Name())).ApplyOrFail(ctx)
 
 			trustDomains := map[string]struct {
 				cert string
diff --git a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
index 2e145df86f..435fd8899e 100644
--- a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
+++ b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
@@ -63,8 +63,8 @@ func TestStrictMTLS(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace.Name()
 			args := map[string]string{"AppNamespace": ns}
-			t.ConfigIstio().Eval(args, PeerAuthenticationConfig).ApplyOrFail(t, ns, resource.Wait)
-			t.ConfigIstio().Eval(args, DestinationRuleConfigIstioMutual).ApplyOrFail(t, ns, resource.Wait)
+			t.ConfigIstio().Eval(ns, args, PeerAuthenticationConfig).ApplyOrFail(t, resource.Wait)
+			t.ConfigIstio().Eval(ns, args, DestinationRuleConfigIstioMutual).ApplyOrFail(t, resource.Wait)
 
 			apps.Client.CallOrFail(t, echo.CallOptions{
 				To: apps.Server,
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 6ecc1f13cd..119cc776f0 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -303,7 +303,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 func CreateGateway(t test.Failer, ctx resource.Context, clientNamespace namespace.Instance, to echo.Instances) {
 	args := map[string]interface{}{"to": to}
 
-	ctx.ConfigIstio().Eval(args, Gateway, VirtualService).ApplyOrFail(t, clientNamespace.Name())
+	ctx.ConfigIstio().Eval(clientNamespace.Name(), args, Gateway, VirtualService).ApplyOrFail(t)
 }
 
 const (
@@ -339,7 +339,7 @@ func CreateDestinationRule(t framework.TestContext, to echo.Instances,
 	istioCfg := istio.DefaultConfigOrFail(t, t)
 	systemNS := namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
 
-	t.ConfigKube(t.Clusters().Default()).Eval(args, DestinationRuleConfig).ApplyOrFail(t, systemNS.Name())
+	t.ConfigKube(t.Clusters().Default()).Eval(systemNS.Name(), args, DestinationRuleConfig).ApplyOrFail(t)
 }
 
 type TLSTestCase struct {
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index 149c3189ad..cf32aa664d 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -102,7 +102,7 @@ func TestClientToServiceTls(t *testing.T) {
 
 func createObject(ctx framework.TestContext, serviceNamespace string, yamlManifest string) {
 	args := map[string]string{"AppNamespace": serviceNamespace}
-	ctx.ConfigIstio().Eval(args, yamlManifest).ApplyOrFail(ctx, serviceNamespace)
+	ctx.ConfigIstio().Eval(serviceNamespace, args, yamlManifest).ApplyOrFail(ctx)
 }
 
 // setupEcho creates an `istio-fd-sds` namespace and brings up two echo instances server and
diff --git a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
index f860d2b538..98057a765b 100644
--- a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
+++ b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
@@ -54,7 +54,7 @@ func TestDestinationRuleTls(t *testing.T) {
 			})
 
 			// Setup our destination rule, enforcing TLS to "server". These certs will be created/mounted below.
-			t.ConfigIstio().YAML(`
+			t.ConfigIstio().YAML(ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
 kind: DestinationRule
 metadata:
@@ -68,7 +68,7 @@ func TestDestinationRuleTls(t *testing.T) {
       clientCertificate: /etc/certs/custom/cert-chain.pem
       privateKey: /etc/certs/custom/key.pem
       caCertificates: /etc/certs/custom/root-cert.pem
-`).ApplyOrFail(t, ns.Name())
+`).ApplyOrFail(t)
 
 			var client, server echo.Instance
 			deployment.New(t).
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index ed33516269..39a02f7d04 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -126,7 +126,7 @@ func TestEgressGatewayTls(t *testing.T) {
 						istioCfg := istio.DefaultConfigOrFail(t, t)
 						systemNamespace := namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
 
-						t.ConfigIstio().YAML(bufDestinationRule.String()).ApplyOrFail(t, systemNamespace.Name())
+						t.ConfigIstio().YAML(systemNamespace.Name(), bufDestinationRule.String()).ApplyOrFail(t)
 
 						opts := echo.CallOptions{
 							To: externalServer,
@@ -401,7 +401,7 @@ func createGateway(t test.Failer, ctx resource.Context, appsNamespace namespace.
 	if err := tmplGateway.Execute(&bufGateway, map[string]string{"ServerNamespace": serviceNamespace.Name()}); err != nil {
 		t.Fatalf("failed to create template: %v", err)
 	}
-	if err := ctx.ConfigIstio().YAML(bufGateway.String()).Apply(appsNamespace.Name()); err != nil {
+	if err := ctx.ConfigIstio().YAML(appsNamespace.Name(), bufGateway.String()).Apply(); err != nil {
 		t.Fatalf("failed to apply gateway: %v. template: %v", err, bufGateway.String())
 	}
 
@@ -418,7 +418,7 @@ func createGateway(t test.Failer, ctx resource.Context, appsNamespace namespace.
 	if err := tmplVS.Execute(&bufVS, map[string]string{"ServerNamespace": serviceNamespace.Name()}); err != nil {
 		t.Fatalf("failed to create template: %v", err)
 	}
-	if err := ctx.ConfigIstio().YAML(bufVS.String()).Apply(appsNamespace.Name()); err != nil {
+	if err := ctx.ConfigIstio().YAML(appsNamespace.Name(), bufVS.String()).Apply(); err != nil {
 		t.Fatalf("failed to apply virtualservice: %v. template: %v", err, bufVS.String())
 	}
 }
diff --git a/tests/integration/security/fuzz/fuzz_test.go b/tests/integration/security/fuzz/fuzz_test.go
index dbbe317809..a711aa9273 100644
--- a/tests/integration/security/fuzz/fuzz_test.go
+++ b/tests/integration/security/fuzz/fuzz_test.go
@@ -94,7 +94,7 @@
 )
 
 func deploy(t framework.TestContext, name, ns, yaml string) {
-	t.ConfigIstio().File(yaml).ApplyOrFail(t, ns)
+	t.ConfigIstio().File(ns, yaml).ApplyOrFail(t)
 	if _, err := kube.WaitUntilPodsAreReady(kube.NewPodFetch(t.Clusters().Default(), ns, "app="+name)); err != nil {
 		t.Fatalf("Wait for pod %s failed: %v", name, err)
 	}
@@ -216,11 +216,11 @@ func TestFuzzAuthorization(t *testing.T) {
 			ns := "fuzz-authz"
 			namespace.ClaimOrFail(t, t, ns)
 
-			t.ConfigIstio().YAML(authzDenyPolicy).ApplyOrFail(t, ns)
+			t.ConfigIstio().YAML(ns, authzDenyPolicy).ApplyOrFail(t)
 			t.Logf("authorization policy applied")
 
 			deploy(t, dotdotpwn, ns, "fuzzers/dotdotpwn/dotdotpwn.yaml")
-			t.ConfigIstio().File("fuzzers/wfuzz/wordlist.yaml").ApplyOrFail(t, ns)
+			t.ConfigIstio().File(ns, "fuzzers/wfuzz/wordlist.yaml").ApplyOrFail(t)
 			deploy(t, wfuzz, ns, "fuzzers/wfuzz/wfuzz.yaml")
 
 			deploy(t, apacheServer, ns, "backends/apache/apache.yaml")
@@ -301,7 +301,7 @@ func TestRequestAuthentication(t *testing.T) {
 			ns := "fuzz-jwt"
 			namespace.ClaimOrFail(t, t, ns)
 
-			t.ConfigIstio().YAML(requestAuthnPolicy).ApplyOrFail(t, ns)
+			t.ConfigIstio().YAML(ns, requestAuthnPolicy).ApplyOrFail(t)
 			t.Logf("request authentication policy applied")
 
 			// We don't care about the actual backend for JWT test, one backend is good enough.
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index bc6f79a195..4c7050b7ab 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -50,9 +50,9 @@ func TestJWTHTTPS(t *testing.T) {
 			ns := apps.Namespace1
 			istioSystemNS := istio.ClaimSystemNamespaceOrFail(t, t)
 
-			t.ConfigKube().EvalFile(map[string]string{
+			t.ConfigKube().EvalFile(istioSystemNS.Name(), map[string]string{
 				"Namespace": istioSystemNS.Name(),
-			}, filepath.Join(env.IstioSrc, "samples/jwt-server", "jwt-server.yaml")).ApplyOrFail(t, istioSystemNS.Name())
+			}, filepath.Join(env.IstioSrc, "samples/jwt-server", "jwt-server.yaml")).ApplyOrFail(t)
 
 			for _, cluster := range t.AllClusters() {
 				fetchFn := kube.NewSinglePodFetch(cluster, istioSystemNS.Name(), "app=jwt-server")
@@ -98,8 +98,8 @@ func TestJWTHTTPS(t *testing.T) {
 								"Namespace": ns.Name(),
 								"dst":       to.Config().Service,
 							}
-							return t.ConfigIstio().EvalFile(args, c.policyFile).
-								Apply(ns.Name(), resource.Wait)
+							return t.ConfigIstio().EvalFile(ns.Name(), args, c.policyFile).
+								Apply(resource.Wait)
 						}).
 						FromMatch(
 							// TODO(JimmyCYJ): enable VM for all test cases.
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index b99ef3b634..97afa65652 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -46,9 +46,9 @@ func TestRequestAuthentication(t *testing.T) {
 		Features("security.authentication.jwt").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			t.ConfigKube().EvalFile(map[string]string{
+			t.ConfigKube().EvalFile(ns.Name(), map[string]string{
 				"Namespace": ns.Name(),
-			}, "../../../samples/jwt-server/jwt-server.yaml").ApplyOrFail(t, ns.Name())
+			}, "../../../samples/jwt-server/jwt-server.yaml").ApplyOrFail(t)
 
 			type testCase struct {
 				name          string
@@ -64,7 +64,7 @@ type testCase struct {
 									"Namespace": ns.Name(),
 									"dst":       to.Config().Service,
 								}
-								return t.ConfigIstio().EvalFile(args, policy).Apply(ns.Name(), resource.Wait)
+								return t.ConfigIstio().EvalFile(ns.Name(), args, policy).Apply(resource.Wait)
 							}
 							return nil
 						}).
@@ -395,10 +395,10 @@ func TestIngressRequestAuthentication(t *testing.T) {
 			ns := apps.Namespace1
 
 			// Apply the policy.
-			t.ConfigIstio().EvalFile(map[string]string{
+			t.ConfigIstio().EvalFile(newRootNS(t).Name(), map[string]string{
 				"Namespace":     ns.Name(),
 				"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
-			}, "testdata/requestauthn/global-jwt.yaml.tmpl").ApplyOrFail(t, newRootNS(t).Name(), resource.Wait)
+			}, "testdata/requestauthn/global-jwt.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 
 			type testCase struct {
 				name          string
@@ -414,7 +414,7 @@ type testCase struct {
 									"Namespace": ns.Name(),
 									"dst":       to.Config().Service,
 								}
-								return t.ConfigIstio().EvalFile(args, policy).Apply(ns.Name(), resource.Wait)
+								return t.ConfigIstio().EvalFile(ns.Name(), args, policy).Apply(resource.Wait)
 							}
 							return nil
 						}).
@@ -466,10 +466,10 @@ type testCase struct {
 
 			t.NewSubTest("ingress-authn").Run(func(t framework.TestContext) {
 				// TODO(JimmyCYJ): add workload-agnostic test pattern to support ingress gateway tests.
-				t.ConfigIstio().EvalFile(map[string]string{
+				t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
 					"Namespace": ns.Name(),
 					"dst":       util.BSvc,
-				}, "testdata/requestauthn/ingress.yaml.tmpl").ApplyOrFail(t, ns.Name())
+				}, "testdata/requestauthn/ingress.yaml.tmpl").ApplyOrFail(t)
 
 				for _, cluster := range t.Clusters() {
 					ingr := ist.IngressFor(cluster)
diff --git a/tests/integration/security/mtls_healthcheck_test.go b/tests/integration/security/mtls_healthcheck_test.go
index c2a20fb582..88e577e2f5 100644
--- a/tests/integration/security/mtls_healthcheck_test.go
+++ b/tests/integration/security/mtls_healthcheck_test.go
@@ -66,7 +66,7 @@ func runHealthCheckDeployment(ctx framework.TestContext, ns namespace.Instance,
   mtls:
     mode: STRICT
 `, name, name)
-	ctx.ConfigIstio().YAML(policyYAML).ApplyOrFail(ctx, ns.Name())
+	ctx.ConfigIstio().YAML(ns.Name(), policyYAML).ApplyOrFail(ctx)
 
 	var healthcheck echo.Instance
 	cfg := echo.Config{
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 206df240e4..1a077f5f80 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -616,7 +616,7 @@ type expect struct {
 									"IP": to.WorkloadsOrFail(t)[0].Address(),
 								},
 							), ns.Name())
-							return t.ConfigIstio().YAML(cfg, fakesvc).Apply(ns.Name())
+							return t.ConfigIstio().YAML(ns.Name(), cfg, fakesvc).Apply()
 						}).
 						FromMatch(srcMatcher).
 						ConditionallyTo(echotest.ReachableDestinations).
diff --git a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
index 4d70e37962..57dda03e53 100644
--- a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
+++ b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
@@ -93,7 +93,7 @@ func doIstioMutualTest(
 	deployment.New(ctx).
 		With(&client, util.EchoConfig("client", ns, false, nil)).
 		BuildOrFail(ctx)
-	ctx.ConfigIstio().File(configPath).ApplyOrFail(ctx, ns.Name())
+	ctx.ConfigIstio().File(ns.Name(), configPath).ApplyOrFail(ctx)
 
 	// give the configuration a moment to kick in
 	time.Sleep(time.Second * 20)
@@ -133,7 +133,7 @@ func applySetupConfig(ctx framework.TestContext, ns namespace.Instance) {
 	}
 
 	for _, c := range configFiles {
-		if err := ctx.ConfigIstio().File(c).Apply(ns.Name()); err != nil {
+		if err := ctx.ConfigIstio().File(ns.Name(), c).Apply(); err != nil {
 			ctx.Fatalf("failed to apply configuration file %s; err: %v", c, err)
 		}
 	}
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index db5948ecec..fbbb490ff3 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -482,7 +482,7 @@ func SetupConfig(ctx framework.TestContext, ns namespace.Instance, config ...Tes
 	for _, c := range config {
 		apply = append(apply, runTemplate(ctx, vsTemplate, c), runTemplate(ctx, gwTemplate, c))
 	}
-	ctx.ConfigIstio().YAML(apply...).ApplyOrFail(ctx, ns.Name())
+	ctx.ConfigIstio().YAML(ns.Name(), apply...).ApplyOrFail(ctx)
 }
 
 // RunTestMultiMtlsGateways deploys multiple mTLS gateways with SDS enabled, and creates kubernetes secret that stores
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 03f168bcf2..fb782896f7 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -110,11 +110,11 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 			}
 
 			// Apply the policy.
-			cfg := t.ConfigIstio().File(filepath.Join("./testdata", c.ConfigFile))
+			cfg := t.ConfigIstio().File(c.Namespace.Name(), filepath.Join("./testdata", c.ConfigFile))
 			retry.UntilSuccessOrFail(t, func() error {
 				t.Logf("[%s] [%v] Apply config %s", testName, time.Now(), c.ConfigFile)
 				// TODO(https://github.com/istio/istio/issues/20460) We shouldn't need a retry loop
-				return cfg.Apply(c.Namespace.Name(), resource.Wait)
+				return cfg.Apply(resource.Wait)
 			})
 			for _, clients := range []echo.Instances{apps.A, match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B), apps.Headless, apps.Naked, apps.HeadlessNaked} {
 				for _, from := range clients {
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index 92ce62c04f..c1c5582433 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -178,7 +178,7 @@ func (t TrafficPolicy) String() string {
 // we can import only the service namespace, so the apps are not known
 func createSidecarScope(t framework.TestContext, tPolicy TrafficPolicy, appsNamespace namespace.Instance, serviceNamespace namespace.Instance) {
 	args := map[string]string{"ImportNamespace": serviceNamespace.Name(), "TrafficPolicyMode": tPolicy.String()}
-	if err := t.ConfigIstio().Eval(args, SidecarScope).Apply(appsNamespace.Name()); err != nil {
+	if err := t.ConfigIstio().Eval(appsNamespace.Name(), args, SidecarScope).Apply(); err != nil {
 		t.Errorf("failed to apply service entries: %v", err)
 	}
 }
@@ -197,7 +197,7 @@ func mustReadCert(t framework.TestContext, f string) string {
 func createGateway(t framework.TestContext, appsNamespace namespace.Instance, serviceNamespace namespace.Instance) {
 	t.Helper()
 	b := tmpl.EvaluateOrFail(t, Gateway, map[string]string{"AppNamespace": appsNamespace.Name()})
-	if err := t.ConfigIstio().YAML(b).Apply(serviceNamespace.Name()); err != nil {
+	if err := t.ConfigIstio().YAML(serviceNamespace.Name(), b).Apply(); err != nil {
 		t.Fatalf("failed to apply gateway: %v. template: %v", err, b)
 	}
 }
@@ -359,7 +359,7 @@ func setupEcho(t framework.TestContext, mode TrafficPolicy) (echo.Instance, echo
 			},
 		}).BuildOrFail(t)
 
-	if err := t.ConfigIstio().YAML(ServiceEntry).Apply(serviceNamespace.Name()); err != nil {
+	if err := t.ConfigIstio().YAML(serviceNamespace.Name(), ServiceEntry).Apply(); err != nil {
 		t.Errorf("failed to apply service entries: %v", err)
 	}
 
diff --git a/tests/integration/telemetry/policy/envoy_ratelimit_test.go b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
index d7948fff15..733a9cb663 100644
--- a/tests/integration/telemetry/policy/envoy_ratelimit_test.go
+++ b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
@@ -144,12 +144,12 @@ func testSetup(ctx resource.Context) (err error) {
 		return
 	}
 
-	err = ctx.ConfigIstio().File("testdata/rate-limit-configmap.yaml").Apply(ratelimitNs.Name())
+	err = ctx.ConfigIstio().File(ratelimitNs.Name(), "testdata/rate-limit-configmap.yaml").Apply()
 	if err != nil {
 		return
 	}
 
-	err = ctx.ConfigIstio().File(filepath.Join(env.IstioSrc, "samples/ratelimit/rate-limit-service.yaml")).Apply(ratelimitNs.Name())
+	err = ctx.ConfigIstio().File(ratelimitNs.Name(), filepath.Join(env.IstioSrc, "samples/ratelimit/rate-limit-service.yaml")).Apply()
 	if err != nil {
 		return
 	}
@@ -181,12 +181,12 @@ func setupEnvoyFilter(ctx framework.TestContext, file string) func() {
 		ctx.Fatal(err)
 	}
 
-	err = ctx.ConfigIstio().YAML(con).Apply(ist.Settings().SystemNamespace)
+	err = ctx.ConfigIstio().YAML(ist.Settings().SystemNamespace, con).Apply()
 	if err != nil {
 		ctx.Fatal(err)
 	}
 	return func() {
-		ctx.ConfigIstio().YAML(con).DeleteOrFail(ctx, ist.Settings().SystemNamespace)
+		ctx.ConfigIstio().YAML(ist.Settings().SystemNamespace, con).DeleteOrFail(ctx)
 	}
 }
 
diff --git a/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go b/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
index 85e84b8b61..9b1345c9b3 100644
--- a/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
@@ -105,7 +105,7 @@ func TestMain(m *testing.M) {
 			if err != nil {
 				return err
 			}
-			return ctx.ConfigIstio().YAML(`
+			return ctx.ConfigIstio().YAML(i.Settings().SystemNamespace, `
 apiVersion: telemetry.istio.io/v1alpha1
 kind: Telemetry
 metadata:
@@ -118,7 +118,7 @@ func TestMain(m *testing.M) {
   metrics:
   - providers:
     - name: stackdriver
-`).Apply(i.Settings().SystemNamespace)
+`).Apply()
 		}).
 		Setup(stackdrivertest.TestSetup).
 		Run()
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index 9dcc91bc9a..8be96a9eb7 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -88,11 +88,11 @@ func TestSetup(ctx resource.Context) (err error) {
 		return
 	}
 
-	err = ctx.ConfigKube().EvalFile(map[string]interface{}{
+	err = ctx.ConfigKube().EvalFile(EchoNsInst.Name(), map[string]interface{}{
 		"StackdriverAddress": SDInst.Address(),
 		"EchoNamespace":      EchoNsInst.Name(),
 		"UseRealSD":          stackdriver.UseRealStackdriver(),
-	}, filepath.Join(env.IstioSrc, stackdriverBootstrapOverride)).Apply(EchoNsInst.Name())
+	}, filepath.Join(env.IstioSrc, stackdriverBootstrapOverride)).Apply()
 	if err != nil {
 		return
 	}
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
index 6e74e0268d..96f0405429 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
@@ -56,7 +56,7 @@ func TestStackdriverHTTPAuditLogging(t *testing.T) {
 			args := map[string]string{
 				"Namespace": ns,
 			}
-			t.ConfigIstio().EvalFile(args, filepath.Join(env.IstioSrc, auditPolicyForLogEntry)).ApplyOrFail(t, ns)
+			t.ConfigIstio().EvalFile(ns, args, filepath.Join(env.IstioSrc, auditPolicyForLogEntry)).ApplyOrFail(t)
 			t.Logf("Audit policy deployed to namespace %v", ns)
 
 			for _, cltInstance := range Clt {
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
index 063d318592..fa2026b718 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
@@ -197,7 +197,7 @@ func createDryRunPolicy(t framework.TestContext, authz string) {
 	t.Helper()
 	ns := EchoNsInst.Name()
 	args := map[string]string{"Namespace": ns}
-	t.ConfigIstio().EvalFile(args, authz).ApplyOrFail(t, ns, resource.Wait)
+	t.ConfigIstio().EvalFile(ns, args, authz).ApplyOrFail(t, resource.Wait)
 }
 
 func verifyAccessLog(t framework.TestContext, cltInstance echo.Instance, wantLog string) error {
diff --git a/tests/integration/telemetry/stackdriver/vm/main_test.go b/tests/integration/telemetry/stackdriver/vm/main_test.go
index e2f64edc5a..3ed872ba2d 100644
--- a/tests/integration/telemetry/stackdriver/vm/main_test.go
+++ b/tests/integration/telemetry/stackdriver/vm/main_test.go
@@ -171,10 +171,10 @@ func testSetup(ctx resource.Context) error {
 	}
 	sdtest.SDInst = sdInst
 
-	if err = ctx.ConfigKube().EvalFile(map[string]interface{}{
+	if err = ctx.ConfigKube().EvalFile(ns.Name(), map[string]interface{}{
 		"StackdriverAddress": sdInst.Address(),
 		"EchoNamespace":      ns.Name(),
-	}, stackdriverBootstrapOverride).Apply(ns.Name()); err != nil {
+	}, stackdriverBootstrapOverride).Apply(); err != nil {
 		return err
 	}
 
diff --git a/tests/integration/telemetry/stackdriver/vm/vm_test.go b/tests/integration/telemetry/stackdriver/vm/vm_test.go
index 38d33907e8..ac082e305a 100644
--- a/tests/integration/telemetry/stackdriver/vm/vm_test.go
+++ b/tests/integration/telemetry/stackdriver/vm/vm_test.go
@@ -44,7 +44,7 @@ func TestVMTelemetry(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			// Set up strict mTLS. This gives a bit more assurance the calls are actually going through envoy,
 			// and certs are set up correctly.
-			t.ConfigIstio().YAML(enforceMTLS).ApplyOrFail(t, ns.Name())
+			t.ConfigIstio().YAML(ns.Name(), enforceMTLS).ApplyOrFail(t)
 
 			clientBuilder.BuildOrFail(t)
 			serverBuilder.BuildOrFail(t)
diff --git a/tests/integration/telemetry/stats/prometheus/api/stats_wasm_filter_test.go b/tests/integration/telemetry/stats/prometheus/api/stats_wasm_filter_test.go
index 0590c9dc49..53d2149179 100644
--- a/tests/integration/telemetry/stats/prometheus/api/stats_wasm_filter_test.go
+++ b/tests/integration/telemetry/stats/prometheus/api/stats_wasm_filter_test.go
@@ -46,7 +46,7 @@ func TestMain(m *testing.M) {
 			if err != nil {
 				return err
 			}
-			return ctx.ConfigIstio().YAML(`
+			return ctx.ConfigIstio().YAML(i.Settings().SystemNamespace, `
 apiVersion: telemetry.istio.io/v1alpha1
 kind: Telemetry
 metadata:
@@ -55,7 +55,7 @@ func TestMain(m *testing.M) {
   metrics:
   - providers:
     - name: prometheus
-`).Apply(i.Settings().SystemNamespace)
+`).Apply()
 		}).
 		Setup(common.TestSetup).
 		Run()
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index c7d90affa2..2893a93b2f 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -217,7 +217,7 @@ func setupEnvoyFilter(ctx resource.Context) error {
 		"WasmRemoteLoad":  useRemoteWasmModule,
 		"AttributeGenURL": attrGenURL,
 	}
-	if err := ctx.ConfigIstio().EvalFile(args, "testdata/attributegen_envoy_filter.yaml").Apply(appNsInst.Name()); err != nil {
+	if err := ctx.ConfigIstio().EvalFile(appNsInst.Name(), args, "testdata/attributegen_envoy_filter.yaml").Apply(); err != nil {
 		return err
 	}
 
@@ -239,7 +239,7 @@ func setupEnvoyFilter(ctx resource.Context) error {
             - regex: "(custom_dimension=\\.=(.*?);\\.;)"
               tag_name: "custom_dimension"
 `
-	if err := ctx.ConfigIstio().YAML(bootstrapPatch).Apply("istio-system", resource.Wait); err != nil {
+	if err := ctx.ConfigIstio().YAML("istio-system", bootstrapPatch).Apply(resource.Wait); err != nil {
 		return err
 	}
 	return nil
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
index f71876fcff..907847d0c6 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
@@ -69,7 +69,7 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
   accessLogging:
   - disabled: %v
 `, !expectLogs)
-	t.ConfigIstio().YAML(config).ApplyOrFail(t, common.GetAppNamespace().Name())
+	t.ConfigIstio().YAML(common.GetAppNamespace().Name(), config).ApplyOrFail(t)
 	testID := rand.String(16)
 	to := common.GetTarget()
 	callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
index 3fe258e80b..8f98fc0460 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
@@ -138,15 +138,15 @@ func TestDashboard(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			p := common.GetPromInstance()
 
-			t.ConfigIstio().YAML(fmt.Sprintf(gatewayConfig, common.GetAppNamespace().Name())).
-				ApplyOrFail(t, common.GetAppNamespace().Name())
+			t.ConfigIstio().YAML(common.GetAppNamespace().Name(), fmt.Sprintf(gatewayConfig, common.GetAppNamespace().Name())).
+				ApplyOrFail(t)
 
 			// Apply just the grafana dashboards
 			cfg, err := os.ReadFile(filepath.Join(env.IstioSrc, "samples/addons/grafana.yaml"))
 			if err != nil {
 				t.Fatal(err)
 			}
-			t.ConfigKube().YAML(yml.SplitYamlByKind(string(cfg))["ConfigMap"]).ApplyOrFail(t, "istio-system")
+			t.ConfigKube().YAML("istio-system", yml.SplitYamlByKind(string(cfg))["ConfigMap"]).ApplyOrFail(t)
 
 			// We will send a bunch of requests until the test exits. This ensures we are continuously
 			// getting new metrics ingested. If we just send a bunch at once, Prometheus may scrape them
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index ca34e3e215..0038291627 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -98,7 +98,7 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {
 		Features(feature).
 		Run(func(t framework.TestContext) {
 			// Enable strict mTLS. This is needed for mock secured prometheus scraping test.
-			t.ConfigIstio().YAML(PeerAuthenticationConfig).ApplyOrFail(t, ist.Settings().SystemNamespace)
+			t.ConfigIstio().YAML(ist.Settings().SystemNamespace, PeerAuthenticationConfig).ApplyOrFail(t)
 			g, _ := errgroup.WithContext(context.Background())
 			for _, cltInstance := range client {
 				cltInstance := cltInstance
diff --git a/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go b/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
index 46fdab41a3..cb6aff4536 100644
--- a/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
+++ b/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
@@ -51,7 +51,7 @@ func TestBadWasmRemoteLoad(t *testing.T) {
 			t.Log("echo server returns OK, apply bad wasm remote load filter.")
 
 			// Apply bad filter config
-			t.ConfigIstio().File("testdata/bad-filter.yaml").ApplyOrFail(t, common.GetAppNamespace().Name())
+			t.ConfigIstio().File(common.GetAppNamespace().Name(), "testdata/bad-filter.yaml").ApplyOrFail(t)
 
 			// Wait until there is agent metrics for wasm download failure
 			retry.UntilSuccessOrFail(t, func() error {
-- 
2.35.3

