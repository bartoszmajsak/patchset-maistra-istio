From ab32b266c72e99adfd7c24212df4fb05368b486f Mon Sep 17 00:00:00 2001
From: Wenhao Li <69884412+liwenhao0810@users.noreply.github.com>
Date: Mon, 22 Nov 2021 16:23:04 -0800
Subject: Istioctl x describe add PeerAuthentication debug info (#36062)

* add describe peerauthentication

* show workload pa when no root ns access

* istio lint fix

* lint fix

* default mtls mode and format config printing

* error when no access to root ns and simplify print config

* use root namespace

* lint fix

* add revision support and print updates
---
 istioctl/cmd/describe.go                      | 133 ++++++++++++++++++
 istioctl/cmd/kubeinject.go                    |   1 +
 .../security/authn/v1beta1/policy_applier.go  |   6 +-
 .../authn/v1beta1/policy_applier_test.go      |   2 +-
 4 files changed, 138 insertions(+), 4 deletions(-)

diff --git a/istioctl/cmd/describe.go b/istioctl/cmd/describe.go
index 1a1b890cf7..f32a2b7592 100644
--- a/istioctl/cmd/describe.go
+++ b/istioctl/cmd/describe.go
@@ -36,21 +36,28 @@
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 	"k8s.io/client-go/kubernetes"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/api/networking/v1alpha3"
+	"istio.io/api/security/v1beta1"
+	typev1beta1 "istio.io/api/type/v1beta1"
 	clientnetworking "istio.io/client-go/pkg/apis/networking/v1alpha3"
 	istioclient "istio.io/client-go/pkg/clientset/versioned"
 	"istio.io/istio/istioctl/pkg/clioptions"
+	"istio.io/istio/istioctl/pkg/tag"
 	"istio.io/istio/istioctl/pkg/util/configdump"
 	"istio.io/istio/istioctl/pkg/util/handlers"
 	istio_envoy_configdump "istio.io/istio/istioctl/pkg/writer/envoy/configdump"
+	"istio.io/istio/pilot/pkg/config/kube/crdclient"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
+	authnv1beta1 "istio.io/istio/pilot/pkg/security/authn/v1beta1"
 	authz_model "istio.io/istio/pilot/pkg/security/authz/model"
 	pilotcontroller "istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/inject"
@@ -143,6 +150,13 @@ func podDescribeCmd() *cobra.Command {
 				return err
 			}
 
+			// render PeerAuthentication info
+			fmt.Fprintf(writer, "--------------------\n")
+			err = describePeerAuthentication(writer, kubeClient, configClient, ns, k8s_labels.Set(pod.ObjectMeta.Labels))
+			if err != nil {
+				return err
+			}
+
 			// TODO find sidecar configs that select this workload and render them
 
 			// Now look for ingress gateways
@@ -1186,3 +1200,122 @@ func containerReady(pod *v1.Pod, containerName string) (bool, error) {
 	}
 	return false, fmt.Errorf("no container %q in pod", containerName)
 }
+
+// describePeerAuthentication fetches all PeerAuthentication in workload and root namespace.
+// It lists the ones applied to the pod, and the current active mTLS mode.
+// When the client doesn't have access to root namespace, it will only show workload namespace Peerauthentications.
+func describePeerAuthentication(writer io.Writer, kubeClient kube.ExtendedClient, configClient istioclient.Interface, workloadNamespace string, podsLabels k8s_labels.Set) error { // nolint: lll
+	meshCfg, err := getMeshConfig(kubeClient)
+	if err != nil {
+		return fmt.Errorf("failed to fetch mesh config: %v", err)
+	}
+
+	workloadPAList, err := configClient.SecurityV1beta1().PeerAuthentications(workloadNamespace).List(context.Background(), metav1.ListOptions{})
+	if err != nil {
+		return fmt.Errorf("failed to fetch workload namespace PeerAuthentication: %v", err)
+	}
+
+	rootPAList, err := configClient.SecurityV1beta1().PeerAuthentications(meshCfg.RootNamespace).List(context.Background(), metav1.ListOptions{})
+	if err != nil {
+		return fmt.Errorf("failed to fetch root namespace PeerAuthentication: %v", err)
+	}
+
+	allPAs := append(rootPAList.Items, workloadPAList.Items...)
+
+	var cfgs []*config.Config
+	for _, pa := range allPAs {
+		pa := pa
+		cfg := crdclient.TranslateObject(&pa, config.GroupVersionKind(pa.GroupVersionKind()), "")
+		cfgs = append(cfgs, &cfg)
+	}
+
+	matchedPA := findMatchedConfigs(podsLabels, cfgs)
+	effectivePA := authnv1beta1.ComposePeerAuthentication(meshCfg.RootNamespace, matchedPA)
+	printPeerAuthentication(writer, effectivePA)
+	if len(matchedPA) != 0 {
+		printConfigs(writer, matchedPA)
+	}
+
+	return nil
+}
+
+// Workloader is used for matching all configs
+type Workloader interface {
+	GetSelector() *typev1beta1.WorkloadSelector
+}
+
+// findMatchedConfigs should filter out unrelated configs that are not matched given podsLabels.
+// When the config has no selector labels, this method will treat it as qualified namespace level
+// config. So configs passed into this method should only contains workload's namespaces configs
+// and rootNamespaces configs, caller should be responsible for controlling configs passed
+// in.
+func findMatchedConfigs(podsLabels k8s_labels.Set, configs []*config.Config) []*config.Config {
+	var cfgs []*config.Config
+
+	for _, cfg := range configs {
+		cfg := cfg
+		labels := cfg.Spec.(Workloader).GetSelector().GetMatchLabels()
+		selector := k8s_labels.SelectorFromSet(labels)
+		if selector.Matches(podsLabels) {
+			cfgs = append(cfgs, cfg)
+		}
+	}
+
+	return cfgs
+}
+
+// printConfig prints the applied configs based on the member's type.
+// When there is the array is empty, caller should make sure the intended
+// log is handled in their methods.
+func printConfigs(writer io.Writer, configs []*config.Config) {
+	if len(configs) == 0 {
+		return
+	}
+	fmt.Fprintf(writer, "Applied %s:\n", configs[0].Meta.GroupVersionKind.Kind)
+	var cfgNames string
+	for i, cfg := range configs {
+		cfgNames += cfg.Meta.Name + "." + cfg.Meta.Namespace
+		if i < len(configs)-1 {
+			cfgNames += ", "
+		}
+	}
+	fmt.Fprintf(writer, "   %s\n", cfgNames)
+}
+
+func printPeerAuthentication(writer io.Writer, pa *v1beta1.PeerAuthentication) {
+	fmt.Fprintf(writer, "Effectve PeerAuthentication:\n")
+	fmt.Fprintf(writer, "   Workload mTLS: %s\n", pa.Mtls.Mode.String())
+	if len(pa.PortLevelMtls) != 0 {
+		fmt.Fprintf(writer, "   Port Level mTLS:\n")
+		for port, mode := range pa.PortLevelMtls {
+			fmt.Fprintf(writer, "      %d: %s\n", port, mode.Mode.String())
+		}
+	}
+}
+
+func getMeshConfig(kubeClient kube.ExtendedClient) (*meshconfig.MeshConfig, error) {
+	rev := kubeClient.Revision()
+	meshConfigMapName := defaultMeshConfigMapName
+
+	// if the revision is not "default", render mesh config map name with revision
+	if rev != tag.DefaultRevisionName && rev != "" {
+		meshConfigMapName = fmt.Sprintf("%s-%s", defaultMeshConfigMapName, rev)
+	}
+
+	meshConfigMap, err := kubeClient.CoreV1().ConfigMaps(istioNamespace).Get(context.TODO(), meshConfigMapName, metav1.GetOptions{})
+	if err != nil {
+		return nil, fmt.Errorf("could not read configmap %q from namespace %q: %v", meshConfigMapName, istioNamespace, err)
+	}
+
+	configYaml, ok := meshConfigMap.Data[defaultMeshConfigMapKey]
+	if !ok {
+		return nil, fmt.Errorf("missing config map key %q", defaultMeshConfigMapKey)
+	}
+
+	cfg, err := mesh.ApplyMeshConfigDefaults(configYaml)
+	if err != nil {
+		return nil, fmt.Errorf("error parsing mesh config: %v", err)
+	}
+
+	return cfg, nil
+}
diff --git a/istioctl/cmd/kubeinject.go b/istioctl/cmd/kubeinject.go
index f2d4d844a4..05a18f178a 100644
--- a/istioctl/cmd/kubeinject.go
+++ b/istioctl/cmd/kubeinject.go
@@ -426,6 +426,7 @@ func setupKubeInjectParameters(sidecarTemplate *inject.Templates, valuesConfig *
 
 const (
 	defaultMeshConfigMapName       = "istio"
+	defaultMeshConfigMapKey        = "mesh"
 	defaultInjectConfigMapName     = "istio-sidecar-injector"
 	defaultInjectWebhookConfigName = "istio-sidecar-injector"
 	defaultWebhookName             = "sidecar-injector.istio.io"
diff --git a/pilot/pkg/security/authn/v1beta1/policy_applier.go b/pilot/pkg/security/authn/v1beta1/policy_applier.go
index a44f1d762e..d95b1cf0b9 100644
--- a/pilot/pkg/security/authn/v1beta1/policy_applier.go
+++ b/pilot/pkg/security/authn/v1beta1/policy_applier.go
@@ -178,7 +178,7 @@ func NewPolicyApplier(rootNamespace string,
 		jwtPolicies:            jwtPolicies,
 		peerPolices:            peerPolicies,
 		processedJwtRules:      processedJwtRules,
-		consolidatedPeerPolicy: composePeerAuthentication(rootNamespace, peerPolicies),
+		consolidatedPeerPolicy: ComposePeerAuthentication(rootNamespace, peerPolicies),
 		push:                   push,
 	}
 }
@@ -362,7 +362,7 @@ func getMutualTLSMode(mtls *v1beta1.PeerAuthentication_MutualTLS) model.MutualTL
 	return model.ConvertToMutualTLSMode(mtls.Mode)
 }
 
-// composePeerAuthentication returns the effective PeerAuthentication given the list of applicable
+// ComposePeerAuthentication returns the effective PeerAuthentication given the list of applicable
 // configs. This list should contains at most 1 mesh-level and 1 namespace-level configs.
 // Workload-level configs should not be in root namespace (this should be guaranteed by the caller,
 // though they will be safely ignored in this function). If the input config list is empty, returns
@@ -375,7 +375,7 @@ func getMutualTLSMode(mtls *v1beta1.PeerAuthentication_MutualTLS) model.MutualTL
 // - UNSET will be replaced with the setting from the parent. I.e UNSET port-level config will be
 // replaced with config from workload-level, UNSET in workload-level config will be replaced with
 // one in namespace-level and so on.
-func composePeerAuthentication(rootNamespace string, configs []*config.Config) *v1beta1.PeerAuthentication {
+func ComposePeerAuthentication(rootNamespace string, configs []*config.Config) *v1beta1.PeerAuthentication {
 	var meshCfg, namespaceCfg, workloadCfg *config.Config
 
 	// Initial outputPolicy is set to a PERMISSIVE.
diff --git a/pilot/pkg/security/authn/v1beta1/policy_applier_test.go b/pilot/pkg/security/authn/v1beta1/policy_applier_test.go
index 7beedb82eb..9fd535d9e6 100644
--- a/pilot/pkg/security/authn/v1beta1/policy_applier_test.go
+++ b/pilot/pkg/security/authn/v1beta1/policy_applier_test.go
@@ -2048,7 +2048,7 @@ func TestComposePeerAuthentication(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			if got := composePeerAuthentication("root-namespace", tt.configs); !reflect.DeepEqual(got, tt.want) {
+			if got := ComposePeerAuthentication("root-namespace", tt.configs); !reflect.DeepEqual(got, tt.want) {
 				t.Errorf("composePeerAuthentication() = %v, want %v", got, tt.want)
 			}
 		})
-- 
2.35.3

