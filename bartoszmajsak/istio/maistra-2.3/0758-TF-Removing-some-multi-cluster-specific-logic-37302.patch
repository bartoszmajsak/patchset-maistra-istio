From b74603a71ae64d4dca9bc962a747b03b5771d694 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Wed, 9 Mar 2022 08:41:09 -0800
Subject: [TF] Removing some multi-cluster specific logic (#37302)

---
 tests/integration/pilot/common/apps.go        |  4 --
 tests/integration/pilot/common/routing.go     | 21 +++++---
 tests/integration/pilot/common/traffic.go     | 21 +++++---
 tests/integration/pilot/ingress_test.go       |  6 +--
 .../security/authorization_test.go            | 50 ++++---------------
 .../ca_custom_root/secure_naming_test.go      |  6 +--
 .../security/external_ca/reachability_test.go | 13 ++---
 .../security/https_jwt/https_jwt_test.go      |  8 +--
 tests/integration/security/jwt_test.go        | 12 +----
 .../security/util/reachability/context.go     |  7 +--
 10 files changed, 54 insertions(+), 94 deletions(-)

diff --git a/tests/integration/pilot/common/apps.go b/tests/integration/pilot/common/apps.go
index 1f1a78bcd0..13ce5676e7 100644
--- a/tests/integration/pilot/common/apps.go
+++ b/tests/integration/pilot/common/apps.go
@@ -311,10 +311,6 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 	return nil
 }
 
-func (d EchoDeployments) IsMulticluster() bool {
-	return d.All.Clusters().IsMulticluster()
-}
-
 // Restart restarts all echo deployments.
 func (d EchoDeployments) Restart() error {
 	wg := sync.WaitGroup{}
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 7613ec6980..f4bda7b990 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -1505,7 +1505,6 @@ func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
 		cases = append(cases, TrafficTestCase{
 			name:   d[0].Config().Service,
 			config: httpGateway("*") + httpVirtualService("gateway", fqdn, d[0].Config().PortByName("http").ServicePort),
-			skip:   false,
 			call:   apps.Naked[0].CallOrFail,
 			opts: echo.CallOptions{
 				Count:   1,
@@ -2009,7 +2008,10 @@ func(responses echoClient.Responses, rerr error) error {
 				config: svc + tmpl.MustEvaluate(destRule, "useSourceIp: true"),
 				call:   c.CallOrFail,
 				opts:   tcpCallopts,
-				skip:   c.Config().WorkloadClass() == echo.Proxyless,
+				skip: skip{
+					skip:   c.Config().WorkloadClass() == echo.Proxyless,
+					reason: "", // TODO: is this a bug or WAI?
+				},
 			})
 		}
 	}
@@ -2134,8 +2136,10 @@ type protocolCase struct {
 	for _, call := range protocols {
 		call := call
 		cases = append(cases, TrafficTestCase{
-			// TODO(https://github.com/istio/istio/issues/26798) enable sniffing tcp
-			skip: call.scheme == scheme.TCP,
+			skip: skip{
+				skip:   call.scheme == scheme.TCP,
+				reason: "https://github.com/istio/istio/issues/26798: enable sniffing tcp",
+			},
 			name: call.port,
 			opts: echo.CallOptions{
 				Count: 1,
@@ -2692,7 +2696,7 @@ func VMTestCases(vms echo.Instances, apps *EchoDeployments) []TrafficTestCase {
 					Name: "http",
 				},
 				Address: c.host,
-				Count:   callsPerCluster * c.to.MustWorkloads().Clusters().Len(),
+				Count:   callCountMultiplier * c.to.MustWorkloads().Clusters().Len(),
 				Check:   checker,
 			},
 		})
@@ -2819,8 +2823,11 @@ func serverFirstTestCases(apps *EchoDeployments) []TrafficTestCase {
 		for _, c := range configs {
 			client, c := client, c
 			cases = append(cases, TrafficTestCase{
-				name:   fmt.Sprintf("%v:%v/%v", c.port, c.dest, c.auth),
-				skip:   apps.IsMulticluster(), // TODO stabilize tcp connection breaks
+				name: fmt.Sprintf("%v:%v/%v", c.port, c.dest, c.auth),
+				skip: skip{
+					skip:   apps.All.Clusters().IsMulticluster(),
+					reason: "https://github.com/istio/istio/issues/37305: stabilize tcp connection breaks",
+				},
 				config: destinationRule(to.Config().Service, c.dest) + peerAuthentication(to.Config().Service, c.auth),
 				call:   client.CallOrFail,
 				opts: echo.CallOptions{
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index fb6e6d90e8..be411c4718 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -34,8 +34,8 @@
 	"istio.io/istio/pkg/test/util/yml"
 )
 
-// callsPerCluster is used to ensure cross-cluster load balancing has a chance to work
-const callsPerCluster = 5
+// callCountMultiplier is used to ensure cross-cluster load balancing has a chance to work
+const callCountMultiplier = 5
 
 type TrafficCall struct {
 	name string
@@ -43,6 +43,11 @@ type TrafficCall struct {
 	opts echo.CallOptions
 }
 
+type skip struct {
+	skip   bool
+	reason string
+}
+
 type TrafficTestCase struct {
 	name string
 	// config can optionally be templated using the params src, dst (each are []echo.Instance)
@@ -62,7 +67,7 @@ type TrafficTestCase struct {
 	checkForN func(src echo.Caller, dst echo.Services, opts *echo.CallOptions) check.Checker
 
 	// setting cases to skipped is better than not adding them - gives visibility to what needs to be fixed
-	skip bool
+	skip skip
 
 	// workloadAgnostic is a temporary setting to trigger using RunForApps
 	// TODO remove this and force everything to be workoad agnostic
@@ -89,8 +94,8 @@ type TrafficTestCase struct {
 var noProxyless = echotest.Not(echotest.FilterMatch(echo.IsProxylessGRPC()))
 
 func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances, namespace string) {
-	if c.skip {
-		t.SkipNow()
+	if c.skip.skip {
+		t.Skip(c.skip.reason)
 	}
 	if c.minIstioVersion != "" {
 		skipMV := !t.Settings().Revisions.AtLeast(resource.IstioVersion(c.minIstioVersion))
@@ -153,7 +158,7 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 					opts.Check = c.checkForN(from, to, &opts)
 				}
 				if opts.Count == 0 {
-					opts.Count = callsPerCluster * opts.To.WorkloadsOrFail(t).Len()
+					opts.Count = callCountMultiplier * opts.To.WorkloadsOrFail(t).Len()
 				}
 				if c.setupOpts != nil {
 					c.setupOpts(from, &opts)
@@ -194,8 +199,8 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 
 func (c TrafficTestCase) Run(t framework.TestContext, namespace string) {
 	job := func(t framework.TestContext) {
-		if c.skip {
-			t.SkipNow()
+		if c.skip.skip {
+			t.Skip(c.skip.reason)
 		}
 		if c.minIstioVersion != "" {
 			skipMV := !t.Settings().Revisions.AtLeast(resource.IstioVersion(c.minIstioVersion))
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index 25442e86de..124d6cb5b7 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -384,10 +384,8 @@ func TestIngress(t *testing.T) {
 
 			successChecker := check.And(check.OK(), check.ReachedClusters(apps.PodB.Clusters()))
 			failureChecker := check.Status(http.StatusNotFound)
-			count := 1
-			if t.Clusters().IsMulticluster() {
-				count = 2 * len(t.Clusters())
-			}
+			count := 2 * t.Clusters().Len()
+
 			// TODO check all clusters were hit
 			cases := []struct {
 				name       string
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index fead277254..d6cf49fbe0 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -63,11 +63,7 @@ func TestAuthorization_mTLS(t *testing.T) {
 					"Namespace2": apps.Namespace2.Name(),
 					"dst":        to.Config().Service,
 				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, apps.Namespace1.Name(), resource.Wait)
-				callCount := 1
-				if to.Clusters().IsMulticluster() {
-					// so we can validate all clusters are hit
-					callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-				}
+				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				for _, cluster := range t.Clusters() {
 					a := apps.A.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace1.Name())))
 					c := apps.C.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace2.Name())))
@@ -142,11 +138,7 @@ func TestAuthorization_JWT(t *testing.T) {
 
 					t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 						newTestCase := func(from echo.Instance, to echo.Target, namePrefix, jwt, path string, expectAllowed bool) func(t framework.TestContext) {
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
+							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
 									To: to,
@@ -237,11 +229,7 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 
 			newTestCase := func(from echo.Instance, to echo.Target, namePrefix, path string,
 				expectAllowed bool) func(t framework.TestContext) {
-				callCount := 1
-				if t.Clusters().IsMulticluster() {
-					// so we can validate all clusters are hit
-					callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-				}
+				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
 						To: to,
@@ -356,8 +344,6 @@ func TestAuthorization_Deny(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.deny-action").
 		Run(func(t framework.TestContext) {
-			// TODO: Convert into multicluster support. Currently reachability does
-			// not cover all clusters.
 			if t.Clusters().IsMulticluster() {
 				t.Skip("https://github.com/istio/istio/issues/37307")
 			}
@@ -386,11 +372,7 @@ func TestAuthorization_Deny(t *testing.T) {
 
 				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-						callCount := 1
-						if t.Clusters().IsMulticluster() {
-							// so we can validate all clusters are hit
-							callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-						}
+						callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
 								To: to,
@@ -481,11 +463,7 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 
 				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-						callCount := 1
-						if t.Clusters().IsMulticluster() {
-							// so we can validate all clusters are hit
-							callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-						}
+						callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
 								To: to,
@@ -1084,11 +1062,7 @@ func TestAuthorization_Conditions(t *testing.T) {
 							}
 
 							t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-conditions.yaml.tmpl").ApplyOrFail(t, "")
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
+							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							newTestCase := func(from echo.Instance, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -1266,11 +1240,7 @@ func TestAuthorization_Path(t *testing.T) {
 						t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-path.yaml.tmpl").ApplyOrFail(t, ns.Name(), resource.Wait)
 
 						newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
+							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
 									To: to,
@@ -1650,10 +1620,10 @@ func (n rbacTestName) String() string {
 func (n rbacTestName) SkipIfNecessary(t framework.TestContext) {
 	t.Helper()
 
-	// Current source ip based authz test cases are not required in multicluster setup
-	// because cross-network traffic will lose the origin source ip info
 	if strings.Contains(n.String(), "source-ip") && t.Clusters().IsMulticluster() {
-		t.Skip("https://github.com/istio/istio/issues/37307")
+		t.Skip("https://github.com/istio/istio/issues/37307: " +
+			"Current source ip based authz test cases are not required in multicluster setup because " +
+			"cross-network traffic will lose the origin source ip info")
 	}
 }
 
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 70c4cc9105..6ee6ceeb96 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -117,11 +117,7 @@ func TestSecureNaming(t *testing.T) {
 				return checkCACert(t, testNamespace)
 			}, retry.Delay(time.Second), retry.Timeout(10*time.Second))
 			to := apps.B.Match(echo.Namespace(testNamespace.Name()))
-			callCount := 1
-			if t.Clusters().IsMulticluster() {
-				// so we can validate all clusters are hit
-				callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-			}
+			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
 					a := apps.A.Match(echo.InCluster(cluster)).Match(echo.Namespace(testNamespace.Name()))[0]
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index 4b1e6febbd..ac49540fca 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -41,17 +41,18 @@ func TestReachability(t *testing.T) {
 			 * (b) When trust-bundle for workload ISTIO_MUTUAL mtls can be explicitly configured PER Istio Trust Domain
 			 */
 			if t.Clusters().IsMulticluster() {
-				t.Skip()
+				t.Skip("https://github.com/istio/istio/issues/37307: Test cases cannot be run in " +
+					"multi-cluster environments when using per cluster K8s CA Signers. Revisit this when:\n" +
+					"* (a) Test environment can be modified to deploy external-signer common to all clusters " +
+					"in multi-cluster environment OR\n" +
+					"* (b) When trust-bundle for workload ISTIO_MUTUAL mtls can be explicitly configured PER " +
+					"Istio Trust Domain")
 			}
 			istioCfg := istio.DefaultConfigOrFail(t, t)
 			testNamespace := apps.Namespace
 			namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
 			to := apps.B.Match(echo.Namespace(testNamespace.Name()))
-			callCount := 1
-			if t.Clusters().IsMulticluster() {
-				// so we can validate all clusters are hit
-				callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-			}
+			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
 					a := apps.A.Match(echo.InCluster(cluster)).Match(echo.Namespace(testNamespace.Name()))[0]
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 9b560f040c..9b33c98b44 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -107,18 +107,12 @@ func TestJWTHTTPS(t *testing.T) {
 						ConditionallyTo(echotest.ReachableDestinations).
 						To(util.DestFilter(apps, ns.Name(), true)...).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
-
 							opts := echo.CallOptions{
 								To: to,
 								Port: echo.Port{
 									Name: "http",
 								},
-								Count: callCount,
+								Count: util.CallsPerCluster * to.WorkloadsOrFail(t).Len(),
 							}
 
 							c.customizeCall(&opts)
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index d2124aa867..f359c87039 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -73,11 +73,7 @@ type testCase struct {
 						ConditionallyTo(echotest.ReachableDestinations).
 						To(util.DestFilter(apps, ns.Name(), true)...).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
+							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -428,11 +424,7 @@ type testCase struct {
 						}).
 						To(util.DestFilter(apps, ns.Name(), false)...).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
-							callCount := 1
-							if t.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
+							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index c2f38db6b7..a70e072f06 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -102,11 +102,12 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 	for _, c := range testCases {
 		// Create a copy to avoid races, as tests are run in parallel
 		c := c
-		if c.SkippedForMulticluster && t.Clusters().IsMulticluster() {
-			continue
-		}
 		testName := strings.TrimSuffix(c.ConfigFile, filepath.Ext(c.ConfigFile))
 		t.NewSubTest(testName).Run(func(t framework.TestContext) {
+			if c.SkippedForMulticluster && t.Clusters().IsMulticluster() {
+				t.Skip("https://github.com/istio/istio/issues/37307")
+			}
+
 			// Apply the policy.
 			cfg := t.ConfigIstio().File(filepath.Join("./testdata", c.ConfigFile))
 			retry.UntilSuccessOrFail(t, func() error {
-- 
2.35.3

