From e9dcadbb3e8785643f068d6356455d293b72e6c2 Mon Sep 17 00:00:00 2001
From: Pengyuan Bian <bianpengyuan@google.com>
Date: Fri, 1 Apr 2022 12:27:52 -0700
Subject: Implement Wasm pull secret. (#37161)

* Implement Wasm pull secret.

* rn

* ut

* update.

* test.

* tidy

* gen

* update.

* update.

* test.

* Update wasm-secret.yaml

* update.

* fix test.

* lint.

* update

* update.

* integration test.

* update.

* update.

* fix.

* update test.

* gen.

* Add prometheus dump.

* update.

* fix.

* update.

* fix
---
 go.mod                                        |   2 +-
 pilot/pkg/bootstrap/server.go                 |   3 +
 pilot/pkg/credentials/kube/multicluster.go    |  16 ++
 pilot/pkg/credentials/kube/secrets.go         |  17 +-
 pilot/pkg/credentials/kube/secrets_test.go    |  90 +++++--
 pilot/pkg/credentials/model.go                |   5 +-
 pilot/pkg/model/config.go                     |  10 +
 pilot/pkg/model/config_test.go                |  46 ++++
 pilot/pkg/model/credentials/resource.go       |  14 +-
 pilot/pkg/model/extensions.go                 |  77 ++++--
 pilot/pkg/model/extensions_test.go            |  85 ++++++-
 pilot/pkg/model/push_context.go               |   2 +-
 pilot/pkg/model/push_context_test.go          |   4 +-
 pilot/pkg/networking/core/configgen.go        |   3 +-
 .../core/v1alpha3/extension/wasmplugin.go     |  36 ++-
 .../v1alpha3/extension/wasmplugin_test.go     |  34 +--
 .../core/v1alpha3/extension_config_builder.go |   4 +-
 pilot/pkg/xds/debug.go                        |   7 +
 pilot/pkg/xds/ecds.go                         | 142 ++++++++++-
 pilot/pkg/xds/ecds_test.go                    | 238 +++++++++++++++++-
 pilot/pkg/xds/fake.go                         |   1 +
 pilot/pkg/xds/proxy_dependencies.go           |   1 -
 pkg/istio-agent/xds_proxy_test.go             |   5 +-
 pkg/test/kube/dump.go                         |   1 +
 pkg/wasm/cache.go                             |   7 +-
 pkg/wasm/cache_test.go                        |   8 +-
 pkg/wasm/convert.go                           |  26 +-
 pkg/wasm/convert_test.go                      |  58 ++++-
 pkg/wasm/imagefetcher.go                      |  62 ++++-
 pkg/wasm/imagefetcher_test.go                 |  35 ++-
 releasenotes/notes/wasm-secret.yaml           |   7 +
 .../customize_metrics_test.go                 |  95 ++++---
 .../testdata/attributegen_envoy_filter.yaml   |  10 +
 33 files changed, 1007 insertions(+), 144 deletions(-)
 create mode 100644 releasenotes/notes/wasm-secret.yaml

diff --git a/go.mod b/go.mod
index 405ac54a1e..83a06a6fee 100644
--- a/go.mod
+++ b/go.mod
@@ -22,6 +22,7 @@ require (
 	github.com/containernetworking/plugins v1.1.1
 	github.com/coreos/go-oidc/v3 v3.1.0
 	github.com/davecgh/go-spew v1.1.1
+	github.com/docker/cli v20.10.12+incompatible
 	github.com/envoyproxy/go-control-plane v0.10.2-0.20220119144013-5ce31a86d483
 	github.com/evanphx/json-patch/v5 v5.6.0
 	github.com/fatih/color v1.13.0
@@ -129,7 +130,6 @@ require (
 	github.com/cpuguy83/go-md2man/v2 v2.0.1 // indirect
 	github.com/cyphar/filepath-securejoin v0.2.3 // indirect
 	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.0.0-20210816181553-5444fa50b93d // indirect
-	github.com/docker/cli v20.10.12+incompatible // indirect
 	github.com/docker/distribution v2.7.1+incompatible // indirect
 	github.com/docker/docker v20.10.12+incompatible // indirect
 	github.com/docker/docker-credential-helpers v0.6.4 // indirect
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 7503884116..72a96b96f8 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -537,6 +537,9 @@ func (s *Server) initSDSServer() {
 		})
 		s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(creds, s.XDSServer.Cache, s.clusterID, s.environment.Mesh())
 		s.multiclusterController.AddHandler(creds)
+		if ecdsGen, found := s.XDSServer.Generators[v3.ExtensionConfigurationType]; found {
+			ecdsGen.(*xds.EcdsGenerator).SetCredController(creds)
+		}
 	}
 }
 
diff --git a/pilot/pkg/credentials/kube/multicluster.go b/pilot/pkg/credentials/kube/multicluster.go
index 31ee2a5878..9dfb46e5ef 100644
--- a/pilot/pkg/credentials/kube/multicluster.go
+++ b/pilot/pkg/credentials/kube/multicluster.go
@@ -146,3 +146,19 @@ func (a *AggregateController) Authorize(serviceAccount, namespace string) error
 func (a *AggregateController) AddEventHandler(f func(name string, namespace string)) {
 	// no ops
 }
+
+func (a *AggregateController) GetDockerCredential(name, namespace string) ([]byte, error) {
+	// Search through all clusters, find first non-empty result
+	var firstError error
+	for _, c := range a.controllers {
+		k, err := c.GetDockerCredential(name, namespace)
+		if err != nil {
+			if firstError == nil {
+				firstError = err
+			}
+		} else {
+			return k, nil
+		}
+	}
+	return nil, firstError
+}
diff --git a/pilot/pkg/credentials/kube/secrets.go b/pilot/pkg/credentials/kube/secrets.go
index 3183e015b7..e4f792c3c6 100644
--- a/pilot/pkg/credentials/kube/secrets.go
+++ b/pilot/pkg/credentials/kube/secrets.go
@@ -84,7 +84,8 @@ func NewCredentialsController(client kube.Client, clusterID cluster.ID) *Credent
 		return informersv1.NewFilteredSecretInformer(
 			k, metav1.NamespaceAll, resync, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
 			func(options *metav1.ListOptions) {
-				// We only care about TLS certificates. Unfortunately, it is not as simple as selecting type=kubernetes.io/tls.
+				// We only care about TLS certificates and docker config for Wasm image pulling.
+				// Unfortunately, it is not as simple as selecting type=kubernetes.io/tls and type=kubernetes.io/dockerconfigjson.
 				// Because of legacy reasons and supporting an extra ca.crt, we also support generic types.
 				// Its also likely users have started to use random types and expect them to continue working.
 				// This makes the assumption we will never care about Helm secrets or SA token secrets - two common
@@ -218,6 +219,20 @@ func (s *CredentialsController) GetCaCert(name, namespace string) (cert []byte,
 	return extractRoot(k8sSecret)
 }
 
+func (s *CredentialsController) GetDockerCredential(name, namespace string) ([]byte, error) {
+	k8sSecret, err := s.secretLister.Secrets(namespace).Get(name)
+	if err != nil || k8sSecret == nil {
+		return nil, fmt.Errorf("secret %v/%v not found", namespace, name)
+	}
+	if k8sSecret.Type != v1.SecretTypeDockerConfigJson {
+		return nil, fmt.Errorf("type of secret %v/%v is not %v", namespace, name, v1.SecretTypeDockerConfigJson)
+	}
+	if cred, found := k8sSecret.Data[v1.DockerConfigJsonKey]; found {
+		return cred, nil
+	}
+	return nil, fmt.Errorf("cannot find docker config at secret %v/%v", namespace, name)
+}
+
 func hasKeys(d map[string][]byte, keys ...string) bool {
 	for _, k := range keys {
 		_, f := d[k]
diff --git a/pilot/pkg/credentials/kube/secrets_test.go b/pilot/pkg/credentials/kube/secrets_test.go
index b9dc9c4bcc..7e569a06f9 100644
--- a/pilot/pkg/credentials/kube/secrets_test.go
+++ b/pilot/pkg/credentials/kube/secrets_test.go
@@ -31,7 +31,7 @@
 	"istio.io/istio/pkg/util/sets"
 )
 
-func makeSecret(name string, data map[string]string) *corev1.Secret {
+func makeSecret(name string, data map[string]string, secretType corev1.SecretType) *corev1.Secret {
 	bdata := map[string][]byte{}
 	for k, v := range data {
 		bdata[k] = []byte(v)
@@ -42,46 +42,53 @@ func makeSecret(name string, data map[string]string) *corev1.Secret {
 			Namespace: "default",
 		},
 		Data: bdata,
+		Type: secretType,
 	}
 }
 
 var (
 	genericCert = makeSecret("generic", map[string]string{
 		GenericScrtCert: "generic-cert", GenericScrtKey: "generic-key",
-	})
+	}, corev1.SecretTypeTLS)
 	genericMtlsCert = makeSecret("generic-mtls", map[string]string{
 		GenericScrtCert: "generic-mtls-cert", GenericScrtKey: "generic-mtls-key", GenericScrtCaCert: "generic-mtls-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	genericMtlsCertSplit = makeSecret("generic-mtls-split", map[string]string{
 		GenericScrtCert: "generic-mtls-split-cert", GenericScrtKey: "generic-mtls-split-key",
-	})
+	}, corev1.SecretTypeTLS)
 	genericMtlsCertSplitCa = makeSecret("generic-mtls-split-cacert", map[string]string{
 		GenericScrtCaCert: "generic-mtls-split-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	overlapping = makeSecret("overlap", map[string]string{
 		GenericScrtCert: "cert", GenericScrtKey: "key", GenericScrtCaCert: "main-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	overlappingCa = makeSecret("overlap-cacert", map[string]string{
 		GenericScrtCaCert: "split-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	tlsCert = makeSecret("tls", map[string]string{
 		TLSSecretCert: "tls-cert", TLSSecretKey: "tls-key",
-	})
+	}, corev1.SecretTypeTLS)
 	tlsMtlsCert = makeSecret("tls-mtls", map[string]string{
 		TLSSecretCert: "tls-mtls-cert", TLSSecretKey: "tls-mtls-key", TLSSecretCaCert: "tls-mtls-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	tlsMtlsCertSplit = makeSecret("tls-mtls-split", map[string]string{
 		TLSSecretCert: "tls-mtls-split-cert", TLSSecretKey: "tls-mtls-split-key",
-	})
+	}, corev1.SecretTypeTLS)
 	tlsMtlsCertSplitCa = makeSecret("tls-mtls-split-cacert", map[string]string{
 		TLSSecretCaCert: "tls-mtls-split-ca",
-	})
+	}, corev1.SecretTypeTLS)
 	emptyCert = makeSecret("empty-cert", map[string]string{
 		TLSSecretCert: "", TLSSecretKey: "tls-key",
-	})
+	}, corev1.SecretTypeTLS)
 	wrongKeys = makeSecret("wrong-keys", map[string]string{
 		"foo-bar": "my-cert", TLSSecretKey: "tls-key",
-	})
+	}, corev1.SecretTypeTLS)
+	dockerjson = makeSecret("docker-json", map[string]string{
+		corev1.DockerConfigJsonKey: "docker-cred",
+	}, corev1.SecretTypeDockerConfigJson)
+	badDockerjson = makeSecret("bad-docker-json", map[string]string{
+		"docker-key": "docker-cred",
+	}, corev1.SecretTypeDockerConfigJson)
 )
 
 func TestSecretsController(t *testing.T) {
@@ -218,6 +225,61 @@ func TestSecretsController(t *testing.T) {
 	}
 }
 
+func TestDockerCredentials(t *testing.T) {
+	secrets := []runtime.Object{
+		dockerjson,
+		badDockerjson,
+		genericCert,
+	}
+	client := kube.NewFakeClient(secrets...)
+	sc := NewCredentialsController(client, "")
+	stop := make(chan struct{})
+	t.Cleanup(func() {
+		close(stop)
+	})
+	client.RunAndWait(stop)
+	cases := []struct {
+		name                string
+		namespace           string
+		expectedType        corev1.SecretType
+		expectedDockerCred  string
+		expectedDockerError string
+	}{
+		{
+			name:               "docker-json",
+			namespace:          "default",
+			expectedType:       corev1.SecretTypeDockerConfigJson,
+			expectedDockerCred: "docker-cred",
+		},
+		{
+			name:                "bad-docker-json",
+			namespace:           "default",
+			expectedDockerError: "cannot find docker config at secret default/bad-docker-json",
+		},
+		{
+			name:                "wrong-name",
+			namespace:           "default",
+			expectedDockerError: "secret default/wrong-name not found",
+		},
+		{
+			name:                "generic",
+			namespace:           "default",
+			expectedDockerError: "type of secret default/generic is not kubernetes.io/dockerconfigjson",
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			dockerCred, err := sc.GetDockerCredential(tt.name, tt.namespace)
+			if tt.expectedDockerCred != "" && tt.expectedDockerCred != string(dockerCred) {
+				t.Errorf("got docker credential %q, want %q", string(dockerCred), tt.expectedDockerCred)
+			}
+			if tt.expectedDockerError != "" && tt.expectedDockerError != errString(err) {
+				t.Errorf("got docker err %q, wanted %q", errString(err), tt.expectedDockerError)
+			}
+		})
+	}
+}
+
 func errString(e error) string {
 	if e == nil {
 		return ""
@@ -319,7 +381,7 @@ func TestSecretsControllerMulticluster(t *testing.T) {
 	}
 	tlsCertModified := makeSecret("tls", map[string]string{
 		TLSSecretCert: "tls-cert-mod", TLSSecretKey: "tls-key",
-	})
+	}, corev1.SecretTypeTLS)
 	secretsRemote := []runtime.Object{
 		tlsCertModified,
 		genericCert,
diff --git a/pilot/pkg/credentials/model.go b/pilot/pkg/credentials/model.go
index 189d3dc373..05e485b2ef 100644
--- a/pilot/pkg/credentials/model.go
+++ b/pilot/pkg/credentials/model.go
@@ -14,11 +14,14 @@
 
 package credentials
 
-import "istio.io/istio/pkg/cluster"
+import (
+	"istio.io/istio/pkg/cluster"
+)
 
 type Controller interface {
 	GetKeyAndCert(name, namespace string) (key []byte, cert []byte, err error)
 	GetCaCert(name, namespace string) (cert []byte, err error)
+	GetDockerCredential(name, namespace string) (cred []byte, err error)
 	Authorize(serviceAccount, namespace string) error
 	AddEventHandler(func(name, namespace string))
 }
diff --git a/pilot/pkg/model/config.go b/pilot/pkg/model/config.go
index c5157a30ee..62dc53ff58 100644
--- a/pilot/pkg/model/config.go
+++ b/pilot/pkg/model/config.go
@@ -90,6 +90,16 @@ func ConfigsOfKind(configs map[ConfigKey]struct{}, kind config.GroupVersionKind)
 	return ret
 }
 
+// ConfigsHaveKind checks if configurations have the specified kind.
+func ConfigsHaveKind(configs map[ConfigKey]struct{}, kind config.GroupVersionKind) bool {
+	for conf := range configs {
+		if conf.Kind == kind {
+			return true
+		}
+	}
+	return false
+}
+
 // ConfigNamesOfKind extracts config names of the specified kind.
 func ConfigNamesOfKind(configs map[ConfigKey]struct{}, kind config.GroupVersionKind) map[string]struct{} {
 	ret := sets.New()
diff --git a/pilot/pkg/model/config_test.go b/pilot/pkg/model/config_test.go
index 04ad50161c..d640ed9ee8 100644
--- a/pilot/pkg/model/config_test.go
+++ b/pilot/pkg/model/config_test.go
@@ -480,3 +480,49 @@ func TestIstioConfigStore_Gateway(t *testing.T) {
 		t.Errorf("Got different Config, Excepted:\n%v\n, Got: \n%v\n", expectedConfig, cfgs)
 	}
 }
+
+func TestConfigsOnlyHaveKind(t *testing.T) {
+	tests := []struct {
+		name    string
+		configs map[model.ConfigKey]struct{}
+		want    bool
+	}{
+		{
+			name: "mix",
+			configs: map[model.ConfigKey]struct{}{
+				{Kind: gvk.Deployment}: {},
+				{Kind: gvk.Secret}:     {},
+			},
+			want: true,
+		},
+		{
+			name: "no secret",
+			configs: map[model.ConfigKey]struct{}{
+				{Kind: gvk.Deployment}: {},
+			},
+			want: false,
+		},
+		{
+			name: "only secret",
+			configs: map[model.ConfigKey]struct{}{
+				{Kind: gvk.Secret}: {},
+				{Kind: gvk.Secret}: {},
+			},
+			want: true,
+		},
+		{
+			name:    "empty",
+			configs: map[model.ConfigKey]struct{}{},
+			want:    false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := model.ConfigsHaveKind(tt.configs, gvk.Secret)
+			if tt.want != got {
+				t.Errorf("got %v want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/pilot/pkg/model/credentials/resource.go b/pilot/pkg/model/credentials/resource.go
index 8972b8d461..4bc6eb2837 100644
--- a/pilot/pkg/model/credentials/resource.go
+++ b/pilot/pkg/model/credentials/resource.go
@@ -25,7 +25,7 @@
 	// KubernetesSecretType is the name of a SDS secret stored in Kubernetes. Secrets here take the form
 	// kubernetes://secret-name. They will be pulled from the same namespace and cluster as the requesting proxy lives in.
 	KubernetesSecretType    = "kubernetes"
-	kubernetesSecretTypeURI = KubernetesSecretType + "://"
+	KubernetesSecretTypeURI = KubernetesSecretType + "://"
 	// KubernetesGatewaySecretType is the name of a SDS secret stored in Kubernetes, used by the gateway-api. Secrets here
 	// take the form kubernetes-gateway://namespace/name. They are pulled from the config cluster.
 	KubernetesGatewaySecretType    = "kubernetes-gateway"
@@ -54,6 +54,10 @@ func (sr SecretResource) Key() string {
 	return "sds://" + sr.Type + "/" + sr.Name + "/" + sr.Namespace + "/" + string(sr.Cluster)
 }
 
+func (sr SecretResource) KubernetesResourceName() string {
+	return fmt.Sprintf("%s://%s/%s", sr.Type, sr.Namespace, sr.Name)
+}
+
 func ToKubernetesGatewayResource(namespace, name string) string {
 	if strings.HasPrefix(name, BuiltinGatewaySecretTypeURI) {
 		return BuiltinGatewaySecretTypeURI
@@ -67,23 +71,23 @@ func ToResourceName(name string) string {
 		return "default"
 	}
 	// If they explicitly defined the type, keep it
-	if strings.HasPrefix(name, kubernetesSecretTypeURI) || strings.HasPrefix(name, kubernetesGatewaySecretTypeURI) {
+	if strings.HasPrefix(name, KubernetesSecretTypeURI) || strings.HasPrefix(name, kubernetesGatewaySecretTypeURI) {
 		return name
 	}
 	// Otherwise, to kubernetes://
-	return kubernetesSecretTypeURI + name
+	return KubernetesSecretTypeURI + name
 }
 
 // ParseResourceName parses a raw resourceName string.
 func ParseResourceName(resourceName string, proxyNamespace string, proxyCluster cluster.ID, configCluster cluster.ID) (SecretResource, error) {
 	sep := "/"
-	if strings.HasPrefix(resourceName, kubernetesSecretTypeURI) {
+	if strings.HasPrefix(resourceName, KubernetesSecretTypeURI) {
 		// Valid formats:
 		// * kubernetes://secret-name
 		// * kubernetes://secret-namespace/secret-name
 		// If namespace is not set, we will fetch from the namespace of the proxy. The secret will be read from
 		// the cluster the proxy resides in. This mirrors the legacy behavior mounting a secret as a file
-		res := strings.TrimPrefix(resourceName, kubernetesSecretTypeURI)
+		res := strings.TrimPrefix(resourceName, KubernetesSecretTypeURI)
 		split := strings.Split(res, sep)
 		namespace := proxyNamespace
 		name := split[0]
diff --git a/pilot/pkg/model/extensions.go b/pilot/pkg/model/extensions.go
index 02e95e7c43..f4b62585ee 100644
--- a/pilot/pkg/model/extensions.go
+++ b/pilot/pkg/model/extensions.go
@@ -27,6 +27,7 @@
 	"google.golang.org/protobuf/types/known/wrapperspb"
 
 	extensions "istio.io/api/extensions/v1alpha1"
+	"istio.io/istio/pilot/pkg/model/credentials"
 	"istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/util/protomarshal"
@@ -36,19 +37,26 @@
 	defaultRuntime = "envoy.wasm.runtime.v8"
 	fileScheme     = "file"
 	ociScheme      = "oci"
+
+	// name of environment variable at Wasm VM, which will carry the Wasm image pull secret.
+	WasmSecretEnv = "ISTIO_META_WASM_IMAGE_PULL_SECRET"
 )
 
 type WasmPluginWrapper struct {
 	*extensions.WasmPlugin
 
-	Name      string
-	Namespace string
+	Name         string
+	Namespace    string
+	ResourceName string
 
-	ExtensionConfiguration *envoyCoreV3.TypedExtensionConfig
+	WasmExtensionConfig *envoyWasmFilterV3.Wasm
 }
 
-func convertToWasmPluginWrapper(plugin *config.Config) *WasmPluginWrapper {
+func convertToWasmPluginWrapper(originPlugin config.Config) *WasmPluginWrapper {
 	var ok bool
+	// Make a deep copy since we are going to mutate the resource later for secret env variable.
+	// We do not want to mutate the underlying resource at informer cache.
+	plugin := originPlugin.DeepCopy()
 	var wasmPlugin *extensions.WasmPlugin
 	if wasmPlugin, ok = plugin.Spec.(*extensions.WasmPlugin); !ok {
 		return nil
@@ -75,32 +83,52 @@ func convertToWasmPluginWrapper(plugin *config.Config) *WasmPluginWrapper {
 	if u.Scheme == "" {
 		u.Scheme = ociScheme
 	}
-
+	// Normalize the image pull secret to the full resource name.
+	wasmPlugin.ImagePullSecret = toSecretResourceName(wasmPlugin.ImagePullSecret, plugin.Namespace)
 	datasource := buildDataSource(u, wasmPlugin)
-	typedConfig, err := anypb.New(&envoyWasmFilterV3.Wasm{
+	wasmExtensionConfig := &envoyWasmFilterV3.Wasm{
 		Config: &envoyExtensionsWasmV3.PluginConfig{
 			Name:          plugin.Namespace + "." + plugin.Name,
 			RootId:        wasmPlugin.PluginName,
 			Configuration: cfg,
-			Vm:            buildVMConfig(datasource, wasmPlugin.VmConfig),
+			Vm:            buildVMConfig(datasource, wasmPlugin.VmConfig, wasmPlugin.ImagePullSecret),
 		},
-	})
+	}
 	if err != nil {
 		log.Warnf("WasmPlugin %s/%s failed to marshal to TypedExtensionConfig: %s", plugin.Namespace, plugin.Name, err)
 		return nil
 	}
-	ec := &envoyCoreV3.TypedExtensionConfig{
-		Name:        plugin.Namespace + "." + plugin.Name,
-		TypedConfig: typedConfig,
-	}
 	return &WasmPluginWrapper{
-		Name:                   plugin.Name,
-		Namespace:              plugin.Namespace,
-		WasmPlugin:             wasmPlugin,
-		ExtensionConfiguration: ec,
+		Name:                plugin.Name,
+		Namespace:           plugin.Namespace,
+		ResourceName:        plugin.Namespace + "." + plugin.Name,
+		WasmPlugin:          wasmPlugin,
+		WasmExtensionConfig: wasmExtensionConfig,
 	}
 }
 
+// toSecretResourceName converts a imagePullSecret to a resource name referenced at Wasm SDS.
+// NOTE: the secret referenced by WasmPlugin has to be in the same namespace as the WasmPlugin,
+// so this function makes sure that the secret resource name, which will be used to retrieve secret at
+// xds generation time, has the same namespace as the WasmPlugin.
+func toSecretResourceName(name, pluginNamespace string) string {
+	if name == "" {
+		return ""
+	}
+	// Convert user provided secret name to secret resource name.
+	rn := credentials.ToResourceName(name)
+	// Parse the secret resource name.
+	sr, err := credentials.ParseResourceName(rn, pluginNamespace, "", "")
+	if err != nil {
+		log.Debugf("Failed to parse wasm secret resource name %v", err)
+		return ""
+	}
+	// Forcely rewrite secret namespace to plugin namespace, since we require secret resource
+	// referenced by WasmPlugin co-located with WasmPlugin in the same namespace.
+	sr.Namespace = pluginNamespace
+	return sr.KubernetesResourceName()
+}
+
 func buildDataSource(u *url.URL, wasmPlugin *extensions.WasmPlugin) *envoyCoreV3.AsyncDataSource {
 	if u.Scheme == fileScheme {
 		return &envoyCoreV3.AsyncDataSource{
@@ -131,29 +159,32 @@ func buildDataSource(u *url.URL, wasmPlugin *extensions.WasmPlugin) *envoyCoreV3
 	}
 }
 
-func buildVMConfig(datasource *envoyCoreV3.AsyncDataSource, vm *extensions.VmConfig) *envoyExtensionsWasmV3.PluginConfig_VmConfig {
+func buildVMConfig(datasource *envoyCoreV3.AsyncDataSource, vm *extensions.VmConfig, secretName string) *envoyExtensionsWasmV3.PluginConfig_VmConfig {
 	cfg := &envoyExtensionsWasmV3.PluginConfig_VmConfig{
 		VmConfig: &envoyExtensionsWasmV3.VmConfig{
 			Runtime: defaultRuntime,
 			Code:    datasource,
+			EnvironmentVariables: &envoyExtensionsWasmV3.EnvironmentVariables{
+				KeyValues: map[string]string{},
+			},
 		},
 	}
 
+	if secretName != "" {
+		cfg.VmConfig.EnvironmentVariables.KeyValues[WasmSecretEnv] = secretName
+	}
+
 	if vm != nil && len(vm.Env) != 0 {
 		hostEnvKeys := make([]string, 0, len(vm.Env))
-		inlineEnvs := make(map[string]string, 0)
 		for _, e := range vm.Env {
 			switch e.ValueFrom {
 			case extensions.EnvValueSource_INLINE:
-				inlineEnvs[e.Name] = e.Value
+				cfg.VmConfig.EnvironmentVariables.KeyValues[e.Name] = e.Value
 			case extensions.EnvValueSource_HOST:
 				hostEnvKeys = append(hostEnvKeys, e.Name)
 			}
 		}
-		cfg.VmConfig.EnvironmentVariables = &envoyExtensionsWasmV3.EnvironmentVariables{
-			HostEnvKeys: hostEnvKeys,
-			KeyValues:   inlineEnvs,
-		}
+		cfg.VmConfig.EnvironmentVariables.HostEnvKeys = hostEnvKeys
 	}
 
 	return cfg
diff --git a/pilot/pkg/model/extensions_test.go b/pilot/pkg/model/extensions_test.go
index c1767024a5..b9eed75866 100644
--- a/pilot/pkg/model/extensions_test.go
+++ b/pilot/pkg/model/extensions_test.go
@@ -24,6 +24,8 @@
 	"google.golang.org/protobuf/types/known/durationpb"
 
 	extensions "istio.io/api/extensions/v1alpha1"
+	"istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/test/util/assert"
 )
 
@@ -91,6 +93,11 @@ func TestBuildVMConfig(t *testing.T) {
 			expected: &envoyExtensionsWasmV3.PluginConfig_VmConfig{
 				VmConfig: &envoyExtensionsWasmV3.VmConfig{
 					Runtime: defaultRuntime,
+					EnvironmentVariables: &envoyExtensionsWasmV3.EnvironmentVariables{
+						KeyValues: map[string]string{
+							WasmSecretEnv: "secret-name",
+						},
+					},
 				},
 			},
 		},
@@ -113,7 +120,8 @@ func TestBuildVMConfig(t *testing.T) {
 					EnvironmentVariables: &envoyExtensionsWasmV3.EnvironmentVariables{
 						HostEnvKeys: []string{"POD_NAME"},
 						KeyValues: map[string]string{
-							"ENV1": "VAL1",
+							"ENV1":        "VAL1",
+							WasmSecretEnv: "secret-name",
 						},
 					},
 				},
@@ -123,8 +131,81 @@ func TestBuildVMConfig(t *testing.T) {
 
 	for _, tc := range cases {
 		t.Run("", func(t *testing.T) {
-			got := buildVMConfig(nil, tc.vm)
+			got := buildVMConfig(nil, tc.vm, "secret-name")
 			assert.Equal(t, tc.expected, got)
 		})
 	}
 }
+
+func TestToSecretName(t *testing.T) {
+	cases := []struct {
+		name                  string
+		namespace             string
+		want                  string
+		wantResourceName      string
+		wantResourceNamespace string
+	}{
+		{
+			name:                  "sec",
+			namespace:             "nm",
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+		{
+			name:                  "nm/sec",
+			namespace:             "nm",
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+		{
+			name:      "nm2/sec",
+			namespace: "nm",
+			// Makes sure we won't search namespace outside of nm (which is the WasmPlugin namespace).
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+		{
+			name:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			namespace:             "nm",
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+		{
+			name:                  "kubernetes://nm2/sec",
+			namespace:             "nm",
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+		{
+			name:                  "kubernetes://sec",
+			namespace:             "nm",
+			want:                  credentials.KubernetesSecretTypeURI + "nm/sec",
+			wantResourceName:      "sec",
+			wantResourceNamespace: "nm",
+		},
+	}
+
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			got := toSecretResourceName(tt.name, tt.namespace)
+			if got != tt.want {
+				t.Errorf("got secret name %q, want %q", got, tt.want)
+			}
+			sr, err := credentials.ParseResourceName(got, tt.namespace, cluster.ID("cluster"), cluster.ID("cluster"))
+			if err != nil {
+				t.Error(err)
+			}
+			if sr.Name != tt.wantResourceName {
+				t.Errorf("parse secret name got %v want %v", sr.Name, tt.name)
+			}
+			if sr.Namespace != tt.wantResourceNamespace {
+				t.Errorf("parse secret name got %v want %v", sr.Name, tt.name)
+			}
+		})
+	}
+}
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index a620a340ea..c6e813477f 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -1812,7 +1812,7 @@ func (ps *PushContext) initWasmPlugins(env *Environment) error {
 	sortConfigByCreationTime(wasmplugins)
 	ps.wasmPluginsByNamespace = map[string][]*WasmPluginWrapper{}
 	for _, plugin := range wasmplugins {
-		if pluginWrapper := convertToWasmPluginWrapper(&plugin); pluginWrapper != nil {
+		if pluginWrapper := convertToWasmPluginWrapper(plugin); pluginWrapper != nil {
 			ps.wasmPluginsByNamespace[plugin.Namespace] = append(ps.wasmPluginsByNamespace[plugin.Namespace], pluginWrapper)
 		}
 	}
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index ffc333255e..77f4d84ac9 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -460,7 +460,7 @@ func TestWasmPlugins(t *testing.T) {
 	env := &Environment{}
 	store := istioConfigStore{ConfigStore: NewFakeStore()}
 
-	wasmPlugins := map[string]*config.Config{
+	wasmPlugins := map[string]config.Config{
 		"invalid-type": {
 			Meta: config.Meta{Name: "invalid-type", Namespace: constants.IstioSystemNamespace, GroupVersionKind: gvk.WasmPlugin},
 			Spec: &networking.DestinationRule{},
@@ -615,7 +615,7 @@ func TestWasmPlugins(t *testing.T) {
 	}
 
 	for _, config := range wasmPlugins {
-		store.Create(*config)
+		store.Create(config)
 	}
 	env.IstioConfigStore = &store
 	m := mesh.DefaultMeshConfig()
diff --git a/pilot/pkg/networking/core/configgen.go b/pilot/pkg/networking/core/configgen.go
index 080f9c80cb..38f78a0dfa 100644
--- a/pilot/pkg/networking/core/configgen.go
+++ b/pilot/pkg/networking/core/configgen.go
@@ -48,7 +48,8 @@ type ConfigGenerator interface {
 	BuildNameTable(node *model.Proxy, push *model.PushContext) *dnsProto.NameTable
 
 	// BuildExtensionConfiguration returns the list of extension configuration for the given proxy and list of names. This is the ECDS output.
-	BuildExtensionConfiguration(node *model.Proxy, push *model.PushContext, extensionConfigNames []string) []*core.TypedExtensionConfig
+	BuildExtensionConfiguration(node *model.Proxy, push *model.PushContext, extensionConfigNames []string,
+		pullSecrets map[string][]byte) []*core.TypedExtensionConfig
 
 	// MeshConfigChanged is invoked when mesh config is changed, giving a chance to rebuild any cached config.
 	MeshConfigChanged(mesh *meshconfig.MeshConfig)
diff --git a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
index 0d968dc4d2..4d7d04c1ad 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
@@ -16,9 +16,11 @@
 
 import (
 	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	extensionsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3"
 	hcm_filter "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/types/known/anypb"
 	"google.golang.org/protobuf/types/known/durationpb"
 
 	extensions "istio.io/api/extensions/v1alpha1"
@@ -29,6 +31,7 @@
 
 	// include for registering wasm logging scope
 	_ "istio.io/istio/pkg/wasm"
+	"istio.io/pkg/log"
 )
 
 const (
@@ -129,7 +132,7 @@ func popAppend(list []*hcm_filter.HttpFilter,
 
 func toEnvoyHTTPFilter(wasmPlugin *model.WasmPluginWrapper) *hcm_filter.HttpFilter {
 	return &hcm_filter.HttpFilter{
-		Name: wasmPlugin.ExtensionConfiguration.Name,
+		Name: wasmPlugin.ResourceName,
 		ConfigType: &hcm_filter.HttpFilter_ConfigDiscovery{
 			ConfigDiscovery: &envoy_config_core_v3.ExtensionConfigSource{
 				ConfigSource: defaultConfigSource,
@@ -142,7 +145,7 @@ func toEnvoyHTTPFilter(wasmPlugin *model.WasmPluginWrapper) *hcm_filter.HttpFilt
 // InsertedExtensionConfigurations returns pre-generated extension configurations added via WasmPlugin.
 func InsertedExtensionConfigurations(
 	wasmPlugins map[extensions.PluginPhase][]*model.WasmPluginWrapper,
-	names []string) []*envoy_config_core_v3.TypedExtensionConfig {
+	names []string, pullSecrets map[string][]byte) []*envoy_config_core_v3.TypedExtensionConfig {
 	result := make([]*envoy_config_core_v3.TypedExtensionConfig, 0)
 	if len(wasmPlugins) == 0 {
 		return result
@@ -150,10 +153,35 @@ func InsertedExtensionConfigurations(
 	hasName := sets.New(names...)
 	for _, list := range wasmPlugins {
 		for _, p := range list {
-			if !hasName.Contains(p.ExtensionConfiguration.Name) {
+			if !hasName.Contains(p.ResourceName) {
 				continue
 			}
-			result = append(result, proto.Clone(p.ExtensionConfiguration).(*envoy_config_core_v3.TypedExtensionConfig))
+			wasmExtensionConfig := proto.Clone(p.WasmExtensionConfig).(*extensionsv3.Wasm)
+			// Find the pull secret resource name from wasm vm env variables.
+			// The Wasm extension config should already have a `ISTIO_META_WASM_IMAGE_PULL_SECRET` env variable
+			// at in the VM env variables, with value being the secret resource name. We try to find the actual
+			// secret, and replace the env variable value with it. When ECDS config update reaches the proxy,
+			// agent will extract out the secret from env variable, use it for image pulling, and strip the
+			// env variable from VM config before forwarding it to envoy.
+			envs := wasmExtensionConfig.GetConfig().GetVmConfig().GetEnvironmentVariables().GetKeyValues()
+			secretName := envs[model.WasmSecretEnv]
+			if secretName != "" {
+				if sec, found := pullSecrets[secretName]; found {
+					envs[model.WasmSecretEnv] = string(sec)
+				} else {
+					envs[model.WasmSecretEnv] = ""
+				}
+			}
+			typedConfig, err := anypb.New(wasmExtensionConfig)
+			if err != nil {
+				log.Warnf("wasmplugin %s/%s failed to marshal to TypedExtensionConfig: %s", p.Namespace, p.Name, err)
+				continue
+			}
+			ec := &envoy_config_core_v3.TypedExtensionConfig{
+				Name:        p.ResourceName,
+				TypedConfig: typedConfig,
+			}
+			result = append(result, ec)
 		}
 	}
 	return result
diff --git a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
index 81a51e2243..72b7737558 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
@@ -18,11 +18,13 @@
 	"testing"
 
 	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	extensionsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3"
 	http_conn "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"github.com/golang/protobuf/ptypes/wrappers"
 	"github.com/google/go-cmp/cmp"
 	"google.golang.org/protobuf/testing/protocmp"
+	"google.golang.org/protobuf/types/known/anypb"
 
 	extensions "istio.io/api/extensions/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
@@ -47,34 +49,28 @@
 		Name: "unknown.filter",
 	}
 	someAuthNFilter = &model.WasmPluginWrapper{
-		Name:      "someAuthNFilter",
-		Namespace: "istio-system",
+		Name:         "someAuthNFilter",
+		Namespace:    "istio-system",
+		ResourceName: "istio-system.someAuthNFilter",
 		WasmPlugin: &extensions.WasmPlugin{
 			Priority: &wrappers.Int64Value{Value: 1},
 		},
-		ExtensionConfiguration: &envoy_config_core_v3.TypedExtensionConfig{
-			Name: "istio-system.someAuthNFilter",
-		},
 	}
 	someImportantAuthNFilter = &model.WasmPluginWrapper{
-		Name:      "someImportantAuthNFilter",
-		Namespace: "istio-system",
+		Name:         "someImportantAuthNFilter",
+		Namespace:    "istio-system",
+		ResourceName: "istio-system.someImportantAuthNFilter",
 		WasmPlugin: &extensions.WasmPlugin{
 			Priority: &wrappers.Int64Value{Value: 1000},
 		},
-		ExtensionConfiguration: &envoy_config_core_v3.TypedExtensionConfig{
-			Name: "istio-system.someImportantAuthNFilter",
-		},
 	}
 	someAuthZFilter = &model.WasmPluginWrapper{
-		Name:      "someAuthZFilter",
-		Namespace: "istio-system",
+		Name:         "someAuthZFilter",
+		Namespace:    "istio-system",
+		ResourceName: "istio-system.someAuthZFilter",
 		WasmPlugin: &extensions.WasmPlugin{
 			Priority: &wrappers.Int64Value{Value: 1000},
 		},
-		ExtensionConfiguration: &envoy_config_core_v3.TypedExtensionConfig{
-			Name: "istio-system.someAuthZFilter",
-		},
 	}
 )
 
@@ -193,6 +189,7 @@ func TestAddWasmPluginsToMutableObjects(t *testing.T) {
 }
 
 func TestInsertedExtensionConfigurations(t *testing.T) {
+	wasm, _ := anypb.New(&extensionsv3.Wasm{})
 	testCases := []struct {
 		name        string
 		wasmPlugins map[extensions.PluginPhase][]*model.WasmPluginWrapper
@@ -215,13 +212,16 @@ func TestInsertedExtensionConfigurations(t *testing.T) {
 			},
 			names: []string{someAuthNFilter.Namespace + "." + someAuthNFilter.Name},
 			expectedECs: []*envoy_config_core_v3.TypedExtensionConfig{
-				someAuthNFilter.ExtensionConfiguration,
+				{
+					Name:        "istio-system.someAuthNFilter",
+					TypedConfig: wasm,
+				},
 			},
 		},
 	}
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			ecs := InsertedExtensionConfigurations(tc.wasmPlugins, tc.names)
+			ecs := InsertedExtensionConfigurations(tc.wasmPlugins, tc.names, nil)
 			if diff := cmp.Diff(tc.expectedECs, ecs, protocmp.Transform()); diff != "" {
 				t.Fatal(diff)
 			}
diff --git a/pilot/pkg/networking/core/v1alpha3/extension_config_builder.go b/pilot/pkg/networking/core/v1alpha3/extension_config_builder.go
index c9d9687a53..e82b052a29 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension_config_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension_config_builder.go
@@ -25,10 +25,10 @@
 // BuildExtensionConfiguration returns the list of extension configuration for the given proxy and list of names.
 // This is the ECDS output.
 func (configgen *ConfigGeneratorImpl) BuildExtensionConfiguration(
-	proxy *model.Proxy, push *model.PushContext, extensionConfigNames []string) []*core.TypedExtensionConfig {
+	proxy *model.Proxy, push *model.PushContext, extensionConfigNames []string, pullSecrets map[string][]byte) []*core.TypedExtensionConfig {
 	envoyFilterPatches := push.EnvoyFilters(proxy)
 	extensions := envoyfilter.InsertedExtensionConfigurations(envoyFilterPatches, extensionConfigNames)
 	wasmPlugins := push.WasmPlugins(proxy)
-	extensions = append(extensions, extension.InsertedExtensionConfigurations(wasmPlugins, extensionConfigNames)...)
+	extensions = append(extensions, extension.InsertedExtensionConfigurations(wasmPlugins, extensionConfigNames, pullSecrets)...)
 	return extensions
 }
diff --git a/pilot/pkg/xds/debug.go b/pilot/pkg/xds/debug.go
index 858e0a5b3c..22448bcf83 100644
--- a/pilot/pkg/xds/debug.go
+++ b/pilot/pkg/xds/debug.go
@@ -640,6 +640,13 @@ func unmarshalToWasm(r *discovery.Resource) (interface{}, error) {
 		if err := tce.TypedConfig.UnmarshalTo(w); err != nil {
 			return nil, err
 		}
+		// Redact Wasm secret env variable.
+		vmenvs := w.GetConfig().GetVmConfig().EnvironmentVariables
+		if vmenvs != nil {
+			if _, found := vmenvs.KeyValues[model.WasmSecretEnv]; found {
+				vmenvs.KeyValues[model.WasmSecretEnv] = "<Redacted>"
+			}
+		}
 		return w, nil
 	}
 
diff --git a/pilot/pkg/xds/ecds.go b/pilot/pkg/xds/ecds.go
index dd41409405..85bae9d773 100644
--- a/pilot/pkg/xds/ecds.go
+++ b/pilot/pkg/xds/ecds.go
@@ -15,16 +15,24 @@
 package xds
 
 import (
+	"fmt"
+	"strings"
+
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 
+	credscontroller "istio.io/istio/pilot/pkg/credentials"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/model/credentials"
 	"istio.io/istio/pilot/pkg/networking/util"
+	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/util/sets"
 )
 
 // EcdsGenerator generates ECDS configuration.
 type EcdsGenerator struct {
-	Server *DiscoveryServer
+	Server           *DiscoveryServer
+	secretController credscontroller.MulticlusterController
 }
 
 var _ model.XdsResourceGenerator = &EcdsGenerator{}
@@ -33,21 +41,19 @@ func ecdsNeedsPush(req *model.PushRequest) bool {
 	if req == nil {
 		return true
 	}
-	if !req.Full {
-		// ECDS only handles full push
-		return false
-	}
 	// If none set, we will always push
 	if len(req.ConfigsUpdated) == 0 {
 		return true
 	}
-	// Only push if config updates is triggered by EnvoyFilter or WasmPlugin.
+	// Only push if config updates is triggered by EnvoyFilter, WasmPlugin, or Secret.
 	for config := range req.ConfigsUpdated {
 		switch config.Kind {
 		case gvk.EnvoyFilter:
 			return true
 		case gvk.WasmPlugin:
 			return true
+		case gvk.Secret:
+			return true
 		}
 	}
 	return false
@@ -58,7 +64,45 @@ func (e *EcdsGenerator) Generate(proxy *model.Proxy, w *model.WatchedResource, r
 	if !ecdsNeedsPush(req) {
 		return nil, model.DefaultXdsLogDetails, nil
 	}
-	ec := e.Server.ConfigGenerator.BuildExtensionConfiguration(proxy, req.Push, w.ResourceNames)
+
+	secretResources := referencedSecrets(proxy, req.Push, w.ResourceNames)
+	var updatedSecrets map[model.ConfigKey]struct{}
+	// Check if the secret updates is relevant to Wasm image pull. If not relevant, skip pushing ECDS.
+	if !model.ConfigsHaveKind(req.ConfigsUpdated, gvk.WasmPlugin) && !model.ConfigsHaveKind(req.ConfigsUpdated, gvk.EnvoyFilter) &&
+		model.ConfigsHaveKind(req.ConfigsUpdated, gvk.Secret) {
+		// Get the updated secrets
+		updatedSecrets = model.ConfigsOfKind(req.ConfigsUpdated, gvk.Secret)
+		needsPush := false
+		for _, sr := range secretResources {
+			if _, found := updatedSecrets[model.ConfigKey{Kind: gvk.Secret, Name: sr.Name, Namespace: sr.Namespace}]; found {
+				needsPush = true
+				break
+			}
+		}
+		if !needsPush {
+			return nil, model.DefaultXdsLogDetails, nil
+		}
+	}
+
+	// Generate the pull secrets first, which will be used when populating the extension config.
+	var secretController credscontroller.Controller
+	if e.secretController != nil {
+		var err error
+		secretController, err = e.secretController.ForCluster(proxy.Metadata.ClusterID)
+		if err != nil {
+			log.Warnf("proxy %s is from an unknown cluster, cannot retrieve certificates for Wasm image pull: %v", proxy.ID, err)
+			return nil, model.DefaultXdsLogDetails, nil
+		}
+	}
+	var secrets map[string][]byte
+	if len(secretResources) > 0 {
+		// Inserts Wasm pull secrets in ECDS response, which will be used at xds proxy for image pull.
+		// Before forwarding to Envoy, xds proxy will remove the secret from ECDS response.
+		secrets = e.GeneratePullSecrets(proxy, updatedSecrets, secretResources, secretController, req)
+	}
+
+	ec := e.Server.ConfigGenerator.BuildExtensionConfiguration(proxy, req.Push, w.ResourceNames, secrets)
+
 	if ec == nil {
 		return nil, model.DefaultXdsLogDetails, nil
 	}
@@ -70,5 +114,89 @@ func (e *EcdsGenerator) Generate(proxy *model.Proxy, w *model.WatchedResource, r
 			Resource: util.MessageToAny(c),
 		})
 	}
+
 	return resources, model.DefaultXdsLogDetails, nil
 }
+
+func (e *EcdsGenerator) GeneratePullSecrets(proxy *model.Proxy, updatedSecrets map[model.ConfigKey]struct{}, secretResources []SecretResource,
+	secretController credscontroller.Controller, req *model.PushRequest) map[string][]byte {
+	if proxy.VerifiedIdentity == nil {
+		log.Warnf("proxy %s is not authorized to receive secret. Ensure you are connecting over TLS port and are authenticated.", proxy.ID)
+		return nil
+	}
+
+	results := make(map[string][]byte)
+	for _, sr := range secretResources {
+		if updatedSecrets != nil {
+			if _, found := updatedSecrets[model.ConfigKey{Kind: gvk.Secret, Name: sr.Name, Namespace: sr.Namespace}]; !found {
+				// This is an incremental update, filter out credscontroller that are not updated.
+				continue
+			}
+		}
+
+		cred, err := secretController.GetDockerCredential(sr.Name, sr.Namespace)
+		if err != nil {
+			log.Warnf("Failed to fetch docker credential %s: %v", sr.ResourceName, err)
+		} else {
+			results[sr.ResourceName] = cred
+		}
+	}
+	return results
+}
+
+func (e *EcdsGenerator) SetCredController(creds credscontroller.MulticlusterController) {
+	e.secretController = creds
+}
+
+func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceNames []string) []SecretResource {
+	// The requirement for the Wasm pull secret:
+	// * Wasm pull secrets must be of type `kubernetes.io/dockerconfigjson`.
+	// * Secret are referenced by a WasmPlugin which applies to this proxy.
+	// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,
+	//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.
+	watched := sets.New(resourceNames...)
+	wasmPlugins := push.WasmPlugins(proxy)
+	referencedSecrets := sets.Set{}
+	for _, wps := range wasmPlugins {
+		for _, wp := range wps {
+			if watched.Contains(wp.ResourceName) && wp.ImagePullSecret != "" {
+				referencedSecrets.Insert(wp.ImagePullSecret)
+			}
+		}
+	}
+	var filtered []SecretResource
+	for rn := range referencedSecrets {
+		sr, err := parseSecretName(rn, proxy.Metadata.ClusterID)
+		if err != nil {
+			log.Warnf("Failed to parse secret resource name %v: %v", rn, err)
+			continue
+		}
+		filtered = append(filtered, sr)
+	}
+
+	return filtered
+}
+
+// parseSecretName parses secret resource name from WasmPlugin env variable.
+// See toSecretResourceName at model/extensions.go about how secret resource name is generated.
+func parseSecretName(resourceName string, proxyCluster cluster.ID) (SecretResource, error) {
+	// The secret resource name must be formatted as kubernetes://secret-namespace/secret-name.
+	if !strings.HasPrefix(resourceName, credentials.KubernetesSecretTypeURI) {
+		return SecretResource{}, fmt.Errorf("misformed Wasm pull secret resource name %v", resourceName)
+	}
+	res := strings.TrimPrefix(resourceName, credentials.KubernetesSecretTypeURI)
+	sep := "/"
+	split := strings.Split(res, sep)
+	if len(split) != 2 {
+		return SecretResource{}, fmt.Errorf("misformed Wasm pull secret resource name %v", resourceName)
+	}
+	return SecretResource{
+		SecretResource: credentials.SecretResource{
+			Type:         credentials.KubernetesSecretType,
+			Name:         split[1],
+			Namespace:    split[0],
+			ResourceName: resourceName,
+			Cluster:      proxyCluster,
+		},
+	}, nil
+}
diff --git a/pilot/pkg/xds/ecds_test.go b/pilot/pkg/xds/ecds_test.go
index 7830bed462..8239c78709 100644
--- a/pilot/pkg/xds/ecds_test.go
+++ b/pilot/pkg/xds/ecds_test.go
@@ -14,13 +14,25 @@
 package xds_test
 
 import (
+	"reflect"
 	"testing"
+	"time"
 
 	corev3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	extensionsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
 
+	extensions "istio.io/api/extensions/v1alpha1"
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/util/sets"
 )
 
 func TestECDS(t *testing.T) {
@@ -30,9 +42,13 @@ func TestECDS(t *testing.T) {
 
 	ads := s.ConnectADS().WithType(v3.ExtensionConfigurationType)
 	wantExtensionConfigName := "extension-config"
+	md := model.NodeMetadata{
+		ClusterID: "Kubernetes",
+	}
 	res := ads.RequestResponseAck(t, &discovery.DiscoveryRequest{
 		Node: &corev3.Node{
-			Id: ads.ID,
+			Id:       ads.ID,
+			Metadata: md.ToStruct(),
 		},
 		ResourceNames: []string{wantExtensionConfigName},
 	})
@@ -47,3 +63,223 @@ func TestECDS(t *testing.T) {
 		t.Errorf("extension config name got %v want %v", ec.Name, wantExtensionConfigName)
 	}
 }
+
+func makeDockerCredentials(name, namespace string, data map[string]string, secretType corev1.SecretType) *corev1.Secret {
+	bdata := map[string][]byte{}
+	for k, v := range data {
+		bdata[k] = []byte(v)
+	}
+	return &corev1.Secret{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: namespace,
+		},
+		Data: bdata,
+		Type: secretType,
+	}
+}
+
+func makeWasmPlugin(name, namespace, secret string) config.Config {
+	spec := &extensions.WasmPlugin{
+		Phase: extensions.PluginPhase_AUTHN,
+	}
+	if secret != "" {
+		spec.ImagePullSecret = secret
+	}
+	return config.Config{
+		Meta: config.Meta{
+			Name:             name,
+			Namespace:        namespace,
+			GroupVersionKind: gvk.WasmPlugin,
+		},
+		Spec: spec,
+	}
+}
+
+var (
+	// Secrets
+	defaultPullSecret = makeDockerCredentials("default-pull-secret", "default", map[string]string{
+		corev1.DockerConfigJsonKey: "default-docker-credential",
+	}, corev1.SecretTypeDockerConfigJson)
+	rootPullSecret = makeDockerCredentials("root-pull-secret", "istio-system", map[string]string{
+		corev1.DockerConfigJsonKey: "root-docker-credential",
+	}, corev1.SecretTypeDockerConfigJson)
+	wrongTypeSecret = makeDockerCredentials("wrong-type-pull-secret", "default", map[string]string{
+		corev1.DockerConfigJsonKey: "wrong-type-docker-credential",
+	}, corev1.SecretTypeTLS)
+
+	wasmPlugin             = makeWasmPlugin("default-plugin", "default", "")
+	wasmPluginWithSec      = makeWasmPlugin("default-plugin-with-sec", "default", "default-pull-secret")
+	wasmPluginWrongSec     = makeWasmPlugin("default-plugin-wrong-sec", "default", "wrong-secret")
+	wasmPluginWrongSecType = makeWasmPlugin("default-plugin-wrong-sec-type", "default", "wrong-type-pull-secret")
+	rootWasmPluginWithSec  = makeWasmPlugin("root-plugin", "istio-system", "root-pull-secret")
+)
+
+func TestECDSGenerate(t *testing.T) {
+	cases := []struct {
+		name             string
+		proxyNamespace   string
+		request          *model.PushRequest
+		watchedResources []string
+		wantExtensions   sets.Set
+		wantSecrets      sets.Set
+	}{
+		{
+			name:             "simple",
+			proxyNamespace:   "default",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"default.default-plugin"},
+			wantExtensions:   sets.Set{"default.default-plugin": {}},
+			wantSecrets:      sets.Set{},
+		},
+		{
+			name:             "simple_with_secret",
+			proxyNamespace:   "default",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"default.default-plugin-with-sec"},
+			wantExtensions:   sets.Set{"default.default-plugin-with-sec": {}},
+			wantSecrets:      sets.Set{"default-docker-credential": {}},
+		},
+		{
+			name:             "miss_secret",
+			proxyNamespace:   "default",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"default.default-plugin-wrong-sec"},
+			wantExtensions:   sets.Set{"default.default-plugin-wrong-sec": {}},
+			wantSecrets:      sets.Set{},
+		},
+		{
+			name:             "wrong_secret_type",
+			proxyNamespace:   "default",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"default.default-plugin-wrong-sec-type"},
+			wantExtensions:   sets.Set{"default.default-plugin-wrong-sec-type": {}},
+			wantSecrets:      sets.Set{},
+		},
+		{
+			name:             "root_and_default",
+			proxyNamespace:   "default",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"default.default-plugin-with-sec", "istio-system.root-plugin"},
+			wantExtensions:   sets.Set{"default.default-plugin-with-sec": {}, "istio-system.root-plugin": {}},
+			wantSecrets:      sets.Set{"default-docker-credential": {}, "root-docker-credential": {}},
+		},
+		{
+			name:             "only_root",
+			proxyNamespace:   "somenamespace",
+			request:          &model.PushRequest{Full: true},
+			watchedResources: []string{"istio-system.root-plugin"},
+			wantExtensions:   sets.Set{"istio-system.root-plugin": {}},
+			wantSecrets:      sets.Set{"root-docker-credential": {}},
+		},
+		{
+			name:           "no_relevant_config_update",
+			proxyNamespace: "default",
+			request: &model.PushRequest{
+				Full: true,
+				ConfigsUpdated: map[model.ConfigKey]struct{}{
+					{Kind: gvk.AuthorizationPolicy}: {},
+				},
+			},
+			watchedResources: []string{"default.default-plugin-with-sec", "istio-system.root-plugin"},
+			wantExtensions:   sets.Set{},
+			wantSecrets:      sets.Set{},
+		},
+		{
+			name:           "has_relevant_config_update",
+			proxyNamespace: "default",
+			request: &model.PushRequest{
+				Full: true,
+				ConfigsUpdated: map[model.ConfigKey]struct{}{
+					{Kind: gvk.AuthorizationPolicy}: {},
+					{Kind: gvk.WasmPlugin}:          {},
+				},
+			},
+			watchedResources: []string{"default.default-plugin-with-sec"},
+			wantExtensions:   sets.Set{"default.default-plugin-with-sec": {}},
+			wantSecrets:      sets.Set{"default-docker-credential": {}},
+		},
+		{
+			name:           "non_relevant_secret_update",
+			proxyNamespace: "default",
+			request: &model.PushRequest{
+				Full: true,
+				ConfigsUpdated: map[model.ConfigKey]struct{}{
+					{Kind: gvk.AuthorizationPolicy}: {},
+					{Kind: gvk.Secret}:              {},
+				},
+			},
+			watchedResources: []string{"default.default-plugin-with-sec"},
+			wantExtensions:   sets.Set{},
+			wantSecrets:      sets.Set{},
+		},
+		{
+			name:           "relevant_secret_update",
+			proxyNamespace: "default",
+			request: &model.PushRequest{
+				Full: true,
+				ConfigsUpdated: map[model.ConfigKey]struct{}{
+					{Kind: gvk.Secret, Name: "default-pull-secret", Namespace: "default"}: {},
+				},
+			},
+			watchedResources: []string{"default.default-plugin-with-sec"},
+			wantExtensions:   sets.Set{"default.default-plugin-with-sec": {}},
+			wantSecrets:      sets.Set{"default-docker-credential": {}},
+		},
+		{
+			name:           "relevant_secret_update_non_full_push",
+			proxyNamespace: "default",
+			request: &model.PushRequest{
+				Full: false,
+				ConfigsUpdated: map[model.ConfigKey]struct{}{
+					{Kind: gvk.Secret, Name: "default-pull-secret", Namespace: "default"}: {},
+				},
+			},
+			watchedResources: []string{"default.default-plugin-with-sec"},
+			wantExtensions:   sets.Set{"default.default-plugin-with-sec": {}},
+			wantSecrets:      sets.Set{"default-docker-credential": {}},
+		},
+	}
+
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			s := xds.NewFakeDiscoveryServer(t, xds.FakeOptions{
+				KubernetesObjects: []runtime.Object{defaultPullSecret, rootPullSecret, wrongTypeSecret},
+				Configs:           []config.Config{wasmPlugin, wasmPluginWithSec, wasmPluginWrongSec, wasmPluginWrongSecType, rootWasmPluginWithSec},
+			})
+
+			gen := s.Discovery.Generators[v3.ExtensionConfigurationType]
+			tt.request.Start = time.Now()
+			proxy := &model.Proxy{
+				VerifiedIdentity: &spiffe.Identity{Namespace: tt.proxyNamespace},
+				Type:             model.Router,
+				Metadata: &model.NodeMetadata{
+					ClusterID: "Kubernetes",
+				},
+			}
+			tt.request.Push = s.PushContext()
+			tt.request.Push.Mesh.RootNamespace = "istio-system"
+			resources, _, _ := gen.Generate(s.SetupProxy(proxy),
+				&model.WatchedResource{ResourceNames: tt.watchedResources}, tt.request)
+			gotExtensions := sets.Set{}
+			gotSecrets := sets.Set{}
+			for _, res := range resources {
+				gotExtensions.Insert(res.Name)
+				ec := &corev3.TypedExtensionConfig{}
+				res.Resource.UnmarshalTo(ec)
+				wasm := &extensionsv3.Wasm{}
+				ec.TypedConfig.UnmarshalTo(wasm)
+				gotsecret := wasm.GetConfig().GetVmConfig().GetEnvironmentVariables().GetKeyValues()[model.WasmSecretEnv]
+				if gotsecret != "" {
+					gotSecrets.Insert(gotsecret)
+				}
+			}
+			if !reflect.DeepEqual(gotSecrets, tt.wantSecrets) {
+				t.Errorf("got secrets %v, want secrets %v", gotSecrets, tt.wantSecrets)
+			}
+			if !reflect.DeepEqual(gotExtensions, tt.wantExtensions) {
+				t.Errorf("got extensions %v, want extensions %v", gotExtensions, tt.wantExtensions)
+			}
+		})
+	}
+}
diff --git a/pilot/pkg/xds/fake.go b/pilot/pkg/xds/fake.go
index fc056cfc1e..02d2a696a2 100644
--- a/pilot/pkg/xds/fake.go
+++ b/pilot/pkg/xds/fake.go
@@ -174,6 +174,7 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 	}
 	creds := kubesecrets.NewMulticluster(opts.DefaultClusterName)
 	s.Generators[v3.SecretType] = NewSecretGen(creds, s.Cache, opts.DefaultClusterName, nil)
+	s.Generators[v3.ExtensionConfigurationType].(*EcdsGenerator).SetCredController(creds)
 	for k8sCluster, objs := range k8sObjects {
 		client := kubelib.NewFakeClientWithVersion(opts.KubernetesVersion, objs...)
 		if opts.KubeClientModifier != nil {
diff --git a/pilot/pkg/xds/proxy_dependencies.go b/pilot/pkg/xds/proxy_dependencies.go
index a9f558dcf8..96238919ce 100644
--- a/pilot/pkg/xds/proxy_dependencies.go
+++ b/pilot/pkg/xds/proxy_dependencies.go
@@ -23,7 +23,6 @@
 // configKindAffectedProxyTypes contains known config types which may affect certain node types.
 var configKindAffectedProxyTypes = map[config.GroupVersionKind][]model.NodeType{
 	gvk.Gateway: {model.Router},
-	gvk.Secret:  {model.Router},
 	gvk.Sidecar: {model.SidecarProxy},
 }
 
diff --git a/pkg/istio-agent/xds_proxy_test.go b/pkg/istio-agent/xds_proxy_test.go
index 0418aef41c..709f6db7ed 100644
--- a/pkg/istio-agent/xds_proxy_test.go
+++ b/pkg/istio-agent/xds_proxy_test.go
@@ -449,14 +449,14 @@ func TestXdsProxyReconnects(t *testing.T) {
 
 type fakeAckCache struct{}
 
-func (f *fakeAckCache) Get(string, string, time.Duration) (string, error) {
+func (f *fakeAckCache) Get(string, string, time.Duration, []byte) (string, error) {
 	return "test", nil
 }
 func (f *fakeAckCache) Cleanup() {}
 
 type fakeNackCache struct{}
 
-func (f *fakeNackCache) Get(string, string, time.Duration) (string, error) {
+func (f *fakeNackCache) Get(string, string, time.Duration, []byte) (string, error) {
 	return "", errors.New("errror")
 }
 func (f *fakeNackCache) Cleanup() {}
@@ -465,6 +465,7 @@ func TestECDSWasmConversion(t *testing.T) {
 	node := model.NodeMetadata{
 		Namespace:   "default",
 		InstanceIPs: []string{"1.1.1.1"},
+		ClusterID:   "Kubernetes",
 	}
 	proxy := setupXdsProxy(t)
 
diff --git a/pkg/test/kube/dump.go b/pkg/test/kube/dump.go
index 37e4442d58..e7737b3b35 100644
--- a/pkg/test/kube/dump.go
+++ b/pkg/test/kube/dump.go
@@ -365,6 +365,7 @@ func DumpPodProxies(_ resource.Context, c cluster.Cluster, workDir, namespace st
 		}
 		dumpProxyCommand(c, pod, workDir, "proxy-config.json", "pilot-agent request GET config_dump?include_eds=true")
 		dumpProxyCommand(c, pod, workDir, "proxy-clusters.txt", "pilot-agent request GET clusters")
+		dumpProxyCommand(c, pod, workDir, "proxy-stats.txt", "pilot-agent request GET stats/prometheus")
 	}
 }
 
diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 19e1b5af88..bbb081eef9 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -44,7 +44,7 @@
 
 // Cache models a Wasm module cache.
 type Cache interface {
-	Get(url, checksum string, timeout time.Duration) (string, error)
+	Get(url, checksum string, timeout time.Duration, pullSecret []byte) (string, error)
 	Cleanup()
 }
 
@@ -105,7 +105,7 @@ func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, in
 }
 
 // Get returns path the local Wasm module file.
-func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration) (string, error) {
+func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration, pullSecret []byte) (string, error) {
 	// Construct Wasm cache key with downloading URL and provided checksum of the module.
 	key := cacheKey{
 		downloadURL: downloadURL,
@@ -155,6 +155,9 @@ func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration
 		imgFetcherOps := ImageFetcherOption{
 			Insecure: insecure,
 		}
+		if pullSecret != nil {
+			imgFetcherOps.PullSecret = pullSecret
+		}
 		wasmLog.Debugf("wasm oci fetch %s with options: %v", downloadURL, imgFetcherOps)
 		fetcher := NewImageFetcher(ctx, imgFetcherOps)
 		b, dChecksum, err = fetcher.Fetch(u.Host+u.Path, checksum)
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index cf5568f037..00ad6562fb 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -268,7 +268,7 @@ func TestWasmCache(t *testing.T) {
 				}
 			}
 
-			gotFilePath, gotErr := cache.Get(c.fetchURL, c.checksum, c.requestTimeout)
+			gotFilePath, gotErr := cache.Get(c.fetchURL, c.checksum, c.requestTimeout, []byte{})
 			if cacheHitKey != nil {
 				cache.mux.Lock()
 				if entry, ok := cache.modules[*cacheHitKey]; ok && entry.last == initTime {
@@ -379,7 +379,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 
 	// Get wasm module three times, since checksum is not specified, it will be fetched from module server every time.
 	// 1st time
-	gotFilePath, err := cache.Get(ts.URL, "", 0)
+	gotFilePath, err := cache.Get(ts.URL, "", 0, []byte{})
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
@@ -388,7 +388,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 	}
 
 	// 2nd time
-	gotFilePath, err = cache.Get(ts.URL, "", 0)
+	gotFilePath, err = cache.Get(ts.URL, "", 0, []byte{})
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
@@ -397,7 +397,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 	}
 
 	// 3rd time
-	gotFilePath, err = cache.Get(ts.URL, "", 0)
+	gotFilePath, err = cache.Get(ts.URL, "", 0, []byte{})
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
diff --git a/pkg/wasm/convert.go b/pkg/wasm/convert.go
index 2be44d2a84..07ef023830 100644
--- a/pkg/wasm/convert.go
+++ b/pkg/wasm/convert.go
@@ -24,6 +24,8 @@
 	"github.com/envoyproxy/go-control-plane/pkg/conversion"
 	"go.uber.org/atomic"
 	any "google.golang.org/protobuf/types/known/anypb"
+
+	"istio.io/istio/pilot/pkg/model"
 )
 
 const (
@@ -78,7 +80,6 @@ func convert(resource *any.Any, cache Cache) (newExtensionConfig *any.Any, sendN
 
 	wasmHTTPFilterConfig := &wasm.Wasm{}
 	// Wasm filter can be configured using typed struct and Wasm filter type
-	wasmLog.Debugf("original extension config resource %+v", ec)
 	if ec.GetTypedConfig() != nil && ec.GetTypedConfig().TypeUrl == wasmHTTPFilterType {
 		err := ec.GetTypedConfig().UnmarshalTo(wasmHTTPFilterConfig)
 		if err != nil {
@@ -119,6 +120,27 @@ func convert(resource *any.Any, cache Cache) (newExtensionConfig *any.Any, sendN
 	status = conversionSuccess
 
 	vm := wasmHTTPFilterConfig.Config.GetVmConfig()
+	envs := vm.GetEnvironmentVariables()
+	var pullSecret []byte
+	if envs != nil {
+		if sec, found := envs.KeyValues[model.WasmSecretEnv]; found {
+			if sec == "" {
+				status = fetchFailure
+				wasmLog.Errorf("cannot fetch Wasm module %v: missing image pulling secret", wasmHTTPFilterConfig.Config.Name)
+				return
+			}
+			pullSecret = []byte(sec)
+		}
+		// Strip all internal env variables from VM env variable.
+		delete(envs.KeyValues, model.WasmSecretEnv)
+		if len(envs.KeyValues) == 0 {
+			if len(envs.HostEnvKeys) == 0 {
+				vm.EnvironmentVariables = nil
+			} else {
+				envs.KeyValues = nil
+			}
+		}
+	}
 	remote := vm.GetCode().GetRemote()
 	httpURI := remote.GetHttpUri()
 	if httpURI == nil {
@@ -134,7 +156,7 @@ func convert(resource *any.Any, cache Cache) (newExtensionConfig *any.Any, sendN
 	if remote.GetHttpUri().Timeout != nil {
 		timeout = remote.GetHttpUri().Timeout.AsDuration()
 	}
-	f, err := cache.Get(httpURI.GetUri(), remote.Sha256, timeout)
+	f, err := cache.Get(httpURI.GetUri(), remote.Sha256, timeout, pullSecret)
 	if err != nil {
 		status = fetchFailure
 		wasmLog.Errorf("cannot fetch Wasm module %v: %v", remote.GetHttpUri().GetUri(), err)
diff --git a/pkg/wasm/convert_test.go b/pkg/wasm/convert_test.go
index 97811ef4c0..9055ee7989 100644
--- a/pkg/wasm/convert_test.go
+++ b/pkg/wasm/convert_test.go
@@ -16,7 +16,9 @@
 
 import (
 	"errors"
+	"fmt"
 	"net/url"
+	"reflect"
 	"testing"
 	"time"
 
@@ -29,12 +31,15 @@
 	any "google.golang.org/protobuf/types/known/anypb"
 	"google.golang.org/protobuf/types/known/structpb"
 
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
 )
 
-type mockCache struct{}
+type mockCache struct {
+	wantSecret []byte
+}
 
-func (c *mockCache) Get(downloadURL, checksum string, timeout time.Duration) (string, error) {
+func (c *mockCache) Get(downloadURL, checksum string, timeout time.Duration, pullSecret []byte) (string, error) {
 	url, _ := url.Parse(downloadURL)
 	query := url.Query()
 
@@ -44,7 +49,9 @@ func (c *mockCache) Get(downloadURL, checksum string, timeout time.Duration) (st
 	if errMsg != "" {
 		err = errors.New(errMsg)
 	}
-
+	if c.wantSecret != nil && !reflect.DeepEqual(c.wantSecret, pullSecret) {
+		return "", fmt.Errorf("wrong secret for %v, got %q want %q", downloadURL, string(pullSecret), c.wantSecret)
+	}
 	return module, err
 }
 func (c *mockCache) Cleanup() {}
@@ -138,19 +145,30 @@ func TestWasmConvert(t *testing.T) {
 			},
 			wantNack: true,
 		},
+		{
+			name: "secret",
+			input: []*core.TypedExtensionConfig{
+				extensionConfigMap["remote-load-secret"],
+			},
+			wantOutput: []*core.TypedExtensionConfig{
+				extensionConfigMap["remote-load-success-local-file"],
+			},
+			wantNack: false,
+		},
 	}
 
 	for _, c := range cases {
 		t.Run(c.name, func(t *testing.T) {
-			gotOutput := make([]*any.Any, 0, len(c.input))
+			resources := make([]*any.Any, 0, len(c.input))
 			for _, i := range c.input {
-				gotOutput = append(gotOutput, util.MessageToAny(i))
+				resources = append(resources, util.MessageToAny(i))
 			}
-			gotNack := MaybeConvertWasmExtensionConfig(gotOutput, &mockCache{})
-			if len(gotOutput) != len(c.wantOutput) {
-				t.Fatalf("wasm config conversion number of configuration got %v want %v", len(gotOutput), len(c.wantOutput))
+			mc := &mockCache{}
+			gotNack := MaybeConvertWasmExtensionConfig(resources, mc)
+			if len(resources) != len(c.wantOutput) {
+				t.Fatalf("wasm config conversion number of configuration got %v want %v", len(resources), len(c.wantOutput))
 			}
-			for i, output := range gotOutput {
+			for i, output := range resources {
 				ec := &core.TypedExtensionConfig{}
 				if err := output.UnmarshalTo(ec); err != nil {
 					t.Errorf("wasm config conversion output %v failed to unmarshal", output)
@@ -161,7 +179,7 @@ func TestWasmConvert(t *testing.T) {
 				}
 			}
 			if gotNack != c.wantNack {
-				t.Errorf("wasm config conversion send nack got %v wamt %v", gotNack, c.wantNack)
+				t.Errorf("wasm config conversion send nack got %v want %v", gotNack, c.wantNack)
 			}
 		})
 	}
@@ -288,4 +306,24 @@ func buildWasmExtensionConfig(name string, wasm *wasm.Wasm) *core.TypedExtension
 			FailOpen: true,
 		},
 	}),
+	"remote-load-secret": buildTypedStructExtensionConfig("remote-load-success", &wasm.Wasm{
+		Config: &v3.PluginConfig{
+			Vm: &v3.PluginConfig_VmConfig{
+				VmConfig: &v3.VmConfig{
+					Code: &core.AsyncDataSource{Specifier: &core.AsyncDataSource_Remote{
+						Remote: &core.RemoteDataSource{
+							HttpUri: &core.HttpUri{
+								Uri: "http://test?module=test.wasm",
+							},
+						},
+					}},
+					EnvironmentVariables: &v3.EnvironmentVariables{
+						KeyValues: map[string]string{
+							model.WasmSecretEnv: "secret",
+						},
+					},
+				},
+			},
+		},
+	}),
 }
diff --git a/pkg/wasm/imagefetcher.go b/pkg/wasm/imagefetcher.go
index 2f59bca2bf..84fb3fba96 100644
--- a/pkg/wasm/imagefetcher.go
+++ b/pkg/wasm/imagefetcher.go
@@ -16,6 +16,7 @@
 
 import (
 	"archive/tar"
+	"bytes"
 	"compress/gzip"
 	"context"
 	"crypto/tls"
@@ -23,8 +24,11 @@
 	"fmt"
 	"io"
 	"path/filepath"
+	"reflect"
 	"strings"
 
+	"github.com/docker/cli/cli/config/configfile"
+	dtypes "github.com/docker/cli/cli/config/types"
 	"github.com/google/go-containerregistry/pkg/authn"
 	"github.com/google/go-containerregistry/pkg/name"
 	v1 "github.com/google/go-containerregistry/pkg/v1"
@@ -40,15 +44,20 @@
 var errWasmOCIImageDigestMismatch = errors.New("fetched image's digest does not match the expected one")
 
 type ImageFetcherOption struct {
-	Username string
-	Password string
 	// TODO(mathetake) Add signature verification stuff.
-
-	Insecure bool
+	PullSecret []byte
+	Insecure   bool
 }
 
 func (o *ImageFetcherOption) useDefaultKeyChain() bool {
-	return o.Username == "" || o.Password == ""
+	return o.PullSecret == nil
+}
+
+func (o ImageFetcherOption) String() string {
+	if o.PullSecret == nil {
+		return fmt.Sprintf("{Insecure: %v}", o.Insecure)
+	}
+	return fmt.Sprintf("{Insecure: %v, PullSecret: <redacted>}", o.Insecure)
 }
 
 type ImageFetcher struct {
@@ -63,7 +72,7 @@ func NewImageFetcher(ctx context.Context, opt ImageFetcherOption) *ImageFetcher
 		// so must set the envvar when reaching this branch is expected.
 		fetchOpts = append(fetchOpts, remote.WithAuthFromKeychain(authn.DefaultKeychain))
 	} else {
-		fetchOpts = append(fetchOpts, remote.WithAuth(&authn.Basic{Username: opt.Username}))
+		fetchOpts = append(fetchOpts, remote.WithAuthFromKeychain(&wasmKeyChain{data: opt.PullSecret}))
 	}
 
 	if opt.Insecure {
@@ -319,3 +328,44 @@ func extractOCIArtifactImage(img v1.Image) ([]byte, error) {
 	}
 	return ret, nil
 }
+
+type wasmKeyChain struct {
+	data []byte
+}
+
+// Resolve an image reference to a credential.
+// The function code is borrowed from https://github.com/google/go-containerregistry/blob/v0.8.0/pkg/authn/keychain.go#L65,
+// by making it take dockerconfigjson directly as bytes instead of reading from files.
+func (k *wasmKeyChain) Resolve(target authn.Resource) (authn.Authenticator, error) {
+	if reflect.DeepEqual(k.data, []byte("null")) {
+		// Filter out key chain with content "null" to prevent crash at underlying docker library.
+		// Remove this check when https://github.com/docker/cli/pull/3434 is merged.
+		return nil, fmt.Errorf("")
+	}
+	reader := bytes.NewReader(k.data)
+	cf := configfile.ConfigFile{}
+	if err := cf.LoadFromReader(reader); err != nil {
+		return nil, err
+	}
+	key := target.RegistryStr()
+	if key == name.DefaultRegistry {
+		key = authn.DefaultAuthKey
+	}
+	cfg, err := cf.GetAuthConfig(key)
+	if err != nil {
+		return nil, err
+	}
+
+	empty := dtypes.AuthConfig{}
+	if cfg == empty {
+		return authn.Anonymous, nil
+	}
+	authConfig := authn.AuthConfig{
+		Username:      cfg.Username,
+		Password:      cfg.Password,
+		Auth:          cfg.Auth,
+		IdentityToken: cfg.IdentityToken,
+		RegistryToken: cfg.RegistryToken,
+	}
+	return authn.FromConfig(authConfig), nil
+}
diff --git a/pkg/wasm/imagefetcher_test.go b/pkg/wasm/imagefetcher_test.go
index c1f9875ce8..fcaf32a16c 100644
--- a/pkg/wasm/imagefetcher_test.go
+++ b/pkg/wasm/imagefetcher_test.go
@@ -19,16 +19,19 @@
 	"bytes"
 	"compress/gzip"
 	"crypto/sha256"
+	"encoding/base64"
 	"encoding/hex"
 	"fmt"
 	"io"
 	"net/http/httptest"
 	"net/url"
+	"reflect"
 	"strings"
 	"testing"
 
 	"github.com/google/go-containerregistry/pkg/authn"
 	"github.com/google/go-containerregistry/pkg/crane"
+	"github.com/google/go-containerregistry/pkg/name"
 	"github.com/google/go-containerregistry/pkg/registry"
 	v1 "github.com/google/go-containerregistry/pkg/v1"
 	"github.com/google/go-containerregistry/pkg/v1/empty"
@@ -46,9 +49,8 @@ func TestImageFetcherOption_useDefaultKeyChain(t *testing.T) {
 		exp  bool
 	}{
 		{name: "default key chain", exp: true},
-		{name: "missing username", opt: ImageFetcherOption{Password: "pass"}, exp: true},
-		{name: "missing password", opt: ImageFetcherOption{Username: "name"}, exp: true},
-		{name: "use basic auth", opt: ImageFetcherOption{Username: "name", Password: "pass"}},
+		{name: "use secret config", opt: ImageFetcherOption{PullSecret: []byte("secret")}},
+		{name: "missing secret", opt: ImageFetcherOption{}, exp: true},
 	}
 	for _, c := range cases {
 		t.Run(c.name, func(t *testing.T) {
@@ -611,3 +613,30 @@ func TestExtractWasmPluginBinary(t *testing.T) {
 		}
 	})
 }
+
+func TestWasmKeyChain(t *testing.T) {
+	dockerjson := fmt.Sprintf(`{"auths": {"test.io": {"auth": %q}}}`, encode("foo", "bar"))
+	keyChain := wasmKeyChain{data: []byte(dockerjson)}
+	testRegistry, _ := name.NewRegistry("test.io", name.WeakValidation)
+	keyChain.Resolve(testRegistry)
+	auth, err := keyChain.Resolve(testRegistry)
+	if err != nil {
+		t.Fatalf("Resolve() = %v", err)
+	}
+	got, err := auth.Authorization()
+	if err != nil {
+		t.Fatal(err)
+	}
+	want := &authn.AuthConfig{
+		Username: "foo",
+		Password: "bar",
+	}
+	if !reflect.DeepEqual(got, want) {
+		t.Errorf("got %+v, want %+v", got, want)
+	}
+}
+
+func encode(user, pass string) string {
+	delimited := fmt.Sprintf("%s:%s", user, pass)
+	return base64.StdEncoding.EncodeToString([]byte(delimited))
+}
diff --git a/releasenotes/notes/wasm-secret.yaml b/releasenotes/notes/wasm-secret.yaml
new file mode 100644
index 0000000000..82f15596d6
--- /dev/null
+++ b/releasenotes/notes/wasm-secret.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: extensibility
+issue: []
+releaseNotes:
+  - |
+    **Added** support for WasmPlugin pulling image from private repo with `imagePullSecret`.
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index b1b3ef9e2f..0f583afc3e 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -18,6 +18,7 @@
 package customizemetrics
 
 import (
+	"encoding/base64"
 	"fmt"
 	"net/http"
 	"strings"
@@ -27,6 +28,7 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
+	"istio.io/istio/pkg/test/framework/components/containerregistry"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
@@ -44,6 +46,7 @@
 	client, server echo.Instances
 	appNsInst      namespace.Instance
 	promInst       prometheus.Instance
+	registry       containerregistry.Instance
 )
 
 const (
@@ -51,6 +54,10 @@
 	requestCountMultipler = 3
 	httpProtocol          = "http"
 	grpcProtocol          = "grpc"
+
+	// Same user name and password as specified at pkg/test/fakes/imageregistry
+	registryUser   = "user"
+	registryPasswd = "passwd"
 )
 
 func TestCustomizeMetrics(t *testing.T) {
@@ -103,12 +110,42 @@ func TestMain(m *testing.M) {
 		Label(label.CustomSetup).
 		Label(label.IPv4). // https://github.com/istio/istio/issues/35915
 		Setup(istio.Setup(common.GetIstioInstance(), setupConfig)).
-		Setup(setupEnvoyFilter).
 		Setup(testSetup).
+		Setup(setupWasmExtension).
 		Run()
 }
 
 func testSetup(ctx resource.Context) (err error) {
+	// enable custom tag in the stats
+	bootstrapPatch := `
+apiVersion: networking.istio.io/v1alpha3
+kind: EnvoyFilter
+metadata:
+  name: bootstrap-tag
+  namespace: istio-system
+spec:
+  configPatches:
+  - applyTo: BOOTSTRAP
+    patch:
+      operation: MERGE
+      value:
+        stats_config:
+          stats_tags:
+          - regex: "(custom_dimension=\\.=(.*?);\\.;)"
+            tag_name: "custom_dimension"
+`
+	if err := ctx.ConfigIstio().YAML("istio-system", bootstrapPatch).Apply(resource.Wait); err != nil {
+		return err
+	}
+
+	var nsErr error
+	appNsInst, nsErr = namespace.New(ctx, namespace.Config{
+		Prefix: "echo",
+		Inject: true,
+	})
+	if nsErr != nil {
+		return nsErr
+	}
 	enableBootstrapDiscovery := `
 proxyMetadata:
   BOOTSTRAP_XDS_AGENT: "true"`
@@ -164,6 +201,10 @@ func testSetup(ctx resource.Context) (err error) {
 	if err != nil {
 		return
 	}
+	registry, err = containerregistry.New(ctx, containerregistry.Config{Cluster: ctx.AllClusters().Default()})
+	if err != nil {
+		return
+	}
 	return nil
 }
 
@@ -193,54 +234,29 @@ func setupConfig(_ resource.Context, cfg *istio.Config) {
 	cfg.ControlPlaneValues = fmt.Sprintf(cfValue, removedTag)
 }
 
-func setupEnvoyFilter(ctx resource.Context) error {
-	var nsErr error
-	appNsInst, nsErr = namespace.New(ctx, namespace.Config{
-		Prefix: "echo",
-		Inject: true,
-	})
-	if nsErr != nil {
-		return nsErr
-	}
+func setupWasmExtension(ctx resource.Context) error {
 	proxySHA, err := env.ReadProxySHA()
 	if err != nil {
 		return err
 	}
 	attrGenURL := fmt.Sprintf("https://storage.googleapis.com/istio-build/proxy/attributegen-%v.wasm", proxySHA)
+	attrGenImageURL := fmt.Sprintf("oci://%v/istio-testing/wasm/attributegen:%v", registry.Address(), proxySHA)
 	useRemoteWasmModule := false
 	resp, err := http.Get(attrGenURL)
 	if err == nil && resp.StatusCode == http.StatusOK {
 		useRemoteWasmModule = true
 	}
+
 	args := map[string]interface{}{
 		"WasmRemoteLoad":  useRemoteWasmModule,
-		"AttributeGenURL": attrGenURL,
+		"AttributeGenURL": attrGenImageURL,
+		"DockerConfigJson": base64.StdEncoding.EncodeToString(
+			[]byte(createDockerCredential(registryUser, registryPasswd, registry.Address()))),
 	}
 	if err := ctx.ConfigIstio().EvalFile(appNsInst.Name(), args, "testdata/attributegen_envoy_filter.yaml").Apply(); err != nil {
 		return err
 	}
 
-	// enable custom tag in the stats
-	bootstrapPatch := `
-apiVersion: networking.istio.io/v1alpha3
-kind: EnvoyFilter
-metadata:
-  name: bootstrap-tag
-  namespace: istio-system
-spec:
-  configPatches:
-    - applyTo: BOOTSTRAP
-      patch:
-        operation: MERGE
-        value:
-          stats_config:
-            stats_tags:
-            - regex: "(custom_dimension=\\.=(.*?);\\.;)"
-              tag_name: "custom_dimension"
-`
-	if err := ctx.ConfigIstio().YAML("istio-system", bootstrapPatch).Apply(resource.Wait); err != nil {
-		return err
-	}
 	return nil
 }
 
@@ -313,3 +329,18 @@ func buildQuery(protocol string) (destinationQuery prometheus.Query) {
 	_, destinationQuery, _ = common.BuildQueryCommon(labels, appNsInst.Name())
 	return destinationQuery
 }
+
+func createDockerCredential(user, passwd, registry string) string {
+	credentials := `{
+	"auths":{
+		"%v":{
+			"username": "%v",
+			"password": "%v",
+			"email": "test@abc.com",
+			"auth": "%v"
+		}
+	}
+}`
+	auth := base64.StdEncoding.EncodeToString([]byte(user + ":" + passwd))
+	return fmt.Sprintf(credentials, registry, user, passwd, auth)
+}
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/testdata/attributegen_envoy_filter.yaml b/tests/integration/telemetry/stats/prometheus/customizemetrics/testdata/attributegen_envoy_filter.yaml
index cec528252d..58574b5e4c 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/testdata/attributegen_envoy_filter.yaml
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/testdata/attributegen_envoy_filter.yaml
@@ -1,4 +1,13 @@
 {{- if .WasmRemoteLoad }}
+---
+apiVersion: v1
+data:
+  .dockerconfigjson: {{ .DockerConfigJson }}
+kind: Secret
+metadata:
+  name: regcred
+type: kubernetes.io/dockerconfigjson
+---
 apiVersion: extensions.istio.io/v1alpha1
 kind: WasmPlugin
 metadata:
@@ -9,6 +18,7 @@ spec:
     matchLabels:
       app: server
   url: {{ .AttributeGenURL }}
+  imagePullSecret: regcred
   pluginConfig:
     attributes:
     - output_attribute: istio_responseClass
-- 
2.35.3

