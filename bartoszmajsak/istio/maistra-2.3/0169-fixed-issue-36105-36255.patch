From 830d632145183db02083721b29ed723eafd4d6d2 Mon Sep 17 00:00:00 2001
From: Steve Zhang <huailong.zhang@intel.com>
Date: Tue, 30 Nov 2021 11:02:32 +0800
Subject: fixed issue#36105 (#36255)

---
 pkg/config/analysis/analyzers/util/config.go |  11 +
 tools/bug-report/pkg/bugreport/bugreport.go  |   8 +-
 tools/bug-report/pkg/cluster/cluster.go      | 176 +++++++--
 tools/bug-report/pkg/cluster/cluster_test.go | 354 +++++++++++++++++++
 tools/bug-report/pkg/config/config.go        |  25 +-
 5 files changed, 534 insertions(+), 40 deletions(-)
 create mode 100644 tools/bug-report/pkg/cluster/cluster_test.go

diff --git a/pkg/config/analysis/analyzers/util/config.go b/pkg/config/analysis/analyzers/util/config.go
index 9fbb11837e..30df3ae928 100644
--- a/pkg/config/analysis/analyzers/util/config.go
+++ b/pkg/config/analysis/analyzers/util/config.go
@@ -15,6 +15,8 @@
 package util
 
 import (
+	"strings"
+
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/resource"
 )
@@ -61,6 +63,15 @@ func IsIncluded(slice []string, term string) bool {
 	return false
 }
 
+// IsMatched check if the term can be matched in a slice of string
+func IsMatched(slice []string, term string) bool {
+	for _, val := range slice {
+		matched := strings.Contains(term, val)
+		return matched
+	}
+	return false
+}
+
 func GetInjectorConfigMapName(revision string) string {
 	name := InjectionConfigMap
 	if revision == "" || revision == "default" {
diff --git a/tools/bug-report/pkg/bugreport/bugreport.go b/tools/bug-report/pkg/bugreport/bugreport.go
index a4bb2254bf..4644521b59 100644
--- a/tools/bug-report/pkg/bugreport/bugreport.go
+++ b/tools/bug-report/pkg/bugreport/bugreport.go
@@ -132,7 +132,13 @@ func runBugReportCommand(_ *cobra.Command, logOpts *log.Options) error {
 	}
 	common.LogAndPrintf("\nCluster endpoint: %s\n", client.RESTConfig().Host)
 
-	resources, err := cluster2.GetClusterResources(context.Background(), clientset)
+	clusterResourcesCtx, getClusterResourcesCancel := context.WithTimeout(context.Background(), bugReportDefaultTimeout)
+	defer func() {
+		message := "Timeout when get cluster resources, please using --include or --exclude to filter"
+		common.LogAndPrintf(message)
+		getClusterResourcesCancel()
+	}()
+	resources, err := cluster2.GetClusterResources(clusterResourcesCtx, clientset, config)
 	if err != nil {
 		return err
 	}
diff --git a/tools/bug-report/pkg/cluster/cluster.go b/tools/bug-report/pkg/cluster/cluster.go
index 64b9177838..0b3321952d 100644
--- a/tools/bug-report/pkg/cluster/cluster.go
+++ b/tools/bug-report/pkg/cluster/cluster.go
@@ -28,20 +28,10 @@
 	analyzer_util "istio.io/istio/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/tools/bug-report/pkg/common"
+	config2 "istio.io/istio/tools/bug-report/pkg/config"
 	"istio.io/istio/tools/bug-report/pkg/util/path"
 )
 
-type ResourceType int
-
-const (
-	Namespace ResourceType = iota
-	Deployment
-	Pod
-	Label
-	Annotation
-	Container
-)
-
 var versionRegex = regexp.MustCompile(`.*(\d\.\d\.\d).*`)
 
 // ParsePath parses path into its components. Input must have the form namespace/deployment/pod/container.
@@ -53,40 +43,164 @@ func ParsePath(path string) (namespace string, deployment, pod string, container
 	return pv[0], pv[1], pv[2], pv[3], nil
 }
 
+// shouldSkip means that current pod should be skip or not based on given --include and --exclude
+func shouldSkip(deployment string, config *config2.BugReportConfig, pod *corev1.Pod) bool {
+	var isInclude bool = len(config.Include) > 0
+	var isExclude bool = len(config.Exclude) > 0
+
+	if isExclude {
+		for _, eld := range config.Exclude {
+			if len(eld.Namespaces) > 0 {
+				if analyzer_util.IsMatched(eld.Namespaces, pod.Namespace) {
+					return true
+				}
+			}
+			if len(eld.Deployments) > 0 {
+				if analyzer_util.IsMatched(eld.Deployments, deployment) {
+					return true
+				}
+			}
+			if len(eld.Pods) > 0 {
+				if analyzer_util.IsMatched(eld.Pods, pod.Name) {
+					return true
+				}
+			}
+			if len(eld.Containers) > 0 {
+				for _, c := range pod.Spec.Containers {
+					if analyzer_util.IsMatched(eld.Containers, c.Name) {
+						return true
+					}
+				}
+			}
+			if len(eld.Labels) > 0 {
+				for kLabel, vLable := range eld.Labels {
+					if evLable, exists := pod.Labels[kLabel]; exists {
+						if vLable == evLable {
+							return true
+						}
+					}
+				}
+			}
+			if len(eld.Annotations) > 0 {
+				for kAnnotation, vAnnotation := range eld.Annotations {
+					if evAnnotation, exists := pod.Annotations[kAnnotation]; exists {
+						if vAnnotation == evAnnotation {
+							return true
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if isInclude {
+		for _, ild := range config.Include {
+			if len(ild.Namespaces) > 0 {
+				if !analyzer_util.IsMatched(ild.Namespaces, pod.Namespace) {
+					return true
+				}
+			}
+			if len(ild.Deployments) > 0 {
+				if !analyzer_util.IsMatched(ild.Deployments, deployment) {
+					return true
+				}
+			}
+			if len(ild.Pods) > 0 {
+				if !analyzer_util.IsMatched(ild.Pods, pod.Name) {
+					return true
+				}
+			}
+
+			if len(ild.Containers) > 0 {
+				isContainerMatch := false
+				for _, c := range pod.Spec.Containers {
+					if analyzer_util.IsMatched(ild.Containers, c.Name) {
+						isContainerMatch = true
+					}
+				}
+				if !isContainerMatch {
+					return true
+				}
+			}
+
+			if len(ild.Labels) > 0 {
+				isLabelsMatch := false
+				for kLabel, vLable := range ild.Labels {
+					if evLable, exists := pod.Labels[kLabel]; exists {
+						if vLable != evLable {
+							isLabelsMatch = false
+						} else {
+							isLabelsMatch = true
+						}
+						// need to match, but no such label
+					} else {
+						isLabelsMatch = false
+					}
+				}
+				if !isLabelsMatch {
+					return true
+				}
+			}
+
+			if len(ild.Annotations) > 0 {
+				isAnnotationMatch := false
+				for kAnnotation, vAnnotation := range ild.Annotations {
+					if evAnnotation, exists := pod.Annotations[kAnnotation]; exists {
+						if vAnnotation != evAnnotation {
+							isAnnotationMatch = false
+						} else {
+							isAnnotationMatch = true
+						}
+						// need to match, but no such annotation
+					} else {
+						isAnnotationMatch = false
+					}
+				}
+				if !isAnnotationMatch {
+					return true
+				}
+			}
+		}
+	}
+	return false
+}
+
 // GetClusterResources returns cluster resources for the given REST config and k8s Clientset.
-func GetClusterResources(ctx context.Context, clientset *kubernetes.Clientset) (*Resources, error) {
+func GetClusterResources(ctx context.Context, clientset *kubernetes.Clientset, config *config2.BugReportConfig) (*Resources, error) {
 	out := &Resources{
 		Labels:      make(map[string]map[string]string),
 		Annotations: make(map[string]map[string]string),
 		Pod:         make(map[string]*corev1.Pod),
 	}
-	namespaces, err := clientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
+
+	pods, err := clientset.CoreV1().Pods("").List(ctx, metav1.ListOptions{})
+	if err != nil {
+		return nil, err
+	}
+
+	replicasets, err := clientset.AppsV1().ReplicaSets("").List(ctx, metav1.ListOptions{})
 	if err != nil {
 		return nil, err
 	}
-	for _, ns := range namespaces.Items {
-		// skip system namesapces
-		if analyzer_util.IsSystemNamespace(resource.Namespace(ns.Name)) {
+
+	for i, p := range pods.Items {
+		if analyzer_util.IsSystemNamespace(resource.Namespace(p.Namespace)) {
 			continue
 		}
-		pods, err := clientset.CoreV1().Pods(ns.Name).List(ctx, metav1.ListOptions{})
-		if err != nil {
-			return nil, err
-		}
-		replicasets, err := clientset.AppsV1().ReplicaSets(ns.Name).List(ctx, metav1.ListOptions{})
-		if err != nil {
-			return nil, err
+
+		deployment := getOwnerDeployment(&p, replicasets.Items)
+		if skip := shouldSkip(deployment, config, &p); skip {
+			continue
 		}
-		for i, p := range pods.Items {
-			deployment := getOwnerDeployment(&p, replicasets.Items)
-			for _, c := range p.Spec.Containers {
-				out.insertContainer(ns.Name, deployment, p.Name, c.Name)
-			}
-			out.Labels[PodKey(p.Namespace, p.Name)] = p.Labels
-			out.Annotations[PodKey(p.Namespace, p.Name)] = p.Annotations
-			out.Pod[PodKey(p.Namespace, p.Name)] = &pods.Items[i]
+
+		for _, c := range p.Spec.Containers {
+			out.insertContainer(p.Namespace, deployment, p.Name, c.Name)
 		}
+		out.Labels[PodKey(p.Namespace, p.Name)] = p.Labels
+		out.Annotations[PodKey(p.Namespace, p.Name)] = p.Annotations
+		out.Pod[PodKey(p.Namespace, p.Name)] = &pods.Items[i]
 	}
+
 	return out, nil
 }
 
diff --git a/tools/bug-report/pkg/cluster/cluster_test.go b/tools/bug-report/pkg/cluster/cluster_test.go
new file mode 100644
index 0000000000..1a997ffefc
--- /dev/null
+++ b/tools/bug-report/pkg/cluster/cluster_test.go
@@ -0,0 +1,354 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package cluster
+
+import (
+	"testing"
+
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	config2 "istio.io/istio/tools/bug-report/pkg/config"
+)
+
+func TestShouldSkip(t *testing.T) {
+	cases := []struct {
+		name       string
+		pod        *v1.Pod
+		config     *config2.BugReportConfig
+		deployment string
+		expected   bool
+	}{
+		{
+			"tested namespace not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Namespace: "in-namespace1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Namespaces: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Namespaces: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			false,
+		},
+		{
+			"tested namespace skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Namespace: "ex-namespace1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Namespaces: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Namespaces: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			true,
+		},
+		{
+			"tested pod name not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-pod1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Pods: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			false,
+		},
+		{
+			"tested pod name skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "ex-pod1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Pods: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			true,
+		},
+		{
+			"tested deployment not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Deployments: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Deployments: []string{"ex-"},
+					},
+				},
+			},
+			"in-dep1",
+			false,
+		},
+		{
+			"tested deployment skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods:        []string{"in-"},
+						Deployments: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Pods:        []string{"ex-"},
+						Deployments: []string{"ex-"},
+					},
+				},
+			},
+			"ex-dep1",
+			true,
+		},
+		{
+			"tested container not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+				},
+				Spec: v1.PodSpec{
+					Containers: []v1.Container{
+						{
+							Name: "in-con1",
+						},
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods:       []string{"in-"},
+						Containers: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Pods:       []string{"ex-"},
+						Containers: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			false,
+		},
+		{
+			"tested container skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+				},
+				Spec: v1.PodSpec{
+					Containers: []v1.Container{
+						{
+							Name: "ex-con1",
+						},
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods:       []string{"in-"},
+						Containers: []string{"in-"},
+					},
+				},
+				Exclude: []*config2.SelectionSpec{
+					{
+						Pods:       []string{"ex-"},
+						Containers: []string{"ex-"},
+					},
+				},
+			},
+			"*",
+			true,
+		},
+		{
+			"tested label not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+					Labels: map[string]string{
+						"l1": "lv1",
+						"l2": "lv2",
+					},
+					Annotations: map[string]string{
+						"a1": "av1",
+						"a2": "av1",
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+						Labels: map[string]string{
+							"l1": "lv1",
+							"l2": "lv2",
+						},
+					},
+				},
+			},
+			"*",
+			false,
+		},
+		{
+			"tested label skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+					Labels: map[string]string{
+						"l1": "lv1",
+					},
+					Annotations: map[string]string{
+						"a1": "av1",
+						"a2": "av1",
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+						Labels: map[string]string{
+							"l1": "lv1",
+							"l2": "lv2",
+						},
+					},
+				},
+			},
+			"*",
+			true,
+		},
+		{
+			"tested annotation not skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+					Labels: map[string]string{
+						"l3": "lv3",
+						"l4": "lv4",
+					},
+					Annotations: map[string]string{
+						"a3": "av3",
+						"a4": "av4",
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+						Annotations: map[string]string{
+							"a3": "av3",
+							"a4": "av4",
+						},
+					},
+				},
+			},
+			"*",
+			false,
+		},
+		{
+			"tested annotation skip",
+			&v1.Pod{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "in-test1",
+					Labels: map[string]string{
+						"l3": "lv3",
+						"l4": "lv4",
+					},
+					Annotations: map[string]string{
+						"a3": "av3",
+					},
+				},
+			},
+			&config2.BugReportConfig{
+				Include: []*config2.SelectionSpec{
+					{
+						Pods: []string{"in-"},
+						Annotations: map[string]string{
+							"a3": "av3",
+							"a4": "av4",
+						},
+					},
+				},
+			},
+			"*",
+			true,
+		},
+	}
+
+	for _, c := range cases {
+		t.Run(c.name, func(t *testing.T) {
+			skip := shouldSkip(c.deployment, c.config, c.pod)
+			if skip != c.expected {
+				t.Errorf("shouldSkip() for test case name [%s] return= %v, want %v", c.name, skip, c.expected)
+			}
+		})
+	}
+}
diff --git a/tools/bug-report/pkg/config/config.go b/tools/bug-report/pkg/config/config.go
index 8043c370b3..2f9115d3ea 100644
--- a/tools/bug-report/pkg/config/config.go
+++ b/tools/bug-report/pkg/config/config.go
@@ -21,8 +21,17 @@
 	"math"
 	"strings"
 	"time"
+)
+
+type ResourceType int
 
-	cluster2 "istio.io/istio/tools/bug-report/pkg/cluster"
+const (
+	Namespace ResourceType = iota
+	Deployment
+	Pod
+	Label
+	Annotation
+	Container
 )
 
 // SelectionSpec is a spec for pods that will be Include in the capture
@@ -210,28 +219,28 @@ func parseToIncludeTypeMap(s string) (map[string]string, error) {
 }
 
 func (s *SelectionSpec) UnmarshalJSON(b []byte) error {
-	ft := []cluster2.ResourceType{cluster2.Namespace, cluster2.Deployment, cluster2.Pod, cluster2.Label, cluster2.Annotation, cluster2.Container}
+	ft := []ResourceType{Namespace, Deployment, Pod, Label, Annotation, Container}
 	str := strings.TrimPrefix(strings.TrimSuffix(string(b), `"`), `"`)
 	for i, f := range strings.Split(str, "/") {
 		var err error
 		switch ft[i] {
-		case cluster2.Namespace:
+		case Namespace:
 			s.Namespaces = parseToIncludeTypeSlice(f)
-		case cluster2.Deployment:
+		case Deployment:
 			s.Deployments = parseToIncludeTypeSlice(f)
-		case cluster2.Pod:
+		case Pod:
 			s.Pods = parseToIncludeTypeSlice(f)
-		case cluster2.Label:
+		case Label:
 			s.Labels, err = parseToIncludeTypeMap(f)
 			if err != nil {
 				return err
 			}
-		case cluster2.Annotation:
+		case Annotation:
 			s.Annotations, err = parseToIncludeTypeMap(f)
 			if err != nil {
 				return err
 			}
-		case cluster2.Container:
+		case Container:
 			s.Containers = parseToIncludeTypeSlice(f)
 		}
 	}
-- 
2.35.3

