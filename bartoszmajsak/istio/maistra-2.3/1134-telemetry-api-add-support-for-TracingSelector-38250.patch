From 790dd7fca79a986ca9cf248fb48c6be299a5f262 Mon Sep 17 00:00:00 2001
From: Douglas Reid <douglas-reid@users.noreply.github.com>
Date: Wed, 27 Apr 2022 09:11:01 -0700
Subject: telemetry api: add support for TracingSelector (#38250)

* telemetry api: add support for TracingSelector

* fix lint issue

* add release note
---
 pilot/pkg/model/telemetry.go                  |  99 ++++++-----
 pilot/pkg/model/telemetry_test.go             | 154 +++++++++++++++---
 pilot/pkg/networking/core/v1alpha3/tracing.go |  22 ++-
 .../networking/core/v1alpha3/tracing_test.go  |  78 ++++++++-
 releasenotes/notes/38250.yaml                 |   7 +
 5 files changed, 283 insertions(+), 77 deletions(-)
 create mode 100644 releasenotes/notes/38250.yaml

diff --git a/pilot/pkg/model/telemetry.go b/pilot/pkg/model/telemetry.go
index 44e70711c3..375bb0d102 100644
--- a/pilot/pkg/model/telemetry.go
+++ b/pilot/pkg/model/telemetry.go
@@ -167,6 +167,11 @@ type computedTelemetries struct {
 }
 
 type TracingConfig struct {
+	ServerSpec TracingSpec
+	ClientSpec TracingSpec
+}
+
+type TracingSpec struct {
 	Provider                     *meshconfig.MeshConfig_ExtensionProvider
 	Disabled                     bool
 	RandomSamplingPercentage     float64
@@ -206,68 +211,84 @@ func (t *Telemetries) Tracing(proxy *Proxy) *TracingConfig {
 	ct := t.applicableTelemetries(proxy)
 
 	providerNames := t.meshConfig.GetDefaultProviders().GetTracing()
-	for _, m := range ct.Tracing {
-		currentNames := getProviderNames(m.Providers)
-		// If we set providers are current level, use that. Otherwise, keep parent providers
-		if len(currentNames) > 0 {
-			providerNames = currentNames
-		}
-	}
-	if len(providerNames) == 0 {
-		// No providers set at all, use fallback
+	hasDefaultProvider := len(providerNames) > 0
+
+	if len(ct.Tracing) == 0 && !hasDefaultProvider {
 		return nil
 	}
-	if len(providerNames) > 1 {
-		// User can set multiple, but we don't actually support it, so we will pick the first one
-		log.Debugf("invalid tracing configure; only one provider supported: %v", providerNames)
-	}
-	supportedProvider := providerNames[0]
 
-	cfg := TracingConfig{
-		Provider:                     t.fetchProvider(supportedProvider),
-		UseRequestIDForTraceSampling: true,
-	}
-	if cfg.Provider == nil {
-		cfg.Disabled = true
-		return &cfg
+	clientSpec := TracingSpec{UseRequestIDForTraceSampling: true}
+	serverSpec := TracingSpec{UseRequestIDForTraceSampling: true}
+
+	if hasDefaultProvider {
+		// todo: what do we want to do with more than one default provider?
+		// for now, use only the first provider.
+		fetched := t.fetchProvider(providerNames[0])
+		clientSpec.Provider = fetched
+		serverSpec.Provider = fetched
 	}
+
 	for _, m := range ct.Tracing {
 		names := getProviderNames(m.Providers)
 
-		// We need to figure out if the tracing config at this level is relevant. For example, if we selected
-		// provider X but this config applies to provider Y, we should ignore it.
-		includeConfig := false
-		// If there is no provider set it applies to the default.
-		if len(names) == 0 {
-			includeConfig = true
-		}
-		// Otherwise, make sure one of the configured providers is our selected provider.
-		for _, n := range names {
-			if n == supportedProvider {
-				includeConfig = true
-				break
+		specs := []*TracingSpec{&clientSpec, &serverSpec}
+		if m.Match != nil {
+			switch m.Match.Mode {
+			case tpb.WorkloadMode_CLIENT:
+				specs = []*TracingSpec{&clientSpec}
+			case tpb.WorkloadMode_SERVER:
+				specs = []*TracingSpec{&serverSpec}
 			}
 		}
-		if !includeConfig {
-			break
+
+		if len(names) > 0 {
+			// NOTE: we only support a single provider per mode
+			// so, choosing the first provider returned in the list
+			// is the "safest"
+			fetched := t.fetchProvider(names[0])
+			for _, spec := range specs {
+				spec.Provider = fetched
+			}
 		}
 
 		// Now merge in any overrides
 		if m.DisableSpanReporting != nil {
-			cfg.Disabled = m.DisableSpanReporting.GetValue()
+			for _, spec := range specs {
+				spec.Disabled = m.DisableSpanReporting.GetValue()
+			}
 		}
 		// TODO: metrics overrides do a deep merge, but here we do a shallow merge.
 		// We should consider if we want to reconcile the two.
 		if m.CustomTags != nil {
-			cfg.CustomTags = m.CustomTags
+			for _, spec := range specs {
+				spec.CustomTags = m.CustomTags
+			}
 		}
 		if m.RandomSamplingPercentage != nil {
-			cfg.RandomSamplingPercentage = m.RandomSamplingPercentage.GetValue()
+			for _, spec := range specs {
+				spec.RandomSamplingPercentage = m.RandomSamplingPercentage.GetValue()
+			}
 		}
 		if m.UseRequestIdForTraceSampling != nil {
-			cfg.UseRequestIDForTraceSampling = m.UseRequestIdForTraceSampling.Value
+			for _, spec := range specs {
+				spec.UseRequestIDForTraceSampling = m.UseRequestIdForTraceSampling.Value
+			}
 		}
 	}
+
+	// If no provider is configured (and retrieved) for the tracing specs,
+	// then we will disable the configuration.
+	if clientSpec.Provider == nil {
+		clientSpec.Disabled = true
+	}
+	if serverSpec.Provider == nil {
+		serverSpec.Disabled = true
+	}
+
+	cfg := TracingConfig{
+		ClientSpec: clientSpec,
+		ServerSpec: serverSpec,
+	}
 	return &cfg
 }
 
diff --git a/pilot/pkg/model/telemetry_test.go b/pilot/pkg/model/telemetry_test.go
index 4df6d66b8b..577f65f197 100644
--- a/pilot/pkg/model/telemetry_test.go
+++ b/pilot/pkg/model/telemetry_test.go
@@ -351,9 +351,16 @@ func TestAccessLoggingWithFilter(t *testing.T) {
 
 func newTracingConfig(providerName string, disabled bool) *TracingConfig {
 	return &TracingConfig{
-		Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: providerName},
-		Disabled:                     disabled,
-		UseRequestIDForTraceSampling: true,
+		ClientSpec: TracingSpec{
+			Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: providerName},
+			Disabled:                     disabled,
+			UseRequestIDForTraceSampling: true,
+		},
+		ServerSpec: TracingSpec{
+			Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: providerName},
+			Disabled:                     disabled,
+			UseRequestIDForTraceSampling: true,
+		},
 	}
 }
 
@@ -441,6 +448,32 @@ func TestTracing(t *testing.T) {
 			},
 		},
 	}
+	clientSideSampling := &tpb.Telemetry{
+		Tracing: []*tpb.Tracing{
+			{
+				Match: &tpb.Tracing_TracingSelector{
+					Mode: tpb.WorkloadMode_CLIENT,
+				},
+				Providers: []*tpb.ProviderRef{
+					{
+						Name: "stackdriver",
+					},
+				},
+				RandomSamplingPercentage: &wrappers.DoubleValue{Value: 99.9},
+			},
+		},
+	}
+	serverSideDisabled := &tpb.Telemetry{
+		Tracing: []*tpb.Tracing{
+			{
+				Match: &tpb.Tracing_TracingSelector{
+					Mode: tpb.WorkloadMode_SERVER,
+				},
+				DisableSpanReporting: &wrappers.BoolValue{Value: true},
+			},
+		},
+	}
+
 	tests := []struct {
 		name             string
 		cfgs             []config.Config
@@ -509,7 +542,10 @@ func TestTracing(t *testing.T) {
 			[]config.Config{newTelemetry("default", nonExistant)},
 			sidecar,
 			[]string{"envoy"},
-			&TracingConfig{Disabled: true, UseRequestIDForTraceSampling: true},
+			&TracingConfig{
+				ClientSpec: TracingSpec{Disabled: true, UseRequestIDForTraceSampling: true},
+				ServerSpec: TracingSpec{Disabled: true, UseRequestIDForTraceSampling: true},
+			},
 		},
 		{
 			"overrides",
@@ -517,13 +553,23 @@ func TestTracing(t *testing.T) {
 			sidecar,
 			[]string{"envoy"},
 			&TracingConfig{
-				Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
-				RandomSamplingPercentage: 50.0,
-				CustomTags: map[string]*tpb.Tracing_CustomTag{
-					"foo": {},
-					"bar": {},
+				ClientSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 50.0,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"bar": {},
+					},
+					UseRequestIDForTraceSampling: false,
+				}, ServerSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 50.0,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"bar": {},
+					},
+					UseRequestIDForTraceSampling: false,
 				},
-				UseRequestIDForTraceSampling: false,
 			},
 		},
 		{
@@ -532,13 +578,23 @@ func TestTracing(t *testing.T) {
 			sidecar,
 			[]string{"envoy"},
 			&TracingConfig{
-				Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
-				RandomSamplingPercentage: 0.0,
-				CustomTags: map[string]*tpb.Tracing_CustomTag{
-					"foo": {},
-					"baz": {},
+				ClientSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 0.0,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"baz": {},
+					},
+					UseRequestIDForTraceSampling: true,
+				}, ServerSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 0.0,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"baz": {},
+					},
+					UseRequestIDForTraceSampling: true,
 				},
-				UseRequestIDForTraceSampling: true,
 			},
 		},
 		{
@@ -550,13 +606,63 @@ func TestTracing(t *testing.T) {
 			sidecar,
 			[]string{"envoy"},
 			&TracingConfig{
-				Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
-				RandomSamplingPercentage: 80,
-				CustomTags: map[string]*tpb.Tracing_CustomTag{
-					"foo": {},
-					"baz": {},
+				ClientSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 80,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"baz": {},
+					},
+					UseRequestIDForTraceSampling: true,
+				},
+				ServerSpec: TracingSpec{
+					Provider:                 &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					RandomSamplingPercentage: 80,
+					CustomTags: map[string]*tpb.Tracing_CustomTag{
+						"foo": {},
+						"baz": {},
+					},
+					UseRequestIDForTraceSampling: true,
+				},
+			},
+		},
+		{
+			"client-only override",
+			[]config.Config{newTelemetry("istio-system", envoy), newTelemetry("default", clientSideSampling)},
+			sidecar,
+			[]string{"envoy"},
+			&TracingConfig{
+				ClientSpec: TracingSpec{
+					Provider: &meshconfig.MeshConfig_ExtensionProvider{
+						Name: "stackdriver",
+						Provider: &meshconfig.MeshConfig_ExtensionProvider_Stackdriver{
+							Stackdriver: &meshconfig.MeshConfig_ExtensionProvider_StackdriverProvider{},
+						},
+					},
+					RandomSamplingPercentage:     99.9,
+					UseRequestIDForTraceSampling: true,
+				},
+				ServerSpec: TracingSpec{
+					Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					UseRequestIDForTraceSampling: true,
+				},
+			},
+		},
+		{
+			"server-only override",
+			[]config.Config{newTelemetry("istio-system", envoy), newTelemetry("default", serverSideDisabled)},
+			sidecar,
+			[]string{"envoy"},
+			&TracingConfig{
+				ClientSpec: TracingSpec{
+					Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					UseRequestIDForTraceSampling: true,
+				},
+				ServerSpec: TracingSpec{
+					Provider:                     &meshconfig.MeshConfig_ExtensionProvider{Name: "envoy"},
+					Disabled:                     true,
+					UseRequestIDForTraceSampling: true,
 				},
-				UseRequestIDForTraceSampling: true,
 			},
 		},
 	}
@@ -565,9 +671,9 @@ func TestTracing(t *testing.T) {
 			telemetry := createTestTelemetries(tt.cfgs, t)
 			telemetry.meshConfig.DefaultProviders.Tracing = tt.defaultProviders
 			got := telemetry.Tracing(tt.proxy)
-			if got != nil && got.Provider != nil {
+			if got != nil && got.ServerSpec.Provider != nil {
 				// We don't match on this, just the name for test simplicity
-				got.Provider.Provider = nil
+				got.ServerSpec.Provider.Provider = nil
 			}
 			assert.Equal(t, got, tt.want)
 		})
diff --git a/pilot/pkg/networking/core/v1alpha3/tracing.go b/pilot/pkg/networking/core/v1alpha3/tracing.go
index a11e24c19b..30257422ed 100644
--- a/pilot/pkg/networking/core/v1alpha3/tracing.go
+++ b/pilot/pkg/networking/core/v1alpha3/tracing.go
@@ -35,6 +35,7 @@
 	"istio.io/istio/pilot/pkg/extensionproviders"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking"
 	authz_model "istio.io/istio/pilot/pkg/security/authz/model"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pilot/pkg/xds/requestidextension"
@@ -73,20 +74,27 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 		return nil, nil
 	}
 
-	if tracing.Disabled {
+	spec := tracing.ServerSpec
+	if opts.class == networking.ListenerClassSidecarOutbound || opts.class == networking.ListenerClassGateway {
+		spec = tracing.ClientSpec
+	}
+
+	if spec.Disabled {
 		return nil, nil
 	}
 
 	var routerFilterCtx *xdsfilters.RouterFilterContext
-	if tracing.Provider != nil {
-		tcfg, rfCtx, err := configureFromProviderConfig(opts.push, opts.proxy.Metadata, tracing.Provider)
+	if spec.Provider != nil {
+		tcfg, rfCtx, err := configureFromProviderConfig(opts.push, opts.proxy.Metadata, spec.Provider)
 		if err != nil {
-			log.Warnf("Not able to configure requested tracing provider %q: %v", tracing.Provider.Name, err)
+			log.Warnf("Not able to configure requested tracing provider %q: %v", spec.Provider.Name, err)
 			return nil, nil
 		}
 		hcm.Tracing = tcfg
 		routerFilterCtx = rfCtx
 	} else {
+		// TODO: should this `return nil, nil` instead ?
+		log.Warnf("Not able to configure tracing provider. Provider lookup failed.")
 		hcm.Tracing = &hpb.HttpConnectionManager_Tracing{}
 		// TODO: transition to configuring providers from proxy config here?
 		// something like: configureFromProxyConfig(tracingCfg, opts.proxy.Metadata.ProxyConfig.Tracing)
@@ -94,8 +102,8 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 
 	// gracefully fallback to MeshConfig configuration. It will act as an implicit
 	// parent configuration during transition period.
-	configureSampling(hcm.Tracing, tracing.RandomSamplingPercentage)
-	configureCustomTags(hcm.Tracing, tracing.CustomTags, proxyCfg, opts.proxy.Metadata)
+	configureSampling(hcm.Tracing, spec.RandomSamplingPercentage)
+	configureCustomTags(hcm.Tracing, spec.CustomTags, proxyCfg, opts.proxy.Metadata)
 
 	// if there is configured max tag length somewhere, fallback to it.
 	if hcm.GetTracing().GetMaxPathTagLength() == nil && proxyCfg.GetTracing().GetMaxPathTagLength() != 0 {
@@ -103,7 +111,7 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 	}
 
 	reqIDExtension := &requestidextension.UUIDRequestIDExtensionContext{}
-	reqIDExtension.UseRequestIDForTraceSampling = tracing.UseRequestIDForTraceSampling
+	reqIDExtension.UseRequestIDForTraceSampling = spec.UseRequestIDForTraceSampling
 	return routerFilterCtx, reqIDExtension
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/tracing_test.go b/pilot/pkg/networking/core/v1alpha3/tracing_test.go
index e1579f000c..b678847357 100644
--- a/pilot/pkg/networking/core/v1alpha3/tracing_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/tracing_test.go
@@ -31,6 +31,7 @@
 	tpb "istio.io/api/telemetry/v1alpha1"
 	"istio.io/istio/pilot/pkg/extensionproviders"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pilot/pkg/xds/requestidextension"
 )
@@ -136,6 +137,22 @@ func TestConfigureTracing(t *testing.T) {
 			wantRfCtx:       &xdsfilters.RouterFilterContext{StartChildSpan: true},
 			wantReqIDExtCtx: &requestidextension.UUIDRequestIDExtensionContext{UseRequestIDForTraceSampling: false},
 		},
+		{
+			name:            "client-only config for server",
+			inSpec:          fakeClientOnlyTracingSpec(fakeSkywalking(), 99.999, false, false),
+			opts:            fakeInboundOptsOnlySkywalkingTelemetryAPI(),
+			want:            nil,
+			wantRfCtx:       nil,
+			wantReqIDExtCtx: nil,
+		},
+		{
+			name:            "server-only config for server",
+			inSpec:          fakeServerOnlyTracingSpec(fakeSkywalking(), 99.999, false, false),
+			opts:            fakeInboundOptsOnlySkywalkingTelemetryAPI(),
+			want:            fakeTracingConfig(fakeSkywalkingProvider(clusterName, providerName), 99.999, 0, append(defaultTracingTags(), fakeEnvTag)),
+			wantRfCtx:       &xdsfilters.RouterFilterContext{StartChildSpan: true},
+			wantReqIDExtCtx: &requestidextension.UUIDRequestIDExtensionContext{UseRequestIDForTraceSampling: false},
+		},
 	}
 
 	for _, tc := range testcases {
@@ -365,6 +382,12 @@ func fakeOptsOnlySkywalkingTelemetryAPI() buildListenerOpts {
 	return opts
 }
 
+func fakeInboundOptsOnlySkywalkingTelemetryAPI() buildListenerOpts {
+	opts := fakeOptsOnlySkywalkingTelemetryAPI()
+	opts.class = networking.ListenerClassSidecarInbound
+	return opts
+}
+
 func fakeTracingSpecNoProvider(sampling float64, disableReporting bool, useRequestIDForTraceSampling bool) *model.TracingConfig {
 	return fakeTracingSpec(nil, sampling, disableReporting, useRequestIDForTraceSampling)
 }
@@ -376,6 +399,37 @@ func fakeTracingSpecNoProviderWithNilCustomTag(sampling float64, disableReportin
 func fakeTracingSpec(provider *meshconfig.MeshConfig_ExtensionProvider, sampling float64, disableReporting bool,
 	useRequestIDForTraceSampling bool) *model.TracingConfig {
 	t := &model.TracingConfig{
+		ClientSpec: tracingSpec(provider, sampling, disableReporting, useRequestIDForTraceSampling),
+		ServerSpec: tracingSpec(provider, sampling, disableReporting, useRequestIDForTraceSampling),
+	}
+	return t
+}
+
+func fakeClientOnlyTracingSpec(provider *meshconfig.MeshConfig_ExtensionProvider, sampling float64, disableReporting bool,
+	useRequestIDForTraceSampling bool) *model.TracingConfig {
+	t := &model.TracingConfig{
+		ClientSpec: tracingSpec(provider, sampling, disableReporting, useRequestIDForTraceSampling),
+		ServerSpec: model.TracingSpec{
+			Disabled: true,
+		},
+	}
+	return t
+}
+
+func fakeServerOnlyTracingSpec(provider *meshconfig.MeshConfig_ExtensionProvider, sampling float64, disableReporting bool,
+	useRequestIDForTraceSampling bool) *model.TracingConfig {
+	t := &model.TracingConfig{
+		ClientSpec: model.TracingSpec{
+			Disabled: true,
+		},
+		ServerSpec: tracingSpec(provider, sampling, disableReporting, useRequestIDForTraceSampling),
+	}
+	return t
+}
+
+func tracingSpec(provider *meshconfig.MeshConfig_ExtensionProvider, sampling float64, disableReporting bool,
+	useRequestIDForTraceSampling bool) model.TracingSpec {
+	return model.TracingSpec{
 		Provider:                 provider,
 		Disabled:                 disableReporting,
 		RandomSamplingPercentage: sampling,
@@ -390,19 +444,29 @@ func fakeTracingSpec(provider *meshconfig.MeshConfig_ExtensionProvider, sampling
 		},
 		UseRequestIDForTraceSampling: useRequestIDForTraceSampling,
 	}
-	return t
 }
 
 func fakeTracingSpecWithNilCustomTag(provider *meshconfig.MeshConfig_ExtensionProvider, sampling float64, disableReporting bool,
 	useRequestIDForTraceSampling bool) *model.TracingConfig {
 	t := &model.TracingConfig{
-		Provider:                 provider,
-		Disabled:                 disableReporting,
-		RandomSamplingPercentage: sampling,
-		CustomTags: map[string]*tpb.Tracing_CustomTag{
-			"test": nil,
+		ClientSpec: model.TracingSpec{
+			Provider:                 provider,
+			Disabled:                 disableReporting,
+			RandomSamplingPercentage: sampling,
+			CustomTags: map[string]*tpb.Tracing_CustomTag{
+				"test": nil,
+			},
+			UseRequestIDForTraceSampling: useRequestIDForTraceSampling,
+		},
+		ServerSpec: model.TracingSpec{
+			Provider:                 provider,
+			Disabled:                 disableReporting,
+			RandomSamplingPercentage: sampling,
+			CustomTags: map[string]*tpb.Tracing_CustomTag{
+				"test": nil,
+			},
+			UseRequestIDForTraceSampling: useRequestIDForTraceSampling,
 		},
-		UseRequestIDForTraceSampling: useRequestIDForTraceSampling,
 	}
 	return t
 }
diff --git a/releasenotes/notes/38250.yaml b/releasenotes/notes/38250.yaml
new file mode 100644
index 0000000000..26ee56fd00
--- /dev/null
+++ b/releasenotes/notes/38250.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: telemetry
+issue: []
+releaseNotes:
+- |
+  **Added** support for tracing WorkloadMode in Telemetry API. This will allow customization of tracing behavior based on traffic direction.
-- 
2.35.3

