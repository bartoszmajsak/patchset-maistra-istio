From 903b7658ef21d7dc6a2e0d8e8c11120181a7087d Mon Sep 17 00:00:00 2001
From: zirain <hejianpeng2@huawei.com>
Date: Fri, 22 Apr 2022 15:26:49 +0800
Subject: make redis op timeout configurable (#38522)

* make redis op time configurable

* fix gen
---
 pilot/pkg/model/context.go                    |  4 +++
 .../networking/core/v1alpha3/networkfilter.go | 19 +++++++----
 .../core/v1alpha3/networkfilter_test.go       | 32 ++++++++++++++++++-
 3 files changed, 47 insertions(+), 8 deletions(-)

diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 65f3d9ad22..641eb7c832 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -623,6 +623,10 @@ type NodeMetadata struct {
 	// redirected tcp listeners. This does not change the virtualOutbound listener.
 	OutboundListenerExactBalance StringBool `json:"OUTBOUND_LISTENER_EXACT_BALANCE,omitempty"`
 
+	// RedisOpTimeout specifies the operation timeout for the Redis proxy filter, in duration format (10s).
+	// If not set, default timeout is 5s.
+	RedisOpTimeout string `json:"REDIS_OP_TIMEOUT,omitempty"`
+
 	// Contains a copy of the raw metadata. This is needed to lookup arbitrary values.
 	// If a value is known ahead of time it should be added to the struct rather than reading from here,
 	Raw map[string]interface{} `json:"-"`
diff --git a/pilot/pkg/networking/core/v1alpha3/networkfilter.go b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
index 9e50dc1b23..6fb19d17d6 100644
--- a/pilot/pkg/networking/core/v1alpha3/networkfilter.go
+++ b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
@@ -76,7 +76,7 @@ func buildInboundNetworkFilters(push *model.PushContext, proxy *model.Proxy, ins
 	var filters []*listener.Filter
 	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, proxy, istionetworking.ListenerClassSidecarInbound)...)
-	filters = append(filters, buildNetworkFiltersStack(instance.ServicePort, tcpFilter, statPrefix, clusterName)...)
+	filters = append(filters, buildNetworkFiltersStack(proxy, instance.ServicePort, tcpFilter, statPrefix, clusterName)...)
 	return filters
 }
 
@@ -111,7 +111,7 @@ func buildOutboundNetworkFiltersWithSingleDestination(push *model.PushContext, n
 	var filters []*listener.Filter
 	filters = append(filters, buildMetadataExchangeNetworkFilters(model.OutboundListenerClass(node.Type))...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, model.OutboundListenerClass(node.Type))...)
-	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
+	filters = append(filters, buildNetworkFiltersStack(node, port, tcpFilter, statPrefix, clusterName)...)
 	return filters
 }
 
@@ -155,7 +155,7 @@ func buildOutboundNetworkFiltersWithWeightedClusters(node *model.Proxy, routes [
 	var filters []*listener.Filter
 	filters = append(filters, buildMetadataExchangeNetworkFilters(model.OutboundListenerClass(node.Type))...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, model.OutboundListenerClass(node.Type))...)
-	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
+	filters = append(filters, buildNetworkFiltersStack(node, port, tcpFilter, statPrefix, clusterName)...)
 	return filters
 }
 
@@ -188,7 +188,7 @@ func maybeSetHashPolicy(destinationRule *networking.DestinationRule, tcpProxy *t
 
 // buildNetworkFiltersStack builds a slice of network filters based on
 // the protocol in use and the given TCP filter instance.
-func buildNetworkFiltersStack(port *model.Port, tcpFilter *listener.Filter, statPrefix string, clusterName string) []*listener.Filter {
+func buildNetworkFiltersStack(node *model.Proxy, port *model.Port, tcpFilter *listener.Filter, statPrefix string, clusterName string) []*listener.Filter {
 	filterstack := make([]*listener.Filter, 0)
 	switch port.Protocol {
 	case protocol.Mongo:
@@ -200,7 +200,7 @@ func buildNetworkFiltersStack(port *model.Port, tcpFilter *listener.Filter, stat
 	case protocol.Redis:
 		if features.EnableRedisFilter {
 			// redis filter has route config, it is a terminating filter, no need append tcp filter.
-			filterstack = append(filterstack, buildRedisFilter(statPrefix, clusterName))
+			filterstack = append(filterstack, buildRedisFilter(node, statPrefix, clusterName))
 		} else {
 			filterstack = append(filterstack, tcpFilter)
 		}
@@ -277,12 +277,17 @@ func buildOutboundAutoPassthroughFilterStack(push *model.PushContext, node *mode
 // buildRedisFilter builds an outbound Envoy RedisProxy filter.
 // Currently, if multiple clusters are defined, one of them will be picked for
 // configuring the Redis proxy.
-func buildRedisFilter(statPrefix, clusterName string) *listener.Filter {
+func buildRedisFilter(node *model.Proxy, statPrefix, clusterName string) *listener.Filter {
+	opTimeout, err := time.ParseDuration(node.Metadata.RedisOpTimeout)
+	if err != nil {
+		opTimeout = redisOpTimeout
+	}
+
 	redisProxy := &redis.RedisProxy{
 		LatencyInMicros: true,       // redis latency stats are captured in micro seconds which is typically the case.
 		StatPrefix:      statPrefix, // redis stats are prefixed with redis.<statPrefix> by Envoy
 		Settings: &redis.RedisProxy_ConnPoolSettings{
-			OpTimeout: durationpb.New(redisOpTimeout), // TODO: Make this user configurable
+			OpTimeout: durationpb.New(opTimeout),
 		},
 		PrefixRoutes: &redis.RedisProxy_PrefixRoutes{
 			CatchAllRoute: &redis.RedisProxy_PrefixRoutes_Route{
diff --git a/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go b/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
index 4a93f3fc65..85402bbad2 100644
--- a/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
@@ -33,7 +33,8 @@
 )
 
 func TestBuildRedisFilter(t *testing.T) {
-	redisFilter := buildRedisFilter("redis", "redis-cluster")
+	node := getProxy()
+	redisFilter := buildRedisFilter(node, "redis", "redis-cluster")
 	if redisFilter.Name != wellknown.RedisProxy {
 		t.Errorf("redis filter name is %s not %s", redisFilter.Name, wellknown.RedisProxy)
 	}
@@ -56,6 +57,35 @@ func TestBuildRedisFilter(t *testing.T) {
 	}
 }
 
+func TestBuildRedisFilterCustomTimeout(t *testing.T) {
+	node := getProxy()
+	node.Metadata.RedisOpTimeout = "15s"
+	redisFilter := buildRedisFilter(node, "redis", "redis-cluster")
+	if redisFilter.Name != wellknown.RedisProxy {
+		t.Errorf("redis filter name is %s not %s", redisFilter.Name, wellknown.RedisProxy)
+	}
+	if config, ok := redisFilter.ConfigType.(*listener.Filter_TypedConfig); ok {
+		redisProxy := redis.RedisProxy{}
+		if err := config.TypedConfig.UnmarshalTo(&redisProxy); err != nil {
+			t.Errorf("unmarshal failed: %v", err)
+		}
+		if redisProxy.StatPrefix != "redis" {
+			t.Errorf("redis proxy statPrefix is %s", redisProxy.StatPrefix)
+		}
+		if !redisProxy.LatencyInMicros {
+			t.Errorf("redis proxy latency stat is not configured for microseconds")
+		}
+		if redisProxy.PrefixRoutes.CatchAllRoute.Cluster != "redis-cluster" {
+			t.Errorf("redis proxy's PrefixRoutes.CatchAllCluster is %s", redisProxy.PrefixRoutes.CatchAllRoute.Cluster)
+		}
+		if redisProxy.Settings.OpTimeout.Seconds != 15 {
+			t.Errorf("redis proxy's Settings.OpTimeout is %s", redisProxy.Settings.OpTimeout)
+		}
+	} else {
+		t.Errorf("redis filter type is %T not listener.Filter_TypedConfig ", redisFilter.ConfigType)
+	}
+}
+
 func TestInboundNetworkFilterStatPrefix(t *testing.T) {
 	cases := []struct {
 		name               string
-- 
2.35.3

