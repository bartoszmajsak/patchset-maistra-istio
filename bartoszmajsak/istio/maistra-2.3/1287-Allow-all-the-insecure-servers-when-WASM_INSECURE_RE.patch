From a340d9ec3e3ef6a76f963855f613267ebcd61cea Mon Sep 17 00:00:00 2001
From: Ingwon Song <102102227+ingwonsong@users.noreply.github.com>
Date: Thu, 19 May 2022 12:55:27 -0700
Subject: Allow all the insecure servers when WASM_INSECURE_REGISTRIES has a
 "*" (#39024)

* Allow all the insecure servers when the environment variable WASM_INSECURE_REGISTRIES has a "*"

* Fix the flakiness
---
 pkg/wasm/cache.go                         | 15 +++--
 pkg/wasm/cache_test.go                    | 75 +++++++++++++++--------
 releasenotes/notes/wasm-insecure-all.yaml |  7 +++
 3 files changed, 68 insertions(+), 29 deletions(-)
 create mode 100644 releasenotes/notes/wasm-insecure-all.yaml

diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 62a41a8a3b..36f1b549c8 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -81,9 +81,10 @@ type LocalFileCache struct {
 	mux sync.Mutex
 
 	// Duration for stale Wasm module purging.
-	purgeInterval      time.Duration
-	wasmModuleExpiry   time.Duration
-	insecureRegistries sets.Set
+	purgeInterval              time.Duration
+	wasmModuleExpiry           time.Duration
+	insecureRegistries         sets.Set
+	allowAllInsecureRegistries bool
 
 	// stopChan currently is only used by test
 	stopChan chan struct{}
@@ -127,6 +128,7 @@ type cacheEntry struct {
 
 // NewLocalFileCache create a new Wasm module cache which downloads and stores Wasm module files locally.
 func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, insecureRegistries []string) *LocalFileCache {
+	ir := sets.New(insecureRegistries...)
 	cache := &LocalFileCache{
 		httpFetcher:        NewHTTPFetcher(DefaultWasmHTTPRequestTimeout),
 		modules:            make(map[moduleKey]*cacheEntry),
@@ -135,8 +137,11 @@ func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, in
 		purgeInterval:      purgeInterval,
 		wasmModuleExpiry:   moduleExpiry,
 		stopChan:           make(chan struct{}),
-		insecureRegistries: sets.New(insecureRegistries...),
+		insecureRegistries: ir,
+		// If the set of the given insecure registries contains "*", then allow all the insecure registries.
+		allowAllInsecureRegistries: ir.Contains("*"),
 	}
+
 	go func() {
 		cache.purge()
 	}()
@@ -203,7 +208,7 @@ func (c *LocalFileCache) Get(
 	// Hex-Encoded sha256 checksum of binary.
 	var dChecksum string
 	var binaryFetcher func() ([]byte, error)
-	insecure := c.insecureRegistries.Contains(u.Host)
+	insecure := c.allowAllInsecureRegistries || c.insecureRegistries.Contains(u.Host)
 
 	ctx, cancel := context.WithTimeout(context.Background(), timeout)
 	defer cancel()
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index 60c99b400f..d4ae0adb81 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -16,6 +16,7 @@
 
 import (
 	"crypto/sha256"
+	"crypto/tls"
 	"encoding/hex"
 	"fmt"
 	"net/http"
@@ -34,6 +35,7 @@
 	"github.com/google/go-containerregistry/pkg/registry"
 	"github.com/google/go-containerregistry/pkg/v1/empty"
 	"github.com/google/go-containerregistry/pkg/v1/mutate"
+	"github.com/google/go-containerregistry/pkg/v1/remote"
 	"github.com/google/go-containerregistry/pkg/v1/types"
 
 	extensions "istio.io/api/extensions/v1alpha1"
@@ -78,7 +80,7 @@ func TestWasmCache(t *testing.T) {
 		t.Fatal(err)
 	}
 
-	_, dockerImageDigest, invalidOCIImageDigest := setupOCIRegistry(t, ou.Host)
+	dockerImageDigest, invalidOCIImageDigest := setupOCIRegistry(t, ou.Host)
 
 	ociWasmFile := fmt.Sprintf("%s.wasm", dockerImageDigest)
 	ociURLWithTag := fmt.Sprintf("oci://%s/test/valid/docker:v0.1.0", ou.Host)
@@ -223,10 +225,8 @@ func TestWasmCache(t *testing.T) {
 			wantVisitServer:     true,
 		},
 		{
-			name: "purge on expiry",
-			initialCachedModules: map[moduleKey]cacheEntry{
-				{name: urlAsResourceName(ts.URL), checksum: httpDataCheckSum}: {modulePath: fmt.Sprintf("%s.wasm", httpDataCheckSum)},
-			},
+			name:                   "purge on expiry",
+			initialCachedModules:   map[moduleKey]cacheEntry{},
 			initialCachedChecksums: map[string]*checksumEntry{},
 			fetchURL:               ts.URL,
 			purgeInterval:          1 * time.Millisecond,
@@ -234,12 +234,10 @@ func TestWasmCache(t *testing.T) {
 			checkPurgeTimeout:      5 * time.Second,
 			checksum:               httpDataCheckSum,
 			requestTimeout:         time.Second * 10,
-			wantCachedModules: map[moduleKey]*cacheEntry{
-				{name: ts.URL, checksum: httpDataCheckSum}: {modulePath: httpDataCheckSum + ".wasm"},
-			},
-			wantCachedChecksums: map[string]*checksumEntry{},
-			wantFileName:        fmt.Sprintf("%s.wasm", httpDataCheckSum),
-			wantVisitServer:     true,
+			wantCachedModules:      map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:    map[string]*checksumEntry{},
+			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
+			wantVisitServer:        true,
 		},
 		{
 			name:                   "fetch oci without digest",
@@ -593,9 +591,7 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:  1 * time.Millisecond,
 			requestTimeout:    time.Second * 10,
 			checkPurgeTimeout: 5 * time.Second,
-			wantCachedModules: map[moduleKey]*cacheEntry{
-				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
-			},
+			wantCachedModules: map[moduleKey]*cacheEntry{},
 			wantCachedChecksums: map[string]*checksumEntry{
 				"test-url": {checksum: "test-checksum", resourceVersionByResource: map[string]string{"namespace.resource2": "123456"}},
 			},
@@ -692,6 +688,10 @@ func TestWasmCache(t *testing.T) {
 			}
 			cache.mux.Unlock()
 
+			atomic.StoreInt32(&tsNumRequest, 0)
+			gotFilePath, gotErr := cache.Get(c.fetchURL, c.checksum, c.resourceName, c.resourceVersion, c.requestTimeout, []byte{}, c.pullPolicy)
+			serverVisited := atomic.LoadInt32(&tsNumRequest) > 0
+
 			if c.checkPurgeTimeout > 0 {
 				moduleDeleted := false
 				for start := time.Now(); time.Since(start) < c.checkPurgeTimeout; {
@@ -707,10 +707,6 @@ func TestWasmCache(t *testing.T) {
 				}
 			}
 
-			atomic.StoreInt32(&tsNumRequest, 0)
-			gotFilePath, gotErr := cache.Get(c.fetchURL, c.checksum, c.resourceName, c.resourceVersion, c.requestTimeout, []byte{}, c.pullPolicy)
-			serverVisited := atomic.LoadInt32(&tsNumRequest) > 0
-
 			cache.mux.Lock()
 			if cacheHitKey != nil {
 				if entry, ok := cache.modules[*cacheHitKey]; ok && entry.last == initTime {
@@ -753,10 +749,13 @@ func TestWasmCache(t *testing.T) {
 	}
 }
 
-func setupOCIRegistry(t *testing.T, host string) (wantBinaryCheckSum, dockerImageDigest, invalidOCIImageDigest string) {
+func setupOCIRegistry(t *testing.T, host string) (dockerImageDigest, invalidOCIImageDigest string) {
 	// Push *compat* variant docker image (others are well tested in imagefetcher's test and the behavior is consistent).
 	ref := fmt.Sprintf("%s/test/valid/docker:v0.1.0", host)
 	binary := append(wasmHeader, []byte("this is wasm plugin")...)
+	transport := remote.DefaultTransport.Clone()
+	transport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
+	fetchOpt := crane.WithTransport(transport)
 
 	// Create docker layer.
 	l, err := newMockLayer(types.DockerLayer,
@@ -777,21 +776,19 @@ func setupOCIRegistry(t *testing.T, host string) (wantBinaryCheckSum, dockerImag
 	manifest.MediaType = types.DockerManifestSchema2
 
 	// Push image to the registry.
-	err = crane.Push(img, ref)
+	err = crane.Push(img, ref, fetchOpt)
 	if err != nil {
 		t.Fatal(err)
 	}
 
 	// Push image to the registry with latest tag as well
 	ref = fmt.Sprintf("%s/test/valid/docker:latest", host)
-	err = crane.Push(img, ref)
+	err = crane.Push(img, ref, fetchOpt)
 	if err != nil {
 		t.Fatal(err)
 	}
 
 	// Calculate sum
-	sha := sha256.Sum256(binary)
-	wantBinaryCheckSum = hex.EncodeToString(sha[:])
 	d, _ := img.Digest()
 	dockerImageDigest = d.Hex
 
@@ -813,7 +810,7 @@ func setupOCIRegistry(t *testing.T, host string) (wantBinaryCheckSum, dockerImag
 	invalidOCIImageDigest = d.Hex
 
 	// Push image to the registry.
-	err = crane.Push(img2, ref)
+	err = crane.Push(img2, ref, fetchOpt)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -828,6 +825,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 	gotNumRequest := 0
 	binary1 := append(wasmHeader, 1)
 	binary2 := append(wasmHeader, 2)
+
 	// Create a test server which returns 0 for the first two calls, and returns 1 for the following calls.
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		if gotNumRequest <= 1 {
@@ -875,3 +873,32 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 		t.Errorf("wasm download call got %v want %v", gotNumRequest, wantNumRequest)
 	}
 }
+
+func TestAllInsecureServer(t *testing.T) {
+	tmpDir := t.TempDir()
+	cache := NewLocalFileCache(tmpDir, DefaultWasmModulePurgeInterval, DefaultWasmModuleExpiry, []string{"*"})
+	defer close(cache.stopChan)
+
+	// Set up a fake registry for OCI images with TLS Server
+	// Without "insecure" option, this should cause an error.
+	tos := httptest.NewTLSServer(registry.New())
+	defer tos.Close()
+	ou, err := url.Parse(tos.URL)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	dockerImageDigest, _ := setupOCIRegistry(t, ou.Host)
+	ociURLWithTag := fmt.Sprintf("oci://%s/test/valid/docker:v0.1.0", ou.Host)
+	var defaultPullPolicy extensions.PullPolicy
+
+	gotFilePath, err := cache.Get(ociURLWithTag, "", "namespace.resource", "123456", time.Second*10, []byte{}, defaultPullPolicy)
+	if err != nil {
+		t.Fatalf("failed to download Wasm module: %v", err)
+	}
+
+	wantFilePath := filepath.Join(tmpDir, fmt.Sprintf("%s.wasm", dockerImageDigest))
+	if gotFilePath != wantFilePath {
+		t.Errorf("Wasm module local file path got %v, want %v", gotFilePath, wantFilePath)
+	}
+}
diff --git a/releasenotes/notes/wasm-insecure-all.yaml b/releasenotes/notes/wasm-insecure-all.yaml
new file mode 100644
index 0000000000..fa42c6a7ef
--- /dev/null
+++ b/releasenotes/notes/wasm-insecure-all.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: extensibility
+issue: []
+releaseNotes:
+  - |
+    **Added** allow all insecure servers when one of the host name in the environment variable WASM_INSECURE_REGISTRIES is *.
-- 
2.35.3

