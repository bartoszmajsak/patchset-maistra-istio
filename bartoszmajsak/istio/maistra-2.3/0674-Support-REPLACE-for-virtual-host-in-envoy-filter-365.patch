From b020516b7ddcfc19f4b635a3c85a8eb7b25b2b12 Mon Sep 17 00:00:00 2001
From: dwq <41563853+dddddai@users.noreply.github.com>
Date: Tue, 1 Mar 2022 10:02:53 +0800
Subject: Support REPLACE for virtual host in envoy filter (#36582)

* support replace for virtual host in envoy filter

* rebase
---
 .../core/v1alpha3/envoyfilter/rc_patch.go     |  19 +--
 .../v1alpha3/envoyfilter/rc_patch_test.go     | 121 ++++++++++++++++++
 releasenotes/notes/replace-virtualhost.yaml   |   9 ++
 3 files changed, 141 insertions(+), 8 deletions(-)
 create mode 100644 releasenotes/notes/replace-virtualhost.yaml

diff --git a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
index ff1d6dd178..73695650a0 100644
--- a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
+++ b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch.go
@@ -70,10 +70,10 @@ func patchVirtualHosts(patchContext networking.EnvoyFilter_PatchContext,
 	patches map[networking.EnvoyFilter_ApplyTo][]*model.EnvoyFilterConfigPatchWrapper,
 	routeConfiguration *route.RouteConfiguration, portMap model.GatewayPortMap) {
 	removedVirtualHosts := sets.NewSet()
-	// first do removes/merges
-	for _, vhost := range routeConfiguration.VirtualHosts {
-		if patchVirtualHost(patchContext, patches, routeConfiguration, vhost, portMap) {
-			removedVirtualHosts.Insert(vhost.Name)
+	// first do removes/merges/replaces
+	for i := range routeConfiguration.VirtualHosts {
+		if patchVirtualHost(patchContext, patches, routeConfiguration, routeConfiguration.VirtualHosts, i, portMap) {
+			removedVirtualHosts.Insert(routeConfiguration.VirtualHosts[i].Name)
 		}
 	}
 
@@ -106,22 +106,25 @@ func patchVirtualHosts(patchContext networking.EnvoyFilter_PatchContext,
 // The return value indicates whether the virtual host has been removed for REMOVE operations.
 func patchVirtualHost(patchContext networking.EnvoyFilter_PatchContext,
 	patches map[networking.EnvoyFilter_ApplyTo][]*model.EnvoyFilterConfigPatchWrapper,
-	routeConfiguration *route.RouteConfiguration, virtualHost *route.VirtualHost, portMap model.GatewayPortMap) bool {
+	routeConfiguration *route.RouteConfiguration, virtualHosts []*route.VirtualHost,
+	idx int, portMap model.GatewayPortMap) bool {
 	for _, rp := range patches[networking.EnvoyFilter_VIRTUAL_HOST] {
 		applied := false
 		if commonConditionMatch(patchContext, rp) &&
 			routeConfigurationMatch(patchContext, routeConfiguration, rp, portMap) &&
-			virtualHostMatch(virtualHost, rp) {
+			virtualHostMatch(virtualHosts[idx], rp) {
 			applied = true
 			if rp.Operation == networking.EnvoyFilter_Patch_REMOVE {
 				return true
 			} else if rp.Operation == networking.EnvoyFilter_Patch_MERGE {
-				proto.Merge(virtualHost, rp.Value)
+				proto.Merge(virtualHosts[idx], rp.Value)
+			} else if rp.Operation == networking.EnvoyFilter_Patch_REPLACE {
+				virtualHosts[idx] = proto.Clone(rp.Value).(*route.VirtualHost)
 			}
 		}
 		IncrementEnvoyFilterMetric(rp.Key(), VirtualHost, applied)
 	}
-	patchHTTPRoutes(patchContext, patches, routeConfiguration, virtualHost, portMap)
+	patchHTTPRoutes(patchContext, patches, routeConfiguration, virtualHosts[idx], portMap)
 	return false
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch_test.go b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch_test.go
index 300a226bf4..3a44eea23e 100644
--- a/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/envoyfilter/rc_patch_test.go
@@ -729,6 +729,127 @@ type args struct {
 	}
 }
 
+func TestReplaceVhost(t *testing.T) {
+	configPatches := []*networking.EnvoyFilter_EnvoyConfigObjectPatch{
+		{
+			ApplyTo: networking.EnvoyFilter_VIRTUAL_HOST,
+			Match: &networking.EnvoyFilter_EnvoyConfigObjectMatch{
+				Context: networking.EnvoyFilter_SIDECAR_INBOUND,
+				ObjectTypes: &networking.EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration{
+					RouteConfiguration: &networking.EnvoyFilter_RouteConfigurationMatch{
+						Vhost: &networking.EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch{
+							Name: "to-be-replaced",
+						},
+					},
+				},
+			},
+			Patch: &networking.EnvoyFilter_Patch{
+				Operation: networking.EnvoyFilter_Patch_REPLACE,
+				Value: buildPatchStruct(`{
+				"name":"replaced",
+				"domains":["replaced.com"],
+				"rate_limits": [
+				  {
+					"actions": [
+					  {
+						"request_headers": {
+						  "header_name": ":path",
+						  "descriptor_key": "PATH"
+						}
+					  }
+					]
+				  }
+				]
+			  }`),
+			},
+		},
+	}
+
+	sidecarInboundRCToBeReplaced := &route.RouteConfiguration{
+		Name: "inbound|http|80",
+		VirtualHosts: []*route.VirtualHost{
+			{
+				Name:    "to-be-replaced",
+				Domains: []string{"xxx"},
+				Routes: []*route.Route{
+					{
+						Name: "xxx",
+						Action: &route.Route_Route{
+							Route: &route.RouteAction{
+								PrefixRewrite: "/xxx",
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	replacedSidecarInboundRC := &route.RouteConfiguration{
+		Name: "inbound|http|80",
+		VirtualHosts: []*route.VirtualHost{
+			{
+				Name:    "replaced",
+				Domains: []string{"replaced.com"},
+				RateLimits: []*route.RateLimit{
+					{
+						Actions: []*route.RateLimit_Action{
+							{
+								ActionSpecifier: &route.RateLimit_Action_RequestHeaders_{
+									RequestHeaders: &route.RateLimit_Action_RequestHeaders{
+										HeaderName:    ":path",
+										DescriptorKey: "PATH",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+
+	serviceDiscovery := memory.NewServiceDiscovery()
+	env := newTestEnvironment(serviceDiscovery, testMesh, buildEnvoyFilterConfigStore(configPatches))
+	push := model.NewPushContext()
+	push.InitContext(env, nil, nil)
+
+	sidecarNode := &model.Proxy{Type: model.SidecarProxy, ConfigNamespace: "not-default"}
+
+	type args struct {
+		patchContext       networking.EnvoyFilter_PatchContext
+		proxy              *model.Proxy
+		push               *model.PushContext
+		routeConfiguration *route.RouteConfiguration
+	}
+	tests := []struct {
+		name string
+		args args
+		want *route.RouteConfiguration
+	}{
+		{
+			name: "sidecar inbound vhost replace",
+			args: args{
+				patchContext:       networking.EnvoyFilter_SIDECAR_INBOUND,
+				proxy:              sidecarNode,
+				push:               push,
+				routeConfiguration: sidecarInboundRCToBeReplaced,
+			},
+			want: replacedSidecarInboundRC,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			efw := tt.args.push.EnvoyFilters(tt.args.proxy)
+			got := ApplyRouteConfigurationPatches(tt.args.patchContext, tt.args.proxy,
+				efw, tt.args.routeConfiguration)
+			if diff := cmp.Diff(tt.want, got, protocmp.Transform()); diff != "" {
+				t.Errorf("ReplaceVhost(): %s mismatch (-want +got):\n%s", tt.name, diff)
+			}
+		})
+	}
+}
+
 func Test_routeMatch(t *testing.T) {
 	type args struct {
 		httpRoute *route.Route
diff --git a/releasenotes/notes/replace-virtualhost.yaml b/releasenotes/notes/replace-virtualhost.yaml
new file mode 100644
index 0000000000..3175bd2dcf
--- /dev/null
+++ b/releasenotes/notes/replace-virtualhost.yaml
@@ -0,0 +1,9 @@
+apiVersion: release-notes/v2
+kind: feature
+area: traffic-management
+issues:
+- https://github.com/istio/istio/issues/36415
+
+releaseNotes:
+- |
+  **Added** support REPLACE for virtual host in envoy filter
-- 
2.35.3

