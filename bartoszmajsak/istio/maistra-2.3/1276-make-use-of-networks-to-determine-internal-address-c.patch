From 9b39302f74ad21f1af00e3fb0ccacd8911594946 Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Wed, 18 May 2022 22:58:43 +0530
Subject: make use of networks to determine internal address config (#38801)

* make use of networks to determine internal address config

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* add test and release notes

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* lint

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 pilot/pkg/bootstrap/mesh.go                   |  21 +++
 pilot/pkg/features/pilot.go                   |   3 +
 pilot/pkg/model/context.go                    |   7 +
 pilot/pkg/model/push_context.go               |   3 +
 pilot/pkg/networking/core/v1alpha3/gateway.go |  28 +++-
 .../networking/core/v1alpha3/gateway_test.go  |  71 ++++++++-
 .../pkg/networking/core/v1alpha3/listener.go  | 123 ----------------
 .../core/v1alpha3/listener_builder.go         | 136 ++++++++++++++++++
 .../core/v1alpha3/listener_builder_test.go    |  74 ++++++++++
 pkg/config/mesh/networks_watcher.go           |  19 ++-
 releasenotes/notes/38801.yaml                 |   7 +
 11 files changed, 358 insertions(+), 134 deletions(-)
 create mode 100644 releasenotes/notes/38801.yaml

diff --git a/pilot/pkg/bootstrap/mesh.go b/pilot/pkg/bootstrap/mesh.go
index d0e6bdf2e6..3bbb03f2c2 100644
--- a/pilot/pkg/bootstrap/mesh.go
+++ b/pilot/pkg/bootstrap/mesh.go
@@ -17,8 +17,11 @@
 import (
 	"encoding/json"
 	"os"
+	"reflect"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/config/mesh/kubemesh"
 	"istio.io/pkg/filewatcher"
@@ -115,6 +118,24 @@ func (s *Server) initMeshNetworks(args *PilotArgs, fileWatcher filewatcher.FileW
 		log.Info("mesh networks configuration not provided")
 		s.environment.NetworksWatcher = mesh.NewFixedNetworksWatcher(nil)
 	}
+	s.environment.AddNetworksHandler(func() {
+		oldNetworks := s.environment.NetworksWatcher.PrevNetworks()
+		currNetworks := s.environment.NetworksWatcher.Networks()
+
+		oldEndpoints := make([]*meshconfig.Network_NetworkEndpoints, 0)
+		newEndpoints := make([]*meshconfig.Network_NetworkEndpoints, 0)
+		for _, networkconf := range currNetworks.Networks {
+			oldEndpoints = append(oldEndpoints, networkconf.Endpoints...)
+		}
+		for _, networkconf := range oldNetworks.Networks {
+			newEndpoints = append(newEndpoints, networkconf.Endpoints...)
+		}
+
+		if !reflect.DeepEqual(newEndpoints, oldEndpoints) {
+			log.Infof("network endpoints changed, triggering push")
+			s.XDSServer.ConfigUpdate(&model.PushRequest{Full: true, Reason: []model.TriggerReason{model.NetworksTrigger}})
+		}
+	})
 }
 
 func getMeshConfigMapName(revision string) string {
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index ffc22c0aae..0ee9cf996b 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -616,6 +616,9 @@
 	VerifySDSCertificate = env.RegisterBoolVar("VERIFY_SDS_CERTIFICATE", true,
 		"If enabled, certificates fetched from SDS server will be verified before sending back to proxy.").Get()
 
+	EnableHCMInternalNetworks = env.RegisterBoolVar("ENABLE_HCM_INTERNAL_NETWORKS", false,
+		"If enable, endpoints defined in mesh networks will be configured as internal addresses in Http Connection Manager").Get()
+
 	CanonicalServiceForMeshExternalServiceEntry = env.RegisterBoolVar("LABEL_CANONICAL_SERVICES_FOR_MESH_EXTERNAL_SERVICE_ENTRIES", false,
 		"If enabled, metadata representing canonical services for ServiceEntry resources with a location of mesh_external will be populated"+
 			"in the cluster metadata for those endpoints.").Get()
diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 77dc230917..c933964b25 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -98,6 +98,13 @@ func (e *Environment) Mesh() *meshconfig.MeshConfig {
 	return nil
 }
 
+func (e *Environment) MeshNetworks() *meshconfig.MeshNetworks {
+	if e != nil && e.NetworksWatcher != nil {
+		return e.NetworksWatcher.Networks()
+	}
+	return nil
+}
+
 // GetDiscoveryAddress parses the DiscoveryAddress specified via MeshConfig.
 func (e *Environment) GetDiscoveryAddress() (host.Name, string, error) {
 	proxyConfig := mesh.DefaultProxyConfig()
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 6df359dacd..a38b40ebf7 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -244,6 +244,8 @@ type PushContext struct {
 	// this is mainly used for kubernetes multi-cluster scenario
 	networkMgr *NetworkManager
 
+	Networks *meshconfig.MeshNetworks
+
 	InitDone        atomic.Bool
 	initializeMutex sync.Mutex
 }
@@ -1103,6 +1105,7 @@ func (ps *PushContext) InitContext(env *Environment, oldPushContext *PushContext
 	}
 
 	ps.Mesh = env.Mesh()
+	ps.Networks = env.MeshNetworks()
 	ps.LedgerVersion = env.Version()
 
 	// Must be initialized first
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway.go b/pilot/pkg/networking/core/v1alpha3/gateway.go
index 1c43ac087f..7fc8baff67 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway.go
@@ -196,7 +196,7 @@ func (configgen *ConfigGeneratorImpl) buildGatewayTCPBasedFilterChains(
 		port := &networking.Port{Number: port.Number, Protocol: port.Protocol}
 		opts.filterChainOpts = []*filterChainOpts{
 			configgen.createGatewayHTTPFilterChainOpts(builder.node, port, nil, serversForPort.RouteName,
-				proxyConfig, istionetworking.ListenerProtocolTCP),
+				proxyConfig, istionetworking.ListenerProtocolTCP, builder.push),
 		}
 		newFilterChains = append(newFilterChains, istionetworking.FilterChain{
 			ListenerProtocol: istionetworking.ListenerProtocolHTTP,
@@ -213,7 +213,7 @@ func (configgen *ConfigGeneratorImpl) buildGatewayTCPBasedFilterChains(
 				routeName := mergedGateway.TLSServerInfo[server].RouteName
 				// This is a HTTPS server, where we are doing TLS termination. Build a http connection manager with TLS context
 				tcpFilterChainOpts = append(tcpFilterChainOpts, configgen.createGatewayHTTPFilterChainOpts(builder.node, server.Port, server,
-					routeName, proxyConfig, istionetworking.TransportProtocolTCP))
+					routeName, proxyConfig, istionetworking.TransportProtocolTCP, builder.push))
 				newFilterChains = append(newFilterChains, istionetworking.FilterChain{
 					ListenerProtocol: istionetworking.ListenerProtocolHTTP,
 				})
@@ -252,7 +252,7 @@ func (configgen *ConfigGeneratorImpl) buildGatewayHTTP3FilterChains(
 		// server. So the same route name would be reused instead of creating new one.
 		routeName := mergedGateway.TLSServerInfo[server].RouteName
 		quicFilterChainOpts = append(quicFilterChainOpts, configgen.createGatewayHTTPFilterChainOpts(builder.node, server.Port, server,
-			routeName, proxyConfig, istionetworking.TransportProtocolQUIC))
+			routeName, proxyConfig, istionetworking.TransportProtocolQUIC, builder.push))
 		newFilterChains = append(newFilterChains, istionetworking.FilterChain{
 			// Make sure that this is set to HTTP so that JWT and Authorization
 			// filters that are applied to HTTPS are also applied to this chain.
@@ -554,7 +554,8 @@ func routesEqual(a, b []*route.Route) bool {
 
 // builds a HTTP connection manager for servers of type HTTP or HTTPS (mode: simple/mutual)
 func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *model.Proxy, port *networking.Port, server *networking.Server,
-	routeName string, proxyConfig *meshconfig.ProxyConfig, transportProtocol istionetworking.TransportProtocol) *filterChainOpts {
+	routeName string, proxyConfig *meshconfig.ProxyConfig, transportProtocol istionetworking.TransportProtocol,
+	push *model.PushContext) *filterChainOpts {
 	serverProto := protocol.Parse(port.Protocol)
 
 	if serverProto.IsHTTP() {
@@ -567,7 +568,7 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 			httpOpts: &httpListenerOpts{
 				rds:               routeName,
 				useRemoteAddress:  true,
-				connectionManager: buildGatewayConnectionManager(proxyConfig, node, false /* http3SupportEnabled */),
+				connectionManager: buildGatewayConnectionManager(proxyConfig, node, false /* http3SupportEnabled */, push),
 				protocol:          serverProto,
 				class:             istionetworking.ListenerClassGateway,
 			},
@@ -587,7 +588,7 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 		httpOpts: &httpListenerOpts{
 			rds:               routeName,
 			useRemoteAddress:  true,
-			connectionManager: buildGatewayConnectionManager(proxyConfig, node, http3Enabled),
+			connectionManager: buildGatewayConnectionManager(proxyConfig, node, http3Enabled, push),
 			protocol:          serverProto,
 			statPrefix:        server.Name,
 			http3Only:         http3Enabled,
@@ -596,7 +597,8 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 	}
 }
 
-func buildGatewayConnectionManager(proxyConfig *meshconfig.ProxyConfig, node *model.Proxy, http3SupportEnabled bool) *hcm.HttpConnectionManager {
+func buildGatewayConnectionManager(proxyConfig *meshconfig.ProxyConfig, node *model.Proxy, http3SupportEnabled bool,
+	push *model.PushContext) *hcm.HttpConnectionManager {
 	httpProtoOpts := &core.Http1ProtocolOptions{}
 	if features.HTTP10 || enableHTTP10(node.Metadata.HTTP10) {
 		httpProtoOpts.AcceptHttp_10 = true
@@ -634,6 +636,18 @@ func buildGatewayConnectionManager(proxyConfig *meshconfig.ProxyConfig, node *mo
 		httpConnManager.Http3ProtocolOptions = &core.Http3ProtocolOptions{}
 		httpConnManager.CodecType = hcm.HttpConnectionManager_HTTP3
 	}
+	if features.EnableHCMInternalNetworks && push.Networks != nil {
+		for _, internalnetwork := range push.Networks.GetNetworks() {
+			iac := &hcm.HttpConnectionManager_InternalAddressConfig{}
+			for _, ne := range internalnetwork.Endpoints {
+				if cidr := util.ConvertAddressToCidr(ne.GetFromCidr()); cidr != nil {
+					iac.CidrRanges = append(iac.CidrRanges, cidr)
+				}
+			}
+			httpConnManager.InternalAddressConfig = iac
+		}
+	}
+
 	return httpConnManager
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway_test.go b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
index b511caa46e..c164afc1b0 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
@@ -28,6 +28,7 @@
 	"github.com/google/uuid"
 	"google.golang.org/protobuf/testing/protocmp"
 	"google.golang.org/protobuf/types/known/durationpb"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
@@ -1506,7 +1507,7 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 				tc.server: {SNIHosts: pilot_model.GetSNIHostsForServer(tc.server)},
 			}}
 			ret := cgi.createGatewayHTTPFilterChainOpts(tc.node, tc.server.Port, tc.server,
-				tc.routeName, tc.proxyConfig, tc.transportProtocol)
+				tc.routeName, tc.proxyConfig, tc.transportProtocol, nil)
 			if diff := cmp.Diff(tc.result.tlsContext, ret.tlsContext, protocmp.Transform()); diff != "" {
 				t.Errorf("got diff in tls context: %v", diff)
 			}
@@ -2511,3 +2512,71 @@ func TestBuildNameToServiceMapForHttpRoutes(t *testing.T) {
 		t.Errorf("The value of hostname %s mapping must be exist and it should be nil.", bazHostName)
 	}
 }
+
+func TestGatewayHCMInternalAddressConfig(t *testing.T) {
+	cg := NewConfigGenTest(t, TestOptions{})
+	proxy := &pilot_model.Proxy{
+		Type:            pilot_model.Router,
+		ConfigNamespace: "test",
+	}
+	proxy = cg.SetupProxy(proxy)
+	test.SetBoolForTest(t, &features.EnableHCMInternalNetworks, true)
+	push := cg.PushContext()
+	cases := []struct {
+		name           string
+		networks       *meshconfig.MeshNetworks
+		expectedconfig *hcm.HttpConnectionManager_InternalAddressConfig
+	}{
+		{
+			name:           "nil networks",
+			expectedconfig: nil,
+		},
+		{
+			name:           "empty networks",
+			networks:       &meshconfig.MeshNetworks{},
+			expectedconfig: nil,
+		},
+		{
+			name: "networks populated",
+			networks: &meshconfig.MeshNetworks{
+				Networks: map[string]*meshconfig.Network{
+					"default": {
+						Endpoints: []*meshconfig.Network_NetworkEndpoints{
+							{
+								Ne: &meshconfig.Network_NetworkEndpoints_FromCidr{
+									FromCidr: "192.168/16",
+								},
+							},
+							{
+								Ne: &meshconfig.Network_NetworkEndpoints_FromCidr{
+									FromCidr: "172.16/12",
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedconfig: &hcm.HttpConnectionManager_InternalAddressConfig{
+				CidrRanges: []*core.CidrRange{
+					{
+						AddressPrefix: "192.168",
+						PrefixLen:     &wrappers.UInt32Value{Value: 16},
+					},
+					{
+						AddressPrefix: "172.16",
+						PrefixLen:     &wrappers.UInt32Value{Value: 12},
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			push.Networks = tt.networks
+			httpConnManager := buildGatewayConnectionManager(&meshconfig.ProxyConfig{}, proxy, false, push)
+			if !reflect.DeepEqual(tt.expectedconfig, httpConnManager.InternalAddressConfig) {
+				t.Errorf("unexpected internal address config, expected: %v, got :%v", tt.expectedconfig, httpConnManager.InternalAddressConfig)
+			}
+		})
+	}
+}
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index fd87282011..9ec2386537 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -20,9 +20,7 @@
 	"sort"
 	"strconv"
 	"strings"
-	"time"
 
-	accesslog "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3"
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
@@ -30,21 +28,16 @@
 	envoyquicv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/quic/v3"
 	auth "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
-	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
-	extensions "istio.io/api/extensions/v1alpha1"
-	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
 	"istio.io/istio/pilot/pkg/networking/util"
 	authnmodel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
-	"istio.io/istio/pilot/pkg/xds/requestidextension"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
@@ -1107,122 +1100,6 @@ type buildListenerOpts struct {
 	transport         istionetworking.TransportProtocol
 }
 
-func (lb *ListenerBuilder) buildHTTPConnectionManager(httpOpts *httpListenerOpts) *hcm.HttpConnectionManager {
-	if httpOpts.connectionManager == nil {
-		httpOpts.connectionManager = &hcm.HttpConnectionManager{}
-	}
-
-	connectionManager := httpOpts.connectionManager
-	if httpOpts.http3Only {
-		connectionManager.CodecType = hcm.HttpConnectionManager_HTTP3
-		connectionManager.Http3ProtocolOptions = &core.Http3ProtocolOptions{}
-	} else {
-		connectionManager.CodecType = hcm.HttpConnectionManager_AUTO
-	}
-	connectionManager.AccessLog = []*accesslog.AccessLog{}
-	connectionManager.StatPrefix = httpOpts.statPrefix
-
-	// Setup normalization
-	connectionManager.PathWithEscapedSlashesAction = hcm.HttpConnectionManager_KEEP_UNCHANGED
-	switch lb.push.Mesh.GetPathNormalization().GetNormalization() {
-	case meshconfig.MeshConfig_ProxyPathNormalization_NONE:
-		connectionManager.NormalizePath = proto.BoolFalse
-	case meshconfig.MeshConfig_ProxyPathNormalization_BASE, meshconfig.MeshConfig_ProxyPathNormalization_DEFAULT:
-		connectionManager.NormalizePath = proto.BoolTrue
-	case meshconfig.MeshConfig_ProxyPathNormalization_MERGE_SLASHES:
-		connectionManager.NormalizePath = proto.BoolTrue
-		connectionManager.MergeSlashes = true
-	case meshconfig.MeshConfig_ProxyPathNormalization_DECODE_AND_MERGE_SLASHES:
-		connectionManager.NormalizePath = proto.BoolTrue
-		connectionManager.MergeSlashes = true
-		connectionManager.PathWithEscapedSlashesAction = hcm.HttpConnectionManager_UNESCAPE_AND_FORWARD
-	}
-
-	if httpOpts.useRemoteAddress {
-		connectionManager.UseRemoteAddress = proto.BoolTrue
-	} else {
-		connectionManager.UseRemoteAddress = proto.BoolFalse
-	}
-
-	// Allow websocket upgrades
-	websocketUpgrade := &hcm.HttpConnectionManager_UpgradeConfig{UpgradeType: "websocket"}
-	connectionManager.UpgradeConfigs = []*hcm.HttpConnectionManager_UpgradeConfig{websocketUpgrade}
-
-	idleTimeout, err := time.ParseDuration(lb.node.Metadata.IdleTimeout)
-	if err == nil {
-		connectionManager.CommonHttpProtocolOptions = &core.HttpProtocolOptions{
-			IdleTimeout: durationpb.New(idleTimeout),
-		}
-	}
-
-	notimeout := durationpb.New(0 * time.Second)
-	connectionManager.StreamIdleTimeout = notimeout
-
-	if httpOpts.rds != "" {
-		rds := &hcm.HttpConnectionManager_Rds{
-			Rds: &hcm.Rds{
-				ConfigSource: &core.ConfigSource{
-					ConfigSourceSpecifier: &core.ConfigSource_Ads{
-						Ads: &core.AggregatedConfigSource{},
-					},
-					InitialFetchTimeout: durationpb.New(0),
-					ResourceApiVersion:  core.ApiVersion_V3,
-				},
-				RouteConfigName: httpOpts.rds,
-			},
-		}
-		connectionManager.RouteSpecifier = rds
-	} else {
-		connectionManager.RouteSpecifier = &hcm.HttpConnectionManager_RouteConfig{RouteConfig: httpOpts.routeConfig}
-	}
-
-	accessLogBuilder.setHTTPAccessLog(lb.push, lb.node, connectionManager, httpOpts.class)
-
-	routerFilterCtx, reqIDExtensionCtx := configureTracing(lb.push, lb.node, connectionManager, httpOpts.class)
-
-	filters := []*hcm.HttpFilter{}
-	wasm := lb.push.WasmPlugins(lb.node)
-	// TODO: how to deal with ext-authz? It will be in the ordering twice
-	filters = append(filters, lb.authzCustomBuilder.BuildHTTP(httpOpts.class)...)
-	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHN)
-	filters = append(filters, lb.authnBuilder.BuildHTTP(httpOpts.class)...)
-	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHZ)
-	filters = append(filters, lb.authzBuilder.BuildHTTP(httpOpts.class)...)
-
-	// TODO: these feel like the wrong place to insert, but this retains backwards compatibility with the original implementation
-	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_STATS)
-	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_UNSPECIFIED_PHASE)
-
-	if features.MetadataExchange {
-		filters = append(filters, xdsfilters.HTTPMx)
-	}
-
-	if httpOpts.protocol == protocol.GRPCWeb {
-		filters = append(filters, xdsfilters.GrpcWeb)
-	}
-
-	if httpOpts.protocol.IsGRPC() {
-		filters = append(filters, xdsfilters.GrpcStats)
-	}
-
-	// append ALPN HTTP filter in HTTP connection manager for outbound listener only.
-	if features.ALPNFilter {
-		if httpOpts.class != istionetworking.ListenerClassSidecarInbound {
-			filters = append(filters, xdsfilters.Alpn)
-		}
-	}
-
-	// TypedPerFilterConfig in route needs these filters.
-	filters = append(filters, xdsfilters.Fault, xdsfilters.Cors)
-	filters = append(filters, lb.push.Telemetry.HTTPFilters(lb.node, httpOpts.class)...)
-	filters = append(filters, xdsfilters.BuildRouterFilter(routerFilterCtx))
-
-	connectionManager.HttpFilters = filters
-	connectionManager.RequestIdExtension = requestidextension.BuildUUIDRequestIDExtension(reqIDExtensionCtx)
-
-	return connectionManager
-}
-
 // buildListener builds and initializes a Listener proto based on the provided opts. It does not set any filters.
 // Optionally for HTTP filters with TLS enabled, HTTP/3 can be supported by generating QUIC Mirror filters for the
 // same port (it is fine as QUIC uses UDP)
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 09f07232dc..d8b25169ae 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -17,21 +17,30 @@
 import (
 	"time"
 
+	accesslog "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3"
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	tcp "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/tcp_proxy/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
+	extensions "istio.io/api/extensions/v1alpha1"
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/envoyfilter"
+	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
 	"istio.io/istio/pilot/pkg/networking/plugin/authn"
 	"istio.io/istio/pilot/pkg/networking/plugin/authz"
 	"istio.io/istio/pilot/pkg/networking/util"
+	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
+	"istio.io/istio/pilot/pkg/xds/requestidextension"
+	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/proto"
 	"istio.io/pkg/log"
 )
@@ -269,3 +278,130 @@ func blackholeFilterChain(push *model.PushContext, node *model.Proxy) *listener.
 		),
 	}
 }
+
+func (lb *ListenerBuilder) buildHTTPConnectionManager(httpOpts *httpListenerOpts) *hcm.HttpConnectionManager {
+	if httpOpts.connectionManager == nil {
+		httpOpts.connectionManager = &hcm.HttpConnectionManager{}
+	}
+
+	connectionManager := httpOpts.connectionManager
+	if httpOpts.http3Only {
+		connectionManager.CodecType = hcm.HttpConnectionManager_HTTP3
+		connectionManager.Http3ProtocolOptions = &core.Http3ProtocolOptions{}
+	} else {
+		connectionManager.CodecType = hcm.HttpConnectionManager_AUTO
+	}
+	connectionManager.AccessLog = []*accesslog.AccessLog{}
+	connectionManager.StatPrefix = httpOpts.statPrefix
+
+	// Setup normalization
+	connectionManager.PathWithEscapedSlashesAction = hcm.HttpConnectionManager_KEEP_UNCHANGED
+	switch lb.push.Mesh.GetPathNormalization().GetNormalization() {
+	case meshconfig.MeshConfig_ProxyPathNormalization_NONE:
+		connectionManager.NormalizePath = proto.BoolFalse
+	case meshconfig.MeshConfig_ProxyPathNormalization_BASE, meshconfig.MeshConfig_ProxyPathNormalization_DEFAULT:
+		connectionManager.NormalizePath = proto.BoolTrue
+	case meshconfig.MeshConfig_ProxyPathNormalization_MERGE_SLASHES:
+		connectionManager.NormalizePath = proto.BoolTrue
+		connectionManager.MergeSlashes = true
+	case meshconfig.MeshConfig_ProxyPathNormalization_DECODE_AND_MERGE_SLASHES:
+		connectionManager.NormalizePath = proto.BoolTrue
+		connectionManager.MergeSlashes = true
+		connectionManager.PathWithEscapedSlashesAction = hcm.HttpConnectionManager_UNESCAPE_AND_FORWARD
+	}
+
+	if httpOpts.useRemoteAddress {
+		connectionManager.UseRemoteAddress = proto.BoolTrue
+	} else {
+		connectionManager.UseRemoteAddress = proto.BoolFalse
+	}
+
+	// Allow websocket upgrades
+	websocketUpgrade := &hcm.HttpConnectionManager_UpgradeConfig{UpgradeType: "websocket"}
+	connectionManager.UpgradeConfigs = []*hcm.HttpConnectionManager_UpgradeConfig{websocketUpgrade}
+
+	idleTimeout, err := time.ParseDuration(lb.node.Metadata.IdleTimeout)
+	if err == nil {
+		connectionManager.CommonHttpProtocolOptions = &core.HttpProtocolOptions{
+			IdleTimeout: durationpb.New(idleTimeout),
+		}
+	}
+
+	notimeout := durationpb.New(0 * time.Second)
+	connectionManager.StreamIdleTimeout = notimeout
+
+	if httpOpts.rds != "" {
+		rds := &hcm.HttpConnectionManager_Rds{
+			Rds: &hcm.Rds{
+				ConfigSource: &core.ConfigSource{
+					ConfigSourceSpecifier: &core.ConfigSource_Ads{
+						Ads: &core.AggregatedConfigSource{},
+					},
+					InitialFetchTimeout: durationpb.New(0),
+					ResourceApiVersion:  core.ApiVersion_V3,
+				},
+				RouteConfigName: httpOpts.rds,
+			},
+		}
+		connectionManager.RouteSpecifier = rds
+	} else {
+		connectionManager.RouteSpecifier = &hcm.HttpConnectionManager_RouteConfig{RouteConfig: httpOpts.routeConfig}
+	}
+
+	accessLogBuilder.setHTTPAccessLog(lb.push, lb.node, connectionManager, httpOpts.class)
+
+	routerFilterCtx, reqIDExtensionCtx := configureTracing(lb.push, lb.node, connectionManager, httpOpts.class)
+
+	filters := []*hcm.HttpFilter{}
+	wasm := lb.push.WasmPlugins(lb.node)
+	// TODO: how to deal with ext-authz? It will be in the ordering twice
+	filters = append(filters, lb.authzCustomBuilder.BuildHTTP(httpOpts.class)...)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHN)
+	filters = append(filters, lb.authnBuilder.BuildHTTP(httpOpts.class)...)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHZ)
+	filters = append(filters, lb.authzBuilder.BuildHTTP(httpOpts.class)...)
+
+	// TODO: these feel like the wrong place to insert, but this retains backwards compatibility with the original implementation
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_STATS)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_UNSPECIFIED_PHASE)
+
+	if features.MetadataExchange {
+		filters = append(filters, xdsfilters.HTTPMx)
+	}
+
+	if httpOpts.protocol == protocol.GRPCWeb {
+		filters = append(filters, xdsfilters.GrpcWeb)
+	}
+
+	if httpOpts.protocol.IsGRPC() {
+		filters = append(filters, xdsfilters.GrpcStats)
+	}
+
+	// append ALPN HTTP filter in HTTP connection manager for outbound listener only.
+	if features.ALPNFilter {
+		if httpOpts.class != istionetworking.ListenerClassSidecarInbound {
+			filters = append(filters, xdsfilters.Alpn)
+		}
+	}
+
+	// TypedPerFilterConfig in route needs these filters.
+	filters = append(filters, xdsfilters.Fault, xdsfilters.Cors)
+	filters = append(filters, lb.push.Telemetry.HTTPFilters(lb.node, httpOpts.class)...)
+	filters = append(filters, xdsfilters.BuildRouterFilter(routerFilterCtx))
+
+	connectionManager.HttpFilters = filters
+	connectionManager.RequestIdExtension = requestidextension.BuildUUIDRequestIDExtension(reqIDExtensionCtx)
+
+	if features.EnableHCMInternalNetworks && lb.push.Networks != nil {
+		for _, internalnetwork := range lb.push.Networks.Networks {
+			iac := &hcm.HttpConnectionManager_InternalAddressConfig{}
+			for _, ne := range internalnetwork.Endpoints {
+				if cidr := util.ConvertAddressToCidr(ne.GetFromCidr()); cidr != nil {
+					iac.CidrRanges = append(iac.CidrRanges, cidr)
+				}
+			}
+			connectionManager.InternalAddressConfig = iac
+		}
+	}
+	return connectionManager
+}
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
index ce94d48d15..d10af467b7 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
@@ -22,14 +22,18 @@
 
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"github.com/golang/protobuf/jsonpb"
+	wrappers "github.com/golang/protobuf/ptypes/wrappers"
 	"google.golang.org/protobuf/types/known/structpb"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/plugin/authz"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/test/xdstest"
 	"istio.io/istio/pkg/config"
@@ -808,3 +812,73 @@ func mtlsMode(m string) string {
     mode: %s
 `, m)
 }
+
+func TestHCMInternalAddressConfig(t *testing.T) {
+	cg := NewConfigGenTest(t, TestOptions{})
+	sidecarProxy := cg.SetupProxy(&model.Proxy{ConfigNamespace: "not-default"})
+	test.SetBoolForTest(t, &features.EnableHCMInternalNetworks, true)
+	push := cg.PushContext()
+	cases := []struct {
+		name           string
+		networks       *meshconfig.MeshNetworks
+		expectedconfig *hcm.HttpConnectionManager_InternalAddressConfig
+	}{
+		{
+			name:           "nil networks",
+			expectedconfig: nil,
+		},
+		{
+			name:           "empty networks",
+			networks:       &meshconfig.MeshNetworks{},
+			expectedconfig: nil,
+		},
+		{
+			name: "networks populated",
+			networks: &meshconfig.MeshNetworks{
+				Networks: map[string]*meshconfig.Network{
+					"default": {
+						Endpoints: []*meshconfig.Network_NetworkEndpoints{
+							{
+								Ne: &meshconfig.Network_NetworkEndpoints_FromCidr{
+									FromCidr: "192.168/16",
+								},
+							},
+							{
+								Ne: &meshconfig.Network_NetworkEndpoints_FromCidr{
+									FromCidr: "172.16/12",
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedconfig: &hcm.HttpConnectionManager_InternalAddressConfig{
+				CidrRanges: []*core.CidrRange{
+					{
+						AddressPrefix: "192.168",
+						PrefixLen:     &wrappers.UInt32Value{Value: 16},
+					},
+					{
+						AddressPrefix: "172.16",
+						PrefixLen:     &wrappers.UInt32Value{Value: 12},
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			push.Networks = tt.networks
+			lb := &ListenerBuilder{
+				push:               push,
+				node:               sidecarProxy,
+				authzCustomBuilder: &authz.Builder{},
+				authzBuilder:       &authz.Builder{},
+			}
+			httpConnManager := lb.buildHTTPConnectionManager(&httpListenerOpts{})
+			if !reflect.DeepEqual(tt.expectedconfig, httpConnManager.InternalAddressConfig) {
+				t.Errorf("unexpected internal address config, expected: %v, got :%v", tt.expectedconfig, httpConnManager.InternalAddressConfig)
+			}
+		})
+	}
+}
diff --git a/pkg/config/mesh/networks_watcher.go b/pkg/config/mesh/networks_watcher.go
index 2140a3487a..59c5de164b 100644
--- a/pkg/config/mesh/networks_watcher.go
+++ b/pkg/config/mesh/networks_watcher.go
@@ -29,6 +29,7 @@
 type NetworksHolder interface {
 	SetNetworks(*meshconfig.MeshNetworks)
 	Networks() *meshconfig.MeshNetworks
+	PrevNetworks() *meshconfig.MeshNetworks
 }
 
 // NetworksWatcher watches changes to the mesh networks config.
@@ -41,9 +42,10 @@ type NetworksWatcher interface {
 var _ NetworksWatcher = &internalNetworkWatcher{}
 
 type internalNetworkWatcher struct {
-	mutex    sync.RWMutex
-	handlers []func()
-	networks *meshconfig.MeshNetworks
+	mutex        sync.RWMutex
+	handlers     []func()
+	networks     *meshconfig.MeshNetworks
+	prevNetworks *meshconfig.MeshNetworks
 }
 
 // NewFixedNetworksWatcher creates a new NetworksWatcher that always returns the given config.
@@ -91,6 +93,16 @@ func (w *internalNetworkWatcher) Networks() *meshconfig.MeshNetworks {
 	return w.networks
 }
 
+// PrevNetworks returns the previous network configuration for the mesh.
+func (w *internalNetworkWatcher) PrevNetworks() *meshconfig.MeshNetworks {
+	if w == nil {
+		return nil
+	}
+	w.mutex.RLock()
+	defer w.mutex.RUnlock()
+	return w.prevNetworks
+}
+
 // SetNetworks will use the given value for mesh networks and notify all handlers of the change
 func (w *internalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetworks) {
 	var handlers []func()
@@ -101,6 +113,7 @@ func (w *internalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetwor
 		log.Infof("mesh networks configuration updated to: %s", networksdump)
 
 		// Store the new config.
+		w.prevNetworks = w.networks
 		w.networks = meshNetworks
 		handlers = append([]func(){}, w.handlers...)
 	}
diff --git a/releasenotes/notes/38801.yaml b/releasenotes/notes/38801.yaml
new file mode 100644
index 0000000000..d4ff8069c0
--- /dev/null
+++ b/releasenotes/notes/38801.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: traffic-management
+releaseNotes:
+  - |
+    **Added** support for configuring internal addresses of mesh. This can be enabled by setting
+    "ENABLE_HCM_INTERNAL_NETWORKS" to true.
\ No newline at end of file
-- 
2.35.3

