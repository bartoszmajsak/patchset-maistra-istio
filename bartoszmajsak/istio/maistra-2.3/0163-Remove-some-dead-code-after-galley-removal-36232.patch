From d4d0dcac9e8db54bf6c045fbb3f0df70191c440e Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Mon, 29 Nov 2021 12:11:22 -0800
Subject: Remove some dead code after galley removal (#36232)

* Remove some dead code after galley removal

* fix

* go mod tidy
---
 go.mod                                       |   2 +-
 pilot/pkg/xds/monitoring.go                  |   2 +-
 pkg/mcp/README.md                            |   5 -
 pkg/mcp/internal/internal.go                 |  52 ---
 pkg/mcp/internal/internal_test.go            | 151 --------
 pkg/mcp/internal/queue.go                    | 232 ------------
 pkg/mcp/internal/queue_test.go               | 354 -------------------
 pkg/mcp/internal/size.go                     |  25 --
 pkg/mcp/internal/test/auth_checker.go        |  38 --
 pkg/mcp/internal/test/types.go               | 201 -----------
 pkg/mcp/sink/sink.go                         |  28 --
 pkg/mcp/snapshot/inmemory.go                 | 215 -----------
 pkg/mcp/snapshot/inmemory_test.go            | 341 ------------------
 pkg/mcp/snapshot/snapshot.go                 | 317 -----------------
 pkg/mcp/snapshot/snapshot_test.go            | 329 -----------------
 pkg/mcp/source/source.go                     |  67 ----
 pkg/mcp/status/status.go                     | 221 ------------
 pkg/mcp/testing/groups/groups.go             |  27 --
 security/pkg/nodeagent/test/mock/caserver.go |   2 +-
 19 files changed, 3 insertions(+), 2606 deletions(-)
 delete mode 100644 pkg/mcp/README.md
 delete mode 100644 pkg/mcp/internal/internal.go
 delete mode 100644 pkg/mcp/internal/internal_test.go
 delete mode 100644 pkg/mcp/internal/queue.go
 delete mode 100644 pkg/mcp/internal/queue_test.go
 delete mode 100644 pkg/mcp/internal/size.go
 delete mode 100644 pkg/mcp/internal/test/auth_checker.go
 delete mode 100644 pkg/mcp/internal/test/types.go
 delete mode 100644 pkg/mcp/sink/sink.go
 delete mode 100644 pkg/mcp/snapshot/inmemory.go
 delete mode 100644 pkg/mcp/snapshot/inmemory_test.go
 delete mode 100644 pkg/mcp/snapshot/snapshot.go
 delete mode 100644 pkg/mcp/snapshot/snapshot_test.go
 delete mode 100644 pkg/mcp/source/source.go
 delete mode 100644 pkg/mcp/status/status.go
 delete mode 100644 pkg/mcp/testing/groups/groups.go

diff --git a/go.mod b/go.mod
index 5de80a0417..e2ac0b981e 100644
--- a/go.mod
+++ b/go.mod
@@ -89,7 +89,6 @@ require (
 	helm.sh/helm/v3 v3.7.1
 	istio.io/api v0.0.0-20211124143550-67f86871f2a5
 	istio.io/client-go v1.12.0-alpha.5.0.20211124144007-2c98ed70c967
-	istio.io/gogo-genproto v0.0.0-20211111171331-7926fce33bb3
 	istio.io/pkg v0.0.0-20211123161558-1e5d0c4ee827
 	k8s.io/api v0.22.2
 	k8s.io/apiextensions-apiserver v0.22.2
@@ -241,6 +240,7 @@ require (
 	google.golang.org/appengine v1.6.7 // indirect
 	gopkg.in/inf.v0 v0.9.1 // indirect
 	gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 // indirect
+	istio.io/gogo-genproto v0.0.0-20211111171331-7926fce33bb3 // indirect
 	k8s.io/component-base v0.22.2 // indirect
 	sigs.k8s.io/kustomize/api v0.8.11 // indirect
 	sigs.k8s.io/kustomize/kyaml v0.11.0 // indirect
diff --git a/pilot/pkg/xds/monitoring.go b/pilot/pkg/xds/monitoring.go
index 409a2d79e7..da0760c24e 100644
--- a/pilot/pkg/xds/monitoring.go
+++ b/pilot/pkg/xds/monitoring.go
@@ -18,10 +18,10 @@
 	"time"
 
 	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
 
 	"istio.io/istio/pilot/pkg/model"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
-	"istio.io/istio/pkg/mcp/status"
 	"istio.io/pkg/monitoring"
 )
 
diff --git a/pkg/mcp/README.md b/pkg/mcp/README.md
deleted file mode 100644
index e7053d68ee..0000000000
--- a/pkg/mcp/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# Mesh Configuration Protocol (MCP)
-
-## Introduction
-
-MCP is a subscription-based configuration distribution API. Checkout more details about MCP on [istio/api](https://github.com/istio/api/tree/master/mcp#overview).
diff --git a/pkg/mcp/internal/internal.go b/pkg/mcp/internal/internal.go
deleted file mode 100644
index df0c29cf59..0000000000
--- a/pkg/mcp/internal/internal.go
+++ /dev/null
@@ -1,52 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package internal
-
-import (
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/pkg/log"
-)
-
-var scope = log.RegisterScope("mcp", "mcp debugging", 0)
-
-// UpdateResourceVersionTracking updates a map of resource versions indexed
-// by name based on the MCP resources response message.
-func UpdateResourceVersionTracking(versions map[string]string, resources *mcp.Resources) {
-	if resources.Incremental {
-		for _, e := range resources.Resources {
-			name, version := e.Metadata.Name, e.Metadata.Version
-			if prev, ok := versions[e.Metadata.Name]; ok {
-				scope.Debugf("MCP: ACK UPDATE collection=%v name=%q version=%q (prev=%v_)",
-					resources.Collection, name, version, prev)
-			} else {
-				scope.Debugf("MCP: ACK ADD collection=%v name=%q version=%q)",
-					resources.Collection, name, version)
-			}
-			versions[name] = version
-		}
-		for _, name := range resources.RemovedResources {
-			scope.Debugf("MCP: ACK REMOVE name=%q)", name)
-			delete(versions, name)
-		}
-	} else {
-		for name := range versions {
-			delete(versions, name)
-		}
-		for _, e := range resources.Resources {
-			name, version := e.Metadata.Name, e.Metadata.Version
-			versions[name] = version
-		}
-	}
-}
diff --git a/pkg/mcp/internal/internal_test.go b/pkg/mcp/internal/internal_test.go
deleted file mode 100644
index 6a4a452b8d..0000000000
--- a/pkg/mcp/internal/internal_test.go
+++ /dev/null
@@ -1,151 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package internal
-
-import (
-	"fmt"
-	"testing"
-
-	"github.com/google/go-cmp/cmp"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/pkg/mcp/internal/test"
-)
-
-func TestUpdateResourceVersionTracking(t *testing.T) {
-	var (
-		r0 = test.Type0A[0].Resource
-		r1 = test.Type0B[0].Resource
-		r2 = test.Type0C[0].Resource
-
-		r0Updated = test.Type0A[1].Resource
-		r1Updated = test.Type0B[1].Resource
-		r2Updated = test.Type0C[1].Resource
-	)
-
-	cases := []struct {
-		name      string
-		current   map[string]string
-		want      map[string]string
-		resources *mcp.Resources
-	}{
-		{
-			name:    "add initial state",
-			current: map[string]string{},
-			want: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			resources: &mcp.Resources{Resources: []mcp.Resource{*r0, *r1, *r2}},
-		},
-		{
-			name: "remove everything",
-			current: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			want:      map[string]string{},
-			resources: &mcp.Resources{Resources: []mcp.Resource{}},
-		},
-		{
-			name: "replace everything",
-			current: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			want: map[string]string{
-				r0Updated.Metadata.Name: r0Updated.Metadata.Version,
-				r1Updated.Metadata.Name: r1Updated.Metadata.Version,
-				r2Updated.Metadata.Name: r2Updated.Metadata.Version,
-			},
-			resources: &mcp.Resources{Resources: []mcp.Resource{*r0Updated, *r1Updated, *r2Updated}},
-		},
-		{
-			name:    "add incrementally",
-			current: map[string]string{},
-			want: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			resources: &mcp.Resources{
-				Incremental: true,
-				Resources:   []mcp.Resource{*r0, *r1, *r2},
-			},
-		},
-		{
-			name: "update incrementally",
-			current: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			want: map[string]string{
-				r0Updated.Metadata.Name: r0Updated.Metadata.Version,
-				r1.Metadata.Name:        r1.Metadata.Version,
-				r2.Metadata.Name:        r2.Metadata.Version,
-			},
-			resources: &mcp.Resources{
-				Incremental: true,
-				Resources:   []mcp.Resource{*r0Updated},
-			},
-		},
-		{
-			name: "delete incrementally",
-			current: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			want: map[string]string{
-				r1.Metadata.Name: r1.Metadata.Version,
-				r2.Metadata.Name: r2.Metadata.Version,
-			},
-			resources: &mcp.Resources{
-				Incremental:      true,
-				Resources:        []mcp.Resource{},
-				RemovedResources: []string{r0Updated.Metadata.Name},
-			},
-		},
-		{
-			name: "add, update, and delete incrementally",
-			current: map[string]string{
-				r0.Metadata.Name: r0.Metadata.Version,
-				r1.Metadata.Name: r1.Metadata.Version,
-			},
-			want: map[string]string{
-				r1Updated.Metadata.Name: r1Updated.Metadata.Version,
-				r2.Metadata.Name:        r2.Metadata.Version,
-			},
-			resources: &mcp.Resources{
-				Incremental:      true,
-				Resources:        []mcp.Resource{*r1Updated, *r2},
-				RemovedResources: []string{r0Updated.Metadata.Name},
-			},
-		},
-	}
-	for i, c := range cases {
-		t.Run(fmt.Sprintf("[%v] %v", i, c.name), func(tt *testing.T) {
-			UpdateResourceVersionTracking(c.current, c.resources)
-			got := c.current // map is modified in place
-			if diff := cmp.Diff(got, c.want); diff != "" {
-				tt.Fatalf("wrong versions: \n got %v \nwant %v\ndiff %v", got, c.want, diff)
-			}
-		})
-	}
-}
diff --git a/pkg/mcp/internal/queue.go b/pkg/mcp/internal/queue.go
deleted file mode 100644
index b3e1d6eeb0..0000000000
--- a/pkg/mcp/internal/queue.go
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package internal
-
-import (
-	"encoding/json"
-	"sync"
-)
-
-// TODO - this can eventually be moved under pkg/mcp/source once the new stack is
-// introduced. The code is temporarily added under pkg/mcp/internal so
-// we can share across package boundaries without exposing outside of the pkg/mcp
-// parent directory.
-
-// UniqueQueue is a specialized queue structure. It has the following properties:
-//
-// - Enqueuing an item already in the queue is idempotent. The first time an item
-//   is added to the queue determines its order in the queue until it is dequeued.
-//   Callers can safely update the queued items state while preserving it's place
-//   in the queue.
-//
-// - Enqueuing an item in the queue creates a trySchedule event. The caller can select
-//   over the Ready() channel to process this event and remove items from the queue.
-//
-// - The maximum queue depth is fixed.
-//
-// - The queue can be safely closed. The caller is responsible for checking the Done()
-//   state of the queue and should stop checking Ready() and invoking Dequeue() when
-//   the channel returned by Done() is closed.
-//
-// This is intended to be used by the MCP source/server packages for managing
-// per-type watch state.
-type UniqueQueue struct {
-	mu             sync.Mutex
-	doneChan       chan struct{}
-	doneChanClosed bool
-	// Enqueue at the tail, Dequeue from the head.
-	// head == tail   -> empty
-	// head == tail+1 -> full
-	head int
-	tail int
-	// Maintain an ordered set of enqueued items.
-	queue     []entry
-	queuedSet map[string]*entry
-	maxDepth  int
-
-	readyChan chan struct{}
-}
-
-type entry struct {
-	key string
-	val interface{}
-}
-
-// NewUniqueScheduledQueue creates a new unique queue specialized for MCP source/server implementations.
-func NewUniqueScheduledQueue(maxDepth int) *UniqueQueue {
-	return &UniqueQueue{
-		// Max queue size is one larger than the max depth so that
-		// we can differentiate empty vs. full conditions.
-		//
-		// 	head == tail   -> empty
-		// 	head == tail+1 -> full
-		queue: make([]entry, maxDepth+1),
-
-		queuedSet: make(map[string]*entry, maxDepth),
-		maxDepth:  maxDepth,
-		readyChan: make(chan struct{}, maxDepth),
-		doneChan:  make(chan struct{}),
-	}
-}
-
-// return the next index accounting for wrap
-func (q *UniqueQueue) inc(idx int) int {
-	return (idx + 1) % (q.maxDepth + 1)
-}
-
-// Empty returns true if the queue is empty
-func (q *UniqueQueue) Empty() bool {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-
-	// 	head == tail -> empty
-	return q.head == q.tail
-}
-
-// internal version of full() that can be called
-// with the lock held.
-func (q *UniqueQueue) full() bool {
-	// 	head == tail+1 -> full
-	return q.head == q.inc(q.tail)
-}
-
-// Full returns true if the queue is full
-func (q *UniqueQueue) Full() bool {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-	return q.full()
-}
-
-// Enqueue an item in the queue. Items with the same key may be safely enqueued multiple
-// times. Enqueueing an item with a key that has already queued has no affect on the order
-// of existing queued items.
-//
-// Returns true if the item exists in the queue upon return. Otherwise,
-// returns false if the item could not be queued.
-func (q *UniqueQueue) Enqueue(key string, val interface{}) bool {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-
-	if q.doneChanClosed {
-		return false
-	}
-
-	// Key is already in the queue. Update the set's entry and
-	// return without modifying its place in the queue.
-	if entry, ok := q.queuedSet[key]; ok {
-		entry.val = val
-		return true
-	}
-
-	if q.full() {
-		return false
-	}
-
-	q.queue[q.tail] = entry{
-		key: key,
-		val: val,
-	}
-	q.queuedSet[key] = &q.queue[q.tail]
-	q.tail = q.inc(q.tail)
-
-	q.trySchedule()
-
-	return true
-}
-
-// must be called with lock held
-func (q *UniqueQueue) trySchedule() {
-	select {
-	case q.readyChan <- struct{}{}:
-	default:
-		scope.Warnf("queue could not be scheduled (head=%v tail=%v depth=%v)",
-			q.head, q.tail, q.maxDepth)
-	}
-}
-
-// Dequeue removes an item from the queue. This should only be called once for each
-// time Ready() indicates a new item is ready to be dequeued.
-func (q *UniqueQueue) Dequeue() (string, interface{}, bool) {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-
-	if q.head == q.tail {
-		return "", nil, false
-	}
-
-	entry := q.queue[q.head]
-	q.head = q.inc(q.head)
-	delete(q.queuedSet, entry.key)
-	return entry.key, entry.val, true
-}
-
-func (q *UniqueQueue) Ready() <-chan struct{} {
-	return q.readyChan
-}
-
-func (q *UniqueQueue) Done() <-chan struct{} {
-	return q.doneChan
-}
-
-func (q *UniqueQueue) Close() {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-
-	if !q.doneChanClosed {
-		q.doneChanClosed = true
-		close(q.doneChan)
-	}
-}
-
-type dump struct {
-	Closed    bool                   `json:"closed"`
-	QueuedSet map[string]interface{} `json:"queued_set"`
-	Queue     []string               `json:"queue"`
-	Head      int                    `json:"head"`
-	Tail      int                    `json:"tail"`
-	MaxDepth  int                    `json:"max_depth"`
-}
-
-// hook for unit tests
-var jsonMarshalDumpHook = json.Marshal
-
-// Dump returns a JSON formatted dump of the internal queue state. This is intended
-// for debug purposes only.
-func (q *UniqueQueue) Dump() string {
-	q.mu.Lock()
-	defer q.mu.Unlock()
-
-	d := &dump{
-		Closed:    q.doneChanClosed,
-		Head:      q.head,
-		Tail:      q.tail,
-		MaxDepth:  q.maxDepth,
-		Queue:     make([]string, 0, len(q.queue)),
-		QueuedSet: make(map[string]interface{}, len(q.queuedSet)),
-	}
-
-	for _, entry := range q.queue {
-		d.Queue = append(d.Queue, entry.key)
-	}
-	for _, entry := range q.queuedSet {
-		d.QueuedSet[entry.key] = entry.val
-	}
-
-	out, err := jsonMarshalDumpHook(d)
-	if err != nil {
-		return ""
-	}
-	return string(out)
-}
diff --git a/pkg/mcp/internal/queue_test.go b/pkg/mcp/internal/queue_test.go
deleted file mode 100644
index a619e79e71..0000000000
--- a/pkg/mcp/internal/queue_test.go
+++ /dev/null
@@ -1,354 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package internal
-
-import (
-	"encoding/json"
-	"errors"
-	"regexp"
-	"testing"
-	"time"
-
-	"github.com/google/go-cmp/cmp"
-)
-
-var items = []struct {
-	key string
-	val int
-}{
-	{"collection/1", 1},
-	{"collection/2", 2},
-	{"collection/3", 3},
-	{"collection/4", 4},
-	{"collection/5", 5},
-	{"collection/6", 6},
-}
-
-func TestUniqueQueue_InitialState(t *testing.T) {
-	depth := 5
-	q := NewUniqueScheduledQueue(depth)
-
-	if !q.Empty() {
-		t.Fatal("initial queue should be empty")
-	}
-
-	if q.Full() {
-		t.Fatal("initial queue shouldn't be full")
-	}
-
-	k, v, ok := q.Dequeue()
-	if ok {
-		t.Fatalf("Dequeue() should not return an entry: got key=%q value=%v", k, v)
-	}
-}
-
-func TestUniqueQueue_EnqueueDequeue(t *testing.T) {
-	depth := int(5)
-	q := NewUniqueScheduledQueue(depth)
-
-	for i := 0; i < depth; i++ {
-		q.Enqueue(items[i].key, items[i].val)
-	}
-
-	if !q.Full() {
-		t.Fatalf("queue should be full")
-	}
-
-	// enqueue some duplicates
-	for i := depth - 1; i >= 0; i-- {
-		if q.Enqueue(items[i].key, items[i].val*2) != true {
-			t.Fatalf("could not enqueue dup #%v", i)
-		}
-	}
-
-	if !q.Full() {
-		t.Fatalf("queue should be full")
-	}
-
-	if q.Enqueue(items[5].key, items[5].val) == true {
-		t.Fatal("enqueueing new item into full queue should fail")
-	}
-
-	for i := 0; i < depth; i++ {
-		<-q.Ready()
-
-		want := items[i].val * 2
-		key, v, _ := q.Dequeue()
-		got := v.(int)
-		if got != want {
-			t.Fatalf("wrong Dequeue() value: got %v want %v", got, want)
-		}
-		q.Enqueue(key, got*2)
-	}
-
-	for i := 0; i < depth; i++ {
-		want := items[i].val * 4
-		_, v, _ := q.Dequeue()
-		got := v.(int)
-		if got != want {
-			t.Fatalf("wrong Dequeue() value: got %v want %v", got, want)
-		}
-	}
-}
-
-func getScheduledItem(t *testing.T, q *UniqueQueue) interface{} {
-	t.Helper()
-
-	select {
-	case <-q.Done():
-		t.Fatal("unexpected done indication")
-	case <-q.Ready():
-		_, v, ok := q.Dequeue()
-		if !ok {
-			t.Fatal("Dequeue() returned no entries")
-		}
-		return v
-	case <-time.After(time.Second):
-		t.Fatal("timeout waiting for scheduled response")
-	}
-	return nil
-}
-
-func TestUniqueQueue_Schedule(t *testing.T) {
-	q := NewUniqueScheduledQueue(5)
-
-	// single enqueue / dequeue
-	q.Enqueue(items[0].key, items[0].val)
-	got := getScheduledItem(t, q)
-	want := 1
-	if got != want {
-		t.Fatalf("got %v want %v", got, want)
-	}
-
-	// fill the queue and drain it
-	for _, v := range []int{0, 1, 2, 3, 4} {
-		q.Enqueue(items[v].key, items[v].val)
-	}
-	for _, v := range []int{0, 1, 2, 3, 4} {
-		want := items[v].val
-		got := getScheduledItem(t, q)
-		if got != want {
-			t.Fatalf("got %v want %v", got, want)
-		}
-	}
-
-	// fill the queue and verify unique property
-	for _, v := range []int{1, 2, 3, 4, 0} {
-		q.Enqueue(items[v].key, items[v].val)
-	}
-	// enqueue dups in a different order
-	for _, v := range []int{4, 0, 1, 2, 3} {
-		q.Enqueue(items[v].key, items[v].val)
-	}
-
-	for _, i := range []int{1, 2, 3, 4, 0} {
-		want := items[i].val
-		got := getScheduledItem(t, q)
-		if got != want {
-			t.Fatalf("got %v want %v", got, want)
-		}
-	}
-
-	select {
-	case <-q.Done():
-		t.Fatal("unexpected Done()")
-	case <-q.Ready():
-		t.Fatal("unexpected Ready()")
-	case <-time.After(100 * time.Millisecond):
-	}
-}
-
-func TestUniqueQueue_DequeueBeforeReady(t *testing.T) {
-	q := NewUniqueScheduledQueue(5)
-
-	for _, v := range []int{0, 1, 2, 3, 4} {
-		q.Enqueue(items[v].key, items[v].val)
-	}
-
-	// // re-enqueue the first two dequeued items
-	for range []int{0, 1} {
-		key, item, _ := q.Dequeue()
-		q.Enqueue(key, item)
-	}
-
-	for _, v := range []int{2, 3, 4, 0, 1} {
-		want := items[v].val
-		got := getScheduledItem(t, q)
-		if got != want {
-			t.Fatalf("got %v want %v", got, want)
-		}
-	}
-
-	// verify no more Ready() indications
-	select {
-	case <-q.Done():
-		t.Fatal("unexpected Done()")
-	case <-q.Ready():
-		t.Fatal("unexpected Ready()")
-	case <-time.After(100 * time.Millisecond):
-	}
-
-	// verify close
-
-	q.Close()
-
-	select {
-	case <-q.Done():
-		// pass
-	case <-q.Ready():
-		t.Fatal("unexpected Ready()")
-	case <-time.After(100 * time.Millisecond):
-		t.Fatal("Done() indication missed")
-	}
-
-	// test passes if nothing deadlocks
-}
-
-func TestUniqueQueue_Done(t *testing.T) {
-	q := NewUniqueScheduledQueue(5)
-
-	q.Enqueue(items[0].key, items[0].val)
-	q.Enqueue(items[1].key, items[1].val)
-	q.Enqueue(items[2].key, items[2].val)
-
-	q.Close()
-
-	q.Enqueue(items[4].key, items[4].val)
-	q.Enqueue(items[5].key, items[5].val) // queue full
-	q.Enqueue(items[1].key, items[1].val) // and a dup
-
-	wanted := []int{0, 1, 2, 3, 4}
-
-	for {
-		select {
-		case <-q.Done():
-			return
-		case <-q.Ready():
-			_, v, _ := q.Dequeue()
-
-			got := v.(int)
-			if len(wanted) == 0 {
-				t.Fatalf("got unexpected item: %v", got)
-			}
-
-			want := items[wanted[0]].val
-			wanted = wanted[1:]
-
-			if got != want {
-				t.Fatalf("got %v want %v", got, want)
-			}
-		case <-time.After(time.Second):
-			t.Fatal("timeout waiting for Done()")
-		}
-	}
-}
-
-func TestUniqueQueue_EnqueueAfterClose(t *testing.T) {
-	q := NewUniqueScheduledQueue(5)
-
-	for _, v := range []int{0, 1, 2, 3, 4} {
-		q.Enqueue(items[v].key, items[v].val)
-	}
-
-	for _, v := range []int{0, 1, 2} {
-		want := items[v].val
-		got := getScheduledItem(t, q)
-		if got != want {
-			t.Fatalf("got %v want %v", got, want)
-		}
-	}
-
-	q.Close()
-
-	for _, v := range []int{3, 4} {
-		want := items[v].val
-
-		select {
-		case <-q.Ready():
-			_, got, ok := q.Dequeue()
-			if !ok {
-				t.Fatal("Dequeue() returned no entries")
-			}
-			if got != want {
-				t.Fatalf("got %v want %v", got, want)
-			}
-		case <-time.After(time.Second):
-			t.Fatal("timeout waiting for scheduled response")
-		}
-	}
-
-	if q.Enqueue(items[0].key, items[0].val) != false {
-		t.Fatal("Enqueue() after close should fail")
-	}
-
-	select {
-	case <-q.Ready():
-		k, v, ok := q.Dequeue()
-		t.Fatalf("unexpected Dequeue() after close: got key=%v value=%v ok=%v", k, v, ok)
-	case <-time.After(time.Second):
-	}
-
-	select {
-	case <-q.Done():
-	case <-time.After(time.Second):
-		t.Fatal("timeout waiting for Done()")
-	}
-}
-
-func TestUniqueQueue_Dump(t *testing.T) {
-	q := NewUniqueScheduledQueue(5)
-	for i := 0; i < 5; i++ {
-		q.Enqueue(items[i].key, items[i].val)
-	}
-
-	want := `{
-   "closed":false,
-   "queued_set":{  
-      "collection/1":1,
-      "collection/2":2,
-      "collection/3":3,
-      "collection/4":4,
-      "collection/5":5
-   },
-   "queue":[  
-      "collection/1",
-      "collection/2",
-      "collection/3",
-      "collection/4",
-      "collection/5",
-      ""
-   ],
-   "head":0,
-   "tail":5,
-   "max_depth":5
-}
-`
-	space := regexp.MustCompile(`\s+`)
-	want = space.ReplaceAllString(want, "")
-	got := q.Dump()
-
-	if diff := cmp.Diff(got, want); diff != "" {
-		t.Fatalf("\n got %v \nwant %v\n diff %v", got, want, diff)
-	}
-
-	jsonMarshalDumpHook = func(v interface{}) ([]byte, error) { return nil, errors.New("unmarhsal error") }
-	defer func() { jsonMarshalDumpHook = json.Marshal }()
-
-	want = ""
-	got = q.Dump()
-	if got != want {
-		t.Fatalf("wrong output on json marshal error\n got %v \nwant %v", got, want)
-	}
-}
diff --git a/pkg/mcp/internal/size.go b/pkg/mcp/internal/size.go
deleted file mode 100644
index 1f9e89ac28..0000000000
--- a/pkg/mcp/internal/size.go
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Provides a ProtoSize method that can be swapped for proto.Size when using Google protos.
-
-package internal
-
-type hasSize interface {
-	Size() int
-}
-
-func ProtoSize(msg hasSize) int {
-	return msg.Size()
-}
diff --git a/pkg/mcp/internal/test/auth_checker.go b/pkg/mcp/internal/test/auth_checker.go
deleted file mode 100644
index dd458b9051..0000000000
--- a/pkg/mcp/internal/test/auth_checker.go
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package test
-
-import (
-	"google.golang.org/grpc/credentials"
-)
-
-type FakeAuthChecker struct {
-	AllowError error
-}
-
-func NewFakeAuthChecker() *FakeAuthChecker {
-	return &FakeAuthChecker{}
-}
-
-func (f *FakeAuthChecker) Check(authInfo credentials.AuthInfo) error {
-	return f.AllowError
-}
-
-func (f *FakeAuthChecker) AuthType() string {
-	if f.AllowError != nil {
-		return "disallowed"
-	}
-	return "allowed"
-}
diff --git a/pkg/mcp/internal/test/types.go b/pkg/mcp/internal/test/types.go
deleted file mode 100644
index 9533947e5d..0000000000
--- a/pkg/mcp/internal/test/types.go
+++ /dev/null
@@ -1,201 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package test
-
-import (
-	"errors"
-	"fmt"
-	"strings"
-
-	"github.com/gogo/protobuf/proto"
-	"github.com/gogo/protobuf/types"
-	"google.golang.org/grpc/codes"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/pkg/mcp/status"
-)
-
-type FakeTypeBase struct{ Info string }
-
-func (f *FakeTypeBase) Reset()                   {}
-func (f *FakeTypeBase) String() string           { return f.Info }
-func (f *FakeTypeBase) ProtoMessage()            {}
-func (f *FakeTypeBase) Marshal() ([]byte, error) { return []byte(f.Info), nil }
-func (f *FakeTypeBase) Unmarshal(in []byte) error {
-	f.Info = string(in)
-	return nil
-}
-
-type (
-	FakeType0 struct{ FakeTypeBase }
-	FakeType1 struct{ FakeTypeBase }
-	FakeType2 struct{ FakeTypeBase }
-)
-
-type UnmarshalErrorType struct{ FakeTypeBase }
-
-func (f *UnmarshalErrorType) Unmarshal(in []byte) error { return errors.New("unmarshal_error") }
-
-const (
-	TypePrefix                = "type.googleapis.com/"
-	FakeType0MessageName      = "istio.io.galley.pkg.mcp.server.FakeType0"
-	FakeType1MessageName      = "istio.io.galley.pkg.mcp.server.FakeType1"
-	FakeType2MessageName      = "istio.io.galley.pkg.mcp.server.FakeType2"
-	UnmarshalErrorMessageName = "istio.io.galley.pkg.mcp.server.UnmarshalErrorType"
-
-	FakeType0TypeURL      = TypePrefix + FakeType0MessageName
-	FakeType1TypeURL      = TypePrefix + FakeType1MessageName
-	FakeType2TypeURL      = TypePrefix + FakeType2MessageName
-	UnmarshalErrorTypeURL = TypePrefix + UnmarshalErrorMessageName
-)
-
-var (
-	FakeType0Collection      = strings.Replace(FakeType0MessageName, ".", "/", -1)
-	FakeType1Collection      = strings.Replace(FakeType1MessageName, ".", "/", -1)
-	FakeType2Collection      = strings.Replace(FakeType2MessageName, ".", "/", -1)
-	UnmarshalErrorCollection = strings.Replace(UnmarshalErrorMessageName, ".", "/", -1)
-)
-
-type Fake struct {
-	Resource   *mcp.Resource
-	Metadata   *mcp.Metadata
-	Proto      proto.Message
-	Collection string
-	TypeURL    string
-}
-
-func MakeRequest(incremental bool, collection, nonce string, errorCode codes.Code) *mcp.RequestResources {
-	req := &mcp.RequestResources{
-		SinkNode:      Node,
-		Collection:    collection,
-		ResponseNonce: nonce,
-		Incremental:   incremental,
-	}
-	if errorCode != codes.OK {
-		req.ErrorDetail = status.New(errorCode, "").Proto()
-	}
-	return req
-}
-
-func MakeResources(incremental bool, collection, version, nonce string, removed []string, fakes ...*Fake) *mcp.Resources {
-	r := &mcp.Resources{
-		Collection:        collection,
-		Nonce:             nonce,
-		RemovedResources:  removed,
-		SystemVersionInfo: version,
-		Incremental:       incremental,
-	}
-	for _, fake := range fakes {
-		r.Resources = append(r.Resources, *fake.Resource)
-	}
-	return r
-}
-
-func MakeFakeResource(collection, typeURL, version, name, data string) *Fake {
-	var pb proto.Message
-	switch typeURL {
-	case FakeType0TypeURL:
-		pb = &FakeType0{FakeTypeBase{data}}
-	case FakeType1TypeURL:
-		pb = &FakeType1{FakeTypeBase{data}}
-	case FakeType2TypeURL:
-		pb = &FakeType2{FakeTypeBase{data}}
-	case UnmarshalErrorTypeURL:
-		pb = &UnmarshalErrorType{FakeTypeBase{data}}
-	default:
-		panic(fmt.Sprintf("unknown typeURL: %v", typeURL))
-	}
-
-	body, err := types.MarshalAny(pb)
-	if err != nil {
-		panic(fmt.Sprintf("could not marshal fake body: %v", err))
-	}
-
-	metadata := &mcp.Metadata{Name: name, Version: version}
-
-	envelope := &mcp.Resource{
-		Metadata: metadata,
-		Body:     body,
-	}
-
-	return &Fake{
-		Resource:   envelope,
-		Metadata:   metadata,
-		Proto:      pb,
-		TypeURL:    typeURL,
-		Collection: collection,
-	}
-}
-
-var (
-	Type0A = []*Fake{}
-	Type0B = []*Fake{}
-	Type0C = []*Fake{}
-	Type1A = []*Fake{}
-	Type2A = []*Fake{}
-
-	BadUnmarshal = MakeFakeResource(UnmarshalErrorCollection, UnmarshalErrorTypeURL, "v0", "bad", "data")
-
-	SupportedCollections = []string{
-		FakeType0Collection,
-		FakeType1Collection,
-		FakeType2Collection,
-	}
-
-	NodeID = "test-node"
-	Node   = &mcp.SinkNode{
-		Id: NodeID,
-		Annotations: map[string]string{
-			"foo": "bar",
-		},
-	}
-	NodeMetadata = map[string]string{"foo": "bar"}
-)
-
-func init() {
-	proto.RegisterType((*FakeType0)(nil), FakeType0MessageName)
-	proto.RegisterType((*FakeType1)(nil), FakeType1MessageName)
-	proto.RegisterType((*FakeType2)(nil), FakeType2MessageName)
-	proto.RegisterType((*UnmarshalErrorType)(nil), UnmarshalErrorMessageName)
-
-	Type0A = []*Fake{
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v0", "a", "data-a0"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v1", "a", "data-a1"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v2", "a", "data-a2"),
-	}
-	Type0B = []*Fake{
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v0", "b", "data-b0"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v1", "b", "data-b1"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v2", "b", "data-b2"),
-	}
-	Type0C = []*Fake{
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v0", "c", "data-c0"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v1", "c", "data-c1"),
-		MakeFakeResource(FakeType0Collection, FakeType0TypeURL, "v2", "c", "data-c2"),
-	}
-
-	Type1A = []*Fake{
-		MakeFakeResource(FakeType1Collection, FakeType1TypeURL, "v0", "a", "data-a0"),
-		MakeFakeResource(FakeType1Collection, FakeType1TypeURL, "v1", "a", "data-a1"),
-		MakeFakeResource(FakeType1Collection, FakeType1TypeURL, "v2", "a", "data-a2"),
-	}
-
-	Type2A = []*Fake{
-		MakeFakeResource(FakeType2Collection, FakeType2TypeURL, "v0", "a", "data-a0"),
-		MakeFakeResource(FakeType2Collection, FakeType2TypeURL, "v1", "a", "data-a1"),
-		MakeFakeResource(FakeType2Collection, FakeType2TypeURL, "v2", "a", "data-a2"),
-	}
-
-	BadUnmarshal = MakeFakeResource(UnmarshalErrorCollection, UnmarshalErrorTypeURL, "v0", "bad", "data")
-}
diff --git a/pkg/mcp/sink/sink.go b/pkg/mcp/sink/sink.go
deleted file mode 100644
index 9cdba88461..0000000000
--- a/pkg/mcp/sink/sink.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package sink
-
-import (
-	"github.com/gogo/protobuf/proto"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-)
-
-// Object contains a decoded versioned object with metadata received from the server.
-type Object struct {
-	TypeURL  string
-	Metadata *mcp.Metadata
-	Body     proto.Message
-}
diff --git a/pkg/mcp/snapshot/inmemory.go b/pkg/mcp/snapshot/inmemory.go
deleted file mode 100644
index d3c21f2c12..0000000000
--- a/pkg/mcp/snapshot/inmemory.go
+++ /dev/null
@@ -1,215 +0,0 @@
-//  Copyright Istio Authors
-//
-//  Licensed under the Apache License, Version 2.0 (the "License");
-//  you may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-
-package snapshot
-
-import (
-	"bytes"
-	"fmt"
-	"sort"
-	"strings"
-	"time"
-
-	"github.com/gogo/protobuf/proto"
-	"github.com/gogo/protobuf/types"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-)
-
-// InMemory Snapshot implementation
-type InMemory struct {
-	resources map[string][]*mcp.Resource
-	versions  map[string]string
-}
-
-var _ Snapshot = &InMemory{}
-
-// InMemoryBuilder is a builder for an InMemory snapshot.
-type InMemoryBuilder struct {
-	snapshot *InMemory
-}
-
-// NewInMemoryBuilder creates and returns a new InMemoryBuilder.
-func NewInMemoryBuilder() *InMemoryBuilder {
-	snapshot := &InMemory{
-		resources: make(map[string][]*mcp.Resource),
-		versions:  make(map[string]string),
-	}
-
-	return &InMemoryBuilder{
-		snapshot: snapshot,
-	}
-}
-
-// Set the values for a given collection. If Set is called after a call to Freeze, then this method panics.
-func (b *InMemoryBuilder) Set(collection, version string, resources []*mcp.Resource) {
-	b.snapshot.resources[collection] = resources
-	b.snapshot.versions[collection] = version
-}
-
-// SetEntry sets a single entry. Note that this is a slow operation, as update requires scanning
-// through existing entries.
-func (b *InMemoryBuilder) SetEntry(collection, name, version string, createTime time.Time, labels,
-	annotations map[string]string, m proto.Message) error {
-	body, err := types.MarshalAny(m)
-	if err != nil {
-		return err
-	}
-
-	createTimeProto, err := types.TimestampProto(createTime)
-	if err != nil {
-		return err
-	}
-
-	e := &mcp.Resource{
-		Metadata: &mcp.Metadata{
-			Name:        name,
-			CreateTime:  createTimeProto,
-			Labels:      labels,
-			Annotations: annotations,
-			Version:     version,
-		},
-		Body: body,
-	}
-
-	entries := b.snapshot.resources[collection]
-
-	for i, prev := range entries {
-		if prev.Metadata.Name == e.Metadata.Name {
-			entries[i] = e
-			return nil
-		}
-	}
-
-	entries = append(entries, e)
-	b.snapshot.resources[collection] = entries
-	return nil
-}
-
-// DeleteEntry deletes the named entry within the given collection.
-func (b *InMemoryBuilder) DeleteEntry(collection string, name string) {
-	entries, found := b.snapshot.resources[collection]
-	if !found {
-		return
-	}
-
-	for i, e := range entries {
-		if e.Metadata.Name == name {
-			if len(entries) == 1 {
-				delete(b.snapshot.resources, collection)
-				delete(b.snapshot.versions, collection)
-				return
-			}
-
-			entries = append(entries[:i], entries[i+1:]...)
-			b.snapshot.resources[collection] = entries
-
-			return
-		}
-	}
-}
-
-// SetVersion sets the version for the given collection
-func (b *InMemoryBuilder) SetVersion(collection string, version string) {
-	b.snapshot.versions[collection] = version
-}
-
-// Build the snapshot and return.
-func (b *InMemoryBuilder) Build() *InMemory {
-	sn := b.snapshot
-
-	// Avoid mutation after build
-	b.snapshot = nil
-
-	return sn
-}
-
-// Resources is an implementation of Snapshot.Resources
-func (s *InMemory) Resources(collection string) []*mcp.Resource {
-	return s.resources[collection]
-}
-
-// Version is an implementation of Snapshot.Version
-func (s *InMemory) Version(collection string) string {
-	return s.versions[collection]
-}
-
-// Collections is an implementation of Snapshot.Collections
-func (s *InMemory) Collections() []string {
-	result := make([]string, 0, len(s.resources))
-	for col := range s.resources {
-		result = append(result, col)
-	}
-	return result
-}
-
-// Clone this snapshot.
-func (s *InMemory) Clone() *InMemory {
-	c := &InMemory{
-		resources: make(map[string][]*mcp.Resource),
-		versions:  make(map[string]string),
-	}
-
-	for k, v := range s.versions {
-		c.versions[k] = v
-	}
-
-	for k, v := range s.resources {
-		envs := make([]*mcp.Resource, len(v))
-		for i, e := range v {
-			envs[i] = proto.Clone(e).(*mcp.Resource)
-		}
-		c.resources[k] = envs
-	}
-
-	return c
-}
-
-// Builder returns a new builder instance, based on the contents of this snapshot.
-func (s *InMemory) Builder() *InMemoryBuilder {
-	snapshot := s.Clone()
-
-	return &InMemoryBuilder{
-		snapshot: snapshot,
-	}
-}
-
-func (s *InMemory) String() string {
-	var b bytes.Buffer
-
-	messages := make([]string, 0, len(s.resources))
-	for message := range s.resources {
-		messages = append(messages, message)
-	}
-	sort.Strings(messages)
-
-	for i, n := range messages {
-		_, _ = fmt.Fprintf(&b, "[%d] (%s @%s)\n", i, n, s.versions[n])
-
-		envs := s.resources[n]
-
-		// Avoid mutating the original data
-		entries := make([]*mcp.Resource, len(envs))
-		copy(entries, envs)
-		sort.Slice(entries, func(i, j int) bool {
-			return strings.Compare(entries[i].Metadata.Name, entries[j].Metadata.Name) == -1
-		})
-
-		for j, entry := range entries {
-			_, _ = fmt.Fprintf(&b, "  [%d] (%s)\n", j, entry.Metadata.Name)
-		}
-	}
-
-	return b.String()
-}
diff --git a/pkg/mcp/snapshot/inmemory_test.go b/pkg/mcp/snapshot/inmemory_test.go
deleted file mode 100644
index 2c307aebb6..0000000000
--- a/pkg/mcp/snapshot/inmemory_test.go
+++ /dev/null
@@ -1,341 +0,0 @@
-//  Copyright Istio Authors
-//
-//  Licensed under the Apache License, Version 2.0 (the "License");
-//  you may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-
-package snapshot
-
-import (
-	"reflect"
-	"sort"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/gogo/protobuf/types"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-)
-
-var (
-	fakeCreateTime      = time.Date(2018, time.January, 1, 2, 3, 4, 5, time.UTC)
-	fakeLabels          = map[string]string{"lk1": "lv1"}
-	fakeAnnotations     = map[string]string{"ak1": "av1"}
-	fakeCreateTimeProto *types.Timestamp
-)
-
-func init() {
-	var err error
-	fakeCreateTimeProto, err = types.TimestampProto(fakeCreateTime)
-	if err != nil {
-		panic(err)
-	}
-}
-
-func TestInMemoryBuilder(t *testing.T) {
-	b := NewInMemoryBuilder()
-	sn := b.Build()
-
-	if len(sn.resources) != 0 {
-		t.Fatal("Resources should have been empty")
-	}
-
-	if len(sn.versions) != 0 {
-		t.Fatal("Versions should have been empty")
-	}
-}
-
-func TestInMemoryBuilder_Set(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	items := []*mcp.Resource{{Body: &types.Any{}, Metadata: &mcp.Metadata{Name: "foo"}}}
-	b.Set("collection", "v1", items)
-	sn := b.Build()
-
-	if sn.Version("collection") != "v1" {
-		t.Fatalf("Unexpected version: %v", sn.Version("type"))
-	}
-
-	actual := sn.Resources("collection")
-	if !reflect.DeepEqual(items, sn.Resources("collection")) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, items)
-	}
-}
-
-func TestInMemoryBuilder_SetEntry_Add(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-
-	sn := b.Build()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "foo",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any", Value: []byte{}},
-		},
-	}
-	actual := sn.Resources("collection")
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-}
-
-func TestInMemoryBuilder_SetEntry_Update(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-
-	sn := b.Build()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "foo",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any", Value: []byte{}},
-		},
-	}
-	actual := sn.Resources("collection")
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-}
-
-func TestInMemoryBuilder_SetEntry_Marshal_Error(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	err := b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, nil)
-	if err == nil {
-		t.Fatal("expected error not found")
-	}
-}
-
-func TestInMemoryBuilder_DeleteEntry_EntryNotFound(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.DeleteEntry("collection", "bar")
-	sn := b.Build()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "foo",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any", Value: []byte{}},
-		},
-	}
-	actual := sn.Resources("collection")
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-}
-
-func TestInMemoryBuilder_DeleteEntry_TypeNotFound(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	b.DeleteEntry("collection", "bar")
-	sn := b.Build()
-
-	if len(sn.resources) != 0 {
-		t.Fatal("Resources should have been empty")
-	}
-
-	if len(sn.versions) != 0 {
-		t.Fatal("Versions should have been empty")
-	}
-}
-
-func TestInMemoryBuilder_DeleteEntry_Single(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.DeleteEntry("collection", "foo")
-	sn := b.Build()
-
-	if len(sn.resources) != 0 {
-		t.Fatal("Resources should have been empty")
-	}
-
-	if len(sn.versions) != 0 {
-		t.Fatal("Versions should have been empty")
-	}
-}
-
-func TestInMemoryBuilder_DeleteEntry_Multiple(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	_ = b.SetEntry("collection", "bar", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.DeleteEntry("collection", "foo")
-	sn := b.Build()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "bar",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any", Value: []byte{}},
-		},
-	}
-	actual := sn.Resources("collection")
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-}
-
-func TestInMemoryBuilder_SetVersion(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.SetVersion("collection", "v1")
-	sn := b.Build()
-
-	if sn.Version("collection") != "v1" {
-		t.Fatalf("Unexpected version: %s", sn.Version("type"))
-	}
-}
-
-func TestInMemory_Clone(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	_ = b.SetEntry("collection", "bar", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.SetVersion("collection", "v1")
-	sn := b.Build()
-
-	sn2 := sn.Clone()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "bar",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any"},
-		},
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "foo",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any"},
-		},
-	}
-
-	actual := sn2.Resources("collection")
-
-	sort.Slice(actual, func(i, j int) bool {
-		return strings.Compare(
-			actual[i].Metadata.Name,
-			actual[j].Metadata.Name) < 0
-	})
-
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-
-	if sn2.Version("collection") != "v1" {
-		t.Fatalf("Unexpected version: %s", sn2.Version("type"))
-	}
-}
-
-func TestInMemory_Builder(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	_ = b.SetEntry("collection", "bar", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.SetVersion("collection", "v1")
-	sn := b.Build()
-
-	b = sn.Builder()
-
-	sn2 := b.Build()
-
-	expected := []*mcp.Resource{
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "bar",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any"},
-		},
-		{
-			Metadata: &mcp.Metadata{
-				Name:        "foo",
-				Version:     "v0",
-				CreateTime:  fakeCreateTimeProto,
-				Labels:      fakeLabels,
-				Annotations: fakeAnnotations,
-			},
-			Body: &types.Any{TypeUrl: "type.googleapis.com/google.protobuf.Any"},
-		},
-	}
-
-	actual := sn2.Resources("collection")
-
-	sort.Slice(actual, func(i, j int) bool {
-		return strings.Compare(
-			actual[i].Metadata.Name,
-			actual[j].Metadata.Name) < 0
-	})
-
-	if !reflect.DeepEqual(expected, actual) {
-		t.Fatalf("Mismatch:\nGot:\n%v\nWanted:\n%v\n", actual, expected)
-	}
-
-	if sn2.Version("collection") != "v1" {
-		t.Fatalf("Unexpected version: %s", sn2.Version("type"))
-	}
-}
-
-func TestInMemory_String(t *testing.T) {
-	b := NewInMemoryBuilder()
-
-	_ = b.SetEntry("collection", "foo", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	_ = b.SetEntry("collection", "bar", "v0", fakeCreateTime, fakeLabels, fakeAnnotations, &types.Any{})
-	b.SetVersion("collection", "v1")
-	sn := b.Build()
-
-	// Shouldn't crash
-	_ = sn.String()
-}
diff --git a/pkg/mcp/snapshot/snapshot.go b/pkg/mcp/snapshot/snapshot.go
deleted file mode 100644
index 92d6098e93..0000000000
--- a/pkg/mcp/snapshot/snapshot.go
+++ /dev/null
@@ -1,317 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshot
-
-import (
-	"sort"
-	"sync"
-	"time"
-
-	"github.com/gogo/protobuf/types"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/pkg/mcp/sink"
-	"istio.io/istio/pkg/mcp/source"
-	"istio.io/pkg/log"
-)
-
-var scope = log.RegisterScope("mcp", "mcp debugging", 0)
-
-// Snapshot provides an immutable view of versioned resources.
-type Snapshot interface {
-	Collections() []string
-	Resources(collection string) []*mcp.Resource
-	Version(collection string) string
-}
-
-// Info is used for configz
-type Info struct {
-	// Collection of mcp resource
-	Collection string
-	// Version of the resource
-	Version string
-	// Names of the resource entries.
-	Names []string
-	// Synced of this collection, including peerAddr and synced status
-	Synced map[string]bool
-}
-
-// Cache is a snapshot-based cache that maintains a single versioned
-// snapshot of responses per group of clients. Cache consistently replies with the
-// latest snapshot.
-type Cache struct {
-	mu         sync.RWMutex
-	snapshots  map[string]Snapshot
-	status     map[string]*StatusInfo
-	watchCount int64
-
-	groupIndex GroupIndexFn
-}
-
-// GroupIndexFn returns a stable group index for the given MCP collection and node.
-// This is how an MCP server partitions snapshots to different clients. The index
-// function is an implementation detail of the MCP server and Istio does not
-// depend on any particular mapping.
-type GroupIndexFn func(collection string, node *mcp.SinkNode) string
-
-// New creates a new cache of resource snapshots.
-func New(groupIndex GroupIndexFn) *Cache {
-	return &Cache{
-		snapshots:  make(map[string]Snapshot),
-		status:     make(map[string]*StatusInfo),
-		groupIndex: groupIndex,
-	}
-}
-
-type responseWatch struct {
-	request      *source.Request
-	pushResponse source.PushResponseFunc
-}
-
-// StatusInfo records watch status information of a group.
-type StatusInfo struct {
-	mu                   sync.RWMutex
-	lastWatchRequestTime time.Time // informational
-	watches              map[int64]*responseWatch
-	// the synced structure is {Collection: {peerAddress: synced|nosynced}}.
-	synced map[string]map[string]bool
-}
-
-// Watch returns a watch for an MCP request.
-func (c *Cache) Watch(
-	request *source.Request,
-	pushResponse source.PushResponseFunc,
-	peerAddr string) source.CancelWatchFunc {
-	group := c.groupIndex(request.Collection, request.SinkNode)
-
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	info := c.fillStatus(group, request, peerAddr)
-
-	collection := request.Collection
-
-	// return an immediate response if a snapshot is available and the
-	// requested version doesn't match.
-	if snapshot, ok := c.snapshots[group]; ok {
-
-		version := snapshot.Version(request.Collection)
-		scope.Debugf("Found snapshot for group: %q for %v @ version: %q",
-			group, request.Collection, version)
-
-		if version != request.VersionInfo {
-			scope.Debugf("Responding to group %q snapshot:\n%v\n", group, snapshot)
-			response := &source.WatchResponse{
-				Collection: request.Collection,
-				Version:    version,
-				Resources:  snapshot.Resources(request.Collection),
-				Request:    request,
-			}
-			pushResponse(response)
-			return nil
-		}
-		info.mu.Lock()
-		info.synced[request.Collection][peerAddr] = true
-		info.mu.Unlock()
-	}
-
-	// Otherwise, open a watch if no snapshot was available or the requested version is up-to-date.
-	c.watchCount++
-	watchID := c.watchCount
-
-	scope.Infof("Watch(): created watch %d for %s from group %q, version %q",
-		watchID, collection, group, request.VersionInfo)
-
-	info.mu.Lock()
-	info.watches[watchID] = &responseWatch{request: request, pushResponse: pushResponse}
-	info.mu.Unlock()
-
-	cancel := func() {
-		c.mu.Lock()
-		defer c.mu.Unlock()
-		if s, ok := c.status[group]; ok {
-			s.mu.Lock()
-			delete(s.watches, watchID)
-			s.mu.Unlock()
-		}
-	}
-	return cancel
-}
-
-func (c *Cache) fillStatus(group string, request *source.Request, peerAddr string) *StatusInfo {
-	info, ok := c.status[group]
-	if !ok {
-		info = &StatusInfo{
-			watches: make(map[int64]*responseWatch),
-			synced:  make(map[string]map[string]bool),
-		}
-		peerStatus := make(map[string]bool)
-		peerStatus[peerAddr] = false
-		info.mu.Lock()
-		info.synced[request.Collection] = peerStatus
-		info.mu.Unlock()
-		c.status[group] = info
-	} else {
-		collectionExists := false
-		peerExists := false
-		info.mu.Lock()
-		for collection, synced := range info.synced {
-			if collection == request.Collection {
-				collectionExists = true
-				for addr := range synced {
-					if addr == peerAddr {
-						peerExists = true
-						break
-					}
-				}
-			}
-			if collectionExists && peerExists {
-				break
-			}
-		}
-		if !collectionExists {
-			// initiate the synced map
-			peerStatus := make(map[string]bool)
-			peerStatus[peerAddr] = false
-			info.synced[request.Collection] = peerStatus
-		}
-		if !peerExists {
-			info.synced[request.Collection][peerAddr] = false
-		}
-		info.mu.Unlock()
-	}
-
-	// update last responseWatch request time
-	info.mu.Lock()
-	info.lastWatchRequestTime = time.Now()
-	info.mu.Unlock()
-
-	return info
-}
-
-// SetSnapshot updates a snapshot for a group.
-func (c *Cache) SetSnapshot(group string, snapshot Snapshot) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	// update the existing entry
-	c.snapshots[group] = snapshot
-
-	// trigger existing watches for which version changed
-	if info, ok := c.status[group]; ok {
-		info.mu.Lock()
-		defer info.mu.Unlock()
-
-		for id, watch := range info.watches {
-			version := snapshot.Version(watch.request.Collection)
-			if version != watch.request.VersionInfo {
-				scope.Infof("SetSnapshot(): respond to watch %d for %v @ version %q",
-					id, watch.request.Collection, version)
-
-				response := &source.WatchResponse{
-					Collection: watch.request.Collection,
-					Version:    version,
-					Resources:  snapshot.Resources(watch.request.Collection),
-					Request:    watch.request,
-				}
-				watch.pushResponse(response)
-
-				// discard the responseWatch
-				delete(info.watches, id)
-
-				scope.Debugf("SetSnapshot(): watch %d for %v @ version %q complete",
-					id, watch.request.Collection, version)
-			}
-		}
-	}
-}
-
-// ClearSnapshot clears snapshot for a group. This does not cancel any open
-// watches already created (see ClearStatus).
-func (c *Cache) ClearSnapshot(group string) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	delete(c.snapshots, group)
-}
-
-// ClearStatus clears status for a group. This has the effect of canceling
-// any open watches opened against this group info.
-func (c *Cache) ClearStatus(group string) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	if info, ok := c.status[group]; ok {
-		info.mu.Lock()
-		for _, watch := range info.watches {
-			// response channel may be shared
-			watch.pushResponse(nil)
-		}
-		info.mu.Unlock()
-	}
-	delete(c.status, group)
-}
-
-// Status returns informational status for a group.
-func (c *Cache) Status(group string) *StatusInfo {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	if info, ok := c.status[group]; ok {
-		return info
-	}
-	return nil
-}
-
-// GetGroups returns all groups of snapshots that the server layer is serving.
-func (c *Cache) GetGroups() []string {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	groups := make([]string, 0, len(c.snapshots))
-
-	for t := range c.snapshots {
-		groups = append(groups, t)
-	}
-	sort.Strings(groups)
-
-	return groups
-}
-
-// GetResource returns the mcp resource detailed information for the specified group
-func (c *Cache) GetResource(group string, collection string, resourceName string) *sink.Object {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	// if the group or collection is empty, return empty
-	if group == "" || collection == "" {
-		return nil
-	}
-
-	if snapshot, ok := c.snapshots[group]; ok {
-		for _, resource := range snapshot.Resources(collection) {
-			if resource.Metadata.Name == resourceName {
-				var dynamicAny types.DynamicAny
-				if err := types.UnmarshalAny(resource.Body, &dynamicAny); err == nil {
-					return &sink.Object{
-						TypeURL:  resource.Body.TypeUrl,
-						Metadata: resource.Metadata,
-						Body:     dynamicAny.Message,
-					}
-				}
-			}
-		}
-	}
-	return nil
-}
diff --git a/pkg/mcp/snapshot/snapshot_test.go b/pkg/mcp/snapshot/snapshot_test.go
deleted file mode 100644
index d779e8e48e..0000000000
--- a/pkg/mcp/snapshot/snapshot_test.go
+++ /dev/null
@@ -1,329 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshot
-
-import (
-	"errors"
-	"fmt"
-	"strconv"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/google/go-cmp/cmp"
-	"github.com/google/go-cmp/cmp/cmpopts"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/pkg/mcp/internal/test"
-	"istio.io/istio/pkg/mcp/source"
-	"istio.io/istio/pkg/mcp/testing/groups"
-)
-
-type fakeSnapshot struct {
-	// read-only fields - no locking required
-	resources map[string][]*mcp.Resource
-	versions  map[string]string
-}
-
-func (fs *fakeSnapshot) Resources(collection string) []*mcp.Resource { return fs.resources[collection] }
-func (fs *fakeSnapshot) Version(collection string) string            { return fs.versions[collection] }
-func (fs *fakeSnapshot) Collections() []string {
-	result := make([]string, 0, len(fs.resources))
-	for collection := range fs.resources {
-		result = append(result, collection)
-	}
-
-	return result
-}
-
-func (fs *fakeSnapshot) copy() *fakeSnapshot {
-	fsCopy := &fakeSnapshot{
-		resources: make(map[string][]*mcp.Resource),
-		versions:  make(map[string]string),
-	}
-	for collection, resources := range fs.resources {
-		fsCopy.resources[collection] = append(fsCopy.resources[collection], resources...)
-		fsCopy.versions[collection] = fs.versions[collection]
-	}
-	return fsCopy
-}
-
-func makeSnapshot(version string) *fakeSnapshot {
-	return &fakeSnapshot{
-		resources: map[string][]*mcp.Resource{
-			test.FakeType0Collection: {test.Type0A[0].Resource},
-			test.FakeType1Collection: {test.Type1A[0].Resource},
-			test.FakeType2Collection: {test.Type2A[0].Resource},
-		},
-		versions: map[string]string{
-			test.FakeType0Collection: version,
-			test.FakeType1Collection: version,
-			test.FakeType2Collection: version,
-		},
-	}
-}
-
-var _ Snapshot = &fakeSnapshot{}
-
-// TODO - refactor tests to not rely on sleeps
-var (
-	asyncResponseTimeout = 200 * time.Millisecond
-)
-
-func nextStrVersion(version *int64) string {
-	v := atomic.AddInt64(version, 1)
-	return strconv.FormatInt(v, 10)
-}
-
-// nolint: unparam
-func createTestWatch(c source.Watcher, collection, version string, responseC chan *source.WatchResponse, wantResponse, wantCancel bool) (*source.WatchResponse, source.CancelWatchFunc, error) { // nolint: lll
-	req := &source.Request{
-		Collection:  collection,
-		VersionInfo: version,
-		SinkNode:    test.Node,
-	}
-
-	cancel := c.Watch(req, func(response *source.WatchResponse) {
-		responseC <- response
-	}, "192.168.1.1:1234")
-
-	if wantResponse {
-		select {
-		case got := <-responseC:
-			return got, nil, nil
-		default:
-			return nil, nil, errors.New("wanted response, got none")
-		}
-	} else {
-		select {
-		case got := <-responseC:
-			if got != nil {
-				return nil, nil, fmt.Errorf("wanted no response, got %v", got)
-			}
-		default:
-		}
-	}
-
-	if wantCancel {
-		if cancel == nil {
-			return nil, nil, errors.New("wanted cancel() function, got none")
-		}
-	} else {
-		if cancel != nil {
-			return nil, nil, fmt.Errorf("wanted no cancel() function, got %p", cancel)
-		}
-	}
-
-	return nil, cancel, nil
-}
-
-func getAsyncResponse(responseC chan *source.WatchResponse) (*source.WatchResponse, bool) {
-	select {
-	case got, more := <-responseC:
-		if !more {
-			return nil, false
-		}
-		return got, false
-	case <-time.After(asyncResponseTimeout):
-		return nil, true
-	}
-}
-
-func TestCreateWatch(t *testing.T) {
-	var versionInt int64 // atomic
-	initVersion := nextStrVersion(&versionInt)
-	snapshot := makeSnapshot(initVersion)
-
-	c := New(groups.DefaultIndexFn)
-	c.SetSnapshot(groups.Default, snapshot)
-
-	// verify immediate and async responses are handled independently across types.
-
-	for _, collection := range test.SupportedCollections {
-		t.Run(collection, func(t *testing.T) {
-			collectionVersion := initVersion
-			responseC := make(chan *source.WatchResponse, 1)
-
-			// verify immediate response
-			if _, _, err := createTestWatch(c, collection, "", responseC, true, false); err != nil {
-				t.Fatalf("CreateWatch() failed: %v", err)
-			}
-
-			// verify open watch, i.e. no immediate or async response
-			if _, _, err := createTestWatch(c, collection, collectionVersion, responseC, false, true); err != nil {
-				t.Fatalf("CreateWatch() failed: %v", err)
-			}
-
-			if gotResponse, _ := getAsyncResponse(responseC); gotResponse != nil {
-				t.Fatalf("open watch failed: received premature response: %v", gotResponse)
-			}
-
-			// verify async response
-			snapshot = snapshot.copy()
-			watchVersion := collectionVersion
-			collectionVersion = nextStrVersion(&versionInt)
-			snapshot.versions[collection] = collectionVersion
-			c.SetSnapshot(groups.Default, snapshot)
-
-			if gotResponse, _ := getAsyncResponse(responseC); gotResponse != nil {
-				wantResponse := &source.WatchResponse{
-					Collection: collection,
-					Version:    collectionVersion,
-					Resources:  snapshot.Resources(collection),
-					Request: &source.Request{
-						Collection:  collection,
-						SinkNode:    test.Node,
-						VersionInfo: watchVersion,
-					},
-				}
-				if diff := cmp.Diff(gotResponse, wantResponse, cmpopts.IgnoreUnexported(source.Request{})); diff != "" {
-					t.Fatalf("received bad WatchResponse: \n got %v \nwant %v \ndiff %v", gotResponse, wantResponse, diff)
-				}
-			} else {
-				t.Fatalf("watch response channel did not produce response after %v", asyncResponseTimeout)
-			}
-
-			// verify lack of immediate response after async response.
-			if _, _, err := createTestWatch(c, collection, collectionVersion, responseC, false, true); err != nil {
-				t.Fatalf("CreateWatch() failed after receiving prior response: %v", err)
-			}
-
-			if gotResponse, _ := getAsyncResponse(responseC); gotResponse != nil {
-				t.Fatalf("open watch failed after receiving prior response: premature response: %v", gotResponse)
-			}
-		})
-	}
-}
-
-func TestWatchCancel(t *testing.T) {
-	var versionInt int64 // atomic
-	initVersion := nextStrVersion(&versionInt)
-	snapshot := makeSnapshot(initVersion)
-
-	c := New(groups.DefaultIndexFn)
-	c.SetSnapshot(groups.Default, snapshot)
-
-	for _, collection := range test.SupportedCollections {
-		t.Run(collection, func(t *testing.T) {
-			collectionVersion := initVersion
-			responseC := make(chan *source.WatchResponse, 1)
-
-			// verify immediate response
-			if _, _, err := createTestWatch(c, collection, "", responseC, true, false); err != nil {
-				t.Fatalf("CreateWatch failed: immediate response not received: %v", err)
-			}
-
-			// verify watch can be canceled
-			_, cancel, err := createTestWatch(c, collection, collectionVersion, responseC, false, true)
-			if err != nil {
-				t.Fatalf("CreateWatche failed: %v", err)
-			}
-			cancel()
-
-			// verify no response after watch is canceled
-			snapshot = snapshot.copy()
-			collectionVersion = nextStrVersion(&versionInt)
-			snapshot.versions[collection] = collectionVersion
-			c.SetSnapshot(groups.Default, snapshot)
-
-			if gotResponse, _ := getAsyncResponse(responseC); gotResponse != nil {
-				t.Fatalf("open watch failed: received premature response: %v", gotResponse)
-			}
-		})
-	}
-}
-
-func TestClearSnapshot(t *testing.T) {
-	var versionInt int64 // atomic
-	initVersion := nextStrVersion(&versionInt)
-	snapshot := makeSnapshot(initVersion)
-
-	c := New(groups.DefaultIndexFn)
-	c.SetSnapshot(groups.Default, snapshot)
-
-	for _, collection := range test.SupportedCollections {
-		t.Run(collection, func(t *testing.T) {
-			responseC := make(chan *source.WatchResponse, 1)
-
-			// verify no immediate response if snapshot is cleared.
-			c.ClearSnapshot(groups.Default)
-			if _, _, err := createTestWatch(c, collection, "", responseC, false, true); err != nil {
-				t.Fatalf("CreateWatch() failed: %v", err)
-			}
-
-			// verify async response after new snapshot is added
-			snapshot = snapshot.copy()
-			typeVersion := nextStrVersion(&versionInt)
-			snapshot.versions[collection] = typeVersion
-			c.SetSnapshot(groups.Default, snapshot)
-
-			if gotResponse, _ := getAsyncResponse(responseC); gotResponse != nil {
-				wantResponse := &source.WatchResponse{
-					Collection: collection,
-					Version:    typeVersion,
-					Resources:  snapshot.Resources(collection),
-					Request: &source.Request{
-						Collection: collection,
-						SinkNode:   test.Node,
-					},
-				}
-				if diff := cmp.Diff(gotResponse, wantResponse, cmpopts.IgnoreUnexported(source.Request{})); diff != "" {
-					t.Fatalf("received bad WatchResponse: \n got %v \nwant %+v \ndiff %v", gotResponse, wantResponse, diff)
-				}
-			} else {
-				t.Fatalf("watch response channel did not produce response after %v", asyncResponseTimeout)
-			}
-		})
-	}
-}
-
-func TestClearStatus(t *testing.T) {
-	var versionInt int64 // atomic
-	initVersion := nextStrVersion(&versionInt)
-	snapshot := makeSnapshot(initVersion)
-
-	c := New(groups.DefaultIndexFn)
-
-	for _, collection := range test.SupportedCollections {
-		t.Run(collection, func(t *testing.T) {
-			responseC := make(chan *source.WatchResponse, 1)
-
-			if _, _, err := createTestWatch(c, collection, "", responseC, false, true); err != nil {
-				t.Fatalf("CreateWatch() failed: %v", err)
-			}
-
-			if status := c.Status(groups.Default); status == nil {
-				t.Fatal("no status found")
-			}
-
-			c.ClearStatus(groups.Default)
-
-			// verify that ClearStatus() cancels the open watch and
-			// that any subsequent snapshot is not delivered.
-			snapshot = snapshot.copy()
-			typeVersion := nextStrVersion(&versionInt)
-			snapshot.versions[collection] = typeVersion
-			c.SetSnapshot(groups.Default, snapshot)
-
-			if gotResponse, timeout := getAsyncResponse(responseC); gotResponse != nil {
-				t.Fatalf("open watch failed: received unexpected response: %v", gotResponse)
-			} else if timeout {
-				t.Fatal("open watch was not canceled on ClearStatus()")
-			}
-
-			c.ClearSnapshot(groups.Default)
-		})
-	}
-}
diff --git a/pkg/mcp/source/source.go b/pkg/mcp/source/source.go
deleted file mode 100644
index a43dae9297..0000000000
--- a/pkg/mcp/source/source.go
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package source
-
-import (
-	mcp "istio.io/api/mcp/v1alpha1"
-)
-
-// Request is a temporary abstraction for the MCP node request which can
-// be used with the mcp.MeshConfigRequest and mcp.RequestResources. It can
-// be removed once we fully cutover to mcp.RequestResources.
-type Request struct {
-	Collection string
-
-	// Most recent version was that ACK/NACK'd by the sink
-	VersionInfo string
-	SinkNode    *mcp.SinkNode
-}
-
-// WatchResponse contains a versioned collection of pre-serialized resources.
-type WatchResponse struct {
-	Collection string
-
-	// Version of the resources in the response for the given
-	// type. The node responses with this version in subsequent
-	// requests as an acknowledgment.
-	Version string
-
-	// Resourced resources to be included in the response.
-	Resources []*mcp.Resource
-
-	// The original request for triggered this response
-	Request *Request
-}
-
-type (
-	// CancelWatchFunc allows the consumer to cancel a previous watch,
-	// terminating the watch for the request.
-	CancelWatchFunc func()
-
-	// PushResponseFunc allows the consumer to push a response for the
-	// corresponding watch.
-	PushResponseFunc func(*WatchResponse)
-)
-
-// Watcher requests watches for configuration resources by node, last
-// applied version, and type. The watch should send the responses when
-// they are ready. The watch can be canceled by the consumer.
-type Watcher interface {
-	// Watch returns a new open watch for a non-empty request.
-	//
-	// Cancel is an optional function to release resources in the
-	// producer. It can be called idempotently to cancel and release resources.
-	Watch(*Request, PushResponseFunc, string) CancelWatchFunc
-}
diff --git a/pkg/mcp/status/status.go b/pkg/mcp/status/status.go
deleted file mode 100644
index 2da18b6b11..0000000000
--- a/pkg/mcp/status/status.go
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- *
- * Copyright 2017 gRPC authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-// Package status implements errors returned by gRPC.  These errors are
-// serialized and transmitted on the wire between server and client, and allow
-// for additional data to be transmitted via the Details field in the status
-// proto.  gRPC service handlers should return an error created by this
-// package, and gRPC clients should expect a corresponding error to be
-// returned from the RPC call.
-//
-// This package upholds the invariants that a non-nil error may not
-// contain an OK code, and an OK code must result in a nil error.
-package status
-
-import (
-	"errors"
-	"fmt"
-
-	"github.com/gogo/protobuf/proto"
-	"github.com/gogo/protobuf/types"
-	spb "google.golang.org/genproto/googleapis/rpc/status"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/status"
-	any "google.golang.org/protobuf/types/known/anypb"
-
-	rpc "istio.io/gogo-genproto/googleapis/google/rpc"
-)
-
-// statusError is an alias of a status proto.  It implements error and Status,
-// and a nil statusError should never be returned by this package.
-type statusError rpc.Status
-
-func (se *statusError) Error() string {
-	p := (*rpc.Status)(se)
-	return fmt.Sprintf("rpc error: code = %s desc = %s", codes.Code(p.GetCode()), p.GetMessage())
-}
-
-// GRPCStatus converts the gogo/statusError to a grpc/status.
-func (se *statusError) GRPCStatus() *status.Status {
-	p := (*rpc.Status)(se)
-	s := &spb.Status{
-		Code:    p.GetCode(),
-		Message: p.GetMessage(),
-	}
-	for _, detail := range p.GetDetails() {
-		s.Details = append(s.GetDetails(), &any.Any{
-			TypeUrl: detail.GetTypeUrl(),
-			Value:   detail.GetValue(),
-		})
-	}
-	return status.FromProto(s)
-}
-
-// Status represents an RPC status code, message, and details.  It is immutable
-// and should be created with New, Newf, or FromProto.
-type Status struct {
-	s *rpc.Status
-}
-
-// Code returns the status code contained in s.
-func (s *Status) Code() codes.Code {
-	if s == nil || s.s == nil {
-		return codes.OK
-	}
-	return codes.Code(s.s.Code)
-}
-
-// Message returns the message contained in s.
-func (s *Status) Message() string {
-	if s == nil || s.s == nil {
-		return ""
-	}
-	return s.s.Message
-}
-
-// Proto returns s's status as an rpc.Status proto message.
-func (s *Status) Proto() *rpc.Status {
-	if s == nil {
-		return nil
-	}
-	return proto.Clone(s.s).(*rpc.Status)
-}
-
-// Err returns an immutable error representing s; returns nil if s.Code() is
-// OK.
-func (s *Status) Err() error {
-	if s.Code() == codes.OK {
-		return nil
-	}
-	return (*statusError)(s.s)
-}
-
-// New returns a Status representing c and msg.
-func New(c codes.Code, msg string) *Status {
-	return &Status{s: &rpc.Status{Code: int32(c), Message: msg}}
-}
-
-// Newf returns New(c, fmt.Sprintf(format, a...)).
-func Newf(c codes.Code, format string, a ...interface{}) *Status {
-	return New(c, fmt.Sprintf(format, a...))
-}
-
-// Error returns an error representing c and msg.  If c is OK, returns nil.
-func Error(c codes.Code, msg string) error {
-	return New(c, msg).Err()
-}
-
-// Errorf returns Error(c, fmt.Sprintf(format, a...)).
-func Errorf(c codes.Code, format string, a ...interface{}) error {
-	return Error(c, fmt.Sprintf(format, a...))
-}
-
-// ErrorProto returns an error representing s.  If s.Code is OK, returns nil.
-func ErrorProto(s *rpc.Status) error {
-	return FromProto(s).Err()
-}
-
-// FromProto returns a Status representing s.
-func FromProto(s *rpc.Status) *Status {
-	return &Status{s: proto.Clone(s).(*rpc.Status)}
-}
-
-// FromError returns a Status representing err if it was produced from this
-// package or the standard grpc/status package. Otherwise, ok is false and
-// a Status is returned with codes.Unknown and the original error message.
-func FromError(err error) (s *Status, ok bool) {
-	if err == nil {
-		return &Status{s: &rpc.Status{Code: int32(codes.OK)}}, true
-	}
-	if se, ok := err.(interface{ GRPCStatus() *status.Status }); ok {
-		return FromGRPCStatus(se.GRPCStatus()), true
-	}
-	return New(codes.Unknown, err.Error()), false
-}
-
-// FromGRPCStatus converts a grpc.Status to gogo.Status.
-func FromGRPCStatus(st *status.Status) *Status {
-	p := st.Proto()
-	pb := &rpc.Status{
-		Code:    p.GetCode(),
-		Message: p.GetMessage(),
-	}
-	for _, detail := range p.GetDetails() {
-		pb.Details = append(pb.GetDetails(), &types.Any{
-			TypeUrl: detail.GetTypeUrl(),
-			Value:   detail.GetValue(),
-		})
-	}
-	return FromProto(pb)
-}
-
-// Convert is a convenience function which removes the need to handle the
-// boolean return value from FromError.
-func Convert(err error) *Status {
-	s, _ := FromError(err)
-	return s
-}
-
-// WithDetails returns a new status with the provided details messages appended to the status.
-// If any errors are encountered, it returns nil and the first error encountered.
-func (s *Status) WithDetails(details ...proto.Message) (*Status, error) {
-	if s.Code() == codes.OK {
-		return nil, errors.New("no error details for status with code OK")
-	}
-	// s.Code() != OK implies that s.Proto() != nil.
-	p := s.Proto()
-	for _, detail := range details {
-		body, err := types.MarshalAny(detail)
-		if err != nil {
-			return nil, err
-		}
-		p.Details = append(p.Details, body)
-	}
-	return &Status{s: p}, nil
-}
-
-// Details returns a slice of details messages attached to the status.
-// If a detail cannot be decoded, the error is returned in place of the detail.
-func (s *Status) Details() []interface{} {
-	if s == nil || s.s == nil {
-		return nil
-	}
-	details := make([]interface{}, 0, len(s.s.Details))
-	for _, body := range s.s.Details {
-		detail := &types.DynamicAny{}
-		if err := types.UnmarshalAny(body, detail); err != nil {
-			details = append(details, err)
-			continue
-		}
-		details = append(details, detail.Message)
-	}
-	return details
-}
-
-// Code returns the Code of the error if it is a Status error, codes.OK if err
-// is nil, or codes.Unknown otherwise.
-func Code(err error) codes.Code {
-	// Don't use FromError to avoid allocation of OK status.
-	if err == nil {
-		return codes.OK
-	}
-	if se, ok := err.(interface{ GRPCStatus() *status.Status }); ok {
-		return se.GRPCStatus().Code()
-	}
-	return codes.Unknown
-}
diff --git a/pkg/mcp/testing/groups/groups.go b/pkg/mcp/testing/groups/groups.go
deleted file mode 100644
index afc6c9b377..0000000000
--- a/pkg/mcp/testing/groups/groups.go
+++ /dev/null
@@ -1,27 +0,0 @@
-//  Copyright Istio Authors
-//
-//  Licensed under the Apache License, Version 2.0 (the "License");
-//  you may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-
-package groups
-
-import (
-	mcp "istio.io/api/mcp/v1alpha1"
-)
-
-// Default used for testing
-var Default = "default"
-
-// DefaultIndexFn used for testing.
-func DefaultIndexFn(_ string, _ *mcp.SinkNode) string {
-	return Default
-}
diff --git a/security/pkg/nodeagent/test/mock/caserver.go b/security/pkg/nodeagent/test/mock/caserver.go
index 8b4c6dde51..e98982ebc8 100644
--- a/security/pkg/nodeagent/test/mock/caserver.go
+++ b/security/pkg/nodeagent/test/mock/caserver.go
@@ -25,9 +25,9 @@
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/codes"
 	ghc "google.golang.org/grpc/health/grpc_health_v1"
+	"google.golang.org/grpc/status"
 
 	pb "istio.io/api/security/v1alpha1"
-	"istio.io/istio/pkg/mcp/status"
 	"istio.io/istio/pkg/security"
 	"istio.io/istio/pkg/spiffe"
 	caerror "istio.io/istio/security/pkg/pki/error"
-- 
2.35.3

