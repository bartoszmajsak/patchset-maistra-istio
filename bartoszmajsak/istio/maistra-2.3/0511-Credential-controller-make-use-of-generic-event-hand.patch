From f5bf7032cd6cdec004506206f30a0482b5933a77 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Wed, 9 Feb 2022 04:18:00 +0800
Subject:  Credential controller: make use of generic event handler wrapper
 (#37075)

* Pass cb when instantialize Credential controller

* Fix comments

* goimports

* revert changes to handler registration

* remove comment

* goimports
---
 pilot/pkg/bootstrap/server.go              |  2 +-
 pilot/pkg/credentials/kube/multicluster.go | 23 +++----
 pilot/pkg/credentials/kube/secrets.go      | 74 ++++++----------------
 3 files changed, 29 insertions(+), 70 deletions(-)

diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 11dc0bd6bc..288e53474e 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -522,7 +522,7 @@ func (s *Server) initSDSServer() {
 		log.Warnf("skipping Kubernetes credential reader; PILOT_ENABLE_XDS_IDENTITY_CHECK must be set to true for this feature.")
 	} else {
 		creds := kubecredentials.NewMulticluster(s.clusterID)
-		creds.AddEventHandler(func(name string, namespace string) {
+		creds.AddSecretHandler(func(name string, namespace string) {
 			s.XDSServer.ConfigUpdate(&model.PushRequest{
 				Full: false,
 				ConfigsUpdated: map[model.ConfigKey]struct{}{
diff --git a/pilot/pkg/credentials/kube/multicluster.go b/pilot/pkg/credentials/kube/multicluster.go
index c4b7adcde3..31ee2a5878 100644
--- a/pilot/pkg/credentials/kube/multicluster.go
+++ b/pilot/pkg/credentials/kube/multicluster.go
@@ -24,14 +24,14 @@
 	"istio.io/pkg/log"
 )
 
-type eventHandler func(name string, namespace string)
+type secretHandler func(name string, namespace string)
 
 // Multicluster structure holds the remote kube Controllers and multicluster specific attributes.
 type Multicluster struct {
 	remoteKubeControllers map[cluster.ID]*CredentialsController
 	m                     sync.Mutex // protects remoteKubeControllers
 	localCluster          cluster.ID
-	eventHandlers         []eventHandler
+	secretHandlers        []secretHandler
 }
 
 var _ credentials.MulticlusterController = &Multicluster{}
@@ -50,8 +50,8 @@ func (m *Multicluster) ClusterAdded(cluster *multicluster.Cluster, _ <-chan stru
 	sc := NewCredentialsController(cluster.Client, cluster.ID)
 	m.m.Lock()
 	m.remoteKubeControllers[cluster.ID] = sc
-	for _, onCredential := range m.eventHandlers {
-		m.remoteKubeControllers[cluster.ID].AddEventHandler(onCredential)
+	for _, onCredential := range m.secretHandlers {
+		sc.AddEventHandler(onCredential)
 	}
 	m.m.Unlock()
 	return nil
@@ -80,24 +80,21 @@ func (m *Multicluster) ForCluster(clusterID cluster.ID) (credentials.Controller,
 	}
 	agg := &AggregateController{}
 	agg.controllers = []*CredentialsController{}
-
+	agg.authController = m.remoteKubeControllers[clusterID]
 	if clusterID != m.localCluster {
 		// If the request cluster is not the local cluster, we will append it and use it for auth
 		// This means we will prioritize the proxy cluster, then the local cluster for credential lookup
 		// Authorization will always use the proxy cluster.
 		agg.controllers = append(agg.controllers, m.remoteKubeControllers[clusterID])
-		agg.authController = m.remoteKubeControllers[clusterID]
-	} else {
-		agg.authController = m.remoteKubeControllers[m.localCluster]
 	}
 	agg.controllers = append(agg.controllers, m.remoteKubeControllers[m.localCluster])
 	return agg, nil
 }
 
-func (m *Multicluster) AddEventHandler(f eventHandler) {
-	m.eventHandlers = append(m.eventHandlers, f)
+func (m *Multicluster) AddSecretHandler(h secretHandler) {
+	m.secretHandlers = append(m.secretHandlers, h)
 	for _, c := range m.remoteKubeControllers {
-		c.AddEventHandler(f)
+		c.AddEventHandler(h)
 	}
 }
 
@@ -147,7 +144,5 @@ func (a *AggregateController) Authorize(serviceAccount, namespace string) error
 }
 
 func (a *AggregateController) AddEventHandler(f func(name string, namespace string)) {
-	for _, c := range a.controllers {
-		c.AddEventHandler(f)
-	}
+	// no ops
 }
diff --git a/pilot/pkg/credentials/kube/secrets.go b/pilot/pkg/credentials/kube/secrets.go
index c78a3da1e0..3183e015b7 100644
--- a/pilot/pkg/credentials/kube/secrets.go
+++ b/pilot/pkg/credentials/kube/secrets.go
@@ -39,6 +39,7 @@
 	securitymodel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/pkg/log"
 )
 
@@ -59,8 +60,9 @@
 )
 
 type CredentialsController struct {
-	secrets informersv1.SecretInformer
-	sar     authorizationv1client.SubjectAccessReviewInterface
+	secretInformer cache.SharedIndexInformer
+	secretLister   listersv1.SecretLister
+	sar            authorizationv1client.SubjectAccessReviewInterface
 
 	clusterID cluster.ID
 
@@ -86,8 +88,8 @@ func(options *metav1.ListOptions) {
 				// Because of legacy reasons and supporting an extra ca.crt, we also support generic types.
 				// Its also likely users have started to use random types and expect them to continue working.
 				// This makes the assumption we will never care about Helm secrets or SA token secrets - two common
-				// large Secrets in clusters.
-				// This is a best effort optimization only; the code would behave correctly if we watched all Secrets.
+				// large secrets in clusters.
+				// This is a best effort optimization only; the code would behave correctly if we watched all secrets.
 				options.FieldSelector = fields.AndSelectors(
 					fields.OneTermNotEqualSelector("type", "helm.sh/release.v1"),
 					fields.OneTermNotEqualSelector("type", string(v1.SecretTypeServiceAccountToken)),
@@ -97,7 +99,8 @@ func(options *metav1.ListOptions) {
 	})
 
 	return &CredentialsController{
-		secrets: informerAdapter{listersv1.NewSecretLister(informer.GetIndexer()), informer},
+		secretInformer: informer,
+		secretLister:   listersv1.NewSecretLister(informer.GetIndexer()),
 
 		sar:                client.AuthorizationV1().SubjectAccessReviews(),
 		clusterID:          clusterID,
@@ -168,7 +171,7 @@ func (s *CredentialsController) Authorize(serviceAccount, namespace string) erro
 	if cached, f := s.cachedAuthorization(user); f {
 		return cached
 	}
-	resp := func() error {
+	err := func() error {
 		resp, err := s.sar.Create(context.Background(), &authorizationv1.SubjectAccessReview{
 			ObjectMeta: metav1.ObjectMeta{},
 			Spec: authorizationv1.SubjectAccessReviewSpec{
@@ -188,12 +191,12 @@ func (s *CredentialsController) Authorize(serviceAccount, namespace string) erro
 		}
 		return nil
 	}()
-	s.insertCache(user, resp)
-	return resp
+	s.insertCache(user, err)
+	return err
 }
 
 func (s *CredentialsController) GetKeyAndCert(name, namespace string) (key []byte, cert []byte, err error) {
-	k8sSecret, err := s.secrets.Lister().Secrets(namespace).Get(name)
+	k8sSecret, err := s.secretLister.Secrets(namespace).Get(name)
 	if err != nil {
 		return nil, nil, fmt.Errorf("secret %v/%v not found", namespace, name)
 	}
@@ -203,10 +206,10 @@ func (s *CredentialsController) GetKeyAndCert(name, namespace string) (key []byt
 
 func (s *CredentialsController) GetCaCert(name, namespace string) (cert []byte, err error) {
 	strippedName := strings.TrimSuffix(name, securitymodel.SdsCaSuffix)
-	k8sSecret, err := s.secrets.Lister().Secrets(namespace).Get(name)
+	k8sSecret, err := s.secretLister.Secrets(namespace).Get(name)
 	if err != nil {
 		// Could not fetch cert, look for secret without -cacert suffix
-		k8sSecret, caCertErr := s.secrets.Lister().Secrets(namespace).Get(strippedName)
+		k8sSecret, caCertErr := s.secretLister.Secrets(namespace).Get(strippedName)
 		if caCertErr != nil {
 			return nil, fmt.Errorf("secret %v/%v not found", namespace, strippedName)
 		}
@@ -287,48 +290,9 @@ func extractRoot(scrt *v1.Secret) (cert []byte, err error) {
 		GenericScrtCaCert, TLSSecretCaCert, found)
 }
 
-func (s *CredentialsController) AddEventHandler(f func(name string, namespace string)) {
-	handler := func(obj interface{}) {
-		scrt, ok := obj.(*v1.Secret)
-		if !ok {
-			if tombstone, ok := obj.(cache.DeletedFinalStateUnknown); ok {
-				if cast, ok := tombstone.Obj.(*v1.Secret); ok {
-					scrt = cast
-				} else {
-					log.Errorf("Failed to convert to tombstoned secret object: %v", obj)
-					return
-				}
-			} else {
-				log.Errorf("Failed to convert to secret object: %v", obj)
-				return
-			}
-		}
-		f(scrt.Name, scrt.Namespace)
-	}
-	s.secrets.Informer().AddEventHandler(
-		cache.ResourceEventHandlerFuncs{
-			AddFunc: func(obj interface{}) {
-				handler(obj)
-			},
-			UpdateFunc: func(old, cur interface{}) {
-				handler(cur)
-			},
-			DeleteFunc: func(obj interface{}) {
-				handler(obj)
-			},
-		})
-}
-
-// informerAdapter allows treating a generic informer as an informersv1.SecretInformer
-type informerAdapter struct {
-	listersv1.SecretLister
-	cache.SharedIndexInformer
-}
-
-func (s informerAdapter) Informer() cache.SharedIndexInformer {
-	return s.SharedIndexInformer
-}
-
-func (s informerAdapter) Lister() listersv1.SecretLister {
-	return s.SecretLister
+func (s *CredentialsController) AddEventHandler(h func(name string, namespace string)) {
+	// register handler before informer starts
+	s.secretInformer.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
+		h(o.GetName(), o.GetNamespace())
+	}))
 }
-- 
2.35.3

