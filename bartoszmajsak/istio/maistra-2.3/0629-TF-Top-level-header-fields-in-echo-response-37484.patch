From f781dff9fe952364c37204adadbd29eb341c49e4 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Wed, 23 Feb 2022 14:25:46 -0800
Subject: [TF] Top-level header fields in echo response (#37484)

We currently don't have a way to distinguish between request and response headers when checking echo results. This promotes request and response headers to a top-level field in echo.Response and provides tools for validating headers.
---
 pkg/test/echo/check/checkers.go               |  86 ++++++++++---
 pkg/test/echo/fields.go                       |   9 +-
 pkg/test/echo/parse.go                        |  43 ++++++-
 pkg/test/echo/response.go                     |  70 ++++++-----
 pkg/test/echo/responses.go                    |   4 +
 pkg/test/echo/server/endpoint/grpc.go         |  13 +-
 pkg/test/echo/server/endpoint/http.go         |   8 +-
 pkg/test/echo/server/endpoint/tcp.go          |   1 +
 pkg/test/echo/server/endpoint/util.go         |   5 +
 pkg/test/echo/server/forwarder/http.go        |   2 +-
 tests/integration/pilot/common/routing.go     | 113 +++++++++---------
 tests/integration/pilot/ingress_test.go       |   2 +-
 .../security/authorization_test.go            |  98 +++++++--------
 .../egress_gateway_origination_test.go        |  24 ++--
 .../file_mounted_certs/p2p_mtls_test.go       |   8 +-
 .../egress_gateway_origination_test.go        |   4 +-
 .../security/normalization_test.go            |   2 +-
 .../security/sds_ingress/ingress_test.go      |  32 ++---
 .../security/sds_ingress/util/util.go         |  10 +-
 .../security/util/authn/authn_util.go         |  17 +--
 tests/integration/security/util/cert/cert.go  |   2 +-
 .../security/util/rbac_util/util.go           |  61 +++++-----
 .../telemetry/outboundtrafficpolicy/helper.go |  37 +++---
 .../traffic_allow_any_test.go                 |  49 ++++----
 .../traffic_registry_only_test.go             |  11 +-
 25 files changed, 406 insertions(+), 305 deletions(-)

diff --git a/pkg/test/echo/check/checkers.go b/pkg/test/echo/check/checkers.go
index 718a2bd11e..1118c6986f 100644
--- a/pkg/test/echo/check/checkers.go
+++ b/pkg/test/echo/check/checkers.go
@@ -28,13 +28,6 @@
 	"istio.io/istio/pkg/util/istiomultierror"
 )
 
-// WithInfo adds additional context information to any error returned by the provided Checker.
-func WithInfo(info string, c Checker) Checker {
-	return FilterError(func(err error) error {
-		return fmt.Errorf("%s: %v", info, err)
-	}, c)
-}
-
 // FilterError applies the given filter function to any errors returned by the Checker.
 func FilterError(filter func(error) error, c Checker) Checker {
 	return func(rs echo.Responses, err error) error {
@@ -48,7 +41,7 @@ func FilterError(filter func(error) error, c Checker) Checker {
 // Each applies the given per-response function across all responses.
 func Each(c func(r echo.Response) error) Checker {
 	return func(rs echo.Responses, _ error) error {
-		if rs.Len() == 0 {
+		if rs.IsEmpty() {
 			return fmt.Errorf("no responses received")
 		}
 		outErr := istiomultierror.New()
@@ -82,7 +75,12 @@ func None() Checker {
 
 // NoError is similar to None, but provides additional context information.
 func NoError() Checker {
-	return WithInfo("expected no error, but encountered", None())
+	return func(_ echo.Responses, err error) error {
+		if err != nil {
+			return fmt.Errorf("expected no error, but encountered %v", err)
+		}
+		return nil
+	}
 }
 
 // Error provides a checker that returns an error if the call succeeds.
@@ -150,6 +148,24 @@ func Host(expected string) Checker {
 	})
 }
 
+func Protocol(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.Protocol != expected {
+			return fmt.Errorf("expected protocol %s, received %s", expected, r.Protocol)
+		}
+		return nil
+	})
+}
+
+func Alpn(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.Alpn != expected {
+			return fmt.Errorf("expected alpn %s, received %s", expected, r.Alpn)
+		}
+		return nil
+	})
+}
+
 func MTLSForHTTP() Checker {
 	return Each(func(r echo.Response) error {
 		if !strings.HasPrefix(r.RequestURL, "http://") &&
@@ -158,8 +174,9 @@ func MTLSForHTTP() Checker {
 			// Non-HTTP traffic. Fail open, we cannot check mTLS.
 			return nil
 		}
-		_, f1 := r.RawResponse["X-Forwarded-Client-Cert"]
-		_, f2 := r.RawResponse["x-forwarded-client-cert"] // grpc has different casing
+		_, f1 := r.RequestHeaders["X-Forwarded-Client-Cert"]
+		// nolint: staticcheck
+		_, f2 := r.RequestHeaders["x-forwarded-client-cert"] // grpc has different casing
 		if f1 || f2 {
 			return nil
 		}
@@ -177,12 +194,51 @@ func Port(expected int) Checker {
 	})
 }
 
-func Key(key, expected string) Checker {
+func requestHeader(r echo.Response, key, expected string) error {
+	actual := r.RequestHeaders.Get(key)
+	if actual != expected {
+		return fmt.Errorf("request header %s: expected `%s`, received `%s`", key, expected, actual)
+	}
+	return nil
+}
+
+func responseHeader(r echo.Response, key, expected string) error {
+	actual := r.ResponseHeaders.Get(key)
+	if actual != expected {
+		return fmt.Errorf("response header %s: expected `%s`, received `%s`", key, expected, actual)
+	}
+	return nil
+}
+
+func RequestHeader(key, expected string) Checker {
+	return Each(func(r echo.Response) error {
+		return requestHeader(r, key, expected)
+	})
+}
+
+func ResponseHeader(key, expected string) Checker {
+	return Each(func(r echo.Response) error {
+		return responseHeader(r, key, expected)
+	})
+}
+
+func RequestHeaders(expected map[string]string) Checker {
 	return Each(func(r echo.Response) error {
-		if r.RawResponse[key] != expected {
-			return fmt.Errorf("%s: HTTP code %s, expected %s, received %s", key, r.Code, expected, r.RawResponse[key])
+		outErr := istiomultierror.New()
+		for k, v := range expected {
+			outErr = multierror.Append(outErr, requestHeader(r, k, v))
 		}
-		return nil
+		return outErr.ErrorOrNil()
+	})
+}
+
+func ResponseHeaders(expected map[string]string) Checker {
+	return Each(func(r echo.Response) error {
+		outErr := istiomultierror.New()
+		for k, v := range expected {
+			outErr = multierror.Append(outErr, responseHeader(r, k, v))
+		}
+		return outErr.ErrorOrNil()
 	})
 }
 
diff --git a/pkg/test/echo/fields.go b/pkg/test/echo/fields.go
index 4d8e1ef7f2..3b31f69b13 100644
--- a/pkg/test/echo/fields.go
+++ b/pkg/test/echo/fields.go
@@ -17,6 +17,10 @@
 // Field is a list of fields returned in responses from the Echo server.
 type Field string
 
+func (f Field) String() string {
+	return string(f)
+}
+
 const (
 	RequestIDField      Field = "X-Request-Id"
 	ServiceVersionField Field = "ServiceVersion"
@@ -26,7 +30,10 @@
 	HostField           Field = "Host"
 	HostnameField       Field = "Hostname"
 	MethodField         Field = "Method"
-	ResponseHeader      Field = "ResponseHeader"
+	ProtocolField       Field = "Proto"
+	AlpnField           Field = "Alpn"
+	RequestHeaderField  Field = "RequestHeader"
+	ResponseHeaderField Field = "ResponseHeader"
 	ClusterField        Field = "Cluster"
 	IstioVersionField   Field = "IstioVersion"
 	IPField             Field = "IP" // The Requesterâ€™s IP Address.
diff --git a/pkg/test/echo/parse.go b/pkg/test/echo/parse.go
index 3347a1e81f..61572e172e 100644
--- a/pkg/test/echo/parse.go
+++ b/pkg/test/echo/parse.go
@@ -15,6 +15,7 @@
 package echo
 
 import (
+	"net/http"
 	"regexp"
 	"strings"
 
@@ -28,11 +29,15 @@
 	statusCodeFieldRegex     = regexp.MustCompile(string(StatusCodeField) + "=(.*)")
 	hostFieldRegex           = regexp.MustCompile(string(HostField) + "=(.*)")
 	hostnameFieldRegex       = regexp.MustCompile(string(HostnameField) + "=(.*)")
-	responseHeaderFieldRegex = regexp.MustCompile(string(ResponseHeader) + "=(.*)")
+	requestHeaderFieldRegex  = regexp.MustCompile(string(RequestHeaderField) + "=(.*)")
+	responseHeaderFieldRegex = regexp.MustCompile(string(ResponseHeaderField) + "=(.*)")
 	URLFieldRegex            = regexp.MustCompile(string(URLField) + "=(.*)")
 	ClusterFieldRegex        = regexp.MustCompile(string(ClusterField) + "=(.*)")
 	IstioVersionFieldRegex   = regexp.MustCompile(string(IstioVersionField) + "=(.*)")
 	IPFieldRegex             = regexp.MustCompile(string(IPField) + "=(.*)")
+	methodFieldRegex         = regexp.MustCompile(string(MethodField) + "=(.*)")
+	protocolFieldRegex       = regexp.MustCompile(string(ProtocolField) + "=(.*)")
+	alpnFieldRegex           = regexp.MustCompile(string(AlpnField) + "=(.*)")
 )
 
 func ParseResponses(req *proto.ForwardEchoRequest, resp *proto.ForwardEchoResponse) Responses {
@@ -46,7 +51,9 @@ func ParseResponses(req *proto.ForwardEchoRequest, resp *proto.ForwardEchoRespon
 
 func parseResponse(output string) Response {
 	out := Response{
-		Body: output,
+		RawContent:      output,
+		RequestHeaders:  make(http.Header),
+		ResponseHeaders: make(http.Header),
 	}
 
 	match := requestIDFieldRegex.FindStringSubmatch(output)
@@ -54,6 +61,21 @@ func parseResponse(output string) Response {
 		out.ID = match[1]
 	}
 
+	match = methodFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Method = match[1]
+	}
+
+	match = protocolFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Protocol = match[1]
+	}
+
+	match = alpnFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Alpn = match[1]
+	}
+
 	match = serviceVersionFieldRegex.FindStringSubmatch(output)
 	if match != nil {
 		out.Version = match[1]
@@ -99,15 +121,24 @@ func parseResponse(output string) Response {
 		out.IP = match[1]
 	}
 
-	out.RawResponse = map[string]string{}
+	out.rawBody = map[string]string{}
+
+	matches := requestHeaderFieldRegex.FindAllStringSubmatch(output, -1)
+	for _, kv := range matches {
+		sl := strings.SplitN(kv[1], ":", 2)
+		if len(sl) != 2 {
+			continue
+		}
+		out.RequestHeaders.Set(sl[0], sl[1])
+	}
 
-	matches := responseHeaderFieldRegex.FindAllStringSubmatch(output, -1)
+	matches = responseHeaderFieldRegex.FindAllStringSubmatch(output, -1)
 	for _, kv := range matches {
 		sl := strings.SplitN(kv[1], ":", 2)
 		if len(sl) != 2 {
 			continue
 		}
-		out.RawResponse[sl[0]] = sl[1]
+		out.ResponseHeaders.Set(sl[0], sl[1])
 	}
 
 	for _, l := range strings.Split(output, "\n") {
@@ -119,7 +150,7 @@ func parseResponse(output string) Response {
 		if len(kv) != 2 {
 			continue
 		}
-		out.RawResponse[kv[0]] = kv[1]
+		out.rawBody[kv[0]] = kv[1]
 	}
 
 	return out
diff --git a/pkg/test/echo/response.go b/pkg/test/echo/response.go
index f0504c6586..732e5d0bf4 100644
--- a/pkg/test/echo/response.go
+++ b/pkg/test/echo/response.go
@@ -16,6 +16,7 @@
 
 import (
 	"fmt"
+	"net/http"
 	"sort"
 	"strings"
 )
@@ -25,8 +26,14 @@ type Response struct {
 	// RequestURL is the requested URL. This differs from URL, which is the just the path.
 	// For example, RequestURL=http://foo/bar, URL=/bar
 	RequestURL string
-	// Body is the body of the response
-	Body string
+	// Method used (for HTTP).
+	Method string
+	// Protocol used for the request.
+	Protocol string
+	// Alpn value (for HTTP).
+	Alpn string
+	// RawContent is the original unparsed content for this response
+	RawContent string
 	// ID is a unique identifier of the resource in the response
 	ID string
 	// URL is the url the request is sent to
@@ -47,48 +54,55 @@ type Response struct {
 	IstioVersion string
 	// IP is the requester's ip address
 	IP string
-	// RawResponse gives a map of all values returned in the response (headers, etc)
-	RawResponse map[string]string
+	// rawBody gives a map of all key/values in the body of the response.
+	rawBody         map[string]string
+	RequestHeaders  http.Header
+	ResponseHeaders http.Header
 }
 
 // Count occurrences of the given text within the body of this response.
 func (r Response) Count(text string) int {
-	return strings.Count(r.Body, text)
+	return strings.Count(r.RawContent, text)
 }
 
-// ResponseBody returns the body of the response, in order
-func (r Response) ResponseBody() []string {
-	type kv struct {
+// Body returns the lines of the response body, in order
+func (r Response) Body() []string {
+	type keyValue struct {
 		k, v string
 	}
-	kvs := []kv{}
-	// RawResponse is in random order, so get the order back via sorting.
-	for k, v := range r.RawResponse {
-		kvs = append(kvs, kv{k, v})
+	var keyValues []keyValue
+	// rawBody is in random order, so get the order back via sorting.
+	for k, v := range r.rawBody {
+		keyValues = append(keyValues, keyValue{k, v})
 	}
-	sort.Slice(kvs, func(i, j int) bool {
-		return kvs[i].k < kvs[j].k
+	sort.Slice(keyValues, func(i, j int) bool {
+		return keyValues[i].k < keyValues[j].k
 	})
-	resp := []string{}
-	for _, v := range kvs {
-		resp = append(resp, v.v)
+	var resp []string
+	for _, kv := range keyValues {
+		resp = append(resp, kv.v)
 	}
 	return resp
 }
 
 func (r Response) String() string {
 	out := ""
-	out += fmt.Sprintf("Body:         %s\n", r.Body)
-	out += fmt.Sprintf("ID:           %s\n", r.ID)
-	out += fmt.Sprintf("URL:          %s\n", r.URL)
-	out += fmt.Sprintf("Version:      %s\n", r.Version)
-	out += fmt.Sprintf("Port:         %s\n", r.Port)
-	out += fmt.Sprintf("Code:         %s\n", r.Code)
-	out += fmt.Sprintf("Host:         %s\n", r.Host)
-	out += fmt.Sprintf("Hostname:     %s\n", r.Hostname)
-	out += fmt.Sprintf("Cluster:      %s\n", r.Cluster)
-	out += fmt.Sprintf("IstioVersion: %s\n", r.IstioVersion)
-	out += fmt.Sprintf("IP:           %s\n", r.IP)
+	out += fmt.Sprintf("RawContent:       %s\n", r.RawContent)
+	out += fmt.Sprintf("ID:               %s\n", r.ID)
+	out += fmt.Sprintf("Method:           %s\n", r.Method)
+	out += fmt.Sprintf("Protocol:         %s\n", r.Protocol)
+	out += fmt.Sprintf("Alpn:             %s\n", r.Alpn)
+	out += fmt.Sprintf("URL:              %s\n", r.URL)
+	out += fmt.Sprintf("Version:          %s\n", r.Version)
+	out += fmt.Sprintf("Port:             %s\n", r.Port)
+	out += fmt.Sprintf("Code:             %s\n", r.Code)
+	out += fmt.Sprintf("Host:             %s\n", r.Host)
+	out += fmt.Sprintf("Hostname:         %s\n", r.Hostname)
+	out += fmt.Sprintf("Cluster:          %s\n", r.Cluster)
+	out += fmt.Sprintf("IstioVersion:     %s\n", r.IstioVersion)
+	out += fmt.Sprintf("IP:               %s\n", r.IP)
+	out += fmt.Sprintf("Request Headers:  %v\n", r.RequestHeaders)
+	out += fmt.Sprintf("Response Headers: %v\n", r.ResponseHeaders)
 
 	return out
 }
diff --git a/pkg/test/echo/responses.go b/pkg/test/echo/responses.go
index aafc487047..218681aaa6 100644
--- a/pkg/test/echo/responses.go
+++ b/pkg/test/echo/responses.go
@@ -21,6 +21,10 @@
 // Responses is an ordered list of parsed response objects.
 type Responses []Response
 
+func (r Responses) IsEmpty() bool {
+	return len(r) == 0
+}
+
 // Len returns the length of the parsed responses.
 func (r Responses) Len() int {
 	return len(r)
diff --git a/pkg/test/echo/server/endpoint/grpc.go b/pkg/test/echo/server/endpoint/grpc.go
index a4ef04b7de..70bac4867c 100644
--- a/pkg/test/echo/server/endpoint/grpc.go
+++ b/pkg/test/echo/server/endpoint/grpc.go
@@ -240,14 +240,20 @@ func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.
 	if ok {
 		for key, values := range md {
 			if strings.HasSuffix(key, "-bin") {
+				// Skip binary headers.
 				continue
 			}
-			field := echo.Field(key)
+
+			field := key
+
 			if key == ":authority" {
-				field = echo.HostField
+				for _, value := range values {
+					writeField(&body, echo.HostField, value)
+				}
 			}
+
 			for _, value := range values {
-				writeField(&body, field, value)
+				writeRequestHeader(&body, field, value)
 			}
 		}
 	}
@@ -271,6 +277,7 @@ func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.
 	writeField(&body, echo.ClusterField, h.Cluster)
 	writeField(&body, echo.IPField, ip)
 	writeField(&body, echo.IstioVersionField, h.IstioVersion)
+	writeField(&body, echo.ProtocolField, "GRPC")
 	writeField(&body, "Echo", req.GetMessage())
 
 	if hostname, err := os.Hostname(); err == nil {
diff --git a/pkg/test/echo/server/endpoint/http.go b/pkg/test/echo/server/endpoint/http.go
index 83e82bc236..384e83bd60 100644
--- a/pkg/test/echo/server/endpoint/http.go
+++ b/pkg/test/echo/server/endpoint/http.go
@@ -316,7 +316,7 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	writeField(body, echo.IstioVersionField, h.IstioVersion)
 
 	writeField(body, echo.MethodField, r.Method)
-	writeField(body, "Proto", r.Proto)
+	writeField(body, echo.ProtocolField, r.Proto)
 	ip, _, _ := net.SplitHostPort(r.RemoteAddr)
 	writeField(body, echo.IPField, ip)
 
@@ -326,9 +326,9 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	if r.TLS != nil {
 		alpn = r.TLS.NegotiatedProtocol
 	}
-	writeField(body, "Alpn", alpn)
+	writeField(body, echo.AlpnField, alpn)
 
-	keys := []string{}
+	var keys []string
 	for k := range r.Header {
 		keys = append(keys, k)
 	}
@@ -336,7 +336,7 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	for _, key := range keys {
 		values := r.Header[key]
 		for _, value := range values {
-			writeField(body, echo.Field(key), value)
+			writeRequestHeader(body, key, value)
 		}
 	}
 
diff --git a/pkg/test/echo/server/endpoint/tcp.go b/pkg/test/echo/server/endpoint/tcp.go
index 27486d9240..ec4994acc4 100644
--- a/pkg/test/echo/server/endpoint/tcp.go
+++ b/pkg/test/echo/server/endpoint/tcp.go
@@ -155,6 +155,7 @@ func (s *tcpInstance) writeResponse(conn net.Conn) {
 		echo.ServiceVersionField: s.Version,
 		echo.ServicePortField:    strconv.Itoa(s.Port.Port),
 		echo.IPField:             ip,
+		echo.ProtocolField:       "TCP",
 	}
 	for field, val := range respFields {
 		val := fmt.Sprintf("%s=%s\n", string(field), val)
diff --git a/pkg/test/echo/server/endpoint/util.go b/pkg/test/echo/server/endpoint/util.go
index b0eb7ae1b1..bb008a148c 100644
--- a/pkg/test/echo/server/endpoint/util.go
+++ b/pkg/test/echo/server/endpoint/util.go
@@ -61,3 +61,8 @@ func listenOnUDS(uds string) (net.Listener, error) {
 func writeField(out *bytes.Buffer, field echo.Field, value string) {
 	_, _ = out.WriteString(string(field) + "=" + value + "\n")
 }
+
+// nolint: interfacer
+func writeRequestHeader(out *bytes.Buffer, key, value string) {
+	writeField(out, echo.RequestHeaderField, key+":"+value)
+}
diff --git a/pkg/test/echo/server/forwarder/http.go b/pkg/test/echo/server/forwarder/http.go
index 5494f144e5..c921ec9a90 100644
--- a/pkg/test/echo/server/forwarder/http.go
+++ b/pkg/test/echo/server/forwarder/http.go
@@ -127,7 +127,7 @@ func (c *httpProtocol) makeRequest(ctx context.Context, req *request) (string, e
 	for _, key := range keys {
 		values := httpResp.Header[key]
 		for _, value := range values {
-			outBuffer.WriteString(fmt.Sprintf("[%d] ResponseHeader=%s:%s\n", req.RequestID, key, value))
+			outBuffer.WriteString(fmt.Sprintf("[%d] %s=%s:%s\n", req.RequestID, echo.ResponseHeaderField, key, value))
 		}
 	}
 
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 6e38a98c14..55baecc5bc 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -158,7 +158,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("request header", check.Key("Istio-Custom-Header", "user-defined-value"))),
+					check.RequestHeader("Istio-Custom-Header", "user-defined-value")),
 			},
 			workloadAgnostic: true,
 		},
@@ -185,7 +185,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added request header", check.Key("X-Custom", "some-value"))),
+					check.RequestHeader("X-Custom", "some-value")),
 			},
 			workloadAgnostic: true,
 		},
@@ -212,7 +212,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added authority header", check.Key("Host", "my-custom-authority"))),
+					check.Host("my-custom-authority")),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.10.0",
@@ -240,7 +240,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added request header", check.Key("Host", "my-custom-authority"))),
+					check.Host("my-custom-authority")),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.10.0",
@@ -272,7 +272,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added request header", check.Key("Host", "route-authority"))),
+					check.Host("route-authority")),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -308,7 +308,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added authority header", check.Key("Host", "route-authority"))),
+					check.Host("route-authority")),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -344,7 +344,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("added authority header", check.Key("Host", "dest-authority"))),
+					check.Host("dest-authority")),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -413,7 +413,7 @@ func(r echoClient.Response) error {
 							if err != nil {
 								return err
 							}
-							return ExpectString(r.RawResponse["Location"],
+							return ExpectString(r.ResponseHeaders.Get("Location"),
 								fmt.Sprintf("https://%s:%d/foo", originalHostname.Hostname(), FindPortByName("http").ServicePort),
 								"Location")
 						})),
@@ -474,7 +474,7 @@ func(r echoClient.Response) error {
 				Count:    1,
 				Check: check.And(
 					check.OK(),
-					check.WithInfo("authority", check.Host("new-authority"))),
+					check.Host("new-authority")),
 			},
 			workloadAgnostic: true,
 		},
@@ -520,10 +520,12 @@ func(r echoClient.Response) error {
 							Count:    1,
 							Check: check.And(
 								check.OK(),
-								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Origin", "cors.com")),
-								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Methods", "POST,GET")),
-								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Headers", "X-Foo-Bar,X-Foo-Baz")),
-								check.WithInfo("CORS preflight header", check.Key("Access-Control-Max-Age", "86400"))),
+								check.ResponseHeaders(map[string]string{
+									"Access-Control-Allow-Origin":  "cors.com",
+									"Access-Control-Allow-Methods": "POST,GET",
+									"Access-Control-Allow-Headers": "X-Foo-Bar,X-Foo-Baz",
+									"Access-Control-Max-Age":       "86400",
+								})),
 						}
 					}(),
 				},
@@ -538,7 +540,7 @@ func(r echoClient.Response) error {
 							Count:    1,
 							Check: check.And(
 								check.OK(),
-								check.WithInfo("CORS origin", check.Key("Access-Control-Allow-Origin", "cors.com"))),
+								check.ResponseHeader("Access-Control-Allow-Origin", "cors.com")),
 						}
 					}(),
 				},
@@ -550,7 +552,7 @@ func(r echoClient.Response) error {
 						Count:    1,
 						Check: check.And(
 							check.OK(),
-							check.WithInfo("mismatched CORS origin", check.Key("Access-Control-Allow-Origin", ""))),
+							check.ResponseHeader("Access-Control-Allow-Origin", "")),
 					},
 				},
 			},
@@ -761,7 +763,7 @@ func tlsOriginationCases(apps *EchoDeployments) []TrafficTestCase {
 					Scheme:  scheme.HTTP,
 					Check: check.And(
 						check.OK(),
-						check.Key("Alpn", e.alpn)),
+						check.Alpn(e.alpn)),
 				},
 				call: c.CallWithRetryOrFail,
 			})
@@ -787,7 +789,7 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				HTTP2:    true,
 				Check: check.And(
 					check.OK(),
-					check.Key("Proto", "HTTP/2.0"),
+					check.Protocol("HTTP/2.0"),
 				),
 			},
 			minIstioVersion: "1.10.0",
@@ -803,7 +805,7 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				HTTP2:    false,
 				Check: check.And(
 					check.OK(),
-					check.Key("Proto", "HTTP/1.1"),
+					check.Protocol("HTTP/1.1"),
 				),
 			},
 		},
@@ -837,7 +839,7 @@ func destinationRuleCases(apps *EchoDeployments) []TrafficTestCase {
 
 // trafficLoopCases contains tests to ensure traffic does not loop through the sidecar
 func trafficLoopCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	for _, c := range apps.PodA {
 		for _, d := range apps.PodB {
 			for _, port := range []string{"15001", "15006"} {
@@ -867,7 +869,7 @@ func trafficLoopCases(apps *EchoDeployments) []TrafficTestCase {
 
 // autoPassthroughCases tests that we cannot hit unexpected destinations when using AUTO_PASSTHROUGH
 func autoPassthroughCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	// We test the cross product of all Istio ALPNs (or no ALPN), all mTLS modes, and various backends
 	alpns := []string{"istio", "istio-peer-exchange", "istio-http/1.0", "istio-http/1.1", "istio-h2", ""}
 	modes := []string{"STRICT", "PERMISSIVE", "DISABLE"}
@@ -887,7 +889,7 @@ func autoPassthroughCases(apps *EchoDeployments) []TrafficTestCase {
 		model.BuildDNSSrvSubsetKey(model.TrafficDirectionOutbound, "", nakedHost, httpsAutoPort),
 	}
 	for _, mode := range modes {
-		childs := []TrafficCall{}
+		var childs []TrafficCall
 		for _, sni := range snis {
 			for _, alpn := range alpns {
 				alpn, sni, mode := alpn, sni, mode
@@ -1257,7 +1259,7 @@ func gatewayCases() []TrafficTestCase {
 				},
 				Check: check.And(
 					check.OK(),
-					check.Key("Proto", "HTTP/1.1")),
+					check.Protocol("HTTP/1.1")),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1300,9 +1302,9 @@ func gatewayCases() []TrafficTestCase {
 				Check: check.And(
 					check.OK(),
 					// Gateway doesn't implicitly use downstream
-					check.Key("Proto", "HTTP/1.1"),
-					// Regression test; if this is set it means the inbound sideacr is treating it as TCP
-					check.Key("X-Envoy-Peer-Metadata", "")),
+					check.Protocol("HTTP/1.1"),
+					// Regression test; if this is set it means the inbound sidecar is treating it as TCP
+					check.RequestHeader("X-Envoy-Peer-Metadata", "")),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1357,9 +1359,9 @@ func gatewayCases() []TrafficTestCase {
 						Check: check.And(
 							check.OK(),
 							// We did configure to use client protocol
-							check.Key("Proto", expectedProto),
+							check.Protocol(expectedProto),
 							// Regression test; if this is set it means the inbound sidecar is treating it as TCP
-							check.Key("X-Envoy-Peer-Metadata", "")),
+							check.RequestHeader("X-Envoy-Peer-Metadata", "")),
 					},
 					setupOpts: fqdnHostHeader,
 					templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1413,7 +1415,7 @@ func gatewayCases() []TrafficTestCase {
 					},
 					Check: check.And(
 						check.OK(),
-						check.WithInfo("request header", check.Key("Istio-Custom-Header", "user-defined-value"))),
+						check.RequestHeader("Istio-Custom-Header", "user-defined-value")),
 				},
 				// to keep tests fast, we only run the basic protocol test per-workload and scheme match once (per cluster)
 				targetFilters:    singleTarget,
@@ -1427,7 +1429,7 @@ func gatewayCases() []TrafficTestCase {
 }
 
 func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 
 	destinationSets := []echo.Instances{
 		apps.PodA,
@@ -1455,19 +1457,19 @@ func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
 				},
 				Check: check.Each(
 					func(r echoClient.Response) error {
-						externalAddress, ok := r.RawResponse["X-Envoy-External-Address"]
+						externalAddress, ok := r.RequestHeaders["X-Envoy-External-Address"]
 						if !ok {
 							return fmt.Errorf("missing X-Envoy-External-Address Header")
 						}
-						if err := ExpectString(externalAddress, "72.9.5.6", "envoy-external-address header"); err != nil {
+						if err := ExpectString(externalAddress[0], "72.9.5.6", "envoy-external-address header"); err != nil {
 							return err
 						}
-						xffHeader, ok := r.RawResponse["X-Forwarded-For"]
+						xffHeader, ok := r.RequestHeaders["X-Forwarded-For"]
 						if !ok {
 							return fmt.Errorf("missing X-Forwarded-For Header")
 						}
 
-						xffIPs := strings.Split(xffHeader, ",")
+						xffIPs := strings.Split(xffHeader[0], ",")
 						if len(xffIPs) != 4 {
 							return fmt.Errorf("did not receive expected 4 hosts in X-Forwarded-For header")
 						}
@@ -1481,7 +1483,7 @@ func(r echoClient.Response) error {
 }
 
 func envoyFilterCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	// Test adding envoyfilter to inbound and outbound route/cluster/listeners
 	cfg := `
 apiVersion: networking.istio.io/v1alpha3
@@ -1587,11 +1589,13 @@ function envoy_on_request(request_handle)
 				Target:   apps.PodB[0],
 				Check: check.And(
 					check.OK(),
-					check.Key("X-Vhost-Inbound", "hello world"),
-					check.Key("X-Vhost-Outbound", "hello world"),
-					check.Key("X-Lua-Inbound", "hello world"),
-					check.Key("X-Lua-Outbound", "hello world"),
-					check.Key("Proto", "HTTP/2.0"),
+					check.Protocol("HTTP/2.0"),
+					check.RequestHeaders(map[string]string{
+						"X-Vhost-Inbound":  "hello world",
+						"X-Vhost-Outbound": "hello world",
+						"X-Lua-Inbound":    "hello world",
+						"X-Lua-Outbound":   "hello world",
+					}),
 				),
 			},
 		})
@@ -1601,7 +1605,7 @@ function envoy_on_request(request_handle)
 
 // hostCases tests different forms of host header to use
 func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	for _, c := range apps.PodA {
 		cfg := apps.Headless[0].Config()
 		port := FindPortByName("auto-http").InstancePort
@@ -1686,7 +1690,7 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 //    The cluster is distinct.
 // 4) Another service, B', with P' -> T'. There is no conflicts here at all.
 func serviceCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	for _, c := range apps.PodA {
 		c := c
 
@@ -1810,7 +1814,7 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 
 // consistentHashCases tests destination rule's consistent hashing mechanism
 func consistentHashCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	for _, app := range []echo.Instances{apps.PodA, apps.PodB} {
 		app := app
 		for _, c := range app {
@@ -1954,7 +1958,7 @@ func(responses echoClient.Responses, rerr error) error {
 }
 
 func flatten(clients ...[]echo.Instance) []echo.Instance {
-	instances := []echo.Instance{}
+	var instances []echo.Instance
 	for _, c := range clients {
 		instances = append(instances, c...)
 	}
@@ -1973,7 +1977,7 @@ func selfCallsCases() []TrafficTestCase {
 				PortName: "http",
 				Check: check.And(
 					check.OK(),
-					check.Key("X-Envoy-Attempt-Count", "1")),
+					check.RequestHeader("X-Envoy-Attempt-Count", "1")),
 			},
 		},
 		// Localhost calls will go directly to localhost, bypassing Envoy. No envoy headers added.
@@ -1991,7 +1995,7 @@ func selfCallsCases() []TrafficTestCase {
 				Scheme:  scheme.HTTP,
 				Check: check.And(
 					check.OK(),
-					check.Key("X-Envoy-Attempt-Count", "")),
+					check.RequestHeader("X-Envoy-Attempt-Count", "")),
 			},
 		},
 		// PodIP calls will go directly to podIP, bypassing Envoy. No envoy headers added.
@@ -2011,7 +2015,7 @@ func selfCallsCases() []TrafficTestCase {
 				Port:   &echo.Port{ServicePort: 8080},
 				Check: check.And(
 					check.OK(),
-					check.Key("X-Envoy-Attempt-Count", "")),
+					check.RequestHeader("X-Envoy-Attempt-Count", "")),
 			},
 		},
 	}
@@ -2032,9 +2036,9 @@ func selfCallsCases() []TrafficTestCase {
 	return cases
 }
 
-// Todo merge with security TestReachability code
+// TODO: merge with security TestReachability code
 func protocolSniffingCases(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 
 	type protocolCase struct {
 		// The port we call
@@ -2183,7 +2187,7 @@ type protocolCase struct {
 
 // Todo merge with security TestReachability code
 func instanceIPTests(apps *EchoDeployments) []TrafficTestCase {
-	cases := []TrafficTestCase{}
+	var cases []TrafficTestCase
 	ipCases := []struct {
 		name            string
 		endpoint        string
@@ -2357,7 +2361,7 @@ func DNSTestCases(apps *EchoDeployments, cniEnabled bool) []TrafficTestCase {
     protocol: HTTP
 `, map[string]interface{}{"IPs": ips})
 	}
-	tcases := []TrafficTestCase{}
+	var tcases []TrafficTestCase
 	ipv4 := "1.2.3.4"
 	ipv6 := "1234:1234:1234::1234:1234:1234"
 	dummyLocalhostServer := "127.0.0.1"
@@ -2430,8 +2434,8 @@ func DNSTestCases(apps *EchoDeployments, cniEnabled bool) []TrafficTestCase {
 			}
 			var checker check.Checker = func(responses echoClient.Responses, _ error) error {
 				for _, r := range responses {
-					if !reflect.DeepEqual(r.ResponseBody(), tt.expected) {
-						return fmt.Errorf("unexpected dns response: wanted %v, got %v", tt.expected, r.ResponseBody())
+					if !reflect.DeepEqual(r.Body(), tt.expected) {
+						return fmt.Errorf("unexpected dns response: wanted %v, got %v", tt.expected, r.Body())
 					}
 				}
 				return nil
@@ -2491,10 +2495,7 @@ func DNSTestCases(apps *EchoDeployments, cniEnabled bool) []TrafficTestCase {
 					Address: address,
 					Check: func(responses echoClient.Responses, _ error) error {
 						for _, r := range responses {
-							ips := []string{}
-							for _, v := range r.RawResponse {
-								ips = append(ips, v)
-							}
+							ips := r.Body()
 							sort.Strings(ips)
 							exp := []string{expected}
 							if !reflect.DeepEqual(ips, exp) {
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index 8033c5f0f9..4da44d5cd6 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -226,7 +226,7 @@ func TestGateway(t *testing.T) {
 							Path:     "/path",
 							Check: check.And(
 								check.OK(),
-								check.Key("My-Added-Header", "added-value")),
+								check.RequestHeader("My-Added-Header", "added-value")),
 						})
 					})
 					t.NewSubTest("status").Run(func(t framework.TestContext) {
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index f56102767f..eebf090ff0 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -843,8 +843,8 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 									check.NoError(),
 									check.StatusCode(tc.code),
 									check.Each(func(r echoClient.Response) error {
-										if !strings.Contains(r.Body, tc.body) {
-											return fmt.Errorf("want %q in body but not found: %s", tc.body, responses[0].Body)
+										if !strings.Contains(r.RawContent, tc.body) {
+											return fmt.Errorf("want %q in body but not found: %s", tc.body, responses[0].RawContent)
 										}
 										return nil
 									})).Check(responses, err)
@@ -1449,7 +1449,8 @@ func TestAuthorization_Custom(t *testing.T) {
 				BuildOrFail(t)
 
 			newTestCase := func(from, target echo.Instance, path, port string, header string, expectAllowed bool,
-				expectHTTPResponse []rbacUtil.ExpectContains, scheme scheme.Instance) rbacUtil.TestCase {
+				expectRequestHeaders []rbacUtil.ExpectHeaderContains, expectResponseHeaders []rbacUtil.ExpectHeaderContains,
+				scheme scheme.Instance) rbacUtil.TestCase {
 				return rbacUtil.TestCase{
 					Request: connection.Checker{
 						From: from,
@@ -1464,11 +1465,12 @@ func TestAuthorization_Custom(t *testing.T) {
 						"x-ext-authz":                            header,
 						"x-ext-authz-additional-header-override": "should-be-override",
 					},
-					ExpectAllowed:      expectAllowed,
-					ExpectHTTPResponse: expectHTTPResponse,
+					ExpectAllowed:         expectAllowed,
+					ExpectRequestHeaders:  expectRequestHeaders,
+					ExpectResponseHeaders: expectResponseHeaders,
 				}
 			}
-			expectHTTPResponse := []rbacUtil.ExpectContains{
+			expectHTTPHeaders := []rbacUtil.ExpectHeaderContains{
 				{
 					// For ext authz HTTP server, we expect the check request to include the override value because it
 					// is configued in the ext-authz filter side.
@@ -1482,7 +1484,7 @@ func TestAuthorization_Custom(t *testing.T) {
 					NotValues: []string{"should-be-override"},
 				},
 			}
-			expectGRPCResponse := []rbacUtil.ExpectContains{
+			expectGRPCHeaders := []rbacUtil.ExpectHeaderContains{
 				{
 					// For ext authz gRPC server, we expect the check request to include the original override value
 					// because the override is not configurable in the ext-authz filter side.
@@ -1500,34 +1502,34 @@ func TestAuthorization_Custom(t *testing.T) {
 			// Path "/health" is not protected and is accessible to public.
 			cases := []rbacUtil.TestCase{
 				// workload b is using an ext-authz service in its own pod of HTTP API.
-				newTestCase(x, b, "/custom", "http", "allow", true, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, b, "/custom", "http", "deny", false, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, b, "/health", "http", "allow", true, nil, scheme.HTTP),
-				newTestCase(x, b, "/health", "http", "deny", true, nil, scheme.HTTP),
+				newTestCase(x, b, "/custom", "http", "allow", true, expectHTTPHeaders, nil, scheme.HTTP),
+				newTestCase(x, b, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
+				newTestCase(x, b, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
+				newTestCase(x, b, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
 
 				// workload c is using an ext-authz service in its own pod of gRPC API.
-				newTestCase(x, c, "/custom", "http", "allow", true, expectGRPCResponse, scheme.HTTP),
-				newTestCase(x, c, "/custom", "http", "deny", false, expectGRPCResponse, scheme.HTTP),
-				newTestCase(x, c, "/health", "http", "allow", true, nil, scheme.HTTP),
-				newTestCase(x, c, "/health", "http", "deny", true, nil, scheme.HTTP),
+				newTestCase(x, c, "/custom", "http", "allow", true, expectGRPCHeaders, nil, scheme.HTTP),
+				newTestCase(x, c, "/custom", "http", "deny", false, nil, expectGRPCHeaders, scheme.HTTP),
+				newTestCase(x, c, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
+				newTestCase(x, c, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
 
 				// workload d is using an local ext-authz service in the same pod as the application of HTTP API.
-				newTestCase(x, d, "/custom", "http", "allow", true, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, d, "/custom", "http", "deny", false, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, d, "/health", "http", "allow", true, nil, scheme.HTTP),
-				newTestCase(x, d, "/health", "http", "deny", true, nil, scheme.HTTP),
+				newTestCase(x, d, "/custom", "http", "allow", true, expectHTTPHeaders, nil, scheme.HTTP),
+				newTestCase(x, d, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
+				newTestCase(x, d, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
+				newTestCase(x, d, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
 
 				// workload e is using an local ext-authz service in the same pod as the application of gRPC API.
-				newTestCase(x, e, "/custom", "http", "allow", true, expectGRPCResponse, scheme.HTTP),
-				newTestCase(x, e, "/custom", "http", "deny", false, expectGRPCResponse, scheme.HTTP),
-				newTestCase(x, e, "/health", "http", "allow", true, nil, scheme.HTTP),
-				newTestCase(x, e, "/health", "http", "deny", true, nil, scheme.HTTP),
+				newTestCase(x, e, "/custom", "http", "allow", true, expectGRPCHeaders, nil, scheme.HTTP),
+				newTestCase(x, e, "/custom", "http", "deny", false, nil, expectGRPCHeaders, scheme.HTTP),
+				newTestCase(x, e, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
+				newTestCase(x, e, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
 
 				// workload f is using an ext-authz service in its own pod of TCP API.
-				newTestCase(a, f, "", "tcp-8092", "", true, nil, scheme.TCP),
-				newTestCase(x, f, "", "tcp-8092", "", false, nil, scheme.TCP),
-				newTestCase(a, f, "", "tcp-8093", "", true, nil, scheme.TCP),
-				newTestCase(x, f, "", "tcp-8093", "", true, nil, scheme.TCP),
+				newTestCase(a, f, "", "tcp-8092", "", true, nil, nil, scheme.TCP),
+				newTestCase(x, f, "", "tcp-8092", "", false, nil, nil, scheme.TCP),
+				newTestCase(a, f, "", "tcp-8093", "", true, nil, nil, scheme.TCP),
+				newTestCase(x, f, "", "tcp-8093", "", true, nil, nil, scheme.TCP),
 			}
 
 			rbacUtil.RunRBACTest(t, cases)
@@ -1535,26 +1537,28 @@ func TestAuthorization_Custom(t *testing.T) {
 			ingr := ist.IngressFor(t.Clusters().Default())
 			ingressCases := []rbacUtil.TestCase{
 				// workload g is using an ext-authz service in its own pod of HTTP API.
-				newTestCase(x, g, "/custom", "http", "allow", true, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, g, "/custom", "http", "deny", false, expectHTTPResponse, scheme.HTTP),
-				newTestCase(x, g, "/health", "http", "allow", true, nil, scheme.HTTP),
-				newTestCase(x, g, "/health", "http", "deny", true, nil, scheme.HTTP),
-			}
-			for _, tc := range ingressCases {
-				name := fmt.Sprintf("%s->%s:%s%s[%t]",
-					tc.Request.From.Config().Service,
-					tc.Request.Options.Target.Config().Service,
-					tc.Request.Options.PortName,
-					tc.Request.Options.Path,
-					tc.ExpectAllowed)
-
-				t.NewSubTest(name).Run(func(t framework.TestContext) {
-					wantCode := map[bool]int{true: http.StatusOK, false: http.StatusForbidden}[tc.ExpectAllowed]
-					headers := map[string][]string{
-						"X-Ext-Authz": {tc.Headers["x-ext-authz"]},
-					}
-					authn.CheckIngressOrFail(t, ingr, "www.company.com", tc.Request.Options.Path, headers, "", wantCode)
-				})
+				newTestCase(x, g, "/custom", "http", "allow", true, nil, expectHTTPHeaders, scheme.HTTP),
+				newTestCase(x, g, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
+				newTestCase(x, g, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
+				newTestCase(x, g, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
 			}
+			t.NewSubTest("ingress").Run(func(t framework.TestContext) {
+				for _, tc := range ingressCases {
+					name := fmt.Sprintf("%s->%s:%s%s[%t]",
+						tc.Request.From.Config().Service,
+						tc.Request.Options.Target.Config().Service,
+						tc.Request.Options.PortName,
+						tc.Request.Options.Path,
+						tc.ExpectAllowed)
+
+					t.NewSubTest(name).Run(func(t framework.TestContext) {
+						wantCode := map[bool]int{true: http.StatusOK, false: http.StatusForbidden}[tc.ExpectAllowed]
+						headers := map[string][]string{
+							"X-Ext-Authz": {tc.Headers["x-ext-authz"]},
+						}
+						authn.CheckIngressOrFail(t, ingr, "www.company.com", tc.Request.Options.Path, headers, "", wantCode)
+					})
+				}
+			})
 		})
 }
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 0412fcfffc..7b4e8cfd31 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -75,7 +75,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// This root certificate can validate the server cert presented by the echoboot server instance.
 				{
 					Name:            "simple",
-					Response:        http.StatusOK,
+					StatusCode:      http.StatusOK,
 					CredentialToUse: strings.TrimSuffix(credName, "-cacert"),
 					Gateway:         true,
 				},
@@ -83,7 +83,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// This root certificate cannot validate the server cert presented by the echoboot server instance.
 				{
 					Name:            "fake root",
-					Response:        http.StatusServiceUnavailable,
+					StatusCode:      http.StatusServiceUnavailable,
 					CredentialToUse: strings.TrimSuffix(fakeCredName, "-cacert"),
 					Gateway:         false,
 				},
@@ -92,7 +92,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// Secret fetching error at Gateway, results in a 503 response.
 				{
 					Name:            "missing secret",
-					Response:        http.StatusServiceUnavailable,
+					StatusCode:      http.StatusServiceUnavailable,
 					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
 					Gateway:         false,
 				},
@@ -172,7 +172,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// validate the client cert. Secret is of type generic.
 				{
 					Name:            "generic",
-					Response:        http.StatusOK,
+					StatusCode:      http.StatusOK,
 					CredentialToUse: strings.TrimSuffix(credNameGeneric, "-cacert"),
 					Gateway:         true,
 				},
@@ -181,7 +181,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// validate the client cert. Secret is not of type generic.
 				{
 					Name:            "non-generic",
-					Response:        http.StatusOK,
+					StatusCode:      http.StatusOK,
 					CredentialToUse: strings.TrimSuffix(credNameNotGeneric, "-cacert"),
 					Gateway:         true,
 				},
@@ -190,7 +190,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// cannot validate the client cert. Returns 503 response as TLS handshake fails.
 				{
 					Name:            "invalid client cert",
-					Response:        http.StatusServiceUnavailable,
+					StatusCode:      http.StatusServiceUnavailable,
 					CredentialToUse: strings.TrimSuffix(fakeCredNameA, "-cacert"),
 					Gateway:         false,
 				},
@@ -199,13 +199,13 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// Secret fetching error at Gateway, results in a 503 response.
 				{
 					Name:            "missing",
-					Response:        http.StatusServiceUnavailable,
+					StatusCode:      http.StatusServiceUnavailable,
 					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
 					Gateway:         false,
 				},
 				{
 					Name:            "no client certs",
-					Response:        http.StatusServiceUnavailable,
+					StatusCode:      http.StatusServiceUnavailable,
 					CredentialToUse: strings.TrimSuffix(simpleCredName, "-cacert"),
 					Gateway:         false,
 				},
@@ -351,7 +351,7 @@ func CreateDestinationRule(t framework.TestContext, serverNamespace namespace.In
 
 type TLSTestCase struct {
 	Name            string
-	Response        int
+	StatusCode      int
 	CredentialToUse string
 	Gateway         bool // true if the request is expected to be routed through gateway
 }
@@ -368,10 +368,10 @@ func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions
 		Check: check.And(
 			check.NoError(),
 			check.And(
-				check.StatusCode(tc.Response),
+				check.StatusCode(tc.StatusCode),
 				check.Each(func(r echoClient.Response) error {
-					if _, f := r.RawResponse["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
-						return fmt.Errorf("expected to be handled by gateway. response: %+v", r.RawResponse)
+					if _, f := r.RequestHeaders["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
+						return fmt.Errorf("expected to be handled by gateway. response: %s", r)
 					}
 					return nil
 				}))),
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index f1f5244f03..d570805686 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -75,12 +75,12 @@ func TestClientToServiceTls(t *testing.T) {
 					return fmt.Errorf("got codes %q, expected %q", codes, []string{strconv.Itoa(http.StatusOK)})
 				}
 				for _, r := range resp {
-					if xfcc, f := r.RawResponse["X-Forwarded-Client-Cert"]; f {
-						if xfcc != ExpectedXfccHeader {
-							return fmt.Errorf("XFCC header's value is incorrect. Expected [%s], received [%s]", ExpectedXfccHeader, r.RawResponse)
+					if xfcc, f := r.RequestHeaders["X-Forwarded-Client-Cert"]; f {
+						if xfcc[0] != ExpectedXfccHeader {
+							return fmt.Errorf("XFCC header's value is incorrect. Expected [%s], received [%s]", ExpectedXfccHeader, r)
 						}
 					} else {
-						return fmt.Errorf("expected to see XFCC header, but none found. response: %+v", r.RawResponse)
+						return fmt.Errorf("expected to see XFCC header, but none found. response: %s", r)
 					}
 				}
 				return nil
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index c33cde3cf8..95b842cdcb 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -146,8 +146,8 @@ func TestEgressGatewayTls(t *testing.T) {
 								return fmt.Errorf("got codes %q, expected %q", codes, []string{strconv.Itoa(tc.code)})
 							}
 							for _, r := range resp {
-								if _, f := r.RawResponse["Handled-By-Egress-Gateway"]; tc.gateway && !f {
-									return fmt.Errorf("expected to be handled by gateway. response: %+v", r.RawResponse)
+								if _, f := r.RequestHeaders["Handled-By-Egress-Gateway"]; tc.gateway && !f {
+									return fmt.Errorf("expected to be handled by gateway. response: %s", r)
 								}
 							}
 							return nil
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index d26852c786..d066b39d6e 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -230,7 +230,7 @@ type expect struct {
 					for _, c := range apps.A {
 						for _, tt := range tt.expectations {
 							t.NewSubTest(tt.in).Run(func(t framework.TestContext) {
-								checker := check.Key("URL", tt.out)
+								checker := check.URL(tt.out)
 								if tt.out == "400" {
 									checker = check.StatusCode(http.StatusBadRequest)
 								}
diff --git a/tests/integration/security/sds_ingress/ingress_test.go b/tests/integration/security/sds_ingress/ingress_test.go
index f1bf3b6260..d029183850 100644
--- a/tests/integration/security/sds_ingress/ingress_test.go
+++ b/tests/integration/security/sds_ingress/ingress_test.go
@@ -90,7 +90,7 @@ func TestSingleTlsGateway_SecretRotation(t *testing.T) {
 
 					// Verify the call works
 					ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.TLS, tlsContextA,
-						ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 
 					// Now rotate the key/cert
 					ingressutil.RotateSecrets(t, credName, ingressutil.TLS,
@@ -99,13 +99,13 @@ func TestSingleTlsGateway_SecretRotation(t *testing.T) {
 					t.NewSubTest("old cert should fail").Run(func(t framework.TestContext) {
 						// Client use old server CA cert to set up SSL connection would fail.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.TLS, tlsContextA,
-							ingressutil.ExpectedResponse{ResponseCode: 0, ErrorMessage: "certificate signed by unknown authority"})
+							ingressutil.ExpectedResponse{ErrorMessage: "certificate signed by unknown authority"})
 					})
 
 					t.NewSubTest("new cert should succeed").Run(func(t framework.TestContext) {
 						// Client use new server CA cert to set up SSL connection.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.TLS, tlsContextB,
-							ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+							ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 					})
 				})
 		})
@@ -159,7 +159,7 @@ func TestSingleMTLSGateway_ServerKeyCertRotation(t *testing.T) {
 						Cert:       ingressutil.TLSClientCertA,
 					}
 					ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-						ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 
 					t.NewSubTest("mismatched key/cert should fail").Run(func(t framework.TestContext) {
 						// key/cert rotation using mis-matched server key/cert. The server cert cannot pass validation
@@ -168,7 +168,7 @@ func TestSingleMTLSGateway_ServerKeyCertRotation(t *testing.T) {
 							ingressutil.IngressCredentialServerKeyCertB, false)
 						// Client uses old server CA cert to set up SSL connection would fail.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: 0, ErrorMessage: "certificate signed by unknown authority"})
+							ingressutil.ExpectedResponse{ErrorMessage: "certificate signed by unknown authority"})
 					})
 
 					t.NewSubTest("matched key/cert should succeed").Run(func(t framework.TestContext) {
@@ -178,7 +178,7 @@ func TestSingleMTLSGateway_ServerKeyCertRotation(t *testing.T) {
 							ingressutil.IngressCredentialServerKeyCertA, false)
 						// Use old CA cert to set up SSL connection would succeed this time.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+							ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 					})
 				})
 		})
@@ -223,7 +223,7 @@ func TestSingleMTLSGateway_CompoundSecretRotation(t *testing.T) {
 						Cert:       ingressutil.TLSClientCertA,
 					}
 					ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-						ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 
 					t.NewSubTest("old server CA should fail").Run(func(t framework.TestContext) {
 						// key/cert rotation
@@ -231,7 +231,7 @@ func TestSingleMTLSGateway_CompoundSecretRotation(t *testing.T) {
 							ingressutil.IngressCredentialB, false)
 						// Use old server CA cert to set up SSL connection would fail.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: 0, ErrorMessage: "certificate signed by unknown authority"})
+							ingressutil.ExpectedResponse{ErrorMessage: "certificate signed by unknown authority"})
 					})
 
 					t.NewSubTest("new server CA should succeed").Run(func(t framework.TestContext) {
@@ -242,7 +242,7 @@ func TestSingleMTLSGateway_CompoundSecretRotation(t *testing.T) {
 							Cert:       ingressutil.TLSClientCertB,
 						}
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+							ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 					})
 				})
 		})
@@ -290,7 +290,7 @@ func TestSingleMTLSGatewayAndNotGeneric_CompoundSecretRotation(t *testing.T) {
 						Cert:       ingressutil.TLSClientCertA,
 					}
 					ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-						ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 
 					t.NewSubTest("old server CA should fail").Run(func(t framework.TestContext) {
 						// key/cert rotation
@@ -298,7 +298,7 @@ func TestSingleMTLSGatewayAndNotGeneric_CompoundSecretRotation(t *testing.T) {
 							ingressutil.IngressCredentialB, true)
 						// Use old server CA cert to set up SSL connection would fail.
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: 0, ErrorMessage: "certificate signed by unknown authority"})
+							ingressutil.ExpectedResponse{ErrorMessage: "certificate signed by unknown authority"})
 					})
 
 					t.NewSubTest("new server CA should succeed").Run(func(t framework.TestContext) {
@@ -309,7 +309,7 @@ func TestSingleMTLSGatewayAndNotGeneric_CompoundSecretRotation(t *testing.T) {
 							Cert:       ingressutil.TLSClientCertB,
 						}
 						ingressutil.SendRequestOrFail(t, ing, host, credName, ingressutil.Mtls, tlsContext,
-							ingressutil.ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+							ingressutil.ExpectedResponse{StatusCode: http.StatusOK})
 					})
 				})
 		})
@@ -364,7 +364,6 @@ func TestMultiTlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultitlsgateway-invalidsecret1.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode: 0,
 						// TODO(JimmyCYJ): Temporarily skip verification of error message to deflake test.
 						//  Need a more accurate way to verify the request failures.
 						// https://github.com/istio/istio/issues/16998
@@ -384,7 +383,6 @@ func TestMultiTlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultitlsgateway-invalidsecret2.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.TLS,
@@ -401,7 +399,6 @@ func TestMultiTlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultitlsgateway-invalidsecret3.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.TLS,
@@ -417,7 +414,6 @@ func TestMultiTlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultitlsgateway-invalidsecret4.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.TLS,
@@ -433,7 +429,6 @@ func TestMultiTlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultitlsgateway-invalidsecret5.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.TLS,
@@ -498,7 +493,6 @@ func TestMultiMtlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultimtlsgateway-invalidsecret1.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode: 0,
 						// TODO(JimmyCYJ): Temporarily skip verification of error message to deflake test.
 						//  Need a more accurate way to verify the request failures.
 						// https://github.com/istio/istio/issues/16998
@@ -520,7 +514,6 @@ func TestMultiMtlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultimtlsgateway-invalidsecret2.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.Mtls,
@@ -540,7 +533,6 @@ func TestMultiMtlsGateway_InvalidSecret(t *testing.T) {
 					},
 					hostName: "testmultimtlsgateway-invalidsecret3.example.com",
 					expectedResponse: ingressutil.ExpectedResponse{
-						ResponseCode:                 0,
 						SkipErrorMessageVerification: true,
 					},
 					callType: ingressutil.Mtls,
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index 86ac64db99..aa4c623146 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -257,7 +257,7 @@ func createSecret(ingressType CallType, cn, ns string, ic IngressCredential, isC
 )
 
 type ExpectedResponse struct {
-	ResponseCode                 int
+	StatusCode                   int
 	SkipErrorMessageVerification bool
 	ErrorMessage                 string
 }
@@ -314,7 +314,7 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 				return nil
 			}
 
-			return check.StatusCode(exRsp.ResponseCode).Check(resp, nil)
+			return check.StatusCode(exRsp.StatusCode).Check(resp, nil)
 		},
 	}
 
@@ -523,7 +523,7 @@ func RunTestMultiMtlsGateways(ctx framework.TestContext, inst istio.Instance, ap
 			for _, h := range tests {
 				ctx.NewSubTest(h.Host).Run(func(t framework.TestContext) {
 					SendRequestOrFail(t, ing, h.Host, h.CredentialName, callType, tlsContext,
-						ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ExpectedResponse{StatusCode: http.StatusOK})
 				})
 			}
 		})
@@ -568,7 +568,7 @@ func RunTestMultiTLSGateways(t framework.TestContext, inst istio.Instance, apps
 			for _, h := range tests {
 				t.NewSubTest(h.Host).Run(func(t framework.TestContext) {
 					SendRequestOrFail(t, ing, h.Host, h.CredentialName, callType, tlsContext,
-						ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ExpectedResponse{StatusCode: http.StatusOK})
 				})
 			}
 		})
@@ -623,7 +623,7 @@ func RunTestMultiQUICGateways(ctx framework.TestContext, inst istio.Instance, ca
 			for _, h := range tests {
 				ctx.NewSubTest(h.Host).Run(func(t framework.TestContext) {
 					SendQUICRequestsOrFail(ctx, ing, h.Host, h.CredentialName, callType, tlsContext,
-						ExpectedResponse{ResponseCode: http.StatusOK, ErrorMessage: ""})
+						ExpectedResponse{StatusCode: http.StatusOK})
 				})
 			}
 		})
diff --git a/tests/integration/security/util/authn/authn_util.go b/tests/integration/security/util/authn/authn_util.go
index d3a3222e7c..75d24b3d5a 100644
--- a/tests/integration/security/util/authn/authn_util.go
+++ b/tests/integration/security/util/authn/authn_util.go
@@ -20,7 +20,6 @@
 import (
 	"fmt"
 	"net/http"
-	"strings"
 
 	"istio.io/istio/pkg/config/protocol"
 	echoclient "istio.io/istio/pkg/test/echo"
@@ -54,22 +53,8 @@ func (c *TestCase) String() string {
 func (c *TestCase) CheckAuthn(responses echoclient.Responses, err error) error {
 	return check.And(
 		check.StatusCode(c.ExpectResponseCode),
+		check.RequestHeaders(c.ExpectHeaders),
 		check.Each(func(r echoclient.Response) error {
-			// Checking if echo backend see header with the given value by finding them in response body
-			// (given the current behavior of echo convert all headers into key=value in the response body)
-			for k, v := range c.ExpectHeaders {
-				matcher := fmt.Sprintf("%s=%s", k, v)
-				if len(v) == 0 {
-					if strings.Contains(r.Body, matcher) {
-						return fmt.Errorf("%s: expect header %s does not exist, got response\n%s", c, k, responses[0].Body)
-					}
-				} else {
-					if !strings.Contains(r.Body, matcher) {
-						return fmt.Errorf("%s: expect header %s=%s in body, got response\n%s", c, k, v, responses[0].Body)
-					}
-				}
-			}
-
 			if c.ExpectResponseCode == http.StatusOK && c.DestClusters.IsMulticluster() {
 				return check.ReachedClusters(c.DestClusters).Check(responses, nil)
 			}
diff --git a/tests/integration/security/util/cert/cert.go b/tests/integration/security/util/cert/cert.go
index 20116796fc..6a7ed40a55 100644
--- a/tests/integration/security/util/cert/cert.go
+++ b/tests/integration/security/util/cert/cert.go
@@ -49,7 +49,7 @@ func DumpCertFromSidecar(t test.Failer, from, to echo.Instance, port string) []s
 		t.Fatalf("dump cert failed, no responses")
 	}
 	certs := []string{}
-	for _, rr := range resp[0].ResponseBody() {
+	for _, rr := range resp[0].Body() {
 		var s string
 		if err := json.Unmarshal([]byte(rr), &s); err != nil {
 			t.Fatalf("failed to unmarshal: %v", err)
diff --git a/tests/integration/security/util/rbac_util/util.go b/tests/integration/security/util/rbac_util/util.go
index b576c2230a..555e131701 100644
--- a/tests/integration/security/util/rbac_util/util.go
+++ b/tests/integration/security/util/rbac_util/util.go
@@ -30,21 +30,22 @@
 	"istio.io/istio/tests/integration/security/util/connection"
 )
 
-// ExpectContains specifies the expected value to be found in the HTTP responses. Every value must be found in order to
+// ExpectHeaderContains specifies the expected value to be found in the HTTP header. Every value must be found in order to
 // to make the test pass. Every NotValue must not be found in order to make the test pass.
-type ExpectContains struct {
+type ExpectHeaderContains struct {
 	Key       string
 	Values    []string
 	NotValues []string
 }
 
 type TestCase struct {
-	NamePrefix         string
-	Request            connection.Checker
-	ExpectAllowed      bool
-	ExpectHTTPResponse []ExpectContains
-	Jwt                string
-	Headers            map[string]string
+	NamePrefix            string
+	Request               connection.Checker
+	ExpectAllowed         bool
+	ExpectRequestHeaders  []ExpectHeaderContains
+	ExpectResponseHeaders []ExpectHeaderContains
+	Jwt                   string
+	Headers               map[string]string
 }
 
 func filterError(req connection.Checker, expect string, c check.Checker) check.Checker {
@@ -59,19 +60,21 @@ func filterError(req connection.Checker, expect string, c check.Checker) check.C
 	}, c)
 }
 
-func checkValues(i int, response echo.Response, want []ExpectContains) error {
+func checkValues(i int, response echo.Response, headers http.Header, headerType string, want []ExpectHeaderContains) error {
 	for _, w := range want {
 		key := w.Key
 		for _, value := range w.Values {
-			if !strings.Contains(response.RawResponse[key], value) {
-				return fmt.Errorf("response[%d]: HTTP code %s, want value %s in key %s, but not found in %s",
-					i, response.Code, value, key, response.RawResponse)
+			actual := headers.Get(key)
+			if !strings.Contains(actual, value) {
+				return fmt.Errorf("response[%d]: HTTP code %s, expected %s `%s` to contain `%s`, value=`%s`, raw content=%s",
+					i, response.Code, headerType, key, value, actual, response.RawContent)
 			}
 		}
 		for _, value := range w.NotValues {
-			if strings.Contains(response.RawResponse[key], value) {
-				return fmt.Errorf("response[%d]: HTTP code %s, do not want value %s in key %s, but found in %s",
-					i, response.Code, value, key, response.RawResponse)
+			actual := headers.Get(key)
+			if strings.Contains(actual, value) {
+				return fmt.Errorf("response[%d]: HTTP code %s, expected %s `%s` to not contain `%s`, value=`%s`, raw content=%s",
+					i, response.Code, headerType, key, value, actual, response.RawContent)
 			}
 		}
 	}
@@ -99,18 +102,25 @@ func (tc TestCase) CheckRBACRequest() error {
 
 	resp, err := req.From.Call(tc.Request.Options)
 
+	checkHeaders := func(rs echo.Responses, _ error) error {
+		for i, r := range rs {
+			if err := checkValues(i, r, r.RequestHeaders, "request header", tc.ExpectRequestHeaders); err != nil {
+				return err
+			}
+			if err := checkValues(i, r, r.ResponseHeaders, "response header", tc.ExpectResponseHeaders); err != nil {
+				return err
+			}
+		}
+		return nil
+	}
+
 	if tc.ExpectAllowed {
 		return filterError(req, "allow with code 200",
 			check.And(
 				check.NoError(),
 				check.OK(),
+				checkHeaders,
 				func(rs echo.Responses, _ error) error {
-					for i, r := range rs {
-						if err := checkValues(i, r, tc.ExpectHTTPResponse); err != nil {
-							return err
-						}
-					}
-
 					if req.DestClusters.IsMulticluster() {
 						return check.ReachedClusters(req.DestClusters).Check(rs, err)
 					}
@@ -132,14 +142,7 @@ func(rs echo.Responses, _ error) error {
 		check.And(
 			check.NoError(),
 			check.StatusCode(http.StatusForbidden),
-			func(rs echo.Responses, _ error) error {
-				for i, r := range rs {
-					if err := checkValues(i, r, tc.ExpectHTTPResponse); err != nil {
-						return err
-					}
-				}
-				return nil
-			})).Check(resp, err)
+			checkHeaders)).Check(resp, err)
 }
 
 func RunRBACTest(ctx framework.TestContext, cases []TestCase) {
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index e2f1cd57c4..4689a65b9e 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -21,11 +21,11 @@
 	"fmt"
 	"os"
 	"path"
-	"reflect"
+	"strconv"
 	"testing"
 
 	"istio.io/istio/pkg/config/protocol"
-	echoclient "istio.io/istio/pkg/test/echo"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -40,7 +40,7 @@
 )
 
 const (
-	// This service entry exists to create conflicts on various ports
+	// ServiceEntry is used to create conflicts on various ports
 	// As defined below, the tcp-conflict and https-conflict ports are 9443 and 9091
 	ServiceEntry = `
 apiVersion: networking.istio.io/v1alpha3
@@ -156,10 +156,9 @@ type TestCase struct {
 type Expected struct {
 	Metric          string
 	PromQueryFormat string
-	ResponseCode    []string
-	// Metadata includes headers and additional injected information such as Method, Proto, etc.
-	// The test will validate the returned metadata includes all options specified here
-	Metadata map[string]string
+	StatusCode      int
+	Protocol        string
+	RequestHeaders  map[string]string
 }
 
 // TrafficPolicy is the mode of the outbound traffic policy to use
@@ -259,23 +258,19 @@ func RunExternalRequest(cases []*TestCase, prometheus prometheus.Instance, mode
 							"Host": {tc.Host},
 						},
 						HTTP2: tc.HTTP2,
-						Check: func(resp echoclient.Responses, err error) error {
+						Check: func(rs echoClient.Responses, err error) error {
 							// the expected response from a blackhole test case will have err
 							// set; use the length of the expected code to ignore this condition
-							if err != nil && len(tc.Expected.ResponseCode) != 0 {
+							if err != nil && tc.Expected.StatusCode > 0 {
 								return fmt.Errorf("request failed: %v", err)
 							}
-							codes := make([]string, 0, len(resp))
-							for _, r := range resp {
-								codes = append(codes, r.Code)
-							}
-							if !reflect.DeepEqual(codes, tc.Expected.ResponseCode) {
-								return fmt.Errorf("got codes %q, expected %q", codes, tc.Expected.ResponseCode)
-							}
-
-							for _, r := range resp {
-								for k, v := range tc.Expected.Metadata {
-									if got := r.RawResponse[k]; got != v {
+							codeStr := strconv.Itoa(tc.Expected.StatusCode)
+							for i, r := range rs {
+								if codeStr != r.Code {
+									return fmt.Errorf("response[%d] received status code %s, expected %d", i, r.Code, tc.Expected.StatusCode)
+								}
+								for k, v := range tc.Expected.RequestHeaders {
+									if got := r.RequestHeaders.Get(k); got != v {
 										return fmt.Errorf("expected metadata %v=%v, got %q", k, v, got)
 									}
 								}
@@ -363,7 +358,7 @@ func setupEcho(t *testing.T, ctx resource.Context, mode TrafficPolicy) (echo.Ins
 		t.Errorf("failed to apply service entries: %v", err)
 	}
 
-	if _, kube := ctx.Environment().(*kube.Environment); kube {
+	if _, isKube := ctx.Environment().(*kube.Environment); isKube {
 		createGateway(t, ctx, appsNamespace, serviceNamespace)
 	}
 	return client, dest
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/traffic_allow_any_test.go b/tests/integration/telemetry/outboundtrafficpolicy/traffic_allow_any_test.go
index 52db7bdecf..35342c5cd8 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/traffic_allow_any_test.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/traffic_allow_any_test.go
@@ -18,6 +18,7 @@
 package outboundtrafficpolicy
 
 import (
+	"net/http"
 	"testing"
 )
 
@@ -29,8 +30,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{reporter="source",destination_service_name="PassthroughCluster",response_code="200"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/1.1"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/1.1",
 			},
 		},
 		{
@@ -40,8 +41,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{reporter="source",destination_service_name="PassthroughCluster",response_code="200"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/2.0"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/2.0",
 			},
 		},
 		{
@@ -50,8 +51,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_opened_total",
 				PromQueryFormat: `sum(istio_tcp_connections_opened_total{reporter="source",destination_service_name="PassthroughCluster"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/1.1"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/1.1",
 			},
 		},
 		{
@@ -60,8 +61,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_opened_total",
 				PromQueryFormat: `sum(istio_tcp_connections_opened_total{reporter="source",destination_service_name="PassthroughCluster"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/1.1"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/1.1",
 			},
 		},
 		{
@@ -71,8 +72,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_opened_total",
 				PromQueryFormat: `sum(istio_tcp_connections_opened_total{reporter="source",destination_service_name="PassthroughCluster"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/2.0"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/2.0",
 			},
 		},
 		{
@@ -82,8 +83,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_opened_total",
 				PromQueryFormat: `sum(istio_tcp_connections_opened_total{reporter="source",destination_service_name="PassthroughCluster"})`,
-				ResponseCode:    []string{"200"},
-				Metadata:        map[string]string{"Proto": "HTTP/2.0"},
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/2.0",
 			},
 		},
 		{
@@ -93,8 +94,9 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{reporter="source",destination_service_name="istio-egressgateway",response_code="200"})`, // nolint: lll
-				ResponseCode:    []string{"200"},
-				Metadata: map[string]string{
+				StatusCode:      http.StatusOK,
+				Protocol:        "HTTP/1.1",
+				RequestHeaders: map[string]string{
 					// We inject this header in the VirtualService
 					"Handled-By-Egress-Gateway": "true",
 				},
@@ -108,13 +110,12 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{reporter="source",destination_service_name="istio-egressgateway",response_code="200"})`, // nolint: lll
-				ResponseCode:    []string{"200"},
-				Metadata: map[string]string{
+				StatusCode:      http.StatusOK,
+				// Even though we send h2 to the gateway, the gateway should send h1, as configured by the ServiceEntry
+				Protocol: "HTTP/1.1",
+				RequestHeaders: map[string]string{
 					// We inject this header in the VirtualService
 					"Handled-By-Egress-Gateway": "true",
-					// Even though we send h2 to the gateway, the gateway should send h1, as configured by the ServiceEntry
-					"Proto": "HTTP/1.1",
-					//"Proto": "HTTP/2.0",
 				},
 			},
 		},
@@ -126,9 +127,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 				// TODO(https://github.com/istio/istio/issues/22717) re-enable TCP
 				// Metric:          "istio_tcp_connections_closed_total",
 				// PromQueryFormat: `sum(istio_tcp_connections_closed_total{reporter="source",destination_service_name="PassthroughCluster",source_workload="client-v1"})`,
-				ResponseCode: []string{"200"},
-				// TCP will add StatusCode field. We don't really have a better way to identify as TCP
-				Metadata: map[string]string{"StatusCode": "200"},
+				StatusCode: http.StatusOK,
+				Protocol:   "TCP",
 			},
 		},
 		{
@@ -138,9 +138,8 @@ func TestOutboundTrafficPolicy_AllowAny(t *testing.T) {
 				// TODO(https://github.com/istio/istio/issues/22717) re-enable TCP
 				// Metric:          "istio_tcp_connections_closed_total",
 				// PromQueryFormat: `sum(istio_tcp_connections_closed_total{reporter="source",destination_service_name="PassthroughCluster",source_workload="client-v1"})`,
-				ResponseCode: []string{"200"},
-				// TCP will add StatusCode field. We don't really have a better way to identify as TCP
-				Metadata: map[string]string{"StatusCode": "200"},
+				StatusCode: http.StatusOK,
+				Protocol:   "TCP",
 			},
 		},
 	}
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/traffic_registry_only_test.go b/tests/integration/telemetry/outboundtrafficpolicy/traffic_registry_only_test.go
index 52321029eb..b222cd9ef6 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/traffic_registry_only_test.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/traffic_registry_only_test.go
@@ -18,6 +18,7 @@
 package outboundtrafficpolicy
 
 import (
+	"net/http"
 	"testing"
 )
 
@@ -29,7 +30,7 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{destination_service_name="BlackHoleCluster",response_code="502"})`,
-				ResponseCode:    []string{"502"},
+				StatusCode:      http.StatusBadGateway,
 			},
 		},
 		{
@@ -38,7 +39,6 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_closed_total",
 				PromQueryFormat: `sum(istio_tcp_connections_closed_total{destination_service_name="BlackHoleCluster"})`,
-				ResponseCode:    []string{},
 			},
 		},
 		{
@@ -47,7 +47,6 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_closed_total",
 				PromQueryFormat: `sum(istio_tcp_connections_closed_total{destination_service_name="BlackHoleCluster"})`,
-				ResponseCode:    []string{},
 			},
 		},
 		{
@@ -57,8 +56,8 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_requests_total",
 				PromQueryFormat: `sum(istio_requests_total{destination_service_name="istio-egressgateway",response_code="200"})`,
-				ResponseCode:    []string{"200"},
-				Metadata: map[string]string{
+				StatusCode:      http.StatusOK,
+				RequestHeaders: map[string]string{
 					// We inject this header in the VirtualService
 					"Handled-By-Egress-Gateway": "true",
 				},
@@ -71,7 +70,6 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_closed_total",
 				PromQueryFormat: `sum(istio_tcp_connections_closed_total{reporter="source",destination_service_name="BlackHoleCluster",source_workload="client-v1"})`,
-				ResponseCode:    []string{},
 			},
 		},
 		{
@@ -80,7 +78,6 @@ func TestOutboundTrafficPolicy_RegistryOnly(t *testing.T) {
 			Expected: Expected{
 				Metric:          "istio_tcp_connections_closed_total",
 				PromQueryFormat: `sum(istio_tcp_connections_closed_total{reporter="source",destination_service_name="BlackHoleCluster",source_workload="client-v1"})`,
-				ResponseCode:    []string{},
 			},
 		},
 	}
-- 
2.35.3

