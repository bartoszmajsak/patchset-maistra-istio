From 73ede26f7449e06bcc883fcbd003ee6cde25a207 Mon Sep 17 00:00:00 2001
From: Yaroslav Skopets <yaroslav@tetrate.io>
Date: Thu, 10 Feb 2022 13:29:39 +0100
Subject: vm support: support multiple WorkloadEntry(s) with the same IP
 (#37129)

* vm support: support multiple WorkloadEntry(s) with the same IP

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* add unit tests

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* fix linting issues

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* refactoring: move `workloadinstances` package

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* apply similar changes to `serviceregistry/serviceentry`

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* fix lint issues

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* refactor out `serviceregistry/serviceentry` changes into a separate PR

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* refactor out `serviceregistry/serviceentry` changes into a separate PR

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* fix unit tests

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* add more unit tests

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* code review: avoid creating a new set

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* code review: introduce `fx.WaitOrFail()` and `fx.WaitForDurationOrFail()`

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>
---
 .../kube/controller/controller.go             |  49 +--
 .../kube/controller/controller_test.go        | 294 +++++++++++++++++-
 .../serviceregistry/kube/controller/fake.go   |  13 +
 .../util/workloadinstances/index.go           | 140 +++++++++
 .../util/workloadinstances/index_test.go      | 134 ++++++++
 .../util/workloadinstances/map.go             |  44 +++
 .../util/workloadinstances/util.go            |  87 ++++++
 pilot/pkg/util/slices/string.go               |  26 ++
 8 files changed, 746 insertions(+), 41 deletions(-)
 create mode 100644 pilot/pkg/serviceregistry/util/workloadinstances/index.go
 create mode 100644 pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
 create mode 100644 pilot/pkg/serviceregistry/util/workloadinstances/map.go
 create mode 100644 pilot/pkg/serviceregistry/util/workloadinstances/util.go
 create mode 100644 pilot/pkg/util/slices/string.go

diff --git a/pilot/pkg/serviceregistry/kube/controller/controller.go b/pilot/pkg/serviceregistry/kube/controller/controller.go
index 180bfef34b..0fcf8c8a11 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller.go
@@ -38,6 +38,7 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/kube"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller/filter"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pilot/pkg/serviceregistry/util/workloadinstances"
 	"istio.io/istio/pilot/pkg/util/informermetric"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/host"
@@ -274,10 +275,8 @@ type Controller struct {
 	nodeInfoMap map[string]kubernetesNode
 	// externalNameSvcInstanceMap stores hostname ==> instance, is used to store instances for ExternalName k8s services
 	externalNameSvcInstanceMap map[host.Name][]*model.ServiceInstance
-	// workload instances from workload entries  - map of ip -> workload instance
-	workloadInstancesByIP map[string]*model.WorkloadInstance
-	// Stores a map of workload instance name/namespace to address
-	workloadInstancesIPsByName map[string]string
+	// index over workload instances from workload entries
+	workloadInstancesIndex workloadinstances.Index
 
 	multinetwork
 	// informerInit is set to true once the controller is running successfully. This ensures we do not
@@ -300,8 +299,7 @@ func NewController(kubeClient kubelib.Client, options Options) *Controller {
 		nodeSelectorsForServices:   make(map[host.Name]labels.Instance),
 		nodeInfoMap:                make(map[string]kubernetesNode),
 		externalNameSvcInstanceMap: make(map[host.Name][]*model.ServiceInstance),
-		workloadInstancesByIP:      make(map[string]*model.WorkloadInstance),
-		workloadInstancesIPsByName: make(map[string]string),
+		workloadInstancesIndex:     workloadinstances.NewIndex(),
 		informerInit:               atomic.NewBool(false),
 		beginSync:                  atomic.NewBool(false),
 		initialSync:                atomic.NewBool(false),
@@ -951,9 +949,8 @@ func (c *Controller) serviceInstancesFromWorkloadInstances(svc *model.Service, r
 	// only if this is a kubernetes internal service and of ClientSideLB (eds) type
 	// as InstancesByPort is called by the aggregate controller. We dont want to include
 	// workload instances for any other registry
-	var workloadInstancesExist bool
+	workloadInstancesExist := !c.workloadInstancesIndex.Empty()
 	c.RLock()
-	workloadInstancesExist = len(c.workloadInstancesByIP) > 0
 	_, inRegistry := c.servicesMap[svc.Hostname]
 	c.RUnlock()
 
@@ -993,10 +990,9 @@ func (c *Controller) serviceInstancesFromWorkloadInstances(svc *model.Service, r
 
 	out := make([]*model.ServiceInstance, 0)
 
-	c.RLock()
-	for _, wi := range c.workloadInstancesByIP {
+	c.workloadInstancesIndex.ForEach(func(wi *model.WorkloadInstance) {
 		if wi.Namespace != svc.Attributes.Namespace {
-			continue
+			return
 		}
 		if selector.SubsetOf(wi.Endpoint.Labels) {
 			instance := serviceInstanceFromWorkloadInstance(svc, servicePort, targetPort, wi)
@@ -1004,8 +1000,7 @@ func (c *Controller) serviceInstancesFromWorkloadInstances(svc *model.Service, r
 				out = append(out, instance)
 			}
 		}
-	}
-	c.RUnlock()
+	})
 	return out
 }
 
@@ -1038,10 +1033,7 @@ func serviceInstanceFromWorkloadInstance(svc *model.Service, servicePort *model.
 
 // convenience function to collect all workload entry endpoints in updateEDS calls.
 func (c *Controller) collectWorkloadInstanceEndpoints(svc *model.Service) []*model.IstioEndpoint {
-	var workloadInstancesExist bool
-	c.RLock()
-	workloadInstancesExist = len(c.workloadInstancesByIP) > 0
-	c.RUnlock()
+	workloadInstancesExist := !c.workloadInstancesIndex.Empty()
 
 	if !workloadInstancesExist || svc.Resolution != model.ClientSideLB || len(svc.Ports) == 0 {
 		return nil
@@ -1063,10 +1055,10 @@ func (c *Controller) collectWorkloadInstanceEndpoints(svc *model.Service) []*mod
 func (c *Controller) GetProxyServiceInstances(proxy *model.Proxy) []*model.ServiceInstance {
 	if len(proxy.IPAddresses) > 0 {
 		proxyIP := proxy.IPAddresses[0]
-		c.RLock()
-		workload, f := c.workloadInstancesByIP[proxyIP]
-		c.RUnlock()
-		if f {
+		// look up for a WorkloadEntry; if there are multiple WorkloadEntry(s)
+		// with the same IP, choose one deterministically
+		workload := workloadinstances.GetInstanceForProxy(c.workloadInstancesIndex, proxy, proxyIP)
+		if workload != nil {
 			return c.serviceInstancesFromWorkloadInstance(workload)
 		}
 		pod := c.pods.getPodByProxy(proxy)
@@ -1159,23 +1151,14 @@ func (c *Controller) WorkloadInstanceHandler(si *model.WorkloadInstance, event m
 		return
 	}
 
-	// this is from a workload entry. Store it in separate map so that
+	// this is from a workload entry. Store it in separate index so that
 	// the InstancesByPort can use these as well as the k8s pods.
-	c.Lock()
 	switch event {
 	case model.EventDelete:
-		delete(c.workloadInstancesByIP, si.Endpoint.Address)
+		c.workloadInstancesIndex.Delete(si)
 	default: // add or update
-		// Check to see if the workload entry changed. If it did, clear the old entry
-		k := si.Namespace + "/" + si.Name
-		existing := c.workloadInstancesIPsByName[k]
-		if existing != si.Endpoint.Address {
-			delete(c.workloadInstancesByIP, existing)
-		}
-		c.workloadInstancesByIP[si.Endpoint.Address] = si
-		c.workloadInstancesIPsByName[k] = si.Endpoint.Address
+		c.workloadInstancesIndex.Insert(si)
 	}
-	c.Unlock()
 
 	// find the workload entry's service by label selector
 	// rather than scanning through our internal map of model.services, get the services via the k8s apis
diff --git a/pilot/pkg/serviceregistry/kube/controller/controller_test.go b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
index 5240efc272..d44595db16 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller_test.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
@@ -17,8 +17,10 @@
 import (
 	"context"
 	"fmt"
+	"net"
 	"reflect"
 	"sort"
+	"strconv"
 	"sync"
 	"testing"
 	"time"
@@ -847,16 +849,48 @@ func TestGetProxyServiceInstances_WorkloadInstance(t *testing.T) {
 	cache.WaitForCacheSync(ctl.stop, ctl.HasSynced)
 	defer ctl.Stop()
 
+	createService(ctl, "ratings", "bookinfo-ratings",
+		map[string]string{
+			annotation.AlphaKubernetesServiceAccounts.Name: "ratings",
+			annotation.AlphaCanonicalServiceAccounts.Name:  "ratings@gserviceaccount2.com",
+		},
+		[]int32{8080}, map[string]string{"app": "ratings"}, t)
+	fx.WaitOrFail(t, "service")
+
+	createService(ctl, "details", "bookinfo-details",
+		map[string]string{
+			annotation.AlphaKubernetesServiceAccounts.Name: "details",
+			annotation.AlphaCanonicalServiceAccounts.Name:  "details@gserviceaccount2.com",
+		},
+		[]int32{9090}, map[string]string{"app": "details"}, t)
+	fx.WaitOrFail(t, "service")
+
 	createService(ctl, "reviews", "bookinfo-reviews",
 		map[string]string{
 			annotation.AlphaKubernetesServiceAccounts.Name: "reviews",
 			annotation.AlphaCanonicalServiceAccounts.Name:  "reviews@gserviceaccount2.com",
 		},
 		[]int32{7070}, map[string]string{"app": "reviews"}, t)
+	fx.WaitOrFail(t, "service")
 
-	ev := fx.Wait("service")
-	if ev == nil {
-		t.Fatal("Timeout creating service")
+	wiRatings1 := &model.WorkloadInstance{
+		Name:      "ratings-1",
+		Namespace: "bookinfo-ratings",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "ratings"},
+			Address:      "2.2.2.21",
+			EndpointPort: 8080,
+		},
+	}
+
+	wiDetails1 := &model.WorkloadInstance{
+		Name:      "details-1",
+		Namespace: "bookinfo-details",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "details"},
+			Address:      "2.2.2.21",
+			EndpointPort: 9090,
+		},
 	}
 
 	wiReviews1 := &model.WorkloadInstance{
@@ -889,7 +923,7 @@ func TestGetProxyServiceInstances_WorkloadInstance(t *testing.T) {
 		},
 	}
 
-	for _, wi := range []*model.WorkloadInstance{wiReviews1, wiReviews2, wiProduct1} {
+	for _, wi := range []*model.WorkloadInstance{wiRatings1, wiDetails1, wiReviews1, wiReviews2, wiProduct1} {
 		ctl.WorkloadInstanceHandler(wi, model.EventAdd) // simulate adding a workload entry
 	}
 
@@ -916,7 +950,6 @@ func TestGetProxyServiceInstances_WorkloadInstance(t *testing.T) {
 		{
 			name:  "proxy with IP from the registry, 1 matching WE, and matching Service",
 			proxy: &model.Proxy{Metadata: &model.NodeMetadata{}, IPAddresses: []string{"3.3.3.31"}},
-			// should return only "reviews-1" rather than all instances of the "reviews" service
 			want: []*model.ServiceInstance{{
 				Service: &model.Service{
 					Hostname: "reviews.bookinfo-reviews.svc.company.com",
@@ -929,6 +962,93 @@ func TestGetProxyServiceInstances_WorkloadInstance(t *testing.T) {
 				},
 			}},
 		},
+		{
+			name:  "proxy with IP from the registry, 2 matching WE, and matching Service",
+			proxy: &model.Proxy{Metadata: &model.NodeMetadata{}, IPAddresses: []string{"2.2.2.21"}},
+			want: []*model.ServiceInstance{{
+				Service: &model.Service{
+					Hostname: "details.bookinfo-details.svc.company.com",
+				},
+				Endpoint: &model.IstioEndpoint{
+					Labels:          map[string]string{"app": "details"}, // should pick "details" because of ordering
+					Address:         "2.2.2.21",
+					ServicePortName: "tcp-port",
+					EndpointPort:    9090,
+				},
+			}},
+		},
+		{
+			name: "proxy with IP from the registry, 2 matching WE, and matching Service, and proxy ID equal to WE with a different address",
+			proxy: &model.Proxy{
+				Metadata: &model.NodeMetadata{}, IPAddresses: []string{"2.2.2.21"},
+				ID: "reviews-1.bookinfo-reviews", ConfigNamespace: "bookinfo-reviews",
+			},
+			want: []*model.ServiceInstance{{
+				Service: &model.Service{
+					Hostname: "details.bookinfo-details.svc.company.com",
+				},
+				Endpoint: &model.IstioEndpoint{
+					Labels:          map[string]string{"app": "details"}, // should pick "details" because of ordering
+					Address:         "2.2.2.21",
+					ServicePortName: "tcp-port",
+					EndpointPort:    9090,
+				},
+			}},
+		},
+		{
+			name: "proxy with IP from the registry, 2 matching WE, and matching Service, and proxy ID equal to WE name, but proxy.ID != proxy.ConfigNamespace",
+			proxy: &model.Proxy{
+				Metadata: &model.NodeMetadata{}, IPAddresses: []string{"2.2.2.21"},
+				ID: "ratings-1.bookinfo-ratings", ConfigNamespace: "wrong-namespace",
+			},
+			want: []*model.ServiceInstance{{
+				Service: &model.Service{
+					Hostname: "details.bookinfo-details.svc.company.com",
+				},
+				Endpoint: &model.IstioEndpoint{
+					Labels:          map[string]string{"app": "details"}, // should pick "details" because of ordering
+					Address:         "2.2.2.21",
+					ServicePortName: "tcp-port",
+					EndpointPort:    9090,
+				},
+			}},
+		},
+		{
+			name: "proxy with IP from the registry, 2 matching WE, and matching Service, and proxy.ID == WE name",
+			proxy: &model.Proxy{
+				Metadata: &model.NodeMetadata{}, IPAddresses: []string{"2.2.2.21"},
+				ID: "ratings-1.bookinfo-ratings", ConfigNamespace: "bookinfo-ratings",
+			},
+			want: []*model.ServiceInstance{{
+				Service: &model.Service{
+					Hostname: "ratings.bookinfo-ratings.svc.company.com",
+				},
+				Endpoint: &model.IstioEndpoint{
+					Labels:          map[string]string{"app": "ratings"}, // should pick "ratings"
+					Address:         "2.2.2.21",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+			}},
+		},
+		{
+			name: "proxy with IP from the registry, 2 matching WE, and matching Service, and proxy.ID != WE name, but proxy.ConfigNamespace == WE namespace",
+			proxy: &model.Proxy{
+				Metadata: &model.NodeMetadata{}, IPAddresses: []string{"2.2.2.21"},
+				ID: "wrong-name.bookinfo-ratings", ConfigNamespace: "bookinfo-ratings",
+			},
+			want: []*model.ServiceInstance{{
+				Service: &model.Service{
+					Hostname: "ratings.bookinfo-ratings.svc.company.com",
+				},
+				Endpoint: &model.IstioEndpoint{
+					Labels:          map[string]string{"app": "ratings"}, // should pick "ratings"
+					Address:         "2.2.2.21",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+			}},
+		},
 	}
 
 	for _, tc := range cases {
@@ -936,15 +1056,15 @@ func TestGetProxyServiceInstances_WorkloadInstance(t *testing.T) {
 			got := ctl.GetProxyServiceInstances(tc.proxy)
 
 			if diff := cmp.Diff(len(tc.want), len(got)); diff != "" {
-				t.Fatalf("GetProxyServiceInstances() returned unexpected number of service instances: %v", diff)
+				t.Fatalf("GetProxyServiceInstances() returned unexpected number of service instances (--want/++got): %v", diff)
 			}
 
 			for i := range tc.want {
 				if diff := cmp.Diff(tc.want[i].Service.Hostname, got[i].Service.Hostname); diff != "" {
-					t.Fatalf("GetProxyServiceInstances() returned unexpected value [%d].Service.Hostname: %v", i, diff)
+					t.Fatalf("GetProxyServiceInstances() returned unexpected value [%d].Service.Hostname (--want/++got): %v", i, diff)
 				}
 				if diff := cmp.Diff(tc.want[i].Endpoint, got[i].Endpoint); diff != "" {
-					t.Fatalf("GetProxyServiceInstances() returned unexpected value [%d].Endpoint: %v", i, diff)
+					t.Fatalf("GetProxyServiceInstances() returned unexpected value [%d].Endpoint (--want/++got): %v", i, diff)
 				}
 			}
 		})
@@ -1477,6 +1597,91 @@ func TestController_ServiceWithChangingDiscoveryNamespaces(t *testing.T) {
 	}
 }
 
+func TestInstancesByPort_WorkloadInstances(t *testing.T) {
+	ctl, fx := NewFakeControllerWithOptions(FakeControllerOptions{})
+	go ctl.Run(ctl.stop)
+	// Wait for the caches to sync, otherwise we may hit race conditions where events are dropped
+	cache.WaitForCacheSync(ctl.stop, ctl.HasSynced)
+	defer ctl.Stop()
+
+	createServiceWithTargetPorts(ctl, "ratings", "bookinfo-ratings",
+		map[string]string{
+			annotation.AlphaKubernetesServiceAccounts.Name: "ratings",
+			annotation.AlphaCanonicalServiceAccounts.Name:  "ratings@gserviceaccount2.com",
+		},
+		[]coreV1.ServicePort{
+			{
+				Name:       "http-port",
+				Port:       8080,
+				Protocol:   "TCP",
+				TargetPort: intstr.IntOrString{Type: intstr.String, StrVal: "http"},
+			},
+		},
+		map[string]string{"app": "ratings"}, t)
+	fx.WaitOrFail(t, "service")
+
+	wiRatings1 := &model.WorkloadInstance{
+		Name:      "ratings-1",
+		Namespace: "bookinfo-ratings",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "ratings"},
+			Address:      "2.2.2.2",
+			EndpointPort: 8081, // should be ignored since it doesn't define PortMap
+		},
+	}
+
+	wiRatings2 := &model.WorkloadInstance{
+		Name:      "ratings-2",
+		Namespace: "bookinfo-ratings",
+		Endpoint: &model.IstioEndpoint{
+			Labels:  labels.Instance{"app": "ratings"},
+			Address: "2.2.2.2",
+		},
+		PortMap: map[string]uint32{
+			"http": 8082, // should be used
+		},
+	}
+
+	wiRatings3 := &model.WorkloadInstance{
+		Name:      "ratings-3",
+		Namespace: "bookinfo-ratings",
+		Endpoint: &model.IstioEndpoint{
+			Labels:  labels.Instance{"app": "ratings"},
+			Address: "2.2.2.2",
+		},
+		PortMap: map[string]uint32{
+			"http": 8083, // should be used
+		},
+	}
+
+	for _, wi := range []*model.WorkloadInstance{wiRatings1, wiRatings2, wiRatings3} {
+		ctl.WorkloadInstanceHandler(wi, model.EventAdd) // simulate adding a workload entry
+	}
+
+	// get service object
+
+	svcs, err := ctl.Services()
+	if err != nil || len(svcs) != 1 {
+		t.Fatalf("failed to get services (%v): %v", svcs, err)
+	}
+
+	// get service instances
+
+	instances := ctl.InstancesByPort(svcs[0], 8080, labels.Collection{})
+
+	want := []string{"2.2.2.2:8082", "2.2.2.2:8083"} // expect both WorkloadEntries even though they have the same IP
+
+	var got []string
+	for _, instance := range instances {
+		got = append(got, net.JoinHostPort(instance.Endpoint.Address, strconv.Itoa(int(instance.Endpoint.EndpointPort))))
+	}
+	sort.Strings(got)
+
+	if diff := cmp.Diff(want, got); diff != "" {
+		t.Fatalf("InstancesByPort() returned unexpected list of endpoints (--want/++got): %v", diff)
+	}
+}
+
 //
 func TestExternalNameServiceInstances(t *testing.T) {
 	for mode, name := range EndpointModeNames {
@@ -2345,6 +2550,79 @@ func TestWorkloadInstanceHandlerMultipleEndpoints(t *testing.T) {
 	}
 }
 
+func TestWorkloadInstanceHandler_WorkloadInstanceIndex(t *testing.T) {
+	ctl, _ := NewFakeControllerWithOptions(FakeControllerOptions{})
+	go ctl.Run(ctl.stop)
+	// Wait for the caches to sync, otherwise we may hit race conditions where events are dropped
+	cache.WaitForCacheSync(ctl.stop, ctl.HasSynced)
+	defer ctl.Stop()
+
+	verifyGetByIP := func(address string, want []*model.WorkloadInstance) {
+		got := ctl.workloadInstancesIndex.GetByIP(address)
+
+		if diff := cmp.Diff(want, got); diff != "" {
+			t.Fatalf("workload index is not valid (--want/++got): %v", diff)
+		}
+	}
+
+	wi1 := &model.WorkloadInstance{
+		Name:      "ratings-1",
+		Namespace: "bookinfo",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "ratings"},
+			Address:      "2.2.2.2",
+			EndpointPort: 8080,
+		},
+	}
+
+	// simulate adding a workload entry
+	ctl.WorkloadInstanceHandler(wi1, model.EventAdd)
+
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi1})
+
+	wi2 := &model.WorkloadInstance{
+		Name:      "details-1",
+		Namespace: "bookinfo",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "details"},
+			Address:      "3.3.3.3",
+			EndpointPort: 9090,
+		},
+	}
+
+	// simulate adding a workload entry
+	ctl.WorkloadInstanceHandler(wi2, model.EventAdd)
+
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi1})
+	verifyGetByIP("3.3.3.3", []*model.WorkloadInstance{wi2})
+
+	wi3 := &model.WorkloadInstance{
+		Name:      "details-1",
+		Namespace: "bookinfo",
+		Endpoint: &model.IstioEndpoint{
+			Labels:       labels.Instance{"app": "details"},
+			Address:      "2.2.2.2", // update IP
+			EndpointPort: 9090,
+		},
+	}
+
+	// simulate updating a workload entry
+	ctl.WorkloadInstanceHandler(wi3, model.EventUpdate)
+
+	verifyGetByIP("3.3.3.3", nil)
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi3, wi1})
+
+	// simulate deleting a workload entry
+	ctl.WorkloadInstanceHandler(wi3, model.EventDelete)
+
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi1})
+
+	// simulate deleting a workload entry
+	ctl.WorkloadInstanceHandler(wi1, model.EventDelete)
+
+	verifyGetByIP("2.2.2.2", nil)
+}
+
 func TestKubeEndpointsControllerOnEvent(t *testing.T) {
 	testCases := []struct {
 		mode      EndpointMode
diff --git a/pilot/pkg/serviceregistry/kube/controller/fake.go b/pilot/pkg/serviceregistry/kube/controller/fake.go
index c91a07cb46..60b73e1862 100644
--- a/pilot/pkg/serviceregistry/kube/controller/fake.go
+++ b/pilot/pkg/serviceregistry/kube/controller/fake.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/mesh"
 	kubelib "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/test"
 )
 
 const (
@@ -113,6 +114,18 @@ func (fx *FakeXdsUpdater) RemoveShard(shardKey model.ShardKey) {
 	}
 }
 
+func (fx *FakeXdsUpdater) WaitOrFail(t test.Failer, et string) *FakeXdsEvent {
+	return fx.WaitForDurationOrFail(t, et, 5*time.Second)
+}
+
+func (fx *FakeXdsUpdater) WaitForDurationOrFail(t test.Failer, et string, d time.Duration) *FakeXdsEvent {
+	ev := fx.WaitForDuration(et, d)
+	if ev == nil {
+		t.Fatalf("Timeout creating %q after %s", et, d)
+	}
+	return ev
+}
+
 func (fx *FakeXdsUpdater) Wait(et string) *FakeXdsEvent {
 	return fx.WaitForDuration(et, 5*time.Second)
 }
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/index.go b/pilot/pkg/serviceregistry/util/workloadinstances/index.go
new file mode 100644
index 0000000000..5a20007ef7
--- /dev/null
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/index.go
@@ -0,0 +1,140 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package workloadinstances
+
+import (
+	"sync"
+
+	"istio.io/istio/pilot/pkg/model"
+)
+
+// Index reprensents an index over workload instances from workload entries.
+//
+// Indexes are thread-safe.
+type Index interface {
+	// Insert adds/updates given workload instance to the index.
+	//
+	// Returns previous value in the index, or nil otherwise.
+	Insert(*model.WorkloadInstance) *model.WorkloadInstance
+	// Delete removes given workload instance from the index.
+	//
+	// Returns value removed from the index, or nil otherwise.
+	Delete(*model.WorkloadInstance) *model.WorkloadInstance
+	// GetByIP returns a list of all workload instances associated with a
+	// given IP address. The list is ordered by namespace/name.
+	//
+	// There are several use cases where multiple workload instances might
+	// have the same IP address:
+	// 1) there are multiple Istio Proxies running on a single host, e.g.
+	//    in 'router' mode or even in 'sidecar' mode.
+	// 2) workload instances have the same IP but different networks
+	GetByIP(string) []*model.WorkloadInstance
+	// Empty returns whether the index is empty.
+	Empty() bool
+	// ForEach iterates over all workload instances in the index.
+	ForEach(func(*model.WorkloadInstance))
+}
+
+// indexKey returns index key for a given workload instance.
+func indexKey(wi *model.WorkloadInstance) string {
+	return wi.Namespace + "/" + wi.Name
+}
+
+// NewIndex returns a new Index instance.
+func NewIndex() Index {
+	return &index{
+		keyFunc:       indexKey,
+		keyToInstance: make(map[string]*model.WorkloadInstance),
+		ipToKeys:      make(MultiValueMap),
+	}
+}
+
+// index implements Index.
+type index struct {
+	mu sync.RWMutex
+	// key function
+	keyFunc func(*model.WorkloadInstance) string
+	// map of namespace/name -> workload instance
+	keyToInstance map[string]*model.WorkloadInstance
+	// map of ip -> set of namespace/name
+	ipToKeys MultiValueMap
+}
+
+// Insert implements Index.
+func (i *index) Insert(wi *model.WorkloadInstance) *model.WorkloadInstance {
+	i.mu.Lock()
+	defer i.mu.Unlock()
+
+	key := i.keyFunc(wi)
+	// Check to see if the workload entry changed. If it did, clear the old entry
+	previous := i.keyToInstance[key]
+	if previous != nil && previous.Endpoint.Address != wi.Endpoint.Address {
+		i.ipToKeys.Delete(previous.Endpoint.Address, key)
+	}
+	i.keyToInstance[key] = wi
+	i.ipToKeys.Insert(wi.Endpoint.Address, key)
+	return previous
+}
+
+// Delete implements Index.
+func (i *index) Delete(wi *model.WorkloadInstance) *model.WorkloadInstance {
+	i.mu.Lock()
+	defer i.mu.Unlock()
+
+	key := i.keyFunc(wi)
+	previous := i.keyToInstance[key]
+	if previous != nil {
+		i.ipToKeys.Delete(previous.Endpoint.Address, key)
+	}
+	i.ipToKeys.Delete(wi.Endpoint.Address, key)
+	delete(i.keyToInstance, key)
+	return previous
+}
+
+// GetByIP implements Index.
+func (i *index) GetByIP(ip string) []*model.WorkloadInstance {
+	i.mu.RLock()
+	defer i.mu.RUnlock()
+
+	keys := i.ipToKeys[ip]
+	if len(keys) == 0 {
+		return nil
+	}
+	instances := make([]*model.WorkloadInstance, 0, len(keys))
+	for _, key := range keys.SortedList() {
+		if instance, exists := i.keyToInstance[key]; exists {
+			instances = append(instances, instance)
+		}
+	}
+	return instances
+}
+
+// Empty implements Index.
+func (i *index) Empty() bool {
+	i.mu.RLock()
+	defer i.mu.RUnlock()
+
+	return len(i.keyToInstance) == 0
+}
+
+// ForEach iterates over all workload instances in the index.
+func (i *index) ForEach(fn func(*model.WorkloadInstance)) {
+	i.mu.RLock()
+	defer i.mu.RUnlock()
+
+	for _, instance := range i.keyToInstance {
+		fn(instance)
+	}
+}
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go b/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
new file mode 100644
index 0000000000..03f11e3048
--- /dev/null
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
@@ -0,0 +1,134 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package workloadinstances
+
+import (
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/spiffe"
+)
+
+var GlobalTime = time.Now()
+
+// ServiceEntry with a selector
+var selector = &config.Config{
+	Meta: config.Meta{
+		GroupVersionKind:  gvk.ServiceEntry,
+		Name:              "selector",
+		Namespace:         "selector",
+		CreationTimestamp: GlobalTime,
+	},
+	Spec: &networking.ServiceEntry{
+		Hosts: []string{"selector.com"},
+		Ports: []*networking.Port{
+			{Number: 444, Name: "tcp-444", Protocol: "tcp"},
+			{Number: 445, Name: "http-445", Protocol: "http"},
+		},
+		WorkloadSelector: &networking.WorkloadSelector{
+			Labels: map[string]string{"app": "wle"},
+		},
+		Resolution: networking.ServiceEntry_STATIC,
+	},
+}
+
+func TestIndex(t *testing.T) {
+	// Setup a couple of workload instances for test. These will be selected by the `selector` SE
+	wi1 := &model.WorkloadInstance{
+		Name:      selector.Name,
+		Namespace: selector.Namespace,
+		Endpoint: &model.IstioEndpoint{
+			Address:        "2.2.2.2",
+			Labels:         map[string]string{"app": "wle"},
+			ServiceAccount: spiffe.MustGenSpiffeURI(selector.Name, "default"),
+			TLSMode:        model.IstioMutualTLSModeLabel,
+		},
+	}
+
+	wi2 := &model.WorkloadInstance{
+		Name:      "some-other-name",
+		Namespace: selector.Namespace,
+		Endpoint: &model.IstioEndpoint{
+			Address:        "3.3.3.3",
+			Labels:         map[string]string{"app": "wle"},
+			ServiceAccount: spiffe.MustGenSpiffeURI(selector.Name, "default"),
+			TLSMode:        model.IstioMutualTLSModeLabel,
+		},
+	}
+
+	wi3 := &model.WorkloadInstance{
+		Name:      "another-name",
+		Namespace: "dns-selector",
+		Endpoint: &model.IstioEndpoint{
+			Address:        "2.2.2.2",
+			Labels:         map[string]string{"app": "dns-wle"},
+			ServiceAccount: spiffe.MustGenSpiffeURI("dns-selector", "default"),
+			TLSMode:        model.IstioMutualTLSModeLabel,
+		},
+	}
+
+	index := NewIndex()
+
+	// test update
+	index.Insert(wi1)
+	index.Insert(wi2)
+	index.Insert(wi3)
+
+	verifyGetByIP := func(ip string, expected []*model.WorkloadInstance) {
+		actual := index.GetByIP(ip)
+
+		if diff := cmp.Diff(len(expected), len(actual)); diff != "" {
+			t.Errorf("GetByIP() returned unexpected number of workload instances (--want/++got): %v", diff)
+		}
+
+		for i := range expected {
+			if diff := cmp.Diff(expected[i], actual[i]); diff != "" {
+				t.Errorf("GetByIP() returned unexpected workload instance %d (--want/++got): %v", i, diff)
+			}
+		}
+	}
+
+	// GetByIP should return 2 workload instances
+
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi3, wi1})
+
+	// Delete should return previously inserted value
+
+	deleted := index.Delete(wi1)
+	if diff := cmp.Diff(wi1, deleted); diff != "" {
+		t.Errorf("1st Delete() returned unexpected value (--want/++got): %v", diff)
+	}
+
+	// GetByIP should return 1 workload instance
+
+	verifyGetByIP("2.2.2.2", []*model.WorkloadInstance{wi3})
+
+	// Delete should return nil since there is no such element in the index
+
+	deleted = index.Delete(wi1)
+	if diff := cmp.Diff((*model.WorkloadInstance)(nil), deleted); diff != "" {
+		t.Errorf("2nd Delete() returned unexpected value (--want/++got): %v", diff)
+	}
+
+	// GetByIP should return nil
+
+	verifyGetByIP("1.1.1.1", nil)
+}
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/map.go b/pilot/pkg/serviceregistry/util/workloadinstances/map.go
new file mode 100644
index 0000000000..d679f1704f
--- /dev/null
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/map.go
@@ -0,0 +1,44 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package workloadinstances
+
+import (
+	"istio.io/istio/pilot/pkg/util/sets"
+)
+
+// MultiValueMap represents a map where each key might be associated with
+// multiple values.
+type MultiValueMap map[string]sets.Set
+
+// Insert adds given (key, value) pair into the map.
+func (m MultiValueMap) Insert(key, value string) MultiValueMap {
+	if values, exists := m[key]; exists {
+		values.Insert(value)
+		return m
+	}
+	m[key] = sets.NewSet(value)
+	return m
+}
+
+// Delete removes given (key, value) pair out of the map.
+func (m MultiValueMap) Delete(key, value string) MultiValueMap {
+	if values, exists := m[key]; exists {
+		values.Delete(value)
+		if values.Empty() {
+			delete(m, key)
+		}
+	}
+	return m
+}
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/util.go b/pilot/pkg/serviceregistry/util/workloadinstances/util.go
new file mode 100644
index 0000000000..c86d035886
--- /dev/null
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/util.go
@@ -0,0 +1,87 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package workloadinstances
+
+import (
+	"strings"
+
+	"k8s.io/apimachinery/pkg/types"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/util/slices"
+)
+
+// FindInstance returns the first workload instance matching given predicate.
+func FindInstance(instances []*model.WorkloadInstance, predicate func(*model.WorkloadInstance) bool) *model.WorkloadInstance {
+	for _, instance := range instances {
+		if predicate(instance) {
+			return instance
+		}
+	}
+	return nil
+}
+
+// InstanceNameForProxy returns a name of the workload instance that
+// corresponds to a given proxy, if any.
+func InstanceNameForProxy(proxy *model.Proxy) types.NamespacedName {
+	parts := strings.Split(proxy.ID, ".")
+	if len(parts) == 2 && proxy.ConfigNamespace == parts[1] {
+		return types.NamespacedName{Name: parts[0], Namespace: parts[1]}
+	}
+	return types.NamespacedName{}
+}
+
+// GetInstanceForProxy returns a workload instance that
+// corresponds to a given proxy, if any.
+func GetInstanceForProxy(index Index, proxy *model.Proxy, proxyIP string) *model.WorkloadInstance {
+	if !slices.ContainsString(proxy.IPAddresses, proxyIP) {
+		return nil
+	}
+	instances := index.GetByIP(proxyIP) // list is ordered by namespace/name
+	if len(instances) == 0 {
+		return nil
+	}
+	if len(instances) == 1 { // dominant use case
+		// NOTE: for the sake of backwards compatibility, we don't enforce
+		//       instance.Namespace == proxy.ConfigNamespace
+		return instances[0]
+	}
+
+	// try to find workload instance with the same name as proxy
+	proxyName := InstanceNameForProxy(proxy)
+	if proxyName != (types.NamespacedName{}) {
+		instance := FindInstance(instances, func(wi *model.WorkloadInstance) bool {
+			return wi.Name == proxyName.Name && wi.Namespace == proxyName.Namespace
+		})
+		if instance != nil {
+			return instance
+		}
+	}
+
+	// try to find workload instance in the same namespace as proxy
+	instance := FindInstance(instances, func(wi *model.WorkloadInstance) bool {
+		// TODO: take auto-registration group into account once it's included into workload instance
+		return wi.Namespace == proxy.ConfigNamespace
+	})
+	if instance != nil {
+		return instance
+	}
+
+	// fall back to choosing one of the workload instances
+
+	// NOTE: for the sake of backwards compatibility, we don't enforce
+	//       instance.Namespace == proxy.ConfigNamespace
+	return instances[0]
+}
diff --git a/pilot/pkg/util/slices/string.go b/pilot/pkg/util/slices/string.go
new file mode 100644
index 0000000000..5bde4e6c04
--- /dev/null
+++ b/pilot/pkg/util/slices/string.go
@@ -0,0 +1,26 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package slices
+
+// ContainsString returns true if a given slice of strings
+// contains given value.
+func ContainsString(values []string, match string) bool {
+	for _, value := range values {
+		if value == match {
+			return true
+		}
+	}
+	return false
+}
-- 
2.35.3

