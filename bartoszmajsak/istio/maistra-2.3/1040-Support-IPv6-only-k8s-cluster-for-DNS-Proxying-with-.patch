From 791bb2c304cb6e15775b7d9f373becbde7504798 Mon Sep 17 00:00:00 2001
From: Steve Zhang <huailong.zhang@intel.com>
Date: Thu, 14 Apr 2022 10:58:05 +0800
Subject: Support IPv6 only k8s cluster for DNS Proxying with address auto
 allocation (#38312)

* support IPv6 only cluster for DNS Proxying with address auto allocation. Fix issues#34002

* change code based on comments

* make the ipv6 address have the same format

* revert the typography for code

* change the format for DNS ip
---
 pilot/pkg/model/service.go                    | 20 +++++----
 .../serviceentry/servicediscovery.go          | 14 +++++--
 .../serviceentry/servicediscovery_test.go     | 42 +++++++++++--------
 3 files changed, 49 insertions(+), 27 deletions(-)

diff --git a/pilot/pkg/model/service.go b/pilot/pkg/model/service.go
index d77918d6bc..67bd7b78a3 100644
--- a/pilot/pkg/model/service.go
+++ b/pilot/pkg/model/service.go
@@ -80,9 +80,10 @@ type Service struct {
 	// Do not access directly. Use GetAddressForProxy
 	DefaultAddress string `json:"defaultAddress,omitempty"`
 
-	// AutoAllocatedAddress specifies the automatically allocated
-	// IPv4 address out of the reserved Class E subnet
-	// (240.240.0.0/16) for service entries with non-wildcard
+	// AutoAllocatedIPv4Address and AutoAllocatedIPv6Address specifies
+	// the automatically allocated IPv4/IPv6 address out of the reserved
+	// Class E subnet (240.240.0.0/16) or reserved Benchmarking IP range
+	// (2001:2::/48) in RFC5180.for service entries with non-wildcard
 	// hostnames. The IPs assigned to services are not
 	// synchronized across istiod replicas as the DNS resolution
 	// for these service entries happens completely inside a pod
@@ -90,7 +91,8 @@ type Service struct {
 	// to allocate IPs is pretty deterministic that at stable state, two
 	// istiods will allocate the exact same set of IPs for a given set of
 	// service entries.
-	AutoAllocatedAddress string `json:"autoAllocatedAddress,omitempty"`
+	AutoAllocatedIPv4Address string `json:"autoAllocatedIPv4Address,omitempty"`
+	AutoAllocatedIPv6Address string `json:"autoAllocatedIPv6Address,omitempty"`
 
 	// Resolution indicates how the service instances need to be resolved before routing
 	// traffic. Most services in the service registry will use static load balancing wherein
@@ -769,9 +771,13 @@ func (s *Service) GetAddressForProxy(node *Proxy) string {
 			}
 		}
 
-		if node.Metadata.DNSCapture && node.Metadata.DNSAutoAllocate &&
-			s.DefaultAddress == constants.UnspecifiedIP && s.AutoAllocatedAddress != "" {
-			return s.AutoAllocatedAddress
+		if node.Metadata.DNSCapture && node.Metadata.DNSAutoAllocate && s.DefaultAddress == constants.UnspecifiedIP {
+			if node.SupportsIPv4() && s.AutoAllocatedIPv4Address != "" {
+				return s.AutoAllocatedIPv4Address
+			}
+			if node.SupportsIPv6() && s.AutoAllocatedIPv6Address != "" {
+				return s.AutoAllocatedIPv6Address
+			}
 		}
 	}
 
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
index fa5f8a2d40..d82d960c1d 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
@@ -557,7 +557,7 @@ func (s *Controller) Services() []*model.Service {
 	}
 	s.mutex.Unlock()
 	for _, svc := range allServices {
-		// shallow copy, copy `AutoAllocatedAddress`
+		// shallow copy, copy `AutoAllocatedIPv4Address` and `AutoAllocatedIPv6Address`
 		// if return the pointer directly, there will be a race with `BuildNameTable`
 		// nolint: govet
 		shallowSvc := *svc
@@ -813,7 +813,8 @@ func servicesDiff(os []*model.Service, ns []*model.Service) ([]*model.Service, [
 // Automatically allocates IPs for service entry services WITHOUT an
 // address field if the hostname is not a wildcard, or when resolution
 // is not NONE. The IPs are allocated from the reserved Class E subnet
-// (240.240.0.0/16) that is not reachable outside the pod. When DNS
+// (240.240.0.0/16) that is not reachable outside the pod or reserved
+// Benchmarking IP range (2001:2::/48) in RFC5180. When DNS
 // capture is enabled, Envoy will resolve the DNS to these IPs. The
 // listeners for TCP services will also be set up on these IPs. The
 // IPs allocated to a service entry may differ from istiod to istiod
@@ -864,7 +865,14 @@ func autoAllocateIPs(services []*model.Service) []*model.Service {
 			}
 			thirdOctet := x / 255
 			fourthOctet := x % 255
-			svc.AutoAllocatedAddress = fmt.Sprintf("240.240.%d.%d", thirdOctet, fourthOctet)
+
+			svc.AutoAllocatedIPv4Address = fmt.Sprintf("240.240.%d.%d", thirdOctet, fourthOctet)
+			// if the service of service entry has IPv6 address, then allocate the IPv4-Mapped IPv6 Address for it
+			if thirdOctet == 0 {
+				svc.AutoAllocatedIPv6Address = fmt.Sprintf("2001:2::f0f0:%x", fourthOctet)
+			} else {
+				svc.AutoAllocatedIPv6Address = fmt.Sprintf("2001:2::f0f0:%x%x", thirdOctet, fourthOctet)
+			}
 		}
 	}
 	return services
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
index f864548ca0..66bc6d1bbd 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
@@ -1486,10 +1486,11 @@ func Test_autoAllocateIP_conditions(t *testing.T) {
 			},
 			wantServices: []*model.Service{
 				{
-					Hostname:             "foo.com",
-					Resolution:           model.ClientSideLB,
-					DefaultAddress:       "0.0.0.0",
-					AutoAllocatedAddress: "240.240.0.1",
+					Hostname:                 "foo.com",
+					Resolution:               model.ClientSideLB,
+					DefaultAddress:           "0.0.0.0",
+					AutoAllocatedIPv4Address: "240.240.0.1",
+					AutoAllocatedIPv6Address: "2001:2::f0f0:1",
 				},
 			},
 		},
@@ -1504,18 +1505,25 @@ func Test_autoAllocateIP_conditions(t *testing.T) {
 			},
 			wantServices: []*model.Service{
 				{
-					Hostname:             "foo.com",
-					Resolution:           model.DNSLB,
-					DefaultAddress:       "0.0.0.0",
-					AutoAllocatedAddress: "240.240.0.1",
+					Hostname:                 "foo.com",
+					Resolution:               model.DNSLB,
+					DefaultAddress:           "0.0.0.0",
+					AutoAllocatedIPv4Address: "240.240.0.1",
+					AutoAllocatedIPv6Address: "2001:2::f0f0:1",
 				},
 			},
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			if got := autoAllocateIPs(tt.inServices); !reflect.DeepEqual(got, tt.wantServices) {
-				t.Errorf("autoAllocateIPs() = %v, want %v", got, tt.wantServices)
+			got := autoAllocateIPs(tt.inServices)
+			if got[0].AutoAllocatedIPv4Address != tt.wantServices[0].AutoAllocatedIPv4Address {
+				t.Errorf("autoAllocateIPs() AutoAllocatedIPv4Address = %v, want %v",
+					got[0].AutoAllocatedIPv4Address, tt.wantServices[0].AutoAllocatedIPv4Address)
+			}
+			if got[0].AutoAllocatedIPv6Address != tt.wantServices[0].AutoAllocatedIPv6Address {
+				t.Errorf("autoAllocateIPs() AutoAllocatedIPv4Address = %v, want %v",
+					got[0].AutoAllocatedIPv6Address, tt.wantServices[0].AutoAllocatedIPv6Address)
 			}
 		})
 	}
@@ -1550,19 +1558,19 @@ func Test_autoAllocateIP_values(t *testing.T) {
 		"240.240.2.255": true,
 	}
 	expectedLastIP := "240.240.2.4"
-	if gotServices[len(gotServices)-1].AutoAllocatedAddress != expectedLastIP {
-		t.Errorf("expected last IP address to be %s, got %s", expectedLastIP, gotServices[len(gotServices)-1].AutoAllocatedAddress)
+	if gotServices[len(gotServices)-1].AutoAllocatedIPv4Address != expectedLastIP {
+		t.Errorf("expected last IP address to be %s, got %s", expectedLastIP, gotServices[len(gotServices)-1].AutoAllocatedIPv4Address)
 	}
 
 	gotIPMap := make(map[string]bool)
 	for _, svc := range gotServices {
-		if svc.AutoAllocatedAddress == "" || doNotWant[svc.AutoAllocatedAddress] {
-			t.Errorf("unexpected value for auto allocated IP address %s", svc.AutoAllocatedAddress)
+		if svc.AutoAllocatedIPv4Address == "" || doNotWant[svc.AutoAllocatedIPv4Address] {
+			t.Errorf("unexpected value for auto allocated IP address %s", svc.AutoAllocatedIPv4Address)
 		}
-		if gotIPMap[svc.AutoAllocatedAddress] {
-			t.Errorf("multiple allocations of same IP address to different services: %s", svc.AutoAllocatedAddress)
+		if gotIPMap[svc.AutoAllocatedIPv4Address] {
+			t.Errorf("multiple allocations of same IP address to different services: %s", svc.AutoAllocatedIPv4Address)
 		}
-		gotIPMap[svc.AutoAllocatedAddress] = true
+		gotIPMap[svc.AutoAllocatedIPv4Address] = true
 	}
 }
 
-- 
2.35.3

