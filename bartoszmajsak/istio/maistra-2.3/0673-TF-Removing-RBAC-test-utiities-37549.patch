From e386548ae6e62b0a53751c3aad0c6115320d5ec0 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Mon, 28 Feb 2022 17:05:45 -0800
Subject: [TF] Removing RBAC test utiities (#37549)

This is removing one of the extra testing frameworks from the security tests. Preferring to use the raw echo libraries to the extent possible.
---
 pkg/http/headers/builder.go                   |   59 +
 pkg/http/headers/wellknown.go                 |   21 +
 pkg/test/echo/check/checkers.go               |   76 +-
 pkg/test/echo/common/util.go                  |   25 +-
 pkg/test/echo/response.go                     |   20 +
 pkg/test/util/file/file.go                    |   27 +-
 tests/integration/pilot/common/routing.go     |   38 +-
 tests/integration/pilot/ingress_test.go       |    4 +-
 .../security/authorization_test.go            | 1347 +++++++++--------
 .../egress_gateway_origination_test.go        |    2 +-
 .../security/normalization_test.go            |    2 +-
 .../pass_through_filter_chain_test.go         |    2 +-
 .../sds_istio_mutual_egress_test.go           |    2 +-
 .../security/sds_ingress/util/util.go         |    2 +-
 .../security/util/authn/authn_util.go         |    4 +-
 tests/integration/security/util/framework.go  |    9 -
 .../security/util/rbac_util/util.go           |  171 ---
 .../security/util/scheck/checkers.go          |   95 ++
 18 files changed, 1022 insertions(+), 884 deletions(-)
 create mode 100644 pkg/http/headers/builder.go
 create mode 100644 pkg/http/headers/wellknown.go
 delete mode 100644 tests/integration/security/util/rbac_util/util.go
 create mode 100644 tests/integration/security/util/scheck/checkers.go

diff --git a/pkg/http/headers/builder.go b/pkg/http/headers/builder.go
new file mode 100644
index 0000000000..def2fc1c2c
--- /dev/null
+++ b/pkg/http/headers/builder.go
@@ -0,0 +1,59 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package headers
+
+import (
+	"net/http"
+)
+
+// Builder for HTTP headers.
+type Builder struct {
+	headers http.Header
+}
+
+// New Builder for HTTP headers.
+func New() *Builder {
+	return &Builder{
+		headers: make(http.Header),
+	}
+}
+
+// With sets the given header value.
+func (b *Builder) With(key, value string) *Builder {
+	b.headers.Set(key, value)
+	return b
+}
+
+// WithAuthz sets the Authorization header with the given token.
+func (b *Builder) WithAuthz(token string) *Builder {
+	if token != "" {
+		return b.With(Authorization, "Bearer "+token)
+	}
+	return b
+}
+
+// WithHost sets the Host header to the given value.
+func (b *Builder) WithHost(host string) *Builder {
+	return b.With(Host, host)
+}
+
+// WithXForwardedFor sets the origin IP of the request.
+func (b *Builder) WithXForwardedFor(ip string) *Builder {
+	return b.With(XForwardedFor, ip)
+}
+
+func (b *Builder) Build() http.Header {
+	return b.headers
+}
diff --git a/pkg/http/headers/wellknown.go b/pkg/http/headers/wellknown.go
new file mode 100644
index 0000000000..2e8d90b85d
--- /dev/null
+++ b/pkg/http/headers/wellknown.go
@@ -0,0 +1,21 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package headers
+
+const (
+	Host          = "Host"
+	Authorization = "Authorization"
+	XForwardedFor = "X-Forwarded-For"
+)
diff --git a/pkg/test/echo/check/checkers.go b/pkg/test/echo/check/checkers.go
index 1118c6986f..e7e00e5cee 100644
--- a/pkg/test/echo/check/checkers.go
+++ b/pkg/test/echo/check/checkers.go
@@ -28,16 +28,6 @@
 	"istio.io/istio/pkg/util/istiomultierror"
 )
 
-// FilterError applies the given filter function to any errors returned by the Checker.
-func FilterError(filter func(error) error, c Checker) Checker {
-	return func(rs echo.Responses, err error) error {
-		if err := c(rs, err); err != nil {
-			return filter(err)
-		}
-		return nil
-	}
-}
-
 // Each applies the given per-response function across all responses.
 func Each(c func(r echo.Response) error) Checker {
 	return func(rs echo.Responses, _ error) error {
@@ -54,11 +44,11 @@ func Each(c func(r echo.Response) error) Checker {
 	}
 }
 
-// And is an aggregate Checker that requires all Checkers succeed.
+// And is an aggregate Checker that requires all Checkers succeed. Any nil Checkers are ignored.
 func And(checkers ...Checker) Checker {
-	return func(r echo.Responses, err error) error {
-		for _, c := range checkers {
-			if err := c(r, err); err != nil {
+	return func(rs echo.Responses, err error) error {
+		for _, c := range filterNil(checkers) {
+			if err := c(rs, err); err != nil {
 				return err
 			}
 		}
@@ -66,6 +56,16 @@ func And(checkers ...Checker) Checker {
 	}
 }
 
+func filterNil(checkers []Checker) []Checker {
+	var out []Checker
+	for _, c := range checkers {
+		if c != nil {
+			out = append(out, c)
+		}
+	}
+	return out
+}
+
 // None provides a Checker that returns the original raw call error, unaltered.
 func None() Checker {
 	return func(_ echo.Responses, err error) error {
@@ -106,13 +106,20 @@ func ErrorContains(expected string) Checker {
 	}
 }
 
+// OK is a shorthand for NoErrorAndStatus(200).
 func OK() Checker {
-	return StatusCode(http.StatusOK)
+	return NoErrorAndStatus(http.StatusOK)
 }
 
-// StatusCode checks that the response status code matches the expected value. If the expected value is zero,
+// NoErrorAndStatus is checks that no error occurred and htat the returned status code matches the expected
+// value.
+func NoErrorAndStatus(expected int) Checker {
+	return And(NoError(), Status(expected))
+}
+
+// Status checks that the response status code matches the expected value. If the expected value is zero,
 // checks that the response code is unset.
-func StatusCode(expected int) Checker {
+func Status(expected int) Checker {
 	expectedStr := ""
 	if expected > 0 {
 		expectedStr = strconv.Itoa(expected)
@@ -260,15 +267,6 @@ func URL(expected string) Checker {
 	})
 }
 
-func IP(expected string) Checker {
-	return Each(func(r echo.Response) error {
-		if r.IP != expected {
-			return fmt.Errorf("expected IP %s, received %s", expected, r.IP)
-		}
-		return nil
-	})
-}
-
 // ReachedClusters returns an error if there wasn't at least one response from each of the given clusters.
 // This can be used in combination with echo.Responses.Clusters(), for example:
 //     echoA[0].CallOrFail(t, ...).CheckReachedClusters(echoB.Clusters())
@@ -291,23 +289,6 @@ func ReachedClusters(clusters cluster.Clusters) Checker {
 	}
 }
 
-// EqualClusterTraffic checks that traffic was equally distributed across the given clusters, allowing some percent error.
-// For example, with 100 requests and 20 percent error, each cluster must given received 20Â±4 responses. Only the passed
-// in clusters will be validated.
-func EqualClusterTraffic(clusters cluster.Clusters, precisionPct int) Checker {
-	return func(r echo.Responses, err error) error {
-		clusterHits := clusterDistribution(r)
-		expected := len(r) / len(clusters)
-		precision := int(float32(expected) * (float32(precisionPct) / 100))
-		for _, hits := range clusterHits {
-			if !almostEquals(hits, expected, precision) {
-				return fmt.Errorf("requests were not equally distributed across clusters: %v", clusterHits)
-			}
-		}
-		return nil
-	}
-}
-
 func clusterDistribution(r echo.Responses) map[string]int {
 	hits := map[string]int{}
 	for _, rr := range r {
@@ -315,12 +296,3 @@ func clusterDistribution(r echo.Responses) map[string]int {
 	}
 	return hits
 }
-
-func almostEquals(a, b, precision int) bool {
-	upper := a + precision
-	lower := a - precision
-	if b < lower || b > upper {
-		return false
-	}
-	return true
-}
diff --git a/pkg/test/echo/common/util.go b/pkg/test/echo/common/util.go
index 1073859742..89491cf92f 100644
--- a/pkg/test/echo/common/util.go
+++ b/pkg/test/echo/common/util.go
@@ -17,6 +17,7 @@
 import (
 	"flag"
 	"net/http"
+	"strings"
 	"time"
 
 	"istio.io/istio/pkg/test/echo/proto"
@@ -57,14 +58,26 @@ func GetCount(request *proto.ForwardEchoRequest) int {
 	return DefaultCount
 }
 
-// GetHeaders returns the headers for the message.
-func GetHeaders(request *proto.ForwardEchoRequest) http.Header {
-	headers := make(http.Header)
-	for _, h := range request.Headers {
+func HTTPToProtoHeaders(headers http.Header) []*proto.Header {
+	out := make([]*proto.Header, 0, len(headers))
+	for k, v := range headers {
+		out = append(out, &proto.Header{Key: k, Value: strings.Join(v, ",")})
+	}
+	return out
+}
+
+func ProtoToHTTPHeaders(headers []*proto.Header) http.Header {
+	out := make(http.Header)
+	for _, h := range headers {
 		// Avoid using .Add() to allow users to pass non-canonical forms
-		headers[h.Key] = append(headers[h.Key], h.Value)
+		out[h.Key] = append(out[h.Key], h.Value)
 	}
-	return headers
+	return out
+}
+
+// GetHeaders returns the headers for the message.
+func GetHeaders(request *proto.ForwardEchoRequest) http.Header {
+	return ProtoToHTTPHeaders(request.Headers)
 }
 
 // MicrosToDuration converts the given microseconds to a time.Duration.
diff --git a/pkg/test/echo/response.go b/pkg/test/echo/response.go
index 732e5d0bf4..32f1da0159 100644
--- a/pkg/test/echo/response.go
+++ b/pkg/test/echo/response.go
@@ -21,6 +21,14 @@
 	"strings"
 )
 
+// HeaderType is a helper enum for retrieving Headers from a Response.
+type HeaderType string
+
+const (
+	RequestHeader  HeaderType = "request"
+	ResponseHeader HeaderType = "response"
+)
+
 // Response represents a response to a single echo request.
 type Response struct {
 	// RequestURL is the requested URL. This differs from URL, which is the just the path.
@@ -65,6 +73,18 @@ func (r Response) Count(text string) int {
 	return strings.Count(r.RawContent, text)
 }
 
+// GetHeaders returns the appropriate headers for the given type.
+func (r Response) GetHeaders(hType HeaderType) http.Header {
+	switch hType {
+	case RequestHeader:
+		return r.RequestHeaders
+	case ResponseHeader:
+		return r.ResponseHeaders
+	default:
+		panic("invalid HeaderType enum: " + hType)
+	}
+}
+
 // Body returns the lines of the response body, in order
 func (r Response) Body() []string {
 	type keyValue struct {
diff --git a/pkg/test/util/file/file.go b/pkg/test/util/file/file.go
index a976e58d0f..d850c53a51 100644
--- a/pkg/test/util/file/file.go
+++ b/pkg/test/util/file/file.go
@@ -43,13 +43,36 @@ func AsBytesOrFail(t test.Failer, filename string) []byte {
 	return content
 }
 
+// AsString is a convenience wrapper around os.ReadFile that converts the content to a string.
+func AsStringArray(files ...string) ([]string, error) {
+	out := make([]string, 0, len(files))
+	for _, f := range files {
+		b, err := AsBytes(f)
+		if err != nil {
+			return nil, err
+		}
+		out = append(out, string(b))
+	}
+	return out, nil
+}
+
+// AsStringArrayOrFail calls AsStringOrFail and then converts to string.
+func AsStringArrayOrFail(t test.Failer, files ...string) []string {
+	t.Helper()
+	out, err := AsStringArray(files...)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return out
+}
+
 // AsString is a convenience wrapper around os.ReadFile that converts the content to a string.
 func AsString(filename string) (string, error) {
-	bytes, err := AsBytes(filename)
+	b, err := AsBytes(filename)
 	if err != nil {
 		return "", err
 	}
-	return string(bytes), nil
+	return string(b), nil
 }
 
 // AsStringOrFail calls AsBytesOrFail and then converts to string.
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 55baecc5bc..339049b328 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -406,7 +406,7 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 				FollowRedirects: false,
 				Count:           1,
 				Check: check.And(
-					check.StatusCode(http.StatusMovedPermanently),
+					check.Status(http.StatusMovedPermanently),
 					check.Each(
 						func(r echoClient.Response) error {
 							originalHostname, err := url.Parse(r.RequestURL)
@@ -608,7 +608,7 @@ func(r echoClient.Response) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Check:    check.StatusCode(http.StatusTeapot),
+				Check:    check.Status(http.StatusTeapot),
 			},
 			workloadAgnostic: true,
 		},
@@ -993,7 +993,7 @@ func gatewayCases() []TrafficTestCase {
 				Headers: map[string][]string{
 					"Host": {"foo.bar"},
 				},
-				Check: check.StatusCode(http.StatusNotFound),
+				Check: check.Status(http.StatusNotFound),
 			},
 			setupOpts: noTarget,
 		},
@@ -1025,7 +1025,7 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Check: check.StatusCode(http.StatusMovedPermanently),
+				Check: check.Status(http.StatusMovedPermanently),
 			},
 			setupOpts: fqdnHostHeader,
 		},
@@ -1147,7 +1147,7 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Check: check.StatusCode(http.StatusMovedPermanently),
+				Check: check.Status(http.StatusMovedPermanently),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1218,7 +1218,7 @@ func gatewayCases() []TrafficTestCase {
 					// In real world, this may be set by a downstream LB that terminates the TLS
 					"X-Forwarded-Proto": {"https"},
 				},
-				Check: check.StatusCode(http.StatusBadRequest),
+				Check: check.Status(http.StatusBadRequest),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -2315,7 +2315,7 @@ func instanceIPTests(apps *EchoDeployments) []TrafficTestCase {
 						PortName: ipCase.port,
 						Scheme:   scheme.HTTP,
 						Timeout:  time.Second * 5,
-						Check:    check.StatusCode(ipCase.code),
+						Check:    check.Status(ipCase.code),
 					},
 					minIstioVersion: ipCase.minIstioVersion,
 				})
@@ -2841,7 +2841,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusOK),
+				Check:    check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2860,7 +2860,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusOK),
+				Check:    check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2882,7 +2882,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusOK),
+				Check:    check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2901,7 +2901,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusOK),
+				Check:    check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2920,7 +2920,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusNotFound),
+				Check:    check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -2940,7 +2940,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusOK),
+				Check:    check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2962,7 +2962,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusNotFound),
+				Check:    check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -2981,7 +2981,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusNotFound),
+				Check:    check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -3000,7 +3000,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headersWithInvalidToken,
-				Check:    check.StatusCode(http.StatusUnauthorized),
+				Check:    check.Status(http.StatusUnauthorized),
 			},
 		},
 		{
@@ -3019,7 +3019,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headersWithNoToken,
-				Check:    check.StatusCode(http.StatusNotFound),
+				Check:    check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -3039,7 +3039,7 @@ type configData struct {
 				PortName: "http",
 				// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
 				Headers: headersWithNoTokenButSameHeader,
-				Check:   check.StatusCode(http.StatusNotFound),
+				Check:   check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -3058,7 +3058,7 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				Headers:  headers,
-				Check:    check.StatusCode(http.StatusNotFound),
+				Check:    check.Status(http.StatusNotFound),
 			},
 		},
 	}
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index 4da44d5cd6..0a567d5085 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -380,7 +380,7 @@ func TestIngress(t *testing.T) {
 			}
 
 			successChecker := check.And(check.OK(), check.ReachedClusters(apps.PodB.Clusters()))
-			failureChecker := check.StatusCode(http.StatusNotFound)
+			failureChecker := check.Status(http.StatusNotFound)
 			count := 1
 			if t.Clusters().IsMulticluster() {
 				count = 2 * len(t.Clusters())
@@ -644,7 +644,7 @@ func TestIngress(t *testing.T) {
 								return nil
 							}
 
-							return check.StatusCode(http.StatusNotFound).Check(rs, nil)
+							return check.Status(http.StatusNotFound).Check(rs, nil)
 						},
 					},
 				},
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index c2433eef19..6088b183f3 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -23,11 +23,12 @@
 	"net/http"
 	"strings"
 	"testing"
-	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
+	echoCommon "istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework"
@@ -42,9 +43,7 @@
 	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/tests/common/jwt"
 	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/authn"
-	"istio.io/istio/tests/integration/security/util/connection"
-	rbacUtil "istio.io/istio/tests/integration/security/util/rbac_util"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 func newRootNS(ctx framework.TestContext) namespace.Instance {
@@ -68,40 +67,51 @@ func TestAuthorization_mTLS(t *testing.T) {
 					file.AsStringOrFail(t, "testdata/authz/v1beta1-mtls.yaml.tmpl"))
 				t.ConfigIstio().ApplyYAMLOrFail(t, apps.Namespace1.Name(), policies...)
 				t.ConfigIstio().WaitForConfigOrFail(t, t, apps.Namespace1.Name(), policies...)
+				callCount := 1
+				if dst.Clusters().IsMulticluster() {
+					// so we can validate all clusters are hit
+					callCount = util.CallsPerCluster * len(dst.Clusters())
+				}
 				for _, cluster := range t.Clusters() {
-					t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-						a := apps.A.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace1.Name())))
-						c := apps.C.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace2.Name())))
-						util.CheckExistence(t, a, c)
-						newTestCase := func(from, to echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-							callCount := 1
-							if to.Clusters().IsMulticluster() {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * len(to.Clusters())
-							}
-							return rbacUtil.TestCase{
-								Request: connection.Checker{
-									From: from[0], // From service
-									Options: echo.CallOptions{
-										Target:   to[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
-										Path:     path, // Requested path
-										Count:    callCount,
-									},
-									DestClusters: to.Clusters(),
-								},
-								ExpectAllowed: expectAllowed,
+					a := apps.A.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace1.Name())))
+					c := apps.C.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace2.Name())))
+					if len(a) == 0 || len(c) == 0 {
+						continue
+					}
+
+					t.NewSubTestf("From %s", cluster.StableName()).Run(func(t framework.TestContext) {
+						newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
+							return func(t framework.TestContext) {
+								opts := echo.CallOptions{
+									Target:   to[0],
+									PortName: "http",
+									Scheme:   scheme.HTTP,
+									Path:     path,
+									Count:    callCount,
+								}
+								if expectAllowed {
+									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+								} else {
+									opts.Check = scheck.RBACFailure(&opts)
+								}
+
+								name := newRbacTestName("", expectAllowed, from, &opts)
+								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+									name.SkipIfNecessary(t)
+									from.CallWithRetryOrFail(t, opts)
+								})
 							}
 						}
 						// a and c send requests to dst
-						cases := []rbacUtil.TestCase{
-							newTestCase(a, dst, "/principal-a", true),
-							newTestCase(a, dst, "/namespace-2", false),
-							newTestCase(c, dst, "/principal-a", false),
-							newTestCase(c, dst, "/namespace-2", true),
+						cases := []func(testContext framework.TestContext){
+							newTestCase(a[0], dst, "/principal-a", true),
+							newTestCase(a[0], dst, "/namespace-2", false),
+							newTestCase(c[0], dst, "/principal-a", false),
+							newTestCase(c[0], dst, "/namespace-2", true),
+						}
+						for _, c := range cases {
+							c(t)
 						}
-						rbacUtil.RunRBACTest(t, cases)
 					})
 				}
 			}
@@ -128,75 +138,85 @@ func TestAuthorization_JWT(t *testing.T) {
 					file.AsStringOrFail(t, "testdata/authz/v1beta1-jwt.yaml.tmpl"))
 				t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
 				t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
+				callCount := 1
+				if t.Clusters().IsMulticluster() {
+					// so we can validate all clusters are hit
+					callCount = util.CallsPerCluster * len(t.Clusters())
+				}
 				for _, srcCluster := range t.Clusters() {
-					t.NewSubTest(fmt.Sprintf("From %s", srcCluster.StableName())).Run(func(t framework.TestContext) {
-						a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
-						util.CheckExistence(t, a)
-						callCount := 1
-						if t.Clusters().IsMulticluster() {
-							// so we can validate all clusters are hit
-							callCount = util.CallsPerCluster * len(t.Clusters())
-						}
-						newTestCase := func(target echo.Instances, namePrefix string, jwt string, path string, expectAllowed bool) rbacUtil.TestCase {
-							return rbacUtil.TestCase{
-								NamePrefix: namePrefix,
-								Request: connection.Checker{
-									From: a[0],
-									Options: echo.CallOptions{
-										Target:   target[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
-										Path:     path,
-										Count:    callCount,
-									},
-									DestClusters: target.Clusters(),
-								},
-								Jwt:           jwt,
-								ExpectAllowed: expectAllowed,
+					a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
+					if len(a) == 0 {
+						continue
+					}
+
+					t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
+						newTestCase := func(from echo.Instance, to echo.Instances, namePrefix, jwt, path string, expectAllowed bool) func(t framework.TestContext) {
+							return func(t framework.TestContext) {
+								opts := echo.CallOptions{
+									Target:   to[0],
+									PortName: "http",
+									Scheme:   scheme.HTTP,
+									Path:     path,
+									Count:    callCount,
+									Headers:  headers.New().WithAuthz(jwt).Build(),
+								}
+								if expectAllowed {
+									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+								} else {
+									opts.Check = scheck.RBACFailure(&opts)
+								}
+
+								name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
+								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+									name.SkipIfNecessary(t)
+									from.CallWithRetryOrFail(t, opts)
+								})
 							}
 						}
-						cases := []rbacUtil.TestCase{
-							newTestCase(dst, "[NoJWT]", "", "/token1", false),
-							newTestCase(dst, "[NoJWT]", "", "/token2", false),
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/token1", true),
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/token2", false),
-							newTestCase(dst, "[Token2]", jwt.TokenIssuer2, "/token1", false),
-							newTestCase(dst, "[Token2]", jwt.TokenIssuer2, "/token2", true),
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/tokenAny", true),
-							newTestCase(dst, "[Token2]", jwt.TokenIssuer2, "/tokenAny", true),
-							newTestCase(dst, "[PermissionToken1]", jwt.TokenIssuer1, "/permission", false),
-							newTestCase(dst, "[PermissionToken2]", jwt.TokenIssuer2, "/permission", false),
-							newTestCase(dst, "[PermissionTokenWithSpaceDelimitedScope]", jwt.TokenIssuer2WithSpaceDelimitedScope, "/permission", true),
-							newTestCase(dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key1", true),
-							newTestCase(dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key1", false),
-							newTestCase(dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key2", false),
-							newTestCase(dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key2", true),
-							newTestCase(dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-2-key1", true),
-							newTestCase(dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-2-key1", false),
-							newTestCase(dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-non-exist", false),
-							newTestCase(dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-non-exist", false),
-							newTestCase(dst, "[NoJWT]", "", "/tokenAny", false),
-							newTestCase(c, "[NoJWT]", "", "/somePath", true),
+						cases := []func(testContext framework.TestContext){
+							newTestCase(a[0], dst, "[NoJWT]", "", "/token1", false),
+							newTestCase(a[0], dst, "[NoJWT]", "", "/token2", false),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/token1", true),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/token2", false),
+							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/token1", false),
+							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/token2", true),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/tokenAny", true),
+							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/tokenAny", true),
+							newTestCase(a[0], dst, "[PermissionToken1]", jwt.TokenIssuer1, "/permission", false),
+							newTestCase(a[0], dst, "[PermissionToken2]", jwt.TokenIssuer2, "/permission", false),
+							newTestCase(a[0], dst, "[PermissionTokenWithSpaceDelimitedScope]", jwt.TokenIssuer2WithSpaceDelimitedScope, "/permission", true),
+							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key1", true),
+							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key1", false),
+							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key2", false),
+							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key2", true),
+							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-2-key1", true),
+							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-2-key1", false),
+							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-non-exist", false),
+							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-non-exist", false),
+							newTestCase(a[0], dst, "[NoJWT]", "", "/tokenAny", false),
+							newTestCase(a[0], c, "[NoJWT]", "", "/somePath", true),
 
 							// Test condition "request.auth.principal" on path "/valid-jwt".
-							newTestCase(dst, "[NoJWT]", "", "/valid-jwt", false),
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/valid-jwt", true),
-							newTestCase(dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/valid-jwt", true),
-							newTestCase(dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/valid-jwt", true),
+							newTestCase(a[0], dst, "[NoJWT]", "", "/valid-jwt", false),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/valid-jwt", true),
+							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/valid-jwt", true),
+							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/valid-jwt", true),
 
 							// Test condition "request.auth.presenter" on suffix "/presenter".
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/request/presenter", false),
-							newTestCase(dst, "[Token1WithAud]", jwt.TokenIssuer1, "/request/presenter", false),
-							newTestCase(dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter-x", false),
-							newTestCase(dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter", true),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/request/presenter", false),
+							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1, "/request/presenter", false),
+							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter-x", false),
+							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter", true),
 
 							// Test condition "request.auth.audiences" on suffix "/audiences".
-							newTestCase(dst, "[Token1]", jwt.TokenIssuer1, "/request/audiences", false),
-							newTestCase(dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/audiences", false),
-							newTestCase(dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences-x", false),
-							newTestCase(dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences", true),
+							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/request/audiences", false),
+							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/audiences", false),
+							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences-x", false),
+							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences", true),
+						}
+						for _, c := range cases {
+							c(t)
 						}
-						rbacUtil.RunRBACTest(t, cases)
 					})
 				}
 			}
@@ -220,100 +240,115 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 				// so we can validate all clusters are hit
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
-			newTestCase := func(namePrefix string, from, target echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-				return rbacUtil.TestCase{
-					NamePrefix: namePrefix,
-					Request: connection.Checker{
-						From: from[0],
-						Options: echo.CallOptions{
-							Target:   target[0],
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     path,
-							Count:    callCount,
-						},
-						DestClusters: target.Clusters(),
-					},
-					ExpectAllowed: expectAllowed,
+
+			newTestCase := func(from echo.Instance, to echo.Instances, namePrefix, path string,
+				expectAllowed bool) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					opts := echo.CallOptions{
+						Target:   to[0],
+						PortName: "http",
+						Scheme:   scheme.HTTP,
+						Path:     path,
+						Count:    callCount,
+					}
+					if expectAllowed {
+						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+					} else {
+						opts.Check = scheck.RBACFailure(&opts)
+					}
+
+					name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
+					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+						name.SkipIfNecessary(t)
+						from.CallWithRetryOrFail(t, opts)
+					})
 				}
 			}
 
 			for _, srcCluster := range t.Clusters() {
 				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
-				util.CheckExistence(t, a)
-				cases := []struct {
-					b        string
-					c        string
-					subCases []rbacUtil.TestCase
-				}{
-					{
-						b: util.BSvc,
-						c: util.CSvc,
-						subCases: []rbacUtil.TestCase{
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns1-b", true),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns1-vm", false),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns1-c", false),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns1-x", false),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns1-all", true),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns2-c", false),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns2-all", false),
-							newTestCase("[bInNS1]", a, bInNS1, "/policy-ns-root-c", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns1-b", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns1-vm", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns1-c", true),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns1-x", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns1-all", true),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns2-c", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns2-all", false),
-							newTestCase("[cInNS1]", a, cInNS1, "/policy-ns-root-c", true),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns1-b", false),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns1-vm", false),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns1-c", false),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns1-x", false),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns1-all", false),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns2-c", true),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns2-all", true),
-							newTestCase("[cInNS2]", a, cInNS2, "/policy-ns-root-c", true),
-						},
-					},
-					{
-						// TODO(JimmyCYJ): Support multiple VMs in different namespaces for workload selector test and set c to service on VM.
-						b: util.VMSvc,
-						c: util.CSvc,
-						subCases: []rbacUtil.TestCase{
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns1-b", false),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns1-vm", true),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns1-c", false),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns1-x", false),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns1-all", true),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns2-b", false),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns2-all", false),
-							newTestCase("[vmInNS1]", a, vmInNS1, "/policy-ns-root-c", false),
-						},
-					},
+				if len(a) == 0 {
+					continue
 				}
 
-				for _, tc := range cases {
-					t.NewSubTest(fmt.Sprintf("From %s", srcCluster.StableName())).
-						Run(func(t framework.TestContext) {
-							args := map[string]string{
-								"Namespace1":    ns1.Name(),
-								"Namespace2":    ns2.Name(),
-								"RootNamespace": rootns.Name(),
-								"b":             tc.b,
-								"c":             tc.c,
-							}
-							applyPolicy := func(filename string, ns namespace.Instance) {
-								policy := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, filename))
-								t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-								t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
-							}
-							applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
-							applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
-							applyPolicy("testdata/authz/v1beta1-workload-ns-root.yaml.tmpl", rootns)
-							rbacUtil.RunRBACTest(t, tc.subCases)
-						})
-				}
+				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
+					applyPolicy := func(filename string, ns namespace.Instance) {
+						policy := tmpl.EvaluateAllOrFail(t, map[string]string{
+							"Namespace1":    ns1.Name(),
+							"Namespace2":    ns2.Name(),
+							"RootNamespace": rootns.Name(),
+							"b":             util.BSvc,
+							"c":             util.CSvc,
+						}, file.AsStringOrFail(t, filename))
+						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
+					}
+					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
+					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
+					applyPolicy("testdata/authz/v1beta1-workload-ns-root.yaml.tmpl", rootns)
+
+					cases := []func(test framework.TestContext){
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-b", true),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-vm", false),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-c", false),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-x", false),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-all", true),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns2-c", false),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns2-all", false),
+						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns-root-c", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-b", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-vm", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-c", true),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-x", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-all", true),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns2-c", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns2-all", false),
+						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns-root-c", true),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-b", false),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-vm", false),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-c", false),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-x", false),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-all", false),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns2-c", true),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns2-all", true),
+						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns-root-c", true),
+					}
+					for _, c := range cases {
+						c(t)
+					}
+				})
+
+				// TODO(JimmyCYJ): Support multiple VMs in different namespaces for workload selector test and set c to service on VM.
+				t.NewSubTestf("VM From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
+					applyPolicy := func(filename string, ns namespace.Instance) {
+						policy := tmpl.EvaluateAllOrFail(t, map[string]string{
+							"Namespace1":    ns1.Name(),
+							"Namespace2":    ns2.Name(),
+							"RootNamespace": rootns.Name(),
+							"b":             util.VMSvc, // This is the only difference from standard args.
+							"c":             util.CSvc,
+						}, file.AsStringOrFail(t, filename))
+						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
+					}
+					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
+					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
+					applyPolicy("testdata/authz/v1beta1-workload-ns-root.yaml.tmpl", rootns)
+
+					cases := []func(test framework.TestContext){
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-b", false),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-vm", true),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-c", false),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-x", false),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-all", true),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns2-b", false),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns2-all", false),
+						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns-root-c", false),
+					}
+					for _, c := range cases {
+						c(t)
+					}
+				})
 			}
 		})
 }
@@ -326,7 +361,7 @@ func TestAuthorization_Deny(t *testing.T) {
 			// TODO: Convert into multicluster support. Currently reachability does
 			// not cover all clusters.
 			if t.Clusters().IsMulticluster() {
-				t.Skip()
+				t.Skip("https://github.com/istio/istio/issues/37307")
 			}
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
@@ -353,55 +388,66 @@ func TestAuthorization_Deny(t *testing.T) {
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
 			for _, srcCluster := range t.Clusters() {
-				t.NewSubTest(fmt.Sprintf("From %s", srcCluster.StableName())).Run(func(t framework.TestContext) {
-					a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
-					util.CheckExistence(t, a)
-					newTestCase := func(target echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-						return rbacUtil.TestCase{
-							Request: connection.Checker{
-								From: a[0],
-								Options: echo.CallOptions{
-									Target:   target[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
-									Path:     path,
-									Count:    callCount,
-								},
-								DestClusters: target.Clusters(),
-							},
-							ExpectAllowed: expectAllowed,
+				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
+				if len(a) == 0 {
+					continue
+				}
+
+				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
+					newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
+						return func(t framework.TestContext) {
+							opts := echo.CallOptions{
+								Target:   to[0],
+								PortName: "http",
+								Scheme:   scheme.HTTP,
+								Path:     path,
+								Count:    callCount,
+							}
+							if expectAllowed {
+								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+							} else {
+								opts.Check = scheck.RBACFailure(&opts)
+							}
+
+							name := newRbacTestName("", expectAllowed, from, &opts)
+							t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+								name.SkipIfNecessary(t)
+								from.CallWithRetryOrFail(t, opts)
+							})
 						}
 					}
-					cases := []rbacUtil.TestCase{
-						newTestCase(b, "/deny", false),
-						newTestCase(b, "/deny?param=value", false),
-						newTestCase(b, "/global-deny", false),
-						newTestCase(b, "/global-deny?param=value", false),
-						newTestCase(b, "/other", true),
-						newTestCase(b, "/other?param=value", true),
-						newTestCase(b, "/allow", true),
-						newTestCase(b, "/allow?param=value", true),
-						newTestCase(c, "/allow/admin", false),
-						newTestCase(c, "/allow/admin?param=value", false),
-						newTestCase(c, "/global-deny", false),
-						newTestCase(c, "/global-deny?param=value", false),
-						newTestCase(c, "/other", false),
-						newTestCase(c, "/other?param=value", false),
-						newTestCase(c, "/allow", true),
-						newTestCase(c, "/allow?param=value", true),
+					cases := []func(t framework.TestContext){
+						newTestCase(a[0], b, "/deny", false),
+						newTestCase(a[0], b, "/deny?param=value", false),
+						newTestCase(a[0], b, "/global-deny", false),
+						newTestCase(a[0], b, "/global-deny?param=value", false),
+						newTestCase(a[0], b, "/other", true),
+						newTestCase(a[0], b, "/other?param=value", true),
+						newTestCase(a[0], b, "/allow", true),
+						newTestCase(a[0], b, "/allow?param=value", true),
+						newTestCase(a[0], c, "/allow/admin", false),
+						newTestCase(a[0], c, "/allow/admin?param=value", false),
+						newTestCase(a[0], c, "/global-deny", false),
+						newTestCase(a[0], c, "/global-deny?param=value", false),
+						newTestCase(a[0], c, "/other", false),
+						newTestCase(a[0], c, "/other?param=value", false),
+						newTestCase(a[0], c, "/allow", true),
+						newTestCase(a[0], c, "/allow?param=value", true),
 
 						// TODO(JimmyCYJ): support multiple VMs and test deny policies on multiple VMs.
-						newTestCase(vm, "/allow/admin", false),
-						newTestCase(vm, "/allow/admin?param=value", false),
-						newTestCase(vm, "/global-deny", false),
-						newTestCase(vm, "/global-deny?param=value", false),
-						newTestCase(vm, "/other", false),
-						newTestCase(vm, "/other?param=value", false),
-						newTestCase(vm, "/allow", true),
-						newTestCase(vm, "/allow?param=value", true),
+						newTestCase(a[0], vm, "/allow/admin", false),
+						newTestCase(a[0], vm, "/allow/admin?param=value", false),
+						newTestCase(a[0], vm, "/global-deny", false),
+						newTestCase(a[0], vm, "/global-deny?param=value", false),
+						newTestCase(a[0], vm, "/other", false),
+						newTestCase(a[0], vm, "/other?param=value", false),
+						newTestCase(a[0], vm, "/allow", true),
+						newTestCase(a[0], vm, "/allow?param=value", true),
 					}
 
-					rbacUtil.RunRBACTest(t, cases)
+					for _, c := range cases {
+						c(t)
+					}
 				})
 			}
 		})
@@ -437,31 +483,40 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
 			for _, srcCluster := range t.Clusters() {
-				t.NewSubTest(fmt.Sprintf("From %s", srcCluster.StableName())).Run(func(t framework.TestContext) {
-					a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
-					bInNS2 := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace2.Name())))
-					util.CheckExistence(t, a, bInNS2)
-					newTestCase := func(from echo.Instance, target echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-						return rbacUtil.TestCase{
-							Request: connection.Checker{
-								From: from,
-								Options: echo.CallOptions{
-									Target:   target[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
-									Path:     path,
-									Count:    callCount,
-								},
-								DestClusters: target.Clusters(),
-							},
-							ExpectAllowed: expectAllowed,
+				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
+				bInNS2 := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace2.Name())))
+				if len(a) == 0 || len(bInNS2) == 0 {
+					continue
+				}
+
+				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
+					newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
+						return func(t framework.TestContext) {
+							opts := echo.CallOptions{
+								Target:   to[0],
+								PortName: "http",
+								Scheme:   scheme.HTTP,
+								Path:     path,
+								Count:    callCount,
+							}
+							if expectAllowed {
+								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+							} else {
+								opts.Check = scheck.RBACFailure(&opts)
+							}
+
+							name := newRbacTestName("", expectAllowed, from, &opts)
+							t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+								name.SkipIfNecessary(t)
+								from.CallWithRetryOrFail(t, opts)
+							})
 						}
 					}
 
 					// a, b, c and d are in the same namespace and another b(bInNs2) is in a different namespace.
 					// a connects to b, c and d in ns1 with mTLS.
 					// bInNs2 connects to b and c with mTLS, to d with plain-text.
-					cases := []rbacUtil.TestCase{
+					cases := []func(testContext framework.TestContext){
 						// Test the policy with overlapped `paths` and `not_paths` on b.
 						// a and bInNs2 should have the same results:
 						// - path with prefix `/prefix` should be denied explicitly.
@@ -504,7 +559,9 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 						newTestCase(bInNS2[0], vm, "/allow", true),
 					}
 
-					rbacUtil.RunRBACTest(t, cases)
+					for _, c := range cases {
+						c(t)
+					}
 				})
 			}
 		})
@@ -523,7 +580,7 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 			// running on a VM.
 			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
 			for _, dst := range []echo.Instances{b, vm} {
-				t.NewSubTest(fmt.Sprintf("to %s/", dst[0].Config().Service)).Run(func(t framework.TestContext) {
+				t.NewSubTestf("to %s/", dst[0].Config().Service).Run(func(t framework.TestContext) {
 					args := map[string]string{
 						"Namespace":     ns.Name(),
 						"RootNamespace": rootns.Name(),
@@ -685,10 +742,15 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 
 					for _, tc := range cases {
 						t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
-							headers := map[string][]string{
-								"X-Forwarded-For": {tc.IP},
+							opts := echo.CallOptions{
+								Port: &echo.Port{
+									Protocol: protocol.HTTP,
+								},
+								Path:    tc.Path,
+								Headers: headers.New().WithHost(tc.Host).WithXForwardedFor(tc.IP).Build(),
+								Check:   check.Status(tc.WantCode),
 							}
-							authn.CheckIngressOrFail(t, ingr, tc.Host, tc.Path, headers, "", tc.WantCode)
+							ingr.CallWithRetryOrFail(t, opts)
 						})
 					}
 				})
@@ -711,7 +773,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 			// policies at gateways are useful for managing accessibility to external
 			// services running on a VM.
 			for _, a := range []echo.Instances{a, vm} {
-				t.NewSubTest(fmt.Sprintf("to %s/", a[0].Config().Service)).Run(func(t framework.TestContext) {
+				t.NewSubTestf("to %s/", a[0].Config().Service).Run(func(t framework.TestContext) {
 					args := map[string]string{
 						"Namespace":     ns.Name(),
 						"RootNamespace": rootns.Name(),
@@ -821,34 +883,26 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 					for _, tc := range cases {
 						request := &epb.ForwardEchoRequest{
 							// Use a fake IP to make sure the request is handled by our test.
-							Url:   fmt.Sprintf("http://10.4.4.4%s", tc.path),
-							Count: 1,
-							Headers: []*epb.Header{
-								{
-									Key:   "Host",
-									Value: tc.host,
-								},
-							},
-						}
-						if tc.token != "" {
-							request.Headers = append(request.Headers, &epb.Header{
-								Key:   "Authorization",
-								Value: "Bearer " + tc.token,
-							})
+							Url:     fmt.Sprintf("http://10.4.4.4%s", tc.path),
+							Count:   1,
+							Headers: echoCommon.HTTPToProtoHeaders(headers.New().WithHost(tc.host).WithAuthz(tc.token).Build()),
 						}
 						t.NewSubTest(tc.name).Run(func(t framework.TestContext) {
 							retry.UntilSuccessOrFail(t, func() error {
-								responses, err := tc.from.ForwardEcho(context.TODO(), request)
+								rs, err := tc.from.ForwardEcho(context.TODO(), request)
+								if err != nil {
+									return err
+								}
 								return check.And(
 									check.NoError(),
-									check.StatusCode(tc.code),
+									check.Status(tc.code),
 									check.Each(func(r echoClient.Response) error {
 										if !strings.Contains(r.RawContent, tc.body) {
-											return fmt.Errorf("want %q in body but not found: %s", tc.body, responses[0].RawContent)
+											return fmt.Errorf("want %q in body but not found: %s", tc.body, r.RawContent)
 										}
 										return nil
-									})).Check(responses, err)
-							}, retry.Delay(250*time.Millisecond), retry.Timeout(30*time.Second))
+									})).Check(rs, err)
+							}, echo.DefaultCallRetryOptions()...)
 						})
 					}
 				})
@@ -861,20 +915,28 @@ func TestAuthorization_TCP(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.tcp").
 		Run(func(t framework.TestContext) {
-			newTestCase := func(from, target echo.Instances, port string, expectAllowed bool, scheme scheme.Instance) rbacUtil.TestCase {
-				return rbacUtil.TestCase{
-					Request: connection.Checker{
-						From: from[0],
-						Options: echo.CallOptions{
-							Target:   target[0],
-							PortName: port,
-							Scheme:   scheme,
-							Path:     "/data",
-						},
-					},
-					ExpectAllowed: expectAllowed,
+			newTestCase := func(from echo.Instance, to echo.Instances, s scheme.Instance, portName string, expectAllowed bool) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					opts := echo.CallOptions{
+						Target:   to[0],
+						PortName: portName,
+						Scheme:   s,
+						Path:     "/data",
+					}
+					if expectAllowed {
+						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+					} else {
+						opts.Check = scheck.RBACFailure(&opts)
+					}
+
+					name := newRbacTestName("", expectAllowed, from, &opts)
+					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+						name.SkipIfNecessary(t)
+						from.CallWithRetryOrFail(t, opts)
+					})
 				}
 			}
+
 			ns := apps.Namespace1
 			ns2 := apps.Namespace2
 			a := apps.A.Match(echo.Namespace(ns.Name()))
@@ -883,7 +945,7 @@ func TestAuthorization_TCP(t *testing.T) {
 			eInNS2 := apps.E.Match(echo.Namespace(ns2.Name()))
 			d := apps.D.Match(echo.Namespace(ns.Name()))
 			e := apps.E.Match(echo.Namespace(ns.Name()))
-			t.NewSubTest("").
+			t.NewSubTest("non-vms").
 				Run(func(t framework.TestContext) {
 					policy := tmpl.EvaluateAllOrFail(t, map[string]string{
 						"Namespace":  ns.Name(),
@@ -895,14 +957,14 @@ func TestAuthorization_TCP(t *testing.T) {
 						"a":          a[0].Config().Service,
 					}, file.AsStringOrFail(t, "testdata/authz/v1beta1-tcp.yaml.tmpl"))
 					t.ConfigIstio().ApplyYAMLOrFail(t, "", policy...)
-					cases := []rbacUtil.TestCase{
+					cases := []func(testContext framework.TestContext){
 						// The policy on workload b denies request with path "/data" to port 8091:
 						// - request to port http-8091 should be denied because both path and port are matched.
 						// - request to port http-8092 should be allowed because the port is not matched.
 						// - request to port tcp-8093 should be allowed because the port is not matched.
-						newTestCase(a, b, "http-8091", false, scheme.HTTP),
-						newTestCase(a, b, "http-8092", true, scheme.HTTP),
-						newTestCase(a, b, "tcp-8093", true, scheme.TCP),
+						newTestCase(a[0], b, scheme.HTTP, "http-8091", false),
+						newTestCase(a[0], b, scheme.HTTP, "http-8092", true),
+						newTestCase(a[0], b, scheme.TCP, "tcp-8093", true),
 
 						// The policy on workload c denies request to port 8091:
 						// - request to port http-8091 should be denied because the port is matched.
@@ -912,13 +974,13 @@ func TestAuthorization_TCP(t *testing.T) {
 						// - request from b to tcp port 8094 should be denied because the principal is matched.
 						// - request from eInNS2 to tcp port 8093 should be denied because the namespace is matched.
 						// - request from eInNS2 to tcp port 8094 should be allowed by default.
-						newTestCase(a, c, "http-8091", false, scheme.HTTP),
-						newTestCase(a, c, "http-8092", true, scheme.HTTP),
-						newTestCase(a, c, "tcp-8093", true, scheme.TCP),
-						newTestCase(b, c, "tcp-8093", true, scheme.TCP),
-						newTestCase(b, c, "tcp-8094", false, scheme.TCP),
-						newTestCase(eInNS2, c, "tcp-8093", false, scheme.TCP),
-						newTestCase(eInNS2, c, "tcp-8094", true, scheme.TCP),
+						newTestCase(a[0], c, scheme.HTTP, "http-8091", false),
+						newTestCase(a[0], c, scheme.HTTP, "http-8092", true),
+						newTestCase(a[0], c, scheme.TCP, "tcp-8093", true),
+						newTestCase(b[0], c, scheme.TCP, "tcp-8093", true),
+						newTestCase(b[0], c, scheme.TCP, "tcp-8094", false),
+						newTestCase(eInNS2[0], c, scheme.TCP, "tcp-8093", false),
+						newTestCase(eInNS2[0], c, scheme.TCP, "tcp-8094", true),
 
 						// The policy on workload d denies request from service account a and workloads in namespace 2:
 						// - request from a to d should be denied because it has service account a.
@@ -926,26 +988,28 @@ func TestAuthorization_TCP(t *testing.T) {
 						// - request from c to d should be allowed.
 						// - request from eInNS2 to a should be allowed because there is no policy on a.
 						// - request from eInNS2 to d should be denied because it's in namespace 2.
-						newTestCase(a, d, "tcp-8093", false, scheme.TCP),
-						newTestCase(b, d, "tcp-8093", true, scheme.TCP),
-						newTestCase(c, d, "tcp-8093", true, scheme.TCP),
-						newTestCase(eInNS2, a, "tcp-8093", true, scheme.TCP),
-						newTestCase(eInNS2, d, "tcp-8093", false, scheme.TCP),
+						newTestCase(a[0], d, scheme.TCP, "tcp-8093", false),
+						newTestCase(b[0], d, scheme.TCP, "tcp-8093", true),
+						newTestCase(c[0], d, scheme.TCP, "tcp-8093", true),
+						newTestCase(eInNS2[0], a, scheme.TCP, "tcp-8093", true),
+						newTestCase(eInNS2[0], d, scheme.TCP, "tcp-8093", false),
 
 						// The policy on workload e denies request with path "/other":
 						// - request to port http-8091 should be allowed because the path is not matched.
 						// - request to port http-8092 should be allowed because the path is not matched.
 						// - request to port tcp-8093 should be denied because policy uses HTTP fields.
-						newTestCase(a, e, "http-8091", true, scheme.HTTP),
-						newTestCase(a, e, "http-8092", true, scheme.HTTP),
-						newTestCase(a, e, "tcp-8093", false, scheme.TCP),
+						newTestCase(a[0], e, scheme.HTTP, "http-8091", true),
+						newTestCase(a[0], e, scheme.HTTP, "http-8092", true),
+						newTestCase(a[0], e, scheme.TCP, "tcp-8093", false),
 					}
 
-					rbacUtil.RunRBACTest(t, cases)
+					for _, c := range cases {
+						c(t)
+					}
 				})
 			// TODO(JimmyCYJ): support multiple VMs and apply different security policies to each VM.
 			vm := apps.VM.Match(echo.Namespace(ns.Name()))
-			t.NewSubTest("").
+			t.NewSubTest("vms").
 				Run(func(t framework.TestContext) {
 					policy := tmpl.EvaluateAllOrFail(t, map[string]string{
 						"Namespace":  ns.Name(),
@@ -957,7 +1021,7 @@ func TestAuthorization_TCP(t *testing.T) {
 						"a":          a[0].Config().Service,
 					}, file.AsStringOrFail(t, "testdata/authz/v1beta1-tcp.yaml.tmpl"))
 					t.ConfigIstio().ApplyYAMLOrFail(t, "", policy...)
-					cases := []rbacUtil.TestCase{
+					cases := []func(testContext framework.TestContext){
 						// The policy on workload vm denies request to port 8091:
 						// - request to port http-8091 should be denied because the port is matched.
 						// - request to http port 8092 should be allowed because the port is not matched.
@@ -966,15 +1030,17 @@ func TestAuthorization_TCP(t *testing.T) {
 						// - request from b to tcp port 8094 should be denied because the principal is matched.
 						// - request from eInNS2 to tcp port 8093 should be denied because the namespace is matched.
 						// - request from eInNS2 to tcp port 8094 should be allowed by default.
-						newTestCase(a, vm, "http-8091", false, scheme.HTTP),
-						newTestCase(a, vm, "http-8092", true, scheme.HTTP),
-						newTestCase(a, vm, "tcp-8093", true, scheme.TCP),
-						newTestCase(b, vm, "tcp-8093", true, scheme.TCP),
-						newTestCase(b, vm, "tcp-8094", false, scheme.TCP),
-						newTestCase(eInNS2, vm, "tcp-8093", false, scheme.TCP),
-						newTestCase(eInNS2, vm, "tcp-8094", true, scheme.TCP),
+						newTestCase(a[0], vm, scheme.HTTP, "http-8091", false),
+						newTestCase(a[0], vm, scheme.HTTP, "http-8092", true),
+						newTestCase(a[0], vm, scheme.TCP, "tcp-8093", true),
+						newTestCase(b[0], vm, scheme.TCP, "tcp-8093", true),
+						newTestCase(b[0], vm, scheme.TCP, "tcp-8094", false),
+						newTestCase(eInNS2[0], vm, scheme.TCP, "tcp-8093", false),
+						newTestCase(eInNS2[0], vm, scheme.TCP, "tcp-8094", true),
+					}
+					for _, c := range cases {
+						c(t)
 					}
-					rbacUtil.RunRBACTest(t, cases)
 				})
 		})
 }
@@ -997,8 +1063,8 @@ func TestAuthorization_Conditions(t *testing.T) {
 						t.Skip()
 					}
 					b := bs[0]
-					t.NewSubTest(fmt.Sprintf("from %s to %s in %s",
-						a.Config().Cluster.StableName(), cSet[0].Config().Service, cSet[0].Config().Cluster.StableName())).
+					t.NewSubTestf("from %s to %s in %s",
+						a.Config().Cluster.StableName(), cSet[0].Config().Service, cSet[0].Config().Cluster.StableName()).
 						Run(func(t framework.TestContext) {
 							var ipC string
 							for i := 0; i < len(cSet); i++ {
@@ -1026,79 +1092,88 @@ func TestAuthorization_Conditions(t *testing.T) {
 								// so we can validate all clusters are hit
 								callCount = util.CallsPerCluster * len(t.Clusters())
 							}
-							newTestCase := func(from echo.Instance, path string, headers map[string]string, expectAllowed bool) rbacUtil.TestCase {
-								return rbacUtil.TestCase{
-									Request: connection.Checker{
-										From: from,
-										Options: echo.CallOptions{
-											Target:   cSet[0],
-											PortName: "http",
-											Scheme:   scheme.HTTP,
-											Path:     path,
-											Count:    callCount,
-										},
-										DestClusters: cSet.Clusters(),
-									},
-									Headers:       headers,
-									ExpectAllowed: expectAllowed,
+							newTestCase := func(from echo.Instance, to echo.Instances, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
+								return func(t framework.TestContext) {
+									opts := echo.CallOptions{
+										Target:   to[0],
+										PortName: "http",
+										Scheme:   scheme.HTTP,
+										Path:     path,
+										Headers:  headers,
+										Count:    callCount,
+									}
+									if expectAllowed {
+										opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+									} else {
+										opts.Check = scheck.RBACFailure(&opts)
+									}
+
+									name := newRbacTestName("", expectAllowed, from, &opts)
+									t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+										name.SkipIfNecessary(t)
+										from.CallWithRetryOrFail(t, opts)
+									})
 								}
 							}
-							cases := []rbacUtil.TestCase{
-								newTestCase(a, "/request-headers", map[string]string{"x-foo": "foo"}, true),
-								newTestCase(b, "/request-headers", map[string]string{"x-foo": "foo"}, true),
-								newTestCase(a, "/request-headers", map[string]string{"x-foo": "bar"}, false),
-								newTestCase(b, "/request-headers", map[string]string{"x-foo": "bar"}, false),
-								newTestCase(a, "/request-headers", nil, false),
-								newTestCase(b, "/request-headers", nil, false),
-								newTestCase(a, "/request-headers-notValues-bar", map[string]string{"x-foo": "foo"}, true),
-								newTestCase(a, "/request-headers-notValues-bar", map[string]string{"x-foo": "bar"}, false),
-
-								newTestCase(a, fmt.Sprintf("/source-ip-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-ip-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-ip-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-ip-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, fmt.Sprintf("/source-principal-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-principal-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-principal-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-principal-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, "/destination-ip-good", nil, true),
-								newTestCase(b, "/destination-ip-good", nil, true),
-								newTestCase(a, "/destination-ip-bad", nil, false),
-								newTestCase(b, "/destination-ip-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/destination-ip-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/destination-ip-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
-
-								newTestCase(a, "/destination-port-good", nil, true),
-								newTestCase(b, "/destination-port-good", nil, true),
-								newTestCase(a, "/destination-port-bad", nil, false),
-								newTestCase(b, "/destination-port-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
-
-								newTestCase(a, "/connection-sni-good", nil, true),
-								newTestCase(b, "/connection-sni-good", nil, true),
-								newTestCase(a, "/connection-sni-bad", nil, false),
-								newTestCase(b, "/connection-sni-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/connection-sni-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/connection-sni-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
-
-								newTestCase(a, "/other", nil, false),
-								newTestCase(b, "/other", nil, false),
+
+							cases := []func(framework.TestContext){
+								newTestCase(a, cSet, "/request-headers", headers.New().With("x-foo", "foo").Build(), true),
+								newTestCase(b, cSet, "/request-headers", headers.New().With("x-foo", "foo").Build(), true),
+								newTestCase(a, cSet, "/request-headers", headers.New().With("x-foo", "bar").Build(), false),
+								newTestCase(b, cSet, "/request-headers", headers.New().With("x-foo", "bar").Build(), false),
+								newTestCase(a, cSet, "/request-headers", nil, false),
+								newTestCase(b, cSet, "/request-headers", nil, false),
+								newTestCase(a, cSet, "/request-headers-notValues-bar", headers.New().With("x-foo", "foo").Build(), true),
+								newTestCase(a, cSet, "/request-headers-notValues-bar", headers.New().With("x-foo", "bar").Build(), false),
+
+								newTestCase(a, cSet, fmt.Sprintf("/source-ip-%s", args["a"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-ip-%s", args["a"]), nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/source-ip-%s", args["b"]), nil, false),
+								newTestCase(b, cSet, fmt.Sprintf("/source-ip-%s", args["b"]), nil, true),
+								newTestCase(a, cSet, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, false),
+
+								newTestCase(a, cSet, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, false),
+								newTestCase(b, cSet, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, true),
+								newTestCase(a, cSet, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, false),
+
+								newTestCase(a, cSet, fmt.Sprintf("/source-principal-%s", args["a"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-principal-%s", args["a"]), nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/source-principal-%s", args["b"]), nil, false),
+								newTestCase(b, cSet, fmt.Sprintf("/source-principal-%s", args["b"]), nil, true),
+								newTestCase(a, cSet, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, true),
+								newTestCase(b, cSet, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, false),
+
+								newTestCase(a, cSet, "/destination-ip-good", nil, true),
+								newTestCase(b, cSet, "/destination-ip-good", nil, true),
+								newTestCase(a, cSet, "/destination-ip-bad", nil, false),
+								newTestCase(b, cSet, "/destination-ip-bad", nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/destination-ip-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
+								newTestCase(a, cSet, fmt.Sprintf("/destination-ip-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
+
+								newTestCase(a, cSet, "/destination-port-good", nil, true),
+								newTestCase(b, cSet, "/destination-port-good", nil, true),
+								newTestCase(a, cSet, "/destination-port-bad", nil, false),
+								newTestCase(b, cSet, "/destination-port-bad", nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
+								newTestCase(b, cSet, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
+
+								newTestCase(a, cSet, "/connection-sni-good", nil, true),
+								newTestCase(b, cSet, "/connection-sni-good", nil, true),
+								newTestCase(a, cSet, "/connection-sni-bad", nil, false),
+								newTestCase(b, cSet, "/connection-sni-bad", nil, false),
+								newTestCase(a, cSet, fmt.Sprintf("/connection-sni-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
+								newTestCase(a, cSet, fmt.Sprintf("/connection-sni-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
+
+								newTestCase(a, cSet, "/other", nil, false),
+								newTestCase(b, cSet, "/other", nil, false),
+							}
+							for _, c := range cases {
+								c(t)
 							}
-							rbacUtil.RunRBACTest(t, cases)
 						})
 				}
 			}
@@ -1121,7 +1196,7 @@ func TestAuthorization_GRPC(t *testing.T) {
 					if a[0].Config().Service == b[0].Config().Service {
 						t.Skip()
 					}
-					t.NewSubTest(fmt.Sprintf("to %s in %s", a[0].Config().Service, a[0].Config().Cluster.StableName())).
+					t.NewSubTestf("to %s in %s", a[0].Config().Service, a[0].Config().Cluster.StableName()).
 						Run(func(t framework.TestContext) {
 							args := map[string]string{
 								"Namespace": ns.Name(),
@@ -1134,43 +1209,35 @@ func TestAuthorization_GRPC(t *testing.T) {
 								file.AsStringOrFail(t, "testdata/authz/v1beta1-grpc.yaml.tmpl"))
 							t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
 							t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
-							cases := []rbacUtil.TestCase{
-								{
-									Request: connection.Checker{
-										From: b[0],
-										Options: echo.CallOptions{
-											Target:   a[0],
-											PortName: "grpc",
-											Scheme:   scheme.GRPC,
-										},
-									},
-									ExpectAllowed: true,
-								},
-								{
-									Request: connection.Checker{
-										From: c[0],
-										Options: echo.CallOptions{
-											Target:   a[0],
-											PortName: "grpc",
-											Scheme:   scheme.GRPC,
-										},
-									},
-									ExpectAllowed: false,
-								},
-								{
-									Request: connection.Checker{
-										From: d[0],
-										Options: echo.CallOptions{
-											Target:   a[0],
-											PortName: "grpc",
-											Scheme:   scheme.GRPC,
-										},
-									},
-									ExpectAllowed: true,
-								},
+							newTestCase := func(from echo.Instance, to echo.Instances, expectAllowed bool) func(t framework.TestContext) {
+								return func(t framework.TestContext) {
+									opts := echo.CallOptions{
+										Target:   to[0],
+										PortName: "grpc",
+										Scheme:   scheme.GRPC,
+									}
+									if expectAllowed {
+										opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+									} else {
+										opts.Check = scheck.RBACFailure(&opts)
+									}
+
+									name := newRbacTestName("", expectAllowed, from, &opts)
+									t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+										name.SkipIfNecessary(t)
+										from.CallWithRetryOrFail(t, opts)
+									})
+								}
+							}
+							cases := []func(testContext framework.TestContext){
+								newTestCase(b[0], a, true),
+								newTestCase(c[0], a, false),
+								newTestCase(d[0], a, true),
 							}
 
-							rbacUtil.RunRBACTest(t, cases)
+							for _, c := range cases {
+								c(t)
+							}
 						})
 				}
 			}
@@ -1188,9 +1255,12 @@ func TestAuthorization_Path(t *testing.T) {
 			vm := apps.VM.Match(echo.Namespace(ns.Name()))
 			for _, a := range []echo.Instances{a, vm} {
 				for _, srcCluster := range t.Clusters() {
-					t.NewSubTest(fmt.Sprintf("In %s", srcCluster.StableName())).Run(func(t framework.TestContext) {
-						b := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
-						util.CheckExistence(t, b)
+					b := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
+					if len(b) == 0 {
+						continue
+					}
+
+					t.NewSubTestf("In %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 						args := map[string]string{
 							"Namespace": ns.Name(),
 							"a":         a[0].Config().Service,
@@ -1206,37 +1276,45 @@ func TestAuthorization_Path(t *testing.T) {
 							callCount = util.CallsPerCluster * len(t.Clusters())
 						}
 
-						newTestCase := func(to echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-							return rbacUtil.TestCase{
-								Request: connection.Checker{
-									From: b[0],
-									Options: echo.CallOptions{
-										Target:   to[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
-										Path:     path,
-										Count:    callCount,
-									},
-									DestClusters: a.Clusters(),
-								},
-								ExpectAllowed: expectAllowed,
+						newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
+							return func(t framework.TestContext) {
+								opts := echo.CallOptions{
+									Target:   to[0],
+									PortName: "http",
+									Scheme:   scheme.HTTP,
+									Path:     path,
+									Count:    callCount,
+								}
+								if expectAllowed {
+									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+								} else {
+									opts.Check = scheck.RBACFailure(&opts)
+								}
+
+								name := newRbacTestName("", expectAllowed, from, &opts)
+								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+									name.SkipIfNecessary(t)
+									from.CallWithRetryOrFail(t, opts)
+								})
 							}
 						}
-						cases := []rbacUtil.TestCase{
-							newTestCase(a, "/public", true),
-							newTestCase(a, "/public/../public", true),
-							newTestCase(a, "/private", false),
-							newTestCase(a, "/public/../private", false),
-							newTestCase(a, "/public/./../private", false),
-							newTestCase(a, "/public/.././private", false),
-							newTestCase(a, "/public/%2E%2E/private", false),
-							newTestCase(a, "/public/%2e%2e/private", false),
-							newTestCase(a, "/public/%2E/%2E%2E/private", false),
-							newTestCase(a, "/public/%2e/%2e%2e/private", false),
-							newTestCase(a, "/public/%2E%2E/%2E/private", false),
-							newTestCase(a, "/public/%2e%2e/%2e/private", false),
+						cases := []func(test framework.TestContext){
+							newTestCase(b[0], a, "/public", true),
+							newTestCase(b[0], a, "/public/../public", true),
+							newTestCase(b[0], a, "/private", false),
+							newTestCase(b[0], a, "/public/../private", false),
+							newTestCase(b[0], a, "/public/./../private", false),
+							newTestCase(b[0], a, "/public/.././private", false),
+							newTestCase(b[0], a, "/public/%2E%2E/private", false),
+							newTestCase(b[0], a, "/public/%2e%2e/private", false),
+							newTestCase(b[0], a, "/public/%2E/%2E%2E/private", false),
+							newTestCase(b[0], a, "/public/%2e/%2e%2e/private", false),
+							newTestCase(b[0], a, "/public/%2E%2E/%2E/private", false),
+							newTestCase(b[0], a, "/public/%2e%2e/%2e/private", false),
+						}
+						for _, c := range cases {
+							c(t)
 						}
-						rbacUtil.RunRBACTest(t, cases)
 					})
 				}
 			}
@@ -1254,95 +1332,79 @@ func TestAuthorization_Audit(t *testing.T) {
 			d := apps.D.Match(echo.Namespace(ns.Name()))
 			vm := apps.VM.Match(echo.Namespace(ns.Name()))
 
-			newTestCase := func(from, to echo.Instances, path string, expectAllowed bool) rbacUtil.TestCase {
-				return rbacUtil.TestCase{
-					Request: connection.Checker{
-						From: from[0],
-						Options: echo.CallOptions{
-							Target:   to[0],
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     path,
-						},
-					},
-					ExpectAllowed: expectAllowed,
-				}
-			}
-
-			cases := []rbacUtil.TestCase{
-				newTestCase(a, b, "/allow", true),
-				newTestCase(a, b, "/audit", false),
-				newTestCase(a, c, "/audit", true),
-				newTestCase(a, c, "/deny", false),
-				newTestCase(a, d, "/audit", true),
-				newTestCase(a, d, "/other", true),
-			}
-			t.NewSubTest(fmt.Sprintf("from %s in %s", a[0].Config().Service, a[0].Config().Cluster.StableName())).
-				Run(func(t framework.TestContext) {
-					args := map[string]string{
+			policy := func(filename string) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					yamlText := tmpl.EvaluateAllOrFail(t, map[string]string{
 						"b":             b[0].Config().Service,
 						"c":             c[0].Config().Service,
 						"d":             d[0].Config().Service,
 						"Namespace":     ns.Name(),
 						"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
+					}, file.AsStringOrFail(t, filename))
+					t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), yamlText...)
+					t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), yamlText...)
+				}
+			}
+
+			vmPolicy := func(filename string) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					yamlText := tmpl.EvaluateAllOrFail(t, map[string]string{
+						"Namespace": ns.Name(),
+						"dst":       vm[0].Config().Service,
+					}, file.AsStringOrFail(t, filename))
+					t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), yamlText...)
+					t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), yamlText...)
+				}
+			}
+
+			newTestCase := func(applyPolicy func(t framework.TestContext), from echo.Instance, to echo.Instances,
+				path string, expectAllowed bool) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					opts := echo.CallOptions{
+						Target:   to[0],
+						PortName: "http",
+						Scheme:   scheme.HTTP,
+						Path:     path,
 					}
-					applyPolicy := func(filename string, ns namespace.Instance) {
-						policy := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, filename))
-						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
+					if expectAllowed {
+						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+					} else {
+						opts.Check = scheck.RBACFailure(&opts)
 					}
-					applyPolicy("testdata/authz/v1beta1-audit.yaml.tmpl", ns)
 
-					rbacUtil.RunRBACTest(t, cases)
-				})
+					name := newRbacTestName("", expectAllowed, from, &opts)
+					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+						name.SkipIfNecessary(t)
 
-			// (TODO)JimmyCYJ: Support multiple VMs and apply audit policies to multiple VMs for testing.
-			// The tests below are duplicated from above for VM workloads. With support for multiple VMs,
-			// These tests will be merged to the tests above.
-			vmCases := []struct {
-				configFile string
-				dst        echo.Instances
-				subCases   []rbacUtil.TestCase
-			}{
-				{
-					configFile: "testdata/authz/v1beta1-audit-allow.yaml.tmpl",
-					dst:        vm,
-					subCases: []rbacUtil.TestCase{
-						newTestCase(b, vm, "/allow", true),
-						newTestCase(b, vm, "/audit", false),
-					},
-				},
-				{
-					configFile: "testdata/authz/v1beta1-audit-deny.yaml.tmpl",
-					dst:        vm,
-					subCases: []rbacUtil.TestCase{
-						newTestCase(b, vm, "/audit", true),
-						newTestCase(b, vm, "/deny", false),
-					},
-				},
-				{
-					configFile: "testdata/authz/v1beta1-audit-default.yaml.tmpl",
-					dst:        vm,
-					subCases: []rbacUtil.TestCase{
-						newTestCase(b, vm, "/audit", true),
-						newTestCase(b, vm, "/other", true),
-					},
-				},
-			}
+						applyPolicy(t)
 
-			for _, tc := range vmCases {
-				t.NewSubTest(fmt.Sprintf("from %s to %s in %s",
-					b[0].Config().Cluster.StableName(), tc.dst[0].Config().Service, tc.dst[0].Config().Cluster.StableName())).
-					Run(func(t framework.TestContext) {
-						args := map[string]string{
-							"Namespace": ns.Name(),
-							"dst":       tc.dst[0].Config().Service,
-						}
-						policies := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, tc.configFile))
-						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
-						rbacUtil.RunRBACTest(t, tc.subCases)
+						from.CallWithRetryOrFail(t, opts)
 					})
+				}
+			}
+
+			cases := []func(t framework.TestContext){
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], b, "/allow", true),
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], b, "/audit", false),
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], c, "/audit", true),
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], c, "/deny", false),
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], d, "/audit", true),
+				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], d, "/other", true),
+
+				// (TODO)JimmyCYJ: Support multiple VMs and apply audit policies to multiple VMs for testing.
+				// The tests below are duplicated from above for VM workloads. With support for multiple VMs,
+				// These tests will be merged to the tests above.
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-allow.yaml.tmpl"), b[0], vm, "/allow", true),
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-allow.yaml.tmpl"), b[0], vm, "/audit", false),
+
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-deny.yaml.tmpl"), b[0], vm, "/audit", true),
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-deny.yaml.tmpl"), b[0], vm, "/deny", false),
+
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-default.yaml.tmpl"), b[0], vm, "/audit", true),
+				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-default.yaml.tmpl"), b[0], vm, "/other", true),
+			}
+			for _, c := range cases {
+				c(t)
 			}
 		})
 }
@@ -1444,117 +1506,170 @@ func TestAuthorization_Custom(t *testing.T) {
 				With(&x, echoConfig("x", false)).
 				BuildOrFail(t)
 
-			newTestCase := func(from, target echo.Instance, path, port string, header string, expectAllowed bool,
-				expectRequestHeaders []rbacUtil.ExpectHeaderContains, expectResponseHeaders []rbacUtil.ExpectHeaderContains,
-				scheme scheme.Instance) rbacUtil.TestCase {
-				return rbacUtil.TestCase{
-					Request: connection.Checker{
-						From: from,
-						Options: echo.CallOptions{
-							Target:   target,
-							PortName: port,
-							Scheme:   scheme,
-							Path:     path,
-						},
-					},
-					Headers: map[string]string{
-						"x-ext-authz":                            header,
-						"x-ext-authz-additional-header-override": "should-be-override",
-					},
-					ExpectAllowed:         expectAllowed,
-					ExpectRequestHeaders:  expectRequestHeaders,
-					ExpectResponseHeaders: expectResponseHeaders,
+			newTestCase := func(from, to echo.Instance, s scheme.Instance, port, path string, headers http.Header,
+				checker check.Checker, expectAllowed bool) func(t framework.TestContext) {
+				return func(t framework.TestContext) {
+					opts := echo.CallOptions{
+						Target:   to,
+						PortName: port,
+						Scheme:   s,
+						Path:     path,
+						Headers:  headers,
+					}
+					if expectAllowed {
+						opts.Check = check.And(check.OK(), scheck.ReachedClusters(echo.Instances{to}, &opts))
+					} else {
+						opts.Check = scheck.RBACFailure(&opts)
+					}
+					opts.Check = check.And(opts.Check, checker)
+
+					name := newRbacTestName("", expectAllowed, from, &opts)
+					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
+						name.SkipIfNecessary(t)
+						from.CallWithRetryOrFail(t, opts)
+					})
 				}
 			}
-			expectHTTPHeaders := []rbacUtil.ExpectHeaderContains{
-				{
-					// For ext authz HTTP server, we expect the check request to include the override value because it
-					// is configued in the ext-authz filter side.
-					Key:       "X-Ext-Authz-Check-Received",
-					Values:    []string{"additional-header-new-value", "additional-header-override-value"},
-					NotValues: []string{"should-be-override"},
-				},
-				{
-					Key:       "X-Ext-Authz-Additional-Header-Override",
-					Values:    []string{"additional-header-override-value"},
-					NotValues: []string{"should-be-override"},
-				},
+			checkHTTPHeaders := func(hType echoClient.HeaderType) check.Checker {
+				return check.And(
+					scheck.HeaderContains(hType, map[string][]string{
+						"X-Ext-Authz-Check-Received":             {"additional-header-new-value", "additional-header-override-value"},
+						"X-Ext-Authz-Additional-Header-Override": {"additional-header-override-value"},
+					}),
+					scheck.HeaderNotContains(hType, map[string][]string{
+						"X-Ext-Authz-Check-Received":             {"should-be-override"},
+						"X-Ext-Authz-Additional-Header-Override": {"should-be-override"},
+					}))
 			}
-			expectGRPCHeaders := []rbacUtil.ExpectHeaderContains{
-				{
-					// For ext authz gRPC server, we expect the check request to include the original override value
-					// because the override is not configurable in the ext-authz filter side.
-					Key:    "X-Ext-Authz-Check-Received",
-					Values: []string{"should-be-override"},
-				},
-				{
-					Key:       "X-Ext-Authz-Additional-Header-Override",
-					Values:    []string{"grpc-additional-header-override-value"},
-					NotValues: []string{"should-be-override"},
-				},
+			checkGRPCHeaders := func(hType echoClient.HeaderType) check.Checker {
+				return check.And(
+					scheck.HeaderContains(hType, map[string][]string{
+						"X-Ext-Authz-Check-Received":             {"should-be-override"},
+						"X-Ext-Authz-Additional-Header-Override": {"grpc-additional-header-override-value"},
+					}),
+					scheck.HeaderNotContains(hType, map[string][]string{
+						"X-Ext-Authz-Additional-Header-Override": {"should-be-override"},
+					}))
+			}
+
+			authzHeaders := func(h string) http.Header {
+				return headers.New().With("x-ext-authz", h).With("x-ext-authz-additional-header-override", "should-be-override").Build()
 			}
 
 			// Path "/custom" is protected by ext-authz service and is accessible with the header `x-ext-authz: allow`.
 			// Path "/health" is not protected and is accessible to public.
-			cases := []rbacUtil.TestCase{
+			cases := []func(test framework.TestContext){
 				// workload b is using an ext-authz service in its own pod of HTTP API.
-				newTestCase(x, b, "/custom", "http", "allow", true, expectHTTPHeaders, nil, scheme.HTTP),
-				newTestCase(x, b, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
-				newTestCase(x, b, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
-				newTestCase(x, b, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
+				newTestCase(x, b, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
+				newTestCase(x, b, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
+				newTestCase(x, b, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
+				newTestCase(x, b, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
 
 				// workload c is using an ext-authz service in its own pod of gRPC API.
-				newTestCase(x, c, "/custom", "http", "allow", true, expectGRPCHeaders, nil, scheme.HTTP),
-				newTestCase(x, c, "/custom", "http", "deny", false, nil, expectGRPCHeaders, scheme.HTTP),
-				newTestCase(x, c, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
-				newTestCase(x, c, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
+				newTestCase(x, c, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkGRPCHeaders(echoClient.RequestHeader), true),
+				newTestCase(x, c, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkGRPCHeaders(echoClient.ResponseHeader), false),
+				newTestCase(x, c, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
+				newTestCase(x, c, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
 
 				// workload d is using an local ext-authz service in the same pod as the application of HTTP API.
-				newTestCase(x, d, "/custom", "http", "allow", true, expectHTTPHeaders, nil, scheme.HTTP),
-				newTestCase(x, d, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
-				newTestCase(x, d, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
-				newTestCase(x, d, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
+				newTestCase(x, d, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
+				newTestCase(x, d, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
+				newTestCase(x, d, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
+				newTestCase(x, d, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
 
 				// workload e is using an local ext-authz service in the same pod as the application of gRPC API.
-				newTestCase(x, e, "/custom", "http", "allow", true, expectGRPCHeaders, nil, scheme.HTTP),
-				newTestCase(x, e, "/custom", "http", "deny", false, nil, expectGRPCHeaders, scheme.HTTP),
-				newTestCase(x, e, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
-				newTestCase(x, e, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
+				newTestCase(x, e, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkGRPCHeaders(echoClient.RequestHeader), true),
+				newTestCase(x, e, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkGRPCHeaders(echoClient.ResponseHeader), false),
+				newTestCase(x, e, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
+				newTestCase(x, e, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
 
 				// workload f is using an ext-authz service in its own pod of TCP API.
-				newTestCase(a, f, "", "tcp-8092", "", true, nil, nil, scheme.TCP),
-				newTestCase(x, f, "", "tcp-8092", "", false, nil, nil, scheme.TCP),
-				newTestCase(a, f, "", "tcp-8093", "", true, nil, nil, scheme.TCP),
-				newTestCase(x, f, "", "tcp-8093", "", true, nil, nil, scheme.TCP),
+				newTestCase(a, f, scheme.TCP, "tcp-8092", "", authzHeaders(""), nil, true),
+				newTestCase(x, f, scheme.TCP, "tcp-8092", "", authzHeaders(""), nil, false),
+				newTestCase(a, f, scheme.TCP, "tcp-8093", "", authzHeaders(""), nil, true),
+				newTestCase(x, f, scheme.TCP, "tcp-8093", "", authzHeaders(""), nil, true),
 			}
 
-			rbacUtil.RunRBACTest(t, cases)
-
-			ingr := ist.IngressFor(t.Clusters().Default())
-			ingressCases := []rbacUtil.TestCase{
-				// workload g is using an ext-authz service in its own pod of HTTP API.
-				newTestCase(x, g, "/custom", "http", "allow", true, nil, expectHTTPHeaders, scheme.HTTP),
-				newTestCase(x, g, "/custom", "http", "deny", false, nil, expectHTTPHeaders, scheme.HTTP),
-				newTestCase(x, g, "/health", "http", "allow", true, nil, nil, scheme.HTTP),
-				newTestCase(x, g, "/health", "http", "deny", true, nil, nil, scheme.HTTP),
+			for _, c := range cases {
+				c(t)
 			}
+
 			t.NewSubTest("ingress").Run(func(t framework.TestContext) {
-				for _, tc := range ingressCases {
-					name := fmt.Sprintf("%s->%s:%s%s[%t]",
-						tc.Request.From.Config().Service,
-						tc.Request.Options.Target.Config().Service,
-						tc.Request.Options.PortName,
-						tc.Request.Options.Path,
-						tc.ExpectAllowed)
-
-					t.NewSubTest(name).Run(func(t framework.TestContext) {
-						wantCode := map[bool]int{true: http.StatusOK, false: http.StatusForbidden}[tc.ExpectAllowed]
-						headers := map[string][]string{
-							"X-Ext-Authz": {tc.Headers["x-ext-authz"]},
+				ingr := ist.IngressFor(t.Clusters().Default())
+				newIngressTestCase := func(from, to echo.Instance, path string, h http.Header,
+					checker check.Checker, expectAllowed bool) func(t framework.TestContext) {
+					return func(t framework.TestContext) {
+						opts := echo.CallOptions{
+							Port: &echo.Port{
+								Protocol: protocol.HTTP,
+							},
+							Scheme: scheme.HTTP,
+							Path:   path,
+							Headers: headers.New().
+								WithHost("www.company.com").
+								With("X-Ext-Authz", h.Get("x-ext-authz")).
+								Build(),
 						}
-						authn.CheckIngressOrFail(t, ingr, "www.company.com", tc.Request.Options.Path, headers, "", wantCode)
-					})
+						if expectAllowed {
+							opts.Check = check.And(check.OK(), scheck.ReachedClusters(echo.Instances{to}, &opts))
+						} else {
+							opts.Check = scheck.RBACFailure(&opts)
+						}
+						opts.Check = check.And(opts.Check, checker)
+
+						name := fmt.Sprintf("%s->%s%s[%t]",
+							from.Config().Service,
+							to.Config().Service,
+							path,
+							expectAllowed)
+
+						t.NewSubTest(name).Run(func(t framework.TestContext) {
+							ingr.CallWithRetryOrFail(t, opts)
+						})
+					}
+				}
+
+				ingressCases := []func(framework.TestContext){
+					// workload g is using an ext-authz service in its own pod of HTTP API.
+					newIngressTestCase(x, g, "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
+					newIngressTestCase(x, g, "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
+					newIngressTestCase(x, g, "/health", authzHeaders("allow"), nil, true),
+					newIngressTestCase(x, g, "/health", authzHeaders("deny"), nil, true),
+				}
+				for _, c := range ingressCases {
+					c(t)
 				}
 			})
 		})
 }
+
+type rbacTestName string
+
+func (n rbacTestName) String() string {
+	return string(n)
+}
+
+func (n rbacTestName) SkipIfNecessary(t framework.TestContext) {
+	t.Helper()
+
+	// Current source ip based authz test cases are not required in multicluster setup
+	// because cross-network traffic will lose the origin source ip info
+	if strings.Contains(n.String(), "source-ip") && t.Clusters().IsMulticluster() {
+		t.Skip("https://github.com/istio/istio/issues/37307")
+	}
+}
+
+func newRbacTestName(prefix string, expectAllowed bool, from echo.Instance, opts *echo.CallOptions) rbacTestName {
+	want := "deny"
+	if expectAllowed {
+		want = "allow"
+	}
+
+	return rbacTestName(fmt.Sprintf("%s%s->%s:%s%s[%s]",
+		prefix,
+		from.Config().Service,
+		opts.Target.Config().Service,
+		opts.PortName,
+		opts.Path,
+		want))
+}
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 7b4e8cfd31..1ca55c324f 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -368,7 +368,7 @@ func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions
 		Check: check.And(
 			check.NoError(),
 			check.And(
-				check.StatusCode(tc.StatusCode),
+				check.Status(tc.StatusCode),
 				check.Each(func(r echoClient.Response) error {
 					if _, f := r.RequestHeaders["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
 						return fmt.Errorf("expected to be handled by gateway. response: %s", r)
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index d066b39d6e..8f5b009d5e 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -232,7 +232,7 @@ type expect struct {
 							t.NewSubTest(tt.in).Run(func(t framework.TestContext) {
 								checker := check.URL(tt.out)
 								if tt.out == "400" {
-									checker = check.StatusCode(http.StatusBadRequest)
+									checker = check.Status(http.StatusBadRequest)
 								}
 								c.CallWithRetryOrFail(t, echo.CallOptions{
 									Target:   apps.B[0],
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 5ff19a9cd3..71f7844efe 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -665,7 +665,7 @@ func(instances echo.Instances) echo.Instances { return instances.Match(echo.Name
 											}
 										} else {
 											// Check HTTP forbidden response
-											if responses.Len() >= 1 && check.StatusCode(http.StatusForbidden).Check(responses, err) == nil {
+											if responses.Len() >= 1 && check.Status(http.StatusForbidden).Check(responses, err) == nil {
 												return nil
 											}
 
diff --git a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
index 96100ec9fa..d63de8b617 100644
--- a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
+++ b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
@@ -109,7 +109,7 @@ func doIstioMutualTest(
 
 		if err := check.And(
 			check.NoError(),
-			check.StatusCode(expectedCode)).Check(responses, err); err != nil {
+			check.Status(expectedCode)).Check(responses, err); err != nil {
 			ctx.Fatal(err)
 		}
 	}
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index e8c83f4908..9638696413 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -315,7 +315,7 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 				return nil
 			}
 
-			return check.StatusCode(exRsp.StatusCode).Check(resp, nil)
+			return check.Status(exRsp.StatusCode).Check(resp, nil)
 		},
 	}
 
diff --git a/tests/integration/security/util/authn/authn_util.go b/tests/integration/security/util/authn/authn_util.go
index 75d24b3d5a..297934a368 100644
--- a/tests/integration/security/util/authn/authn_util.go
+++ b/tests/integration/security/util/authn/authn_util.go
@@ -52,7 +52,7 @@ func (c *TestCase) String() string {
 // CheckAuthn checks a request based on ExpectResponseCode.
 func (c *TestCase) CheckAuthn(responses echoclient.Responses, err error) error {
 	return check.And(
-		check.StatusCode(c.ExpectResponseCode),
+		check.Status(c.ExpectResponseCode),
 		check.RequestHeaders(c.ExpectHeaders),
 		check.Each(func(r echoclient.Response) error {
 			if c.ExpectResponseCode == http.StatusOK && c.DestClusters.IsMulticluster() {
@@ -78,7 +78,7 @@ func CheckIngressOrFail(ctx framework.TestContext, ingr ingress.Instance, host s
 		},
 		Path:    path,
 		Headers: headers,
-		Check:   check.StatusCode(expectResponseCode),
+		Check:   check.Status(expectResponseCode),
 	}
 	if len(token) != 0 {
 		opts.Headers["Authorization"] = []string{
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index a884cf4a29..d1ef762811 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -327,15 +327,6 @@ func IsMultiversion() echo.Matcher {
 	}
 }
 
-// CheckExistence skips the test if any instance is not available.
-func CheckExistence(ctx framework.TestContext, instances ...echo.Instances) {
-	for _, inst := range instances {
-		if inst == nil || len(inst) == 0 {
-			ctx.Skip()
-		}
-	}
-}
-
 // SourceFilter returns workload pod A with sidecar injected and VM
 func SourceFilter(t framework.TestContext, apps *EchoDeployments, ns string, skipVM bool) []echotest.Filter {
 	rt := []echotest.Filter{func(instances echo.Instances) echo.Instances {
diff --git a/tests/integration/security/util/rbac_util/util.go b/tests/integration/security/util/rbac_util/util.go
deleted file mode 100644
index 555e131701..0000000000
--- a/tests/integration/security/util/rbac_util/util.go
+++ /dev/null
@@ -1,171 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rbac
-
-import (
-	"fmt"
-	"net/http"
-	"strings"
-	"time"
-
-	"istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/util/retry"
-	"istio.io/istio/tests/integration/security/util/connection"
-)
-
-// ExpectHeaderContains specifies the expected value to be found in the HTTP header. Every value must be found in order to
-// to make the test pass. Every NotValue must not be found in order to make the test pass.
-type ExpectHeaderContains struct {
-	Key       string
-	Values    []string
-	NotValues []string
-}
-
-type TestCase struct {
-	NamePrefix            string
-	Request               connection.Checker
-	ExpectAllowed         bool
-	ExpectRequestHeaders  []ExpectHeaderContains
-	ExpectResponseHeaders []ExpectHeaderContains
-	Jwt                   string
-	Headers               map[string]string
-}
-
-func filterError(req connection.Checker, expect string, c check.Checker) check.Checker {
-	return check.FilterError(func(err error) error {
-		return fmt.Errorf("%s to %s:%s%s: expect %s, got: %v",
-			req.From.Config().Service,
-			req.Options.Target.Config().Service,
-			req.Options.PortName,
-			req.Options.Path,
-			expect,
-			err)
-	}, c)
-}
-
-func checkValues(i int, response echo.Response, headers http.Header, headerType string, want []ExpectHeaderContains) error {
-	for _, w := range want {
-		key := w.Key
-		for _, value := range w.Values {
-			actual := headers.Get(key)
-			if !strings.Contains(actual, value) {
-				return fmt.Errorf("response[%d]: HTTP code %s, expected %s `%s` to contain `%s`, value=`%s`, raw content=%s",
-					i, response.Code, headerType, key, value, actual, response.RawContent)
-			}
-		}
-		for _, value := range w.NotValues {
-			actual := headers.Get(key)
-			if strings.Contains(actual, value) {
-				return fmt.Errorf("response[%d]: HTTP code %s, expected %s `%s` to not contain `%s`, value=`%s`, raw content=%s",
-					i, response.Code, headerType, key, value, actual, response.RawContent)
-			}
-		}
-	}
-	return nil
-}
-
-// CheckRBACRequest checks if a request is successful under RBAC policies.
-// Under RBAC policies, a request is consider successful if:
-// * If the policy is allow:
-// *** Response code is 200
-// * If the policy is deny:
-// *** For HTTP: response code is 403.
-// *** For TCP: EOF error
-func (tc TestCase) CheckRBACRequest() error {
-	req := tc.Request
-
-	headers := make(http.Header)
-	if len(tc.Jwt) > 0 {
-		headers.Add("Authorization", "Bearer "+tc.Jwt)
-	}
-	for k, v := range tc.Headers {
-		headers.Add(k, v)
-	}
-	tc.Request.Options.Headers = headers
-
-	resp, err := req.From.Call(tc.Request.Options)
-
-	checkHeaders := func(rs echo.Responses, _ error) error {
-		for i, r := range rs {
-			if err := checkValues(i, r, r.RequestHeaders, "request header", tc.ExpectRequestHeaders); err != nil {
-				return err
-			}
-			if err := checkValues(i, r, r.ResponseHeaders, "response header", tc.ExpectResponseHeaders); err != nil {
-				return err
-			}
-		}
-		return nil
-	}
-
-	if tc.ExpectAllowed {
-		return filterError(req, "allow with code 200",
-			check.And(
-				check.NoError(),
-				check.OK(),
-				checkHeaders,
-				func(rs echo.Responses, _ error) error {
-					if req.DestClusters.IsMulticluster() {
-						return check.ReachedClusters(req.DestClusters).Check(rs, err)
-					}
-					return nil
-				})).Check(resp, err)
-	}
-
-	if strings.HasPrefix(req.Options.PortName, "tcp") || req.Options.PortName == "grpc" {
-		expectedErrMsg := "EOF" // TCP deny message.
-		if req.Options.PortName == "grpc" {
-			expectedErrMsg = "rpc error: code = PermissionDenied desc = RBAC: access denied"
-		}
-
-		return filterError(req, fmt.Sprintf("deny with %s error", expectedErrMsg),
-			check.ErrorContains(expectedErrMsg)).Check(resp, err)
-	}
-
-	return filterError(req, "deny with code 403",
-		check.And(
-			check.NoError(),
-			check.StatusCode(http.StatusForbidden),
-			checkHeaders)).Check(resp, err)
-}
-
-func RunRBACTest(ctx framework.TestContext, cases []TestCase) {
-	for _, tc := range cases {
-		want := "deny"
-		if tc.ExpectAllowed {
-			want = "allow"
-		}
-		testName := fmt.Sprintf("%s%s->%s:%s%s[%s]",
-			tc.NamePrefix,
-			tc.Request.From.Config().Service,
-			tc.Request.Options.Target.Config().Service,
-			tc.Request.Options.PortName,
-			tc.Request.Options.Path,
-			want)
-		ctx.NewSubTest(testName).Run(func(t framework.TestContext) {
-			// Current source ip based authz test cases are not required in multicluster setup
-			// because cross-network traffic will lose the origin source ip info
-			if strings.Contains(testName, "source-ip") && t.Clusters().IsMulticluster() {
-				t.Skip()
-			}
-			retry.UntilSuccessOrFail(t, tc.CheckRBACRequest,
-				retry.Delay(250*time.Millisecond), retry.Timeout(30*time.Second))
-		})
-	}
-}
diff --git a/tests/integration/security/util/scheck/checkers.go b/tests/integration/security/util/scheck/checkers.go
new file mode 100644
index 0000000000..d74dd7b8b0
--- /dev/null
+++ b/tests/integration/security/util/scheck/checkers.go
@@ -0,0 +1,95 @@
+//go:build integ
+// +build integ
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package scheck
+
+import (
+	"fmt"
+	"net/http"
+	"sort"
+	"strings"
+
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
+	"istio.io/istio/pkg/test/echo/common/scheme"
+	"istio.io/istio/pkg/test/framework/components/echo"
+)
+
+func ReachedClusters(to echo.Instances, opts *echo.CallOptions) check.Checker {
+	// TODO(https://github.com/istio/istio/issues/37307): Investigate why we don't reach all clusters.
+	if to.Clusters().IsMulticluster() && opts.Count > 1 && opts.Scheme != scheme.GRPC && !opts.Target.Config().IsHeadless() {
+		return check.ReachedClusters(to.Clusters())
+	}
+	return check.None()
+}
+
+func RBACFailure(opts *echo.CallOptions) check.Checker {
+	if opts.PortName == "grpc" {
+		return check.ErrorContains("rpc error: code = PermissionDenied desc = RBAC: access denied")
+	}
+
+	if strings.HasPrefix(opts.PortName, "tcp") {
+		return check.ErrorContains("EOF")
+	}
+
+	return check.And(
+		check.NoError(),
+		check.Status(http.StatusForbidden))
+}
+
+func HeaderContains(hType echoClient.HeaderType, expected map[string][]string) check.Checker {
+	return check.Each(func(r echoClient.Response) error {
+		h := r.GetHeaders(hType)
+		for _, key := range sortKeys(expected) {
+			actual := h.Get(key)
+
+			for _, value := range expected[key] {
+				if !strings.Contains(actual, value) {
+					return fmt.Errorf("status code %s, expected %s header `%s` to contain `%s`, value=`%s`, raw content=%s",
+						r.Code, hType, key, value, actual, r.RawContent)
+				}
+			}
+		}
+		return nil
+	})
+}
+
+func HeaderNotContains(hType echoClient.HeaderType, expected map[string][]string) check.Checker {
+	return check.Each(func(r echoClient.Response) error {
+		h := r.GetHeaders(hType)
+		for _, key := range sortKeys(expected) {
+			actual := h.Get(key)
+
+			for _, value := range expected[key] {
+				if strings.Contains(actual, value) {
+					return fmt.Errorf("status code %s, expected %s header `%s` to not contain `%s`, value=`%s`, raw content=%s",
+						r.Code, hType, key, value, actual, r.RawContent)
+				}
+			}
+		}
+		return nil
+	})
+}
+
+func sortKeys(v map[string][]string) []string {
+	out := make([]string, 0, len(v))
+	for k := range v {
+		out = append(out, k)
+	}
+	sort.Strings(out)
+	return out
+}
-- 
2.35.3

