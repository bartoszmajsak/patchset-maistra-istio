From 0b66378bcb8ca2d17864bf6106a9f73939cceaee Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 21 Apr 2022 09:42:24 -0700
Subject: [tf] Various improvements (#38480)

A number of improvements around the testing framework to help with work on https://github.com/istio/istio/pull/37914.
---
 pkg/http/headers/builder.go                   |  19 ++
 .../framework/components/echo/calloptions.go  |   9 +
 .../components/echo/check/checkers.go         | 155 ++++++----
 .../echo/common/deployment/echos.go           | 273 +++++++++++-------
 .../echo/common/deployment/namespace.go       |  12 +-
 pkg/test/framework/components/echo/config.go  |  13 +
 .../components/echo/match/matchers.go         |  10 +-
 .../framework/components/echo/services.go     |   8 +
 .../framework/components/echo/workload.go     |   9 +
 pkg/test/framework/components/istio/util.go   |   9 +-
 pkg/test/framework/config.go                  |  22 +-
 pkg/test/framework/resource/context.go        |   3 +
 .../pilot/cni/cniversionskew_test.go          |   5 +-
 tests/integration/pilot/common/routing.go     |   2 +-
 .../pilot/endpointslice/endpointslice_test.go |   4 +-
 tests/integration/pilot/main_test.go          |   4 +-
 tests/integration/pilot/multicluster_test.go  |   4 +-
 .../pilot/revisions/revisions_test.go         |   2 +-
 .../security/authorization_test.go            | 155 +++++-----
 .../ca_custom_root/secure_naming_test.go      |   6 +-
 .../security/external_ca/reachability_test.go |   4 +-
 .../security/normalization_test.go            |   2 +-
 .../pass_through_filter_chain_test.go         |   2 +-
 .../authz/v1beta1-conditions.yaml.tmpl        |  12 +-
 .../security/util/reachability/context.go     |   2 +-
 .../security/util/scheck/checkers.go          |  16 +-
 26 files changed, 466 insertions(+), 296 deletions(-)

diff --git a/pkg/http/headers/builder.go b/pkg/http/headers/builder.go
index def2fc1c2c..b29d9c380b 100644
--- a/pkg/http/headers/builder.go
+++ b/pkg/http/headers/builder.go
@@ -30,6 +30,11 @@ func New() *Builder {
 	}
 }
 
+// Get returns the current value for the key.
+func (b *Builder) Get(key string) string {
+	return b.headers.Get(key)
+}
+
 // With sets the given header value.
 func (b *Builder) With(key, value string) *Builder {
 	b.headers.Set(key, value)
@@ -55,5 +60,19 @@ func (b *Builder) WithXForwardedFor(ip string) *Builder {
 }
 
 func (b *Builder) Build() http.Header {
+	if b == nil {
+		return nil
+	}
+
 	return b.headers
 }
+
+func (b *Builder) BuildTo(out http.Header) {
+	if b == nil {
+		return
+	}
+
+	for k, v := range b.headers {
+		out[k] = v
+	}
+}
diff --git a/pkg/test/framework/components/echo/calloptions.go b/pkg/test/framework/components/echo/calloptions.go
index de6d46fff4..8aaf2be338 100644
--- a/pkg/test/framework/components/echo/calloptions.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -23,6 +23,7 @@
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	"istio.io/istio/pkg/http/headers"
+	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/util/retry"
@@ -219,6 +220,14 @@ func (o *CallOptions) FillDefaults() error {
 	return nil
 }
 
+// FillDefaultsOrFail calls FillDefaults and fails if an error occurs.
+func (o *CallOptions) FillDefaultsOrFail(t test.Failer) {
+	t.Helper()
+	if err := o.FillDefaults(); err != nil {
+		t.Fatal(err)
+	}
+}
+
 func (o *CallOptions) fillAddress() error {
 	if o.Address == "" {
 		if o.To != nil {
diff --git a/pkg/test/framework/components/echo/check/checkers.go b/pkg/test/framework/components/echo/check/checkers.go
index c58579806b..a46dc302ab 100644
--- a/pkg/test/framework/components/echo/check/checkers.go
+++ b/pkg/test/framework/components/echo/check/checkers.go
@@ -23,6 +23,7 @@
 
 	"github.com/hashicorp/go-multierror"
 
+	"istio.io/istio/pkg/config/protocol"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -155,12 +156,34 @@ func Status(expected int) echo.Checker {
 	}
 	return Each(func(r echoClient.Response) error {
 		if r.Code != expectedStr {
-			return fmt.Errorf("expected response code `%s`, got %q", expectedStr, r.Code)
+			return fmt.Errorf("expected response code `%s`, got %q. Response: %s", expectedStr, r.Code, r)
 		}
 		return nil
 	})
 }
 
+// BodyContains checks that the response body contains the given string.
+func BodyContains(expected string) echo.Checker {
+	return Each(func(r echoClient.Response) error {
+		if !strings.Contains(r.RawContent, expected) {
+			return fmt.Errorf("want %q in body but not found: %s", expected, r.RawContent)
+		}
+		return nil
+	})
+}
+
+// Forbidden checks that the response indicates that the request was rejected by RBAC.
+func Forbidden(p protocol.Instance) echo.Checker {
+	switch {
+	case p.IsGRPC():
+		return ErrorContains("rpc error: code = PermissionDenied")
+	case p.IsTCP():
+		return ErrorContains("EOF")
+	default:
+		return NoErrorAndStatus(http.StatusForbidden)
+	}
+}
+
 // TooManyRequests checks that at least one message receives a StatusTooManyRequests status code.
 func TooManyRequests() echo.Checker {
 	codeStr := strconv.Itoa(http.StatusTooManyRequests)
@@ -296,6 +319,15 @@ func URL(expected string) echo.Checker {
 	})
 }
 
+// ReachedTargetClusters is similar to ReachedClusters, except that the set of expected clusters is
+// retrieved from the Target of the request.
+func ReachedTargetClusters(allClusters cluster.Clusters) echo.Checker {
+	return func(result echo.CallResult, err error) error {
+		expectedByNetwork := result.Opts.To.Clusters().ByNetwork()
+		return checkReachedClusters(result, allClusters, expectedByNetwork)
+	}
+}
+
 // ReachedClusters returns an error if requests did not load balance as expected.
 //
 // For cases where all clusters are on the same network, verifies that each of the expected clusters was reached.
@@ -305,81 +337,84 @@ func URL(expected string) echo.Checker {
 // client were reached.
 func ReachedClusters(allClusters cluster.Clusters, expectedClusters cluster.Clusters) echo.Checker {
 	expectedByNetwork := expectedClusters.ByNetwork()
-	return And(
-		reachedNetworks(allClusters, expectedByNetwork),
-		reachedClustersInNetwork(allClusters, expectedByNetwork))
+	return func(result echo.CallResult, err error) error {
+		return checkReachedClusters(result, allClusters, expectedByNetwork)
+	}
 }
 
-func reachedNetworks(allClusters cluster.Clusters, expectedByNetwork cluster.ClustersByNetwork) echo.Checker {
-	return func(result echo.CallResult, _ error) error {
-		// Gather the networks that were reached.
-		networkHits := make(map[string]int)
-		for _, rr := range result.Responses {
-			c := allClusters.GetByName(rr.Cluster)
-			if c != nil {
-				networkHits[c.NetworkName()]++
-			}
+func checkReachedClusters(result echo.CallResult, allClusters cluster.Clusters, expectedByNetwork cluster.ClustersByNetwork) error {
+	if err := checkReachedNetworks(result, allClusters, expectedByNetwork); err != nil {
+		return err
+	}
+	return checkReachedClustersInNetwork(result, allClusters, expectedByNetwork)
+}
+
+func checkReachedNetworks(result echo.CallResult, allClusters cluster.Clusters, expectedByNetwork cluster.ClustersByNetwork) error {
+	// Gather the networks that were reached.
+	networkHits := make(map[string]int)
+	for _, rr := range result.Responses {
+		c := allClusters.GetByName(rr.Cluster)
+		if c != nil {
+			networkHits[c.NetworkName()]++
 		}
+	}
 
-		// Verify that all expected networks were reached.
-		for network := range expectedByNetwork {
-			if networkHits[network] == 0 {
-				return fmt.Errorf("did not reach network %v, got %v", network, networkHits)
-			}
+	// Verify that all expected networks were reached.
+	for network := range expectedByNetwork {
+		if networkHits[network] == 0 {
+			return fmt.Errorf("did not reach network %v, got %v", network, networkHits)
 		}
+	}
 
-		// Verify that no unexpected networks were reached.
-		for network := range networkHits {
-			if expectedByNetwork[network] == nil {
-				return fmt.Errorf("reached network not in %v, got %v", expectedByNetwork.Networks(), networkHits)
-			}
+	// Verify that no unexpected networks were reached.
+	for network := range networkHits {
+		if expectedByNetwork[network] == nil {
+			return fmt.Errorf("reached network not in %v, got %v", expectedByNetwork.Networks(), networkHits)
 		}
-		return nil
 	}
+	return nil
 }
 
-func reachedClustersInNetwork(allClusters cluster.Clusters, expectedByNetwork cluster.ClustersByNetwork) echo.Checker {
-	return func(result echo.CallResult, _ error) error {
-		// Determine the source network of the caller.
-		var sourceNetwork string
-		switch from := result.From.(type) {
-		case echo.Instance:
-			sourceNetwork = from.Config().Cluster.NetworkName()
-		case ingress.Instance:
-			sourceNetwork = from.Cluster().NetworkName()
-		default:
-			// Unable to determine the source network of the caller. Skip this check.
-			return nil
-		}
+func checkReachedClustersInNetwork(result echo.CallResult, allClusters cluster.Clusters, expectedByNetwork cluster.ClustersByNetwork) error {
+	// Determine the source network of the caller.
+	var sourceNetwork string
+	switch from := result.From.(type) {
+	case echo.Instance:
+		sourceNetwork = from.Config().Cluster.NetworkName()
+	case ingress.Instance:
+		sourceNetwork = from.Cluster().NetworkName()
+	default:
+		// Unable to determine the source network of the caller. Skip this check.
+		return nil
+	}
 
-		// Lookup only the expected clusters in the same network as the caller.
-		expectedClustersInSourceNetwork := expectedByNetwork[sourceNetwork]
+	// Lookup only the expected clusters in the same network as the caller.
+	expectedClustersInSourceNetwork := expectedByNetwork[sourceNetwork]
 
-		clusterHits := make(map[string]int)
-		for _, rr := range result.Responses {
-			clusterHits[rr.Cluster]++
-		}
+	clusterHits := make(map[string]int)
+	for _, rr := range result.Responses {
+		clusterHits[rr.Cluster]++
+	}
 
-		for _, c := range expectedClustersInSourceNetwork {
-			if clusterHits[c.Name()] == 0 {
-				return fmt.Errorf("did not reach all of %v in source network %v, got %v",
-					expectedClustersInSourceNetwork, sourceNetwork, clusterHits)
-			}
+	for _, c := range expectedClustersInSourceNetwork {
+		if clusterHits[c.Name()] == 0 {
+			return fmt.Errorf("did not reach all of %v in source network %v, got %v",
+				expectedClustersInSourceNetwork, sourceNetwork, clusterHits)
 		}
+	}
 
-		// Verify that no unexpected clusters were reached.
-		for clusterName := range clusterHits {
-			reachedCluster := allClusters.GetByName(clusterName)
-			if reachedCluster == nil || reachedCluster.NetworkName() != sourceNetwork {
-				// Ignore clusters on a different network from the source.
-				continue
-			}
+	// Verify that no unexpected clusters were reached.
+	for clusterName := range clusterHits {
+		reachedCluster := allClusters.GetByName(clusterName)
+		if reachedCluster == nil || reachedCluster.NetworkName() != sourceNetwork {
+			// Ignore clusters on a different network from the source.
+			continue
+		}
 
-			if expectedClustersInSourceNetwork.GetByName(clusterName) == nil {
-				return fmt.Errorf("reached cluster %v in source network %v not in %v, got %v",
-					clusterName, sourceNetwork, expectedClustersInSourceNetwork, clusterHits)
-			}
+		if expectedClustersInSourceNetwork.GetByName(clusterName) == nil {
+			return fmt.Errorf("reached cluster %v in source network %v not in %v, got %v",
+				clusterName, sourceNetwork, expectedClustersInSourceNetwork, clusterHits)
 		}
-		return nil
 	}
+	return nil
 }
diff --git a/pkg/test/framework/components/echo/common/deployment/echos.go b/pkg/test/framework/components/echo/common/deployment/echos.go
index 0d4af55325..af31076df7 100644
--- a/pkg/test/framework/components/echo/common/deployment/echos.go
+++ b/pkg/test/framework/components/echo/common/deployment/echos.go
@@ -23,6 +23,7 @@
 	"github.com/hashicorp/go-multierror"
 	"golang.org/x/sync/errgroup"
 
+	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
@@ -30,6 +31,84 @@
 	"istio.io/istio/pkg/test/framework/resource"
 )
 
+// Config for new echo deployment.
+type Config struct {
+	// Echos is the target Echos for the newly created echo apps. If nil, a new Echos
+	// instance will be created.
+	Echos *Echos
+
+	// NamespaceCount indicates the number of echo namespaces to be generated.
+	// Ignored if Namespaces is non-empty. Defaults to 1.
+	NamespaceCount int
+
+	// Namespaces is the user-provided list of echo namespaces. If empty, NamespaceCount
+	// namespaces will be generated.
+	Namespaces []namespace.Instance
+
+	// NoExternalNamespace if true, no external namespace will be generated and no external echo
+	// instance will be deployed. Ignored if ExternalNamespace is non-nil.
+	NoExternalNamespace bool
+
+	// ExternalNamespace the namespace to use for the external deployment. If nil, a namespace
+	// will be generated unless NoExternalNamespace is specified.
+	ExternalNamespace namespace.Instance
+}
+
+func (c *Config) fillDefaults(ctx resource.Context) error {
+	// Create the namespaces concurrently.
+	g, _ := errgroup.WithContext(context.TODO())
+
+	if c.Echos == nil {
+		c.Echos = &Echos{}
+	}
+
+	if len(c.Namespaces) > 0 {
+		c.NamespaceCount = len(c.Namespaces)
+	} else if c.NamespaceCount <= 0 {
+		c.NamespaceCount = 1
+	}
+
+	// Create the echo namespaces.
+	if len(c.Namespaces) == 0 {
+		c.Namespaces = make([]namespace.Instance, c.NamespaceCount)
+		if c.NamespaceCount == 1 {
+			// If only using a single namespace, preserve the "echo" prefix.
+			g.Go(func() (err error) {
+				c.Namespaces[0], err = namespace.New(ctx, namespace.Config{
+					Prefix: "echo",
+					Inject: true,
+				})
+				return
+			})
+		} else {
+			for i := 0; i < c.NamespaceCount; i++ {
+				i := i
+				g.Go(func() (err error) {
+					c.Namespaces[i], err = namespace.New(ctx, namespace.Config{
+						Prefix: fmt.Sprintf("echo%d", i+1),
+						Inject: true,
+					})
+					return
+				})
+			}
+		}
+	}
+
+	// Create the external namespace, if necessary.
+	if c.ExternalNamespace == nil && !c.NoExternalNamespace {
+		g.Go(func() (err error) {
+			c.ExternalNamespace, err = namespace.New(ctx, namespace.Config{
+				Prefix: "external",
+				Inject: false,
+			})
+			return
+		})
+	}
+
+	// Wait for the namespaces to be created.
+	return g.Wait()
+}
+
 // SingleNamespaceView is a simplified view of Echos for tests that only require a single namespace.
 type SingleNamespaceView struct {
 	// Include the echos at the top-level, so there is no need for accessing sub-structures.
@@ -72,6 +151,66 @@ type Echos struct {
 	All echo.Services
 }
 
+// New echo deployment with the given configuration.
+func New(ctx resource.Context, cfg Config) (*Echos, error) {
+	if err := cfg.fillDefaults(ctx); err != nil {
+		return nil, err
+	}
+
+	apps := cfg.Echos
+	apps.NS = make([]EchoNamespace, len(cfg.Namespaces))
+	for i, ns := range cfg.Namespaces {
+		apps.NS[i].Namespace = ns
+	}
+	apps.External.Namespace = cfg.ExternalNamespace
+
+	builder := deployment.New(ctx).WithClusters(ctx.Clusters()...)
+	for _, n := range apps.NS {
+		builder = n.build(ctx, builder)
+	}
+
+	if !cfg.NoExternalNamespace {
+		builder = apps.External.build(builder)
+	}
+
+	echos, err := builder.Build()
+	if err != nil {
+		return nil, err
+	}
+
+	apps.All = echos.Services()
+
+	g := multierror.Group{}
+	for i := 0; i < len(apps.NS); i++ {
+		i := i
+		g.Go(func() error {
+			return apps.NS[i].loadValues(ctx, echos, apps)
+		})
+	}
+
+	if !cfg.NoExternalNamespace {
+		g.Go(func() error {
+			return apps.External.loadValues(echos)
+		})
+	}
+
+	if err := g.Wait().ErrorOrNil(); err != nil {
+		return nil, err
+	}
+
+	return apps, nil
+}
+
+// NewOrFail calls New and fails if an error is returned.
+func NewOrFail(t test.Failer, ctx resource.Context, cfg Config) *Echos {
+	t.Helper()
+	out, err := New(ctx, cfg)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return out
+}
+
 // SingleNamespaceView converts this Echos into a SingleNamespaceView.
 func (d Echos) SingleNamespaceView() SingleNamespaceView {
 	return SingleNamespaceView{
@@ -93,24 +232,6 @@ func (d Echos) TwoNamespaceView() TwoNamespaceView {
 	}
 }
 
-func (d *Echos) loadValues(t resource.Context, echos echo.Instances) error {
-	d.All = echos.Services()
-
-	g := multierror.Group{}
-	for i := 0; i < len(d.NS); i++ {
-		i := i
-		g.Go(func() error {
-			return d.NS[i].loadValues(t, echos, d)
-		})
-	}
-
-	g.Go(func() error {
-		return d.External.loadValues(echos)
-	})
-
-	return g.Wait().ErrorOrNil()
-}
-
 func (d Echos) namespaces(excludes ...namespace.Instance) []string {
 	var out []string
 	for _, n := range d.NS {
@@ -143,100 +264,52 @@ func serviceEntryPorts() []echo.Port {
 	return res
 }
 
-type Config struct {
-	NamespaceCount int
-}
+// SetupSingleNamespace calls Setup and returns a SingleNamespaceView.
+func SetupSingleNamespace(view *SingleNamespaceView) resource.SetupFn {
+	return func(ctx resource.Context) error {
+		// Perform a setup with 1 namespace.
+		var apps Echos
+		if err := Setup(&apps, Config{NamespaceCount: 1})(ctx); err != nil {
+			return err
+		}
 
-func (c *Config) fillDefaults() {
-	if c.NamespaceCount <= 1 {
-		c.NamespaceCount = 1
+		// Store the view.
+		*view = apps.SingleNamespaceView()
+		return nil
 	}
 }
 
-func SetupSingleNamespace(t resource.Context, view *SingleNamespaceView) error {
-	// Perform a setup with 1 namespace.
-	var apps Echos
-	if err := Setup(t, &apps, Config{NamespaceCount: 1}); err != nil {
-		return err
-	}
-
-	// Store the view.
-	*view = apps.SingleNamespaceView()
-	return nil
-}
+// SetupTwoNamespaces calls Setup and returns a TwoNamespaceView.
+func SetupTwoNamespaces(view *TwoNamespaceView) resource.SetupFn {
+	return func(ctx resource.Context) error {
+		// Perform a setup with 2 namespaces.
+		var apps Echos
+		if err := Setup(&apps, Config{NamespaceCount: 2})(ctx); err != nil {
+			return err
+		}
 
-func SetupTwoNamespaces(t resource.Context, view *TwoNamespaceView) error {
-	// Perform a setup with 2 namespaces.
-	var apps Echos
-	if err := Setup(t, &apps, Config{NamespaceCount: 2}); err != nil {
-		return err
+		// Store the view.
+		*view = apps.TwoNamespaceView()
+		return nil
 	}
-
-	// Store the view.
-	*view = apps.TwoNamespaceView()
-	return nil
 }
 
-func Setup(t resource.Context, apps *Echos, cfg Config) error {
-	cfg.fillDefaults()
+// Setup function for writing to a global deployment variable.
+func Setup(apps *Echos, cfg Config) resource.SetupFn {
+	return func(ctx resource.Context) error {
+		// Set the target for the deployments.
+		cfg.Echos = apps
 
-	// Create the namespaces concurrently.
-	g, _ := errgroup.WithContext(context.TODO())
-
-	// Create the echo namespaces.
-	apps.NS = make([]EchoNamespace, cfg.NamespaceCount)
-	if cfg.NamespaceCount == 1 {
-		// If only using a single namespace, preserve the "echo" prefix.
-		g.Go(func() (err error) {
-			apps.NS[0].Namespace, err = namespace.New(t, namespace.Config{
-				Prefix: "echo",
-				Inject: true,
-			})
-			return
-		})
-	} else {
-		for i := 0; i < cfg.NamespaceCount; i++ {
-			i := i
-			g.Go(func() (err error) {
-				apps.NS[i].Namespace, err = namespace.New(t, namespace.Config{
-					Prefix: fmt.Sprintf("echo%d", i+1),
-					Inject: true,
-				})
-				return
-			})
+		_, err := New(ctx, cfg)
+		if err != nil {
+			return err
 		}
-	}
-
-	// Create the external namespace.
-	g.Go(func() (err error) {
-		apps.External.Namespace, err = namespace.New(t, namespace.Config{
-			Prefix: "external",
-			Inject: false,
-		})
-		return
-	})
-
-	// Wait for the namespaces to be created.
-	if err := g.Wait(); err != nil {
-		return err
-	}
 
-	builder := deployment.New(t).WithClusters(t.Clusters()...)
-	for _, n := range apps.NS {
-		builder = n.build(t, builder)
+		return nil
 	}
-	builder = apps.External.build(builder)
-
-	echos, err := builder.Build()
-	if err != nil {
-		return err
-	}
-
-	// Load values from the deployed echo instances.
-	return apps.loadValues(t, echos)
 }
 
-// TODO(nmittler): should t.Settings().Skip(echo.Delta) do all of this?
-func skipDeltaXDS(t resource.Context) bool {
-	return t.Settings().Skip(echo.Delta) || !t.Settings().Revisions.AtLeast("1.12")
+// TODO(nmittler): should ctx.Settings().Skip(echo.Delta) do all of this?
+func skipDeltaXDS(ctx resource.Context) bool {
+	return ctx.Settings().Skip(echo.Delta) || !ctx.Settings().Revisions.AtLeast("1.12")
 }
diff --git a/pkg/test/framework/components/echo/common/deployment/namespace.go b/pkg/test/framework/components/echo/common/deployment/namespace.go
index 33282c59c9..c715000d11 100644
--- a/pkg/test/framework/components/echo/common/deployment/namespace.go
+++ b/pkg/test/framework/components/echo/common/deployment/namespace.go
@@ -224,11 +224,12 @@ func (n *EchoNamespace) loadValues(t resource.Context, echos echo.Instances, d *
 `)
 
 	// Create a ServiceEntry to allow apps in this namespace to talk to the external service.
-	cfg.Eval(ns.Name(), map[string]interface{}{
-		"Namespace": d.External.Namespace.Name(),
-		"Hostname":  externalHostname,
-		"Ports":     serviceEntryPorts(),
-	}, `apiVersion: networking.istio.io/v1alpha3
+	if d.External.Namespace != nil {
+		cfg.Eval(ns.Name(), map[string]interface{}{
+			"Namespace": d.External.Namespace.Name(),
+			"Hostname":  externalHostname,
+			"Ports":     serviceEntryPorts(),
+		}, `apiVersion: networking.istio.io/v1alpha3
 kind: ServiceEntry
 metadata:
   name: external-service
@@ -254,6 +255,7 @@ func (n *EchoNamespace) loadValues(t resource.Context, echos echo.Instances, d *
     protocol: "{{$p.Protocol}}"
 {{- end }}
 `)
+	}
 
 	return cfg.Apply(resource.NoCleanup)
 }
diff --git a/pkg/test/framework/components/echo/config.go b/pkg/test/framework/components/echo/config.go
index 21b1b84109..6b05658737 100644
--- a/pkg/test/framework/components/echo/config.go
+++ b/pkg/test/framework/components/echo/config.go
@@ -150,6 +150,14 @@ type Config struct {
 	IPFamilyPolicy string
 }
 
+// NamespaceName returns the string name of the namespace.
+func (c Config) NamespaceName() string {
+	if c.Namespace != nil {
+		return c.Namespace.Name()
+	}
+	return ""
+}
+
 // NamespacedName returns the namespaced name for the service.
 func (c Config) NamespacedName() NamespacedName {
 	return NamespacedName{
@@ -158,6 +166,11 @@ func (c Config) NamespacedName() NamespacedName {
 	}
 }
 
+// ServiceAccountString returns the service account string for this service.
+func (c Config) ServiceAccountString() string {
+	return "cluster.local/ns/" + c.NamespaceName() + "/sa/" + c.Service
+}
+
 // SubsetConfig is the config for a group of Subsets (e.g. Kubernetes deployment).
 type SubsetConfig struct {
 	// The version of the deployment.
diff --git a/pkg/test/framework/components/echo/match/matchers.go b/pkg/test/framework/components/echo/match/matchers.go
index 99dee253f8..82491eae52 100644
--- a/pkg/test/framework/components/echo/match/matchers.go
+++ b/pkg/test/framework/components/echo/match/matchers.go
@@ -17,6 +17,7 @@
 import (
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/namespace"
 )
 
 // Any doesn't filter out any echos.
@@ -77,9 +78,14 @@ func AnyServiceName(expected echo.NamespacedNames) Matcher {
 }
 
 // Namespace matches instances within the given namespace name.
-func Namespace(namespace string) Matcher {
+func Namespace(n namespace.Instance) Matcher {
+	return NamespaceName(n.Name())
+}
+
+// NamespaceName matches instances within the given namespace name.
+func NamespaceName(ns string) Matcher {
 	return func(i echo.Instance) bool {
-		return i.Config().Namespace.Name() == namespace
+		return i.Config().Namespace.Name() == ns
 	}
 }
 
diff --git a/pkg/test/framework/components/echo/services.go b/pkg/test/framework/components/echo/services.go
index 75ee1a5858..6408db3f2d 100644
--- a/pkg/test/framework/components/echo/services.go
+++ b/pkg/test/framework/components/echo/services.go
@@ -53,6 +53,14 @@ func (d Services) Instances() Instances {
 	return out
 }
 
+func (d Services) Callers() Callers {
+	var out Callers
+	for _, s := range d {
+		out = append(out, s[0])
+	}
+	return out
+}
+
 func (d Services) MatchFQDNs(fqdns ...string) Services {
 	match := map[string]bool{}
 	for _, fqdn := range fqdns {
diff --git a/pkg/test/framework/components/echo/workload.go b/pkg/test/framework/components/echo/workload.go
index 816cd9aa9b..d754b93bbf 100644
--- a/pkg/test/framework/components/echo/workload.go
+++ b/pkg/test/framework/components/echo/workload.go
@@ -66,6 +66,15 @@ func (ws Workloads) Len() int {
 	return len(ws)
 }
 
+// Addresses returns the list of addresses for all workloads.
+func (ws Workloads) Addresses() []string {
+	out := make([]string, 0, len(ws))
+	for _, w := range ws {
+		out = append(out, w.Address())
+	}
+	return out
+}
+
 func (ws Workloads) Clusters() cluster.Clusters {
 	clusters := make(map[string]cluster.Cluster)
 	for _, w := range ws {
diff --git a/pkg/test/framework/components/istio/util.go b/pkg/test/framework/components/istio/util.go
index fa832aa5ce..c9d6375a2e 100644
--- a/pkg/test/framework/components/istio/util.go
+++ b/pkg/test/framework/components/istio/util.go
@@ -177,7 +177,7 @@ func (i *operatorComponent) isExternalControlPlane() bool {
 	return false
 }
 
-func PatchMeshConfig(t framework.TestContext, ns string, clusters cluster.Clusters, patch string) {
+func PatchMeshConfig(t resource.Context, ns string, clusters cluster.Clusters, patch string) error {
 	errG := multierror.Group{}
 	origCfg := map[string]string{}
 	mu := sync.RWMutex{}
@@ -240,7 +240,12 @@ func PatchMeshConfig(t framework.TestContext, ns string, clusters cluster.Cluste
 			scopes.Framework.Errorf("failed cleaning up cluster-local config: %v", err)
 		}
 	})
-	if err := errG.Wait().ErrorOrNil(); err != nil {
+	return errG.Wait().ErrorOrNil()
+}
+
+func PatchMeshConfigOrFail(t framework.TestContext, ns string, clusters cluster.Clusters, patch string) {
+	t.Helper()
+	if err := PatchMeshConfig(t, ns, clusters, patch); err != nil {
 		t.Fatal(err)
 	}
 }
diff --git a/pkg/test/framework/config.go b/pkg/test/framework/config.go
index 0d814b3634..8a08f4356f 100644
--- a/pkg/test/framework/config.go
+++ b/pkg/test/framework/config.go
@@ -30,6 +30,7 @@
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/file"
 	"istio.io/istio/pkg/test/util/tmpl"
+	"istio.io/istio/pkg/test/util/yml"
 )
 
 var _ resource.ConfigManager = &configManager{}
@@ -184,11 +185,30 @@ type configImpl struct {
 	yamlText map[string][]string
 }
 
+func (c *configImpl) Copy() resource.Config {
+	yamlText := make(map[string][]string, len(c.yamlText))
+	for k, v := range c.yamlText {
+		yamlText[k] = append([]string{}, v...)
+	}
+	return &configImpl{
+		configManager: c.configManager,
+		yamlText:      yamlText,
+	}
+}
+
 func (c *configImpl) YAML(ns string, yamlText ...string) resource.Config {
-	c.yamlText[ns] = append(c.yamlText[ns], yamlText...)
+	c.yamlText[ns] = append(c.yamlText[ns], splitYAML(yamlText...)...)
 	return c
 }
 
+func splitYAML(yamlText ...string) []string {
+	var out []string
+	for _, doc := range yamlText {
+		out = append(out, yml.SplitString(doc)...)
+	}
+	return out
+}
+
 func (c *configImpl) File(ns string, paths ...string) resource.Config {
 	yamlText, err := file.AsStringArray(paths...)
 	if err != nil {
diff --git a/pkg/test/framework/resource/context.go b/pkg/test/framework/resource/context.go
index ca7772e2e1..9d8aa83554 100644
--- a/pkg/test/framework/resource/context.go
+++ b/pkg/test/framework/resource/context.go
@@ -58,6 +58,9 @@ type Config interface {
 	// ConfigFactory for appending to this Config
 	ConfigFactory
 
+	// Copy this Config
+	Copy() Config
+
 	// Apply this config to all clusters within the ConfigManager
 	Apply(opts ...ConfigOption) error
 	ApplyOrFail(t test.Failer, opts ...ConfigOption)
diff --git a/tests/integration/pilot/cni/cniversionskew_test.go b/tests/integration/pilot/cni/cniversionskew_test.go
index c675c22a2f..5a81b7daed 100644
--- a/tests/integration/pilot/cni/cniversionskew_test.go
+++ b/tests/integration/pilot/cni/cniversionskew_test.go
@@ -28,7 +28,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo/common/deployment"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/label"
-	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/util/file"
 	"istio.io/istio/pkg/test/util/retry"
@@ -100,9 +99,7 @@ func TestMain(m *testing.M) {
 		Label(label.CustomSetup).
 		RequireMultiPrimary().
 		Setup(istio.Setup(&i, nil)).
-		Setup(func(t resource.Context) error {
-			return deployment.SetupSingleNamespace(t, &apps)
-		}).
+		Setup(deployment.SetupSingleNamespace(&apps)).
 		Run()
 }
 
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index f00791c8d5..c94d7c3e68 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -2681,7 +2681,7 @@ func VMTestCases(t framework.TestContext, vms echo.Instances, apps *deployment.S
 		checker := check.OK()
 		if !match.Headless.Any(c.to) {
 			// headless load-balancing can be inconsistent
-			checker = check.And(checker, check.ReachedClusters(t.AllClusters(), c.to.Clusters()))
+			checker = check.And(checker, check.ReachedTargetClusters(t.AllClusters()))
 		}
 		cases = append(cases, TrafficTestCase{
 			name: fmt.Sprintf("%s from %s", c.name, c.from.Config().Cluster.StableName()),
diff --git a/tests/integration/pilot/endpointslice/endpointslice_test.go b/tests/integration/pilot/endpointslice/endpointslice_test.go
index 1e414959e8..d091746003 100644
--- a/tests/integration/pilot/endpointslice/endpointslice_test.go
+++ b/tests/integration/pilot/endpointslice/endpointslice_test.go
@@ -53,9 +53,7 @@ func TestMain(m *testing.M) {
 				// for k8s 1.21+, this suite should test disabling EndpointSlice mode
 				kubelib.IsLessThanVersion(t.Clusters().Kube().Default(), 21))
 		})).
-		Setup(func(t resource.Context) error {
-			return deployment.SetupSingleNamespace(t, &apps)
-		}).
+		Setup(deployment.SetupSingleNamespace(&apps)).
 		Run()
 }
 
diff --git a/tests/integration/pilot/main_test.go b/tests/integration/pilot/main_test.go
index 293299ab81..fb1c2a1e96 100644
--- a/tests/integration/pilot/main_test.go
+++ b/tests/integration/pilot/main_test.go
@@ -54,9 +54,7 @@ func TestMain(m *testing.M) {
 	framework.
 		NewSuite(m).
 		Setup(istio.Setup(&i, nil)).
-		Setup(func(t resource.Context) error {
-			return deployment.SetupSingleNamespace(t, &apps)
-		}).
+		Setup(deployment.SetupSingleNamespace(&apps)).
 		Setup(func(t resource.Context) error {
 			gatewayConformanceInputs.Client = t.Clusters().Default()
 			gatewayConformanceInputs.Cleanup = !t.Settings().NoCleanup
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index ab7419d205..1c7b757db0 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -64,7 +64,7 @@ func TestClusterLocal(t *testing.T) {
 				{
 					"MeshConfig.serviceSettings",
 					func(t framework.TestContext) {
-						istio.PatchMeshConfig(t, i.Settings().SystemNamespace, to.Clusters(), fmt.Sprintf(`
+						istio.PatchMeshConfigOrFail(t, i.Settings().SystemNamespace, to.Clusters(), fmt.Sprintf(`
 serviceSettings: 
 - settings:
     clusterLocal: true
@@ -153,7 +153,7 @@ func(t framework.TestContext) {
 							},
 							Check: check.And(
 								check.OK(),
-								check.ReachedClusters(t.AllClusters(), to.Clusters()),
+								check.ReachedTargetClusters(t.AllClusters()),
 							),
 							Retry: echo.Retry{
 								Options: []retry.Option{multiclusterRetryDelay, multiclusterRetryTimeout},
diff --git a/tests/integration/pilot/revisions/revisions_test.go b/tests/integration/pilot/revisions/revisions_test.go
index b6eda532d8..45e41b40ee 100644
--- a/tests/integration/pilot/revisions/revisions_test.go
+++ b/tests/integration/pilot/revisions/revisions_test.go
@@ -120,7 +120,7 @@ func TestMultiRevision(t *testing.T) {
 							},
 							Check: check.And(
 								check.OK(),
-								check.ReachedClusters(t.AllClusters(), to.Clusters()),
+								check.ReachedTargetClusters(t.AllClusters()),
 							),
 						})
 						return check.And(
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 9922982194..9729f14841 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -54,8 +54,8 @@ func TestAuthorization_mTLS(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.mtls-local").
 		Run(func(t framework.TestContext) {
-			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
 			for _, to := range []echo.Instances{b, vm} {
 				to := to
 				t.ConfigIstio().EvalFile(apps.Namespace1.Name(), map[string]string{
@@ -65,8 +65,8 @@ func TestAuthorization_mTLS(t *testing.T) {
 				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				for _, cluster := range t.Clusters() {
-					a := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
-					c := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace2.Name())).GetMatches(apps.C)
+					a := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
+					c := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace2)).GetMatches(apps.C)
 					if len(a) == 0 || len(c) == 0 {
 						continue
 					}
@@ -87,7 +87,7 @@ func TestAuthorization_mTLS(t *testing.T) {
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 								} else {
-									opts.Check = scheck.RBACFailure(&opts)
+									opts.Check = check.Forbidden(protocol.HTTP)
 								}
 
 								name := newRbacTestName("", expectAllowed, from, &opts)
@@ -120,9 +120,9 @@ func TestAuthorization_JWT(t *testing.T) {
 		Features("security.authorization.jwt-token").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			b := match.Namespace(ns.Name()).GetMatches(apps.B)
-			c := match.Namespace(ns.Name()).GetMatches(apps.C)
-			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
+			b := match.Namespace(ns).GetMatches(apps.B)
+			c := match.Namespace(ns).GetMatches(apps.C)
+			vm := match.Namespace(ns).GetMatches(apps.VM)
 			for _, dst := range []echo.Instances{b, vm} {
 				args := map[string]string{
 					"Namespace":  apps.Namespace1.Name(),
@@ -131,7 +131,7 @@ func TestAuthorization_JWT(t *testing.T) {
 				}
 				t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-jwt.yaml.tmpl").ApplyOrFail(t, resource.Wait)
 				for _, srcCluster := range t.Clusters() {
-					a := match.And(match.Cluster(srcCluster), match.Namespace(ns.Name())).GetMatches(apps.A)
+					a := match.And(match.Cluster(srcCluster), match.Namespace(ns)).GetMatches(apps.A)
 					if len(a) == 0 {
 						continue
 					}
@@ -154,7 +154,7 @@ func TestAuthorization_JWT(t *testing.T) {
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 								} else {
-									opts.Check = scheck.RBACFailure(&opts)
+									opts.Check = check.Forbidden(protocol.HTTP)
 								}
 
 								name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
@@ -221,10 +221,10 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.workload-selector").
 		Run(func(t framework.TestContext) {
-			bInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
-			vmInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
-			cInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
-			cInNS2 := match.Namespace(apps.Namespace2.Name()).GetMatches(apps.C)
+			bInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.B)
+			vmInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
+			cInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.C)
+			cInNS2 := match.Namespace(apps.Namespace2).GetMatches(apps.C)
 			ns1 := apps.Namespace1
 			ns2 := apps.Namespace2
 			rootns := newRootNS(t)
@@ -246,7 +246,7 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 					} else {
-						opts.Check = scheck.RBACFailure(&opts)
+						opts.Check = check.Forbidden(protocol.HTTP)
 					}
 
 					name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
@@ -258,7 +258,7 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 			}
 
 			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
+				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
 				if len(a) == 0 {
 					continue
 				}
@@ -351,9 +351,9 @@ func TestAuthorization_Deny(t *testing.T) {
 			}
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
 
 			applyPolicy := func(filename string, ns namespace.Instance) {
 				t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
@@ -367,7 +367,7 @@ func TestAuthorization_Deny(t *testing.T) {
 			applyPolicy("testdata/authz/v1beta1-deny.yaml.tmpl", ns)
 			applyPolicy("testdata/authz/v1beta1-deny-ns-root.yaml.tmpl", rootns)
 			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
+				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
 				if len(a) == 0 {
 					continue
 				}
@@ -389,7 +389,7 @@ func TestAuthorization_Deny(t *testing.T) {
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 							} else {
-								opts.Check = scheck.RBACFailure(&opts)
+								opts.Check = check.Forbidden(protocol.HTTP)
 							}
 
 							name := newRbacTestName("", expectAllowed, from, &opts)
@@ -443,10 +443,10 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			ns2 := apps.Namespace2
-			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
-			d := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.D)
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
+			d := match.Namespace(apps.Namespace1).GetMatches(apps.D)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
 			t.ConfigIstio().EvalFile("", map[string]string{
 				"Namespace":  ns.Name(),
 				"Namespace2": ns2.Name(),
@@ -466,8 +466,8 @@ type request struct {
 			reqNotPortParam := request{method: "GET", port: "http-8091"}
 			reqNotHostParam := request{method: "GET", port: "http", host: "deny.com"}
 			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
-				bInNS2 := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace2.Name())).GetMatches(apps.B)
+				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
+				bInNS2 := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace2)).GetMatches(apps.B)
 				if len(a) == 0 || len(bInNS2) == 0 {
 					continue
 				}
@@ -491,7 +491,7 @@ type request struct {
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 							} else {
-								opts.Check = scheck.RBACFailure(&opts)
+								opts.Check = check.Forbidden(protocol.HTTP)
 							}
 
 							name := newRbacTestName("", expectAllowed, from, &opts)
@@ -570,11 +570,11 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
 			// Gateways on VMs are not supported yet. This test verifies that security
 			// policies at gateways are useful for managing accessibility to services
 			// running on a VM.
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
 			for _, dst := range []echo.Instances{b, vm} {
 				t.NewSubTestf("to %s/", dst[0].Config().Service).Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile("", map[string]string{
@@ -772,9 +772,9 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			a := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.A)
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
-			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
+			a := match.Namespace(apps.Namespace1).GetMatches(apps.A)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
+			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
 			// Gateways on VMs are not supported yet. This test verifies that security
 			// policies at gateways are useful for managing accessibility to external
 			// services running on a VM.
@@ -900,12 +900,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 								Check: check.And(
 									check.NoError(),
 									check.Status(tc.code),
-									check.Each(func(r echoClient.Response) error {
-										if !strings.Contains(r.RawContent, tc.body) {
-											return fmt.Errorf("want %q in body but not found: %s", tc.body, r.RawContent)
-										}
-										return nil
-									})),
+									check.BodyContains(tc.body)),
 							})
 						})
 					}
@@ -931,10 +926,11 @@ func TestAuthorization_TCP(t *testing.T) {
 							Path: "/data",
 						},
 					}
+					opts.FillDefaultsOrFail(t)
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 					} else {
-						opts.Check = scheck.RBACFailure(&opts)
+						opts.Check = check.Forbidden(opts.Port.Protocol)
 					}
 
 					name := newRbacTestName("", expectAllowed, from, &opts)
@@ -947,12 +943,12 @@ func TestAuthorization_TCP(t *testing.T) {
 
 			ns := apps.Namespace1
 			ns2 := apps.Namespace2
-			a := match.Namespace(ns.Name()).GetMatches(apps.A)
-			b := match.Namespace(ns.Name()).GetMatches(apps.B)
-			c := match.Namespace(ns.Name()).GetMatches(apps.C)
-			eInNS2 := match.Namespace(ns2.Name()).GetMatches(apps.E)
-			d := match.Namespace(ns.Name()).GetMatches(apps.D)
-			e := match.Namespace(ns.Name()).GetMatches(apps.E)
+			a := match.Namespace(ns).GetMatches(apps.A)
+			b := match.Namespace(ns).GetMatches(apps.B)
+			c := match.Namespace(ns).GetMatches(apps.C)
+			eInNS2 := match.Namespace(ns2).GetMatches(apps.E)
+			d := match.Namespace(ns).GetMatches(apps.D)
+			e := match.Namespace(ns).GetMatches(apps.E)
 			t.NewSubTest("non-vms").
 				Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile("", map[string]string{
@@ -1016,7 +1012,7 @@ func TestAuthorization_TCP(t *testing.T) {
 					}
 				})
 			// TODO(JimmyCYJ): support multiple VMs and apply different security policies to each VM.
-			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
+			vm := match.Namespace(ns).GetMatches(apps.VM)
 			t.NewSubTest("vms").
 				Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile("", map[string]string{
@@ -1061,13 +1057,13 @@ func TestAuthorization_Conditions(t *testing.T) {
 			nsB := apps.Namespace2
 			nsC := apps.Namespace3
 
-			c := match.Namespace(nsC.Name()).GetMatches(apps.C)
-			vm := match.Namespace(nsA.Name()).GetMatches(apps.VM)
+			c := match.Namespace(nsC).GetMatches(apps.C)
+			vm := match.Namespace(nsA).GetMatches(apps.VM)
 			for _, to := range []echo.Instances{c, vm} {
 				to := to
-				for _, a := range match.Namespace(nsA.Name()).GetMatches(apps.A) {
+				for _, a := range match.Namespace(nsA).GetMatches(apps.A) {
 					a := a
-					bs := match.And(match.Cluster(a.Config().Cluster), match.Namespace(nsB.Name())).GetMatches(apps.B)
+					bs := match.And(match.Cluster(a.Config().Cluster), match.Namespace(nsB)).GetMatches(apps.B)
 					if len(bs) < 1 {
 						t.Skip()
 					}
@@ -1075,22 +1071,14 @@ func TestAuthorization_Conditions(t *testing.T) {
 					t.NewSubTestf("from %s to %s in %s",
 						a.Config().Cluster.StableName(), to.Config().Service, to.Config().Cluster.StableName()).
 						Run(func(t framework.TestContext) {
-							addresses := func(to echo.Target) string {
-								var out []string
-								for _, w := range to.WorkloadsOrFail(t) {
-									out = append(out, "\""+w.Address()+"\"")
-								}
-								return strings.Join(out, ",")
-							}
-
-							args := map[string]string{
+							args := map[string]interface{}{
 								"NamespaceA": nsA.Name(),
 								"NamespaceB": nsB.Name(),
 								"NamespaceC": to.Config().Namespace.Name(),
 								"cSet":       to.Config().Service,
-								"ipA":        addresses(a),
-								"ipB":        addresses(b),
-								"ipC":        addresses(to),
+								"ipA":        a.WorkloadsOrFail(t).Addresses(),
+								"ipB":        b.WorkloadsOrFail(t).Addresses(),
+								"ipC":        to.WorkloadsOrFail(t).Addresses(),
 								"portC":      "8090",
 								"a":          util.ASvc,
 								"b":          util.BSvc,
@@ -1114,7 +1102,7 @@ func TestAuthorization_Conditions(t *testing.T) {
 									if expectAllowed {
 										opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 									} else {
-										opts.Check = scheck.RBACFailure(&opts)
+										opts.Check = check.Forbidden(protocol.HTTP)
 									}
 
 									name := newRbacTestName("", expectAllowed, from, &opts)
@@ -1195,11 +1183,11 @@ func TestAuthorization_GRPC(t *testing.T) {
 		Features("security.authorization.grpc-protocol").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.A)
-			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
-			d := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.D)
-			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			a := match.Namespace(apps.Namespace1).GetMatches(apps.A)
+			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
+			d := match.Namespace(apps.Namespace1).GetMatches(apps.D)
+			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
 			for _, a := range []echo.Instances{a, vm} {
 				for _, b := range []echo.Instances{b, vm} {
 					if a[0].Config().Service == b[0].Config().Service {
@@ -1226,7 +1214,7 @@ func TestAuthorization_GRPC(t *testing.T) {
 									if expectAllowed {
 										opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 									} else {
-										opts.Check = scheck.RBACFailure(&opts)
+										opts.Check = check.Forbidden(protocol.GRPC)
 									}
 
 									name := newRbacTestName("", expectAllowed, from, &opts)
@@ -1258,11 +1246,11 @@ func TestAuthorization_Path(t *testing.T) {
 		Features("security.authorization.path-normalization").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := match.Namespace(ns.Name()).GetMatches(apps.A)
-			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
+			a := match.Namespace(ns).GetMatches(apps.A)
+			vm := match.Namespace(ns).GetMatches(apps.VM)
 			for _, a := range []echo.Instances{a, vm} {
 				for _, srcCluster := range t.Clusters() {
-					b := match.And(match.Cluster(srcCluster), match.Namespace(ns.Name())).GetMatches(apps.B)
+					b := match.And(match.Cluster(srcCluster), match.Namespace(ns)).GetMatches(apps.B)
 					if len(b) == 0 {
 						continue
 					}
@@ -1290,7 +1278,7 @@ func TestAuthorization_Path(t *testing.T) {
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 								} else {
-									opts.Check = scheck.RBACFailure(&opts)
+									opts.Check = check.Forbidden(protocol.HTTP)
 								}
 
 								name := newRbacTestName("", expectAllowed, from, &opts)
@@ -1328,11 +1316,11 @@ func TestAuthorization_Audit(t *testing.T) {
 	framework.NewTest(t).
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := match.Namespace(ns.Name()).GetMatches(apps.A)
-			b := match.Namespace(ns.Name()).GetMatches(apps.B)
-			c := match.Namespace(ns.Name()).GetMatches(apps.C)
-			d := match.Namespace(ns.Name()).GetMatches(apps.D)
-			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
+			a := match.Namespace(ns).GetMatches(apps.A)
+			b := match.Namespace(ns).GetMatches(apps.B)
+			c := match.Namespace(ns).GetMatches(apps.C)
+			d := match.Namespace(ns).GetMatches(apps.D)
+			vm := match.Namespace(ns).GetMatches(apps.VM)
 
 			policy := func(filename string) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
@@ -1370,7 +1358,7 @@ func TestAuthorization_Audit(t *testing.T) {
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 					} else {
-						opts.Check = scheck.RBACFailure(&opts)
+						opts.Check = check.Forbidden(protocol.HTTP)
 					}
 
 					name := newRbacTestName("", expectAllowed, from, &opts)
@@ -1433,7 +1421,7 @@ func TestAuthorization_Custom(t *testing.T) {
 			// Update the mesh config extension provider for the ext-authz service.
 			extService := fmt.Sprintf("ext-authz.%s.svc.cluster.local", ns.Name())
 			extServiceWithNs := fmt.Sprintf("%s/%s", ns.Name(), extService)
-			istio.PatchMeshConfig(t, ist.Settings().SystemNamespace, t.Clusters(), fmt.Sprintf(`
+			istio.PatchMeshConfigOrFail(t, ist.Settings().SystemNamespace, t.Clusters(), fmt.Sprintf(`
 extensionProviders:
 - name: "ext-authz-http"
   envoyExtAuthzHttp:
@@ -1520,10 +1508,11 @@ func TestAuthorization_Custom(t *testing.T) {
 							Headers: headers,
 						},
 					}
+					opts.FillDefaultsOrFail(t)
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 					} else {
-						opts.Check = scheck.RBACFailure(&opts)
+						opts.Check = check.Forbidden(opts.Port.Protocol)
 					}
 					opts.Check = check.And(opts.Check, checker)
 
@@ -1620,7 +1609,7 @@ func TestAuthorization_Custom(t *testing.T) {
 						if expectAllowed {
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 						} else {
-							opts.Check = scheck.RBACFailure(&opts)
+							opts.Check = check.Forbidden(protocol.HTTP)
 						}
 						opts.Check = check.And(opts.Check, checker)
 
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 34e3a4e092..21dba979af 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -117,12 +117,12 @@ func TestSecureNaming(t *testing.T) {
 			retry.UntilSuccessOrFail(t, func() error {
 				return checkCACert(t, testNamespace)
 			}, retry.Delay(time.Second), retry.Timeout(10*time.Second))
-			to := match.Namespace(testNamespace.Name()).GetMatches(apps.B)
+			to := match.Namespace(testNamespace).GetMatches(apps.B)
 			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.A)[0]
-					b := match.And(match.Cluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.B)[0]
+					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace)).GetMatches(apps.A)[0]
+					b := match.And(match.Cluster(cluster), match.Namespace(testNamespace)).GetMatches(apps.B)[0]
 					t.NewSubTest("mTLS cert validation with plugin CA").
 						Run(func(t framework.TestContext) {
 							// Verify that the certificate issued to the sidecar is as expected.
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index 0b9334776e..edb3832785 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -52,11 +52,11 @@ func TestReachability(t *testing.T) {
 			istioCfg := istio.DefaultConfigOrFail(t, t)
 			testNamespace := apps.Namespace
 			namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
-			to := match.Namespace(testNamespace.Name()).GetMatches(apps.B)
+			to := match.Namespace(testNamespace).GetMatches(apps.B)
 			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.A)[0]
+					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace)).GetMatches(apps.A)[0]
 					t.NewSubTest("Basic reachability with external ca").
 						Run(func(t framework.TestContext) {
 							// Verify mTLS works between a and b
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index c049d34434..3ac0bd8cf3 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -224,7 +224,7 @@ type expect struct {
 			}
 			for _, tt := range cases {
 				t.NewSubTest(tt.name).Run(func(t framework.TestContext) {
-					istio.PatchMeshConfig(t, ist.Settings().SystemNamespace, t.Clusters(), fmt.Sprintf(`
+					istio.PatchMeshConfigOrFail(t, ist.Settings().SystemNamespace, t.Clusters(), fmt.Sprintf(`
 pathNormalization:
   normalization: %v`, tt.ntype.String()))
 					for _, c := range apps.A {
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index a6511bec9c..7bb97326de 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -620,7 +620,7 @@ type expect struct {
 						To(
 							echotest.SingleSimplePodServiceAndAllSpecial(),
 							echotest.FilterMatch(match.And(
-								match.Namespace(ns.Name()),
+								match.Namespace(ns),
 								match.NotHeadless,
 								match.NotNaked,
 								match.NotExternal,
diff --git a/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
index 67e0f20e2d..113d8cb12f 100644
--- a/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
+++ b/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
@@ -79,13 +79,13 @@ spec:
         paths: ["/source-ip-{{ .a }}"]
     when:
     - key: source.ip
-      values: [{{ .ipA }}]
+      values: {{ toJson .ipA }}
   - to:
     - operation:
         paths: ["/source-ip-{{ .b }}"]
     when:
     - key: source.ip
-      values: [{{ .ipB }}]
+      values: {{ toJson .ipB }}
 ---
 
 apiVersion: security.istio.io/v1beta1
@@ -103,7 +103,7 @@ spec:
         paths: ["/source-ip-notValues-{{ .b }}"]
     when:
     - key: source.ip
-      notValues: [{{ .ipB }}]
+      notValues: {{ toJson .ipB }}
 ---
 
 apiVersion: security.istio.io/v1beta1
@@ -205,7 +205,7 @@ spec:
         paths: ["/destination-ip-good"]
     when:
     - key: destination.ip
-      values: [{{ .ipC }}]
+      values: {{ toJson .ipC }}
   - to:
     - operation:
         paths: ["/destination-ip-bad"]
@@ -229,13 +229,13 @@ spec:
         paths: ["/destination-ip-notValues-{{ .a }}-or-{{ .b }}"]
     when:
     - key: destination.ip
-      notValues: [{{ .ipA }}, {{ .ipB }}]
+      notValues: {{ concat .ipA .ipB | toJson }}
   - to:
     - operation:
         paths: ["/destination-ip-notValues-{{ .a }}-or-{{ .b }}-or-{{ .cSet }}"]
     when:
     - key: destination.ip
-      notValues: [{{ .ipA }}, {{ .ipB }}, {{ .ipC }}]
+      notValues: {{ concat .ipA .ipB .ipC | toJson }}
 ---
 
 apiVersion: security.istio.io/v1beta1
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 8fa5c7244b..ce83a6875b 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -116,7 +116,7 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 				// TODO(https://github.com/istio/istio/issues/20460) We shouldn't need a retry loop
 				return cfg.Apply(resource.Wait)
 			})
-			for _, clients := range []echo.Instances{apps.A, match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B), apps.Headless, apps.Naked, apps.HeadlessNaked} {
+			for _, clients := range []echo.Instances{apps.A, match.Namespace(apps.Namespace1).GetMatches(apps.B), apps.Headless, apps.Naked, apps.HeadlessNaked} {
 				for _, from := range clients {
 					from := from
 					t.NewSubTest(fmt.Sprintf("%s in %s",
diff --git a/tests/integration/security/util/scheck/checkers.go b/tests/integration/security/util/scheck/checkers.go
index 5a4f19a0f4..3ae862080a 100644
--- a/tests/integration/security/util/scheck/checkers.go
+++ b/tests/integration/security/util/scheck/checkers.go
@@ -45,25 +45,11 @@ func NotOK() echo.Checker {
 func ReachedClusters(allClusters cluster.Clusters, opts *echo.CallOptions) echo.Checker {
 	// TODO(https://github.com/istio/istio/issues/37307): Investigate why we don't reach all clusters.
 	if opts.To.Clusters().IsMulticluster() && opts.Count > 1 && opts.Scheme != scheme.GRPC && !opts.To.Config().IsHeadless() {
-		return check.ReachedClusters(allClusters, opts.To.Clusters())
+		return check.ReachedTargetClusters(allClusters)
 	}
 	return echo.NoChecker()
 }
 
-func RBACFailure(opts *echo.CallOptions) echo.Checker {
-	if opts.Port.Name == "grpc" {
-		return check.ErrorContains("rpc error: code = PermissionDenied desc = RBAC: access denied")
-	}
-
-	if strings.HasPrefix(opts.Port.Name, "tcp") {
-		return check.ErrorContains("EOF")
-	}
-
-	return check.And(
-		check.NoError(),
-		check.Status(http.StatusForbidden))
-}
-
 func HeaderContains(hType echoClient.HeaderType, expected map[string][]string) echo.Checker {
 	return check.Each(func(r echoClient.Response) error {
 		h := r.GetHeaders(hType)
-- 
2.35.3

