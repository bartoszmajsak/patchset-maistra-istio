From e3904269b7bd95207fdccd2be6f14276a3ad470a Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Mon, 21 Feb 2022 10:41:25 +0800
Subject: Refactor Services to remove dummy proxy (#37427)

* Refactor Services to remove dummy proxy

* Change servicesForSidecarScope to servicesExportToNamespace

* use NameapceAll

* address comments

* Fix tests

* Fix tests

* go imports
---
 pilot/pkg/model/push_context.go               | 59 ++++++++++---------
 pilot/pkg/model/push_context_test.go          | 10 ++--
 pilot/pkg/model/sidecar.go                    | 30 ++++------
 pilot/pkg/networking/apigen/apigen.go         |  2 +-
 pilot/pkg/networking/core/v1alpha3/cluster.go |  4 +-
 pilot/pkg/networking/core/v1alpha3/gateway.go |  8 +--
 pilot/pkg/networking/grpcgen/lds.go           |  6 +-
 pilot/pkg/xds/ads.go                          |  2 +-
 pilot/pkg/xds/eds.go                          |  2 +-
 pkg/dns/server/name_table.go                  |  2 +-
 pkg/dns/server/name_table_test.go             |  7 +++
 11 files changed, 67 insertions(+), 65 deletions(-)

diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 3598e942db..94977c1fed 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -725,7 +725,7 @@ func virtualServiceDestinationHosts(v *networking.VirtualService) []string {
 
 // GatewayServices returns the set of services which are referred from the proxy gateways.
 func (ps *PushContext) GatewayServices(proxy *Proxy) []*Service {
-	svcs := ps.Services(proxy)
+	svcs := proxy.SidecarScope.services
 	// host set.
 	hostsFromGateways := map[string]struct{}{}
 
@@ -736,7 +736,7 @@ func (ps *PushContext) GatewayServices(proxy *Proxy) []*Service {
 	}
 
 	for _, gw := range proxy.MergedGateway.GatewayNameForServer {
-		for _, vsConfig := range ps.VirtualServicesForGateway(proxy, gw) {
+		for _, vsConfig := range ps.VirtualServicesForGateway(proxy.ConfigNamespace, gw) {
 			vs, ok := vsConfig.Spec.(*networking.VirtualService)
 			if !ok { // should never happen
 				log.Errorf("Failed in getting a virtual service: %v", vsConfig.Labels)
@@ -766,24 +766,19 @@ func (ps *PushContext) GatewayServices(proxy *Proxy) []*Service {
 	return gwSvcs
 }
 
-// Services returns the list of services that are visible to a Proxy in a given config namespace
-func (ps *PushContext) Services(proxy *Proxy) []*Service {
-	// If proxy has a sidecar scope that is user supplied, then get the services from the sidecar scope
-	// sidecarScope.config is nil if there is no sidecar scope for the namespace
-	if proxy != nil && proxy.SidecarScope != nil && proxy.Type == SidecarProxy {
-		return proxy.SidecarScope.services
-	}
-
+// servicesExportedToNamespace returns the list of services that are visible to a namespace.
+// namespace "" indicates all namespaces
+func (ps *PushContext) servicesExportedToNamespace(ns string) []*Service {
 	out := make([]*Service, 0)
 
 	// First add private services and explicitly exportedTo services
-	if proxy == nil {
+	if ns == NamespaceAll {
 		for _, privateServices := range ps.ServiceIndex.privateByNamespace {
 			out = append(out, privateServices...)
 		}
 	} else {
-		out = append(out, ps.ServiceIndex.privateByNamespace[proxy.ConfigNamespace]...)
-		out = append(out, ps.ServiceIndex.exportedToNamespace[proxy.ConfigNamespace]...)
+		out = append(out, ps.ServiceIndex.privateByNamespace[ns]...)
+		out = append(out, ps.ServiceIndex.exportedToNamespace[ns]...)
 	}
 
 	// Second add public services
@@ -792,6 +787,12 @@ func (ps *PushContext) Services(proxy *Proxy) []*Service {
 	return out
 }
 
+// GetAllServices returns the total services within the mesh.
+// Note: per proxy services should use SidecarScope.Services.
+func (ps *PushContext) GetAllServices() []*Service {
+	return ps.servicesExportedToNamespace(NamespaceAll)
+}
+
 // ServiceForHostname returns the service associated with a given hostname following SidecarScope
 func (ps *PushContext) ServiceForHostname(proxy *Proxy, hostname host.Name) *Service {
 	if proxy != nil && proxy.SidecarScope != nil {
@@ -831,12 +832,12 @@ func (ps *PushContext) IsServiceVisible(service *Service, namespace string) bool
 // VirtualServicesForGateway lists all virtual services bound to the specified gateways
 // This replaces store.VirtualServices. Used only by the gateways
 // Sidecars use the egressListener.VirtualServices().
-func (ps *PushContext) VirtualServicesForGateway(proxy *Proxy, gateway string) []config.Config {
-	res := make([]config.Config, 0, len(ps.virtualServiceIndex.privateByNamespaceAndGateway[proxy.ConfigNamespace][gateway])+
-		len(ps.virtualServiceIndex.exportedToNamespaceByGateway[proxy.ConfigNamespace][gateway])+
+func (ps *PushContext) VirtualServicesForGateway(proxyNamespace, gateway string) []config.Config {
+	res := make([]config.Config, 0, len(ps.virtualServiceIndex.privateByNamespaceAndGateway[proxyNamespace][gateway])+
+		len(ps.virtualServiceIndex.exportedToNamespaceByGateway[proxyNamespace][gateway])+
 		len(ps.virtualServiceIndex.publicByGateway[gateway]))
-	res = append(res, ps.virtualServiceIndex.privateByNamespaceAndGateway[proxy.ConfigNamespace][gateway]...)
-	res = append(res, ps.virtualServiceIndex.exportedToNamespaceByGateway[proxy.ConfigNamespace][gateway]...)
+	res = append(res, ps.virtualServiceIndex.privateByNamespaceAndGateway[proxyNamespace][gateway]...)
+	res = append(res, ps.virtualServiceIndex.exportedToNamespaceByGateway[proxyNamespace][gateway]...)
 	res = append(res, ps.virtualServiceIndex.publicByGateway[gateway]...)
 	return res
 }
@@ -935,8 +936,8 @@ func (ps *PushContext) getSidecarScope(proxy *Proxy, workloadLabels labels.Colle
 	return computed
 }
 
-// destinationRule returns a destination rule for a service name in a given namespace(proxy's configNamespace).
-func (ps *PushContext) destinationRule(proxy *Proxy, service *Service) *config.Config {
+// destinationRule returns a destination rule for a service name in a given namespace.
+func (ps *PushContext) destinationRule(proxyNameSpace string, service *Service) *config.Config {
 	if service == nil {
 		return nil
 	}
@@ -951,14 +952,14 @@ func (ps *PushContext) destinationRule(proxy *Proxy, service *Service) *config.C
 	// rules anyway, later in the code
 
 	// 1. select destination rule from proxy config namespace
-	if proxy.ConfigNamespace != ps.Mesh.RootNamespace {
+	if proxyNameSpace != ps.Mesh.RootNamespace {
 		// search through the DestinationRules in proxy's namespace first
-		if ps.destinationRuleIndex.namespaceLocal[proxy.ConfigNamespace] != nil {
+		if ps.destinationRuleIndex.namespaceLocal[proxyNameSpace] != nil {
 			if hostname, ok := MostSpecificHostMatch(service.Hostname,
-				ps.destinationRuleIndex.namespaceLocal[proxy.ConfigNamespace].hostsMap,
-				ps.destinationRuleIndex.namespaceLocal[proxy.ConfigNamespace].hosts,
+				ps.destinationRuleIndex.namespaceLocal[proxyNameSpace].hostsMap,
+				ps.destinationRuleIndex.namespaceLocal[proxyNameSpace].hosts,
 			); ok {
-				return ps.destinationRuleIndex.namespaceLocal[proxy.ConfigNamespace].destRule[hostname]
+				return ps.destinationRuleIndex.namespaceLocal[proxyNameSpace].destRule[hostname]
 			}
 		}
 	} else {
@@ -980,7 +981,7 @@ func (ps *PushContext) destinationRule(proxy *Proxy, service *Service) *config.C
 	// Because based on a pure cluster's fqdn, we do not know the service and
 	// construct a fake service without setting Attributes at all.
 	if svcNs == "" {
-		for _, svc := range ps.Services(proxy) {
+		for _, svc := range ps.servicesExportedToNamespace(proxyNameSpace) {
 			if service.Hostname == svc.Hostname && svc.Attributes.Namespace != "" {
 				svcNs = svc.Attributes.Namespace
 				break
@@ -991,21 +992,21 @@ func (ps *PushContext) destinationRule(proxy *Proxy, service *Service) *config.C
 	// 3. if no private/public rule matched in the calling proxy's namespace,
 	// check the target service's namespace for exported rules
 	if svcNs != "" {
-		if out := ps.getExportedDestinationRuleFromNamespace(svcNs, service.Hostname, proxy.ConfigNamespace); out != nil {
+		if out := ps.getExportedDestinationRuleFromNamespace(svcNs, service.Hostname, proxyNameSpace); out != nil {
 			return out
 		}
 	}
 
 	// 4. if no public/private rule in calling proxy's namespace matched, and no public rule in the
 	// target service's namespace matched, search for any exported destination rule in the config root namespace
-	if out := ps.getExportedDestinationRuleFromNamespace(ps.Mesh.RootNamespace, service.Hostname, proxy.ConfigNamespace); out != nil {
+	if out := ps.getExportedDestinationRuleFromNamespace(ps.Mesh.RootNamespace, service.Hostname, proxyNameSpace); out != nil {
 		return out
 	}
 
 	// 5. service DestinationRules were merged in SetDestinationRules, return mesh/namespace rules if present
 	if features.EnableDestinationRuleInheritance {
 		// return namespace rule if present
-		if out := ps.destinationRuleIndex.inheritedByNamespace[proxy.ConfigNamespace]; out != nil {
+		if out := ps.destinationRuleIndex.inheritedByNamespace[proxyNameSpace]; out != nil {
 			return out
 		}
 		// return mesh rule
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index 344acf2c42..307c100a1b 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -1343,7 +1343,7 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 	ps.SetDestinationRules([]config.Config{meshDestinationRule, nsDestinationRule, svcDestinationRule, destinationRuleNamespace2})
 
 	for _, tt := range testCases {
-		mergedConfig := ps.destinationRule(&Proxy{ConfigNamespace: tt.proxyNs},
+		mergedConfig := ps.destinationRule(tt.proxyNs,
 			&Service{
 				Hostname: host.Name(tt.serviceHostname),
 				Attributes: ServiceAttributes{
@@ -1622,7 +1622,7 @@ func TestSetDestinationRuleWithExportTo(t *testing.T) {
 	}
 	for _, tt := range cases {
 		t.Run(fmt.Sprintf("%s-%s", tt.proxyNs, tt.serviceNs), func(t *testing.T) {
-			destRuleConfig := ps.destinationRule(&Proxy{ConfigNamespace: tt.proxyNs},
+			destRuleConfig := ps.destinationRule(tt.proxyNs,
 				&Service{
 					Hostname: host.Name(tt.host),
 					Attributes: ServiceAttributes{
@@ -1781,7 +1781,7 @@ func TestVirtualServiceWithExportTo(t *testing.T) {
 	}
 	for _, tt := range cases {
 		t.Run(fmt.Sprintf("%s-%s", tt.proxyNs, tt.gateway), func(t *testing.T) {
-			rules := ps.VirtualServicesForGateway(&Proxy{ConfigNamespace: tt.proxyNs}, tt.gateway)
+			rules := ps.VirtualServicesForGateway(tt.proxyNs, tt.gateway)
 			gotHosts := make([]string, 0)
 			for _, r := range rules {
 				vs := r.Spec.(*networking.VirtualService)
@@ -1872,7 +1872,7 @@ func TestInitVirtualService(t *testing.T) {
 	}
 
 	t.Run("resolve shortname", func(t *testing.T) {
-		rules := ps.VirtualServicesForGateway(&Proxy{ConfigNamespace: "ns1"}, gatewayName)
+		rules := ps.VirtualServicesForGateway("ns1", gatewayName)
 		if len(rules) != 1 {
 			t.Fatalf("wanted 1 virtualservice for gateway %s, actually got %d", gatewayName, len(rules))
 		}
@@ -1961,7 +1961,7 @@ func TestServiceWithExportTo(t *testing.T) {
 		},
 	}
 	for _, tt := range cases {
-		services := ps.Services(&Proxy{ConfigNamespace: tt.proxyNs})
+		services := ps.servicesExportedToNamespace(tt.proxyNs)
 		gotHosts := make([]string, 0)
 		for _, r := range services {
 			gotHosts = append(gotHosts, string(r.Hostname))
diff --git a/pilot/pkg/model/sidecar.go b/pilot/pkg/model/sidecar.go
index a131c33d25..b1c478eabf 100644
--- a/pilot/pkg/model/sidecar.go
+++ b/pilot/pkg/model/sidecar.go
@@ -171,17 +171,13 @@ type IstioEgressListenerWrapper struct {
 // that matches the default Istio behavior: a sidecar has listeners for all services in the mesh
 // We use this scope when the user has not set any sidecar Config for a given config namespace.
 func DefaultSidecarScopeForNamespace(ps *PushContext, configNamespace string) *SidecarScope {
-	dummyNode := Proxy{
-		ConfigNamespace: configNamespace,
-	}
-
 	defaultEgressListener := &IstioEgressListenerWrapper{
 		IstioListener: &networking.IstioEgressListener{
 			Hosts: []string{"*/*"},
 		},
 	}
-	defaultEgressListener.services = ps.Services(&dummyNode)
-	defaultEgressListener.virtualServices = ps.VirtualServicesForGateway(&dummyNode, constants.IstioMeshGateway)
+	defaultEgressListener.services = ps.servicesExportedToNamespace(configNamespace)
+	defaultEgressListener.virtualServices = ps.VirtualServicesForGateway(configNamespace, constants.IstioMeshGateway)
 
 	out := &SidecarScope{
 		Name:               defaultSidecar,
@@ -210,7 +206,7 @@ func DefaultSidecarScopeForNamespace(ps *PushContext, configNamespace string) *S
 			continue
 		}
 		out.servicesByHostname[s.Hostname] = s
-		if dr := ps.destinationRule(&dummyNode, s); dr != nil {
+		if dr := ps.destinationRule(configNamespace, s); dr != nil {
 			out.destinationRules[s.Hostname] = dr
 		}
 		out.AddConfigDependencies(ConfigKey{
@@ -289,10 +285,6 @@ func ConvertToSidecarScope(ps *PushContext, sidecarConfig *config.Config, config
 	// this sidecar crd. This is needed to generate CDS output
 	out.services = make([]*Service, 0)
 	servicesAdded := make(map[host.Name]*Service)
-	dummyNode := Proxy{
-		ConfigNamespace: configNamespace,
-	}
-
 	addService := func(s *Service) {
 		if s == nil {
 			return
@@ -405,7 +397,7 @@ func ConvertToSidecarScope(ps *PushContext, sidecarConfig *config.Config, config
 	out.destinationRules = make(map[host.Name]*config.Config)
 	for _, s := range out.services {
 		out.servicesByHostname[s.Hostname] = s
-		dr := ps.destinationRule(&dummyNode, s)
+		dr := ps.destinationRule(configNamespace, s)
 		if dr != nil {
 			out.destinationRules[s.Hostname] = dr
 			out.AddConfigDependencies(ConfigKey{
@@ -451,13 +443,9 @@ func convertIstioListenerToWrapper(ps *PushContext, configNamespace string,
 		out.listenerHosts[parts[0]] = append(out.listenerHosts[parts[0]], host.Name(parts[1]))
 	}
 
-	dummyNode := Proxy{
-		ConfigNamespace: configNamespace,
-	}
-
-	vses := ps.VirtualServicesForGateway(&dummyNode, constants.IstioMeshGateway)
+	vses := ps.VirtualServicesForGateway(configNamespace, constants.IstioMeshGateway)
 	out.virtualServices = SelectVirtualServices(vses, out.listenerHosts)
-	svces := ps.Services(&dummyNode)
+	svces := ps.servicesExportedToNamespace(configNamespace)
 	out.services = out.selectServices(svces, configNamespace, out.listenerHosts)
 
 	return out
@@ -557,10 +545,16 @@ func (sc *SidecarScope) AddConfigDependencies(dependencies ...ConfigKey) {
 	}
 }
 
+// DestinationRule returns a destinationrule for a svc.
 func (sc *SidecarScope) DestinationRule(svc host.Name) *config.Config {
 	return sc.destinationRules[svc]
 }
 
+// Services returns the list of services that are visible to a sidecar.
+func (sc *SidecarScope) Services() []*Service {
+	return sc.services
+}
+
 // Return filtered services through the hosts field in the egress portion of the Sidecar config.
 // Note that the returned service could be trimmed.
 func (ilw *IstioEgressListenerWrapper) selectServices(services []*Service, configNamespace string, hosts map[string][]host.Name) []*Service {
diff --git a/pilot/pkg/networking/apigen/apigen.go b/pilot/pkg/networking/apigen/apigen.go
index dd918b1de6..03173d4594 100644
--- a/pilot/pkg/networking/apigen/apigen.go
+++ b/pilot/pkg/networking/apigen/apigen.go
@@ -138,7 +138,7 @@ func (g *APIGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *
 	if w.TypeUrl == gvk.ServiceEntry.String() {
 		// Include 'synthetic' SE - but without the endpoints. Used to generate CDS, LDS.
 		// EDS is pass-through.
-		svcs := push.Services(proxy)
+		svcs := proxy.SidecarScope.Services()
 		for _, s := range svcs {
 			// Ignore services that are result of conversion from ServiceEntry.
 			if s.Attributes.ServiceRegistry == provider.External {
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster.go b/pilot/pkg/networking/core/v1alpha3/cluster.go
index d7ec154e13..1d77d21f06 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster.go
@@ -83,7 +83,7 @@ func (configgen *ConfigGeneratorImpl) BuildClusters(proxy *model.Proxy, req *mod
 	if features.FilterGatewayClusterConfig && proxy.Type == model.Router {
 		services = req.Push.GatewayServices(proxy)
 	} else {
-		services = req.Push.Services(proxy)
+		services = proxy.SidecarScope.Services()
 	}
 	return configgen.buildClusters(proxy, req, services)
 }
@@ -335,7 +335,7 @@ func (configgen *ConfigGeneratorImpl) buildOutboundSniDnatClusters(proxy *model.
 
 	networkView := proxy.GetNetworkView()
 
-	for _, service := range req.Push.Services(proxy) {
+	for _, service := range proxy.SidecarScope.Services() {
 		if service.MeshExternal {
 			continue
 		}
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway.go b/pilot/pkg/networking/core/v1alpha3/gateway.go
index bfa9bd173c..1e72be4d6e 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway.go
@@ -365,7 +365,7 @@ func (configgen *ConfigGeneratorImpl) buildGatewayHTTPRouteConfig(node *model.Pr
 		var exists bool
 
 		if virtualServices, exists = gatewayVirtualServices[gatewayName]; !exists {
-			virtualServices = push.VirtualServicesForGateway(node, gatewayName)
+			virtualServices = push.VirtualServicesForGateway(node.ConfigNamespace, gatewayName)
 			gatewayVirtualServices[gatewayName] = virtualServices
 		}
 
@@ -730,7 +730,7 @@ func buildGatewayNetworkFiltersFromTCPRoutes(node *model.Proxy, push *model.Push
 		gatewayServerHosts[host.Name(hostname)] = true
 	}
 
-	virtualServices := push.VirtualServicesForGateway(node, gateway)
+	virtualServices := push.VirtualServicesForGateway(node.ConfigNamespace, gateway)
 	if len(virtualServices) == 0 {
 		log.Warnf("no virtual service bound to gateway: %v", gateway)
 	}
@@ -791,7 +791,7 @@ func buildGatewayNetworkFiltersFromTLSRoutes(node *model.Proxy, push *model.Push
 	} else {
 		tlsSniHosts := map[string]struct{}{} // sni host -> exists
 
-		virtualServices := push.VirtualServicesForGateway(node, gatewayName)
+		virtualServices := push.VirtualServicesForGateway(node.ConfigNamespace, gatewayName)
 		for _, v := range virtualServices {
 			vsvc := v.Spec.(*networking.VirtualService)
 			// We have two cases here:
@@ -843,7 +843,7 @@ func buildGatewayNetworkFiltersFromTLSRoutes(node *model.Proxy, push *model.Push
 // To handle this, we generate a filter chain per upstream cluster
 func builtAutoPassthroughFilterChains(push *model.PushContext, proxy *model.Proxy, hosts []string) []*filterChainOpts {
 	filterChains := make([]*filterChainOpts, 0)
-	for _, service := range push.Services(proxy) {
+	for _, service := range proxy.SidecarScope.Services() {
 		if service.MeshExternal {
 			continue
 		}
diff --git a/pilot/pkg/networking/grpcgen/lds.go b/pilot/pkg/networking/grpcgen/lds.go
index 05d77cd7db..c1a5a06cb0 100644
--- a/pilot/pkg/networking/grpcgen/lds.go
+++ b/pilot/pkg/networking/grpcgen/lds.go
@@ -52,7 +52,7 @@ func (g *GrpcConfigGenerator) BuildListeners(node *model.Proxy, push *model.Push
 	log.Debugf("building lds for %s with filter:\n%v", node.ID, filter)
 
 	resp := make(model.Resources, 0, len(filter))
-	resp = append(resp, buildOutboundListeners(node, push, filter)...)
+	resp = append(resp, buildOutboundListeners(node, filter)...)
 	resp = append(resp, buildInboundListeners(node, push, filter.inboundNames())...)
 
 	return resp
@@ -185,9 +185,9 @@ func buildInboundFilterChain(nameSuffix string, tlsContext *tls.DownstreamTlsCon
 	return out
 }
 
-func buildOutboundListeners(node *model.Proxy, push *model.PushContext, filter listenerNames) model.Resources {
+func buildOutboundListeners(node *model.Proxy, filter listenerNames) model.Resources {
 	out := make(model.Resources, 0, len(filter))
-	for _, sv := range push.Services(node) {
+	for _, sv := range node.SidecarScope.Services() {
 		serviceHost := string(sv.Hostname)
 		match, ok := filter.includes(serviceHost)
 		if !ok {
diff --git a/pilot/pkg/xds/ads.go b/pilot/pkg/xds/ads.go
index 1359cae823..f8f5993f15 100644
--- a/pilot/pkg/xds/ads.go
+++ b/pilot/pkg/xds/ads.go
@@ -823,7 +823,7 @@ func (s *DiscoveryServer) AdsPushAll(version string, req *model.PushRequest) {
 		log.Infof("XDS: Incremental Pushing:%s ConnectedEndpoints:%d Version:%s",
 			version, s.adsClientCount(), req.Push.PushVersion)
 	} else {
-		totalService := len(req.Push.Services(nil))
+		totalService := len(req.Push.GetAllServices())
 		log.Infof("XDS: Pushing:%s Services:%d ConnectedEndpoints:%d Version:%s",
 			version, totalService, s.adsClientCount(), req.Push.PushVersion)
 		monServices.Record(float64(totalService))
diff --git a/pilot/pkg/xds/eds.go b/pilot/pkg/xds/eds.go
index 599864b088..bca9c7f2ba 100644
--- a/pilot/pkg/xds/eds.go
+++ b/pilot/pkg/xds/eds.go
@@ -60,7 +60,7 @@ func (s *DiscoveryServer) UpdateServiceShards(push *model.PushContext) error {
 	}
 	// Each registry acts as a shard - we don't want to combine them because some
 	// may individually update their endpoints incrementally
-	for _, svc := range push.Services(nil) {
+	for _, svc := range push.GetAllServices() {
 		for _, registry := range registries {
 			// skip the service in case this svc does not belong to the registry.
 			if svc.Attributes.ServiceRegistry != registry.Provider() {
diff --git a/pkg/dns/server/name_table.go b/pkg/dns/server/name_table.go
index e15d2a1b19..c753b9335f 100644
--- a/pkg/dns/server/name_table.go
+++ b/pkg/dns/server/name_table.go
@@ -46,7 +46,7 @@ func BuildNameTable(cfg Config) *dnsProto.NameTable {
 	out := &dnsProto.NameTable{
 		Table: make(map[string]*dnsProto.NameTable_NameInfo),
 	}
-	for _, svc := range cfg.Push.Services(cfg.Node) {
+	for _, svc := range cfg.Node.SidecarScope.Services() {
 		svcAddress := svc.GetAddressForProxy(cfg.Node)
 		var addressList []string
 		hostName := svc.Hostname
diff --git a/pkg/dns/server/name_table_test.go b/pkg/dns/server/name_table_test.go
index cf89c4c8b6..e57ac1ed07 100644
--- a/pkg/dns/server/name_table_test.go
+++ b/pkg/dns/server/name_table_test.go
@@ -20,6 +20,7 @@
 	"github.com/google/go-cmp/cmp"
 	"google.golang.org/protobuf/testing/protocmp"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pkg/config/constants"
@@ -43,6 +44,7 @@ func makeServiceInstances(proxy *model.Proxy, service *model.Service, hostname,
 }
 
 func TestNameTable(t *testing.T) {
+	mesh := &meshconfig.MeshConfig{RootNamespace: "istio-system"}
 	proxy := &model.Proxy{
 		IPAddresses: []string{"9.9.9.9"},
 		Metadata:    &model.NodeMetadata{},
@@ -167,6 +169,7 @@ func TestNameTable(t *testing.T) {
 	}
 
 	push := model.NewPushContext()
+	push.Mesh = mesh
 	push.AddPublicServices([]*model.Service{headlessService})
 	push.AddServiceInstances(headlessService,
 		makeServiceInstances(pod1, headlessService, "pod1", "headless-svc"))
@@ -178,12 +181,15 @@ func TestNameTable(t *testing.T) {
 		makeServiceInstances(pod4, headlessService, "pod4", "headless-svc"))
 
 	wpush := model.NewPushContext()
+	wpush.Mesh = mesh
 	wpush.AddPublicServices([]*model.Service{wildcardService})
 
 	cpush := model.NewPushContext()
+	cpush.Mesh = mesh
 	wpush.AddPublicServices([]*model.Service{cidrService})
 
 	sepush := model.NewPushContext()
+	sepush.Mesh = mesh
 	sepush.AddPublicServices([]*model.Service{headlessServiceForServiceEntry})
 	sepush.AddServiceInstances(headlessServiceForServiceEntry,
 		makeServiceInstances(pod1, headlessServiceForServiceEntry, "", ""))
@@ -417,6 +423,7 @@ func TestNameTable(t *testing.T) {
 	}
 	for _, tt := range cases {
 		t.Run(tt.name, func(t *testing.T) {
+			tt.proxy.SidecarScope = model.ConvertToSidecarScope(tt.push, nil, "default")
 			if diff := cmp.Diff(dnsServer.BuildNameTable(dnsServer.Config{
 				Node:                        tt.proxy,
 				Push:                        tt.push,
-- 
2.35.3

