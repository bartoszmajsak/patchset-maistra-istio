From 908d3fb4768e103e4d949dcc2a2cb2badce9d627 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Tue, 15 Feb 2022 14:05:42 -0800
Subject: [TF] Install Istio with istioctl library (#37332)

This avoids race conditions associated with using global variables in istioctl.
---
 operator/cmd/mesh/install.go                  | 142 ++++++++------
 operator/cmd/mesh/manifest-diff.go            |   6 +-
 operator/cmd/mesh/manifest-generate.go        |  78 ++++----
 operator/cmd/mesh/manifest.go                 |   6 +-
 operator/cmd/mesh/operator-common.go          |   2 +-
 operator/cmd/mesh/operator-dump.go            |   4 +-
 operator/cmd/mesh/operator-init.go            |   6 +-
 operator/cmd/mesh/operator-remove.go          |   6 +-
 operator/cmd/mesh/operator.go                 |   2 +-
 operator/cmd/mesh/operator_test.go            |   2 +-
 operator/cmd/mesh/profile-diff.go             |   4 +-
 operator/cmd/mesh/profile-dump.go             |   4 +-
 operator/cmd/mesh/profile-list.go             |   4 +-
 operator/cmd/mesh/profile.go                  |   2 +-
 operator/cmd/mesh/root.go                     |  10 +-
 operator/cmd/mesh/shared.go                   |  25 ++-
 operator/cmd/mesh/uninstall.go                |   6 +-
 operator/cmd/mesh/upgrade.go                  |  31 +--
 .../framework/components/istio/eastwest.go    |  51 ++---
 .../framework/components/istio/operator.go    | 180 +++++++++++-------
 20 files changed, 334 insertions(+), 237 deletions(-)

diff --git a/operator/cmd/mesh/install.go b/operator/cmd/mesh/install.go
index 9f17381575..ad3b59b296 100644
--- a/operator/cmd/mesh/install.go
+++ b/operator/cmd/mesh/install.go
@@ -17,6 +17,7 @@
 import (
 	"context"
 	"fmt"
+	"io"
 	"os"
 	"sort"
 	"strings"
@@ -47,52 +48,64 @@
 	"istio.io/pkg/log"
 )
 
-type installArgs struct {
-	// inFilenames is an array of paths to the input IstioOperator CR files.
-	inFilenames []string
-	// kubeConfigPath is the path to kube config file.
-	kubeConfigPath string
-	// context is the cluster context in the kube config
-	context string
-	// readinessTimeout is maximum time to wait for all Istio resources to be ready. wait must be true for this setting
+type InstallArgs struct {
+	// InFilenames is an array of paths to the input IstioOperator CR files.
+	InFilenames []string
+	// KubeConfigPath is the path to kube config file.
+	KubeConfigPath string
+	// Context is the cluster context in the kube config
+	Context string
+	// ReadinessTimeout is maximum time to wait for all Istio resources to be ready. wait must be true for this setting
 	// to take effect.
-	readinessTimeout time.Duration
-	// skipConfirmation determines whether the user is prompted for confirmation.
+	ReadinessTimeout time.Duration
+	// SkipConfirmation determines whether the user is prompted for confirmation.
 	// If set to true, the user is not prompted and a Yes response is assumed in all cases.
-	skipConfirmation bool
-	// force proceeds even if there are validation errors
-	force bool
-	// verify after installation
-	verify bool
-	// set is a string with element format "path=value" where path is an IstioOperator path and the value is a
+	SkipConfirmation bool
+	// Force proceeds even if there are validation errors
+	Force bool
+	// Verify after installation
+	Verify bool
+	// Set is a string with element format "path=value" where path is an IstioOperator path and the value is a
 	// value to set the node at that path to.
-	set []string
-	// manifestsPath is a path to a manifestsPath and profiles directory in the local filesystem, or URL with a release tgz.
-	manifestsPath string
-	// revision is the Istio control plane revision the command targets.
-	revision string
+	Set []string
+	// ManifestsPath is a path to a ManifestsPath and profiles directory in the local filesystem, or URL with a release tgz.
+	ManifestsPath string
+	// Revision is the Istio control plane revision the command targets.
+	Revision string
 }
 
-func addInstallFlags(cmd *cobra.Command, args *installArgs) {
-	cmd.PersistentFlags().StringSliceVarP(&args.inFilenames, "filename", "f", nil, filenameFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.kubeConfigPath, "kubeconfig", "c", "", KubeConfigFlagHelpStr)
-	cmd.PersistentFlags().StringVar(&args.context, "context", "", ContextFlagHelpStr)
-	cmd.PersistentFlags().DurationVar(&args.readinessTimeout, "readiness-timeout", 300*time.Second,
-		"Maximum time to wait for Istio resources in each component to be ready.")
-	cmd.PersistentFlags().BoolVarP(&args.skipConfirmation, "skip-confirmation", "y", false, skipConfirmationFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.force, "force", false, ForceFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.verify, "verify", false, VerifyCRInstallHelpStr)
-	cmd.PersistentFlags().StringArrayVarP(&args.set, "set", "s", nil, setFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "charts", "", "", ChartsDeprecatedStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.revision, "revision", "r", "", revisionFlagHelpStr)
+func (a *InstallArgs) String() string {
+	var b strings.Builder
+	b.WriteString("InFilenames:      " + fmt.Sprint(a.InFilenames) + "\n")
+	b.WriteString("KubeConfigPath:   " + a.KubeConfigPath + "\n")
+	b.WriteString("Context:          " + a.Context + "\n")
+	b.WriteString("ReadinessTimeout: " + fmt.Sprint(a.ReadinessTimeout) + "\n")
+	b.WriteString("SkipConfirmation: " + fmt.Sprint(a.SkipConfirmation) + "\n")
+	b.WriteString("Force:            " + fmt.Sprint(a.Force) + "\n")
+	b.WriteString("Verify:           " + fmt.Sprint(a.Verify) + "\n")
+	b.WriteString("Set:              " + fmt.Sprint(a.Set) + "\n")
+	b.WriteString("ManifestsPath:    " + a.ManifestsPath + "\n")
+	b.WriteString("Revision:         " + a.Revision + "\n")
+	return b.String()
 }
 
-// InstallCmd generates an Istio install manifest and applies it to a cluster
-func InstallCmd(logOpts *log.Options) *cobra.Command {
-	rootArgs := &rootArgs{}
-	iArgs := &installArgs{}
+func addInstallFlags(cmd *cobra.Command, args *InstallArgs) {
+	cmd.PersistentFlags().StringSliceVarP(&args.InFilenames, "filename", "f", nil, filenameFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.KubeConfigPath, "kubeconfig", "c", "", KubeConfigFlagHelpStr)
+	cmd.PersistentFlags().StringVar(&args.Context, "context", "", ContextFlagHelpStr)
+	cmd.PersistentFlags().DurationVar(&args.ReadinessTimeout, "readiness-timeout", 300*time.Second,
+		"Maximum time to wait for Istio resources in each component to be ready.")
+	cmd.PersistentFlags().BoolVarP(&args.SkipConfirmation, "skip-confirmation", "y", false, skipConfirmationFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.Force, "force", false, ForceFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.Verify, "verify", false, VerifyCRInstallHelpStr)
+	cmd.PersistentFlags().StringArrayVarP(&args.Set, "set", "s", nil, setFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "charts", "", "", ChartsDeprecatedStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.Revision, "revision", "r", "", revisionFlagHelpStr)
+}
 
+// InstallCmdWithArgs generates an Istio install manifest and applies it to a cluster
+func InstallCmdWithArgs(rootArgs *RootArgs, iArgs *InstallArgs, logOpts *log.Options) *cobra.Command {
 	ic := &cobra.Command{
 		Use:     "install",
 		Short:   "Applies an Istio manifest, installing or reconfiguring Istio on a cluster.",
@@ -116,13 +129,15 @@ func InstallCmd(logOpts *log.Options) *cobra.Command {
 `,
 		Args: cobra.ExactArgs(0),
 		PreRunE: func(cmd *cobra.Command, args []string) error {
-			if !labels.IsDNS1123Label(iArgs.revision) && cmd.PersistentFlags().Changed("revision") {
-				return fmt.Errorf("invalid revision specified: %v", iArgs.revision)
+			if !labels.IsDNS1123Label(iArgs.Revision) && cmd.PersistentFlags().Changed("revision") {
+				return fmt.Errorf("invalid revision specified: %v", iArgs.Revision)
 			}
 			return nil
 		},
 		RunE: func(cmd *cobra.Command, args []string) error {
-			return runApplyCmd(cmd, rootArgs, iArgs, logOpts)
+			l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
+			p := NewPrinterForWriter(cmd.OutOrStderr())
+			return Install(rootArgs, iArgs, logOpts, cmd.OutOrStdout(), l, p)
 		},
 	}
 
@@ -131,10 +146,13 @@ func InstallCmd(logOpts *log.Options) *cobra.Command {
 	return ic
 }
 
-func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, logOpts *log.Options) error {
-	l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
+// InstallCmd generates an Istio install manifest and applies it to a cluster
+func InstallCmd(logOpts *log.Options) *cobra.Command {
+	return InstallCmdWithArgs(&RootArgs{}, &InstallArgs{}, logOpts)
+}
 
-	kubeClient, client, err := KubernetesClients(iArgs.kubeConfigPath, iArgs.context, l)
+func Install(rootArgs *RootArgs, iArgs *InstallArgs, logOpts *log.Options, stdOut io.Writer, l clog.Logger, p Printer) error {
+	kubeClient, client, err := KubernetesClients(iArgs.KubeConfigPath, iArgs.Context, l)
 	if err != nil {
 		return err
 	}
@@ -143,9 +161,9 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 	if err != nil {
 		return fmt.Errorf("fetch Istio version: %v", err)
 	}
-	setFlags := applyFlagAliases(iArgs.set, iArgs.manifestsPath, iArgs.revision)
+	setFlags := applyFlagAliases(iArgs.Set, iArgs.ManifestsPath, iArgs.Revision)
 
-	_, iop, err := manifest.GenerateConfig(iArgs.inFilenames, setFlags, iArgs.force, kubeClient, l)
+	_, iop, err := manifest.GenerateConfig(iArgs.InFilenames, setFlags, iArgs.Force, kubeClient, l)
 	if err != nil {
 		return fmt.Errorf("generate config: %v", err)
 	}
@@ -157,16 +175,16 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 
 	// Ignore the err because we don't want to show
 	// "no running Istio pods in istio-system" for the first time
-	_ = DetectIstioVersionDiff(cmd, tag, ns, kubeClient, setFlags)
+	_ = detectIstioVersionDiff(p, tag, ns, kubeClient, setFlags)
 
 	// Warn users if they use `istioctl install` without any config args.
-	if !rootArgs.dryRun && !iArgs.skipConfirmation {
+	if !rootArgs.DryRun && !iArgs.SkipConfirmation {
 		prompt := fmt.Sprintf("This will install the Istio %s %s profile with %q components into the cluster. Proceed? (y/N)", tag, profile, enabledComponents)
 		if profile == "empty" {
 			prompt = fmt.Sprintf("This will install the Istio %s %s profile into the cluster. Proceed? (y/N)", tag, profile)
 		}
-		if !confirm(prompt, cmd.OutOrStdout()) {
-			cmd.Println("Cancelled.")
+		if !confirm(prompt, stdOut) {
+			p.Println("Cancelled.")
 			os.Exit(1)
 		}
 	}
@@ -181,13 +199,13 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 	if rev == "" && pilotEnabled {
 		_ = revtag.DeleteTagWebhooks(context.Background(), kubeClient, revtag.DefaultRevisionName)
 	}
-	iop, err = InstallManifests(iop, iArgs.force, rootArgs.dryRun, kubeClient, client, iArgs.readinessTimeout, l)
+	iop, err = InstallManifests(iop, iArgs.Force, rootArgs.DryRun, kubeClient, client, iArgs.ReadinessTimeout, l)
 	if err != nil {
 		return fmt.Errorf("failed to install manifests: %v", err)
 	}
 
 	if !exists || rev == "" {
-		cmd.Println("Making this installation the default for injection and validation.")
+		p.Println("Making this installation the default for injection and validation.")
 		if rev == "" {
 			rev = revtag.DefaultRevisionName
 		}
@@ -209,14 +227,14 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 		}
 	}
 
-	if iArgs.verify {
-		if rootArgs.dryRun {
+	if iArgs.Verify {
+		if rootArgs.DryRun {
 			l.LogAndPrint("Control plane health check is not applicable in dry-run mode")
 			return nil
 		}
 		l.LogAndPrint("\n\nVerifying installation:")
-		installationVerifier, err := verifier.NewStatusVerifier(iop.Namespace, iArgs.manifestsPath, iArgs.kubeConfigPath,
-			iArgs.context, iArgs.inFilenames, clioptions.ControlPlaneOptions{Revision: iop.Spec.Revision},
+		installationVerifier, err := verifier.NewStatusVerifier(iop.Namespace, iArgs.ManifestsPath, iArgs.KubeConfigPath,
+			iArgs.Context, iArgs.InFilenames, clioptions.ControlPlaneOptions{Revision: iop.Spec.Revision},
 			verifier.WithLogger(l),
 			verifier.WithIOP(iop),
 		)
@@ -234,7 +252,7 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 // InstallManifests generates manifests from the given istiooperator instance and applies them to the
 // cluster. See GenManifests for more description of the manifest generation process.
 //  force   validation warnings are written to logger but command is not aborted
-//  dryRun  all operations are done but nothing is written
+//  DryRun  all operations are done but nothing is written
 // Returns final IstioOperator after installation if successful.
 func InstallManifests(iop *v1alpha12.IstioOperator, force bool, dryRun bool, kubeClient kube.Client, client client.Client,
 	waitTimeout time.Duration, l clog.Logger) (*v1alpha12.IstioOperator, error) {
@@ -283,9 +301,9 @@ func savedIOPName(iop *v1alpha12.IstioOperator) string {
 	return ret
 }
 
-// DetectIstioVersionDiff will show warning if istioctl version and control plane version are different
+// detectIstioVersionDiff will show warning if istioctl version and control plane version are different
 // nolint: interfacer
-func DetectIstioVersionDiff(cmd *cobra.Command, tag string, ns string, kubeClient kube.ExtendedClient, setFlags []string) error {
+func detectIstioVersionDiff(p Printer, tag string, ns string, kubeClient kube.ExtendedClient, setFlags []string) error {
 	warnMarker := color.New(color.FgYellow).Add(color.Italic).Sprint("WARNING:")
 	icps, err := kubeClient.GetIstioVersions(context.TODO(), ns)
 	if err != nil {
@@ -319,17 +337,17 @@ func DetectIstioVersionDiff(cmd *cobra.Command, tag string, ns string, kubeClien
 			} else {
 				msg = "An older"
 			}
-			cmd.Printf("%s Istio control planes installed: %s.\n"+
+			p.Printf("%s Istio control planes installed: %s.\n"+
 				"%s "+msg+" installed version of Istio has been detected. Running this command will overwrite it.\n", warnMarker, strings.Join(icpTags, ", "), warnMarker)
 		}
 		// when the revision is passed
 		if icpTag != "" && tag != icpTag && revision != "" {
 			if icpTag < tag {
-				cmd.Printf("%s Istio is being upgraded from %s -> %s.\n"+
+				p.Printf("%s Istio is being upgraded from %s -> %s.\n"+
 					"%s Before upgrading, you may wish to use 'istioctl analyze' to check for "+
 					"IST0002 and IST0135 deprecation warnings.\n", warnMarker, icpTag, tag, warnMarker)
 			} else {
-				cmd.Printf("%s Istio is being downgraded from %s -> %s.\n", warnMarker, icpTag, tag)
+				p.Printf("%s Istio is being downgraded from %s -> %s.\n", warnMarker, icpTag, tag)
 			}
 		}
 	}
diff --git a/operator/cmd/mesh/manifest-diff.go b/operator/cmd/mesh/manifest-diff.go
index b4d1912af6..8323e4215d 100644
--- a/operator/cmd/mesh/manifest-diff.go
+++ b/operator/cmd/mesh/manifest-diff.go
@@ -66,7 +66,7 @@ func addManifestDiffFlags(cmd *cobra.Command, diffArgs *manifestDiffArgs) {
 			"e.g. Service:*:istiod->Service:*:istio-control - rename istiod service into istio-control")
 }
 
-func manifestDiffCmd(rootArgs *rootArgs, diffArgs *manifestDiffArgs) *cobra.Command {
+func manifestDiffCmd(rootArgs *RootArgs, diffArgs *manifestDiffArgs) *cobra.Command {
 	cmd := &cobra.Command{
 		Use:   "diff <file|dir> <file|dir>",
 		Short: "Compare manifests and generate diff",
@@ -110,7 +110,7 @@ func manifestDiffCmd(rootArgs *rootArgs, diffArgs *manifestDiffArgs) *cobra.Comm
 }
 
 // compareManifestsFromFiles compares two manifest files
-func compareManifestsFromFiles(rootArgs *rootArgs, args []string, verbose bool,
+func compareManifestsFromFiles(rootArgs *RootArgs, args []string, verbose bool,
 	renameResources, selectResources, ignoreResources string) (bool, error) {
 	initLogsOrExit(rootArgs)
 
@@ -142,7 +142,7 @@ func yamlFileFilter(path string) bool {
 }
 
 // compareManifestsFromDirs compares manifests from two directories
-func compareManifestsFromDirs(rootArgs *rootArgs, verbose bool, dirName1, dirName2,
+func compareManifestsFromDirs(rootArgs *RootArgs, verbose bool, dirName1, dirName2,
 	renameResources, selectResources, ignoreResources string) (bool, error) {
 	initLogsOrExit(rootArgs)
 
diff --git a/operator/cmd/mesh/manifest-generate.go b/operator/cmd/mesh/manifest-generate.go
index 87d018f34d..aab3875080 100644
--- a/operator/cmd/mesh/manifest-generate.go
+++ b/operator/cmd/mesh/manifest-generate.go
@@ -31,36 +31,48 @@
 	"istio.io/pkg/log"
 )
 
-type manifestGenerateArgs struct {
-	// inFilenames is an array of paths to the input IstioOperator CR files.
-	inFilename []string
-	// outFilename is the path to the generated output directory.
-	outFilename string
-	// set is a string with element format "path=value" where path is an IstioOperator path and the value is a
+type ManifestGenerateArgs struct {
+	// InFilenames is an array of paths to the input IstioOperator CR files.
+	InFilenames []string
+	// OutFilename is the path to the generated output directory.
+	OutFilename string
+	// Set is a string with element format "path=value" where path is an IstioOperator path and the value is a
 	// value to set the node at that path to.
-	set []string
-	// force proceeds even if there are validation errors
-	force bool
-	// manifestsPath is a path to a charts and profiles directory in the local filesystem, or URL with a release tgz.
-	manifestsPath string
-	// revision is the Istio control plane revision the command targets.
-	revision string
-	// components is a list of strings specifying which component's manifests to be generated.
-	components []string
+	Set []string
+	// Force proceeds even if there are validation errors
+	Force bool
+	// ManifestsPath is a path to a charts and profiles directory in the local filesystem, or URL with a release tgz.
+	ManifestsPath string
+	// Revision is the Istio control plane revision the command targets.
+	Revision string
+	// Components is a list of strings specifying which component's manifests to be generated.
+	Components []string
 }
 
-func addManifestGenerateFlags(cmd *cobra.Command, args *manifestGenerateArgs) {
-	cmd.PersistentFlags().StringSliceVarP(&args.inFilename, "filename", "f", nil, filenameFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.outFilename, "output", "o", "", "Manifest output directory path.")
-	cmd.PersistentFlags().StringArrayVarP(&args.set, "set", "s", nil, setFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.force, "force", false, ForceFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "charts", "", "", ChartsDeprecatedStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.revision, "revision", "r", "", revisionFlagHelpStr)
-	cmd.PersistentFlags().StringSliceVar(&args.components, "component", nil, ComponentFlagHelpStr)
+func (a *ManifestGenerateArgs) String() string {
+	var b strings.Builder
+	b.WriteString("InFilenames:   " + fmt.Sprint(a.InFilenames) + "\n")
+	b.WriteString("OutFilename:   " + a.OutFilename + "\n")
+	b.WriteString("Set:           " + fmt.Sprint(a.Set) + "\n")
+	b.WriteString("Force:         " + fmt.Sprint(a.Force) + "\n")
+	b.WriteString("ManifestsPath: " + a.ManifestsPath + "\n")
+	b.WriteString("Revision:      " + a.Revision + "\n")
+	b.WriteString("Components:    " + fmt.Sprint(a.Components) + "\n")
+	return b.String()
 }
 
-func manifestGenerateCmd(rootArgs *rootArgs, mgArgs *manifestGenerateArgs, logOpts *log.Options) *cobra.Command {
+func addManifestGenerateFlags(cmd *cobra.Command, args *ManifestGenerateArgs) {
+	cmd.PersistentFlags().StringSliceVarP(&args.InFilenames, "filename", "f", nil, filenameFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.OutFilename, "output", "o", "", "Manifest output directory path.")
+	cmd.PersistentFlags().StringArrayVarP(&args.Set, "set", "s", nil, setFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.Force, "force", false, ForceFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "charts", "", "", ChartsDeprecatedStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.Revision, "revision", "r", "", revisionFlagHelpStr)
+	cmd.PersistentFlags().StringSliceVar(&args.Components, "component", nil, ComponentFlagHelpStr)
+}
+
+func ManifestGenerateCmd(rootArgs *RootArgs, mgArgs *ManifestGenerateArgs, logOpts *log.Options) *cobra.Command {
 	return &cobra.Command{
 		Use:   "generate",
 		Short: "Generates an Istio install manifest",
@@ -89,24 +101,24 @@ func manifestGenerateCmd(rootArgs *rootArgs, mgArgs *manifestGenerateArgs, logOp
 		},
 		RunE: func(cmd *cobra.Command, args []string) error {
 			l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
-			return manifestGenerate(rootArgs, mgArgs, logOpts, l)
+			return ManifestGenerate(rootArgs, mgArgs, logOpts, l)
 		},
 	}
 }
 
-func manifestGenerate(args *rootArgs, mgArgs *manifestGenerateArgs, logopts *log.Options, l clog.Logger) error {
+func ManifestGenerate(args *RootArgs, mgArgs *ManifestGenerateArgs, logopts *log.Options, l clog.Logger) error {
 	if err := configLogs(logopts); err != nil {
 		return fmt.Errorf("could not configure logs: %s", err)
 	}
 
-	manifests, _, err := manifest.GenManifests(mgArgs.inFilename, applyFlagAliases(mgArgs.set, mgArgs.manifestsPath, mgArgs.revision), mgArgs.force, nil, l)
+	manifests, _, err := manifest.GenManifests(mgArgs.InFilenames, applyFlagAliases(mgArgs.Set, mgArgs.ManifestsPath, mgArgs.Revision), mgArgs.Force, nil, l)
 	if err != nil {
 		return err
 	}
 
-	if len(mgArgs.components) != 0 {
+	if len(mgArgs.Components) != 0 {
 		filteredManifests := name.ManifestMap{}
-		for _, cArg := range mgArgs.components {
+		for _, cArg := range mgArgs.Components {
 			componentName := name.ComponentName(cArg)
 			if cManifests, ok := manifests[componentName]; ok {
 				filteredManifests[componentName] = cManifests
@@ -117,7 +129,7 @@ func manifestGenerate(args *rootArgs, mgArgs *manifestGenerateArgs, logopts *log
 		manifests = filteredManifests
 	}
 
-	if mgArgs.outFilename == "" {
+	if mgArgs.OutFilename == "" {
 		ordered, err := orderedManifests(manifests)
 		if err != nil {
 			return fmt.Errorf("failed to order manifests: %v", err)
@@ -126,10 +138,10 @@ func manifestGenerate(args *rootArgs, mgArgs *manifestGenerateArgs, logopts *log
 			l.Print(m + object.YAMLSeparator)
 		}
 	} else {
-		if err := os.MkdirAll(mgArgs.outFilename, os.ModePerm); err != nil {
+		if err := os.MkdirAll(mgArgs.OutFilename, os.ModePerm); err != nil {
 			return err
 		}
-		if err := RenderToDir(manifests, mgArgs.outFilename, args.dryRun, l); err != nil {
+		if err := RenderToDir(manifests, mgArgs.OutFilename, args.DryRun, l); err != nil {
 			return err
 		}
 	}
diff --git a/operator/cmd/mesh/manifest.go b/operator/cmd/mesh/manifest.go
index d39b84f4d8..b632a7c5b4 100644
--- a/operator/cmd/mesh/manifest.go
+++ b/operator/cmd/mesh/manifest.go
@@ -28,12 +28,12 @@ func ManifestCmd(logOpts *log.Options) *cobra.Command {
 		Long:  "The manifest command generates and diffs Istio manifests.",
 	}
 
-	mgcArgs := &manifestGenerateArgs{}
+	mgcArgs := &ManifestGenerateArgs{}
 	mdcArgs := &manifestDiffArgs{}
 
-	args := &rootArgs{}
+	args := &RootArgs{}
 
-	mgc := manifestGenerateCmd(args, mgcArgs, logOpts)
+	mgc := ManifestGenerateCmd(args, mgcArgs, logOpts)
 	mdc := manifestDiffCmd(args, mdcArgs)
 	ic := InstallCmd(logOpts)
 
diff --git a/operator/cmd/mesh/operator-common.go b/operator/cmd/mesh/operator-common.go
index 7d9e54372d..b5c1706020 100644
--- a/operator/cmd/mesh/operator-common.go
+++ b/operator/cmd/mesh/operator-common.go
@@ -66,7 +66,7 @@ func isControllerInstalled(cs kubernetes.Interface, operatorNamespace string, re
 }
 
 // renderOperatorManifest renders a manifest to install the operator with the given input arguments.
-func renderOperatorManifest(_ *rootArgs, ocArgs *operatorCommonArgs) (string, string, error) {
+func renderOperatorManifest(_ *RootArgs, ocArgs *operatorCommonArgs) (string, string, error) {
 	// If manifestsPath is a URL, fetch and extract it and continue with the local filesystem path instead.
 	installPackagePath, _, err := manifest.RewriteURLToLocalInstallPath(ocArgs.manifestsPath, "" /*profileOrPath*/, false /*skipValidation */)
 	if err != nil {
diff --git a/operator/cmd/mesh/operator-dump.go b/operator/cmd/mesh/operator-dump.go
index 3a3f00a788..33844d27d1 100644
--- a/operator/cmd/mesh/operator-dump.go
+++ b/operator/cmd/mesh/operator-dump.go
@@ -44,7 +44,7 @@ func addOperatorDumpFlags(cmd *cobra.Command, args *operatorDumpArgs) {
 		"Output format: one of json|yaml")
 }
 
-func operatorDumpCmd(rootArgs *rootArgs, odArgs *operatorDumpArgs) *cobra.Command {
+func operatorDumpCmd(rootArgs *RootArgs, odArgs *operatorDumpArgs) *cobra.Command {
 	return &cobra.Command{
 		Use:   "dump",
 		Short: "Dumps the Istio operator controller manifest.",
@@ -58,7 +58,7 @@ func operatorDumpCmd(rootArgs *rootArgs, odArgs *operatorDumpArgs) *cobra.Comman
 }
 
 // operatorDump dumps the manifest used to install the operator.
-func operatorDump(args *rootArgs, odArgs *operatorDumpArgs, l clog.Logger) {
+func operatorDump(args *RootArgs, odArgs *operatorDumpArgs, l clog.Logger) {
 	if err := validateOperatorOutputFormatFlag(odArgs.common.outputFormat); err != nil {
 		l.LogAndFatal(fmt.Errorf("unknown output format: %v", odArgs.common.outputFormat))
 	}
diff --git a/operator/cmd/mesh/operator-init.go b/operator/cmd/mesh/operator-init.go
index abcdb3cc6f..37232b598d 100644
--- a/operator/cmd/mesh/operator-init.go
+++ b/operator/cmd/mesh/operator-init.go
@@ -62,7 +62,7 @@ func addOperatorInitFlags(cmd *cobra.Command, args *operatorInitArgs) {
 	cmd.PersistentFlags().StringVarP(&args.common.revision, "revision", "r", "", OperatorRevFlagHelpStr)
 }
 
-func operatorInitCmd(rootArgs *rootArgs, oiArgs *operatorInitArgs) *cobra.Command {
+func operatorInitCmd(rootArgs *RootArgs, oiArgs *operatorInitArgs) *cobra.Command {
 	return &cobra.Command{
 		Use:   "init",
 		Short: "Installs the Istio operator controller in the cluster.",
@@ -82,7 +82,7 @@ func operatorInitCmd(rootArgs *rootArgs, oiArgs *operatorInitArgs) *cobra.Comman
 }
 
 // operatorInit installs the Istio operator controller into the cluster.
-func operatorInit(args *rootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
+func operatorInit(args *RootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
 	initLogsOrExit(args)
 
 	kubeClient, client, err := kubeClients(oiArgs.kubeConfigPath, oiArgs.context, l)
@@ -111,7 +111,7 @@ func operatorInit(args *rootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
 	installerScope.Debugf("Using the following manifest to install operator:\n%s\n", mstr)
 
 	opts := &applyOptions{
-		DryRun:     args.dryRun,
+		DryRun:     args.DryRun,
 		Kubeconfig: oiArgs.kubeConfigPath,
 		Context:    oiArgs.context,
 	}
diff --git a/operator/cmd/mesh/operator-remove.go b/operator/cmd/mesh/operator-remove.go
index a01340e926..a0fbb367c6 100644
--- a/operator/cmd/mesh/operator-remove.go
+++ b/operator/cmd/mesh/operator-remove.go
@@ -47,7 +47,7 @@ func addOperatorRemoveFlags(cmd *cobra.Command, oiArgs *operatorRemoveArgs) {
 	cmd.PersistentFlags().StringVarP(&oiArgs.revision, "revision", "r", "", OperatorRevFlagHelpStr)
 }
 
-func operatorRemoveCmd(rootArgs *rootArgs, orArgs *operatorRemoveArgs) *cobra.Command {
+func operatorRemoveCmd(rootArgs *RootArgs, orArgs *operatorRemoveArgs) *cobra.Command {
 	return &cobra.Command{
 		Use:   "remove",
 		Short: "Removes the Istio operator controller from the cluster.",
@@ -61,7 +61,7 @@ func operatorRemoveCmd(rootArgs *rootArgs, orArgs *operatorRemoveArgs) *cobra.Co
 }
 
 // operatorRemove removes the Istio operator controller from the cluster.
-func operatorRemove(args *rootArgs, orArgs *operatorRemoveArgs, l clog.Logger) {
+func operatorRemove(args *RootArgs, orArgs *operatorRemoveArgs, l clog.Logger) {
 	initLogsOrExit(args)
 
 	kubeClient, client, err := KubernetesClients(orArgs.kubeConfigPath, orArgs.context, l)
@@ -90,7 +90,7 @@ func operatorRemove(args *rootArgs, orArgs *operatorRemoveArgs, l clog.Logger) {
 			l.LogAndFatal(err)
 		}
 	}
-	reconciler, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, &helmreconciler.Options{DryRun: args.dryRun, Log: l})
+	reconciler, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, &helmreconciler.Options{DryRun: args.DryRun, Log: l})
 	if err != nil {
 		l.LogAndFatal(err)
 	}
diff --git a/operator/cmd/mesh/operator.go b/operator/cmd/mesh/operator.go
index d08f5bc260..330862b78f 100644
--- a/operator/cmd/mesh/operator.go
+++ b/operator/cmd/mesh/operator.go
@@ -29,7 +29,7 @@ func OperatorCmd() *cobra.Command {
 	odArgs := &operatorDumpArgs{}
 	oiArgs := &operatorInitArgs{}
 	orArgs := &operatorRemoveArgs{}
-	args := &rootArgs{}
+	args := &RootArgs{}
 
 	odc := operatorDumpCmd(args, odArgs)
 	oic := operatorInitCmd(args, oiArgs)
diff --git a/operator/cmd/mesh/operator_test.go b/operator/cmd/mesh/operator_test.go
index 79da63f4e2..206f7edf00 100644
--- a/operator/cmd/mesh/operator_test.go
+++ b/operator/cmd/mesh/operator_test.go
@@ -135,7 +135,7 @@ func TestOperatorDumpJSONFormat(t *testing.T) {
 // TODO: rewrite this with running the actual top level command.
 func TestOperatorInit(t *testing.T) {
 	goldenFilepath := filepath.Join(operatorRootDir, "cmd/mesh/testdata/operator/output/operator-init.yaml")
-	rootArgs := &rootArgs{}
+	rootArgs := &RootArgs{}
 	oiArgs := &operatorInitArgs{
 		common: operatorCommonArgs{
 			hub:               "foo.io/istio",
diff --git a/operator/cmd/mesh/profile-diff.go b/operator/cmd/mesh/profile-diff.go
index 9b1d42da32..8a85a20104 100644
--- a/operator/cmd/mesh/profile-diff.go
+++ b/operator/cmd/mesh/profile-diff.go
@@ -37,7 +37,7 @@ func addProfileDiffFlags(cmd *cobra.Command, args *profileDiffArgs) {
 	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
 }
 
-func profileDiffCmd(rootArgs *rootArgs, pfArgs *profileDiffArgs, logOpts *log.Options) *cobra.Command {
+func profileDiffCmd(rootArgs *RootArgs, pfArgs *profileDiffArgs, logOpts *log.Options) *cobra.Command {
 	return &cobra.Command{
 		Use:   "diff <profile|file1.yaml> <profile|file2.yaml>",
 		Short: "Diffs two Istio configuration profiles",
@@ -67,7 +67,7 @@ func profileDiffCmd(rootArgs *rootArgs, pfArgs *profileDiffArgs, logOpts *log.Op
 }
 
 // profileDiff compare two profile files.
-func profileDiff(cmd *cobra.Command, rootArgs *rootArgs, pfArgs *profileDiffArgs, args []string, logOpts *log.Options) (bool, error) {
+func profileDiff(cmd *cobra.Command, rootArgs *RootArgs, pfArgs *profileDiffArgs, args []string, logOpts *log.Options) (bool, error) {
 	initLogsOrExit(rootArgs)
 
 	l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.OutOrStderr(), nil)
diff --git a/operator/cmd/mesh/profile-dump.go b/operator/cmd/mesh/profile-dump.go
index fd549a55db..e6c5c747a8 100644
--- a/operator/cmd/mesh/profile-dump.go
+++ b/operator/cmd/mesh/profile-dump.go
@@ -64,7 +64,7 @@ func addProfileDumpFlags(cmd *cobra.Command, args *profileDumpArgs) {
 	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
 }
 
-func profileDumpCmd(rootArgs *rootArgs, pdArgs *profileDumpArgs, logOpts *log.Options) *cobra.Command {
+func profileDumpCmd(rootArgs *RootArgs, pdArgs *profileDumpArgs, logOpts *log.Options) *cobra.Command {
 	return &cobra.Command{
 		Use:   "dump [<profile>]",
 		Short: "Dumps an Istio configuration profile",
@@ -119,7 +119,7 @@ func yamlToPrettyJSON(yml string) (string, error) {
 	return string(prettyJSON), nil
 }
 
-func profileDump(args []string, rootArgs *rootArgs, pdArgs *profileDumpArgs, l clog.Logger, logOpts *log.Options) error {
+func profileDump(args []string, rootArgs *RootArgs, pdArgs *profileDumpArgs, l clog.Logger, logOpts *log.Options) error {
 	initLogsOrExit(rootArgs)
 
 	if len(args) == 1 && pdArgs.inFilenames != nil {
diff --git a/operator/cmd/mesh/profile-list.go b/operator/cmd/mesh/profile-list.go
index 56f272a535..05e26b8ee6 100644
--- a/operator/cmd/mesh/profile-list.go
+++ b/operator/cmd/mesh/profile-list.go
@@ -32,7 +32,7 @@ func addProfileListFlags(cmd *cobra.Command, args *profileListArgs) {
 	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
 }
 
-func profileListCmd(rootArgs *rootArgs, plArgs *profileListArgs) *cobra.Command {
+func profileListCmd(rootArgs *RootArgs, plArgs *profileListArgs) *cobra.Command {
 	return &cobra.Command{
 		Use:   "list",
 		Short: "Lists available Istio configuration profiles",
@@ -45,7 +45,7 @@ func profileListCmd(rootArgs *rootArgs, plArgs *profileListArgs) *cobra.Command
 }
 
 // profileList list all the builtin profiles.
-func profileList(cmd *cobra.Command, args *rootArgs, plArgs *profileListArgs) error {
+func profileList(cmd *cobra.Command, args *RootArgs, plArgs *profileListArgs) error {
 	initLogsOrExit(args)
 	profiles, err := helm.ListProfiles(plArgs.manifestsPath)
 	if err != nil {
diff --git a/operator/cmd/mesh/profile.go b/operator/cmd/mesh/profile.go
index 33d642a4eb..460c61ae04 100644
--- a/operator/cmd/mesh/profile.go
+++ b/operator/cmd/mesh/profile.go
@@ -33,7 +33,7 @@ func ProfileCmd(logOpts *log.Options) *cobra.Command {
 	pdArgs := &profileDumpArgs{}
 	plArgs := &profileListArgs{}
 	pdfArgs := &profileDiffArgs{}
-	args := &rootArgs{}
+	args := &RootArgs{}
 
 	plc := profileListCmd(args, plArgs)
 	pdc := profileDumpCmd(args, pdArgs, logOpts)
diff --git a/operator/cmd/mesh/root.go b/operator/cmd/mesh/root.go
index 29edac48a1..307fefb474 100644
--- a/operator/cmd/mesh/root.go
+++ b/operator/cmd/mesh/root.go
@@ -59,13 +59,13 @@
 	VerifyCRInstallHelpStr   = "Verify the Istio control plane after installation/in-place upgrade"
 )
 
-type rootArgs struct {
-	// Dry run performs all steps except actually applying the manifests or creating output dirs/files.
-	dryRun bool
+type RootArgs struct {
+	// DryRun performs all steps except actually applying the manifests or creating output dirs/files.
+	DryRun bool
 }
 
-func addFlags(cmd *cobra.Command, rootArgs *rootArgs) {
-	cmd.PersistentFlags().BoolVarP(&rootArgs.dryRun, "dry-run", "",
+func addFlags(cmd *cobra.Command, rootArgs *RootArgs) {
+	cmd.PersistentFlags().BoolVarP(&rootArgs.DryRun, "dry-run", "",
 		false, "Console/log output only, make no changes.")
 }
 
diff --git a/operator/cmd/mesh/shared.go b/operator/cmd/mesh/shared.go
index 1f8c941fc4..e74c9b562e 100644
--- a/operator/cmd/mesh/shared.go
+++ b/operator/cmd/mesh/shared.go
@@ -48,7 +48,28 @@
 	testRestConfig  *rest.Config
 )
 
-func initLogsOrExit(_ *rootArgs) {
+type Printer interface {
+	Printf(format string, a ...interface{})
+	Println(string)
+}
+
+func NewPrinterForWriter(w io.Writer) Printer {
+	return &writerPrinter{writer: w}
+}
+
+type writerPrinter struct {
+	writer io.Writer
+}
+
+func (w *writerPrinter) Printf(format string, a ...interface{}) {
+	_, _ = fmt.Fprintf(w.writer, format, a...)
+}
+
+func (w *writerPrinter) Println(str string) {
+	_, _ = fmt.Fprintln(w.writer, str)
+}
+
+func initLogsOrExit(_ *RootArgs) {
 	if err := configLogs(log.DefaultOptions()); err != nil {
 		_, _ = fmt.Fprintf(os.Stderr, "Could not configure logs: %s", err)
 		os.Exit(1)
@@ -80,7 +101,7 @@ func kubeBuilderInstalled() bool {
 
 // confirm waits for a user to confirm with the supplied message.
 func confirm(msg string, writer io.Writer) bool {
-	fmt.Fprintf(writer, "%s ", msg)
+	_, _ = fmt.Fprintf(writer, "%s ", msg)
 
 	var response string
 	_, err := fmt.Scanln(&response)
diff --git a/operator/cmd/mesh/uninstall.go b/operator/cmd/mesh/uninstall.go
index 732a6d937e..a1cf388ba8 100644
--- a/operator/cmd/mesh/uninstall.go
+++ b/operator/cmd/mesh/uninstall.go
@@ -89,7 +89,7 @@ func addUninstallFlags(cmd *cobra.Command, args *uninstallArgs) {
 
 // UninstallCmd command uninstalls Istio from a cluster
 func UninstallCmd(logOpts *log.Options) *cobra.Command {
-	rootArgs := &rootArgs{}
+	rootArgs := &RootArgs{}
 	uiArgs := &uninstallArgs{}
 	uicmd := &cobra.Command{
 		Use:   "uninstall",
@@ -122,7 +122,7 @@ func UninstallCmd(logOpts *log.Options) *cobra.Command {
 }
 
 // uninstall uninstalls control plane by either pruning by target revision or deleting specified manifests.
-func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, logOpts *log.Options) error {
+func uninstall(cmd *cobra.Command, rootArgs *RootArgs, uiArgs *uninstallArgs, logOpts *log.Options) error {
 	l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
 	if err := configLogs(logOpts); err != nil {
 		return fmt.Errorf("could not configure logs: %s", err)
@@ -132,7 +132,7 @@ func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, lo
 		l.LogAndFatal(err)
 	}
 	cache.FlushObjectCaches()
-	opts := &helmreconciler.Options{DryRun: rootArgs.dryRun, Log: l, ProgressLog: progress.NewLog()}
+	opts := &helmreconciler.Options{DryRun: rootArgs.DryRun, Log: l, ProgressLog: progress.NewLog()}
 	var h *helmreconciler.HelmReconciler
 
 	// If the user is performing a purge install but also specified a revision or filename, we should warn
diff --git a/operator/cmd/mesh/upgrade.go b/operator/cmd/mesh/upgrade.go
index 7cf843ae5a..6067e995fe 100644
--- a/operator/cmd/mesh/upgrade.go
+++ b/operator/cmd/mesh/upgrade.go
@@ -19,32 +19,33 @@
 
 	"github.com/spf13/cobra"
 
+	"istio.io/istio/operator/pkg/util/clog"
 	"istio.io/pkg/log"
 )
 
 type upgradeArgs struct {
-	*installArgs
+	*InstallArgs
 }
 
 func addUpgradeFlags(cmd *cobra.Command, args *upgradeArgs) {
-	cmd.PersistentFlags().StringSliceVarP(&args.inFilenames, "filename", "f", nil, filenameFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.kubeConfigPath, "kubeconfig", "c", "", KubeConfigFlagHelpStr)
-	cmd.PersistentFlags().StringVar(&args.context, "context", "", ContextFlagHelpStr)
-	cmd.PersistentFlags().DurationVar(&args.readinessTimeout, "readiness-timeout", 300*time.Second,
+	cmd.PersistentFlags().StringSliceVarP(&args.InFilenames, "filename", "f", nil, filenameFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.KubeConfigPath, "kubeconfig", "c", "", KubeConfigFlagHelpStr)
+	cmd.PersistentFlags().StringVar(&args.Context, "context", "", ContextFlagHelpStr)
+	cmd.PersistentFlags().DurationVar(&args.ReadinessTimeout, "readiness-timeout", 300*time.Second,
 		"Maximum time to wait for Istio resources in each component to be ready.")
-	cmd.PersistentFlags().BoolVarP(&args.skipConfirmation, "skip-confirmation", "y", false, skipConfirmationFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.force, "force", false, ForceFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.verify, "verify", false, VerifyCRInstallHelpStr)
-	cmd.PersistentFlags().StringArrayVarP(&args.set, "set", "s", nil, setFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "charts", "", "", ChartsDeprecatedStr)
-	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
+	cmd.PersistentFlags().BoolVarP(&args.SkipConfirmation, "skip-confirmation", "y", false, skipConfirmationFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.Force, "force", false, ForceFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.Verify, "verify", false, VerifyCRInstallHelpStr)
+	cmd.PersistentFlags().StringArrayVarP(&args.Set, "set", "s", nil, setFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "charts", "", "", ChartsDeprecatedStr)
+	cmd.PersistentFlags().StringVarP(&args.ManifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
 }
 
 // UpgradeCmd upgrades Istio control plane in-place with eligibility checks.
 func UpgradeCmd(logOpts *log.Options) *cobra.Command {
-	rootArgs := &rootArgs{}
+	rootArgs := &RootArgs{}
 	upgradeArgs := &upgradeArgs{
-		installArgs: &installArgs{},
+		InstallArgs: &InstallArgs{},
 	}
 	cmd := &cobra.Command{
 		Use:   "upgrade",
@@ -52,7 +53,9 @@ func UpgradeCmd(logOpts *log.Options) *cobra.Command {
 		Long: "The upgrade command is an alias for the install command" +
 			" that performs additional upgrade-related checks.",
 		RunE: func(cmd *cobra.Command, args []string) (e error) {
-			return runApplyCmd(cmd, rootArgs, upgradeArgs.installArgs, logOpts)
+			l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
+			p := NewPrinterForWriter(cmd.OutOrStderr())
+			return Install(rootArgs, upgradeArgs.InstallArgs, logOpts, cmd.OutOrStdout(), l, p)
 		},
 	}
 	addFlags(cmd, rootArgs)
diff --git a/pkg/test/framework/components/istio/eastwest.go b/pkg/test/framework/components/istio/eastwest.go
index b3c3295e53..a68d956571 100644
--- a/pkg/test/framework/components/istio/eastwest.go
+++ b/pkg/test/framework/components/istio/eastwest.go
@@ -15,6 +15,7 @@
 package istio
 
 import (
+	"bytes"
 	"context"
 	"fmt"
 	"os"
@@ -25,9 +26,9 @@
 	corev1 "k8s.io/api/core/v1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
+	"istio.io/istio/operator/cmd/mesh"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/components/istioctl"
 	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
@@ -69,36 +70,40 @@ func (i *operatorComponent) deployEastWestGateway(cluster cluster.Cluster, revis
 		return err
 	}
 
-	// use operator yaml to generate k8s resources
-	istioCtl, err := istioctl.New(i.ctx, istioctl.Config{Cluster: cluster})
-	if err != nil {
-		return err
+	// Save the manifest generate output so we can later cleanup
+	manifestGenArgs := &mesh.ManifestGenerateArgs{
+		InFilenames: []string{iopFile},
+		Set: []string{
+			"hub=" + imgSettings.Hub,
+			"tag=" + imgSettings.Tag,
+			"values.global.imagePullPolicy=" + imgSettings.PullPolicy,
+			"values.gateways.istio-ingressgateway.autoscaleEnabled=false",
+		},
+		ManifestsPath: filepath.Join(env.IstioSrc, "manifests"),
+		Revision:      revision,
 	}
 
-	installSettings := []string{
-		"--istioNamespace", i.settings.SystemNamespace,
-		"--manifests", filepath.Join(env.IstioSrc, "manifests"),
-		"--set", "hub=" + imgSettings.Hub,
-		"--set", "tag=" + imgSettings.Tag,
-		"--set", "values.global.imagePullPolicy=" + imgSettings.PullPolicy,
-		"--set", "values.gateways.istio-ingressgateway.autoscaleEnabled=false",
-		"-f", iopFile,
-	}
-	if revision != "" {
-		installSettings = append(installSettings, "--revision", revision)
+	var stdOut, stdErr bytes.Buffer
+	if err := mesh.ManifestGenerate(&mesh.RootArgs{}, manifestGenArgs, cmdLogOptions(), cmdLogger(&stdOut, &stdErr)); err != nil {
+		return err
 	}
+	i.saveManifestForCleanup(cluster.Name(), stdOut.String())
 
-	// Save the manifest generate output so we can later cleanup
-	genCmd := []string{"manifest", "generate"}
-	genCmd = append(genCmd, installSettings...)
-	out, _, err := istioCtl.Invoke(genCmd)
+	kubeConfigFile, err := kubeConfigFileForCluster(cluster)
 	if err != nil {
 		return err
 	}
-	i.saveManifestForCleanup(cluster.Name(), out)
 
-	scopes.Framework.Infof("Deploying eastwestgateway in %s: %v", cluster.Name(), installSettings)
-	err = install(i, installSettings, istioCtl, cluster.Name())
+	installArgs := &mesh.InstallArgs{
+		InFilenames:    []string{iopFile},
+		KubeConfigPath: kubeConfigFile,
+		Set:            manifestGenArgs.Set,
+		ManifestsPath:  manifestGenArgs.ManifestsPath,
+		Revision:       manifestGenArgs.Revision,
+	}
+
+	scopes.Framework.Infof("Deploying eastwestgateway in %s: %v", cluster.Name(), installArgs)
+	err = install(i, installArgs, cluster.Name())
 	if err != nil {
 		scopes.Framework.Error(err)
 		return fmt.Errorf("failed installing eastwestgateway via IstioOperator: %v", err)
diff --git a/pkg/test/framework/components/istio/operator.go b/pkg/test/framework/components/istio/operator.go
index 1b960a37f5..847711745c 100644
--- a/pkg/test/framework/components/istio/operator.go
+++ b/pkg/test/framework/components/istio/operator.go
@@ -15,6 +15,7 @@
 package istio
 
 import (
+	"bytes"
 	"context"
 	"fmt"
 	"io"
@@ -37,7 +38,9 @@
 	"istio.io/api/label"
 	opAPI "istio.io/api/operator/v1alpha1"
 	"istio.io/istio/istioctl/cmd"
+	"istio.io/istio/operator/cmd/mesh"
 	pkgAPI "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
+	"istio.io/istio/operator/pkg/util/clog"
 	"istio.io/istio/pkg/test/cert/ca"
 	testenv "istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -53,6 +56,7 @@
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/pkg/test/util/yml"
 	"istio.io/istio/pkg/util/gogoprotomarshal"
+	"istio.io/pkg/log"
 )
 
 // TODO: dynamically generate meshID to support multi-tenancy tests
@@ -555,7 +559,7 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 			return err
 		}
 	}
-	installSettings, err := i.generateCommonInstallSettings(cfg, c, cfg.PrimaryClusterIOPFile, iopFile)
+	installArgs, err := i.generateCommonInstallArgs(cfg, c, cfg.PrimaryClusterIOPFile, iopFile)
 	if err != nil {
 		return err
 	}
@@ -563,7 +567,7 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 	if i.environment.IsMulticluster() {
 		if i.isExternalControlPlane() || cfg.IstiodlessRemotes {
 			// Enable namespace controller writing to remote clusters
-			installSettings = append(installSettings, "--set", "values.pilot.env.EXTERNAL_ISTIOD=true")
+			installArgs.Set = append(installArgs.Set, "values.pilot.env.EXTERNAL_ISTIOD=true")
 		}
 
 		// Set the clusterName for the local cluster.
@@ -572,18 +576,10 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 		if !c.IsConfig() {
 			clusterName = c.ConfigName()
 		}
-		installSettings = append(installSettings, "--set", "values.global.multiCluster.clusterName="+clusterName)
+		installArgs.Set = append(installArgs.Set, "values.global.multiCluster.clusterName="+clusterName)
 	}
 
-	// Create an istioctl to configure this cluster.
-	istioCtl, err := istioctl.New(i.ctx, istioctl.Config{
-		Cluster: c,
-	})
-	if err != nil {
-		return err
-	}
-
-	err = install(i, installSettings, istioCtl, c.Name())
+	err = install(i, installArgs, c.Name())
 	if err != nil {
 		return err
 	}
@@ -625,8 +621,8 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 
 		// configure istioctl to run with an external control plane topology.
 		if !c.IsConfig() {
-			os.Setenv("ISTIOCTL_XDS_ADDRESS", istiodAddress.String())
-			os.Setenv("ISTIOCTL_PREFER_EXPERIMENTAL", "true")
+			_ = os.Setenv("ISTIOCTL_XDS_ADDRESS", istiodAddress.String())
+			_ = os.Setenv("ISTIOCTL_PREFER_EXPERIMENTAL", "true")
 			if err := cmd.ConfigAndEnvProcessing(); err != nil {
 				return err
 			}
@@ -651,41 +647,34 @@ func installRemoteCluster(i *operatorComponent, cfg Config, c cluster.Cluster, r
 
 // Common install on a either a remote-config or pure remote cluster.
 func installRemoteCommon(i *operatorComponent, cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) error {
-	installSettings, err := i.generateCommonInstallSettings(cfg, c, defaultsIOPFile, iopFile)
+	installArgs, err := i.generateCommonInstallArgs(cfg, c, defaultsIOPFile, iopFile)
 	if err != nil {
 		return err
 	}
 	if i.environment.IsMulticluster() {
 		// Set the clusterName for the local cluster.
 		// This MUST match the clusterName in the remote secret for this cluster.
-		installSettings = append(installSettings, "--set", "values.global.multiCluster.clusterName="+c.Name())
-	}
-	// Create an istioctl to configure this cluster.
-	istioCtl, err := istioctl.New(i.ctx, istioctl.Config{
-		Cluster: c,
-	})
-	if err != nil {
-		return err
+		installArgs.Set = append(installArgs.Set, "values.global.multiCluster.clusterName="+c.Name())
 	}
 
 	// Configure the cluster and network arguments to pass through the injector webhook.
 	if i.isExternalControlPlane() {
-		installSettings = append(installSettings,
-			"--set", fmt.Sprintf("values.istiodRemote.injectionPath=/inject/net/%s/cluster/%s", c.NetworkName(), c.Name()))
+		installArgs.Set = append(installArgs.Set,
+			fmt.Sprintf("values.istiodRemote.injectionPath=/inject/net/%s/cluster/%s", c.NetworkName(), c.Name()))
 	} else {
 		remoteIstiodAddress, err := i.RemoteDiscoveryAddressFor(c)
 		if err != nil {
 			return err
 		}
-		installSettings = append(installSettings, "--set", "values.global.remotePilotAddress="+remoteIstiodAddress.IP.String())
+		installArgs.Set = append(installArgs.Set, "values.global.remotePilotAddress="+remoteIstiodAddress.IP.String())
 		if cfg.IstiodlessRemotes {
-			installSettings = append(installSettings,
-				"--set", fmt.Sprintf("values.istiodRemote.injectionURL=https://%s/inject/net/%s/cluster/%s",
+			installArgs.Set = append(installArgs.Set,
+				fmt.Sprintf("values.istiodRemote.injectionURL=https://%s/inject/net/%s/cluster/%s",
 					net.JoinHostPort(remoteIstiodAddress.IP.String(), "15017"), c.NetworkName(), c.Name()))
 		}
 	}
 
-	if err := install(i, installSettings, istioCtl, c.Name()); err != nil {
+	if err := install(i, installArgs, c.Name()); err != nil {
 		return err
 	}
 
@@ -697,93 +686,142 @@ func installRemoteClusterGateways(i *operatorComponent, c cluster.Cluster) error
 	if err != nil {
 		return err
 	}
-	installSettings := []string{
-		"-f", filepath.Join(testenv.IstioSrc, IntegrationTestRemoteGatewaysIOP),
-		"--istioNamespace", i.settings.SystemNamespace,
-		"--manifests", filepath.Join(testenv.IstioSrc, "manifests"),
-		"--set", "values.global.imagePullPolicy=" + s.PullPolicy,
-	}
 
-	// Create an istioctl to configure this cluster.
-	istioCtl, err := istioctl.New(i.ctx, istioctl.Config{
-		Cluster: c,
-	})
+	kubeConfigFile, err := kubeConfigFileForCluster(c)
 	if err != nil {
 		return err
 	}
 
-	scopes.Framework.Infof("Deploying ingress and egress gateways in %s: %v", c.Name(), installSettings)
-	if err = install(i, installSettings, istioCtl, c.Name()); err != nil {
+	installArgs := &mesh.InstallArgs{
+		KubeConfigPath: kubeConfigFile,
+		ManifestsPath:  filepath.Join(testenv.IstioSrc, "manifests"),
+		InFilenames: []string{
+			filepath.Join(testenv.IstioSrc, IntegrationTestRemoteGatewaysIOP),
+		},
+		Set: []string{
+			"values.global.imagePullPolicy=" + s.PullPolicy,
+		},
+	}
+
+	scopes.Framework.Infof("Deploying ingress and egress gateways in %s: %v", c.Name(), installArgs)
+	if err = install(i, installArgs, c.Name()); err != nil {
 		return err
 	}
 
 	return nil
 }
 
-func (i *operatorComponent) generateCommonInstallSettings(cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) ([]string, error) {
+func kubeConfigFileForCluster(c cluster.Cluster) (string, error) {
+	type Filenamer interface {
+		Filename() string
+	}
+	fn, ok := c.(Filenamer)
+	if !ok {
+		return "", fmt.Errorf("cluster does not support fetching kube config")
+	}
+	return fn.Filename(), nil
+}
+
+func (i *operatorComponent) generateCommonInstallArgs(cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) (*mesh.InstallArgs, error) {
 	s, err := image.SettingsFromCommandLine()
 	if err != nil {
 		return nil, err
 	}
+
+	kubeConfigFile, err := kubeConfigFileForCluster(c)
+	if err != nil {
+		return nil, err
+	}
+
 	if !path.IsAbs(defaultsIOPFile) {
 		defaultsIOPFile = filepath.Join(testenv.IstioSrc, defaultsIOPFile)
 	}
 
-	installSettings := []string{
-		"-f", defaultsIOPFile,
-		"-f", iopFile,
-		"--set", "values.global.imagePullPolicy=" + s.PullPolicy,
-		"--manifests", filepath.Join(testenv.IstioSrc, "manifests"),
+	installArgs := &mesh.InstallArgs{
+		KubeConfigPath: kubeConfigFile,
+		ManifestsPath:  filepath.Join(testenv.IstioSrc, "manifests"),
+		InFilenames: []string{
+			defaultsIOPFile,
+			iopFile,
+		},
+		Set: []string{
+			"values.global.imagePullPolicy=" + s.PullPolicy,
+		},
 	}
 
 	if i.environment.IsMultinetwork() && c.NetworkName() != "" {
-		installSettings = append(installSettings,
-			"--set", "values.global.meshID="+meshID,
-			"--set", "values.global.network="+c.NetworkName())
+		installArgs.Set = append(installArgs.Set,
+			"values.global.meshID="+meshID,
+			"values.global.network="+c.NetworkName())
 	}
 
 	// Include all user-specified values and configuration options.
 	if cfg.EnableCNI {
-		installSettings = append(installSettings,
-			"--set", "components.cni.namespace=kube-system",
-			"--set", "components.cni.enabled=true")
+		installArgs.Set = append(installArgs.Set,
+			"components.cni.namespace=kube-system",
+			"components.cni.enabled=true")
 	}
 
 	// Include all user-specified values.
 	for k, v := range cfg.Values {
-		installSettings = append(installSettings, "--set", fmt.Sprintf("values.%s=%s", k, v))
+		installArgs.Set = append(installArgs.Set, fmt.Sprintf("values.%s=%s", k, v))
 	}
 
 	for k, v := range cfg.OperatorOptions {
-		installSettings = append(installSettings, "--set", fmt.Sprintf("%s=%s", k, v))
+		installArgs.Set = append(installArgs.Set, fmt.Sprintf("values.%s=%s", k, v))
 	}
-	return installSettings, nil
+	return installArgs, nil
 }
 
 // install will replace and reconcile the installation based on the given install settings
-func install(c *operatorComponent, installSettings []string, istioCtl istioctl.Instance, clusterName string) error {
-	// Save the manifest generate output so we can later cleanup
-	genCmd := []string{"manifest", "generate"}
-	genCmd = append(genCmd, installSettings...)
-	out, _, err := istioCtl.Invoke(genCmd)
-	if err != nil {
+func install(c *operatorComponent, installArgs *mesh.InstallArgs, clusterName string) error {
+	var stdOut, stdErr bytes.Buffer
+	if err := mesh.ManifestGenerate(&mesh.RootArgs{}, &mesh.ManifestGenerateArgs{
+		InFilenames:   installArgs.InFilenames,
+		Set:           installArgs.Set,
+		Force:         installArgs.Force,
+		ManifestsPath: installArgs.ManifestsPath,
+		Revision:      installArgs.Revision,
+	}, cmdLogOptions(), cmdLogger(&stdOut, &stdErr)); err != nil {
 		return err
 	}
-	c.saveManifestForCleanup(clusterName, out)
+	c.saveManifestForCleanup(clusterName, stdOut.String())
 
 	// Actually run the install command
-	cmd := []string{
-		"install",
-		"--skip-confirmation",
-	}
-	cmd = append(cmd, installSettings...)
-	scopes.Framework.Infof("Installing Istio components on cluster %s %v", clusterName, cmd)
-	if _, _, err := istioCtl.Invoke(cmd); err != nil {
-		return fmt.Errorf("install failed: %v", err)
+	installArgs.SkipConfirmation = true
+
+	scopes.Framework.Infof("Installing Istio components on cluster %s %s", clusterName, installArgs)
+	stdOut.Reset()
+	stdErr.Reset()
+	if err := mesh.Install(&mesh.RootArgs{}, installArgs, cmdLogOptions(), &stdOut,
+		cmdLogger(&stdOut, &stdErr),
+		mesh.NewPrinterForWriter(&stdOut)); err != nil {
+		return fmt.Errorf("install failed: %v: %s", err, &stdErr)
 	}
 	return nil
 }
 
+func cmdLogOptions() *log.Options {
+	o := log.DefaultOptions()
+
+	// These scopes are, at the default "INFO" level, too chatty for command line use
+	o.SetOutputLevel("validation", log.ErrorLevel)
+	o.SetOutputLevel("processing", log.ErrorLevel)
+	o.SetOutputLevel("analysis", log.WarnLevel)
+	o.SetOutputLevel("installer", log.WarnLevel)
+	o.SetOutputLevel("translator", log.WarnLevel)
+	o.SetOutputLevel("adsc", log.WarnLevel)
+	o.SetOutputLevel("default", log.WarnLevel)
+	o.SetOutputLevel("klog", log.WarnLevel)
+	o.SetOutputLevel("kube", log.ErrorLevel)
+
+	return o
+}
+
+func cmdLogger(stdOut, stdErr io.Writer) clog.Logger {
+	return clog.NewConsoleLogger(stdOut, stdErr, scopes.Framework)
+}
+
 func waitForIstioReady(ctx resource.Context, c cluster.Cluster, cfg Config) error {
 	if !cfg.SkipWaitForValidationWebhook {
 		// Wait for webhook to come online. The only reliable way to do that is to see if we can submit invalid config.
-- 
2.35.3

