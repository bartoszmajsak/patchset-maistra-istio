From df4472104f21de44a62c750168f1586e1ca544de Mon Sep 17 00:00:00 2001
From: Ingwon Song <102102227+ingwonsong@users.noreply.github.com>
Date: Fri, 13 May 2022 16:09:15 -0700
Subject: WasmPlugin: Fix to update the checksum cache when the module cache
 hits (#38911)

* Fix a bug that `checksums` mapping is not updated when the retrieved
OCI image was already pulled before.

* Update pkg/wasm/cache_test.go

Co-authored-by: Douglas Reid <douglas-reid@users.noreply.github.com>

* Update pkg/wasm/cache_test.go

Co-authored-by: Douglas Reid <douglas-reid@users.noreply.github.com>

* removea temporal debug log

Co-authored-by: Douglas Reid <douglas-reid@users.noreply.github.com>
---
 pkg/wasm/cache.go      |  44 +++++--
 pkg/wasm/cache_test.go | 291 ++++++++++++++++++++++++++++++++++-------
 2 files changed, 274 insertions(+), 61 deletions(-)

diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 600c367be1..62a41a8a3b 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -192,6 +192,7 @@ func (c *LocalFileCache) Get(
 	var modulePath string
 	modulePath, key.checksum = c.getEntry(key, pullIfNotPresent(pullPolicy, u))
 	if modulePath != "" {
+		c.touchEntry(key)
 		return modulePath, nil
 	}
 
@@ -242,6 +243,7 @@ func (c *LocalFileCache) Get(
 		key.checksum = dChecksum
 		// check again if the cache is having the checksum.
 		if modulePath, _ := c.getEntry(key, true); modulePath != "" {
+			c.touchEntry(key)
 			return modulePath, nil
 		}
 	} else if dChecksum != key.checksum {
@@ -278,13 +280,32 @@ func (c *LocalFileCache) Cleanup() {
 	close(c.stopChan)
 }
 
-func (c *LocalFileCache) addEntry(key cacheKey, wasmModule []byte, f string) error {
+func (c *LocalFileCache) updateChecksum(key cacheKey) bool {
 	// If OCI URL having a tag, we need to update checksum.
 	needChecksumUpdate := strings.HasPrefix(key.downloadURL, ociURLPrefix) && !strings.Contains(key.downloadURL, "@")
+	if needChecksumUpdate {
+		ce := c.checksums[key.downloadURL]
+		if ce == nil {
+			ce = new(checksumEntry)
+			ce.resourceVersionByResource = make(map[string]string)
+			c.checksums[key.downloadURL] = ce
+		}
+		ce.checksum = key.checksum
+		ce.resourceVersionByResource[key.resourceName] = key.resourceVersion
+	}
+	return needChecksumUpdate
+}
 
+func (c *LocalFileCache) touchEntry(key cacheKey) {
 	c.mux.Lock()
 	defer c.mux.Unlock()
+	c.updateChecksum(key)
+}
 
+func (c *LocalFileCache) addEntry(key cacheKey, wasmModule []byte, f string) error {
+	c.mux.Lock()
+	defer c.mux.Unlock()
+	needChecksumUpdate := c.updateChecksum(key)
 	if needChecksumUpdate {
 		ce := c.checksums[key.downloadURL]
 		if ce == nil {
@@ -375,17 +396,18 @@ func (c *LocalFileCache) purge() {
 		case <-ticker.C:
 			c.mux.Lock()
 			for k, m := range c.modules {
-				if m.expired(c.wasmModuleExpiry) {
-					// The module has not be touched for expiry duration, delete it from the map as well as the local dir.
-					if err := os.Remove(m.modulePath); err != nil {
-						wasmLog.Errorf("failed to purge Wasm module %v: %v", m.modulePath, err)
-					} else {
-						for downloadURL := range m.referencingURLs {
-							delete(c.checksums, downloadURL)
-						}
-						delete(c.modules, k)
-						wasmLog.Debugf("successfully removed stale Wasm module %v", m.modulePath)
+				if !m.expired(c.wasmModuleExpiry) {
+					continue
+				}
+				// The module has not be touched for expiry duration, delete it from the map as well as the local dir.
+				if err := os.Remove(m.modulePath); err != nil {
+					wasmLog.Errorf("failed to purge Wasm module %v: %v", m.modulePath, err)
+				} else {
+					for downloadURL := range m.referencingURLs {
+						delete(c.checksums, downloadURL)
 					}
+					delete(c.modules, k)
+					wasmLog.Debugf("successfully removed stale Wasm module %v", m.modulePath)
 				}
 			}
 			wasmCacheEntries.Record(float64(len(c.modules)))
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index ea9860351b..60c99b400f 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -28,6 +28,8 @@
 	"testing"
 	"time"
 
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
 	"github.com/google/go-containerregistry/pkg/crane"
 	"github.com/google/go-containerregistry/pkg/registry"
 	"github.com/google/go-containerregistry/pkg/v1/empty"
@@ -100,10 +102,11 @@ func TestWasmCache(t *testing.T) {
 		resourceVersion        string
 		requestTimeout         time.Duration
 		pullPolicy             extensions.PullPolicy
+		wantCachedModules      map[moduleKey]*cacheEntry
+		wantCachedChecksums    map[string]*checksumEntry
 		wantFileName           string
 		wantErrorMsgPrefix     string
 		wantVisitServer        bool
-		wantURLPurged          string
 	}{
 		{
 			name:                   "cache miss",
@@ -114,8 +117,12 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: ts.URL, checksum: httpDataCheckSum}: {modulePath: httpDataCheckSum + ".wasm"},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantFileName:        fmt.Sprintf("%s.wasm", httpDataCheckSum),
+			wantVisitServer:     true,
 		},
 		{
 			name: "cache hit",
@@ -128,8 +135,12 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               cacheHitSum,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           "test.wasm",
-			wantVisitServer:        false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: ts.URL, checksum: cacheHitSum}: {modulePath: "test.wasm"},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantFileName:        "test.wasm",
+			wantVisitServer:     false,
 		},
 		{
 			name:                   "invalid scheme",
@@ -140,6 +151,8 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
 			requestTimeout:         time.Second * 10,
+			wantCachedModules:      map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:    map[string]*checksumEntry{},
 			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
 			wantErrorMsgPrefix:     "unsupported Wasm module downloading URL scheme: foo",
 			wantVisitServer:        false,
@@ -152,6 +165,8 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
+			wantCachedModules:      map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:    map[string]*checksumEntry{},
 			wantErrorMsgPrefix:     "wasm module download failed after 5 attempts, last error: Get \"https://dummyurl\"",
 			wantVisitServer:        false,
 		},
@@ -164,6 +179,8 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               "wrongchecksum\n",
 			requestTimeout:         time.Second * 10,
+			wantCachedModules:      map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:    map[string]*checksumEntry{},
 			wantErrorMsgPrefix:     fmt.Sprintf("module downloaded from %v has checksum %s, which does not match", ts.URL, httpDataCheckSum),
 			wantVisitServer:        true,
 		},
@@ -180,8 +197,12 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
 			requestTimeout:         time.Second * 10,
-			wantErrorMsgPrefix:     fmt.Sprintf("module downloaded from %v/different-url has checksum", ts.URL),
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: ts.URL, checksum: httpDataCheckSum}: {modulePath: httpDataCheckSum + ".wasm"},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantErrorMsgPrefix:  fmt.Sprintf("module downloaded from %v/different-url has checksum", ts.URL),
+			wantVisitServer:     true,
 		},
 		{
 			name: "invalid wasm header",
@@ -194,8 +215,12 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               invalidHTTPDataCheckSum,
 			requestTimeout:         time.Second * 10,
-			wantErrorMsgPrefix:     fmt.Sprintf("fetched Wasm binary from %s is invalid", ts.URL+"/invalid-wasm-header"),
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: ts.URL, checksum: httpDataCheckSum}: {modulePath: httpDataCheckSum + ".wasm"},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantErrorMsgPrefix:  fmt.Sprintf("fetched Wasm binary from %s is invalid", ts.URL+"/invalid-wasm-header"),
+			wantVisitServer:     true,
 		},
 		{
 			name: "purge on expiry",
@@ -209,31 +234,51 @@ func TestWasmCache(t *testing.T) {
 			checkPurgeTimeout:      5 * time.Second,
 			checksum:               httpDataCheckSum,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: ts.URL, checksum: httpDataCheckSum}: {modulePath: httpDataCheckSum + ".wasm"},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantFileName:        fmt.Sprintf("%s.wasm", httpDataCheckSum),
+			wantVisitServer:     true,
 		},
 		{
 			name:                   "fetch oci without digest",
 			initialCachedModules:   map[moduleKey]cacheEntry{},
 			initialCachedChecksums: map[string]*checksumEntry{},
+			resourceName:           "namespace.resource",
+			resourceVersion:        "0",
 			fetchURL:               ociURLWithTag,
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           ociWasmFile,
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name:                   "fetch oci with digest",
 			initialCachedModules:   map[moduleKey]cacheEntry{},
 			initialCachedChecksums: map[string]*checksumEntry{},
+			resourceName:           "namespace.resource",
+			resourceVersion:        "0",
 			fetchURL:               ociURLWithTag,
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
 			checksum:               dockerImageDigest,
-			wantFileName:           ociWasmFile,
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name: "cache hit for tagged oci url with digest",
@@ -241,13 +286,21 @@ func TestWasmCache(t *testing.T) {
 				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
 			initialCachedChecksums: map[string]*checksumEntry{},
+			resourceName:           "namespace.resource",
+			resourceVersion:        "0",
 			fetchURL:               ociURLWithTag,
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
 			checksum:               dockerImageDigest,
-			wantFileName:           ociWasmFile,
-			wantVisitServer:        false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "cache hit for tagged oci url without digest",
@@ -268,8 +321,14 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:    DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "cache miss for tagged oci url without digest",
@@ -277,12 +336,20 @@ func TestWasmCache(t *testing.T) {
 				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
 			initialCachedChecksums: map[string]*checksumEntry{},
+			resourceName:           "namespace.resource",
+			resourceVersion:        "0",
 			fetchURL:               ociURLWithTag,
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           ociWasmFile,
-			wantVisitServer:        true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name: "cache hit for oci url suffixed by digest",
@@ -290,12 +357,18 @@ func TestWasmCache(t *testing.T) {
 				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
 			initialCachedChecksums: map[string]*checksumEntry{},
+			resourceName:           "namespace.resource",
+			resourceVersion:        "0",
 			fetchURL:               ociURLWithDigest,
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			requestTimeout:         time.Second * 10,
-			wantFileName:           ociWasmFile,
-			wantVisitServer:        false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{},
+			wantFileName:        ociWasmFile,
+			wantVisitServer:     false,
 		},
 		{
 			name: "pull due to pull-always policy when cache hit",
@@ -317,8 +390,14 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
 			pullPolicy:       extensions.PullPolicy_Always,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  true,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name: "do not pull due to resourceVersion is the same",
@@ -340,8 +419,14 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
 			pullPolicy:       extensions.PullPolicy_Always,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "123456"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "pull due to if-not-present policy when cache hit",
@@ -363,61 +448,135 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
 			pullPolicy:       extensions.PullPolicy_IfNotPresent,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "do not pull in spite of pull-always policy due to checksum",
 			initialCachedModules: map[moduleKey]cacheEntry{
 				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
+			resourceName:     "namespace.resource",
+			resourceVersion:  "0",
 			fetchURL:         ociURLWithTag,
 			purgeInterval:    DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
 			checksum:         dockerImageDigest,
 			pullPolicy:       extensions.PullPolicy_Always,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
+		},
+		{
+			name: "pull due to latest tag",
+			initialCachedModules: map[moduleKey]cacheEntry{
+				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			resourceName:    "namespace.resource",
+			resourceVersion: "0",
+			initialCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {
+					checksum: dockerImageDigest,
+					resourceVersionByResource: map[string]string{
+						"namespace.resource": "123456",
+					},
+				},
+			},
+			fetchURL:         ociURLWithLatestTag,
+			purgeInterval:    DefaultWasmModulePurgeInterval,
+			wasmModuleExpiry: DefaultWasmModuleExpiry,
+			requestTimeout:   time.Second * 10,
+			pullPolicy:       extensions.PullPolicy_UNSPECIFIED_POLICY, // Default policy
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name: "do not pull in spite of latest tag due to checksum",
 			initialCachedModules: map[moduleKey]cacheEntry{
 				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
+			initialCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {
+					checksum: dockerImageDigest,
+					resourceVersionByResource: map[string]string{
+						"namespace.resource": "123456",
+					},
+				},
+			},
+			resourceName:     "namespace.resource",
+			resourceVersion:  "0",
 			fetchURL:         ociURLWithLatestTag,
 			purgeInterval:    DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
 			checksum:         dockerImageDigest,
 			pullPolicy:       extensions.PullPolicy_UNSPECIFIED_POLICY, // Default policy
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "do not pull in spite of latest tag due to IfNotPresent policy",
 			initialCachedModules: map[moduleKey]cacheEntry{
 				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
 			},
+			initialCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {
+					checksum: dockerImageDigest,
+					resourceVersionByResource: map[string]string{
+						"namespace.resource": "123456",
+					},
+				},
+			},
+			resourceName:     "namespace.resource",
+			resourceVersion:  "0",
 			fetchURL:         ociURLWithLatestTag,
 			purgeInterval:    DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry: DefaultWasmModuleExpiry,
 			requestTimeout:   time.Second * 10,
-			checksum:         dockerImageDigest,
 			pullPolicy:       extensions.PullPolicy_IfNotPresent,
-			wantFileName:     ociWasmFile,
-			wantVisitServer:  false,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				ociURLWithLatestTag: {checksum: dockerImageDigest, resourceVersionByResource: map[string]string{"namespace.resource": "0"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: false,
 		},
 		{
 			name: "purge OCI image on expiry",
 			initialCachedModules: map[moduleKey]cacheEntry{
-				{name: urlAsResourceName(ociURLWithTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile, referencingURLs: sets.New(ociURLWithTag)},
+				{name: urlAsResourceName(ociURLWithTag) + "-purged", checksum: dockerImageDigest}: {modulePath: ociWasmFile, referencingURLs: sets.New(ociURLWithTag)},
 			},
 			initialCachedChecksums: map[string]*checksumEntry{
 				ociURLWithTag: {
 					checksum: dockerImageDigest,
 					resourceVersionByResource: map[string]string{
-						"namespace.resource1": "123456",
+						"namespace.resource": "123456",
 					},
 				},
 				"test-url": {
@@ -427,33 +586,48 @@ func TestWasmCache(t *testing.T) {
 					},
 				},
 			},
+			resourceName:      "namespace.resource",
+			resourceVersion:   "0",
 			fetchURL:          ociURLWithDigest,
 			purgeInterval:     1 * time.Millisecond,
 			wasmModuleExpiry:  1 * time.Millisecond,
 			requestTimeout:    time.Second * 10,
 			checkPurgeTimeout: 5 * time.Second,
-			wantFileName:      ociWasmFile,
-			wantVisitServer:   true,
-			wantURLPurged:     ociURLWithTag,
+			wantCachedModules: map[moduleKey]*cacheEntry{
+				{name: urlAsResourceName(ociURLWithLatestTag), checksum: dockerImageDigest}: {modulePath: ociWasmFile},
+			},
+			wantCachedChecksums: map[string]*checksumEntry{
+				"test-url": {checksum: "test-checksum", resourceVersionByResource: map[string]string{"namespace.resource2": "123456"}},
+			},
+			wantFileName:    ociWasmFile,
+			wantVisitServer: true,
 		},
 		{
 			name:                 "fetch oci timed out",
 			initialCachedModules: map[moduleKey]cacheEntry{},
+			resourceName:         "namespace.resource",
+			resourceVersion:      "0",
 			fetchURL:             ociURLWithTag,
 			purgeInterval:        DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:     DefaultWasmModuleExpiry,
 			requestTimeout:       0, // Cause timeout immediately.
+			wantCachedModules:    map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:  map[string]*checksumEntry{},
 			wantErrorMsgPrefix:   fmt.Sprintf("could not fetch Wasm OCI image: could not fetch manifest: Get \"https://%s/v2/\"", ou.Host),
 			wantVisitServer:      false,
 		},
 		{
 			name:                 "fetch oci with wrong digest",
 			initialCachedModules: map[moduleKey]cacheEntry{},
+			resourceName:         "namespace.resource",
+			resourceVersion:      "0",
 			fetchURL:             ociURLWithTag,
 			purgeInterval:        DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:     DefaultWasmModuleExpiry,
 			requestTimeout:       time.Second * 10,
 			checksum:             "wrongdigest",
+			wantCachedModules:    map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:  map[string]*checksumEntry{},
 			wantErrorMsgPrefix: fmt.Sprintf(
 				"module downloaded from %v has checksum %v, which does not match:", fmt.Sprintf("oci://%s/test/valid/docker:v0.1.0", ou.Host), dockerImageDigest,
 			),
@@ -462,11 +636,15 @@ func TestWasmCache(t *testing.T) {
 		{
 			name:                 "fetch invalid oci",
 			initialCachedModules: map[moduleKey]cacheEntry{},
+			resourceName:         "namespace.resource",
+			resourceVersion:      "0",
 			fetchURL:             fmt.Sprintf("oci://%s/test/invalid", ou.Host),
 			purgeInterval:        DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:     DefaultWasmModuleExpiry,
 			checksum:             invalidOCIImageDigest,
 			requestTimeout:       time.Second * 10,
+			wantCachedModules:    map[moduleKey]*cacheEntry{},
+			wantCachedChecksums:  map[string]*checksumEntry{},
 			wantErrorMsgPrefix: `could not fetch Wasm binary: the given image is in invalid format as an OCI image: 2 errors occurred:
 	* could not parse as compat variant: invalid media type application/vnd.oci.image.layer.v1.tar (expect application/vnd.oci.image.layer.v1.tar+gzip)
 	* could not parse as oci variant: number of layers must be 2 but got 1`,
@@ -507,6 +685,11 @@ func TestWasmCache(t *testing.T) {
 			for k, m := range c.initialCachedChecksums {
 				cache.checksums[k] = m
 			}
+
+			// put the tmp dir into the module path.
+			for k, m := range c.wantCachedModules {
+				c.wantCachedModules[k].modulePath = filepath.Join(tmpDir, m.modulePath)
+			}
 			cache.mux.Unlock()
 
 			if c.checkPurgeTimeout > 0 {
@@ -519,13 +702,6 @@ func TestWasmCache(t *testing.T) {
 					}
 				}
 
-				cache.mux.Lock()
-				_, ok := cache.checksums[c.wantURLPurged]
-				cache.mux.Unlock()
-				if ok {
-					t.Fatalf("the checksum cache for %v is not purged before purge timeout", c.wantURLPurged)
-				}
-
 				if !moduleDeleted {
 					t.Fatalf("Wasm modules are not purged before purge timeout")
 				}
@@ -535,13 +711,28 @@ func TestWasmCache(t *testing.T) {
 			gotFilePath, gotErr := cache.Get(c.fetchURL, c.checksum, c.resourceName, c.resourceVersion, c.requestTimeout, []byte{}, c.pullPolicy)
 			serverVisited := atomic.LoadInt32(&tsNumRequest) > 0
 
+			cache.mux.Lock()
 			if cacheHitKey != nil {
-				cache.mux.Lock()
 				if entry, ok := cache.modules[*cacheHitKey]; ok && entry.last == initTime {
 					t.Errorf("Wasm module cache entry's last access time not updated after get operation, key: %v", *cacheHitKey)
 				}
-				cache.mux.Unlock()
 			}
+
+			if diff := cmp.Diff(cache.modules, c.wantCachedModules,
+				cmpopts.IgnoreFields(cacheEntry{}, "last", "referencingURLs"),
+				cmp.AllowUnexported(cacheEntry{}),
+			); diff != "" {
+				t.Errorf("unexpected module cache: (+want, -got)\n%v", diff)
+			}
+
+			if diff := cmp.Diff(cache.checksums, c.wantCachedChecksums,
+				cmp.AllowUnexported(checksumEntry{}),
+			); diff != "" {
+				t.Errorf("unexpected checksums: (+want, -got)\n%v", diff)
+			}
+
+			cache.mux.Unlock()
+
 			wantFilePath := filepath.Join(tmpDir, c.wantFileName)
 			if c.wantErrorMsgPrefix != "" {
 				if gotErr == nil {
-- 
2.35.3

