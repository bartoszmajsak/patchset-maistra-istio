From 8355b7fa8ecc8a59a5b1cdbf2c71056c9e5fe9b7 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Wed, 13 Apr 2022 00:21:43 +0800
Subject: Clean up unused destinationCIDR  param (#38321)

* Remove prefix range if it is 0.0.0.0

* update

* update
---
 pilot/pkg/networking/core/v1alpha3/listener.go | 16 ++++++----------
 pilot/pkg/networking/core/v1alpha3/tls.go      | 10 ++++++++--
 2 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index aca0ea7419..09c5456933 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -932,7 +932,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundHTTPListenerOptsForPor
 	}}
 }
 
-func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPortOrUDS(destinationCIDR *string, listenerMapKey *string,
+func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPortOrUDS(listenerMapKey *string,
 	currentListenerEntry **outboundListenerEntry, listenerOpts *buildListenerOpts, listenerMap map[string]*outboundListenerEntry,
 	virtualServices []config.Config, actualWildcard string) (bool, []*filterChainOpts) {
 	// first identify the bind if its not set. Then construct the key
@@ -945,7 +945,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPort
 	// As a small optimization, CIDRs with /32 prefix will be converted
 	// into listener address so that there is a dedicated listener for this
 	// ip:port. This will reduce the impact of a listener reload
-
+	var destinationCIDR string
 	if len(listenerOpts.bind) == 0 {
 		svcListenAddress := listenerOpts.service.GetAddressForProxy(listenerOpts.proxy)
 		// We should never get an empty address.
@@ -957,7 +957,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPort
 			} else {
 				// Address is a CIDR. Fall back to 0.0.0.0 and
 				// filter chain match
-				*destinationCIDR = svcListenAddress
+				destinationCIDR = svcListenAddress
 				listenerOpts.bind = actualWildcard
 			}
 		}
@@ -1033,7 +1033,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPort
 	meshGateway := map[string]bool{constants.IstioMeshGateway: true}
 	return true, buildSidecarOutboundTCPTLSFilterChainOpts(listenerOpts.proxy,
 		listenerOpts.push, virtualServices,
-		*destinationCIDR, listenerOpts.service,
+		destinationCIDR, listenerOpts.service,
 		listenerOpts.bind, listenerOpts.port, meshGateway)
 }
 
@@ -1044,7 +1044,6 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPort
 // allowed only if they have different CIDR matches.
 func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
 	listenerMap map[string]*outboundListenerEntry, virtualServices []config.Config, actualWildcard string) {
-	var destinationCIDR string
 	var listenerMapKey string
 	var currentListenerEntry *outboundListenerEntry
 	var ret bool
@@ -1118,7 +1117,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 			listenerOpts.filterChainOpts = opts
 
 		case istionetworking.ListenerProtocolTCP:
-			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&destinationCIDR, &listenerMapKey, &currentListenerEntry,
+			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 				&listenerOpts, listenerMap, virtualServices, actualWildcard); !ret {
 				return
 			}
@@ -1140,7 +1139,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 
 		case istionetworking.ListenerProtocolAuto:
 			// Add tcp filter chain, build TCP filter chain first.
-			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&destinationCIDR, &listenerMapKey, &currentListenerEntry,
+			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 				&listenerOpts, listenerMap, virtualServices, actualWildcard); !ret {
 				return
 			}
@@ -1552,9 +1551,6 @@ func buildListener(opts buildListenerOpts, trafficDirection core.TrafficDirectio
 			chain.destinationCIDRs = append([]string{}, chain.destinationCIDRs...)
 			sort.Stable(sort.StringSlice(chain.destinationCIDRs))
 			for _, d := range chain.destinationCIDRs {
-				if len(d) == 0 {
-					continue
-				}
 				cidr := util.ConvertAddressToCidr(d)
 				if cidr != nil && cidr.AddressPrefix != constants.UnspecifiedIP {
 					match.PrefixRanges = append(match.PrefixRanges, cidr)
diff --git a/pilot/pkg/networking/core/v1alpha3/tls.go b/pilot/pkg/networking/core/v1alpha3/tls.go
index da43e77986..697d9db473 100644
--- a/pilot/pkg/networking/core/v1alpha3/tls.go
+++ b/pilot/pkg/networking/core/v1alpha3/tls.go
@@ -132,7 +132,10 @@ func buildSidecarOutboundTLSFilterChainOpts(node *model.Proxy, push *model.PushC
 					// But if a virtual service overrides it with its own destination subnet match
 					// give preference to the user provided one
 					// destinationCIDR will be empty for services with VIPs
-					destinationCIDRs := []string{destinationCIDR}
+					var destinationCIDRs []string
+					if destinationCIDR != "" {
+						destinationCIDRs = []string{destinationCIDR}
+					}
 					// Only set CIDR match if the listener is bound to an IP.
 					// If its bound to a unix domain socket, then ignore the CIDR matches
 					// Unix domain socket bound ports have Port value set to 0
@@ -223,7 +226,10 @@ func buildSidecarOutboundTCPFilterChainOpts(node *model.Proxy, push *model.PushC
 	for _, cfg := range configs {
 		virtualService := cfg.Spec.(*v1alpha3.VirtualService)
 		for _, tcp := range virtualService.Tcp {
-			destinationCIDRs := []string{destinationCIDR}
+			var destinationCIDRs []string
+			if destinationCIDR != "" {
+				destinationCIDRs = []string{destinationCIDR}
+			}
 			if len(tcp.Match) == 0 {
 				// implicit match
 				out = append(out, &filterChainOpts{
-- 
2.35.3

