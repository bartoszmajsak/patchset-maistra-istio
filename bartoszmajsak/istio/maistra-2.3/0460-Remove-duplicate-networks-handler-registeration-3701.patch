From e734af4be2312475bea8c9367abb4138cb44ae16 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Fri, 28 Jan 2022 00:45:51 +0800
Subject: Remove duplicate networks handler registeration (#37010)

* Remove duplicate networks handler registeration

* Fix tests
---
 pilot/pkg/bootstrap/mesh.go                   | 11 +++----
 pilot/pkg/bootstrap/server.go                 |  8 +----
 pilot/pkg/model/context.go                    |  7 ++--
 pilot/pkg/model/network.go                    |  2 +-
 pilot/pkg/networking/core/configgen.go        |  2 +-
 .../pkg/networking/core/v1alpha3/configgen.go |  2 +-
 .../kube/controller/network.go                |  2 +-
 pilot/pkg/xds/eds_sh_test.go                  |  6 ++--
 pkg/config/mesh/kubemesh/watcher.go           |  7 +---
 pkg/config/mesh/networks_watcher.go           | 28 ++++++++--------
 pkg/config/mesh/watcher.go                    | 32 +++++++++++--------
 pkg/config/mesh/watcher_test_utils.go         |  4 +--
 pkg/kube/configmapwatcher/configmapwatcher.go |  2 +-
 .../configmapwatcher/configmapwatcher_test.go |  2 --
 14 files changed, 52 insertions(+), 63 deletions(-)

diff --git a/pilot/pkg/bootstrap/mesh.go b/pilot/pkg/bootstrap/mesh.go
index ed683f1dd8..61e804fa11 100644
--- a/pilot/pkg/bootstrap/mesh.go
+++ b/pilot/pkg/bootstrap/mesh.go
@@ -85,8 +85,11 @@ func (s *Server) initMeshConfiguration(args *PilotArgs, fileWatcher filewatcher.
 	// Watch the istio ConfigMap for mesh config changes.
 	// This may be necessary for external Istiod.
 	configMapName := getMeshConfigMapName(args.Revision)
-	s.environment.Watcher = kubemesh.NewConfigMapWatcher(
+	multiWatcher := kubemesh.NewConfigMapWatcher(
 		s.kubeClient, args.Namespace, configMapName, configMapKey, multiWatch, s.internalStop)
+	s.environment.Watcher = multiWatcher
+	s.environment.NetworksWatcher = multiWatcher
+	log.Infof("initializing mesh networks from mesh config watcher")
 
 	if multiWatch {
 		kubemesh.AddUserMeshConfig(s.kubeClient, s.environment.Watcher, args.Namespace, configMapKey, features.SharedMeshConfig, s.internalStop)
@@ -96,11 +99,7 @@ func (s *Server) initMeshConfiguration(args *PilotArgs, fileWatcher filewatcher.
 // initMeshNetworks loads the mesh networks configuration from the file provided
 // in the args and add a watcher for changes in this file.
 func (s *Server) initMeshNetworks(args *PilotArgs, fileWatcher filewatcher.FileWatcher) {
-	if mw, ok := s.environment.Watcher.(mesh.NetworksWatcher); ok {
-		// The mesh config watcher is also a NetworksWatcher, this is common for reading ConfigMap
-		// directly from Kubernetes
-		log.Infof("initializing mesh networks from mesh config watcher")
-		s.environment.NetworksWatcher = mw
+	if s.environment.NetworksWatcher != nil {
 		return
 	}
 	log.Info("initializing mesh networks")
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index cd5adc9935..11dc0bd6bc 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -368,7 +368,7 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 func initOIDC(args *PilotArgs, trustDomain string) (security.Authenticator, error) {
 	// JWTRule is from the JWT_RULE environment variable.
 	// An example of json string for JWTRule is:
-	//`{"issuer": "foo", "jwks_uri": "baz", "audiences": ["aud1", "aud2"]}`.
+	// `{"issuer": "foo", "jwks_uri": "baz", "audiences": ["aud1", "aud2"]}`.
 	jwtRule := v1beta1.JWTRule{}
 	err := json.Unmarshal([]byte(args.JwtRule), &jwtRule)
 	if err != nil {
@@ -1186,12 +1186,6 @@ func (s *Server) initMeshHandlers() {
 			Reason: []model.TriggerReason{model.GlobalUpdate},
 		})
 	})
-	s.environment.AddNetworksHandler(func() {
-		s.XDSServer.ConfigUpdate(&model.PushRequest{
-			Full:   true,
-			Reason: []model.TriggerReason{model.NetworksTrigger},
-		})
-	})
 }
 
 func (s *Server) addIstioCAToTrustBundle(args *PilotArgs) error {
diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 3b4e2a8fad..6f920eefa1 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -50,10 +50,7 @@
 	"istio.io/pkg/monitoring"
 )
 
-var (
-	_ mesh.Holder         = &Environment{}
-	_ mesh.NetworksHolder = &Environment{}
-)
+var _ mesh.Holder = &Environment{}
 
 // Environment provides an aggregate environmental API for Pilot
 type Environment struct {
@@ -71,7 +68,7 @@ type Environment struct {
 	// network. Each network provides information about the endpoints in a
 	// routable L3 network. A single routable L3 network can have one or more
 	// service registries.
-	mesh.NetworksWatcher
+	NetworksWatcher mesh.NetworksWatcher
 
 	NetworkManager *NetworkManager
 
diff --git a/pilot/pkg/model/network.go b/pilot/pkg/model/network.go
index b88aa3629c..96155fec04 100644
--- a/pilot/pkg/model/network.go
+++ b/pilot/pkg/model/network.go
@@ -103,7 +103,7 @@ func (mgr *NetworkManager) reload() NetworkGatewaySet {
 	gatewaySet := make(NetworkGatewaySet)
 
 	// First, load gateways from the static MeshNetworks config.
-	meshNetworks := mgr.env.Networks()
+	meshNetworks := mgr.env.NetworksWatcher.Networks()
 	if meshNetworks != nil {
 		for nw, networkConf := range meshNetworks.Networks {
 			for _, gw := range networkConf.Gateways {
diff --git a/pilot/pkg/networking/core/configgen.go b/pilot/pkg/networking/core/configgen.go
index 57e73faf9c..080f9c80cb 100644
--- a/pilot/pkg/networking/core/configgen.go
+++ b/pilot/pkg/networking/core/configgen.go
@@ -50,7 +50,7 @@ type ConfigGenerator interface {
 	// BuildExtensionConfiguration returns the list of extension configuration for the given proxy and list of names. This is the ECDS output.
 	BuildExtensionConfiguration(node *model.Proxy, push *model.PushContext, extensionConfigNames []string) []*core.TypedExtensionConfig
 
-	// ConfigChanged is invoked when mesh config is changed, giving a chance to rebuild any cached config.
+	// MeshConfigChanged is invoked when mesh config is changed, giving a chance to rebuild any cached config.
 	MeshConfigChanged(mesh *meshconfig.MeshConfig)
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/configgen.go b/pilot/pkg/networking/core/v1alpha3/configgen.go
index 18700460af..e3f85280a9 100644
--- a/pilot/pkg/networking/core/v1alpha3/configgen.go
+++ b/pilot/pkg/networking/core/v1alpha3/configgen.go
@@ -33,7 +33,7 @@ func NewConfigGenerator(plugins []plugin.Plugin, cache model.XdsCache) *ConfigGe
 	}
 }
 
-// Called when mesh config is changed.
+// MeshConfigChanged is called when mesh config is changed.
 func (configgen *ConfigGeneratorImpl) MeshConfigChanged(_ *meshconfig.MeshConfig) {
 	accessLogBuilder.reset()
 }
diff --git a/pilot/pkg/serviceregistry/kube/controller/network.go b/pilot/pkg/serviceregistry/kube/controller/network.go
index 590e6c4824..2054845b34 100644
--- a/pilot/pkg/serviceregistry/kube/controller/network.go
+++ b/pilot/pkg/serviceregistry/kube/controller/network.go
@@ -154,7 +154,7 @@ func (c *Controller) NetworkGateways() []model.NetworkGateway {
 	c.RLock()
 	defer c.RUnlock()
 
-	if c.networkGatewaysBySvc == nil || len(c.networkGatewaysBySvc) == 0 {
+	if len(c.networkGatewaysBySvc) == 0 {
 		return nil
 	}
 
diff --git a/pilot/pkg/xds/eds_sh_test.go b/pilot/pkg/xds/eds_sh_test.go
index 07d59e91dc..829ed8a988 100644
--- a/pilot/pkg/xds/eds_sh_test.go
+++ b/pilot/pkg/xds/eds_sh_test.go
@@ -22,7 +22,7 @@
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	endpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
-	structpb "google.golang.org/protobuf/types/known/structpb"
+	"google.golang.org/protobuf/types/known/structpb"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
@@ -325,7 +325,7 @@ func initRegistry(server *xds.FakeDiscoveryServer, networkNum int, gatewaysIP []
 }
 
 func addNetwork(server *xds.FakeDiscoveryServer, id network.ID, network *meshconfig.Network) {
-	meshNetworks := server.Env().Networks()
+	meshNetworks := server.Env().NetworksWatcher.Networks()
 	// copy old networks if they exist
 	c := map[string]*meshconfig.Network{}
 	if meshNetworks != nil {
@@ -335,7 +335,7 @@ func addNetwork(server *xds.FakeDiscoveryServer, id network.ID, network *meshcon
 	}
 	// add the new one
 	c[string(id)] = network
-	server.Env().SetNetworks(&meshconfig.MeshNetworks{Networks: c})
+	server.Env().NetworksWatcher.SetNetworks(&meshconfig.MeshNetworks{Networks: c})
 }
 
 func getLbEndpointAddrs(eps []*endpoint.LbEndpoint) []string {
diff --git a/pkg/config/mesh/kubemesh/watcher.go b/pkg/config/mesh/kubemesh/watcher.go
index 6ffd952052..e8f27c2259 100644
--- a/pkg/config/mesh/kubemesh/watcher.go
+++ b/pkg/config/mesh/kubemesh/watcher.go
@@ -30,12 +30,7 @@
 // NewConfigMapWatcher creates a new Watcher for changes to the given ConfigMap.
 func NewConfigMapWatcher(client kube.Client, namespace, name, key string, multiWatch bool, stop <-chan struct{}) *mesh.MultiWatcher {
 	defaultMesh := mesh.DefaultMeshConfig()
-	w := &mesh.MultiWatcher{
-		InternalWatcher: mesh.InternalWatcher{
-			MeshConfig: &defaultMesh,
-		},
-		InternalNetworkWatcher: mesh.InternalNetworkWatcher{},
-	}
+	w := mesh.NewMultiWatcher(&defaultMesh)
 	c := configmapwatcher.NewController(client, namespace, name, func(cm *v1.ConfigMap) {
 		meshNetworks, err := ReadNetworksConfigMap(cm, "meshNetworks")
 		if err != nil {
diff --git a/pkg/config/mesh/networks_watcher.go b/pkg/config/mesh/networks_watcher.go
index 8aebf631e6..57bb27da13 100644
--- a/pkg/config/mesh/networks_watcher.go
+++ b/pkg/config/mesh/networks_watcher.go
@@ -18,8 +18,6 @@
 	"fmt"
 	"reflect"
 	"sync"
-	"sync/atomic"
-	"unsafe"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pkg/util/gogoprotomarshal"
@@ -33,17 +31,17 @@ type NetworksHolder interface {
 	Networks() *meshconfig.MeshNetworks
 }
 
-// NetworkWatcher watches changes to the mesh networks config.
+// NetworksWatcher watches changes to the mesh networks config.
 type NetworksWatcher interface {
 	NetworksHolder
 
 	AddNetworksHandler(func())
 }
 
-var _ NetworksWatcher = &InternalNetworkWatcher{}
+var _ NetworksWatcher = &internalNetworkWatcher{}
 
-type InternalNetworkWatcher struct {
-	mutex    sync.Mutex
+type internalNetworkWatcher struct {
+	mutex    sync.RWMutex
 	handlers []func()
 	networks *meshconfig.MeshNetworks
 }
@@ -51,7 +49,7 @@ type InternalNetworkWatcher struct {
 // NewFixedNetworksWatcher creates a new NetworksWatcher that always returns the given config.
 // It will never fire any events, since the config never changes.
 func NewFixedNetworksWatcher(networks *meshconfig.MeshNetworks) NetworksWatcher {
-	return &InternalNetworkWatcher{
+	return &internalNetworkWatcher{
 		networks: networks,
 	}
 }
@@ -66,7 +64,7 @@ func NewNetworksWatcher(fileWatcher filewatcher.FileWatcher, filename string) (N
 	networksdump, _ := gogoprotomarshal.ToJSONWithIndent(meshNetworks, "   ")
 	log.Infof("mesh networks configuration: %s", networksdump)
 
-	w := &InternalNetworkWatcher{
+	w := &internalNetworkWatcher{
 		networks: meshNetworks,
 	}
 
@@ -84,15 +82,17 @@ func NewNetworksWatcher(fileWatcher filewatcher.FileWatcher, filename string) (N
 }
 
 // Networks returns the latest network configuration for the mesh.
-func (w *InternalNetworkWatcher) Networks() *meshconfig.MeshNetworks {
+func (w *internalNetworkWatcher) Networks() *meshconfig.MeshNetworks {
 	if w == nil {
 		return nil
 	}
-	return (*meshconfig.MeshNetworks)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&w.networks))))
+	w.mutex.RLock()
+	defer w.mutex.RUnlock()
+	return w.networks
 }
 
 // SetNetworks will use the given value for mesh networks and notify all handlers of the change
-func (w *InternalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetworks) {
+func (w *internalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetworks) {
 	var handlers []func()
 
 	w.mutex.Lock()
@@ -101,7 +101,7 @@ func (w *InternalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetwor
 		log.Infof("mesh networks configuration updated to: %s", networksdump)
 
 		// Store the new config.
-		atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&w.networks)), unsafe.Pointer(meshNetworks))
+		w.networks = meshNetworks
 		handlers = append([]func(){}, w.handlers...)
 	}
 	w.mutex.Unlock()
@@ -112,8 +112,8 @@ func (w *InternalNetworkWatcher) SetNetworks(meshNetworks *meshconfig.MeshNetwor
 	}
 }
 
-// AddMeshHandler registers a callback handler for changes to the mesh network config.
-func (w *InternalNetworkWatcher) AddNetworksHandler(h func()) {
+// AddNetworksHandler registers a callback handler for changes to the mesh network config.
+func (w *internalNetworkWatcher) AddNetworksHandler(h func()) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 
diff --git a/pkg/config/mesh/watcher.go b/pkg/config/mesh/watcher.go
index 6c5e5bc7f3..cfe2eab96a 100644
--- a/pkg/config/mesh/watcher.go
+++ b/pkg/config/mesh/watcher.go
@@ -46,13 +46,19 @@ type Watcher interface {
 
 // MultiWatcher is a struct wrapping the internal injector to let users know that both
 type MultiWatcher struct {
-	InternalWatcher
-	InternalNetworkWatcher
+	internalWatcher
+	internalNetworkWatcher
 }
 
-var _ Watcher = &InternalWatcher{}
+func NewMultiWatcher(config *meshconfig.MeshConfig) *MultiWatcher {
+	return &MultiWatcher{
+		internalWatcher: internalWatcher{MeshConfig: config},
+	}
+}
+
+var _ Watcher = &internalWatcher{}
 
-type InternalWatcher struct {
+type internalWatcher struct {
 	mutex    sync.Mutex
 	handlers []func()
 	// Current merged mesh config
@@ -65,7 +71,7 @@ type InternalWatcher struct {
 // NewFixedWatcher creates a new Watcher that always returns the given mesh config. It will never
 // fire any events, since the config never changes.
 func NewFixedWatcher(mesh *meshconfig.MeshConfig) Watcher {
-	return &InternalWatcher{
+	return &internalWatcher{
 		MeshConfig: mesh,
 	}
 }
@@ -83,7 +89,7 @@ func NewFileWatcher(fileWatcher filewatcher.FileWatcher, filename string, multiW
 		return nil, err
 	}
 
-	w := &InternalWatcher{
+	w := &internalWatcher{
 		MeshConfig:    meshConfig,
 		revMeshConfig: meshConfigYaml,
 	}
@@ -111,12 +117,12 @@ func NewFileWatcher(fileWatcher filewatcher.FileWatcher, filename string, multiW
 }
 
 // Mesh returns the latest mesh config.
-func (w *InternalWatcher) Mesh() *meshconfig.MeshConfig {
+func (w *internalWatcher) Mesh() *meshconfig.MeshConfig {
 	return (*meshconfig.MeshConfig)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&w.MeshConfig))))
 }
 
 // AddMeshHandler registers a callback handler for changes to the mesh config.
-func (w *InternalWatcher) AddMeshHandler(h func()) {
+func (w *internalWatcher) AddMeshHandler(h func()) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 	w.handlers = append(w.handlers, h)
@@ -124,7 +130,7 @@ func (w *InternalWatcher) AddMeshHandler(h func()) {
 
 // HandleMeshConfigData keeps track of the standard mesh config. These are merged with the user
 // mesh config, but takes precedence.
-func (w *InternalWatcher) HandleMeshConfigData(yaml string) {
+func (w *internalWatcher) HandleMeshConfigData(yaml string) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 	w.revMeshConfig = yaml
@@ -134,7 +140,7 @@ func (w *InternalWatcher) HandleMeshConfigData(yaml string) {
 
 // HandleUserMeshConfig keeps track of user mesh config overrides. These are merged with the standard
 // mesh config, which takes precedence.
-func (w *InternalWatcher) HandleUserMeshConfig(yaml string) {
+func (w *internalWatcher) HandleUserMeshConfig(yaml string) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 	w.userMeshConfig = yaml
@@ -143,7 +149,7 @@ func (w *InternalWatcher) HandleUserMeshConfig(yaml string) {
 }
 
 // merged returns the merged user and revision config.
-func (w *InternalWatcher) merged() *meshconfig.MeshConfig {
+func (w *internalWatcher) merged() *meshconfig.MeshConfig {
 	mc := DefaultMeshConfig()
 	if w.userMeshConfig != "" {
 		mc1, err := ApplyMeshConfig(w.userMeshConfig, mc)
@@ -168,14 +174,14 @@ func (w *InternalWatcher) merged() *meshconfig.MeshConfig {
 
 // HandleMeshConfig calls all handlers for a given mesh configuration update. This must be called
 // with a lock on w.Mutex, or updates may be applied out of order.
-func (w *InternalWatcher) HandleMeshConfig(meshConfig *meshconfig.MeshConfig) {
+func (w *internalWatcher) HandleMeshConfig(meshConfig *meshconfig.MeshConfig) {
 	w.mutex.Lock()
 	defer w.mutex.Unlock()
 	w.handleMeshConfigInternal(meshConfig)
 }
 
 // handleMeshConfigInternal behaves the same as HandleMeshConfig but must be called under a lock
-func (w *InternalWatcher) handleMeshConfigInternal(meshConfig *meshconfig.MeshConfig) {
+func (w *internalWatcher) handleMeshConfigInternal(meshConfig *meshconfig.MeshConfig) {
 	var handlers []func()
 
 	if !reflect.DeepEqual(meshConfig, w.MeshConfig) {
diff --git a/pkg/config/mesh/watcher_test_utils.go b/pkg/config/mesh/watcher_test_utils.go
index afa292a8d2..942e392643 100644
--- a/pkg/config/mesh/watcher_test_utils.go
+++ b/pkg/config/mesh/watcher_test_utils.go
@@ -23,13 +23,13 @@
 
 // only used for testing, exposes a blocking Update method that allows test environments to trigger meshConfig updates
 type TestWatcher struct {
-	InternalWatcher
+	internalWatcher
 	doneCh chan struct{} // used to implement a blocking Update method
 }
 
 func NewTestWatcher(meshConfig *meshconfig.MeshConfig) *TestWatcher {
 	w := &TestWatcher{
-		InternalWatcher: InternalWatcher{MeshConfig: meshConfig},
+		internalWatcher: internalWatcher{MeshConfig: meshConfig},
 	}
 	w.doneCh = make(chan struct{}, 1)
 	w.AddMeshHandler(func() {
diff --git a/pkg/kube/configmapwatcher/configmapwatcher.go b/pkg/kube/configmapwatcher/configmapwatcher.go
index c5a397388e..6b5dfe85f8 100644
--- a/pkg/kube/configmapwatcher/configmapwatcher.go
+++ b/pkg/kube/configmapwatcher/configmapwatcher.go
@@ -59,7 +59,7 @@ func NewController(client kube.Client, namespace, name string, callback func(*v1
 	c.informer = informers.NewSharedInformerFactoryWithOptions(client.Kube(), 12*time.Hour,
 		informers.WithNamespace(namespace),
 		informers.WithTweakListOptions(func(listOptions *metav1.ListOptions) {
-			listOptions.FieldSelector = fields.OneTermEqualSelector("metadata.name", name).String()
+			listOptions.FieldSelector = fields.OneTermEqualSelector(metav1.ObjectNameField, name).String()
 		})).
 		Core().V1().ConfigMaps()
 
diff --git a/pkg/kube/configmapwatcher/configmapwatcher_test.go b/pkg/kube/configmapwatcher/configmapwatcher_test.go
index 22c0343427..d74474163e 100644
--- a/pkg/kube/configmapwatcher/configmapwatcher_test.go
+++ b/pkg/kube/configmapwatcher/configmapwatcher_test.go
@@ -27,7 +27,6 @@
 	"k8s.io/client-go/tools/cache"
 
 	"istio.io/istio/pkg/kube"
-	"istio.io/pkg/log"
 )
 
 const (
@@ -104,7 +103,6 @@ func Test_ConfigMapWatcher(t *testing.T) {
 	cache.WaitForCacheSync(stop, c.HasSynced)
 
 	cms := client.Kube().CoreV1().ConfigMaps(configMapNamespace)
-	log.FindScope("controllers").SetOutputLevel(log.DebugLevel)
 	for i, step := range steps {
 		resetCalled()
 
-- 
2.35.3

