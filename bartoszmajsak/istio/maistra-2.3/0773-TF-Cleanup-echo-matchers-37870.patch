From 185d5259799a78190a87b92a12857092036b2bbe Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 10 Mar 2022 15:44:02 -0800
Subject: [TF] Cleanup echo matchers (#37870)

- Moves matchers to the `match` package, which aids in readability from the call sites.

- Moved match methods out of `echo.Instances` to avoid circular dependency.

- Added a few more options for `Filter`s and `Matcher`s that will be used in subsequent PRs.
---
 pkg/test/framework/components/echo/config.go  |   9 ++
 .../components/echo/echotest/echotest.go      |   4 +-
 .../components/echo/echotest/filters.go       | 100 +++++++++-------
 .../components/echo/echotest/filters_test.go  |   7 +-
 .../framework/components/echo/instances.go    |  50 ++------
 .../components/echo/match/matcher.go          |  66 +++++++++++
 .../components/echo/{ => match}/matchers.go   | 110 ++++++++++++------
 pkg/test/framework/components/echo/matcher.go |  18 ---
 tests/integration/pilot/common/apps.go        |  23 ++--
 tests/integration/pilot/common/routing.go     | 105 ++++++++---------
 tests/integration/pilot/common/traffic.go     |  15 ++-
 .../pilot/mcs/autoexport/autoexport_test.go   |   4 +-
 .../discoverability/discoverability_test.go   |   9 +-
 .../pilot/revisions/revisions_test.go         |   3 +-
 tests/integration/pilot/vm_test.go            |   3 +-
 .../security/authorization_test.go            | 105 ++++++++---------
 .../security/ca_custom_root/main_test.go      |  17 +--
 .../ca_custom_root/multi_root_test.go         |   3 +-
 .../ca_custom_root/secure_naming_test.go      |   7 +-
 .../trust_domain_alias_secure_naming_test.go  |   3 +-
 .../trust_domain_validation_test.go           |   7 +-
 .../ecc_signature_algorithm/main_test.go      |   5 +-
 .../egress_gateway_origination_test.go        |   9 +-
 .../security/external_ca/main_test.go         |   5 +-
 .../security/external_ca/reachability_test.go |   5 +-
 .../security/https_jwt/https_jwt_test.go      |   6 +-
 tests/integration/security/jwt_test.go        |  13 ++-
 .../mtls_first_party_jwt/strict_test.go       |   3 +-
 .../security/mtlsk8sca/strict_test.go         |   3 +-
 .../pass_through_filter_chain_test.go         |  36 +++---
 .../integration/security/reachability_test.go |   3 +-
 tests/integration/security/util/framework.go  | 101 +++++++++-------
 .../security/util/reachability/context.go     |   9 +-
 .../telemetry/stackdriver/common.go           |   5 +-
 .../customize_metrics_test.go                 |   5 +-
 .../telemetry/stats/prometheus/stats.go       |  11 +-
 .../prometheus/wasm/bad_wasm_filter_test.go   |   6 +-
 .../integration/telemetry/tracing/tracing.go  |   5 +-
 38 files changed, 504 insertions(+), 394 deletions(-)
 create mode 100644 pkg/test/framework/components/echo/match/matcher.go
 rename pkg/test/framework/components/echo/{ => match}/matchers.go (52%)
 delete mode 100644 pkg/test/framework/components/echo/matcher.go

diff --git a/pkg/test/framework/components/echo/config.go b/pkg/test/framework/components/echo/config.go
index e060abcbee..886c3f4b8b 100644
--- a/pkg/test/framework/components/echo/config.go
+++ b/pkg/test/framework/components/echo/config.go
@@ -23,6 +23,7 @@
 	"github.com/mitchellh/copystructure"
 	"gopkg.in/yaml.v3"
 
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/echo/common"
@@ -140,6 +141,14 @@ type Config struct {
 	IncludeExtAuthz bool
 }
 
+// NamespacedName returns the namespaced name for the service.
+func (c Config) NamespacedName() model.NamespacedName {
+	return model.NamespacedName{
+		Name:      c.Service,
+		Namespace: c.Namespace.Name(),
+	}
+}
+
 // SubsetConfig is the config for a group of Subsets (e.g. Kubernetes deployment).
 type SubsetConfig struct {
 	// The version of the deployment.
diff --git a/pkg/test/framework/components/echo/echotest/echotest.go b/pkg/test/framework/components/echo/echotest/echotest.go
index 77f412c6a8..a54a84845f 100644
--- a/pkg/test/framework/components/echo/echotest/echotest.go
+++ b/pkg/test/framework/components/echo/echotest/echotest.go
@@ -17,6 +17,7 @@
 import (
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 )
 
 // T enumerates subtests given a set of workloads as echo.Instances.
@@ -41,8 +42,7 @@ func New(ctx framework.TestContext, instances echo.Instances) *T {
 	copy(d, instances)
 	t := &T{rootCtx: ctx, sources: s, destinations: d}
 	if ctx.Settings().Skip(echo.VM) {
-		noVM := Not(FilterMatch(echo.IsVirtualMachine()))
-		t = t.From(noVM).To(noVM)
+		t = t.FromMatch(match.IsNotVM).ToMatch(match.IsNotVM)
 	}
 	return t
 }
diff --git a/pkg/test/framework/components/echo/echotest/filters.go b/pkg/test/framework/components/echo/echotest/filters.go
index 4db3a27608..1bf68425d9 100644
--- a/pkg/test/framework/components/echo/echotest/filters.go
+++ b/pkg/test/framework/components/echo/echotest/filters.go
@@ -14,7 +14,10 @@
 
 package echotest
 
-import "istio.io/istio/pkg/test/framework/components/echo"
+import (
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
+)
 
 type (
 	Filter            func(echo.Instances) echo.Instances
@@ -33,6 +36,10 @@ func (t *T) From(filters ...Filter) *T {
 	return t
 }
 
+func (t *T) FromMatch(m match.Matcher) *T {
+	return t.From(FilterMatch(m))
+}
+
 // To applies each of the filter functions in order to allow removing workloads from the set of destinations.
 // Example:
 //     echotest.New(t, apps).
@@ -45,6 +52,10 @@ func (t *T) To(filters ...Filter) *T {
 	return t
 }
 
+func (t *T) ToMatch(m match.Matcher) *T {
+	return t.To(FilterMatch(m))
+}
+
 // ConditionallyTo appends the given filters which are executed per test. Destination filters may need
 // to change behavior based on the client. For example, naked services can't be reached cross-network, so
 // the client matters.
@@ -65,7 +76,7 @@ func (t *T) ConditionallyTo(filters ...CombinationFilter) *T {
 //   Pod a will not be in destinations, but b will (one simpe pod not in sources)
 func (t *T) WithDefaultFilters() *T {
 	return t.
-		From(SingleSimplePodServiceAndAllSpecial(), Not(ExternalServices)).
+		From(SingleSimplePodServiceAndAllSpecial(), FilterMatch(match.IsNotExternal)).
 		ConditionallyTo(ReachableDestinations).
 		To(SingleSimplePodServiceAndAllSpecial(t.sources...))
 }
@@ -92,15 +103,15 @@ func SingleSimplePodServiceAndAllSpecial(exclude ...echo.Instance) Filter {
 }
 
 func oneRegularPod(instances echo.Instances, exclude echo.Instances) echo.Instances {
-	regularPods := instances.Match(RegularPod)
-	others := instances.Match(echo.Not(RegularPod))
+	regularPods := RegularPod.GetMatches(instances)
+	others := NotRegularPod.GetMatches(instances)
 	for _, exclude := range exclude {
-		regularPods = regularPods.Match(echo.Not(echo.SameDeployment(exclude)))
+		regularPods = match.Not(match.SameDeployment(exclude)).GetMatches(regularPods)
 	}
 	if len(regularPods) == 0 {
 		return others
 	}
-	regularPods = regularPods.Match(echo.SameDeployment(regularPods[0]))
+	regularPods = match.SameDeployment(regularPods[0]).GetMatches(regularPods)
 	// TODO will the re-ordering end up breaking something or making other filters hard to predict?
 	return append(regularPods, others...)
 }
@@ -111,89 +122,90 @@ func oneRegularPod(instances echo.Instances, exclude echo.Instances) echo.Instan
 // - Headless
 // - TProxy
 // - Multi-Subset
-func RegularPod(instance echo.Instance) bool {
+var RegularPod match.Matcher = func(instance echo.Instance) bool {
 	c := instance.Config()
 	return len(c.Subsets) == 1 && !c.IsVM() && !c.IsTProxy() && !c.IsNaked() && !c.IsHeadless() && !c.IsStatefulSet() && !c.IsProxylessGRPC()
 }
 
+var NotRegularPod = match.Not(RegularPod)
+
 // Not includes all workloads that don't match the given filter
 func Not(filter Filter) Filter {
 	return func(instances echo.Instances) echo.Instances {
 		filtered := filter(instances)
-		inverted := instances.Match(func(instance echo.Instance) bool {
+
+		return match.Matcher(func(instance echo.Instance) bool {
 			return !filtered.Contains(instance)
-		})
-		return inverted
+		}).GetMatches(instances)
 	}
 }
 
 // FilterMatch returns a filter that simply applies the given matcher.
-func FilterMatch(matcher echo.Matcher) Filter {
+func FilterMatch(matcher match.Matcher) Filter {
 	return func(instances echo.Instances) echo.Instances {
-		return instances.Match(matcher)
+		return matcher.GetMatches(instances)
 	}
 }
 
-// VirtualMachines includes VM deployments
-func VirtualMachines(instances echo.Instances) echo.Instances {
-	return instances.Match(echo.IsVirtualMachine())
-}
-
-// ExternalServices includes services that are based on naked pods with a custom DefaultHostHeader
-func ExternalServices(instances echo.Instances) echo.Instances {
-	return instances.Match(echo.IsExternal())
-}
-
 // ReachableDestinations filters out known-unreachable destinations given a source.
 // - from a naked pod, we can't reach cross-network endpoints or VMs
 // - we can't reach cross-cluster headless endpoints
 // - from an injected Pod, only non-naked cross-network endpoints are reachable
 var ReachableDestinations CombinationFilter = func(from echo.Instance, to echo.Instances) echo.Instances {
-	return to.Match(fromNaked(from).
-		And(reachableFromVM(from)).
-		And(reachableFromProxylessGRPC(from)).
-		And(reachableNakedDestinations(from)).
-		And(reachableHeadlessDestinations(from)))
+	return match.And(
+		fromNaked(from),
+		reachableFromVM(from),
+		reachableFromProxylessGRPC(from),
+		reachableNakedDestinations(from),
+		reachableHeadlessDestinations(from)).
+		GetMatches(to)
 }
 
 // reachableHeadlessDestinations filters out headless services that aren't in the same cluster
 // TODO https://github.com/istio/istio/issues/27342
-func reachableHeadlessDestinations(from echo.Instance) echo.Matcher {
-	excluded := echo.IsHeadless().And(echo.Not(echo.InNetwork(from.Config().Cluster.NetworkName())))
-	return echo.Not(excluded)
+func reachableHeadlessDestinations(from echo.Instance) match.Matcher {
+	excluded := match.And(
+		match.IsHeadless,
+		match.Not(match.InNetwork(from.Config().Cluster.NetworkName())))
+	return match.Not(excluded)
 }
 
 // reachableNakedDestinations filters out naked instances that aren't on the same network.
 // While External services are considered "naked", we won't see 500s due to different loadbalancing.
-func reachableNakedDestinations(from echo.Instance) echo.Matcher {
+func reachableNakedDestinations(from echo.Instance) match.Matcher {
 	srcNw := from.Config().Cluster.NetworkName()
-	excluded := echo.IsNaked().
+	excluded := match.And(
+		match.IsNaked,
 		// TODO we probably don't actually reach all external, but for now maintaining what the tests did
-		And(echo.Not(echo.IsExternal())).
-		And(echo.Not(echo.InNetwork(srcNw)))
-	return echo.Not(excluded)
+		match.IsNotExternal,
+		match.Not(match.InNetwork(srcNw)))
+	return match.Not(excluded)
 }
 
 // reachableFromVM filters out external services due to issues with ServiceEntry resolution
 // TODO https://github.com/istio/istio/issues/27154
-func reachableFromVM(from echo.Instance) echo.Matcher {
+func reachableFromVM(from echo.Instance) match.Matcher {
 	if !from.Config().IsVM() {
-		return echo.Any
+		return match.Any
 	}
-	return echo.Not(echo.IsExternal())
+	return match.IsNotExternal
 }
 
-func reachableFromProxylessGRPC(from echo.Instance) echo.Matcher {
+func reachableFromProxylessGRPC(from echo.Instance) match.Matcher {
 	if !from.Config().IsProxylessGRPC() {
-		return echo.Any
+		return match.Any
 	}
-	return echo.Not(echo.IsExternal()).And(echo.Not(echo.IsHeadless()))
+	return match.And(
+		match.IsNotExternal,
+		match.IsNotHeadless)
 }
 
 // fromNaked filters out all virtual machines and any instance that isn't on the same network
-func fromNaked(from echo.Instance) echo.Matcher {
+func fromNaked(from echo.Instance) match.Matcher {
 	if !from.Config().IsNaked() {
-		return echo.Any
+		return match.Any
 	}
-	return echo.InNetwork(from.Config().Cluster.NetworkName()).And(echo.Not(echo.IsVirtualMachine()))
+	return match.And(
+		match.InNetwork(from.Config().Cluster.NetworkName()),
+		match.IsNotVM)
 }
diff --git a/pkg/test/framework/components/echo/echotest/filters_test.go b/pkg/test/framework/components/echo/echotest/filters_test.go
index b286c29b1e..690d5c8f19 100644
--- a/pkg/test/framework/components/echo/echotest/filters_test.go
+++ b/pkg/test/framework/components/echo/echotest/filters_test.go
@@ -27,6 +27,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 )
@@ -268,12 +269,10 @@ func TestRun(t *testing.T) {
 			},
 			"RunToN": {
 				run: func(t framework.TestContext, testTopology map[string]map[string]int) {
-					noNaked := Not(FilterMatch(echo.IsNaked()))
-					noHeadless := Not(FilterMatch(echo.IsHeadless()))
 					New(t, all).
 						WithDefaultFilters().
-						From(noNaked, noHeadless).
-						To(noHeadless).
+						FromMatch(match.And(match.IsNotNaked, match.IsNotHeadless)).
+						ToMatch(match.IsNotHeadless).
 						RunToN(3, func(ctx framework.TestContext, from echo.Instance, dsts echo.Services) {
 							srcKey := from.Config().ClusterLocalFQDN()
 							if testTopology[srcKey] == nil {
diff --git a/pkg/test/framework/components/echo/instances.go b/pkg/test/framework/components/echo/instances.go
index 17755ebd8b..ac7fa1a63b 100644
--- a/pkg/test/framework/components/echo/instances.go
+++ b/pkg/test/framework/components/echo/instances.go
@@ -103,52 +103,24 @@ func (i Instances) IsDeployment() bool {
 	return len(i.Services()) == 1
 }
 
-// Match filters instances that matcher the given Matcher
-func (i Instances) Match(matches Matcher) Instances {
-	out := make(Instances, 0)
-	for _, i := range i {
-		if matches(i) {
-			out = append(out, i)
-		}
-	}
-	return out
-}
-
-// Get finds the first Instance that matches the Matcher.
-func (i Instances) Get(matches Matcher) (Instance, error) {
-	res := i.Match(matches)
-	if len(res) == 0 {
-		return nil, errors.New("found 0 matching echo instances")
-	}
-	return res[0], nil
-}
-
-func (i Instances) GetOrFail(t test.Failer, matches Matcher) Instance {
-	res, err := i.Get(matches)
-	if err != nil {
-		t.Fatal(err)
-	}
-	return res
-}
-
 func (i Instances) ContainsTarget(t Target) bool {
 	return i.Contains(t.Instances()...)
 }
 
 func (i Instances) Contains(instances ...Instance) bool {
-	matches := i.Match(func(instance Instance) bool {
-		for _, ii := range instances {
-			if ii == instance {
-				return true
+	for _, thatI := range instances {
+		found := false
+		for _, thisI := range i {
+			if thisI == thatI {
+				found = true
+				break
 			}
 		}
-		return false
-	})
-	return len(matches) > 0
-}
-
-func (i Instances) ContainsMatch(matches Matcher) bool {
-	return len(i.Match(matches)) > 0
+		if !found {
+			return false
+		}
+	}
+	return true
 }
 
 // Services groups the Instances by FQDN. Each returned element is an Instances
diff --git a/pkg/test/framework/components/echo/match/matcher.go b/pkg/test/framework/components/echo/match/matcher.go
new file mode 100644
index 0000000000..fdbd4a1fbd
--- /dev/null
+++ b/pkg/test/framework/components/echo/match/matcher.go
@@ -0,0 +1,66 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package match
+
+import (
+	"errors"
+
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/framework/components/echo"
+)
+
+// Matcher is used to filter matching instances
+type Matcher func(echo.Instance) bool
+
+// GetMatches returns the subset of echo.Instances that match this Matcher.
+func (m Matcher) GetMatches(i echo.Instances) echo.Instances {
+	out := make(echo.Instances, 0)
+	for _, i := range i {
+		if m(i) {
+			out = append(out, i)
+		}
+	}
+	return out
+}
+
+// First finds the first Instance that matches the Matcher.
+func (m Matcher) First(i echo.Instances) (echo.Instance, error) {
+	for _, i := range i {
+		if m(i) {
+			return i, nil
+		}
+	}
+
+	return nil, errors.New("found 0 matching echo instances")
+}
+
+// FirstOrFail calls First and then fails the test if an error occurs.
+func (m Matcher) FirstOrFail(t test.Failer, i echo.Instances) echo.Instance {
+	res, err := m.First(i)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return res
+}
+
+// Any indicates whether any echo.Instance matches this matcher.
+func (m Matcher) Any(i echo.Instances) bool {
+	for _, i := range i {
+		if m(i) {
+			return true
+		}
+	}
+	return false
+}
diff --git a/pkg/test/framework/components/echo/matchers.go b/pkg/test/framework/components/echo/match/matchers.go
similarity index 52%
rename from pkg/test/framework/components/echo/matchers.go
rename to pkg/test/framework/components/echo/match/matchers.go
index 25e66c954a..cbd29b30d6 100644
--- a/pkg/test/framework/components/echo/matchers.go
+++ b/pkg/test/framework/components/echo/match/matchers.go
@@ -12,115 +12,151 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package echo
+package match
 
 import (
 	"strings"
 
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/test/framework/components/cluster"
+	"istio.io/istio/pkg/test/framework/components/echo"
 )
 
 // Any doesn't filter out any echos.
-var Any Matcher = func(_ Instance) bool {
+var Any Matcher = func(_ echo.Instance) bool {
 	return true
 }
 
-// And combines two or more matches. Example:
-//     Service("a").And(InCluster(c)).And(Match(func(...))
-func (m Matcher) And(other Matcher) Matcher {
-	return func(i Instance) bool {
-		return m(i) && other(i)
+// And is an aggregate Matcher that requires all matches return true.
+func And(ms ...Matcher) Matcher {
+	return func(i echo.Instance) bool {
+		for _, m := range ms {
+			if !m(i) {
+				return false
+			}
+		}
+		return true
+	}
+}
+
+// Or is an aggregate Matcher that requires at least one matches return true.
+func Or(ms ...Matcher) Matcher {
+	return func(i echo.Instance) bool {
+		for _, m := range ms {
+			if m(i) {
+				return true
+			}
+		}
+		return false
 	}
 }
 
 // Not negates the given matcher. Example:
 //     Not(IsNaked())
 func Not(m Matcher) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return !m(i)
 	}
 }
 
 // ServicePrefix matches instances whose service name starts with the given prefix.
 func ServicePrefix(prefix string) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return strings.HasPrefix(i.Config().Service, prefix)
 	}
 }
 
+// NamespacedName matches instances with the given namespace and service name.
+func NamespacedName(n model.NamespacedName) Matcher {
+	return func(i echo.Instance) bool {
+		return n == i.Config().NamespacedName()
+	}
+}
+
 // Service matches instances with have the given service name.
 func Service(value string) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return value == i.Config().Service
 	}
 }
 
 // FQDN matches instances with have the given fully qualified domain name.
 func FQDN(value string) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return value == i.Config().ClusterLocalFQDN()
 	}
 }
 
 // SameDeployment matches instnaces with the same FQDN and assumes they're part of the same Service and Namespace.
-func SameDeployment(match Instance) Matcher {
-	return func(instance Instance) bool {
+func SameDeployment(match echo.Instance) Matcher {
+	return func(instance echo.Instance) bool {
 		return match.Config().ClusterLocalFQDN() == instance.Config().ClusterLocalFQDN()
 	}
 }
 
 // Namespace matches instances within the given namespace name.
 func Namespace(namespace string) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return i.Config().Namespace.Name() == namespace
 	}
 }
 
 // InCluster matches instances deployed on the given cluster.
 func InCluster(c cluster.Cluster) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return c.Name() == i.Config().Cluster.Name()
 	}
 }
 
 // InNetwork matches instances deployed in the given network.
 func InNetwork(n string) Matcher {
-	return func(i Instance) bool {
+	return func(i echo.Instance) bool {
 		return i.Config().Cluster.NetworkName() == n
 	}
 }
 
-// IsVirtualMachine matches instances with DeployAsVM
-func IsVirtualMachine() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsVM()
-	}
+// IsVM matches instances with DeployAsVM
+var IsVM Matcher = func(i echo.Instance) bool {
+	return i.Config().IsVM()
 }
 
+// IsNotVM is matches against instances that are NOT VMs.
+var IsNotVM = Not(IsVM)
+
 // IsExternal matches instances that have a custom DefaultHostHeader defined
-func IsExternal() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsExternal()
-	}
+var IsExternal Matcher = func(i echo.Instance) bool {
+	return i.Config().IsExternal()
 }
 
+// IsNotExternal is equivalent to Not(IsExternal)
+var IsNotExternal = Not(IsExternal)
+
 // IsNaked matches instances that are Pods with a SidecarInject annotation equal to false.
-func IsNaked() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsNaked()
-	}
+var IsNaked Matcher = func(i echo.Instance) bool {
+	return i.Config().IsNaked()
 }
 
+// IsNotNaked is equivalent to Not(IsNaked)
+var IsNotNaked = Not(IsNaked)
+
 // IsHeadless matches instances that are backed by headless services.
-func IsHeadless() Matcher {
-	return func(i Instance) bool {
-		return i.Config().Headless
-	}
+var IsHeadless Matcher = func(i echo.Instance) bool {
+	return i.Config().Headless
 }
 
+// IsNotHeadless is equivalent to Not(IsHeadless)
+var IsNotHeadless = Not(IsHeadless)
+
 // IsProxylessGRPC matches instances that are Pods with a SidecarInjectTemplate annotation equal to grpc.
-func IsProxylessGRPC() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsProxylessGRPC()
-	}
+var IsProxylessGRPC Matcher = func(i echo.Instance) bool {
+	return i.Config().IsProxylessGRPC()
 }
+
+// IsNotProxylessGRPC is equivalent to Not(IsProxylessGRPC)
+var IsNotProxylessGRPC = Not(IsProxylessGRPC)
+
+var IsTProxy Matcher = func(i echo.Instance) bool {
+	return i.Config().IsTProxy()
+}
+
+var IsNotTProxy = Not(IsTProxy)
diff --git a/pkg/test/framework/components/echo/matcher.go b/pkg/test/framework/components/echo/matcher.go
deleted file mode 100644
index f3f09b340b..0000000000
--- a/pkg/test/framework/components/echo/matcher.go
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package echo
-
-// Matcher is used to filter matching instances
-type Matcher func(Instance) bool
diff --git a/tests/integration/pilot/common/apps.go b/tests/integration/pilot/common/apps.go
index 13ce5676e7..32dc09dcc7 100644
--- a/tests/integration/pilot/common/apps.go
+++ b/tests/integration/pilot/common/apps.go
@@ -27,6 +27,7 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -246,20 +247,20 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 		return err
 	}
 	apps.All = echos
-	apps.PodA = echos.Match(echo.Service(PodASvc))
-	apps.PodB = echos.Match(echo.Service(PodBSvc))
-	apps.PodC = echos.Match(echo.Service(PodCSvc))
-	apps.PodTproxy = echos.Match(echo.Service(PodTproxySvc))
-	apps.Headless = echos.Match(echo.Service(HeadlessSvc))
-	apps.StatefulSet = echos.Match(echo.Service(StatefulSetSvc))
-	apps.Naked = echos.Match(echo.Service(NakedSvc))
-	apps.External = echos.Match(echo.Service(ExternalSvc))
-	apps.ProxylessGRPC = echos.Match(echo.Service(ProxylessGRPCSvc))
+	apps.PodA = match.Service(PodASvc).GetMatches(echos)
+	apps.PodB = match.Service(PodBSvc).GetMatches(echos)
+	apps.PodC = match.Service(PodCSvc).GetMatches(echos)
+	apps.PodTproxy = match.Service(PodTproxySvc).GetMatches(echos)
+	apps.Headless = match.Service(HeadlessSvc).GetMatches(echos)
+	apps.StatefulSet = match.Service(StatefulSetSvc).GetMatches(echos)
+	apps.Naked = match.Service(NakedSvc).GetMatches(echos)
+	apps.External = match.Service(ExternalSvc).GetMatches(echos)
+	apps.ProxylessGRPC = match.Service(ProxylessGRPCSvc).GetMatches(echos)
 	if !t.Settings().Skip(echo.VM) {
-		apps.VM = echos.Match(echo.Service(VMSvc))
+		apps.VM = match.Service(VMSvc).GetMatches(echos)
 	}
 	if !skipDelta {
-		apps.DeltaXDS = echos.Match(echo.Service(DeltaSvc))
+		apps.DeltaXDS = match.Service(DeltaSvc).GetMatches(echos)
 	}
 
 	if err := t.ConfigIstio().YAML(`
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index f4bda7b990..092414a6fd 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -43,6 +43,7 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/tmpl"
@@ -129,9 +130,6 @@ func httpGateway(host string) string {
 }
 
 func virtualServiceCases(skipVM bool) []TrafficTestCase {
-	noTProxy := echotest.FilterMatch(func(instance echo.Instance) bool {
-		return !instance.Config().IsTProxy()
-	})
 	var cases []TrafficTestCase
 	cases = append(cases,
 		TrafficTestCase{
@@ -510,7 +508,8 @@ func(r echoClient.Response) error {
 		TrafficTestCase{
 			name: "cors",
 			// TODO https://github.com/istio/istio/issues/31532
-			targetFilters: []echotest.Filter{noTProxy, echotest.Not(echotest.VirtualMachines)},
+			targetMatchers: []match.Matcher{match.IsNotTProxy, match.IsNotVM},
+
 			config: `
 apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
@@ -656,13 +655,10 @@ func(r echoClient.Response) error {
 	)
 
 	// reduce the total # of subtests that don't give valuable coverage or just don't work
-	noNaked := echotest.FilterMatch(echo.Not(echo.IsNaked()))
-	noHeadless := echotest.FilterMatch(echo.Not(echo.IsHeadless()))
-	noExternal := echotest.FilterMatch(echo.Not(echo.IsExternal()))
 	for i, tc := range cases {
 		// TODO include proxyless as different features become supported
-		tc.sourceFilters = append(tc.sourceFilters, noNaked, noHeadless, noProxyless)
-		tc.targetFilters = append(tc.targetFilters, noNaked, noHeadless, noProxyless)
+		tc.sourceMatchers = append(tc.sourceMatchers, match.IsNotNaked, match.IsNotHeadless, match.IsNotProxylessGRPC)
+		tc.targetMatchers = append(tc.targetMatchers, match.IsNotNaked, match.IsNotHeadless, match.IsNotProxylessGRPC)
 		cases[i] = tc
 	}
 
@@ -679,10 +675,10 @@ func(r echoClient.Response) error {
 	for _, split := range splits {
 		split := split
 		cases = append(cases, TrafficTestCase{
-			name:          fmt.Sprintf("shifting-%d", split[0]),
-			toN:           len(split),
-			sourceFilters: []echotest.Filter{noHeadless, noNaked},
-			targetFilters: []echotest.Filter{noHeadless, noExternal},
+			name:           fmt.Sprintf("shifting-%d", split[0]),
+			toN:            len(split),
+			sourceMatchers: []match.Matcher{match.IsNotHeadless, match.IsNotNaked},
+			targetMatchers: []match.Matcher{match.IsNotHeadless, match.IsNotExternal},
 			templateVars: func(_ echo.Callers, _ echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
 					"split": split,
@@ -726,10 +722,10 @@ func(responses echoClient.Responses, err error) error {
 								return fmt.Errorf("expected %v calls to %q, got %v", exp, hostName, len(hostResponses))
 							}
 							// echotest should have filtered the deployment to only contain reachable clusters
-							to := dests.Instances().Match(echo.Service(hostName))
+							to := match.Service(hostName).GetMatches(dests.Instances())
 							toClusters := to.Clusters()
 							// don't check headless since lb is unpredictable
-							headlessTarget := to.ContainsMatch(echo.IsHeadless())
+							headlessTarget := match.IsHeadless.Any(to)
 							if !headlessTarget && len(toClusters.ByNetwork()[src.(echo.Instance).Config().Cluster.NetworkName()]) > 1 {
 								// Conditionally check reached clusters to work around connection load balancing issues
 								// See https://github.com/istio/istio/issues/32208 for details
@@ -1033,12 +1029,12 @@ func gatewayCases() []TrafficTestCase {
 	}
 
 	// SingleRegualrPod is already applied leaving one regular pod, to only regular pods should leave a single workload.
-	singleTarget := []echotest.Filter{echotest.FilterMatch(echotest.RegularPod)}
+	singleTarget := []match.Matcher{echotest.RegularPod}
 	// the following cases don't actually target workloads, we use the singleTarget filter to avoid duplicate cases
 	cases := []TrafficTestCase{
 		{
 			name:             "404",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           httpGateway("*"),
@@ -1056,7 +1052,7 @@ func gatewayCases() []TrafficTestCase {
 		},
 		{
 			name:             "https redirect",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1089,7 +1085,7 @@ func gatewayCases() []TrafficTestCase {
 		{
 			// See https://github.com/istio/istio/issues/27315
 			name:             "https with x-forwarded-proto",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1178,7 +1174,7 @@ func gatewayCases() []TrafficTestCase {
 		{
 			// See https://github.com/istio/istio/issues/34609
 			name:             "http redirect when vs port specify https",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1220,7 +1216,7 @@ func gatewayCases() []TrafficTestCase {
 			// See https://github.com/istio/istio/issues/27315
 			// See https://github.com/istio/istio/issues/34609
 			name:             "http return 400 with with x-forwarded-proto https when vs port specify https",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1290,7 +1286,7 @@ func gatewayCases() []TrafficTestCase {
 		{
 			// https://github.com/istio/istio/issues/37196
 			name:             "client protocol - http1",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1331,7 +1327,7 @@ func gatewayCases() []TrafficTestCase {
 		{
 			// https://github.com/istio/istio/issues/37196
 			name:             "client protocol - http2",
-			targetFilters:    singleTarget,
+			targetMatchers:   singleTarget,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config: `apiVersion: networking.istio.io/v1alpha3
@@ -1390,7 +1386,7 @@ func gatewayCases() []TrafficTestCase {
 				TrafficTestCase{
 					// https://github.com/istio/istio/issues/37196
 					name:             fmt.Sprintf("client protocol - %v use client with %v", protoName, port),
-					targetFilters:    singleTarget,
+					targetMatchers:   singleTarget,
 					workloadAgnostic: true,
 					viaIngress:       true,
 					config: `apiVersion: networking.istio.io/v1alpha3
@@ -1479,7 +1475,7 @@ func gatewayCases() []TrafficTestCase {
 						check.RequestHeader("Istio-Custom-Header", "user-defined-value")),
 				},
 				// to keep tests fast, we only run the basic protocol test per-workload and scheme match once (per cluster)
-				targetFilters:    singleTarget,
+				targetMatchers:   singleTarget,
 				viaIngress:       true,
 				workloadAgnostic: true,
 			},
@@ -2098,14 +2094,14 @@ func selfCallsCases() []TrafficTestCase {
 	}
 	for i, tc := range cases {
 		// proxyless doesn't get valuable coverage here
-		tc.sourceFilters = []echotest.Filter{
-			echotest.Not(echotest.ExternalServices),
-			echotest.Not(echotest.FilterMatch(echo.IsNaked())),
-			echotest.Not(echotest.FilterMatch(echo.IsHeadless())),
-			noProxyless,
+		tc.sourceMatchers = []match.Matcher{
+			match.IsNotExternal,
+			match.IsNotNaked,
+			match.IsNotHeadless,
+			match.IsNotProxylessGRPC,
 		}
 		tc.comboFilters = []echotest.CombinationFilter{func(from echo.Instance, to echo.Instances) echo.Instances {
-			return to.Match(echo.FQDN(from.Config().ClusterLocalFQDN()))
+			return match.FQDN(from.Config().ClusterLocalFQDN()).GetMatches(to)
 		}}
 		cases[i] = tc
 	}
@@ -2162,7 +2158,7 @@ type protocolCase struct {
 			comboFilters: func() []echotest.CombinationFilter {
 				if call.scheme != scheme.GRPC {
 					return []echotest.CombinationFilter{func(from echo.Instance, to echo.Instances) echo.Instances {
-						if from.Config().IsProxylessGRPC() && to.ContainsMatch(echo.IsVirtualMachine()) {
+						if from.Config().IsProxylessGRPC() && match.IsVM.Any(to) {
 							return nil
 						}
 						return to
@@ -2270,7 +2266,7 @@ type protocolCase struct {
 	//comboFilters: func() []echotest.CombinationFilter {
 	//	if call.scheme != scheme.GRPC {
 	//		return []echotest.CombinationFilter{func(from echo.Instance, to echo.Instances) echo.Instances {
-	//			if from.Config().IsProxylessGRPC() && to.ContainsMatch(echo.IsVirtualMachine()) {
+	//			if from.Config().IsProxylessGRPC() && to.ContainsMatch(echo.IsVM()) {
 	//				return nil
 	//			}
 	//			return to
@@ -2422,9 +2418,8 @@ func instanceIPTests(apps *EchoDeployments) []TrafficTestCase {
 
 	for _, tc := range cases {
 		// proxyless doesn't get valuable coverage here
-		noProxyless := echotest.FilterMatch(echo.Not(echo.IsProxylessGRPC()))
-		tc.sourceFilters = append(tc.sourceFilters, noProxyless)
-		tc.targetFilters = append(tc.targetFilters, noProxyless)
+		tc.sourceMatchers = append(tc.sourceMatchers, match.IsNotProxylessGRPC)
+		tc.targetMatchers = append(tc.targetMatchers, match.IsNotProxylessGRPC)
 	}
 
 	return cases
@@ -2571,10 +2566,10 @@ func DNSTestCases(apps *EchoDeployments, cniEnabled bool) []TrafficTestCase {
 	for _, client := range flatten(apps.VM, apps.PodA, apps.PodTproxy) {
 		for _, tt := range svcCases {
 			tt, client := tt, client
-			aInCluster := apps.PodA.Match(echo.InCluster(client.Config().Cluster))
+			aInCluster := match.InCluster(client.Config().Cluster).GetMatches(apps.PodA)
 			if len(aInCluster) == 0 {
 				// The cluster doesn't contain A, but connects to a cluster containing A
-				aInCluster = apps.PodA.Match(echo.InCluster(client.Config().Cluster.Config()))
+				aInCluster = match.InCluster(client.Config().Cluster.Config()).GetMatches(apps.PodA)
 			}
 			address := aInCluster[0].Config().ClusterLocalFQDN() + "?"
 			if tt.protocol != "" {
@@ -2635,13 +2630,13 @@ func VMTestCases(vms echo.Instances, apps *EchoDeployments) []TrafficTestCase {
 			vmCase{
 				name: "dns: VM to k8s headless service",
 				from: vm,
-				to:   apps.Headless.Match(echo.InCluster(vm.Config().Cluster.Config())),
+				to:   match.InCluster(vm.Config().Cluster.Config()).GetMatches(apps.Headless),
 				host: apps.Headless[0].Config().ClusterLocalFQDN(),
 			},
 			vmCase{
 				name: "dns: VM to k8s statefulset service",
 				from: vm,
-				to:   apps.StatefulSet.Match(echo.InCluster(vm.Config().Cluster.Config())),
+				to:   match.InCluster(vm.Config().Cluster.Config()).GetMatches(apps.StatefulSet),
 				host: apps.StatefulSet[0].Config().ClusterLocalFQDN(),
 			},
 			// TODO(https://github.com/istio/istio/issues/32552) re-enable
@@ -2682,7 +2677,7 @@ func VMTestCases(vms echo.Instances, apps *EchoDeployments) []TrafficTestCase {
 	for _, c := range testCases {
 		c := c
 		checker := check.OK()
-		if !c.to.ContainsMatch(echo.IsHeadless()) {
+		if !match.IsHeadless.Any(c.to) {
 			// headless load-balancing can be inconsistent
 			checker = check.And(checker, check.ReachedClusters(c.to.Clusters()))
 		}
@@ -2909,9 +2904,7 @@ func jwtClaimRoute(apps *EchoDeployments) []TrafficTestCase {
     jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
 ---
 `
-	podB := []echotest.Filter{func(instances echo.Instances) echo.Instances {
-		return instances.Match(echo.SameDeployment(apps.PodB[0]))
-	}}
+	podB := []match.Matcher{match.SameDeployment(apps.PodB[0])}
 	headers := map[string][]string{
 		"Host":          {"foo.bar"},
 		"Authorization": {"Bearer " + jwt.TokenIssuer1WithNestedClaims1},
@@ -2932,7 +2925,7 @@ type configData struct {
 	cases := []TrafficTestCase{
 		{
 			name:             "matched with nested claims:200",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -2955,7 +2948,7 @@ type configData struct {
 		},
 		{
 			name:             "matched with single claim:200",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -2978,7 +2971,7 @@ type configData struct {
 		},
 		{
 			name:             "matched multiple claims:200",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3004,7 +2997,7 @@ type configData struct {
 		},
 		{
 			name:             "matched without claim:200",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3027,7 +3020,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched without claim:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3050,7 +3043,7 @@ type configData struct {
 		},
 		{
 			name:             "matched both with and without claims:200",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3074,7 +3067,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched multiple claims:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3100,7 +3093,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched token:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3123,7 +3116,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched with invalid token:401",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3146,7 +3139,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched with no token:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3169,7 +3162,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched with no token but same header:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configAll,
@@ -3193,7 +3186,7 @@ type configData struct {
 		},
 		{
 			name:             "unmatched with no request authentication:404",
-			targetFilters:    podB,
+			targetMatchers:   podB,
 			workloadAgnostic: true,
 			viaIngress:       true,
 			config:           configRoute,
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index be411c4718..30d84a2481 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -26,6 +26,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/label"
@@ -78,10 +79,10 @@ type TrafficTestCase struct {
 	toN int
 	// viaIngress makes the ingress gateway the caller for tests
 	viaIngress bool
-	// sourceFilters allows adding additional filtering for workload agnostic cases to test using fewer clients
-	sourceFilters []echotest.Filter
-	// targetFilters allows adding additional filtering for workload agnostic cases to test using fewer targets
-	targetFilters []echotest.Filter
+	// sourceMatchers allows adding additional filtering for workload agnostic cases to test using fewer clients
+	sourceMatchers []match.Matcher
+	// targetMatchers allows adding additional filtering for workload agnostic cases to test using fewer targets
+	targetMatchers []match.Matcher
 	// comboFilters allows conditionally filtering based on pairs of apps
 	comboFilters []echotest.CombinationFilter
 	// vars given to the config template
@@ -91,8 +92,6 @@ type TrafficTestCase struct {
 	minIstioVersion string
 }
 
-var noProxyless = echotest.Not(echotest.FilterMatch(echo.IsProxylessGRPC()))
-
 func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances, namespace string) {
 	if c.skip.skip {
 		t.Skip(c.skip.reason)
@@ -142,9 +141,9 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 				return t.ConfigIstio().YAML(cfg).Apply("")
 			}).
 			WithDefaultFilters().
-			From(c.sourceFilters...).
+			FromMatch(match.And(c.sourceMatchers...)).
 			// TODO mainly testing proxyless features as a client for now
-			To(append(c.targetFilters, noProxyless)...).
+			ToMatch(match.And(append(c.targetMatchers, match.IsNotProxylessGRPC)...)).
 			ConditionallyTo(c.comboFilters...)
 
 		doTest := func(t framework.TestContext, from echo.Caller, to echo.Services) {
diff --git a/tests/integration/pilot/mcs/autoexport/autoexport_test.go b/tests/integration/pilot/mcs/autoexport/autoexport_test.go
index 27444d8bda..5ba216ea72 100644
--- a/tests/integration/pilot/mcs/autoexport/autoexport_test.go
+++ b/tests/integration/pilot/mcs/autoexport/autoexport_test.go
@@ -28,7 +28,7 @@
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -62,7 +62,7 @@ func TestAutoExport(t *testing.T) {
 			// Verify that ServiceExport is created automatically for services.
 			ctx.NewSubTest("exported").RunParallel(
 				func(ctx framework.TestContext) {
-					for _, cluster := range echos.Match(echo.Service(common.ServiceB)).Clusters() {
+					for _, cluster := range match.Service(common.ServiceB).GetMatches(echos.Instances).Clusters() {
 						cluster := cluster
 						ctx.NewSubTest(cluster.StableName()).RunParallel(func(ctx framework.TestContext) {
 							// Verify that the ServiceExport was created.
diff --git a/tests/integration/pilot/mcs/discoverability/discoverability_test.go b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
index 1d13699451..f2c05948ea 100644
--- a/tests/integration/pilot/mcs/discoverability/discoverability_test.go
+++ b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
@@ -46,6 +46,7 @@
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -147,7 +148,7 @@ func TestServiceExportedInOneCluster(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			t.Skip("https://github.com/istio/istio/issues/34051")
 			// Get all the clusters where service B resides.
-			bClusters := echos.Match(echo.Service(common.ServiceB)).Clusters()
+			bClusters := match.Service(common.ServiceB).GetMatches(echos.Instances).Clusters()
 
 			// Test exporting service B exclusively in each cluster.
 			for _, exportCluster := range bClusters {
@@ -205,8 +206,8 @@ func runForAllClusterCombinations(
 	t.Helper()
 	echotest.New(t, echos.Instances).
 		WithDefaultFilters().
-		From(echotest.FilterMatch(echo.Service(common.ServiceA))).
-		To(echotest.FilterMatch(echo.Service(common.ServiceB))).
+		FromMatch(match.Service(common.ServiceA)).
+		ToMatch(match.Service(common.ServiceB)).
 		Run(fn)
 }
 
@@ -387,7 +388,7 @@ func createAndCleanupServiceExport(t framework.TestContext, service string, expo
 	}
 
 	// Now wait for ServiceImport to be created
-	importClusters := echos.Match(echo.Service(common.ServiceA)).Clusters()
+	importClusters := match.Service(common.ServiceA).GetMatches(echos.Instances).Clusters()
 	if common.IsMCSControllerEnabled(t) {
 		scopes.Framework.Infof("Waiting for the MCS Controller to create ServiceImport in each cluster")
 		for _, c := range importClusters {
diff --git a/tests/integration/pilot/revisions/revisions_test.go b/tests/integration/pilot/revisions/revisions_test.go
index ae638b8cc4..5ad838d22d 100644
--- a/tests/integration/pilot/revisions/revisions_test.go
+++ b/tests/integration/pilot/revisions/revisions_test.go
@@ -27,6 +27,7 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
@@ -105,7 +106,7 @@ func TestMultiRevision(t *testing.T) {
 
 			echotest.New(t, echos).
 				ConditionallyTo(echotest.ReachableDestinations).
-				To(echotest.FilterMatch(echo.Service("server"))).
+				ToMatch(match.Service("server")).
 				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 					retry.UntilSuccessOrFail(t, func() error {
 						resp, err := from.Call(echo.CallOptions{
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 3b5c10d75d..1cd4a0591d 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -36,6 +36,7 @@
 	echocommon "istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
 	"istio.io/istio/pkg/test/framework/components/echo/kube"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
@@ -98,7 +99,7 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 				t.Skip()
 			}
 			scaleDeploymentOrFail(t, "istiod", i.Settings().SystemNamespace, 2)
-			client := apps.PodA.GetOrFail(t, echo.InCluster(t.Clusters().Default()))
+			client := match.InCluster(t.Clusters().Default()).FirstOrFail(t, apps.PodA)
 			// TODO test multi-network (must be shared control plane but on different networks)
 			var autoVM echo.Instance
 			_ = deployment.New(t).
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index d6cf49fbe0..f14cc2122b 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -34,6 +34,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
@@ -54,8 +55,8 @@ func TestAuthorization_mTLS(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.mtls-local").
 		Run(func(t framework.TestContext) {
-			b := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
+			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			for _, to := range []echo.Instances{b, vm} {
 				to := to
 				t.ConfigIstio().EvalFile(map[string]string{
@@ -65,8 +66,8 @@ func TestAuthorization_mTLS(t *testing.T) {
 				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, apps.Namespace1.Name(), resource.Wait)
 				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				for _, cluster := range t.Clusters() {
-					a := apps.A.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace1.Name())))
-					c := apps.C.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace2.Name())))
+					a := match.And(match.InCluster(cluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
+					c := match.And(match.InCluster(cluster), match.Namespace(apps.Namespace2.Name())).GetMatches(apps.C)
 					if len(a) == 0 || len(c) == 0 {
 						continue
 					}
@@ -120,9 +121,9 @@ func TestAuthorization_JWT(t *testing.T) {
 		Features("security.authorization.jwt-token").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			b := apps.B.Match(echo.Namespace(ns.Name()))
-			c := apps.C.Match(echo.Namespace(ns.Name()))
-			vm := apps.VM.Match(echo.Namespace(ns.Name()))
+			b := match.Namespace(ns.Name()).GetMatches(apps.B)
+			c := match.Namespace(ns.Name()).GetMatches(apps.C)
+			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
 			for _, dst := range []echo.Instances{b, vm} {
 				args := map[string]string{
 					"Namespace":  apps.Namespace1.Name(),
@@ -131,7 +132,7 @@ func TestAuthorization_JWT(t *testing.T) {
 				}
 				t.ConfigIstio().EvalFile(args, "testdata/authz/v1beta1-jwt.yaml.tmpl").ApplyOrFail(t, ns.Name(), resource.Wait)
 				for _, srcCluster := range t.Clusters() {
-					a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
+					a := match.And(match.InCluster(srcCluster), match.Namespace(ns.Name())).GetMatches(apps.A)
 					if len(a) == 0 {
 						continue
 					}
@@ -219,10 +220,10 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authorization.workload-selector").
 		Run(func(t framework.TestContext) {
-			bInNS1 := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
-			vmInNS1 := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
-			cInNS1 := apps.C.Match(echo.Namespace(apps.Namespace1.Name()))
-			cInNS2 := apps.C.Match(echo.Namespace(apps.Namespace2.Name()))
+			bInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			vmInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			cInNS1 := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
+			cInNS2 := match.Namespace(apps.Namespace2.Name()).GetMatches(apps.C)
 			ns1 := apps.Namespace1
 			ns2 := apps.Namespace2
 			rootns := newRootNS(t)
@@ -256,7 +257,7 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 			}
 
 			for _, srcCluster := range t.Clusters() {
-				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
+				a := match.And(match.InCluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
 				if len(a) == 0 {
 					continue
 				}
@@ -349,9 +350,9 @@ func TestAuthorization_Deny(t *testing.T) {
 			}
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			b := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
-			c := apps.C.Match(echo.Namespace(apps.Namespace1.Name()))
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
+			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 
 			applyPolicy := func(filename string, ns namespace.Instance) {
 				t.ConfigIstio().EvalFile(map[string]string{
@@ -365,7 +366,7 @@ func TestAuthorization_Deny(t *testing.T) {
 			applyPolicy("testdata/authz/v1beta1-deny.yaml.tmpl", ns)
 			applyPolicy("testdata/authz/v1beta1-deny-ns-root.yaml.tmpl", rootns)
 			for _, srcCluster := range t.Clusters() {
-				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
+				a := match.And(match.InCluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
 				if len(a) == 0 {
 					continue
 				}
@@ -441,10 +442,10 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			ns2 := apps.Namespace2
-			b := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
-			c := apps.C.Match(echo.Namespace(apps.Namespace1.Name()))
-			d := apps.D.Match(echo.Namespace(apps.Namespace1.Name()))
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
+			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
+			d := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.D)
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			t.ConfigIstio().EvalFile(map[string]string{
 				"Namespace":  ns.Name(),
 				"Namespace2": ns2.Name(),
@@ -455,8 +456,8 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 			}, "testdata/authz/v1beta1-negative-match.yaml.tmpl").ApplyOrFail(t, "")
 
 			for _, srcCluster := range t.Clusters() {
-				a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace1.Name())))
-				bInNS2 := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(apps.Namespace2.Name())))
+				a := match.And(match.InCluster(srcCluster), match.Namespace(apps.Namespace1.Name())).GetMatches(apps.A)
+				bInNS2 := match.And(match.InCluster(srcCluster), match.Namespace(apps.Namespace2.Name())).GetMatches(apps.B)
 				if len(a) == 0 || len(bInNS2) == 0 {
 					continue
 				}
@@ -550,11 +551,11 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			b := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
+			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
 			// Gateways on VMs are not supported yet. This test verifies that security
 			// policies at gateways are useful for managing accessibility to services
 			// running on a VM.
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			for _, dst := range []echo.Instances{b, vm} {
 				t.NewSubTestf("to %s/", dst[0].Config().Service).Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile(map[string]string{
@@ -738,9 +739,9 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
 			rootns := newRootNS(t)
-			a := apps.A.Match(echo.Namespace(apps.Namespace1.Name()))
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
-			c := apps.C.Match(echo.Namespace(apps.Namespace1.Name()))
+			a := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.A)
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
+			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
 			// Gateways on VMs are not supported yet. This test verifies that security
 			// policies at gateways are useful for managing accessibility to external
 			// services running on a VM.
@@ -912,12 +913,12 @@ func TestAuthorization_TCP(t *testing.T) {
 
 			ns := apps.Namespace1
 			ns2 := apps.Namespace2
-			a := apps.A.Match(echo.Namespace(ns.Name()))
-			b := apps.B.Match(echo.Namespace(ns.Name()))
-			c := apps.C.Match(echo.Namespace(ns.Name()))
-			eInNS2 := apps.E.Match(echo.Namespace(ns2.Name()))
-			d := apps.D.Match(echo.Namespace(ns.Name()))
-			e := apps.E.Match(echo.Namespace(ns.Name()))
+			a := match.Namespace(ns.Name()).GetMatches(apps.A)
+			b := match.Namespace(ns.Name()).GetMatches(apps.B)
+			c := match.Namespace(ns.Name()).GetMatches(apps.C)
+			eInNS2 := match.Namespace(ns2.Name()).GetMatches(apps.E)
+			d := match.Namespace(ns.Name()).GetMatches(apps.D)
+			e := match.Namespace(ns.Name()).GetMatches(apps.E)
 			t.NewSubTest("non-vms").
 				Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile(map[string]string{
@@ -981,7 +982,7 @@ func TestAuthorization_TCP(t *testing.T) {
 					}
 				})
 			// TODO(JimmyCYJ): support multiple VMs and apply different security policies to each VM.
-			vm := apps.VM.Match(echo.Namespace(ns.Name()))
+			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
 			t.NewSubTest("vms").
 				Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile(map[string]string{
@@ -1026,13 +1027,13 @@ func TestAuthorization_Conditions(t *testing.T) {
 			nsB := apps.Namespace2
 			nsC := apps.Namespace3
 
-			c := apps.C.Match(echo.Namespace(nsC.Name()))
-			vm := apps.VM.Match(echo.Namespace(nsA.Name()))
+			c := match.Namespace(nsC.Name()).GetMatches(apps.C)
+			vm := match.Namespace(nsA.Name()).GetMatches(apps.VM)
 			for _, to := range []echo.Instances{c, vm} {
 				to := to
-				for _, a := range apps.A.Match(echo.Namespace(nsA.Name())) {
+				for _, a := range match.Namespace(nsA.Name()).GetMatches(apps.A) {
 					a := a
-					bs := apps.B.Match(echo.InCluster(a.Config().Cluster)).Match(echo.Namespace(nsB.Name()))
+					bs := match.And(match.InCluster(a.Config().Cluster), match.Namespace(nsB.Name())).GetMatches(apps.B)
 					if len(bs) < 1 {
 						t.Skip()
 					}
@@ -1160,11 +1161,11 @@ func TestAuthorization_GRPC(t *testing.T) {
 		Features("security.authorization.grpc-protocol").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := apps.A.Match(echo.Namespace(apps.Namespace1.Name()))
-			b := apps.B.Match(echo.Namespace(apps.Namespace1.Name()))
-			c := apps.C.Match(echo.Namespace(apps.Namespace1.Name()))
-			d := apps.D.Match(echo.Namespace(apps.Namespace1.Name()))
-			vm := apps.VM.Match(echo.Namespace(apps.Namespace1.Name()))
+			a := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.A)
+			b := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B)
+			c := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.C)
+			d := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.D)
+			vm := match.Namespace(apps.Namespace1.Name()).GetMatches(apps.VM)
 			for _, a := range []echo.Instances{a, vm} {
 				for _, b := range []echo.Instances{b, vm} {
 					if a[0].Config().Service == b[0].Config().Service {
@@ -1223,11 +1224,11 @@ func TestAuthorization_Path(t *testing.T) {
 		Features("security.authorization.path-normalization").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := apps.A.Match(echo.Namespace(ns.Name()))
-			vm := apps.VM.Match(echo.Namespace(ns.Name()))
+			a := match.Namespace(ns.Name()).GetMatches(apps.A)
+			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
 			for _, a := range []echo.Instances{a, vm} {
 				for _, srcCluster := range t.Clusters() {
-					b := apps.B.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
+					b := match.And(match.InCluster(srcCluster), match.Namespace(ns.Name())).GetMatches(apps.B)
 					if len(b) == 0 {
 						continue
 					}
@@ -1293,11 +1294,11 @@ func TestAuthorization_Audit(t *testing.T) {
 	framework.NewTest(t).
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			a := apps.A.Match(echo.Namespace(ns.Name()))
-			b := apps.B.Match(echo.Namespace(ns.Name()))
-			c := apps.C.Match(echo.Namespace(ns.Name()))
-			d := apps.D.Match(echo.Namespace(ns.Name()))
-			vm := apps.VM.Match(echo.Namespace(ns.Name()))
+			a := match.Namespace(ns.Name()).GetMatches(apps.A)
+			b := match.Namespace(ns.Name()).GetMatches(apps.B)
+			c := match.Namespace(ns.Name()).GetMatches(apps.C)
+			d := match.Namespace(ns.Name()).GetMatches(apps.D)
+			vm := match.Namespace(ns.Name()).GetMatches(apps.VM)
 
 			policy := func(filename string) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
diff --git a/tests/integration/security/ca_custom_root/main_test.go b/tests/integration/security/ca_custom_root/main_test.go
index 50291c5b50..bbb4aa4cb4 100644
--- a/tests/integration/security/ca_custom_root/main_test.go
+++ b/tests/integration/security/ca_custom_root/main_test.go
@@ -32,6 +32,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
@@ -248,14 +249,14 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 	if err != nil {
 		return err
 	}
-	apps.A = echos.Match(echo.Service(ASvc))
-	apps.B = echos.Match(echo.Service(BSvc))
-	apps.Client = echos.Match(echo.Service("client"))
-	apps.ServerNakedFoo = echos.Match(echo.Service("server-naked-foo"))
-	apps.ServerNakedBar = echos.Match(echo.Service("server-naked-bar"))
-	apps.ServerNakedFooAlt = echos.Match(echo.Service("server-naked-foo-alt"))
-	apps.Naked = echos.Match(echo.Service("naked"))
-	apps.Server = echos.Match(echo.Service("server"))
+	apps.A = match.Service(ASvc).GetMatches(echos)
+	apps.B = match.Service(BSvc).GetMatches(echos)
+	apps.Client = match.Service("client").GetMatches(echos)
+	apps.ServerNakedFoo = match.Service("server-naked-foo").GetMatches(echos)
+	apps.ServerNakedBar = match.Service("server-naked-bar").GetMatches(echos)
+	apps.ServerNakedFooAlt = match.Service("server-naked-foo-alt").GetMatches(echos)
+	apps.Naked = match.Service("naked").GetMatches(echos)
+	apps.Server = match.Service("server").GetMatches(echos)
 	return nil
 }
 
diff --git a/tests/integration/security/ca_custom_root/multi_root_test.go b/tests/integration/security/ca_custom_root/multi_root_test.go
index 46468db827..7c99127b0d 100644
--- a/tests/integration/security/ca_custom_root/multi_root_test.go
+++ b/tests/integration/security/ca_custom_root/multi_root_test.go
@@ -25,6 +25,7 @@
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
@@ -60,7 +61,7 @@ func TestMultiRootSetup(t *testing.T) {
 						})
 					}
 
-					client := apps.Client.GetOrFail(t, echo.InCluster(cluster))
+					client := match.InCluster(cluster).FirstOrFail(t, apps.Client)
 					cases := []struct {
 						from   echo.Instance
 						to     echo.Instances
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 6ee6ceeb96..f5a07984f8 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -30,6 +30,7 @@
 	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/util/retry"
@@ -116,12 +117,12 @@ func TestSecureNaming(t *testing.T) {
 			retry.UntilSuccessOrFail(t, func() error {
 				return checkCACert(t, testNamespace)
 			}, retry.Delay(time.Second), retry.Timeout(10*time.Second))
-			to := apps.B.Match(echo.Namespace(testNamespace.Name()))
+			to := match.Namespace(testNamespace.Name()).GetMatches(apps.B)
 			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					a := apps.A.Match(echo.InCluster(cluster)).Match(echo.Namespace(testNamespace.Name()))[0]
-					b := apps.B.Match(echo.InCluster(cluster)).Match(echo.Namespace(testNamespace.Name()))[0]
+					a := match.And(match.InCluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.A)[0]
+					b := match.And(match.InCluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.B)[0]
 					t.NewSubTest("mTLS cert validation with plugin CA").
 						Run(func(t framework.TestContext) {
 							// Verify that the certificate issued to the sidecar is as expected.
diff --git a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
index 3b665c7046..3038cfdfc6 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
@@ -25,6 +25,7 @@
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
@@ -104,7 +105,7 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 						})
 					}
 
-					client := apps.Client.GetOrFail(t, echo.InCluster(cluster))
+					client := match.InCluster(cluster).FirstOrFail(t, apps.Client)
 					cases := []struct {
 						src    echo.Instance
 						dest   echo.Instances
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index ef07e9a6f1..20cac37d44 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -33,6 +33,7 @@
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/util/retry"
 )
 
@@ -122,9 +123,9 @@ func(ctx framework.TestContext) {
 					// naked: only test app without sidecar, send requests from trust domain aliases
 					// client: app with sidecar, send request from cluster.local
 					// server: app with sidecar, verify requests from cluster.local or trust domain aliases
-					client := apps.Client.GetOrFail(t, echo.InCluster(cluster))
-					naked := apps.Naked.GetOrFail(t, echo.InCluster(cluster))
-					server := apps.Server.GetOrFail(t, echo.InCluster(cluster))
+					client := match.InCluster(cluster).FirstOrFail(t, apps.Client)
+					naked := match.InCluster(cluster).FirstOrFail(t, apps.Naked)
+					server := match.InCluster(cluster).FirstOrFail(t, apps.Server)
 					verify := func(ctx framework.TestContext, from echo.Instance, td, port string, s scheme.Instance, allow bool) {
 						ctx.Helper()
 						want := "allow"
diff --git a/tests/integration/security/ecc_signature_algorithm/main_test.go b/tests/integration/security/ecc_signature_algorithm/main_test.go
index c7d853e632..ff4742109b 100644
--- a/tests/integration/security/ecc_signature_algorithm/main_test.go
+++ b/tests/integration/security/ecc_signature_algorithm/main_test.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
@@ -99,12 +100,12 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 	if err != nil {
 		return err
 	}
-	apps.Client, err = echos.Get(echo.Service("client"))
+	apps.Client, err = match.Service("client").First(echos)
 	if err != nil {
 		return err
 	}
 
-	apps.Server, err = echos.Get(echo.Service("server"))
+	apps.Server, err = match.Service("server").First(echos)
 	if err != nil {
 		return err
 	}
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 7d4f5b43ec..2d6a4ab966 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -33,6 +33,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -103,8 +104,8 @@ func TestSimpleTlsOrigination(t *testing.T) {
 					CreateDestinationRule(t, apps.Namespace1, "SIMPLE", tc.CredentialToUse)
 					echotest.New(t, apps.All).
 						WithDefaultFilters().
-						From(echotest.Not(echotest.FilterMatch(echo.IsNaked()))).
-						To(echotest.FilterMatch(echo.Service(util.ExternalSvc))).
+						FromMatch(match.IsNotNaked).
+						ToMatch(match.Service(util.ExternalSvc)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							callOpt := CallOpts(to, host, tc)
 							from.CallOrFail(t, callOpt)
@@ -216,8 +217,8 @@ func TestMutualTlsOrigination(t *testing.T) {
 					CreateDestinationRule(t, apps.Namespace1, "MUTUAL", tc.CredentialToUse)
 					echotest.New(t, apps.All).
 						WithDefaultFilters().
-						From(echotest.Not(echotest.FilterMatch(echo.IsNaked()))).
-						To(echotest.FilterMatch(echo.Service(util.ExternalSvc))).
+						FromMatch(match.IsNotNaked).
+						ToMatch(match.Service(util.ExternalSvc)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							callOpt := CallOpts(to, host, tc)
 							from.CallOrFail(t, callOpt)
diff --git a/tests/integration/security/external_ca/main_test.go b/tests/integration/security/external_ca/main_test.go
index 060c662132..ab0b885af2 100644
--- a/tests/integration/security/external_ca/main_test.go
+++ b/tests/integration/security/external_ca/main_test.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
@@ -69,8 +70,8 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 	if err != nil {
 		return err
 	}
-	apps.A = echos.Match(echo.Service(ASvc))
-	apps.B = echos.Match(echo.Service(BSvc))
+	apps.A = match.Service(ASvc).GetMatches(echos)
+	apps.B = match.Service(BSvc).GetMatches(echos)
 	return nil
 }
 
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index ac49540fca..ea34b6676c 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -24,6 +24,7 @@
 	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/tests/integration/security/util"
@@ -51,11 +52,11 @@ func TestReachability(t *testing.T) {
 			istioCfg := istio.DefaultConfigOrFail(t, t)
 			testNamespace := apps.Namespace
 			namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
-			to := apps.B.Match(echo.Namespace(testNamespace.Name()))
+			to := match.Namespace(testNamespace.Name()).GetMatches(apps.B)
 			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					a := apps.A.Match(echo.InCluster(cluster)).Match(echo.Namespace(testNamespace.Name()))[0]
+					a := match.And(match.InCluster(cluster), match.Namespace(testNamespace.Name())).GetMatches(apps.A)[0]
 					t.NewSubTest("Basic reachability with external ca").
 						Run(func(t framework.TestContext) {
 							// Verify mTLS works between a and b
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 9b33c98b44..bc6f79a195 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -101,11 +101,11 @@ func TestJWTHTTPS(t *testing.T) {
 							return t.ConfigIstio().EvalFile(args, c.policyFile).
 								Apply(ns.Name(), resource.Wait)
 						}).
-						From(
+						FromMatch(
 							// TODO(JimmyCYJ): enable VM for all test cases.
-							util.SourceFilter(apps, ns.Name(), true)...).
+							util.SourceMatcher(ns.Name(), true)).
 						ConditionallyTo(echotest.ReachableDestinations).
-						To(util.DestFilter(apps, ns.Name(), true)...).
+						ToMatch(util.DestMatcher(ns.Name(), true)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							opts := echo.CallOptions{
 								To: to,
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index f359c87039..80ba54c102 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -28,6 +28,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -67,11 +68,11 @@ type testCase struct {
 							}
 							return nil
 						}).
-						From(
+						FromMatch(
 							// TODO(JimmyCYJ): enable VM for all test cases.
-							util.SourceFilter(apps, ns.Name(), true)...).
+							util.SourceMatcher(ns.Name(), true)).
 						ConditionallyTo(echotest.ReachableDestinations).
-						To(util.DestFilter(apps, ns.Name(), true)...).
+						ToMatch(util.DestMatcher(ns.Name(), true)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
@@ -417,12 +418,12 @@ type testCase struct {
 							}
 							return nil
 						}).
-						From(util.SourceFilter(apps, ns.Name(), false)...).
+						FromMatch(util.SourceMatcher(ns.Name(), false)).
 						ConditionallyTo(echotest.ReachableDestinations).
 						ConditionallyTo(func(from echo.Instance, to echo.Instances) echo.Instances {
-							return to.Match(echo.InCluster(from.Config().Cluster))
+							return match.InCluster(from.Config().Cluster).GetMatches(to)
 						}).
-						To(util.DestFilter(apps, ns.Name(), false)...).
+						ToMatch(util.DestMatcher(ns.Name(), false)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
diff --git a/tests/integration/security/mtls_first_party_jwt/strict_test.go b/tests/integration/security/mtls_first_party_jwt/strict_test.go
index 6c8e3a6651..ee21bf7163 100644
--- a/tests/integration/security/mtls_first_party_jwt/strict_test.go
+++ b/tests/integration/security/mtls_first_party_jwt/strict_test.go
@@ -22,6 +22,7 @@
 
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/tests/integration/security/util/reachability"
 )
@@ -88,7 +89,7 @@ func TestMtlsStrictK8sCA(t *testing.T) {
 					},
 					ExpectDestinations: func(from echo.Instance, to echo.Target) echo.Instances {
 						// Without TLS we can't perform SNI routing required for multi-network
-						return to.Instances().Match(echo.InNetwork(from.Config().Cluster.NetworkName()))
+						return match.InNetwork(from.Config().Cluster.NetworkName()).GetMatches(to.Instances())
 					},
 					ExpectMTLS: func(src echo.Instance, opts echo.CallOptions) bool {
 						return false
diff --git a/tests/integration/security/mtlsk8sca/strict_test.go b/tests/integration/security/mtlsk8sca/strict_test.go
index 76e96d5a95..2d1ee30137 100644
--- a/tests/integration/security/mtlsk8sca/strict_test.go
+++ b/tests/integration/security/mtlsk8sca/strict_test.go
@@ -22,6 +22,7 @@
 
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/tests/integration/security/util/reachability"
 )
@@ -89,7 +90,7 @@ func TestMtlsStrictK8sCA(t *testing.T) {
 					},
 					ExpectDestinations: func(from echo.Instance, to echo.Target) echo.Instances {
 						// Without TLS we can't perform SNI routing required for multi-network
-						return to.Instances().Match(echo.InNetwork(from.Config().Cluster.NetworkName()))
+						return match.InNetwork(from.Config().Cluster.NetworkName()).GetMatches(to.Instances())
 					},
 					ExpectMTLS: func(src echo.Instance, opts echo.CallOptions) bool {
 						return false
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 2649e6d2c8..78f1c2a32c 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -22,6 +22,7 @@
 	"net/http"
 	"testing"
 
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/http/headers"
 	echoClient "istio.io/istio/pkg/test/echo"
@@ -29,6 +30,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/pkg/test/util/yml"
 	"istio.io/istio/tests/integration/security/util"
@@ -542,14 +544,20 @@ type expect struct {
 				},
 			}
 
-			// srcFilter finds the naked app as client.
 			// TODO(slandow) replace this with built-in framework filters (blocked by https://github.com/istio/istio/pull/31565)
-			srcFilter := []echotest.Filter{func(instances echo.Instances) echo.Instances {
-				src := apps.Naked.Match(echo.Namespace(ns.Name()))
-				src = append(src, apps.B.Match(echo.Namespace(ns.Name()))...)
-				src = append(src, apps.VM.Match(echo.Namespace(ns.Name()))...)
-				return src
-			}}
+			srcMatcher := match.Or(
+				match.NamespacedName(model.NamespacedName{
+					Name:      util.NakedSvc,
+					Namespace: ns.Name(),
+				}),
+				match.NamespacedName(model.NamespacedName{
+					Name:      util.BSvc,
+					Namespace: ns.Name(),
+				}),
+				match.NamespacedName(model.NamespacedName{
+					Name:      util.VMSvc,
+					Namespace: ns.Name(),
+				}))
 			for _, tc := range cases {
 				t.NewSubTest(tc.name).Run(func(t framework.TestContext) {
 					echotest.New(t, apps.All).
@@ -610,16 +618,16 @@ type expect struct {
 							), ns.Name())
 							return t.ConfigIstio().YAML(cfg, fakesvc).Apply(ns.Name())
 						}).
-						From(srcFilter...).
+						FromMatch(srcMatcher).
 						ConditionallyTo(echotest.ReachableDestinations).
 						To(
 							echotest.SingleSimplePodServiceAndAllSpecial(),
-							echotest.Not(func(instances echo.Instances) echo.Instances { return instances.Match(echo.IsHeadless()) }),
-							echotest.Not(func(instances echo.Instances) echo.Instances { return instances.Match(echo.IsNaked()) }),
-							echotest.Not(func(instances echo.Instances) echo.Instances { return instances.Match(echo.IsExternal()) }),
-							echotest.Not(func(instances echo.Instances) echo.Instances { return instances.Match(util.IsMultiversion()) }),
-							func(instances echo.Instances) echo.Instances { return instances.Match(echo.Namespace(ns.Name())) },
-						).
+							echotest.FilterMatch(match.And(
+								match.Namespace(ns.Name()),
+								match.IsNotHeadless,
+								match.IsNotNaked,
+								match.IsNotExternal,
+								util.IsNotMultiversion))).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
 							clusterName := from.Config().Cluster.StableName()
 							if to.Config().Cluster.StableName() != clusterName {
diff --git a/tests/integration/security/reachability_test.go b/tests/integration/security/reachability_test.go
index 6c8c2d6079..046d457e15 100644
--- a/tests/integration/security/reachability_test.go
+++ b/tests/integration/security/reachability_test.go
@@ -22,6 +22,7 @@
 
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/tests/integration/security/util/reachability"
 )
@@ -163,7 +164,7 @@ func TestReachability(t *testing.T) {
 					Namespace:  systemNM,
 					ExpectDestinations: func(from echo.Instance, to echo.Target) echo.Instances {
 						// Without TLS we can't perform SNI routing required for multi-network
-						return to.Instances().Match(echo.InNetwork(from.Config().Cluster.NetworkName()))
+						return match.InNetwork(from.Config().Cluster.NetworkName()).GetMatches(to.Instances())
 					},
 					ExpectSuccess: Always,
 					ExpectMTLS:    Never,
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index 076b567305..6da9fd8cc5 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -22,12 +22,13 @@
 	"os"
 	"path"
 
+	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
-	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -184,7 +185,7 @@ func MustReadCert(f string) string {
 	return string(b)
 }
 
-func SetupApps(ctx resource.Context, i istio.Instance, apps *EchoDeployments, buildVM bool) error {
+func SetupApps(ctx resource.Context, _ istio.Instance, apps *EchoDeployments, buildVM bool) error {
 	if ctx.Settings().Skip(echo.VM) {
 		buildVM = false
 	}
@@ -290,17 +291,17 @@ func SetupApps(ctx resource.Context, i istio.Instance, apps *EchoDeployments, bu
 		return err
 	}
 	apps.All = echos
-	apps.A = echos.Match(echo.Service(ASvc))
-	apps.B = echos.Match(echo.Service(BSvc))
-	apps.C = echos.Match(echo.Service(CSvc))
-	apps.D = echos.Match(echo.Service(DSvc))
-	apps.E = echos.Match(echo.Service(ESvc))
+	apps.A = match.Service(ASvc).GetMatches(echos)
+	apps.B = match.Service(BSvc).GetMatches(echos)
+	apps.C = match.Service(CSvc).GetMatches(echos)
+	apps.D = match.Service(DSvc).GetMatches(echos)
+	apps.E = match.Service(ESvc).GetMatches(echos)
 
-	apps.Multiversion = echos.Match(echo.Service(MultiversionSvc))
-	apps.Headless = echos.Match(echo.Service(HeadlessSvc))
-	apps.Naked = echos.Match(echo.Service(NakedSvc))
-	apps.VM = echos.Match(echo.Service(VMSvc))
-	apps.HeadlessNaked = echos.Match(echo.Service(HeadlessNakedSvc))
+	apps.Multiversion = match.Service(MultiversionSvc).GetMatches(echos)
+	apps.Headless = match.Service(HeadlessSvc).GetMatches(echos)
+	apps.Naked = match.Service(NakedSvc).GetMatches(echos)
+	apps.VM = match.Service(VMSvc).GetMatches(echos)
+	apps.HeadlessNaked = match.Service(HeadlessNakedSvc).GetMatches(echos)
 
 	return nil
 }
@@ -318,43 +319,53 @@ func (apps *EchoDeployments) IsVM(t echo.Target) bool {
 }
 
 // IsMultiversion matches instances that have Multi-version specific setup.
-func IsMultiversion() echo.Matcher {
-	return func(i echo.Instance) bool {
-		if len(i.Config().Subsets) != 2 {
-			return false
-		}
-		var matchIstio, matchLegacy bool
-		for _, s := range i.Config().Subsets {
-			if s.Version == "vistio" {
-				matchIstio = true
-			} else if s.Version == "vlegacy" && !s.Annotations.GetBool(echo.SidecarInject) {
-				matchLegacy = true
-			}
+var IsMultiversion match.Matcher = func(i echo.Instance) bool {
+	if len(i.Config().Subsets) != 2 {
+		return false
+	}
+	var matchIstio, matchLegacy bool
+	for _, s := range i.Config().Subsets {
+		if s.Version == "vistio" {
+			matchIstio = true
+		} else if s.Version == "vlegacy" && !s.Annotations.GetBool(echo.SidecarInject) {
+			matchLegacy = true
 		}
-		return matchIstio && matchLegacy
 	}
+	return matchIstio && matchLegacy
 }
 
-// SourceFilter returns workload pod A with sidecar injected and VM
-func SourceFilter(apps *EchoDeployments, ns string, skipVM bool) []echotest.Filter {
-	rt := []echotest.Filter{func(instances echo.Instances) echo.Instances {
-		inst := apps.A.Match(echo.Namespace(ns))
-		if !skipVM {
-			inst = append(inst, apps.VM.Match(echo.Namespace(ns))...)
-		}
-		return inst
-	}}
-	return rt
+var IsNotMultiversion = match.Not(IsMultiversion)
+
+// SourceMatcher matches workload pod A with sidecar injected and VM
+func SourceMatcher(ns string, skipVM bool) match.Matcher {
+	m := match.NamespacedName(model.NamespacedName{
+		Name:      ASvc,
+		Namespace: ns,
+	})
+
+	if !skipVM {
+		m = match.Or(m, match.NamespacedName(model.NamespacedName{
+			Name:      VMSvc,
+			Namespace: ns,
+		}))
+	}
+
+	return m
 }
 
-// DestFilter returns workload pod B with sidecar injected and VM
-func DestFilter(apps *EchoDeployments, ns string, skipVM bool) []echotest.Filter {
-	rt := []echotest.Filter{func(instances echo.Instances) echo.Instances {
-		inst := apps.B.Match(echo.Namespace(ns))
-		if !skipVM {
-			inst = append(inst, apps.VM.Match(echo.Namespace(ns))...)
-		}
-		return inst
-	}}
-	return rt
+// DestMatcher matches workload pod B with sidecar injected and VM
+func DestMatcher(ns string, skipVM bool) match.Matcher {
+	m := match.NamespacedName(model.NamespacedName{
+		Name:      BSvc,
+		Namespace: ns,
+	})
+
+	if !skipVM {
+		m = match.Or(m, match.NamespacedName(model.NamespacedName{
+			Name:      VMSvc,
+			Namespace: ns,
+		}))
+	}
+
+	return m
 }
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index a70e072f06..a50fa859ff 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -27,6 +27,7 @@
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/retry"
@@ -115,7 +116,7 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 				// TODO(https://github.com/istio/istio/issues/20460) We shouldn't need a retry loop
 				return cfg.Apply(c.Namespace.Name(), resource.Wait)
 			})
-			for _, clients := range []echo.Instances{apps.A, apps.B.Match(echo.Namespace(apps.Namespace1.Name())), apps.Headless, apps.Naked, apps.HeadlessNaked} {
+			for _, clients := range []echo.Instances{apps.A, match.Namespace(apps.Namespace1.Name()).GetMatches(apps.B), apps.Headless, apps.Naked, apps.HeadlessNaked} {
 				for _, from := range clients {
 					from := from
 					t.NewSubTest(fmt.Sprintf("%s in %s",
@@ -124,11 +125,11 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 							apps.A,
 							apps.B,
 							// only hit same network headless services
-							apps.Headless.Match(echo.InNetwork(from.Config().Cluster.NetworkName())),
+							match.InNetwork(from.Config().Cluster.NetworkName()).GetMatches(apps.Headless),
 							// only hit same cluster multiversion services
-							apps.Multiversion.Match(echo.InCluster(from.Config().Cluster)),
+							match.InCluster(from.Config().Cluster).GetMatches(apps.Multiversion),
 							// only hit same cluster naked services
-							apps.Naked.Match(echo.InCluster(from.Config().Cluster)),
+							match.InCluster(from.Config().Cluster).GetMatches(apps.Naked),
 							apps.VM,
 						}
 
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index 53a54af873..4f4cd46559 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -38,6 +38,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/gcemetadata"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -151,8 +152,8 @@ func TestSetup(ctx resource.Context) (err error) {
 	if err != nil {
 		return
 	}
-	Clt = echos.Match(echo.ServicePrefix("clt"))
-	Srv = echos.Match(echo.Service("srv"))
+	Clt = match.ServicePrefix("clt").GetMatches(echos)
+	Srv = match.Service("srv").GetMatches(echos)
 	return nil
 }
 
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index d6dedfdae3..24587a8df4 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -29,6 +29,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/components/prometheus"
@@ -157,8 +158,8 @@ func testSetup(ctx resource.Context) (err error) {
 	if err != nil {
 		return err
 	}
-	client = echos.Match(echo.Service("client"))
-	server = echos.Match(echo.Service("server"))
+	client = match.Service("client").GetMatches(echos)
+	server = match.Service("server").GetMatches(echos)
 	promInst, err = prometheus.New(ctx, prometheus.Config{})
 	if err != nil {
 		return
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index 1fe5867714..e72a6ea6f6 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -31,6 +31,7 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -148,7 +149,7 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {
 
 			// In addition, verifies that mocked prometheus could call metrics endpoint with proxy provisioned certs
 			for _, prom := range mockProm {
-				st := server.GetOrFail(t, echo.InCluster(prom.Config().Cluster))
+				st := match.InCluster(prom.Config().Cluster).FirstOrFail(t, server)
 				prom.CallOrFail(t, echo.CallOptions{
 					Address: st.WorkloadsOrFail(t)[0].Address(),
 					Scheme:  scheme.HTTPS,
@@ -308,10 +309,10 @@ func TestSetup(ctx resource.Context) (err error) {
 	for _, c := range ctx.Clusters() {
 		ingr = append(ingr, ist.IngressFor(c))
 	}
-	client = echos.Match(echo.Service("client"))
-	server = echos.Match(echo.Service("server"))
-	nonInjectedServer = echos.Match(echo.Service("server-no-sidecar"))
-	mockProm = echos.Match(echo.Service("mock-prom"))
+	client = match.Service("client").GetMatches(echos)
+	server = match.Service("server").GetMatches(echos)
+	nonInjectedServer = match.Service("server-no-sidecar").GetMatches(echos)
+	mockProm = match.Service("mock-prom").GetMatches(echos)
 	promInst, err = prometheus.New(ctx, prometheus.Config{})
 	if err != nil {
 		return
diff --git a/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go b/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
index 66acd226d9..72195fd6e5 100644
--- a/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
+++ b/tests/integration/telemetry/stats/prometheus/wasm/bad_wasm_filter_test.go
@@ -22,7 +22,7 @@
 	"time"
 
 	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/prometheus"
 	"istio.io/istio/pkg/test/util/retry"
 	util "istio.io/istio/tests/integration/telemetry"
@@ -39,8 +39,8 @@ func TestBadWasmRemoteLoad(t *testing.T) {
 		Features("extensibility.wasm.remote-load").
 		Run(func(t framework.TestContext) {
 			// Test bad wasm remote load in only one cluster.
-			// There is no need to repeat the same testing logic in several different clusters.
-			cltInstance := common.GetClientInstances().GetOrFail(t, echo.InCluster(t.Clusters().Default()))
+			// There is no need to repeat the same testing logic in multiple clusters.
+			cltInstance := match.InCluster(t.Clusters().Default()).FirstOrFail(t, common.GetClientInstances())
 			// Verify that echo server could return 200
 			retry.UntilSuccessOrFail(t, func() error {
 				if err := common.SendTraffic(cltInstance); err != nil {
diff --git a/tests/integration/telemetry/tracing/tracing.go b/tests/integration/telemetry/tracing/tracing.go
index acbac001aa..34e11133d3 100644
--- a/tests/integration/telemetry/tracing/tracing.go
+++ b/tests/integration/telemetry/tracing/tracing.go
@@ -25,6 +25,7 @@
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -105,8 +106,8 @@ func TestSetup(ctx resource.Context) (err error) {
 	if err != nil {
 		return err
 	}
-	client = echos.Match(echo.ServicePrefix("client"))
-	server = echos.Match(echo.Service("server"))
+	client = match.ServicePrefix("client").GetMatches(echos)
+	server = match.Service("server").GetMatches(echos)
 	ingInst = ist.IngressFor(ctx.Clusters().Default())
 	addr, _ := ingInst.HTTPAddress()
 	zipkinInst, err = zipkin.New(ctx, zipkin.Config{Cluster: ctx.Clusters().Default(), IngressAddr: addr})
-- 
2.35.3

