From 9f56e4cb0cf09c8f719218cb0ff4c4ab5176fa23 Mon Sep 17 00:00:00 2001
From: Gregory Hanson <gihanson@us.ibm.com>
Date: Thu, 10 Mar 2022 22:12:03 -0500
Subject: Add Warning for IPs in SNI Hosts in TLSRoute.Match criteria (#37586)

* add error message for IP addresses in SNI hosts field

* add tests for IPs in SNI hosts fields

* added release note

* switched from validation fail to warning message

* update warning message

* update release note

* review comments
---
 pkg/config/validation/validation.go      | 46 ++++++++++++------------
 pkg/config/validation/validation_test.go | 28 +++++++++++++++
 releasenotes/notes/ip-sni-hosts.yaml     |  8 +++++
 3 files changed, 58 insertions(+), 24 deletions(-)
 create mode 100644 releasenotes/notes/ip-sni-hosts.yaml

diff --git a/pkg/config/validation/validation.go b/pkg/config/validation/validation.go
index 6b3c56de46..430b0440a4 100644
--- a/pkg/config/validation/validation.go
+++ b/pkg/config/validation/validation.go
@@ -2443,67 +2443,65 @@ func requestName(match interface{}, matchn int) string {
 	return fmt.Sprintf("#%d", matchn)
 }
 
-func validateTLSRoute(tls *networking.TLSRoute, context *networking.VirtualService) error {
-	var errs error
+func validateTLSRoute(tls *networking.TLSRoute, context *networking.VirtualService) (errs Validation) {
 	if tls == nil {
-		return nil
+		return
 	}
 	if len(tls.Match) == 0 {
-		errs = appendErrors(errs, errors.New("TLS route must have at least one match condition"))
+		errs = appendValidation(errs, errors.New("TLS route must have at least one match condition"))
 	}
 	for _, match := range tls.Match {
-		errs = appendErrors(errs, validateTLSMatch(match, context))
+		errs = appendValidation(errs, validateTLSMatch(match, context))
 	}
 	if len(tls.Route) == 0 {
-		errs = appendErrors(errs, errors.New("TLS route is required"))
+		errs = appendValidation(errs, errors.New("TLS route is required"))
 	}
-	errs = appendErrors(errs, validateRouteDestinations(tls.Route))
+	errs = appendValidation(errs, validateRouteDestinations(tls.Route))
 	return errs
 }
 
-func validateTLSMatch(match *networking.TLSMatchAttributes, context *networking.VirtualService) (errs error) {
+func validateTLSMatch(match *networking.TLSMatchAttributes, context *networking.VirtualService) (errs Validation) {
 	if match == nil {
-		errs = appendErrors(errs, errors.New("TLS match may not be null"))
+		errs = appendValidation(errs, errors.New("TLS match may not be null"))
 		return
 	}
 	if len(match.SniHosts) == 0 {
-		errs = appendErrors(errs, fmt.Errorf("TLS match must have at least one SNI host"))
+		errs = appendValidation(errs, fmt.Errorf("TLS match must have at least one SNI host"))
 	} else {
 		for _, sniHost := range match.SniHosts {
-			err := validateSniHost(sniHost, context)
-			if err != nil {
-				errs = appendErrors(errs, err)
-			}
+			errs = appendValidation(errs, validateSniHost(sniHost, context))
 		}
 	}
 
 	for _, destinationSubnet := range match.DestinationSubnets {
-		errs = appendErrors(errs, ValidateIPSubnet(destinationSubnet))
+		errs = appendValidation(errs, ValidateIPSubnet(destinationSubnet))
 	}
 
 	if match.Port != 0 {
-		errs = appendErrors(errs, ValidatePort(int(match.Port)))
+		errs = appendValidation(errs, ValidatePort(int(match.Port)))
 	}
-	errs = appendErrors(errs, labels.Instance(match.SourceLabels).Validate())
-	errs = appendErrors(errs, validateGatewayNames(match.Gateways))
+	errs = appendValidation(errs, labels.Instance(match.SourceLabels).Validate())
+	errs = appendValidation(errs, validateGatewayNames(match.Gateways))
 	return
 }
 
-func validateSniHost(sniHost string, context *networking.VirtualService) error {
+func validateSniHost(sniHost string, context *networking.VirtualService) (errs Validation) {
 	if err := ValidateWildcardDomain(sniHost); err != nil {
 		ipAddr := net.ParseIP(sniHost) // Could also be an IP
-		if ipAddr == nil {
-			return err
+		if ipAddr != nil {
+			errs = appendValidation(errs, WrapWarning(fmt.Errorf("using an IP address (%q) goes against SNI spec and most clients do not support this", ipAddr)))
+			return
 		}
+		return appendValidation(errs, err)
 	}
 	sniHostname := host.Name(sniHost)
 	for _, hostname := range context.Hosts {
 		if sniHostname.SubsetOf(host.Name(hostname)) {
-			return nil
+			return
 		}
 	}
-	return fmt.Errorf("SNI host %q is not a compatible subset of any of the virtual service hosts: [%s]",
-		sniHost, strings.Join(context.Hosts, ", "))
+	return appendValidation(errs, fmt.Errorf("SNI host %q is not a compatible subset of any of the virtual service hosts: [%s]",
+		sniHost, strings.Join(context.Hosts, ", ")))
 }
 
 func validateTCPRoute(tcp *networking.TCPRoute) (errs error) {
diff --git a/pkg/config/validation/validation_test.go b/pkg/config/validation/validation_test.go
index 7133b534bd..ce32dceede 100644
--- a/pkg/config/validation/validation_test.go
+++ b/pkg/config/validation/validation_test.go
@@ -2786,6 +2786,34 @@ func TestValidateVirtualService(t *testing.T) {
 				},
 			}},
 		}, valid: false, warning: false},
+		{name: "ip address as sni host", in: &networking.VirtualService{
+			Hosts: []string{"foo.bar"},
+			Tls: []*networking.TLSRoute{{
+				Route: []*networking.RouteDestination{{
+					Destination: &networking.Destination{Host: "foo.baz"},
+				}},
+				Match: []*networking.TLSMatchAttributes{
+					{
+						Port:     999,
+						SniHosts: []string{"1.1.1.1"},
+					},
+				},
+			}},
+		}, valid: true, warning: true},
+		{name: "invalid wildcard as sni host", in: &networking.VirtualService{
+			Hosts: []string{"foo.bar"},
+			Tls: []*networking.TLSRoute{{
+				Route: []*networking.RouteDestination{{
+					Destination: &networking.Destination{Host: "foo.baz"},
+				}},
+				Match: []*networking.TLSMatchAttributes{
+					{
+						Port:     999,
+						SniHosts: []string{"foo.*.com"},
+					},
+				},
+			}},
+		}, valid: false, warning: false},
 	}
 
 	for _, tc := range testCases {
diff --git a/releasenotes/notes/ip-sni-hosts.yaml b/releasenotes/notes/ip-sni-hosts.yaml
new file mode 100644
index 0000000000..18e7f8a047
--- /dev/null
+++ b/releasenotes/notes/ip-sni-hosts.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+- 33401
+releaseNotes:
+- |
+  **Added** warning messages for users attempting to use IP addresses as SNI values in VirtualService.TLSRoute.Match.SniHosts
-- 
2.35.3

