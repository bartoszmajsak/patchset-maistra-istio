From a37782af0cd8282868271e2a05eb98e00864ab39 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Mon, 25 Apr 2022 09:48:04 -0700
Subject: [tf] Support echo egress to ext-authz (#38540)

The echos are currently restricted to just the other echo namespaces, which prevents egress to the external authz server, if it's in another namespace.

This PR changes the logic so that egress is allowed to any namespace that has been allocated by the test framework up to the point the echos are created.

Fixes #38451
---
 .../echo/common/deployment/echos.go           |  20 ---
 .../echo/common/deployment/namespace.go       |  13 +-
 .../framework/components/namespace/kube.go    | 151 +++++++++++++-----
 .../components/namespace/namespace.go         |   9 ++
 4 files changed, 126 insertions(+), 67 deletions(-)

diff --git a/pkg/test/framework/components/echo/common/deployment/echos.go b/pkg/test/framework/components/echo/common/deployment/echos.go
index 1eb350cd50..eb140d4b77 100644
--- a/pkg/test/framework/components/echo/common/deployment/echos.go
+++ b/pkg/test/framework/components/echo/common/deployment/echos.go
@@ -17,7 +17,6 @@
 import (
 	"context"
 	"fmt"
-	"sort"
 	"strings"
 
 	"github.com/hashicorp/go-multierror"
@@ -267,25 +266,6 @@ func (e *Echos) TwoNamespaceView() TwoNamespaceView {
 	}
 }
 
-func (e Echos) namespaces(excludes ...namespace.Instance) []string {
-	var out []string
-	for _, n := range e.NS {
-		include := true
-		for _, e := range excludes {
-			if n.Namespace.Name() == e.Name() {
-				include = false
-				break
-			}
-		}
-		if include {
-			out = append(out, n.Namespace.Name())
-		}
-	}
-
-	sort.Strings(out)
-	return out
-}
-
 func serviceEntryPorts() []echo.Port {
 	var res []echo.Port
 	for _, p := range ports.All().GetServicePorts() {
diff --git a/pkg/test/framework/components/echo/common/deployment/namespace.go b/pkg/test/framework/components/echo/common/deployment/namespace.go
index 4c9820dc51..2080c62f58 100644
--- a/pkg/test/framework/components/echo/common/deployment/namespace.go
+++ b/pkg/test/framework/components/echo/common/deployment/namespace.go
@@ -15,6 +15,7 @@
 package deployment
 
 import (
+	"fmt"
 	"strconv"
 
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -210,10 +211,15 @@ func (n *EchoNamespace) loadValues(t resource.Context, echos echo.Instances, d *
 		n.DeltaXDS = all(match.ServiceName(echo.NamespacedName{Name: DeltaSvc, Namespace: ns}).GetMatches(echos))
 	}
 
+	namespaces, err := namespace.GetAll(t)
+	if err != nil {
+		return fmt.Errorf("failed retrieving list of namespaces: %v", err)
+	}
+
 	// Restrict egress from this namespace to only those endpoints in the same Echos.
 	cfg := t.ConfigIstio().New()
 	cfg.Eval(ns.Name(), map[string]interface{}{
-		"otherNS": d.namespaces(n.Namespace),
+		"Namespaces": namespaces,
 	}, `
 apiVersion: networking.istio.io/v1alpha3
 kind: Sidecar
@@ -222,10 +228,9 @@ func (n *EchoNamespace) loadValues(t resource.Context, echos echo.Instances, d *
 spec:
   egress:
   - hosts:
-    - "./*"
     - "istio-system/*"
-{{ range $ns := .otherNS }}
-    - "{{ $ns }}/*"
+{{ range $ns := .Namespaces }}
+    - "{{ $ns.Name }}/*"
 {{ end }}
 `)
 
diff --git a/pkg/test/framework/components/namespace/kube.go b/pkg/test/framework/components/namespace/kube.go
index a1710355dc..f8e73c73ad 100644
--- a/pkg/test/framework/components/namespace/kube.go
+++ b/pkg/test/framework/components/namespace/kube.go
@@ -44,10 +44,11 @@
 
 // kubeNamespace represents a Kubernetes namespace. It is tracked as a resource.
 type kubeNamespace struct {
-	id     resource.ID
-	name   string
-	prefix string
-	ctx    resource.Context
+	id           resource.ID
+	name         string
+	prefix       string
+	cleanupFuncs []func() error
+	ctx          resource.Context
 }
 
 func (n *kubeNamespace) Dump(ctx resource.Context) {
@@ -120,14 +121,27 @@ func (n *kubeNamespace) ID() resource.ID {
 
 // Close implements io.Closer
 func (n *kubeNamespace) Close() (err error) {
-	if n.name != "" {
+	// Get non-nil cleanup funcs.
+	var cleanupFuncs []func() error
+	for _, fn := range n.cleanupFuncs {
+		if fn != nil {
+			cleanupFuncs = append(cleanupFuncs, fn)
+		}
+	}
+
+	// Clear out the cleanup funcs and name to mark this namespace as closed.
+	n.cleanupFuncs = nil
+	n.name = ""
+
+	if len(cleanupFuncs) > 0 {
 		scopes.Framework.Debugf("%s deleting namespace", n.id)
-		ns := n.name
-		n.name = ""
 
-		for _, c := range n.ctx.Clusters().Kube() {
-			err = c.CoreV1().Namespaces().Delete(context.TODO(), ns, kube2.DeleteOptionsForeground())
+		g := multierror.Group{}
+		for _, cleanup := range cleanupFuncs {
+			g.Go(cleanup)
 		}
+
+		err = g.Wait().ErrorOrNil()
 	}
 
 	scopes.Framework.Debugf("%s close complete (err:%v)", n.id, err)
@@ -135,47 +149,80 @@ func (n *kubeNamespace) Close() (err error) {
 }
 
 func claimKube(ctx resource.Context, nsConfig *Config) (Instance, error) {
-	for _, cluster := range ctx.Clusters().Kube() {
-		if !kube2.NamespaceExists(cluster, nsConfig.Prefix) {
-			if _, err := cluster.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:   nsConfig.Prefix,
-					Labels: createNamespaceLabels(ctx, nsConfig),
-				},
-			}, metav1.CreateOptions{}); err != nil {
-				return nil, err
-			}
+	clusters := ctx.Clusters().Kube()
+	n := &kubeNamespace{
+		ctx:          ctx,
+		prefix:       nsConfig.Prefix,
+		name:         nsConfig.Prefix,
+		cleanupFuncs: make([]func() error, len(clusters)),
+	}
+
+	id := ctx.TrackResource(n)
+	n.id = id
+	name := nsConfig.Prefix
+
+	g := multierror.Group{}
+	for i, cluster := range clusters {
+		i := i
+		cluster := cluster
+		if !kube2.NamespaceExists(cluster, name) {
+			g.Go(func() error {
+				if _, err := cluster.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:   name,
+						Labels: createNamespaceLabels(ctx, nsConfig),
+					},
+				}, metav1.CreateOptions{}); err != nil {
+					return err
+				}
+
+				n.cleanupFuncs[i] = func() error {
+					return cluster.CoreV1().Namespaces().Delete(context.TODO(), name, kube2.DeleteOptionsForeground())
+				}
+				return nil
+			})
 		}
 	}
-	return &kubeNamespace{prefix: nsConfig.Prefix, name: nsConfig.Prefix, ctx: ctx}, nil
+
+	return n, nil
 }
 
 // setNamespaceLabel labels a namespace with the given key, value pair
 func (n *kubeNamespace) setNamespaceLabel(key, value string) error {
 	// need to convert '/' to '~1' as per the JSON patch spec http://jsonpatch.com/#operations
 	jsonPatchEscapedKey := strings.ReplaceAll(key, "/", "~1")
+	name := n.name
+
+	g := multierror.Group{}
 	for _, cluster := range n.ctx.Clusters().Kube() {
+		cluster := cluster
 		nsLabelPatch := fmt.Sprintf(`[{"op":"replace","path":"/metadata/labels/%s","value":"%s"}]`, jsonPatchEscapedKey, value)
-		if _, err := cluster.CoreV1().Namespaces().Patch(context.TODO(), n.name, types.JSONPatchType, []byte(nsLabelPatch), metav1.PatchOptions{}); err != nil {
+		g.Go(func() error {
+			_, err := cluster.CoreV1().Namespaces().Patch(context.TODO(), name, types.JSONPatchType, []byte(nsLabelPatch), metav1.PatchOptions{})
 			return err
-		}
+		})
 	}
 
-	return nil
+	return g.Wait().ErrorOrNil()
 }
 
 // removeNamespaceLabel removes namespace label with the given key
 func (n *kubeNamespace) removeNamespaceLabel(key string) error {
 	// need to convert '/' to '~1' as per the JSON patch spec http://jsonpatch.com/#operations
 	jsonPatchEscapedKey := strings.ReplaceAll(key, "/", "~1")
+	name := n.name
+
+	g := multierror.Group{}
 	for _, cluster := range n.ctx.Clusters().Kube() {
+		cluster := cluster
 		nsLabelPatch := fmt.Sprintf(`[{"op":"remove","path":"/metadata/labels/%s"}]`, jsonPatchEscapedKey)
-		if _, err := cluster.CoreV1().Namespaces().Patch(context.TODO(), n.name, types.JSONPatchType, []byte(nsLabelPatch), metav1.PatchOptions{}); err != nil {
+		g.Go(func() error {
+			_, err := cluster.CoreV1().Namespaces().Patch(context.TODO(), name, types.JSONPatchType, []byte(nsLabelPatch), metav1.PatchOptions{})
 			return err
-		}
+		})
 	}
 
-	return nil
+	return g.Wait().ErrorOrNil()
 }
 
 // NewNamespace allocates a new testing namespace.
@@ -186,30 +233,48 @@ func newKube(ctx resource.Context, nsConfig *Config) (Instance, error) {
 	r := rnd.Intn(99999)
 	mu.Unlock()
 
-	ns := fmt.Sprintf("%s-%d-%d", nsConfig.Prefix, nsid, r)
+	clusters := ctx.Clusters().Kube()
+	name := fmt.Sprintf("%s-%d-%d", nsConfig.Prefix, nsid, r)
 	n := &kubeNamespace{
-		name:   ns,
-		prefix: nsConfig.Prefix,
-		ctx:    ctx,
+		name:         name,
+		prefix:       nsConfig.Prefix,
+		ctx:          ctx,
+		cleanupFuncs: make([]func() error, len(clusters)),
 	}
 	id := ctx.TrackResource(n)
 	n.id = id
 
 	s := ctx.Settings()
-	for _, cluster := range n.ctx.Clusters().Kube() {
-		if _, err := cluster.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:   ns,
-				Labels: createNamespaceLabels(ctx, nsConfig),
-			},
-		}, metav1.CreateOptions{}); err != nil {
-			return nil, err
-		}
-		if s.Image.PullSecret != "" {
-			if err := cluster.ApplyYAMLFiles(n.name, s.Image.PullSecret); err != nil {
-				return nil, err
+	g := multierror.Group{}
+	for i, cluster := range clusters {
+		i := i
+		cluster := cluster
+
+		g.Go(func() error {
+			if _, err := cluster.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:   name,
+					Labels: createNamespaceLabels(ctx, nsConfig),
+				},
+			}, metav1.CreateOptions{}); err != nil {
+				return err
 			}
-		}
+
+			n.cleanupFuncs[i] = func() error {
+				return cluster.CoreV1().Namespaces().Delete(context.TODO(), name, kube2.DeleteOptionsForeground())
+			}
+
+			if s.Image.PullSecret != "" {
+				if err := cluster.ApplyYAMLFiles(n.name, s.Image.PullSecret); err != nil {
+					return err
+				}
+			}
+			return nil
+		})
+	}
+
+	if err := g.Wait().ErrorOrNil(); err != nil {
+		return nil, err
 	}
 
 	return n, nil
diff --git a/pkg/test/framework/components/namespace/namespace.go b/pkg/test/framework/components/namespace/namespace.go
index 5128c95160..3ce580794b 100644
--- a/pkg/test/framework/components/namespace/namespace.go
+++ b/pkg/test/framework/components/namespace/namespace.go
@@ -79,6 +79,15 @@ func NewOrFail(t test.Failer, ctx resource.Context, nsConfig Config) Instance {
 	return i
 }
 
+// GetAll returns all namespaces that have exist in the context.
+func GetAll(ctx resource.Context) ([]Instance, error) {
+	var out []Instance
+	if err := ctx.GetResource(&out); err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
 func overwriteRevisionIfEmpty(nsConfig *Config, revision string) {
 	// Overwrite the default namespace label (istio-injection=enabled)
 	// with istio.io/rev=XXX. If a revision label is already provided,
-- 
2.35.3

