From fb0871c1309ed85504e9c1be6cd349ca453f5d95 Mon Sep 17 00:00:00 2001
From: Yaroslav Skopets <yaroslav@tetrate.io>
Date: Wed, 23 Feb 2022 08:15:07 +0100
Subject: refactoring: reuse `workloadinstances.Index` in
 `serviceregistry/serviceentry` (#37276)

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>
---
 .../serviceentry/servicediscovery.go          | 31 ++++----
 .../pkg/serviceregistry/serviceentry/store.go | 35 ---------
 .../serviceentry/store_test.go                | 75 -------------------
 .../util/workloadinstances/index_test.go      | 70 ++++++++++++++++-
 .../util/workloadinstances/selector.go        | 42 +++++++++++
 5 files changed, 124 insertions(+), 129 deletions(-)
 create mode 100644 pilot/pkg/serviceregistry/util/workloadinstances/selector.go

diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
index 4ad2bf49cb..cd77ea2380 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
@@ -29,6 +29,7 @@
 	"istio.io/istio/pilot/pkg/model/status"
 	"istio.io/istio/pilot/pkg/serviceregistry"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pilot/pkg/serviceregistry/util/workloadinstances"
 	"istio.io/istio/pilot/pkg/util/informermetric"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config"
@@ -81,9 +82,11 @@ type ServiceEntryStore struct {
 	// This lock is to make multi ops on the below stores.
 	// For example, in some case, it requires delete all instances and then update new ones.
 	// TODO: refactor serviceInstancesStore to remove the lock
-	mutex             sync.RWMutex
-	serviceInstances  serviceInstancesStore
-	workloadInstances workloadInstancesStore
+	mutex            sync.RWMutex
+	serviceInstances serviceInstancesStore
+	// NOTE: historically, one index for both WorkloadEntry(s) and Pod(s);
+	//       beware of naming collisions
+	workloadInstances workloadinstances.Index
 	services          serviceStore
 	// to make sure the eds update run in serial to prevent stale ones can override new ones
 	// There are multiple threads calling edsUpdate.
@@ -135,9 +138,7 @@ func NewServiceDiscovery(
 			instances:     map[instancesKey]map[configKey][]*model.ServiceInstance{},
 			instancesBySE: map[types.NamespacedName]map[configKey][]*model.ServiceInstance{},
 		},
-		workloadInstances: workloadInstancesStore{
-			instancesByKey: map[types.NamespacedName]*model.WorkloadInstance{},
-		},
+		workloadInstances: workloadinstances.NewIndex(),
 		services: serviceStore{
 			servicesBySE: map[types.NamespacedName][]*model.Service{},
 		},
@@ -245,10 +246,10 @@ func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event
 
 	s.serviceInstances.deleteInstances(key, instancesDeleted)
 	if event == model.EventDelete {
-		s.workloadInstances.delete(types.NamespacedName{Namespace: curr.Namespace, Name: curr.Name})
+		s.workloadInstances.Delete(wi)
 		s.serviceInstances.deleteInstances(key, instancesUpdated)
 	} else {
-		s.workloadInstances.update(wi)
+		s.workloadInstances.Insert(wi)
 		s.serviceInstances.updateInstances(key, instancesUpdated)
 	}
 	s.mutex.Unlock()
@@ -414,17 +415,11 @@ func (s *ServiceEntryStore) WorkloadInstanceHandler(wi *model.WorkloadInstance,
 
 	// this is from a pod. Store it in separate map so that
 	// the refreshIndexes function can use these as well as the store ones.
-	k := types.NamespacedName{Namespace: wi.Namespace, Name: wi.Name}
 	switch event {
 	case model.EventDelete:
-		if s.workloadInstances.get(k) == nil {
-			// multiple delete events for the same pod (succeeded/failed/unknown status repeating).
-			redundantEventForPod = true
-		} else {
-			s.workloadInstances.delete(k)
-		}
+		redundantEventForPod = s.workloadInstances.Delete(wi) == nil
 	default: // add or update
-		if old := s.workloadInstances.get(k); old != nil {
+		if old := s.workloadInstances.Insert(wi); old != nil {
 			if old.Endpoint.Address != wi.Endpoint.Address {
 				addressToDelete = old.Endpoint.Address
 			}
@@ -435,7 +430,6 @@ func (s *ServiceEntryStore) WorkloadInstanceHandler(wi *model.WorkloadInstance,
 				redundantEventForPod = true
 			}
 		}
-		s.workloadInstances.update(wi)
 	}
 
 	if redundantEventForPod {
@@ -847,7 +841,8 @@ func (s *ServiceEntryStore) buildServiceInstancesForSE(
 	serviceInstancesByConfig := map[configKey][]*model.ServiceInstance{}
 	// for service entry with labels
 	if currentServiceEntry.WorkloadSelector != nil {
-		workloadInstances := s.workloadInstances.listUnordered(curr.Namespace, labels.Collection{currentServiceEntry.WorkloadSelector.Labels})
+		selector := workloadinstances.ByServiceSelector(curr.Namespace, labels.Collection{currentServiceEntry.WorkloadSelector.Labels})
+		workloadInstances := workloadinstances.FindAllInIndex(s.workloadInstances, selector)
 		for _, wi := range workloadInstances {
 			if wi.DNSServiceEntryOnly && currentServiceEntry.Resolution != networking.ServiceEntry_DNS &&
 				currentServiceEntry.Resolution != networking.ServiceEntry_DNS_ROUND_ROBIN {
diff --git a/pilot/pkg/serviceregistry/serviceentry/store.go b/pilot/pkg/serviceregistry/serviceentry/store.go
index 2f60fb551d..492f8a4f58 100644
--- a/pilot/pkg/serviceregistry/serviceentry/store.go
+++ b/pilot/pkg/serviceregistry/serviceentry/store.go
@@ -18,7 +18,6 @@
 	"k8s.io/apimachinery/pkg/types"
 
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pkg/config/labels"
 )
 
 // stores all the service instances from SE, WLE and pods
@@ -100,40 +99,6 @@ func (s *serviceInstancesStore) deleteAllServiceEntryInstances(key types.Namespa
 	delete(s.instancesBySE, key)
 }
 
-// stores all the workload instances from pods or workloadEntries
-type workloadInstancesStore struct {
-	// Stores a map of workload instance name/namespace to workload instance
-	instancesByKey map[types.NamespacedName]*model.WorkloadInstance
-}
-
-func (w *workloadInstancesStore) get(key types.NamespacedName) *model.WorkloadInstance {
-	return w.instancesByKey[key]
-}
-
-func (w *workloadInstancesStore) listUnordered(namespace string, selector labels.Collection) (out []*model.WorkloadInstance) {
-	for _, wi := range w.instancesByKey {
-		if wi.Namespace != namespace {
-			continue
-		}
-		if selector.HasSubsetOf(wi.Endpoint.Labels) {
-			out = append(out, wi)
-		}
-	}
-	return out
-}
-
-func (w *workloadInstancesStore) delete(key types.NamespacedName) {
-	delete(w.instancesByKey, key)
-}
-
-func (w *workloadInstancesStore) update(wi *model.WorkloadInstance) {
-	if wi == nil {
-		return
-	}
-	key := types.NamespacedName{Namespace: wi.Namespace, Name: wi.Name}
-	w.instancesByKey[key] = wi
-}
-
 // stores all the services converted from serviceEntries
 type serviceStore struct {
 	// services keeps track of all services - mainly used to return from Services() to avoid reconversion.
diff --git a/pilot/pkg/serviceregistry/serviceentry/store_test.go b/pilot/pkg/serviceregistry/serviceentry/store_test.go
index d157b8bb36..79c707af56 100644
--- a/pilot/pkg/serviceregistry/serviceentry/store_test.go
+++ b/pilot/pkg/serviceregistry/serviceentry/store_test.go
@@ -23,8 +23,6 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/labels"
-	"istio.io/istio/pkg/spiffe"
 )
 
 func TestServiceInstancesStore(t *testing.T) {
@@ -104,79 +102,6 @@ func TestServiceInstancesStore(t *testing.T) {
 	}
 }
 
-func TestWorkloadInstancesStore(t *testing.T) {
-	// Setup a couple of workload instances for test. These will be selected by the `selector` SE
-	wi1 := &model.WorkloadInstance{
-		Name:      selector.Name,
-		Namespace: selector.Namespace,
-		Endpoint: &model.IstioEndpoint{
-			Address:        "2.2.2.2",
-			Labels:         map[string]string{"app": "wle"},
-			ServiceAccount: spiffe.MustGenSpiffeURI(selector.Name, "default"),
-			TLSMode:        model.IstioMutualTLSModeLabel,
-		},
-	}
-
-	wi2 := &model.WorkloadInstance{
-		Name:      "some-other-name",
-		Namespace: selector.Namespace,
-		Endpoint: &model.IstioEndpoint{
-			Address:        "3.3.3.3",
-			Labels:         map[string]string{"app": "wle"},
-			ServiceAccount: spiffe.MustGenSpiffeURI(selector.Name, "default"),
-			TLSMode:        model.IstioMutualTLSModeLabel,
-		},
-	}
-
-	wi3 := &model.WorkloadInstance{
-		Name:      "another-name",
-		Namespace: dnsSelector.Namespace,
-		Endpoint: &model.IstioEndpoint{
-			Address:        "2.2.2.2",
-			Labels:         map[string]string{"app": "dns-wle"},
-			ServiceAccount: spiffe.MustGenSpiffeURI(dnsSelector.Name, "default"),
-			TLSMode:        model.IstioMutualTLSModeLabel,
-		},
-	}
-	store := workloadInstancesStore{
-		instancesByKey: map[types.NamespacedName]*model.WorkloadInstance{},
-	}
-
-	// test update
-	store.update(wi1)
-	store.update(wi2)
-	store.update(wi3)
-
-	key := types.NamespacedName{
-		Namespace: wi1.Namespace,
-		Name:      wi1.Name,
-	}
-	// test get
-	got := store.get(key)
-	if !reflect.DeepEqual(got, wi1) {
-		t.Errorf("got unexpected workloadinstance %v", got)
-	}
-	workloadinstances := store.listUnordered(selector.Namespace, labels.Collection{{"app": "wle"}})
-	expected := map[string]*model.WorkloadInstance{
-		wi1.Name: wi1,
-		wi2.Name: wi2,
-	}
-	if len(workloadinstances) != 2 {
-		t.Errorf("got unexpected workload instance %v", workloadinstances)
-	}
-	for _, wi := range workloadinstances {
-		if !reflect.DeepEqual(expected[wi.Name], wi) {
-			t.Errorf("got unexpected workload instance %v", wi)
-		}
-	}
-
-	store.delete(key)
-	got = store.get(key)
-	if got != nil {
-		t.Errorf("workloadInstance %v was not deleted", got)
-	}
-}
-
 func TestServiceStore(t *testing.T) {
 	store := serviceStore{
 		servicesBySE: map[types.NamespacedName][]*model.Service{},
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go b/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
index 03f11e3048..e1fa734668 100644
--- a/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/index_test.go
@@ -23,6 +23,7 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/spiffe"
 )
@@ -51,7 +52,7 @@
 }
 
 func TestIndex(t *testing.T) {
-	// Setup a couple of workload instances for test. These will be selected by the `selector` SE
+	// Setup a couple of workload instances for test
 	wi1 := &model.WorkloadInstance{
 		Name:      selector.Name,
 		Namespace: selector.Namespace,
@@ -132,3 +133,70 @@ func TestIndex(t *testing.T) {
 
 	verifyGetByIP("1.1.1.1", nil)
 }
+
+func TestIndex_FindAll(t *testing.T) {
+	// Setup a couple of workload instances for test. These will be selected by the `selector` SE
+	wi1 := &model.WorkloadInstance{
+		Name:      selector.Name,
+		Namespace: selector.Namespace,
+		Endpoint: &model.IstioEndpoint{
+			Address: "2.2.2.2",
+			Labels:  map[string]string{"app": "wle"}, // should match
+		},
+	}
+
+	wi2 := &model.WorkloadInstance{
+		Name:      "same-ip",
+		Namespace: selector.Namespace,
+		Endpoint: &model.IstioEndpoint{
+			Address: "2.2.2.2",
+			Labels:  map[string]string{"app": "wle"}, // should match
+		},
+	}
+
+	wi3 := &model.WorkloadInstance{
+		Name:      "another-ip",
+		Namespace: selector.Namespace,
+		Endpoint: &model.IstioEndpoint{
+			Address: "3.3.3.3",
+			Labels:  map[string]string{"app": "another-wle"}, // should not match because of another label
+		},
+	}
+
+	wi4 := &model.WorkloadInstance{
+		Name:      "another-name",
+		Namespace: "another-namespace", // should not match because of another namespace
+		Endpoint: &model.IstioEndpoint{
+			Address: "2.2.2.2",
+			Labels:  map[string]string{"app": "wle"},
+		},
+	}
+
+	index := NewIndex()
+
+	// test update
+	index.Insert(wi1)
+	index.Insert(wi2)
+	index.Insert(wi3)
+	index.Insert(wi4)
+
+	// test search by service selector
+	actual := FindAllInIndex(index, ByServiceSelector(selector.Namespace, labels.Collection{{"app": "wle"}}))
+
+	want := []*model.WorkloadInstance{wi1, wi2}
+
+	if diff := cmp.Diff(len(want), len(actual)); diff != "" {
+		t.Errorf("FindAllInIndex() returned unexpected number of workload instances (--want/++got): %v", diff)
+	}
+
+	got := map[string]*model.WorkloadInstance{}
+	for _, instance := range actual {
+		got[instance.Name] = instance
+	}
+
+	for _, expected := range want {
+		if diff := cmp.Diff(expected, got[expected.Name]); diff != "" {
+			t.Fatalf("FindAllInIndex() returned unexpected workload instance %q (--want/++got): %v", expected.Name, diff)
+		}
+	}
+}
diff --git a/pilot/pkg/serviceregistry/util/workloadinstances/selector.go b/pilot/pkg/serviceregistry/util/workloadinstances/selector.go
new file mode 100644
index 0000000000..2935560877
--- /dev/null
+++ b/pilot/pkg/serviceregistry/util/workloadinstances/selector.go
@@ -0,0 +1,42 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package workloadinstances
+
+import (
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config/labels"
+)
+
+// ByServiceSelector returns a predicate that matches workload instances
+// of a given service.
+func ByServiceSelector(namespace string, selector labels.Collection) func(*model.WorkloadInstance) bool {
+	return func(wi *model.WorkloadInstance) bool {
+		return wi.Namespace == namespace && selector.HasSubsetOf(wi.Endpoint.Labels)
+	}
+}
+
+// FindAllInIndex returns a list of workload instances in the index
+// that match given predicate.
+//
+// The returned list is not ordered.
+func FindAllInIndex(index Index, predicate func(*model.WorkloadInstance) bool) []*model.WorkloadInstance {
+	var instances []*model.WorkloadInstance
+	index.ForEach(func(instance *model.WorkloadInstance) {
+		if predicate(instance) {
+			instances = append(instances, instance)
+		}
+	})
+	return instances
+}
-- 
2.35.3

