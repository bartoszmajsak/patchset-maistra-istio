From d0748d7c46c02e1fddf77d7a38f90cb3620e4358 Mon Sep 17 00:00:00 2001
From: Mitch Connors <mitchconnors@gmail.com>
Date: Wed, 17 Nov 2021 04:28:05 -0800
Subject: Refactor Analysis to remove dependency on galley (#35764)

* create analyzer interface

Change-Id: Id19fedce4a2a8ce2fc84752a53bdfe039f6d1d24

* First possibly working implementation

Change-Id: I083ba4bef7fed5f6e93b9755a7a2ffeb6be0e73f

* not working

Change-Id: I0b0530f96e3a6b51c0682d9397bbada34199816a

* mostly passing

Change-Id: I798957ea32adbe067626101e2b8753ef620a01e6

* all tests pass

Change-Id: I91f2d4af06188c83be7c93f1dae5604437c1cb1f

* move istiod analyzer to /pkg

Change-Id: I0f0ef811ab75fcef64c7d35c2c466025f26be50f

* removing galley references

Change-Id: Icee6ceae5c487d26ed108743ed1b90bc1a046787

* removing last vestiges of galley

Change-Id: I020690d12ffa12cc979120ff4eebe17c95fe7d14

* tests passing again

Change-Id: I8ccad8bbff6f841bb54e1e95ff31ace167d06e42

* remove test dependencies on instances

Change-Id: I2a9efa2fa63c72a2d9441647f6554e5c3438bbac

* fmt

Change-Id: I04efe179a6503133e9c8c0ffcbcfda36776c9357

* update mod, remove dot

Change-Id: Ifbce09ec30f77ab61d98af0d0c77d224dbdce630

* remove unnecessary aliases

Change-Id: I5d26b3b39d1e3839feb77aacdad7b41deb21a5dc

* something fishy

Change-Id: I399053d2ec6586e515500a8fb8bf2cc3bd0df32c

* fix accidental change to crdclient

Change-Id: I5e96d10d63d02e2682066bd0633aa51ed6c688ba

* minor tweaks

Change-Id: I81a884c75a08919a82b9c89d15a76e8de1d5f545

* fix test schemas

Change-Id: Ic7f8d664c4911232f9ad42805001eb09058f8ae9

* remove reference to deleted fuzz test

Change-Id: I25d989310d393015135a76da2f9516066bf67b06

* fix some lint errors

Change-Id: I73ee2ffaf5c6639f548da9c749ae5a95f1cd0f08

* revert crdclient and config monitor changes as they are unneeded

Change-Id: I5cf6ac4c4c1bc8c9e2181490a1901e2b772fd762

* reset unneeded context changes

Change-Id: I4e4399ba5550f058f1c469ee4ab6a94d71d8c614

* avoid nil stores

Change-Id: Ida3197f3d392c7b1ea294d8d6b8a56ca736831b1

* skip unwachable resources

Change-Id: Ia64cf8e821a4aa0b95764da5f007f82ac875d804

* fix fmt

Change-Id: I2af63103bbc1e043a4582009e383215e3343fadc

* non-functional iteration towards analysis in status

Change-Id: I3012725751fcb6d8b9af74df0c07e81512da6fc3

* rename status lib

Change-Id: Ia38d2818c7f886828e78a06ee6aa32e3800f7713

* create status manager

Change-Id: Iaa61d975b7766bd6d550c335c075f93a6e049af4

* fix incluster analysis

Change-Id: I348f7c98e74bde21a9b26c1412b81cddcc969cee

* fmt

Change-Id: Ia39a936082f47e14df3a599295ad8aa49fb89250

* fix refactor errors in jwt analyze

Change-Id: I385752e0190b9e8a2f0c3516e0870b9885a5159e

* fix more jwt analyzer rebase stuff

Change-Id: I93f0ead312113d450fac71b421b5023be414ac5d

* add missing file

Change-Id: I97faca5fce865be30f1f4f2bf44b25d5918a6aa5

* fix copied test

Change-Id: I984826a48c5ecb44e916bb2f62efed4d85ebd63e

* fmt

Change-Id: I9708b009a588bfafddfa753a2f90a6c2438e46d8

* fix lint errors

Change-Id: I78a57f2b0c3e4a2d5486c3d39fecabfdbc1a6d47

* fix bad tests

Change-Id: Ib3642c6afa37bca40f6226168fbbf87dc2f05391

* Add fieldmaps back to file store

Change-Id: If93a9868a4de92e4510b761c78591e0055fe67e7

* prevent nil panic

Change-Id: Ica49683f39a2465523e13cca580eacf12d2893fe

* allow multiple crdclients to exist

Change-Id: I3b27e772dbb099c73d0f5538d5dcd81d9ecf6a69

* fix gateway class status

Change-Id: I15d563c190f0b4b3fd9638fdc0b8257eaf1dea2d

* fix startup order

Change-Id: I4293afac3c4d8ffba1cd57e6db9ad02e54e73cde

* fix typo

Change-Id: Ic43a6db0ecfc2cdad5f15f6c0d11cd7fb4a9d11e

* make operator obey image pull policy

Change-Id: I3f10d25f78df0ecfba0289341c131bdf67e821e1

* always pull operator image

Change-Id: I619984554dd23a26815efa836b5b0f7fa4248ad2

* gen

Change-Id: I44b85ada91e270a84eaa6e55bb6d27d17da46538

* dont skip disabled cols

Change-Id: I91c6967c181381129d5240a3f9567ca054b94cb8

* mod tidy

Change-Id: I3d6bf3a75d0694985e49adb15f8c87d26bedcfed

* try to dump operator

Change-Id: Ia7fa6999d1e1e3a231126180293b89781a10a2e5

* lint dumper

Change-Id: Ib83a4f42181084de27b18c85777605f0e0da1ac2

* Revert "dont skip disabled cols"

This reverts commit dea7c7753456817f52e77a2cea2c629f92fbb013.

* try fix remove skipped

Change-Id: Ic625220c54194b9c72ae0781a9b1cf4388bb566e

* build equivalence into skipping analyzers

Change-Id: I40845214a66363c8f6bfce063f60a561ac3a2f73

* fix unstructured test

Change-Id: Ia16b77837206cf344121bd98877011d318cabb7c

* tidy up

Change-Id: I9a44d755395ee72a36e9cbbb098b0c495a78ff70

* lint

Change-Id: I9a80c2ec2861fdbd2146c5f9ad7d6cf7393549ef

* analyzer fuzzer no longer fails

Change-Id: Ia133bd40079480876a3948a45068a70d3b9fc952

* remove last galley reference

Change-Id: I14db369fe2ef923f6873f601f6807f2b2a5b488d

* fix default log level

Change-Id: I00df74bfa3d9d0a6623cd3534bd0569ad0bff861

* remove galley

Change-Id: I55252807a3bc72cf3e263dca31b075178e3b4b18

* remove hanging reference

Change-Id: Ia26e72b45ddd6fd103d2f7ed6b9b8a2f734c8dd3

* fix readme lint

Change-Id: Ib7e045a96ce24cea093c10c0d132533dfc3a1834

* remove galley from makefile

Change-Id: I11d7c8cc3377cd2abdd9c3c7ebbe0d7e4e72f2fc

* remove mistake file

Change-Id: I1c612cfa71136dfe1d4f97085067391dcca091c0

* dedupe watches

Change-Id: Ia830c7da0f80c46fa45a521705d123ef8da9080b

* implement requested changes

Change-Id: If376446a1d735d774452ad68d396d3ab4218ad11

* fix unit failure

Change-Id: Ib181362656c53de48cf3474811ecb7debf87022d

* move distribution status to manager model

Change-Id: Ide44b5650b1e3173469417267e1edc83223386eb

* remove distribution.ResourceLock

Change-Id: I52f4cbd63082aa889536a2d6b75bb11c6ea695dd

* revert manifest pullpolicy

Change-Id: Id31c4f6dbadbdaf766b6920a6c304192fd6795dd

* fix build errors

Change-Id: I2bafd245029564c26dd9e7323dbe6698d1798c02

* pr feedback

Change-Id: I754c01eaccf615e3c0d6be7edc533b6ea4f61f52

* fix status manager tests

Change-Id: Iaca3ff18b68874f30efc39b2ccf6f357bc2ddf54

* fix more build errors

Change-Id: I5982561c1395efa6a08c8d8a5b5ec2283d2dd617

* fix test build errors

Change-Id: Ibb31cc3f81eac86ab2db10594dc9a0d2083fabde

* fix lint errors

Change-Id: I01e702e16c373eca3f98243ef6080bf209693ef6

* fix status control test failure

Change-Id: I62c7e9f1d3e8efdade65b28643d173afedfa4cdf

* Fix in-cluster status

Change-Id: I1c8427a47b419e0655f51f23d5a625822befcf8e

* fix default ns

Change-Id: Iee080ce6246c2bd1666eb04c32f1389252a6b756

* unfix default ns for helm reconciler

Change-Id: I2834369443040ff008526c456baa3aefd0f9165d

* allow status pkg for non-istio types

Change-Id: Ib7abb624e877f5180587b5655196cc92aba7e728

* Revert "fix default ns"

This reverts commit 00935dee

Change-Id: I191d984dbb65354906d10c69886d4063cc0e1bb2

* remove vestiges of default ns

Change-Id: I052d08eef48e9f37a232c543d15fd74cc695331c

* address feedback

Change-Id: Ife50aa66c1fc0b12f31e86ee1e545d622ca6e16c
---
 Makefile.core.mk                              |   2 +-
 galley/README.md                              |  10 -
 galley/pkg/config/analysis/local/analyze.go   | 381 ------------
 .../pkg/config/analysis/local/helpers_test.go |  51 --
 galley/pkg/config/analysis/local/source.go    | 160 -----
 .../pkg/config/analysis/local/source_test.go  | 115 ----
 galley/pkg/config/collection/instance.go      | 134 -----
 galley/pkg/config/collection/instance_test.go | 155 -----
 galley/pkg/config/collection/set.go           |  83 ---
 galley/pkg/config/collection/set_test.go      |  92 ---
 galley/pkg/config/mesh/defaults.go            |  33 -
 galley/pkg/config/mesh/fs.go                  | 149 -----
 galley/pkg/config/mesh/fs_test.go             | 453 --------------
 galley/pkg/config/mesh/inmemory.go            | 156 -----
 galley/pkg/config/mesh/inmemory_test.go       | 237 --------
 galley/pkg/config/mesh/metadata_test.go       |  30 -
 galley/pkg/config/monitoring/monitoring.go    | 253 --------
 galley/pkg/config/processing/processor.go     |  29 -
 galley/pkg/config/processing/runtime.go       | 164 -----
 galley/pkg/config/processing/runtime_test.go  | 467 ---------------
 galley/pkg/config/processing/session.go       | 313 ----------
 .../snapshotter/analyzingdistributor.go       | 279 ---------
 .../snapshotter/analyzingdistributor_test.go  | 542 -----------------
 .../processing/snapshotter/distributor.go     |  82 ---
 .../snapshotter/distributor_test.go           |  75 ---
 .../config/processing/snapshotter/snapshot.go | 115 ----
 .../processing/snapshotter/snapshot_test.go   |  75 ---
 .../processing/snapshotter/snapshotoptions.go |  34 --
 .../processing/snapshotter/snapshotter.go     | 268 ---------
 .../snapshotter/snapshotter_test.go           | 155 -----
 .../processing/snapshotter/statusupdater.go   |  88 ---
 .../snapshotter/statusupdater_test.go         | 105 ----
 .../processing/snapshotter/strategy/create.go |  34 --
 .../snapshotter/strategy/create_test.go       |  47 --
 .../snapshotter/strategy/debounce.go          | 191 ------
 .../snapshotter/strategy/debounce_test.go     | 222 -------
 .../snapshotter/strategy/immediate.go         |  57 --
 .../snapshotter/strategy/immediate_test.go    |  40 --
 .../snapshotter/strategy/instance.go          |  26 -
 galley/pkg/config/processor/build.go          |  89 ---
 galley/pkg/config/processor/build_test.go     |  83 ---
 galley/pkg/config/processor/groups/groups.go  |  30 -
 .../config/processor/groups/groups_test.go    |  29 -
 galley/pkg/config/scope/scopes.go             |  28 -
 .../pkg/config/source/inmemory/collection.go  | 169 ------
 .../config/source/inmemory/collection_test.go | 211 -------
 galley/pkg/config/source/inmemory/source.go   | 117 ----
 .../pkg/config/source/inmemory/source_test.go | 276 ---------
 .../config/source/kube/apiserver/options.go   |  37 --
 .../config/source/kube/apiserver/source.go    | 289 ---------
 .../kube/apiserver/source_builtin_test.go     | 415 -------------
 .../kube/apiserver/source_dynamic_test.go     | 567 ------------------
 .../source/kube/apiserver/stats/stats.go      | 117 ----
 .../kube/apiserver/status/controller.go       | 217 -------
 .../kube/apiserver/status/controller_test.go  | 394 ------------
 .../source/kube/apiserver/status/messages.go  |  46 --
 .../source/kube/apiserver/status/state.go     | 233 -------
 .../kube/apiserver/status/state_test.go       | 291 ---------
 .../source/kube/apiserver/status/status.go    |  94 ---
 .../source/kube/apiserver/status/util.go      |  38 --
 .../kube/apiserver/tombstone/recover.go       |  51 --
 .../kube/apiserver/tombstone/recover_test.go  |  53 --
 .../config/source/kube/apiserver/watcher.go   | 143 -----
 .../source/kube/inmemory/kubesource_test.go   | 413 -------------
 galley/pkg/config/source/kube/interfaces.go   |  96 ---
 .../pkg/config/source/kube/interfaces_test.go |  49 --
 galley/pkg/config/source/kube/rt/adapter.go   | 126 ----
 galley/pkg/config/source/kube/rt/dynamic.go   | 112 ----
 .../pkg/config/source/kube/rt/dynamic_test.go | 107 ----
 galley/pkg/config/source/kube/rt/extract.go   |  58 --
 galley/pkg/config/source/kube/rt/known.go     | 520 ----------------
 .../pkg/config/source/kube/rt/known_test.go   | 213 -------
 .../pkg/config/source/kube/rt/origin_test.go  |  64 --
 galley/pkg/config/source/kube/rt/provider.go  | 114 ----
 galley/pkg/config/source/mcp/origin.go        |  57 --
 galley/pkg/config/source/mcp/origin_test.go   |  31 -
 galley/pkg/config/util/pb/proto.go            |  46 --
 galley/pkg/config/util/pb/proto_test.go       |  75 ---
 galley/pkg/server/components/patchtable.go    |  37 --
 galley/pkg/server/components/processing.go    | 167 ------
 .../pkg/server/components/processing_test.go  | 102 ----
 galley/pkg/server/settings/args.go            |  94 ---
 galley/pkg/server/settings/args_test.go       |  39 --
 galley/pkg/testing/mock/watch.go              | 132 ----
 go.mod                                        |   6 +-
 go.sum                                        |  17 +-
 istioctl/cmd/analyze.go                       |  26 +-
 istioctl/cmd/analyze_test.go                  |   2 +-
 istioctl/cmd/injector-list.go                 |   4 +-
 istioctl/cmd/precheck.go                      |  21 +-
 istioctl/cmd/remove-from-mesh.go              |   8 +-
 istioctl/cmd/root.go                          |   2 +-
 istioctl/cmd/tag.go                           |  14 +-
 istioctl/pkg/util/formatting/formatter.go     |   2 +-
 .../pkg/util/formatting/formatter_test.go     |   2 +-
 istioctl/pkg/util/formatting/msg_threshold.go |   2 +-
 operator/cmd/mesh/manifest-generate_test.go   |   2 +-
 operator/pkg/helmreconciler/reconciler.go     |  15 +-
 pilot/pkg/bootstrap/configcontroller.go       |  62 +-
 pilot/pkg/bootstrap/server.go                 |  12 +-
 pilot/pkg/config/aggregate/config_test.go     |   2 +-
 .../pkg/config/file/store.go                  | 268 ++++++---
 .../config/file}/util/kubeyaml/kubeyaml.go    |   0
 .../file}/util/kubeyaml/kubeyaml_test.go      |   0
 .../pkg/config/kube/arbitraryclient/client.go | 491 +++++++++++++++
 pilot/pkg/config/kube/crd/conversion_test.go  |  12 +-
 pilot/pkg/config/kube/crdclient/client.go     |  22 +-
 pilot/pkg/config/kube/gateway/controller.go   |  38 +-
 .../config/kube/gateway/generation_adapter.go |  32 +
 pilot/pkg/networking/apigen/apigen.go         |  32 +-
 .../status/{ => distribution}/leak_test.go    |   2 +-
 pilot/pkg/status/{ => distribution}/ledger.go |   2 +-
 .../pkg/status/distribution/report.go         |  25 +-
 .../status/{ => distribution}/report_test.go  |  10 +-
 .../pkg/status/{ => distribution}/reporter.go |  34 +-
 .../{ => distribution}/reporter_test.go       |   7 +-
 .../pkg/status/distribution/resourcelock.go   |   8 +-
 pilot/pkg/status/{ => distribution}/state.go  | 127 ++--
 .../status/{ => distribution}/state_test.go   |  27 +-
 pilot/pkg/status/manager.go                   | 125 ++++
 pilot/pkg/status/{report.go => resource.go}   |  96 ++-
 pilot/pkg/status/resourcelock.go              |  91 ++-
 pilot/pkg/status/resourcelock_test.go         |  32 +-
 {galley/pkg => pkg}/config/analysis/README.md |   0
 .../pkg => pkg}/config/analysis/analyzer.go   |  11 +-
 .../config/analysis/analyzer_test.go          |  55 +-
 .../config/analysis/analyzers/all.go          |  30 +-
 .../analyzers/analyzers_bench_test.go         | 116 +---
 .../analysis/analyzers/analyzers_test.go      |  52 +-
 .../analyzers/annotations/annotations.go      |   6 +-
 .../analyzers/authz/authorizationpolicies.go  |  17 +-
 .../authz/authorizationpolicies_test.go       |   0
 .../analysis/analyzers/deployment/pod.go      |  18 +-
 .../analysis/analyzers/deployment/services.go |  27 +-
 .../analyzers/deprecation/deprecation.go      |   4 +-
 .../destinationrule/ca-certificates.go        |   6 +-
 .../analysis/analyzers/gateway/certificate.go |   6 +-
 .../analyzers/gateway/conflictinggateway.go   |   6 +-
 .../analysis/analyzers/gateway/gateway.go     |  11 +-
 .../analysis/analyzers/gateway/secret.go      |  10 +-
 .../analyzers/injection/image-auto.go         |  20 +-
 .../analyzers/injection/injection-image.go    |  12 +-
 .../analysis/analyzers/injection/injection.go |  14 +-
 .../analysis/analyzers/maturity/maturity.go   |   6 +-
 .../analyzers/multicluster/meshnetworks.go    |   6 +-
 .../analysis/analyzers/schema/validation.go   |   6 +-
 .../analyzers/schema/validation_test.go       |   4 +-
 .../analysis/analyzers/service/portname.go    |   6 +-
 .../serviceentry/protocoladresses.go          |   6 +-
 .../analyzers/sidecar/defaultselector.go      |   4 +-
 .../analysis/analyzers/sidecar/selector.go    |  10 +-
 .../config/analysis/analyzers/sidecar/util.go |   0
 .../testdata/authorizationpolicies.yaml       |   0
 .../testdata/common/meshnetworks.yaml         |   0
 .../common/sidecar-injector-configmap.yaml    |   0
 .../sidecar-injector-enabled-nsbydefault.yaml |   0
 .../testdata/conflicting-gateways.yaml        |   0
 .../testdata/deployment-con-sec-uid.yaml      |   0
 ...deployment-multi-service-different-ns.yaml |   0
 .../testdata/deployment-multi-service.yaml    |   0
 .../testdata/deployment-pod-sec-uid.yaml      |   0
 .../analyzers/testdata/deprecation.yaml       |   0
 ...estinationrule-compound-mutual-simple.yaml |   0
 ...estinationrule-compound-simple-mutual.yaml |   0
 .../destinationrule-mutual-destination.yaml   |   0
 .../testdata/destinationrule-mutual-port.yaml |   0
 .../destinationrule-simple-destination.yaml   |   0
 .../testdata/destinationrule-simple-port.yaml |   0
 .../testdata/destinationrule-with-ca.yaml     |   0
 .../testdata/gateway-correct-port.yaml        |   0
 ...gateway-custom-ingressgateway-badport.yaml |   0
 ...way-custom-ingressgateway-svcselector.yaml |   0
 .../gateway-custom-ingressgateway.yaml        |   0
 .../gateway-duplicate-certificate.yaml        |   0
 .../analyzers/testdata/gateway-no-port.yaml   |   0
 .../testdata/gateway-no-workload.yaml         |   0
 .../analyzers/testdata/gateway-secrets.yaml   |   0
 .../analyzers/testdata/image-auto.yaml        |   0
 .../injection-with-mismatched-sidecar.yaml    |   0
 .../analyzers/testdata/injection.yaml         |   0
 .../testdata/mesh-with-automtls.yaml          |   0
 .../analyzers/testdata/misannotated.yaml      |   0
 .../analyzers/testdata/mtls-exports.yaml      |   0
 .../mtls-global-dr-no-meshpolicy.yaml         |   0
 .../mtls-ignores-istio-control-plane.yaml     |   0
 .../mtls-ignores-system-namespaces.yaml       |   0
 .../testdata/mtls-meshpolicy-permissive.yaml  |   0
 .../analyzers/testdata/mtls-meshpolicy.yaml   |   0
 .../analyzers/testdata/mtls-no-dr.yaml        |   0
 .../analyzers/testdata/mtls-no-policy.yaml    |   0
 .../analyzers/testdata/mtls-no-sidecar.yaml   |   0
 .../analyzers/testdata/mtls-with-port.yaml    |   0
 .../multicluster-unknown-serviceregistry.yaml |   0
 .../testdata/peerauthentication-crd.yaml      |   0
 .../analyzers/testdata/pod-con-sec-uid.yaml   |   0
 .../analyzers/testdata/pod-sec-uid.yaml       |   0
 ...service-no-port-name-system-namespace.yaml |   0
 .../testdata/service-no-port-name.yaml        |   0
 .../analyzers/testdata/service-port-name.yaml |   0
 ...rviceentry-missing-addresses-protocol.yaml |   0
 .../testdata/sidecar-default-selector.yaml    |   0
 ...-injector-configmap-absolute-override.yaml |   0
 ...jector-configmap-with-revision-canary.yaml |   0
 .../analyzers/testdata/sidecar-selector.yaml  |   0
 ...alservice_conflictingmeshgatewayhosts.yaml |   0
 .../virtualservice_destinationhosts.yaml      |   0
 .../virtualservice_destinationrules.yaml      |   0
 .../testdata/virtualservice_dupmatches.yaml   |   0
 .../testdata/virtualservice_gateways.yaml     |   0
 ...virtualservice_host_not_found_gateway.yaml |   0
 ...host_not_found_gateway_with_ns_prefix.yaml |   0
 .../virtualservice_jwtclaimroute.yaml         |   0
 .../virtualservice_overlappingmatches.yaml    |   0
 .../testdata/virtualservice_regexes.yaml      |   0
 ...service_route_rule_no_effects_ingress.yaml |   0
 .../analysis/analyzers/testdata/webhook.yaml  |   0
 .../config/analysis/analyzers/util/config.go  |   0
 .../analysis/analyzers/util/constants.go      |   0
 .../analysis/analyzers/util/exportto.go       |   0
 .../analysis/analyzers/util/exportto_test.go  |   0
 .../analyzers/util/find_errorline_utils.go    |   2 +-
 .../util/find_errorline_utils_test.go         |   4 +-
 .../config/analysis/analyzers/util/hosts.go   |   0
 .../analysis/analyzers/util/hosts_test.go     |   0
 .../config/analysis/analyzers/util/in_mesh.go |  10 +-
 .../analysis/analyzers/util/service_lookup.go |   2 +-
 .../conflictingmeshgatewayhosts.go            |   6 +-
 .../virtualservice/destinationhosts.go        |   6 +-
 .../virtualservice/destinationrules.go        |   6 +-
 .../analyzers/virtualservice/gateways.go      |   6 +-
 .../analyzers/virtualservice/jwtclaimroute.go |  14 +-
 .../analyzers/virtualservice/regexes.go       |   6 +-
 .../analysis/analyzers/virtualservice/util.go |   0
 .../analysis/analyzers/webhook/webhook.go     |   4 +-
 .../pkg => pkg}/config/analysis/context.go    |   2 +-
 .../config/analysis/diag/helper.go            |   0
 .../pkg => pkg}/config/analysis/diag/level.go |   0
 .../config/analysis/diag/message.go           |  12 +-
 .../config/analysis/diag/message_test.go      |   4 +-
 .../config/analysis/diag/messages.go          |   0
 .../config/analysis/diag/messages_test.go     |   0
 pkg/config/analysis/equivalence.go            |  74 +++
 pkg/config/analysis/incluster/controller.go   | 125 ++++
 .../config/analysis/local/analyze_test.go     | 148 +++--
 pkg/config/analysis/local/context.go          | 202 +++++++
 .../config/analysis/local/defaults.go         |   0
 pkg/config/analysis/local/helpers_test.go     |  80 +++
 pkg/config/analysis/local/istiod_analyze.go   | 493 +++++++++++++++
 pkg/config/analysis/local/local.go            |  34 ++
 .../pkg => pkg}/config/analysis/metadata.go   |   0
 .../config/analysis/msg/generate.main.go      |   2 +-
 .../config/analysis/msg/messages.gen.go       |   2 +-
 .../config/analysis/msg/messages.go           |   4 +-
 .../config/analysis/msg/messages.yaml         |   0
 pkg/config/analysis/scope/scope.go            |  26 +
 .../analysis/testing/fixtures/context.go      |   4 +-
 pkg/config/conversion.go                      |  50 ++
 pkg/config/event/buffer.go                    |   2 +-
 pkg/config/event/buffer_test.go               |   4 +-
 pkg/config/event/event_test.go                |   2 +-
 pkg/config/event/handlers_test.go             |   4 +-
 pkg/config/event/router.go                    |   2 +-
 pkg/config/event/router_test.go               |   6 +-
 pkg/config/event/source_test.go               |   2 +-
 pkg/config/event/transformer.go               |   2 +-
 pkg/config/event/transformer_test.go          |   4 +-
 .../config/legacy}/mesh/const.go              |   0
 pkg/config/legacy/processing/processor.go     |  25 +
 .../processing/transformer/provider.go        |  15 +-
 .../processing/transformer/provider_test.go   |   8 +-
 .../processor/transforms/direct/create.go     |   2 +-
 .../transforms/direct/create_test.go          |  12 +-
 .../processor/transforms/transforms.go        |   4 +-
 .../config/legacy/source/kube}/origin.go      |  32 +-
 .../testing/basicmeta/basicmeta.gen.go        |   0
 .../legacy}/testing/basicmeta/basicmeta.yaml  |   0
 .../legacy}/testing/basicmeta/basicmeta2.yaml |   0
 .../testing/basicmeta/collections.gen.go      |   0
 .../legacy}/testing/basicmeta/generate.go     |   2 +-
 .../config/legacy}/testing/basicmeta/get.go   |   0
 .../legacy}/testing/data/builtin.gen.go       |   0
 .../config/legacy}/testing/data/builtin.go    |   0
 .../testing/data/builtin/deployment.yaml      |   0
 .../testing/data/builtin/endpoints.yaml       |   0
 .../legacy}/testing/data/builtin/ingress.yaml |   0
 .../testing/data/builtin/namespace.yaml       |   0
 .../legacy}/testing/data/builtin/node.yaml    |   0
 .../legacy}/testing/data/builtin/pod.yaml     |   0
 .../legacy}/testing/data/builtin/service.yaml |   0
 .../legacy}/testing/data/collections.go       |   2 +-
 .../config/legacy}/testing/data/events.go     |   2 +-
 .../config/legacy}/testing/data/resources.go  |   2 +-
 .../config/legacy}/testing/data/yaml.go       |  11 -
 .../legacy}/testing/fixtures/accumulator.go   |   0
 .../testing/fixtures/accumulator_test.go      |   2 +-
 .../config/legacy}/testing/fixtures/expect.go |   0
 .../legacy}/testing/fixtures/expect_test.go   |   6 +-
 .../legacy}/testing/fixtures/filters.go       |   0
 .../legacy}/testing/fixtures/filters_test.go  |   4 +-
 .../legacy}/testing/fixtures/listener.go      |   0
 .../legacy}/testing/fixtures/listener_test.go |   2 +-
 .../config/legacy}/testing/fixtures/source.go |   0
 .../legacy}/testing/fixtures/source_test.go   |   2 +-
 .../legacy}/testing/fixtures/transformer.go   |   0
 .../testing/k8smeta/collections.gen.go        |   0
 .../legacy}/testing/k8smeta/generate.go       |   2 +-
 .../config/legacy}/testing/k8smeta/get.go     |   5 +
 .../legacy}/testing/k8smeta/k8smeta.gen.go    |   0
 .../legacy}/testing/k8smeta/k8smeta.yaml      |   0
 .../legacy}/util/kuberesource/resources.go    |  40 +-
 pkg/config/mesh/mesh.go                       |   7 +
 pkg/config/resource/metadata.go               |   1 +
 pkg/config/resource/serialization_test.go     |   2 +-
 pkg/config/schema/collection/names_test.go    |   4 +-
 pkg/config/schema/collection/schemas.go       |  21 +
 .../schema/collections/collections_test.go    |  28 -
 pkg/config/schema/collections_test.go         |  31 +
 pkg/config/schema/get.go                      |  27 +
 pkg/config/schema/schema_test.go              |   2 +-
 .../test/datasets}/Readme.md                  |   2 +
 .../test/datasets}/validation/dataset.go      |   0
 ...xtensions-v1alpha1-WasmPlugin-invalid.yaml |   0
 .../extensions-v1alpha1-WasmPlugin-valid.yaml |   0
 ...king-v1alpha3-DestinationRule-invalid.yaml |   0
 ...orking-v1alpha3-DestinationRule-valid.yaml |   0
 ...tworking-v1alpha3-EnvoyFilter-invalid.yaml |   0
 ...networking-v1alpha3-EnvoyFilter-valid.yaml |   0
 .../networking-v1alpha3-Gateway-invalid.yaml  |   0
 .../networking-v1alpha3-Gateway-valid.yaml    |   0
 ...working-v1alpha3-ServiceEntry-invalid.yaml |   0
 ...etworking-v1alpha3-ServiceEntry-valid.yaml |   0
 .../networking-v1alpha3-Sidecar-invalid.yaml  |   0
 .../networking-v1alpha3-Sidecar-valid.yaml    |   0
 ...rking-v1alpha3-VirtualService-invalid.yaml |   0
 ...1alpha3-VirtualService-regexp-invalid.yaml |   0
 ...working-v1alpha3-VirtualService-valid.yaml |   0
 ...orking-v1alpha3-WorkloadEntry-invalid.yaml |   0
 ...tworking-v1alpha3-WorkloadEntry-valid.yaml |   0
 ...orking-v1alpha3-WorkloadGroup-invalid.yaml |   0
 ...tworking-v1alpha3-WorkloadGroup-valid.yaml |   0
 ...orking-v1beta-DestinationRule-invalid.yaml |   0
 ...tworking-v1beta-DestinationRule-valid.yaml |   0
 .../networking-v1beta-Gateway-invalid.yaml    |   0
 .../networking-v1beta-Gateway-valid.yaml      |   0
 .../networking-v1beta-Sidecar-invalid.yaml    |   0
 .../networking-v1beta-Sidecar-valid.yaml      |   0
 ...working-v1beta-VirtualService-invalid.yaml |   0
 ...etworking-v1beta-VirtualService-valid.yaml |   0
 ...tworking-v1beta-WorkloadEntry-invalid.yaml |   0
 ...networking-v1beta-WorkloadEntry-valid.yaml |   0
 ...etworking-v1beta1-ProxyConfig-invalid.yaml |   0
 .../networking-v1beta1-ProxyConfig-valid.yaml |   0
 ...y-v1beta1-AuthorizationPolicy-invalid.yaml |   0
 ...ity-v1beta1-AuthorizationPolicy-valid.yaml |   0
 ...ty-v1beta1-PeerAuthentication-invalid.yaml |   0
 ...rity-v1beta1-PeerAuthentication-valid.yaml |   0
 ...v1beta1-RequestAuthentication-invalid.yaml |   0
 ...y-v1beta1-RequestAuthentication-valid.yaml |   0
 .../telemetry-v1alpha1-Telemetry-invalid.yaml |   0
 .../telemetry-v1alpha1-Telemetry-valid.yaml   |   0
 tests/fuzz/analyzer_fuzzer.go                 |  10 +-
 tests/fuzz/kube_fuzzer.go                     |  86 ---
 tests/fuzz/misc_fuzzers.go                    |  41 +-
 tests/fuzz/oss_fuzz_build.sh                  |   2 -
 tests/fuzz/regression_test.go                 |   7 +-
 tests/integration/operator/operator_dumper.go |  59 ++
 tests/integration/operator/switch_cr_test.go  |   6 +
 .../pilot/analysis/analysis_test.go           |  19 +-
 tests/integration/pilot/analyze_test.go       |   4 +-
 tests/integration/pilot/validation_test.go    |   2 +-
 tools/bug-report/pkg/bugreport/bugreport.go   |   2 +-
 tools/bug-report/pkg/bugreport/flags.go       |   2 +-
 tools/bug-report/pkg/cluster/cluster.go       |   2 +-
 tools/bug-report/pkg/content/content.go       |  14 +-
 374 files changed, 2953 insertions(+), 13684 deletions(-)
 delete mode 100644 galley/README.md
 delete mode 100644 galley/pkg/config/analysis/local/analyze.go
 delete mode 100644 galley/pkg/config/analysis/local/helpers_test.go
 delete mode 100644 galley/pkg/config/analysis/local/source.go
 delete mode 100644 galley/pkg/config/analysis/local/source_test.go
 delete mode 100644 galley/pkg/config/collection/instance.go
 delete mode 100644 galley/pkg/config/collection/instance_test.go
 delete mode 100644 galley/pkg/config/collection/set.go
 delete mode 100644 galley/pkg/config/collection/set_test.go
 delete mode 100644 galley/pkg/config/mesh/defaults.go
 delete mode 100644 galley/pkg/config/mesh/fs.go
 delete mode 100644 galley/pkg/config/mesh/fs_test.go
 delete mode 100644 galley/pkg/config/mesh/inmemory.go
 delete mode 100644 galley/pkg/config/mesh/inmemory_test.go
 delete mode 100644 galley/pkg/config/mesh/metadata_test.go
 delete mode 100644 galley/pkg/config/monitoring/monitoring.go
 delete mode 100644 galley/pkg/config/processing/processor.go
 delete mode 100644 galley/pkg/config/processing/runtime.go
 delete mode 100644 galley/pkg/config/processing/runtime_test.go
 delete mode 100644 galley/pkg/config/processing/session.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/analyzingdistributor.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/analyzingdistributor_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/distributor.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/distributor_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/snapshot.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/snapshot_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/snapshotoptions.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/snapshotter.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/snapshotter_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/statusupdater.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/statusupdater_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/create.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/create_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/debounce.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/debounce_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/immediate.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/immediate_test.go
 delete mode 100644 galley/pkg/config/processing/snapshotter/strategy/instance.go
 delete mode 100644 galley/pkg/config/processor/build.go
 delete mode 100644 galley/pkg/config/processor/build_test.go
 delete mode 100644 galley/pkg/config/processor/groups/groups.go
 delete mode 100644 galley/pkg/config/processor/groups/groups_test.go
 delete mode 100644 galley/pkg/config/scope/scopes.go
 delete mode 100644 galley/pkg/config/source/inmemory/collection.go
 delete mode 100644 galley/pkg/config/source/inmemory/collection_test.go
 delete mode 100644 galley/pkg/config/source/inmemory/source.go
 delete mode 100644 galley/pkg/config/source/inmemory/source_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/options.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/source.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/source_builtin_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/source_dynamic_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/stats/stats.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/controller.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/controller_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/messages.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/state.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/state_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/status.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/status/util.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/tombstone/recover.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/tombstone/recover_test.go
 delete mode 100644 galley/pkg/config/source/kube/apiserver/watcher.go
 delete mode 100644 galley/pkg/config/source/kube/inmemory/kubesource_test.go
 delete mode 100644 galley/pkg/config/source/kube/interfaces.go
 delete mode 100644 galley/pkg/config/source/kube/interfaces_test.go
 delete mode 100644 galley/pkg/config/source/kube/rt/adapter.go
 delete mode 100644 galley/pkg/config/source/kube/rt/dynamic.go
 delete mode 100644 galley/pkg/config/source/kube/rt/dynamic_test.go
 delete mode 100644 galley/pkg/config/source/kube/rt/extract.go
 delete mode 100644 galley/pkg/config/source/kube/rt/known.go
 delete mode 100644 galley/pkg/config/source/kube/rt/known_test.go
 delete mode 100644 galley/pkg/config/source/kube/rt/origin_test.go
 delete mode 100644 galley/pkg/config/source/kube/rt/provider.go
 delete mode 100644 galley/pkg/config/source/mcp/origin.go
 delete mode 100644 galley/pkg/config/source/mcp/origin_test.go
 delete mode 100644 galley/pkg/config/util/pb/proto.go
 delete mode 100644 galley/pkg/config/util/pb/proto_test.go
 delete mode 100644 galley/pkg/server/components/patchtable.go
 delete mode 100644 galley/pkg/server/components/processing.go
 delete mode 100644 galley/pkg/server/components/processing_test.go
 delete mode 100644 galley/pkg/server/settings/args.go
 delete mode 100644 galley/pkg/server/settings/args_test.go
 delete mode 100644 galley/pkg/testing/mock/watch.go
 rename galley/pkg/config/source/kube/inmemory/kubesource.go => pilot/pkg/config/file/store.go (57%)
 rename {galley/pkg/config => pilot/pkg/config/file}/util/kubeyaml/kubeyaml.go (100%)
 rename {galley/pkg/config => pilot/pkg/config/file}/util/kubeyaml/kubeyaml_test.go (100%)
 create mode 100644 pilot/pkg/config/kube/arbitraryclient/client.go
 create mode 100644 pilot/pkg/config/kube/gateway/generation_adapter.go
 rename pilot/pkg/status/{ => distribution}/leak_test.go (97%)
 rename pilot/pkg/status/{ => distribution}/ledger.go (98%)
 rename galley/pkg/config/mesh/defaults_test.go => pilot/pkg/status/distribution/report.go (62%)
 rename pilot/pkg/status/{ => distribution}/report_test.go (91%)
 rename pilot/pkg/status/{ => distribution}/reporter.go (95%)
 rename pilot/pkg/status/{ => distribution}/reporter_test.go (96%)
 rename galley/pkg/config/processing/snapshotter/strategy/scope.go => pilot/pkg/status/distribution/resourcelock.go (85%)
 rename pilot/pkg/status/{ => distribution}/state.go (61%)
 rename pilot/pkg/status/{ => distribution}/state_test.go (86%)
 create mode 100644 pilot/pkg/status/manager.go
 rename pilot/pkg/status/{report.go => resource.go} (50%)
 rename {galley/pkg => pkg}/config/analysis/README.md (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzer.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzer_test.go (78%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/all.go (67%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/analyzers_bench_test.go (50%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/analyzers_test.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/annotations/annotations.go (97%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/authz/authorizationpolicies.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/authz/authorizationpolicies_test.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/deployment/pod.go (87%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/deployment/services.go (88%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/deprecation/deprecation.go (98%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/destinationrule/ca-certificates.go (94%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/gateway/certificate.go (97%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/gateway/conflictinggateway.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/gateway/gateway.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/gateway/secret.go (92%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/injection/image-auto.go (87%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/injection/injection-image.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/injection/injection.go (92%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/maturity/maturity.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/multicluster/meshnetworks.go (94%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/schema/validation.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/schema/validation_test.go (97%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/service/portname.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/serviceentry/protocoladresses.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/sidecar/defaultselector.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/sidecar/selector.go (93%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/sidecar/util.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/authorizationpolicies.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/common/meshnetworks.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/conflicting-gateways.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/deployment-multi-service.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/deprecation.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-correct-port.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-no-port.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-no-workload.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/gateway-secrets.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/image-auto.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/injection.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mesh-with-automtls.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/misannotated.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-exports.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-no-dr.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-no-policy.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/mtls-with-port.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/peerauthentication-crd.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/pod-sec-uid.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/service-no-port-name.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/service-port-name.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/sidecar-default-selector.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/sidecar-selector.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_gateways.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_regexes.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/testdata/webhook.yaml (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/config.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/constants.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/exportto.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/exportto_test.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/find_errorline_utils.go (98%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/find_errorline_utils_test.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/hosts.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/hosts_test.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/in_mesh.go (90%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/util/service_lookup.go (98%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/destinationhosts.go (97%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/destinationrules.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/gateways.go (96%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/jwtclaimroute.go (92%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/regexes.go (95%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/virtualservice/util.go (100%)
 rename {galley/pkg => pkg}/config/analysis/analyzers/webhook/webhook.go (98%)
 rename {galley/pkg => pkg}/config/analysis/context.go (96%)
 rename {galley/pkg => pkg}/config/analysis/diag/helper.go (100%)
 rename {galley/pkg => pkg}/config/analysis/diag/level.go (100%)
 rename {galley/pkg => pkg}/config/analysis/diag/message.go (97%)
 rename {galley/pkg => pkg}/config/analysis/diag/message_test.go (95%)
 rename {galley/pkg => pkg}/config/analysis/diag/messages.go (100%)
 rename {galley/pkg => pkg}/config/analysis/diag/messages_test.go (100%)
 create mode 100644 pkg/config/analysis/equivalence.go
 create mode 100644 pkg/config/analysis/incluster/controller.go
 rename {galley/pkg => pkg}/config/analysis/local/analyze_test.go (58%)
 create mode 100644 pkg/config/analysis/local/context.go
 rename {galley/pkg => pkg}/config/analysis/local/defaults.go (100%)
 create mode 100644 pkg/config/analysis/local/helpers_test.go
 create mode 100644 pkg/config/analysis/local/istiod_analyze.go
 create mode 100644 pkg/config/analysis/local/local.go
 rename {galley/pkg => pkg}/config/analysis/metadata.go (100%)
 rename {galley/pkg => pkg}/config/analysis/msg/generate.main.go (98%)
 rename {galley/pkg => pkg}/config/analysis/msg/messages.gen.go (99%)
 rename {galley/pkg => pkg}/config/analysis/msg/messages.go (74%)
 rename {galley/pkg => pkg}/config/analysis/msg/messages.yaml (100%)
 create mode 100644 pkg/config/analysis/scope/scope.go
 rename {galley/pkg => pkg}/config/analysis/testing/fixtures/context.go (94%)
 create mode 100644 pkg/config/conversion.go
 rename {galley/pkg/config => pkg/config/legacy}/mesh/const.go (100%)
 create mode 100644 pkg/config/legacy/processing/processor.go
 rename {galley/pkg/config => pkg/config/legacy}/processing/transformer/provider.go (89%)
 rename {galley/pkg/config => pkg/config/legacy}/processing/transformer/provider_test.go (87%)
 rename {galley/pkg/config => pkg/config/legacy}/processor/transforms/direct/create.go (95%)
 rename {galley/pkg/config => pkg/config/legacy}/processor/transforms/direct/create_test.go (94%)
 rename {galley/pkg/config => pkg/config/legacy}/processor/transforms/transforms.go (89%)
 rename {galley/pkg/config/source/kube/rt => pkg/config/legacy/source/kube}/origin.go (78%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/basicmeta.gen.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/basicmeta.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/basicmeta2.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/collections.gen.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/generate.go (89%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/basicmeta/get.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin.gen.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/deployment.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/endpoints.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/ingress.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/namespace.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/node.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/pod.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/builtin/service.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/collections.go (97%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/events.go (97%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/resources.go (98%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/data/yaml.go (93%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/accumulator.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/accumulator_test.go (96%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/expect.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/expect_test.go (90%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/filters.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/filters_test.go (94%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/listener.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/listener_test.go (94%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/source.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/source_test.go (95%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/fixtures/transformer.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/k8smeta/collections.gen.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/k8smeta/generate.go (89%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/k8smeta/get.go (92%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/k8smeta/k8smeta.gen.go (100%)
 rename {galley/pkg/config => pkg/config/legacy}/testing/k8smeta/k8smeta.yaml (100%)
 rename {galley/pkg/config => pkg/config/legacy}/util/kuberesource/resources.go (73%)
 delete mode 100644 pkg/config/schema/collections/collections_test.go
 create mode 100644 pkg/config/schema/collections_test.go
 rename {galley/testdatasets => pkg/test/datasets}/Readme.md (94%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset.go (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-Gateway-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-DestinationRule-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-Gateway-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-Gateway-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-Sidecar-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-Sidecar-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-VirtualService-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-VirtualService-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml (100%)
 rename {galley/testdatasets => pkg/test/datasets}/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml (100%)
 delete mode 100644 tests/fuzz/kube_fuzzer.go
 create mode 100644 tests/integration/operator/operator_dumper.go

diff --git a/Makefile.core.mk b/Makefile.core.mk
index a7177629c2..269f856a4f 100644
--- a/Makefile.core.mk
+++ b/Makefile.core.mk
@@ -343,7 +343,7 @@ lint-helm-global:
 lint: lint-python lint-copyright-banner lint-scripts lint-go lint-dockerfiles lint-markdown lint-yaml lint-licenses lint-helm-global ## Runs all linters.
 	@bin/check_samples.sh
 	@testlinter
-	@envvarlinter galley istioctl pilot security
+	@envvarlinter istioctl pilot security
 
 go-gen:
 	@mkdir -p /tmp/bin
diff --git a/galley/README.md b/galley/README.md
deleted file mode 100644
index 20ca64530b..0000000000
--- a/galley/README.md
+++ /dev/null
@@ -1,10 +0,0 @@
-# Galley
-
-Galley is the top-level config ingestion, processing and distribution component of
-Istio. It is responsible for insulating the rest of the Istio components from the
-details of obtaining user configuration from the underlying platform. It contains
-Kubernetes CRD listeners for collecting configuration, an MCP protocol server
-implementation for distributing config, and a validation web-hook for pre-ingestion
-validation by Kubernetes API Server.
-
-[High-level design doc](https://docs.google.com/document/d/1GRLQ6bs2pzhURKQ871fgoagh8bkJkRYRFABgAuezK8s) *(Oct 2019)*
diff --git a/galley/pkg/config/analysis/local/analyze.go b/galley/pkg/config/analysis/local/analyze.go
deleted file mode 100644
index a1f92d9f84..0000000000
--- a/galley/pkg/config/analysis/local/analyze.go
+++ /dev/null
@@ -1,381 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package local
-
-import (
-	"context"
-	"fmt"
-	"io"
-	"os"
-	"strings"
-	"time"
-
-	"github.com/hashicorp/go-multierror"
-	kerrors "k8s.io/apimachinery/pkg/api/errors"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/kubernetes"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	galley_mesh "istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/processing/transformer"
-	"istio.io/istio/galley/pkg/config/processor"
-	"istio.io/istio/galley/pkg/config/processor/transforms"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/inmemory"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver"
-	kube_inmemory "istio.io/istio/galley/pkg/config/source/kube/inmemory"
-	"istio.io/istio/galley/pkg/config/util/kuberesource"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/mesh"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/config/schema/collections"
-	"istio.io/istio/pkg/config/schema/snapshots"
-)
-
-const (
-	meshConfigMapKey   = "mesh"
-	meshConfigMapName  = "istio"
-	meshNetworksMapKey = "meshNetworks"
-)
-
-// Pseudo-constants, since golang doesn't support a true const slice/array
-var (
-	analysisSnapshots = []string{snapshots.LocalAnalysis}
-)
-
-// Patch table
-var (
-	apiserverNew = apiserver.New
-)
-
-// SourceAnalyzer handles local analysis of k8s event sources, both live and file-based
-type SourceAnalyzer struct {
-	m                    *schema.Metadata
-	sources              []precedenceSourceInput
-	analyzer             *analysis.CombinedAnalyzer
-	transformerProviders transformer.Providers
-	namespace            resource.Namespace
-	istioNamespace       resource.Namespace
-
-	// List of code and resource suppressions to exclude messages on
-	suppressions []snapshotter.AnalysisSuppression
-
-	// Mesh config for this analyzer. This can come from multiple sources, and the last added version will take precedence.
-	meshCfg *v1alpha1.MeshConfig
-
-	// Mesh networks config for this analyzer.
-	meshNetworks *v1alpha1.MeshNetworks
-
-	// Which kube resources are used by this analyzer
-	// Derived from metadata and the specified analyzer and transformer providers
-	kubeResources collection.Schemas
-
-	// Hook function called when a collection is used in analysis
-	collectionReporter snapshotter.CollectionReporterFn
-
-	// How long to wait for snapshot + analysis to complete before aborting
-	timeout time.Duration
-}
-
-// AnalysisResult represents the returnable results of an analysis execution
-type AnalysisResult struct {
-	Messages          diag.Messages
-	SkippedAnalyzers  []string
-	ExecutedAnalyzers []string
-}
-
-// ReaderSource is a tuple of a io.Reader and filepath.
-type ReaderSource struct {
-	// Name is the name of the source (commonly the path to a file, but can be "-" for sources read from stdin or "" if completely synthetic).
-	Name string
-	// Reader is the reader instance to use.
-	Reader io.Reader
-}
-
-// NewSourceAnalyzer creates a new SourceAnalyzer with no sources. Use the Add*Source methods to add sources in ascending precedence order,
-// then execute Analyze to perform the analysis
-func NewSourceAnalyzer(m *schema.Metadata, analyzer *analysis.CombinedAnalyzer, namespace, istioNamespace resource.Namespace,
-	cr snapshotter.CollectionReporterFn, serviceDiscovery bool, timeout time.Duration) *SourceAnalyzer {
-	// collectionReporter hook function defaults to no-op
-	if cr == nil {
-		cr = func(collection.Name) {}
-	}
-
-	transformerProviders := transforms.Providers(m)
-
-	// Get the closure of all input collections for our analyzer, paying attention to transforms
-	kubeResources := kuberesource.DisableExcludedCollections(
-		m.KubeCollections(),
-		transformerProviders,
-		analyzer.Metadata().Inputs,
-		kuberesource.DefaultExcludedResourceKinds(),
-		serviceDiscovery)
-
-	sa := &SourceAnalyzer{
-		m:                    m,
-		meshCfg:              galley_mesh.DefaultMeshConfig(),
-		meshNetworks:         galley_mesh.DefaultMeshNetworks(),
-		sources:              make([]precedenceSourceInput, 0),
-		analyzer:             analyzer,
-		transformerProviders: transformerProviders,
-		namespace:            namespace,
-		istioNamespace:       istioNamespace,
-		kubeResources:        kubeResources,
-		collectionReporter:   cr,
-		timeout:              timeout,
-	}
-
-	return sa
-}
-
-// Analyze loads the sources and executes the analysis
-func (sa *SourceAnalyzer) Analyze(cancel chan struct{}) (AnalysisResult, error) {
-	var result AnalysisResult
-
-	// We need at least one non-meshcfg source
-	if len(sa.sources) == 0 {
-		return result, fmt.Errorf("at least one file and/or Kubernetes source must be provided")
-	}
-
-	// Create a source representing mesh config. There should be exactly one.
-	meshconfig := galley_mesh.NewInmemoryMeshCfg()
-	meshconfig.Set(sa.meshCfg)
-	sa.sources = append(sa.sources, precedenceSourceInput{
-		src: meshconfig,
-		cols: collection.Names{
-			collections.IstioMeshV1Alpha1MeshConfig.Name(),
-		},
-	})
-
-	// Create a source representing meshnetworks. There should be exactly one.
-	meshnetworks := galley_mesh.NewInmemoryMeshNetworks()
-	meshnetworks.Set(sa.meshNetworks)
-	sa.sources = append(sa.sources, precedenceSourceInput{
-		src: meshnetworks,
-		cols: collection.Names{
-			collections.IstioMeshV1Alpha1MeshNetworks.Name(),
-		},
-	})
-
-	var namespaces []resource.Namespace
-	if sa.namespace != "" {
-		namespaces = []resource.Namespace{sa.namespace}
-	}
-
-	var colsInSnapshots collection.Names
-	for _, c := range sa.m.AllCollectionsInSnapshots(analysisSnapshots) {
-		colsInSnapshots = append(colsInSnapshots, collection.NewName(c))
-	}
-
-	result.SkippedAnalyzers = sa.analyzer.RemoveSkipped(colsInSnapshots, sa.kubeResources.DisabledCollectionNames(),
-		sa.transformerProviders)
-	result.ExecutedAnalyzers = sa.analyzer.AnalyzerNames()
-
-	updater := &snapshotter.InMemoryStatusUpdater{
-		WaitTimeout: sa.timeout,
-	}
-
-	distributorSettings := snapshotter.AnalyzingDistributorSettings{
-		StatusUpdater:      updater,
-		Analyzer:           sa.analyzer,
-		Distributor:        snapshotter.NewInMemoryDistributor(),
-		AnalysisSnapshots:  analysisSnapshots,
-		TriggerSnapshot:    snapshots.LocalAnalysis,
-		CollectionReporter: sa.collectionReporter,
-		AnalysisNamespaces: namespaces,
-		Suppressions:       sa.suppressions,
-	}
-	distributor := snapshotter.NewAnalyzingDistributor(distributorSettings)
-
-	processorSettings := processor.Settings{
-		Metadata:           sa.m,
-		DomainSuffix:       constants.DefaultKubernetesDomain,
-		Source:             newPrecedenceSource(sa.sources),
-		TransformProviders: sa.transformerProviders,
-		Distributor:        distributor,
-		EnabledSnapshots:   analysisSnapshots,
-	}
-	rt, err := processor.Initialize(processorSettings)
-	if err != nil {
-		return result, err
-	}
-
-	rt.Start()
-
-	scope.Analysis.Debugf("Waiting for analysis messages to be available...")
-	if err := updater.WaitForReport(cancel); err != nil {
-		return result, fmt.Errorf("failed to get analysis result: %v", err)
-	}
-
-	result.Messages = updater.Get()
-
-	rt.Stop()
-
-	return result, nil
-}
-
-// SetSuppressions will set the list of suppressions for the analyzer. Any
-// resource that matches the provided suppression will not be included in the
-// final message output.
-func (sa *SourceAnalyzer) SetSuppressions(suppressions []snapshotter.AnalysisSuppression) {
-	sa.suppressions = suppressions
-}
-
-// AddReaderKubeSource adds a source based on the specified k8s yaml files to the current SourceAnalyzer
-func (sa *SourceAnalyzer) AddReaderKubeSource(readers []ReaderSource) error {
-	src := kube_inmemory.NewKubeSource(sa.kubeResources)
-	src.SetDefaultNamespace(sa.namespace)
-
-	var errs error
-
-	// If we encounter any errors reading or applying files, track them but attempt to continue
-	for _, r := range readers {
-		by, err := io.ReadAll(r.Reader)
-		if err != nil {
-			errs = multierror.Append(errs, err)
-			continue
-		}
-
-		if err = src.ApplyContent(r.Name, string(by)); err != nil {
-			errs = multierror.Append(errs, err)
-		}
-	}
-
-	sa.sources = append(sa.sources, precedenceSourceInput{src: src, cols: sa.kubeResources.CollectionNames()})
-
-	return errs
-}
-
-// AddRunningKubeSource adds a source based on a running k8s cluster to the current SourceAnalyzer
-// Also tries to get mesh config from the running cluster, if it can
-func (sa *SourceAnalyzer) AddRunningKubeSource(k kube.Interfaces) {
-	client, err := k.KubeClient()
-	if err != nil {
-		scope.Analysis.Errorf("error getting KubeClient: %v", err)
-		return
-	}
-
-	// Since we're using a running k8s source, try to get meshconfig and meshnetworks from the configmap.
-	if err := sa.addRunningKubeIstioConfigMapSource(client); err != nil {
-		_, err := client.CoreV1().Namespaces().Get(context.TODO(), sa.istioNamespace.String(), metav1.GetOptions{})
-		if kerrors.IsNotFound(err) {
-			// An AnalysisMessage already show up to warn the absence of istio-system namespace, so making it debug level.
-			scope.Analysis.Debugf("%v namespace not found. Istio may not be installed in the target cluster. "+
-				"Using default mesh configuration values for analysis", sa.istioNamespace.String())
-		} else if err != nil {
-			scope.Analysis.Errorf("error getting mesh config from running kube source: %v", err)
-		}
-	}
-
-	src := apiserverNew(apiserver.Options{
-		Client:  k,
-		Schemas: sa.kubeResources,
-	})
-	sa.sources = append(sa.sources, precedenceSourceInput{src: src, cols: sa.kubeResources.CollectionNames()})
-}
-
-// AddInMemorySource adds a source based on user supplied in-memory configs to the current SourceAnalyzer
-// Assumes that the in memory source has same or subset of resource types that this analyzer is configured with.
-// This can be used by external users who import the analyzer as a module within their own controllers.
-func (sa *SourceAnalyzer) AddInMemorySource(src *inmemory.Source) {
-	sa.sources = append(sa.sources, precedenceSourceInput{src: src, cols: sa.kubeResources.CollectionNames()})
-}
-
-// AddFileKubeMeshConfig gets mesh config from the specified yaml file
-func (sa *SourceAnalyzer) AddFileKubeMeshConfig(file string) error {
-	by, err := os.ReadFile(file)
-	if err != nil {
-		return err
-	}
-
-	cfg, err := mesh.ApplyMeshConfigDefaults(string(by))
-	if err != nil {
-		return err
-	}
-
-	sa.meshCfg = cfg
-	return nil
-}
-
-// AddFileKubeMeshNetworks gets a file meshnetworks and add it to the analyzer.
-func (sa *SourceAnalyzer) AddFileKubeMeshNetworks(file string) error {
-	mn, err := mesh.ReadMeshNetworks(file)
-	if err != nil {
-		return err
-	}
-
-	sa.meshNetworks = mn
-	return nil
-}
-
-// AddDefaultResources adds some basic dummy Istio resources, based on mesh configuration.
-// This is useful for files-only analysis cases where we don't expect the user to be including istio system resources
-// and don't want to generate false positives because they aren't there.
-// Respect mesh config when deciding which default resources should be generated
-func (sa *SourceAnalyzer) AddDefaultResources() error {
-	var readers []ReaderSource
-
-	if sa.meshCfg.GetIngressControllerMode() != v1alpha1.MeshConfig_OFF {
-		ingressResources, err := getDefaultIstioIngressGateway(sa.istioNamespace.String(), sa.meshCfg.GetIngressService())
-		if err != nil {
-			return err
-		}
-		readers = append(readers, ReaderSource{Reader: strings.NewReader(ingressResources)})
-	}
-
-	if len(readers) == 0 {
-		return nil
-	}
-
-	return sa.AddReaderKubeSource(readers)
-}
-
-func (sa *SourceAnalyzer) addRunningKubeIstioConfigMapSource(client kubernetes.Interface) error {
-	meshConfigMap, err := client.CoreV1().ConfigMaps(string(sa.istioNamespace)).Get(context.TODO(), meshConfigMapName, metav1.GetOptions{})
-	if err != nil {
-		return fmt.Errorf("could not read configmap %q from namespace %q: %v", meshConfigMapName, sa.istioNamespace, err)
-	}
-
-	configYaml, ok := meshConfigMap.Data[meshConfigMapKey]
-	if !ok {
-		return fmt.Errorf("missing config map key %q", meshConfigMapKey)
-	}
-
-	cfg, err := mesh.ApplyMeshConfigDefaults(configYaml)
-	if err != nil {
-		return fmt.Errorf("error parsing mesh config: %v", err)
-	}
-
-	sa.meshCfg = cfg
-
-	meshNetworksYaml, ok := meshConfigMap.Data[meshNetworksMapKey]
-	if !ok {
-		return fmt.Errorf("missing config map key %q", meshNetworksMapKey)
-	}
-
-	mn, err := mesh.ParseMeshNetworks(meshNetworksYaml)
-	if err != nil {
-		return fmt.Errorf("error parsing mesh networks: %v", err)
-	}
-
-	sa.meshNetworks = mn
-	return nil
-}
diff --git a/galley/pkg/config/analysis/local/helpers_test.go b/galley/pkg/config/analysis/local/helpers_test.go
deleted file mode 100644
index 932a6ee0da..0000000000
--- a/galley/pkg/config/analysis/local/helpers_test.go
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package local
-
-// Test helpers common to this package
-
-import (
-	"testing"
-
-	"github.com/gogo/protobuf/types"
-
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-)
-
-func createTestEvent(t *testing.T, k event.Kind, r *resource.Instance) event.Event {
-	t.Helper()
-	return event.Event{
-		Kind:     k,
-		Source:   basicmeta.K8SCollection1,
-		Resource: r,
-	}
-}
-
-func createTestResource(t *testing.T, ns, name, version string) *resource.Instance {
-	t.Helper()
-	rname := resource.NewFullName(resource.Namespace(ns), resource.LocalName(name))
-	return &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: rname,
-			Version:  resource.Version(version),
-		},
-		Message: &types.Empty{},
-		Origin: &rt.Origin{
-			FullName: rname,
-		},
-	}
-}
diff --git a/galley/pkg/config/analysis/local/source.go b/galley/pkg/config/analysis/local/source.go
deleted file mode 100644
index ea5da2a43c..0000000000
--- a/galley/pkg/config/analysis/local/source.go
+++ /dev/null
@@ -1,160 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package local
-
-import (
-	"fmt"
-	"sync"
-
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// precedenceSource is a processor.Source implementation that combines multiple sources in precedence order
-// Such that events from sources later in the input list take precedence over events affecting
-// the same resource from sources earlier in the list
-// Only events from the highest precedence source so far are allowed through.
-// Each source input also needs to include the collections it provides,
-// so we know how many to wait for before sending a full sync
-type precedenceSource struct {
-	mu      sync.Mutex
-	started bool
-
-	inputs  []precedenceSourceInput
-	handler event.Handler
-
-	eventStateMu     sync.Mutex
-	resourcePriority map[string]int
-	expectedCounts   map[collection.Name]int
-	countMu          sync.Mutex
-}
-
-type precedenceSourceInput struct {
-	src  event.Source
-	cols collection.Names
-}
-
-type precedenceHandler struct {
-	precedence int
-	src        *precedenceSource
-}
-
-var _ event.Source = &precedenceSource{}
-
-func newPrecedenceSource(inputs []precedenceSourceInput) *precedenceSource {
-	return &precedenceSource{
-		inputs:           inputs,
-		resourcePriority: make(map[string]int),
-	}
-}
-
-// Handle implements event.Handler
-func (ph *precedenceHandler) Handle(e event.Event) {
-	ph.src.eventStateMu.Lock()
-	defer ph.src.eventStateMu.Unlock()
-
-	switch e.Kind {
-	case event.Added, event.Updated, event.Deleted:
-		ph.handleEvent(e)
-	case event.FullSync:
-		ph.handleFullSync(e)
-	default:
-		ph.src.handler.Handle(e)
-	}
-}
-
-// handleFullSync handles FullSync events, which are a special case.
-// For each collection, we want to only send this once, after all upstream sources have sent theirs.
-func (ph *precedenceHandler) handleFullSync(e event.Event) {
-	col := e.Source.Name()
-	ph.src.countMu.Lock()
-	ph.src.expectedCounts[col]--
-	shallHandle := ph.src.expectedCounts[col] <= 0
-	ph.src.countMu.Unlock()
-	if shallHandle {
-		ph.src.handler.Handle(e)
-	}
-}
-
-// handleEvent handles non fullsync events.
-// For each event, only pass it along to the downstream handler if the source it came from
-// had equal or higher precedence on the current resource
-func (ph *precedenceHandler) handleEvent(e event.Event) {
-	key := fmt.Sprintf("%s/%s", e.Source.Name(), e.Resource.Metadata.FullName)
-	curPrecedence, ok := ph.src.resourcePriority[key]
-	if ok && ph.precedence < curPrecedence {
-		return
-	}
-	ph.src.resourcePriority[key] = ph.precedence
-	ph.src.handler.Handle(e)
-}
-
-// Dispatch implements event.Source
-func (s *precedenceSource) Dispatch(h event.Handler) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	s.handler = h
-
-	// Inject a precedenceHandler for each source
-	// precedence is based on index position (higher index, higher precedence)
-	for i, input := range s.inputs {
-		ph := &precedenceHandler{
-			precedence: i,
-			src:        s,
-		}
-		input.src.Dispatch(ph)
-	}
-}
-
-// Start implements processor.Source
-func (s *precedenceSource) Start() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if s.started {
-		return
-	}
-
-	// Init expected counts map
-	s.expectedCounts = make(map[collection.Name]int)
-	for _, i := range s.inputs {
-		for _, c := range i.cols {
-			s.expectedCounts[c]++
-		}
-	}
-
-	for _, i := range s.inputs {
-		i.src.Start()
-	}
-
-	s.started = true
-}
-
-// Stop implements processor.Source
-func (s *precedenceSource) Stop() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if !s.started {
-		return
-	}
-
-	s.started = false
-
-	for _, i := range s.inputs {
-		i.src.Stop()
-	}
-}
diff --git a/galley/pkg/config/analysis/local/source_test.go b/galley/pkg/config/analysis/local/source_test.go
deleted file mode 100644
index 025b4372dd..0000000000
--- a/galley/pkg/config/analysis/local/source_test.go
+++ /dev/null
@@ -1,115 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package local
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-func TestBasicSingleSource(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := &fixtures.Source{}
-
-	psi := precedenceSourceInput{src: s1, cols: collection.Names{basicmeta.K8SCollection1.Name()}}
-	ps := newPrecedenceSource([]precedenceSourceInput{psi})
-
-	h := &fixtures.Accumulator{}
-	ps.Dispatch(h)
-
-	ps.Start()
-	defer ps.Stop()
-
-	e1 := createTestEvent(t, event.Added, createTestResource(t, "ns", "resource1", "v1"))
-	e2 := createTestEvent(t, event.FullSync, nil)
-
-	s1.Handle(e1)
-	s1.Handle(e2)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1, e2}))
-}
-
-func TestWaitAndCombineFullSync(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := &fixtures.Source{}
-	s2 := &fixtures.Source{}
-
-	psi1 := precedenceSourceInput{src: s1, cols: collection.Names{basicmeta.K8SCollection1.Name(), basicmeta.Collection2.Name()}}
-	psi2 := precedenceSourceInput{src: s2, cols: collection.Names{basicmeta.K8SCollection1.Name()}}
-
-	ps := newPrecedenceSource([]precedenceSourceInput{psi1, psi2})
-
-	h := &fixtures.Accumulator{}
-	ps.Dispatch(h)
-
-	ps.Start()
-	defer ps.Stop()
-
-	// For collections in more than one source, wait for all sources before publishing fullsync
-	e1 := createTestEvent(t, event.FullSync, nil)
-
-	s1.Handle(e1)
-	g.Expect(h.Events()).To(BeEmpty())
-
-	s2.Handle(e1)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1}))
-
-	// Collection2 is only in one source, so we shouldn't wait for an event from both sources
-	e2 := createTestEvent(t, event.FullSync, nil)
-	e2.Source = basicmeta.Collection2
-
-	s1.Handle(e2)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1, e2}))
-}
-
-func TestPrecedence(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := &fixtures.Source{}
-	s2 := &fixtures.Source{}
-	s3 := &fixtures.Source{}
-
-	psi1 := precedenceSourceInput{src: s1, cols: collection.Names{basicmeta.K8SCollection1.Name()}}
-	psi2 := precedenceSourceInput{src: s2, cols: collection.Names{basicmeta.K8SCollection1.Name()}}
-	psi3 := precedenceSourceInput{src: s3, cols: collection.Names{basicmeta.K8SCollection1.Name()}}
-
-	ps := newPrecedenceSource([]precedenceSourceInput{psi1, psi2, psi3})
-
-	h := &fixtures.Accumulator{}
-	ps.Dispatch(h)
-
-	ps.Start()
-	defer ps.Stop()
-
-	e1 := createTestEvent(t, event.Added, createTestResource(t, "ns", "resource1", "v1"))
-	e2 := createTestEvent(t, event.Added, createTestResource(t, "ns", "resource1", "v2"))
-
-	s2.Handle(e1)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1}))
-
-	// For a lower precedence source, e2 should get ignored
-	s1.Handle(e2)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1}))
-
-	// For a higher precedence source, e2 should get handled
-	s3.Handle(e2)
-	g.Expect(h.Events()).To(Equal([]event.Event{e1, e2}))
-}
diff --git a/galley/pkg/config/collection/instance.go b/galley/pkg/config/collection/instance.go
deleted file mode 100644
index 711b0bde27..0000000000
--- a/galley/pkg/config/collection/instance.go
+++ /dev/null
@@ -1,134 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package collection
-
-import (
-	"sync"
-
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Instance is collection of resources, indexed by name.
-type Instance struct {
-	mu          sync.RWMutex // TODO: This lock will most likely cause contention. We should investigate whether removing it would help.
-	schema      collection.Schema
-	generation  int64
-	resources   map[resource.FullName]*resource.Instance
-	copyOnWrite bool
-}
-
-// New returns a new collection.Instance
-func New(collection collection.Schema) *Instance {
-	return &Instance{
-		schema:    collection,
-		resources: make(map[resource.FullName]*resource.Instance),
-	}
-}
-
-// Name of the collection
-func (c *Instance) Name() collection.Name {
-	return c.schema.Name()
-}
-
-// Schema for the collection.
-func (c *Instance) Schema() collection.Schema {
-	return c.schema
-}
-
-// Get the instance with the given name
-func (c *Instance) Get(name resource.FullName) *resource.Instance {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return c.resources[name]
-}
-
-// Generation of the current state of the collection.Instance
-func (c *Instance) Generation() int64 {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return c.generation
-}
-
-// Size returns the number of items in the set
-func (c *Instance) Size() int {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	return len(c.resources)
-}
-
-// ForEach executes the given function for each entry
-func (c *Instance) ForEach(fn func(e *resource.Instance) bool) {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	for _, e := range c.resources {
-		if !fn(e) {
-			break
-		}
-	}
-}
-
-// Set an entry in the collection
-func (c *Instance) Set(r *resource.Instance) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.doCopyOnWrite()
-	c.generation++
-	c.resources[r.Metadata.FullName] = r
-}
-
-// Remove an entry from the collection.
-func (c *Instance) Remove(n resource.FullName) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.doCopyOnWrite()
-	c.generation++
-	delete(c.resources, n)
-}
-
-// Clear the contents of this instance.
-func (c *Instance) Clear() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.doCopyOnWrite()
-	c.generation++
-	c.resources = make(map[resource.FullName]*resource.Instance)
-}
-
-func (c *Instance) doCopyOnWrite() { // TODO: we should optimize copy-on write.
-	if !c.copyOnWrite {
-		return
-	}
-
-	m := make(map[resource.FullName]*resource.Instance)
-	for k, v := range c.resources {
-		m[k] = v
-	}
-	c.resources = m
-	c.copyOnWrite = false
-}
-
-// Clone the instance
-func (c *Instance) Clone() *Instance {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.copyOnWrite = true
-	return &Instance{
-		schema:      c.schema,
-		generation:  c.generation,
-		resources:   c.resources,
-		copyOnWrite: true,
-	}
-}
diff --git a/galley/pkg/config/collection/instance_test.go b/galley/pkg/config/collection/instance_test.go
deleted file mode 100644
index a91683eaaf..0000000000
--- a/galley/pkg/config/collection/instance_test.go
+++ /dev/null
@@ -1,155 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package collection_test
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/pkg/config/resource"
-)
-
-func TestInstance_Basics(t *testing.T) {
-	g := NewWithT(t)
-
-	inst := collection.New(basicmeta.K8SCollection1)
-
-	g.Expect(inst.Size()).To(Equal(0))
-
-	var fe []*resource.Instance
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-	g.Expect(fe).To(HaveLen(0))
-
-	g.Expect(inst.Generation()).To(Equal(int64(0)))
-
-	inst.Set(data.EntryN1I1V2)
-	inst.Set(data.EntryN2I2V2)
-
-	g.Expect(inst.Size()).To(Equal(2))
-
-	fe = nil
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-	g.Expect(fe).To(HaveLen(2))
-
-	g.Expect(inst.Generation()).To(Equal(int64(2)))
-
-	inst.Remove(data.EntryN1I1V1.Metadata.FullName)
-
-	g.Expect(inst.Size()).To(Equal(1))
-
-	fe = nil
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-	g.Expect(fe).To(HaveLen(1))
-
-	g.Expect(inst.Generation()).To(Equal(int64(3)))
-
-	inst.Clear()
-
-	fe = nil
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-	g.Expect(fe).To(HaveLen(0))
-
-	g.Expect(inst.Generation()).To(Equal(int64(4)))
-	g.Expect(inst.Size()).To(Equal(0))
-}
-
-func TestInstance_Clone(t *testing.T) {
-	g := NewWithT(t)
-
-	inst := collection.New(basicmeta.K8SCollection1)
-	inst.Set(data.EntryN1I1V1)
-	inst.Set(data.EntryN2I2V2)
-
-	inst2 := inst.Clone()
-
-	g.Expect(inst2.Size()).To(Equal(2))
-	g.Expect(inst2.Generation()).To(Equal(int64(2)))
-
-	var fe []*resource.Instance
-	inst2.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-	g.Expect(fe).To(HaveLen(2))
-
-	inst.Remove(data.EntryN1I1V1.Metadata.FullName)
-
-	g.Expect(inst2.Size()).To(Equal(2))
-	g.Expect(inst2.Generation()).To(Equal(int64(2)))
-
-	fe = nil
-	inst2.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return true
-	})
-
-	g.Expect(fe).To(HaveLen(2))
-}
-
-func TestInstance_ForEach_False(t *testing.T) {
-	g := NewWithT(t)
-
-	inst := collection.New(basicmeta.K8SCollection1)
-	inst.Set(data.EntryN1I1V2)
-	inst.Set(data.EntryN2I2V2)
-	inst.Set(data.EntryN3I3V1)
-
-	var fe []*resource.Instance
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return false
-	})
-	g.Expect(fe).To(HaveLen(1))
-
-	fe = nil
-	inst.ForEach(func(r *resource.Instance) bool {
-		fe = append(fe, r)
-		return len(fe) < 2
-	})
-	g.Expect(fe).To(HaveLen(2))
-}
-
-func TestInstance_Get(t *testing.T) {
-	g := NewWithT(t)
-
-	inst := collection.New(basicmeta.K8SCollection1)
-	inst.Set(data.EntryN1I1V1)
-	inst.Set(data.EntryN3I3V1)
-
-	e := inst.Get(data.EntryN1I1V1.Metadata.FullName)
-	g.Expect(e).To(Equal(data.EntryN1I1V1))
-
-	e = inst.Get(data.EntryN3I3V1.Metadata.FullName)
-	g.Expect(e).To(Equal(data.EntryN3I3V1))
-
-	e = inst.Get(data.EntryN2I2V2.Metadata.FullName)
-	g.Expect(e).To(BeNil())
-}
diff --git a/galley/pkg/config/collection/set.go b/galley/pkg/config/collection/set.go
deleted file mode 100644
index 96ec4a8d77..0000000000
--- a/galley/pkg/config/collection/set.go
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package collection
-
-import (
-	"sort"
-	"strings"
-
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Set of collections
-type Set struct {
-	collections map[collection.Name]*Instance
-}
-
-// NewSet returns a new set of collections for the given schemas.
-func NewSet(schemas collection.Schemas) *Set {
-	c := make(map[collection.Name]*Instance)
-	schemas.ForEach(func(s collection.Schema) (done bool) {
-		c[s.Name()] = New(s)
-		return
-	})
-
-	return &Set{
-		collections: c,
-	}
-}
-
-// NewSetFromCollections creates a new set based on the given collections
-func NewSetFromCollections(collections []*Instance) *Set {
-	c := make(map[collection.Name]*Instance, len(collections))
-	for _, col := range collections {
-		c[col.schema.Name()] = col
-	}
-
-	return &Set{
-		collections: c,
-	}
-}
-
-// Collection returns the named collection
-func (s *Set) Collection(n collection.Name) *Instance {
-	return s.collections[n]
-}
-
-// Clone the set.
-func (s *Set) Clone() *Set {
-	c := make(map[collection.Name]*Instance, len(s.collections))
-	for k, v := range s.collections {
-		c[k] = v.Clone()
-	}
-
-	return &Set{
-		collections: c,
-	}
-}
-
-// Names of the collections in the set.
-func (s *Set) Names() collection.Names {
-	result := make([]collection.Name, 0, len(s.collections))
-	for name := range s.collections {
-		result = append(result, name)
-	}
-
-	sort.Slice(result, func(i, j int) bool {
-		return strings.Compare(result[i].String(), result[j].String()) < 0
-	})
-
-	return result
-}
diff --git a/galley/pkg/config/collection/set_test.go b/galley/pkg/config/collection/set_test.go
deleted file mode 100644
index b95ec4b95e..0000000000
--- a/galley/pkg/config/collection/set_test.go
+++ /dev/null
@@ -1,92 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package collection_test
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-func TestNewSet(t *testing.T) {
-	g := NewWithT(t)
-
-	s := coll.NewSet(collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).MustAdd(basicmeta.Collection2).Build())
-
-	s1 := s.Collection(basicmeta.K8SCollection1.Name())
-	g.Expect(s1).NotTo(BeNil())
-	s2 := s.Collection(basicmeta.Collection2.Name())
-	g.Expect(s2).NotTo(BeNil())
-
-	s3 := s.Collection(collection.NewName("foobar"))
-	g.Expect(s3).To(BeNil())
-}
-
-func TestNewSetFromCollections(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := coll.New(basicmeta.K8SCollection1)
-	g.Expect(s1).NotTo(BeNil())
-	s2 := coll.New(basicmeta.Collection2)
-	g.Expect(s2).NotTo(BeNil())
-
-	s := coll.NewSetFromCollections([]*coll.Instance{s1, s2})
-
-	c := s.Collection(basicmeta.K8SCollection1.Name())
-	g.Expect(c).NotTo(BeNil())
-	c = s.Collection(basicmeta.Collection2.Name())
-	g.Expect(c).NotTo(BeNil())
-
-	c = s.Collection(collection.NewName("foobar"))
-	g.Expect(c).To(BeNil())
-}
-
-func TestSet_Clone(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := coll.New(basicmeta.K8SCollection1)
-	g.Expect(s1).NotTo(BeNil())
-	s2 := coll.New(basicmeta.Collection2)
-	g.Expect(s2).NotTo(BeNil())
-
-	s := coll.NewSetFromCollections([]*coll.Instance{s1, s2})
-
-	s = s.Clone()
-
-	c := s.Collection(basicmeta.K8SCollection1.Name())
-	g.Expect(c).NotTo(BeNil())
-	c = s.Collection(basicmeta.Collection2.Name())
-	g.Expect(c).NotTo(BeNil())
-
-	c = s.Collection(collection.NewName("foobar"))
-	g.Expect(c).To(BeNil())
-}
-
-func TestSet_Names(t *testing.T) {
-	g := NewWithT(t)
-
-	s1 := coll.New(basicmeta.K8SCollection1)
-	s2 := coll.New(basicmeta.Collection2)
-
-	s := coll.NewSetFromCollections([]*coll.Instance{s1, s2})
-	names := s.Names()
-	g.Expect(names).To(ConsistOf(
-		basicmeta.K8SCollection1.Name(),
-		basicmeta.Collection2.Name()))
-}
diff --git a/galley/pkg/config/mesh/defaults.go b/galley/pkg/config/mesh/defaults.go
deleted file mode 100644
index 5f591add86..0000000000
--- a/galley/pkg/config/mesh/defaults.go
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/pkg/config/mesh"
-)
-
-// DefaultMeshConfig returns a default meshconfig.
-func DefaultMeshConfig() *v1alpha1.MeshConfig {
-	meshconfig := mesh.DefaultMeshConfig()
-	return &meshconfig
-}
-
-// DefaultMeshNetworks returns a default meshnetworks configuration.
-// By default, it is empty.
-func DefaultMeshNetworks() *v1alpha1.MeshNetworks {
-	mn := mesh.EmptyMeshNetworks()
-	return &mn
-}
diff --git a/galley/pkg/config/mesh/fs.go b/galley/pkg/config/mesh/fs.go
deleted file mode 100644
index 0a2cc152f9..0000000000
--- a/galley/pkg/config/mesh/fs.go
+++ /dev/null
@@ -1,149 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"os"
-	"sync"
-
-	"github.com/gogo/protobuf/jsonpb"
-	"github.com/gogo/protobuf/proto"
-	"sigs.k8s.io/yaml"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/pkg/filewatcher"
-)
-
-// FsSource is a event.InMemorySource implementation that reads mesh from file.
-type FsSource struct {
-	path string
-	fw   filewatcher.FileWatcher
-
-	inmemory *InMemorySource
-
-	wg sync.WaitGroup
-
-	// For overriding in tests
-	yamlToJSON func(y []byte) ([]byte, error)
-}
-
-var _ event.Source = &FsSource{}
-
-// NewMeshConfigFS returns a new meshconfig cache, based on watching a file.
-func NewMeshConfigFS(path string) (*FsSource, error) {
-	return newMeshConfigFS(path, yaml.YAMLToJSON)
-}
-
-// newFS returns a new mesh cache, based on watching a file.
-func newMeshConfigFS(path string, yamlToJSON func(y []byte) ([]byte, error)) (*FsSource, error) {
-	fw := filewatcher.NewWatcher()
-
-	err := fw.Add(path)
-	if err != nil {
-		_ = fw.Close()
-		return nil, err
-	}
-
-	c := &FsSource{
-		path:       path,
-		fw:         fw,
-		inmemory:   NewInmemoryMeshCfg(),
-		yamlToJSON: yamlToJSON,
-	}
-
-	c.reload()
-
-	// If we were not able to load mesh config, start with the default.
-	if !c.inmemory.IsSynced() {
-		scope.Processing.Infof("Unable to load up mesh config, using default values (path: %s)", path)
-		c.inmemory.Set(DefaultMeshConfig())
-	}
-
-	c.wg.Add(1)
-	go func() {
-		ch := fw.Events(path)
-
-		// Make sure the channel isn't nil. This can happen if the Stop function
-		// is called before we get here.
-		if ch != nil {
-			for range ch {
-				c.reload()
-			}
-		}
-		c.wg.Done()
-	}()
-
-	return c, nil
-}
-
-// Start implements event.Source
-func (c *FsSource) Start() {
-	c.inmemory.Start()
-}
-
-// Stop implements event.Source
-func (c *FsSource) Stop() {
-	scope.Processing.Debugf("mesh.FsSource.Stop >>>")
-	c.inmemory.Stop()
-
-	// close the file watcher
-	_ = c.fw.Close()
-
-	// wait for the goroutine to be done
-	c.wg.Wait()
-
-	scope.Processing.Debugf("mesh.FsSource.Stop <<<")
-}
-
-// Dispatch implements event.Source
-func (c *FsSource) Dispatch(h event.Handler) {
-	c.inmemory.Dispatch(h)
-}
-
-func (c *FsSource) reload() {
-	by, err := os.ReadFile(c.path)
-	if err != nil {
-		scope.Processing.Errorf("Error loading mesh config (path: %s): %v", c.path, err)
-		return
-	}
-
-	js, err := c.yamlToJSON(by)
-	if err != nil {
-		scope.Processing.Errorf("Error converting mesh config Yaml to JSON (path: %s): %v", c.path, err)
-		return
-	}
-
-	var cfg proto.Message
-	switch c.inmemory.current.(type) {
-	case *v1alpha1.MeshConfig:
-		cfg = DefaultMeshConfig()
-	case *v1alpha1.MeshNetworks:
-		cfg = DefaultMeshNetworks()
-	}
-	if err = jsonpb.UnmarshalString(string(js), cfg); err != nil {
-		scope.Processing.Errorf("Error reading config file as JSON (path: %s): %v", c.path, err)
-		return
-	}
-
-	c.inmemory.Set(cfg)
-	scope.Processing.Infof("Reloaded config (path: %s): \n%s\n", c.path, string(by))
-}
-
-// Close closes this cache.
-func (c *FsSource) Close() error {
-	return c.fw.Close()
-}
diff --git a/galley/pkg/config/mesh/fs_test.go b/galley/pkg/config/mesh/fs_test.go
deleted file mode 100644
index 8eba8faf27..0000000000
--- a/galley/pkg/config/mesh/fs_test.go
+++ /dev/null
@@ -1,453 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"fmt"
-	"os"
-	"path"
-	"testing"
-	"time"
-
-	"github.com/gogo/protobuf/jsonpb"
-	. "github.com/onsi/gomega"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collections"
-)
-
-func TestFsSource_NoInitialFile(t *testing.T) {
-	g := NewWithT(t)
-
-	file := setupDir(t, nil)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestFsSource_NoInitialFile_UpdateAfterStart(t *testing.T) {
-	g := NewWithT(t)
-
-	file := setupDir(t, nil)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-
-	acc.Clear()
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	writeMeshCfg(t, file, mcfg)
-
-	expected = []event.Event{
-		{
-			Kind:   event.Reset,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected[0])
-}
-
-func TestFsSource_InitialFile_UpdateAfterStart(t *testing.T) {
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: mcfg,
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-
-	acc.Clear()
-	mcfg2 := DefaultMeshConfig()
-	mcfg2.IngressClass = "bar"
-	writeMeshCfg(t, file, mcfg2)
-
-	expected = []event.Event{
-		{
-			Kind:   event.Reset,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected[0])
-}
-
-func TestFsSource_InitialFile(t *testing.T) {
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: mcfg,
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestFsSource_StartStopStart(t *testing.T) {
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: mcfg,
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-
-	acc.Clear()
-	fs.Stop()
-	g.Consistently(acc.Events()).Should(HaveLen(0))
-
-	fs.Start()
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestFsSource_FileRemoved_NoChange(t *testing.T) {
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: mcfg,
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-	acc.Clear()
-
-	err = os.Remove(file)
-	g.Expect(err).To(BeNil())
-	time.Sleep(time.Millisecond * 100)
-	g.Consistently(acc.Events()).Should(HaveLen(0))
-}
-
-func TestFsSource_BogusFile_NoChange(t *testing.T) {
-	t.Skip("https://github.com/istio/istio/issues/15987")
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := NewMeshConfigFS(file)
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: mcfg,
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-	acc.Clear()
-
-	err = os.WriteFile(file, []byte(":@#Hallo!"), os.ModePerm)
-	g.Expect(err).To(BeNil())
-
-	time.Sleep(time.Millisecond * 100)
-	g.Consistently(acc.Events).Should(HaveLen(0))
-}
-
-func setupDir(t *testing.T, m *v1alpha1.MeshConfig) string {
-	g := NewWithT(t)
-
-	p, err := os.MkdirTemp(os.TempDir(), t.Name())
-	g.Expect(err).To(BeNil())
-	file := path.Join(p, "meshconfig.yaml")
-
-	if m != nil {
-		writeMeshCfg(t, file, m)
-	}
-
-	return file
-}
-
-func writeMeshCfg(t *testing.T, file string, m *v1alpha1.MeshConfig) { // nolint:interfacer
-	g := NewWithT(t)
-	s, err := (&jsonpb.Marshaler{Indent: "  "}).MarshalToString(m)
-	g.Expect(err).To(BeNil())
-	err = os.WriteFile(file, []byte(s), os.ModePerm)
-	g.Expect(err).To(BeNil())
-}
-
-func TestFsSource_InvalidPath(t *testing.T) {
-	g := NewWithT(t)
-
-	file := setupDir(t, nil)
-	file = path.Join(file, "bogus")
-
-	_, err := NewMeshConfigFS(file)
-	g.Expect(err).NotTo(BeNil())
-}
-
-func TestFsSource_YamlToJSONError(t *testing.T) {
-	g := NewWithT(t)
-
-	mcfg := DefaultMeshConfig()
-	mcfg.IngressClass = "foo"
-	file := setupDir(t, mcfg)
-
-	fs, err := newMeshConfigFS(file, func([]byte) ([]byte, error) {
-		return nil, fmt.Errorf("horror")
-	})
-
-	g.Expect(err).To(BeNil())
-	defer func() {
-		err = fs.Close()
-		g.Expect(err).To(BeNil())
-	}()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-
-	fs.Start()
-
-	// Expect default config
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: resource.NewFullName("istio-system", "meshconfig"),
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
diff --git a/galley/pkg/config/mesh/inmemory.go b/galley/pkg/config/mesh/inmemory.go
deleted file mode 100644
index 57019949fd..0000000000
--- a/galley/pkg/config/mesh/inmemory.go
+++ /dev/null
@@ -1,156 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"sync"
-
-	"github.com/gogo/protobuf/proto"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/config/schema/collections"
-)
-
-// InMemorySource is an event.InMemorySource implementation for meshconfig. When the mesh config is first set, add & fullsync events
-// will be published. Otherwise a reset event will be sent.
-type InMemorySource struct {
-	mu      sync.Mutex
-	current proto.Message
-
-	handlers event.Handler
-
-	synced  bool
-	started bool
-}
-
-var _ event.Source = &InMemorySource{}
-
-// NewInmemoryMeshCfg returns a new in-memory source of MeshConfig.
-func NewInmemoryMeshCfg() *InMemorySource {
-	return &InMemorySource{
-		current: DefaultMeshConfig(),
-	}
-}
-
-// NewInmemoryMeshNetworks returns a new-inmemory source of MeshNetworks.
-func NewInmemoryMeshNetworks() *InMemorySource {
-	return &InMemorySource{
-		current: DefaultMeshNetworks(),
-	}
-}
-
-// Dispatch implements event.Dispatcher
-func (s *InMemorySource) Dispatch(handler event.Handler) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	s.handlers = event.CombineHandlers(s.handlers, handler)
-}
-
-// Start implements event.InMemorySource
-func (s *InMemorySource) Start() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if s.started {
-		// Already started
-		return
-	}
-	s.started = true
-
-	if s.synced {
-		s.send(event.Added)
-		s.send(event.FullSync)
-	}
-}
-
-// Stop implements event.InMemorySource
-func (s *InMemorySource) Stop() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	s.started = false
-}
-
-// Set new meshconfig
-func (s *InMemorySource) Set(cfg proto.Message) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	cfg = proto.Clone(cfg)
-	s.current = cfg
-
-	if s.started {
-		if !s.synced {
-			s.send(event.Added)
-			s.send(event.FullSync)
-		} else {
-			s.send(event.Reset)
-		}
-	}
-
-	s.synced = true
-}
-
-// IsSynced indicates that the InMemorySource has been given a Mesh config at least once.
-func (s *InMemorySource) IsSynced() bool {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	return s.synced
-}
-
-func (s *InMemorySource) send(k event.Kind) {
-	// must be called under lock
-	var c collection.Schema
-	var n resource.FullName
-	switch t := s.current.(type) {
-	case *v1alpha1.MeshConfig:
-		n = MeshConfigResourceName
-		c = collections.IstioMeshV1Alpha1MeshConfig
-	case *v1alpha1.MeshNetworks:
-		n = MeshNetworksResourceName
-		c = collections.IstioMeshV1Alpha1MeshNetworks
-	default:
-		scope.Processing.Errorf("Unsupported type: %T", t)
-	}
-
-	e := event.Event{
-		Kind:   k,
-		Source: c,
-	}
-
-	o := rt.Origin{
-		FullName:   n,
-		Collection: c.Name(),
-		Kind:       c.Resource().Kind(),
-	}
-
-	switch k {
-	case event.Added, event.Updated:
-		e.Resource = &resource.Instance{
-			Metadata: resource.Metadata{
-				FullName: n,
-				Schema:   c.Resource(),
-			},
-			Message: proto.Clone(s.current),
-			Origin:  &o,
-		}
-	}
-
-	s.handlers.Handle(e)
-}
diff --git a/galley/pkg/config/mesh/inmemory_test.go b/galley/pkg/config/mesh/inmemory_test.go
deleted file mode 100644
index 846dc95f7e..0000000000
--- a/galley/pkg/config/mesh/inmemory_test.go
+++ /dev/null
@@ -1,237 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collections"
-)
-
-func TestInMemorySource_Empty(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	g.Expect(s.IsSynced()).To(BeFalse())
-
-	s.Start()
-
-	g.Consistently(s.IsSynced).Should(BeFalse())
-	g.Consistently(acc.Events).Should(HaveLen(0))
-}
-
-func TestInMemorySource_SetBeforeStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Set(DefaultMeshConfig())
-	g.Expect(s.IsSynced()).To(BeTrue())
-
-	s.Start()
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: MeshConfigResourceName,
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestInMemorySource_SetAfterStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Start()
-	s.Set(DefaultMeshConfig())
-	g.Expect(s.IsSynced()).To(BeTrue())
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: MeshConfigResourceName,
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestInMemorySource_DoubleStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Set(DefaultMeshConfig())
-	s.Start()
-	s.Start()
-	g.Expect(s.IsSynced()).To(BeTrue())
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: MeshConfigResourceName,
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestInMemorySource_StartStop(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Start()
-	s.Set(DefaultMeshConfig())
-	s.Stop()
-	acc.Clear()
-
-	s.Start()
-	g.Expect(s.IsSynced()).To(BeTrue())
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: MeshConfigResourceName,
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
-
-func TestInMemorySource_ResetOnUpdate(t *testing.T) {
-	s := NewInmemoryMeshCfg()
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Start()
-	s.Set(DefaultMeshConfig())
-	m := DefaultMeshConfig()
-	m.IngressClass = "foo"
-	s.Set(m)
-
-	expected := []event.Event{
-		{
-			Kind:   event.Added,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-			Resource: &resource.Instance{
-				Metadata: resource.Metadata{
-					FullName: MeshConfigResourceName,
-					Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-				},
-				Message: DefaultMeshConfig(),
-				Origin: &rt.Origin{
-					Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-					Kind:       "MeshConfig",
-					FullName:   resource.NewFullName("istio-system", "meshconfig"),
-				},
-			},
-		},
-		{
-			Kind:   event.FullSync,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-		{
-			Kind:   event.Reset,
-			Source: collections.IstioMeshV1Alpha1MeshConfig,
-		},
-	}
-	fixtures.ExpectEventsEventually(t, acc, expected...)
-}
diff --git a/galley/pkg/config/mesh/metadata_test.go b/galley/pkg/config/mesh/metadata_test.go
deleted file mode 100644
index 151edec1da..0000000000
--- a/galley/pkg/config/mesh/metadata_test.go
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"testing"
-
-	"istio.io/istio/pkg/config/schema"
-	"istio.io/istio/pkg/config/schema/collections"
-)
-
-func TestMeshConfigNameValidity(t *testing.T) {
-	m := schema.MustGet()
-	_, found := m.AllCollections().Find(collections.IstioMeshV1Alpha1MeshConfig.Name().String())
-	if !found {
-		t.Fatalf("Mesh config collection not found in metadata.")
-	}
-}
diff --git a/galley/pkg/config/monitoring/monitoring.go b/galley/pkg/config/monitoring/monitoring.go
deleted file mode 100644
index 1fa6d8f327..0000000000
--- a/galley/pkg/config/monitoring/monitoring.go
+++ /dev/null
@@ -1,253 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package monitoring
-
-import (
-	"context"
-	"fmt"
-	"strings"
-	"sync"
-	"time"
-
-	"go.opencensus.io/stats"
-	"go.opencensus.io/stats/view"
-	"go.opencensus.io/tag"
-
-	"istio.io/istio/galley/pkg/config/scope"
-)
-
-const (
-	collection = "collection"
-	namespace  = "namespace"
-	name       = "name"
-	version    = "version"
-)
-
-var (
-	// CollectionTag holds the type URL for the context.
-	CollectionTag tag.Key
-	// NamespaceTag holds namespace of the resource for the context.
-	NamespaceTag tag.Key
-	// NameTag holds name of the resource for the context.
-	NameTag tag.Key
-	// VersionTag holds version of the resource for the context.
-	VersionTag tag.Key
-	// StateTypeConfigKeys holds key tags for runtime state metrics.
-	StateTypeConfigKeys []tag.Key
-)
-
-var (
-	strategyOnChangeTotal = stats.Int64(
-		"galley/runtime/strategy/on_change_total",
-		"The number of times the strategy's onChange has been called",
-		stats.UnitDimensionless)
-	strategyOnTimerMaxTimeReachedTotal = stats.Int64(
-		"galley/runtime/strategy/timer_max_time_reached_total",
-		"The number of times the max time has been reached",
-		stats.UnitDimensionless)
-	strategyOnTimerQuiesceReachedTotal = stats.Int64(
-		"galley/runtime/strategy/timer_quiesce_reached_total",
-		"The number of times a quiesce has been reached",
-		stats.UnitDimensionless)
-	strategyOnTimerResetTotal = stats.Int64(
-		"galley/runtime/strategy/timer_resets_total",
-		"The number of times the timer has been reset",
-		stats.UnitDimensionless)
-	processorEventSpansMs = stats.Int64(
-		"galley/runtime/processor/event_span_duration_milliseconds",
-		"The duration between each incoming event",
-		stats.UnitMilliseconds)
-	processorEventsProcessed = stats.Int64(
-		"galley/runtime/processor/events_processed_total",
-		"The number of events that have been processed",
-		stats.UnitDimensionless)
-	processorSnapshotsPublished = stats.Int64(
-		"galley/runtime/processor/snapshots_published_total",
-		"The number of snapshots that have been published",
-		stats.UnitDimensionless)
-	processorEventsPerSnapshot = stats.Int64(
-		"galley/runtime/processor/snapshot_events_total",
-		"The number of events per snapshot",
-		stats.UnitDimensionless)
-	processorSnapshotLifetimesMs = stats.Int64(
-		"galley/runtime/processor/snapshot_lifetime_duration_milliseconds",
-		"The duration of each snapshot",
-		stats.UnitMilliseconds)
-	stateTypeInstancesTotal = stats.Int64(
-		"galley/runtime/state/type_instances_total",
-		"The number of type instances per type URL",
-		stats.UnitDimensionless)
-
-	durationDistributionMs = view.Distribution(0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8193, 16384, 32768, 65536,
-		131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608)
-
-	stateTypeConfigTotal     map[string]*stats.Int64Measure
-	stateTypeCollectionMutex sync.RWMutex
-)
-
-// RecordStrategyOnChange event
-func RecordStrategyOnChange() {
-	stats.Record(context.Background(), strategyOnChangeTotal.M(1))
-}
-
-// RecordOnTimer event
-func RecordOnTimer(maxTimeReached, quiesceTimeReached, timerReset bool) {
-	if maxTimeReached {
-		stats.Record(context.Background(), strategyOnTimerMaxTimeReachedTotal.M(1))
-	}
-	if quiesceTimeReached {
-		stats.Record(context.Background(), strategyOnTimerQuiesceReachedTotal.M(1))
-	}
-	if timerReset {
-		stats.Record(context.Background(), strategyOnTimerResetTotal.M(1))
-	}
-}
-
-// RecordProcessorEventProcessed event
-func RecordProcessorEventProcessed(eventSpan time.Duration) {
-	stats.Record(context.Background(), processorEventsProcessed.M(1),
-		processorEventSpansMs.M(eventSpan.Nanoseconds()/1e6))
-}
-
-// RecordProcessorSnapshotPublished event
-func RecordProcessorSnapshotPublished(events int64, snapshotSpan time.Duration) {
-	stats.Record(context.Background(), processorSnapshotsPublished.M(1))
-	stats.Record(context.Background(), processorEventsPerSnapshot.M(events),
-		processorSnapshotLifetimesMs.M(snapshotSpan.Nanoseconds()/1e6))
-}
-
-// RecordStateTypeCount event
-func RecordStateTypeCount(collection string, count int) {
-	ctx, err := tag.New(context.Background(), tag.Insert(CollectionTag, collection))
-	if err != nil {
-		scope.Processing.Errorf("Error creating monitoring context for counting state: %v", err)
-	} else {
-		RecordStateTypeCountWithContext(ctx, count)
-	}
-}
-
-// RecordStateTypeCountWithContext event
-func RecordStateTypeCountWithContext(ctx context.Context, count int) {
-	if ctx != nil {
-		stats.Record(ctx, stateTypeInstancesTotal.M(int64(count)))
-	}
-}
-
-// RecordDetailedStateType records name, namespace, version of the resource in Galley.
-func RecordDetailedStateType(namespace, name string, collection fmt.Stringer, count int) {
-	collectionStr := strings.Split(collection.String(), "/")
-	// collection is of the format istio/<kind>/<version>/<name>
-	if len(collectionStr) < 4 {
-		scope.Processing.Errorf("length of collection is less than 4, does not match expectation. collection: %v",
-			collectionStr)
-		return
-	}
-	ctx, err := tag.New(context.Background(), tag.Insert(NamespaceTag, namespace),
-		tag.Insert(NameTag, name), tag.Insert(VersionTag, collectionStr[2]))
-	if err != nil {
-		scope.Processing.Errorf("error creating monitoring context for counting state: %v", err)
-		return
-	}
-
-	// We remove version from the collection name as it has been added as the VersionTag in the measurement.
-	collectionName := strings.Replace(collection.String(),
-		fmt.Sprintf("%s/", collectionStr[2]), "", 1)
-	RecordDetailedStateTypeWithContext(ctx, collectionName, count)
-}
-
-// RecordDetailedStateTypeWithContext event
-func RecordDetailedStateTypeWithContext(ctx context.Context, collection string, count int) {
-	if ctx == nil {
-		return
-	}
-	stateTypeCollectionMutex.Lock()
-	defer stateTypeCollectionMutex.Unlock()
-	if stateTypeConfigTotal[collection] == nil {
-		err := registerNewStateTypeConfigView(collection)
-		if err != nil {
-			scope.Processing.Errorf("could not register collection %v for monitoring", err)
-			return
-		}
-	}
-	stats.Record(ctx, stateTypeConfigTotal[collection].M(int64(count)))
-}
-
-func newView(measure stats.Measure, keys []tag.Key, aggregation *view.Aggregation) *view.View {
-	return &view.View{
-		Name:        measure.Name(),
-		Description: measure.Description(),
-		Measure:     measure,
-		TagKeys:     keys,
-		Aggregation: aggregation,
-	}
-}
-
-func getStateTypeConfigKeys() ([]tag.Key, error) {
-	var err error
-	if NamespaceTag, err = tag.NewKey(namespace); err != nil {
-		return nil, err
-	}
-	if NameTag, err = tag.NewKey(name); err != nil {
-		return nil, err
-	}
-	if VersionTag, err = tag.NewKey(version); err != nil {
-		return nil, err
-	}
-
-	return []tag.Key{NamespaceTag, NameTag, VersionTag}, err
-}
-
-func registerNewStateTypeConfigView(collection string) error {
-	stateTypeConfigTotal[collection] = stats.Int64(fmt.Sprintf("galley/%s", collection),
-		fmt.Sprintf("The number of valid %v known to galley at a point in time", collection),
-		stats.UnitDimensionless)
-	err := view.Register(
-		newView(stateTypeConfigTotal[collection], StateTypeConfigKeys, view.LastValue()),
-	)
-	return err
-}
-
-func init() {
-	var err error
-	if CollectionTag, err = tag.NewKey(collection); err != nil {
-		panic(err)
-	}
-
-	var noKeys []tag.Key
-	collectionKeys := []tag.Key{CollectionTag}
-
-	err = view.Register(
-		newView(strategyOnTimerResetTotal, noKeys, view.Count()),
-		newView(strategyOnChangeTotal, noKeys, view.Count()),
-		newView(strategyOnTimerMaxTimeReachedTotal, noKeys, view.Count()),
-		newView(strategyOnTimerQuiesceReachedTotal, noKeys, view.Count()),
-		newView(processorEventSpansMs, noKeys, durationDistributionMs),
-		newView(processorEventsProcessed, noKeys, view.Count()),
-		newView(processorSnapshotsPublished, noKeys, view.Count()),
-		newView(processorEventsPerSnapshot, noKeys, view.Distribution(0, 1, 2, 4, 8, 16, 32, 64, 128, 256)),
-		newView(processorSnapshotLifetimesMs, noKeys, durationDistributionMs),
-		newView(stateTypeInstancesTotal, collectionKeys, view.LastValue()),
-	)
-
-	if err != nil {
-		panic(err)
-	}
-
-	stateTypeConfigTotal = make(map[string]*stats.Int64Measure)
-	StateTypeConfigKeys, err = getStateTypeConfigKeys()
-	if err != nil {
-		panic(err)
-	}
-}
diff --git a/galley/pkg/config/processing/processor.go b/galley/pkg/config/processing/processor.go
deleted file mode 100644
index 9b8f3411a1..0000000000
--- a/galley/pkg/config/processing/processor.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processing
-
-import (
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/pkg/config/event"
-)
-
-// ProcessorOptions are options that are passed to event.Processors during startup.
-type ProcessorOptions struct {
-	MeshConfig   *v1alpha1.MeshConfig
-	DomainSuffix string
-}
-
-// ProcessorProvider returns a new Processor instance for the given ProcessorOptions.
-type ProcessorProvider func(o ProcessorOptions) event.Processor
diff --git a/galley/pkg/config/processing/runtime.go b/galley/pkg/config/processing/runtime.go
deleted file mode 100644
index 3dd507db7f..0000000000
--- a/galley/pkg/config/processing/runtime.go
+++ /dev/null
@@ -1,164 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processing
-
-import (
-	"sync"
-	"sync/atomic"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-)
-
-// RuntimeOptions is options for Runtime
-type RuntimeOptions struct {
-	Source            event.Source
-	ProcessorProvider ProcessorProvider
-	DomainSuffix      string
-}
-
-// Clone returns a cloned copy of the RuntimeOptions.
-func (o RuntimeOptions) Clone() RuntimeOptions {
-	return o
-}
-
-// Runtime is the top-level config processing machinery. Through runtime options, it takes in a set of Sources and
-// a Processor. Once started, Runtime will go through a startup phase, where it waits for MeshConfig to arrive before
-// starting the Processor. If, the Runtime receives any event.RESET events, or if there is a change to the MeshConfig,
-// then the Runtime will stop the processor and sources and will restart them again.
-//
-// Internally, Runtime uses the session type to implement this stateful behavior. The session handles state transitions
-// and is responsible for starting/stopping the Sources, Processors, in the correct order.
-type Runtime struct { // nolint:maligned
-	mu sync.RWMutex
-
-	// counter for session id. The current value reflects the processing session's id.
-	sessionIDCtr int32
-
-	// runtime options that was passed as parameters to the command-line.
-	options RuntimeOptions
-
-	// stopCh is used to send stop signal completion to the background go-routine.
-	stopCh chan struct{}
-
-	// wg is used to synchronize the completion of Stop call with the completion of the background
-	// go routine.
-	wg      sync.WaitGroup
-	session atomic.Value
-}
-
-// NewRuntime returns a new instance of a processing.Runtime.
-func NewRuntime(o RuntimeOptions) *Runtime {
-	r := &Runtime{
-		options: o.Clone(),
-	}
-
-	h := event.HandlerFromFn(r.handle)
-	o.Source.Dispatch(h)
-
-	return r
-}
-
-// Start the Runtime
-func (r *Runtime) Start() {
-	r.mu.Lock()
-	defer r.mu.Unlock()
-
-	if r.stopCh != nil {
-		scope.Processing.Warnf("Runtime.Start: already started")
-		return
-	}
-	r.stopCh = make(chan struct{})
-
-	r.wg.Add(1)
-	startedCh := make(chan struct{})
-	go r.run(startedCh, r.stopCh)
-	<-startedCh
-}
-
-// Stop the Runtime
-func (r *Runtime) Stop() {
-	r.mu.Lock()
-	defer r.mu.Unlock()
-
-	if r.stopCh == nil {
-		return
-	}
-	close(r.stopCh)
-	r.wg.Wait()
-
-	r.stopCh = nil
-}
-
-// currentSessionID is a numeric identifier of internal Runtime state. It is used for debugging purposes.
-func (r *Runtime) currentSessionID() int32 {
-	var id int32
-	se := r.session.Load()
-	if se != nil {
-		s := se.(*session)
-		id = s.id
-	}
-	return id
-}
-
-// currentSessionState is the state of the internal Runtime state. It is used for debugging purposes.
-func (r *Runtime) currentSessionState() sessionState {
-	var state sessionState
-	se := r.session.Load()
-	if se != nil {
-		s := se.(*session)
-		state = s.getState()
-	}
-	return state
-}
-
-func (r *Runtime) run(startedCh, stopCh chan struct{}) {
-loop:
-	for {
-		sid := atomic.AddInt32(&r.sessionIDCtr, 1)
-		scope.Processing.Infof("Runtime.run: Starting new session id:%d", sid)
-		se, done := newSession(sid, r.options)
-		r.session.Store(se)
-		se.start()
-
-		if startedCh != nil {
-			close(startedCh)
-			startedCh = nil
-		}
-
-		select {
-		case <-done:
-			scope.Processing.Infof("Runtime.run: Completing session: id:%d", sid)
-
-		case <-stopCh:
-			scope.Processing.Infof("Runtime.run: Stopping session: id%d", sid)
-			se.stop()
-			break loop
-		}
-	}
-
-	r.wg.Done()
-	scope.Processing.Info("Runtime.run: Exiting...")
-}
-
-func (r *Runtime) handle(e event.Event) {
-	se := r.session.Load()
-	if se == nil {
-		return
-	}
-
-	s := se.(*session)
-	s.handle(e)
-}
diff --git a/galley/pkg/config/processing/runtime_test.go b/galley/pkg/config/processing/runtime_test.go
deleted file mode 100644
index c6a5e7666c..0000000000
--- a/galley/pkg/config/processing/runtime_test.go
+++ /dev/null
@@ -1,467 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processing
-
-import (
-	"sync"
-	"testing"
-
-	"github.com/gogo/protobuf/types"
-	. "github.com/onsi/gomega"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/inmemory"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collections"
-	"istio.io/pkg/log"
-)
-
-func init() {
-	scope.Processing.SetOutputLevel(log.DebugLevel)
-}
-
-func TestRuntime_Startup_NoMeshConfig(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	defer f.rt.Stop()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	g.Consistently(f.p.acc.Events).Should(HaveLen(0))
-	g.Consistently(f.p.HasStarted).Should(BeFalse())
-}
-
-func TestRuntime_Startup_MeshConfig_Arrives_No_Resources(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	defer f.rt.Stop()
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-
-	g.Eventually(f.p.acc.Events).Should(HaveLen(3))
-	fixtures.ExpectEventsEventually(t, &f.p.acc,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig),
-		event.AddFor(collections.IstioMeshV1Alpha1MeshConfig, meshConfigEntry(mesh.DefaultMeshConfig())))
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-}
-
-func TestRuntime_Startup_MeshConfig_Arrives(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	defer f.rt.Stop()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-	g.Eventually(f.p.acc.Events).Should(HaveLen(4))
-	fixtures.ExpectEventsEventually(t, &f.p.acc,
-		event.AddFor(basicmeta.K8SCollection1, r),
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig),
-		event.AddFor(collections.IstioMeshV1Alpha1MeshConfig, meshConfigEntry(mesh.DefaultMeshConfig())),
-	)
-
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-}
-
-func TestRuntime_Startup_Stop(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-
-	g.Eventually(f.p.acc.Events).Should(HaveLen(4))
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-	f.rt.Stop()
-	g.Eventually(f.p.HasStarted).Should(BeFalse())
-}
-
-func TestRuntime_Start_Start_Stop(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	f.rt.Start() // Double start
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-	g.Eventually(f.p.acc.Events).Should(HaveLen(4))
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-	f.rt.Stop()
-	g.Eventually(f.p.HasStarted).Should(BeFalse())
-}
-
-func TestRuntime_Start_Stop_Stop(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-
-	g.Eventually(f.p.acc.Events).Should(HaveLen(4))
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-	f.rt.Stop()
-	f.rt.Stop()
-	g.Eventually(f.p.HasStarted).Should(BeFalse())
-}
-
-func TestRuntime_MeshConfig_Causing_Restart(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	defer f.rt.Stop()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Get(coll.Name()).Set(r)
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-	fixtures.ExpectEventsEventually(t, &f.p.acc,
-		event.AddFor(collections.IstioMeshV1Alpha1MeshConfig, &resource.Instance{
-			Metadata: resource.Metadata{
-				FullName: mesh.MeshConfigResourceName,
-				Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-			},
-			Message: mesh.DefaultMeshConfig(),
-			Origin: &rt.Origin{
-				Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-				Kind:       "MeshConfig",
-				FullName:   resource.NewFullName("istio-system", "meshconfig"),
-			},
-		}),
-		event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig),
-		event.AddFor(coll, r),
-		event.FullSyncFor(coll),
-	)
-
-	oldSessionID := f.rt.currentSessionID()
-
-	f.p.acc.Clear()
-
-	mcfg := mesh.DefaultMeshConfig()
-	mcfg.IngressClass = "ing"
-
-	f.meshsrc.Set(mcfg)
-	g.Eventually(f.rt.currentSessionID).Should(Equal(oldSessionID + 1))
-	g.Eventually(f.p.acc.Events).Should(HaveLen(4))
-}
-
-func TestRuntime_Event_Before_Start(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-
-	coll := basicmeta.K8SCollection1
-	r := &resource.Instance{
-		Metadata: resource.Metadata{},
-		Message:  &types.Empty{},
-	}
-	f.src.Start()
-	f.src.Get(coll.Name()).Set(r)
-
-	g.Consistently(f.p.acc.Events).Should(HaveLen(0))
-}
-
-func TestRuntime_Stop_WhileStarting(t *testing.T) {
-	g := NewWithT(t)
-
-	f := newFixture()
-	f.meshsrc = nil
-	f.src = nil
-	f.init()
-
-	// Wait until mockSrc.Start is called, but block it from completing.
-	f.mockSrc.blockStart()
-
-	f.rt.Start()
-
-	g.Eventually(f.rt.currentSessionState).Should(Equal(starting))
-	g.Eventually(f.mockSrc.hasStarted).Should(BeTrue())
-
-	go f.rt.Stop()
-
-	g.Eventually(f.rt.currentSessionState).Should(Equal(terminating))
-
-	// release Start call. Things should cleanup and release.
-	f.mockSrc.releaseStart()
-
-	// Once Stop returns, both started and stopped should be
-	g.Eventually(f.mockSrc.hasStopped).Should(BeTrue())
-}
-
-func TestRuntime_Reset_WhileStarting(t *testing.T) {
-	g := NewWithT(t)
-
-	f := newFixture()
-	f.meshsrc = nil
-	f.src = nil
-	f.init()
-
-	// Wait until mockSrc.Start is called, but block it from completing.
-	f.mockSrc.blockStart()
-
-	f.rt.Start()
-
-	g.Eventually(f.rt.currentSessionState).Should(Equal(starting))
-	g.Eventually(f.mockSrc.hasStarted).Should(BeTrue())
-
-	oldSessionID := f.rt.currentSessionID()
-
-	f.mockSrc.h.Handle(event.Event{Kind: event.Reset})
-
-	f.mockSrc.releaseStart()
-
-	g.Eventually(f.rt.currentSessionID).Should(Equal(oldSessionID + 1))
-
-	g.Eventually(f.rt.currentSessionState).Should(Equal(buffering))
-	g.Consistently(f.p.acc.Events).Should(BeEmpty())
-
-	f.rt.Stop()
-}
-
-func TestRuntime_MeshEvent_WhileBuffering(t *testing.T) {
-	g := NewWithT(t)
-
-	f := newFixture()
-	f.meshsrc = nil
-	f.src = nil
-	f.init()
-
-	f.rt.Start()
-	g.Eventually(f.rt.currentSessionState).Should(Equal(buffering))
-
-	f.mockSrc.h.Handle(event.DeleteFor(collections.IstioMeshV1Alpha1MeshConfig, mesh.MeshConfigResourceName, "vxx"))
-
-	g.Consistently(f.rt.currentSessionState).Should(Equal(buffering))
-
-	f.mockSrc.h.Handle(event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig))
-
-	g.Eventually(f.rt.currentSessionState).Should(Equal(processing))
-
-	f.rt.Stop()
-}
-
-func TestRuntime_MeshEvent_WhileRunning(t *testing.T) {
-	g := NewWithT(t)
-
-	f := initFixture()
-	f.rt.Start()
-	defer f.rt.Stop()
-
-	f.meshsrc.Set(mesh.DefaultMeshConfig())
-	fixtures.ExpectEventsEventually(t, &f.p.acc,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig),
-		event.AddFor(collections.IstioMeshV1Alpha1MeshConfig, meshConfigEntry(mesh.DefaultMeshConfig())),
-	)
-
-	oldSessionID := f.rt.currentSessionID()
-	f.p.acc.Clear()
-
-	// Send a mesh event out-of-band
-	f.mockSrc.h.Handle(event.DeleteFor(collections.IstioMeshV1Alpha1MeshConfig, mesh.MeshConfigResourceName, "vxx"))
-
-	g.Eventually(f.rt.currentSessionID).Should(Equal(oldSessionID + 1))
-	fixtures.ExpectEventsEventually(t, &f.p.acc,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		event.FullSyncFor(collections.IstioMeshV1Alpha1MeshConfig),
-		event.AddFor(collections.IstioMeshV1Alpha1MeshConfig, meshConfigEntry(mesh.DefaultMeshConfig())))
-
-	g.Eventually(f.p.HasStarted).Should(BeTrue())
-}
-
-type fixture struct {
-	meshsrc *mesh.InMemorySource
-	src     *inmemory.KubeSource
-	mockSrc *testSource
-	p       *testProcessor
-	rt      *Runtime
-}
-
-func newFixture() *fixture {
-	p := &testProcessor{}
-	f := &fixture{
-		meshsrc: mesh.NewInmemoryMeshCfg(),
-		src:     inmemory.NewKubeSource(basicmeta.MustGet().KubeCollections()),
-		mockSrc: &testSource{},
-		p:       p,
-	}
-
-	f.mockSrc.startCalled = sync.NewCond(&f.mockSrc.mu)
-	return f
-}
-
-func initFixture() *fixture {
-	f := newFixture()
-	f.init()
-	return f
-}
-
-func (f *fixture) init() {
-	var srcs []event.Source
-
-	if f.meshsrc != nil {
-		srcs = append(srcs, f.meshsrc)
-	}
-	if f.src != nil {
-		srcs = append(srcs, f.src)
-	}
-	if f.mockSrc != nil {
-		srcs = append(srcs, f.mockSrc)
-	}
-
-	o := RuntimeOptions{
-		DomainSuffix:      "local.svc",
-		Source:            event.CombineSources(srcs...),
-		ProcessorProvider: func(_ ProcessorOptions) event.Processor { return f.p },
-	}
-
-	f.rt = NewRuntime(o)
-}
-
-type testSource struct {
-	mu          sync.Mutex
-	h           event.Handler
-	startCalled *sync.Cond
-	startWG     sync.WaitGroup
-	started     bool
-	stopped     bool
-}
-
-var _ event.Source = &testSource{}
-
-func (s *testSource) Dispatch(handler event.Handler) {
-	s.h = event.CombineHandlers(s.h, handler)
-}
-
-func (s *testSource) Start() {
-	s.mu.Lock()
-	s.startCalled.Broadcast()
-	s.started = true
-	s.mu.Unlock()
-	s.startWG.Wait()
-}
-
-func (s *testSource) Stop() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	s.stopped = true
-}
-
-func (s *testSource) blockStart() {
-	s.startWG.Add(1)
-}
-
-func (s *testSource) releaseStart() {
-	s.startWG.Done()
-}
-
-func (s *testSource) hasStarted() bool {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	return s.started
-}
-
-func (s *testSource) hasStopped() bool {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	return s.stopped
-}
-
-type testProcessor struct {
-	acc     fixtures.Accumulator
-	started bool
-}
-
-func (t *testProcessor) Handle(e event.Event) {
-	t.acc.Handle(e)
-}
-
-func (t *testProcessor) Start() {
-	t.started = true
-}
-
-func (t *testProcessor) Stop() {
-	t.started = false
-}
-
-func (t *testProcessor) HasStarted() bool {
-	return t.started
-}
-
-func meshConfigEntry(m *v1alpha1.MeshConfig) *resource.Instance { // nolint:interfacer
-	return &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: resource.NewFullName("istio-system", "meshconfig"),
-			Schema:   collections.IstioMeshV1Alpha1MeshConfig.Resource(),
-		},
-		Message: m,
-		Origin: &rt.Origin{
-			Collection: collections.IstioMeshV1Alpha1MeshConfig.Name(),
-			Kind:       "MeshConfig",
-			FullName:   resource.NewFullName("istio-system", "meshconfig"),
-		},
-	}
-}
diff --git a/galley/pkg/config/processing/session.go b/galley/pkg/config/processing/session.go
deleted file mode 100644
index 0f7b9f9bd0..0000000000
--- a/galley/pkg/config/processing/session.go
+++ /dev/null
@@ -1,313 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processing
-
-import (
-	"fmt"
-	"sync"
-
-	"github.com/gogo/protobuf/proto"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collections"
-)
-
-type sessionState string
-
-const (
-	// The session is inactive. This is both the initial, and the terminal state of the session.
-	// Allowed transitions are: starting
-	inactive = sessionState("inactive")
-
-	// The session is starting up. In this phase, the sources are being initialized. The starting session is an explicit
-	// state, since it is possible to get lifecycle events during the startup of sources. Having an explicit state for
-	// startup enables handling such lifecycle events appropriately.
-	// Allowed transitions are: buffering, terminating
-	starting = sessionState("starting")
-
-	// The session is buffering events until a mesh configuration arrives.
-	// Allowed transitions are: processing, terminating
-	buffering = sessionState("buffering")
-
-	// The session is in full execution mode, processing events.
-	// Allowed transitions are: terminating
-	processing = sessionState("processing")
-
-	// The session is terminating. It will ignore all incoming events, while processors & sources are being stopped.
-	// Allowed transitions are: inactive
-	terminating = sessionState("terminating")
-)
-
-// session represents a config processing session. It is a stateful controller type whose main responsibility is to
-// manage state transitions and react to the events that impact lifecycle.
-//
-// A session starts with an external request (through the start() method, called by Runtime) which puts the session into
-// the "starting" state. During this phase, the Sources are started, and the events from Sources  start to come in. Once
-// all sources are started, the session transitions to the "buffering" state.
-//
-// In "buffering" (and also in "starting") state, the incoming events are selectively buffered, until a usable mesh
-// configuration is received. Once received, the buffered events start getting processed.
-//
-// The main difference between buffering & starting states is how life-cycle events (such as a stop() call from
-// Runtime, or a received reset event) are handled. In starting state, the cleanup is performed right within the context
-// of the startup call.
-//
-// Once a mesh config is received, the state transitions to the "processing" state, where the processor is initialized
-// and buffered events starts getting processed. This is a steady-state, and persists until a life-cycle event occurs
-// (i.e. an explicit stop call from Runtime, a Reset event, or a change in mesh config). Once such a life-cycle event
-// occurs, the state transitions to "terminating", and teardown operations take place (i.e. stop Processor, stop
-// Sources etc.).
-type session struct { // nolint:maligned
-	mu sync.Mutex
-
-	id      int32
-	options RuntimeOptions
-	buffer  *event.Buffer
-
-	state sessionState
-
-	// mesh config state
-	meshCfg    *v1alpha1.MeshConfig
-	meshSynced bool
-
-	processor event.Processor
-	doneCh    chan struct{}
-}
-
-// newSession creates a new config processing session state. It returns the session, as well as a channel
-// that will be closed upon termination of the session.
-func newSession(id int32, o RuntimeOptions) (*session, chan struct{}) {
-	s := &session{
-		id:      id,
-		options: o,
-		buffer:  event.NewBuffer(),
-		state:   inactive,
-		doneCh:  make(chan struct{}),
-	}
-
-	return s, s.doneCh
-}
-
-// start the session. This must be called when state == inactive.
-func (s *session) start() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	if s.state != inactive {
-		panic(fmt.Sprintf("invalid state: %s (expecting inactive)", s.state))
-	}
-	s.transitionTo(starting)
-
-	go s.startSources()
-}
-
-func (s *session) startSources() {
-	scope.Processing.Debug("session starting sources...")
-	// start source after relinquishing lock. This avoids deadlocks.
-	s.options.Source.Start()
-
-	scope.Processing.Debugf("session source start complete")
-
-	// check the state again. During startup we might have received mesh config, or got signaled for stop.
-	var terminate bool
-	s.mu.Lock()
-	switch s.state {
-	case starting:
-		// This is the expected state. Depending on whether we received mesh config or not we can transition to the
-		// buffering, or processing states.
-		s.transitionTo(buffering)
-		if s.meshSynced {
-			s.startProcessing()
-		}
-
-	case terminating:
-		// stop was called during startup. There is nothing we can do, simply exit.
-		terminate = true
-
-	default:
-		panic(fmt.Sprintf("session.start: unexpected state during session startup: %v", s.state))
-	}
-	s.mu.Unlock()
-
-	if terminate {
-		s.terminate()
-	}
-}
-
-func (s *session) stop() {
-	scope.Processing.Debug("session.stop()")
-
-	var terminate bool
-	s.mu.Lock()
-	switch s.state {
-	case starting:
-		// set the state to terminating and let the startup code complete startup steps and deal with termination.
-		s.transitionTo(terminating)
-
-	case buffering, processing:
-		s.transitionTo(terminating)
-		terminate = true
-
-	case terminating:
-		scope.Processing.Warn("session stopped more than once")
-
-	default:
-		panic(fmt.Errorf("session.stop: Invalid state: %v", s.state))
-	}
-	s.mu.Unlock()
-	if terminate {
-		s.terminate()
-	}
-}
-
-func (s *session) terminate() {
-	// must be called outside lock.
-	s.mu.Lock()
-	if s.state != terminating {
-		panic(fmt.Sprintf("invalid state: %s (expecting terminating)", s.state))
-	}
-	s.mu.Unlock()
-
-	scope.Processing.Debug("session.terminate: stopping buffer...")
-	s.buffer.Stop()
-	scope.Processing.Debug("session.terminate: stopping processor...")
-	if s.processor != nil {
-		s.processor.Stop()
-	}
-	scope.Processing.Debug("session.terminate: stopping sources...")
-	s.options.Source.Stop()
-
-	scope.Processing.Debug("session.terminate: signaling session termination...")
-	s.mu.Lock()
-	if s.doneCh != nil {
-		close(s.doneCh)
-		s.doneCh = nil
-	}
-	s.transitionTo(inactive)
-	s.mu.Unlock()
-}
-
-func (s *session) startProcessing() {
-	// must be called under lock.
-	if s.state != buffering {
-		panic(fmt.Sprintf("invalid state: %s (expecting buffering)", s.state))
-	}
-
-	// immediately transition to the processing state
-	o := ProcessorOptions{
-		DomainSuffix: s.options.DomainSuffix,
-		MeshConfig:   proto.Clone(s.meshCfg).(*v1alpha1.MeshConfig),
-	}
-	s.processor = s.options.ProcessorProvider(o)
-	s.buffer.Dispatch(s.processor)
-	s.processor.Start()
-	s.transitionTo(processing)
-	go s.buffer.Process()
-}
-
-func (s *session) handle(e event.Event) {
-	// Check the event kind first to avoid excessive locking.
-	if e.Kind != event.Reset {
-		s.buffer.Handle(e)
-
-		if e.SourceName() == collections.IstioMeshV1Alpha1MeshConfig.Name() {
-			s.handleMeshEvent(e)
-		}
-		return
-	}
-
-	// Handle the reset event
-	s.mu.Lock()
-	switch s.state {
-	case inactive, terminating:
-		// nothing to do
-
-	case starting:
-		// set the state to terminating and let the startup code complete startup steps and deal with termination.
-		s.transitionTo(terminating)
-
-	case buffering, processing:
-		s.transitionTo(terminating)
-		go s.terminate()
-
-	default:
-		panic(fmt.Errorf("session.handle: invalid session state: %v", s.state))
-	}
-	s.mu.Unlock()
-}
-
-func (s *session) handleMeshEvent(e event.Event) {
-	s.mu.Lock()
-
-	switch s.state {
-	case inactive, terminating:
-		// nothing to do
-
-	case processing:
-		scope.Processing.Infof("session.handleMeshEvent: Mesh event received during running state, restarting: %+v", e)
-		s.transitionTo(terminating)
-		go s.terminate()
-
-	case starting:
-		scope.Processing.Infof("session.handleMeshEvent: Received initial mesh event, applying it: %+v", e)
-		s.applyMeshEvent(e)
-
-	case buffering:
-		s.applyMeshEvent(e)
-		if s.meshSynced {
-			s.startProcessing()
-		}
-
-	default:
-		panic(fmt.Errorf("session.handleMeshEvent: mesh event in unsupported state '%v': %+v", s.state, e))
-	}
-
-	s.mu.Unlock()
-}
-
-func (s *session) applyMeshEvent(e event.Event) {
-	// Apply the meshconfig changes directly to the internal state.
-	switch e.Kind {
-	case event.Added, event.Updated:
-		scope.Processing.Infof("session.handleMeshEvent: received an add/update mesh config event: %v", e)
-		s.meshCfg = proto.Clone(e.Resource.Message).(*v1alpha1.MeshConfig)
-	case event.Deleted:
-		scope.Processing.Infof("session.handleMeshEvent: received a delete mesh config event: %v", e)
-		s.meshCfg = mesh.DefaultMeshConfig()
-	case event.FullSync:
-		scope.Processing.Infof("session.applyMeshEvent meshSynced: %v => %v", s.meshSynced, true)
-		s.meshSynced = true
-
-	// reset case is already handled by the time call arrives here.
-
-	default:
-		panic(fmt.Errorf("session.handleMeshEvent: unrecognized event kind: %v", e.Kind))
-	}
-}
-
-func (s *session) transitionTo(st sessionState) {
-	scope.Processing.Infof("session[%d] %q => %q", s.id, s.state, st)
-	s.state = st
-}
-
-// getState returns the state of session. This is useful for testing/debugging purposes.
-func (s *session) getState() sessionState {
-	s.mu.Lock()
-	st := s.state
-	s.mu.Unlock()
-	return st
-}
diff --git a/galley/pkg/config/processing/snapshotter/analyzingdistributor.go b/galley/pkg/config/processing/snapshotter/analyzingdistributor.go
deleted file mode 100644
index ef4950eb3e..0000000000
--- a/galley/pkg/config/processing/snapshotter/analyzingdistributor.go
+++ /dev/null
@@ -1,279 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"strings"
-	"sync"
-
-	"github.com/ryanuber/go-glob"
-
-	"istio.io/api/annotation"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// CollectionReporterFn is a hook function called whenever a collection is accessed through the AnalyzingDistributor's context
-type CollectionReporterFn func(collection.Name)
-
-// AnalyzingDistributor is an snapshotter. Distributor implementation that will perform analysis on a snapshot before
-// publishing. It will update the CRD status with the analysis results.
-type AnalyzingDistributor struct {
-	s AnalyzingDistributorSettings
-
-	analysisMu     sync.Mutex
-	cancelAnalysis chan struct{}
-
-	snapshotsMu   sync.RWMutex
-	lastSnapshots map[string]*Snapshot
-}
-
-var _ Distributor = &AnalyzingDistributor{}
-
-// AnalyzingDistributorSettings are settings for an AnalyzingDistributor
-type AnalyzingDistributorSettings struct {
-	// The status updater to route diagnostic messages to
-	StatusUpdater StatusUpdater
-
-	// The top-level combined analyzer that will perform the analysis
-	Analyzer *analysis.CombinedAnalyzer
-
-	// The downstream distributor to call, after the analysis is done.
-	Distributor Distributor
-
-	// The snapshots that will get analyzed.
-	AnalysisSnapshots []string
-
-	// The snapshot that will trigger the analysis.
-	// TODO(https://github.com/istio/istio/issues/17543): This should be eventually replaced by the AnalysisSnapshots
-	//  and a matching debounce mechanism.
-	TriggerSnapshot string
-
-	// An optional hook that will be called whenever a collection is accessed. Useful for testing.
-	CollectionReporter CollectionReporterFn
-
-	// Namespaces that should be analyzed
-	AnalysisNamespaces []resource.Namespace
-
-	// Suppressions that suppress a set of matching messages.
-	Suppressions []AnalysisSuppression
-}
-
-// AnalysisSuppression describes a resource and analysis code to be suppressed
-// (e.g. ignored) during analysis. Used when a particular message code is to be
-// ignored for a specific resource.
-type AnalysisSuppression struct {
-	// Code is the analysis code to suppress (e.g. "IST0104").
-	Code string
-
-	// ResourceName is the name of the resource to suppress the message for. For
-	// K8s resources it has the same form as used by istioctl (e.g.
-	// "DestinationRule default.istio-system"). Note that globbing wildcards are
-	// supported (e.g. "DestinationRule *.istio-system").
-	ResourceName string
-}
-
-// NewAnalyzingDistributor returns a new instance of AnalyzingDistributor.
-func NewAnalyzingDistributor(s AnalyzingDistributorSettings) *AnalyzingDistributor {
-	// collectionReport hook function defaults to no-op
-	if s.CollectionReporter == nil {
-		s.CollectionReporter = func(collection.Name) {}
-	}
-
-	return &AnalyzingDistributor{
-		s:             s,
-		lastSnapshots: make(map[string]*Snapshot),
-	}
-}
-
-// Distribute implements snapshotter.Distributor
-func (d *AnalyzingDistributor) Distribute(name string, s *Snapshot) {
-	// Keep the most recent snapshot for each snapshot group we care about for analysis so we can combine them
-	// For analysis, we want default, and we can safely combine them since they are disjoint.
-	if d.isAnalysisSnapshot(name) {
-		d.snapshotsMu.Lock()
-		d.lastSnapshots[name] = s
-		d.snapshotsMu.Unlock()
-	}
-
-	// If the trigger snapshot is not set, simply bypass.
-	// TODO(https://github.com/istio/istio/issues/17543): This should be replaced by a debounce logic
-	if name != d.s.TriggerSnapshot {
-		d.s.Distributor.Distribute(name, s)
-		return
-	}
-
-	d.analysisMu.Lock()
-	defer d.analysisMu.Unlock()
-
-	// Cancel the previous analysis session, if it is still working.
-	if d.cancelAnalysis != nil {
-		close(d.cancelAnalysis)
-		d.cancelAnalysis = nil
-	}
-
-	namespaces := make(map[resource.Namespace]struct{})
-	for _, ns := range d.s.AnalysisNamespaces {
-		namespaces[ns] = struct{}{}
-	}
-
-	// start a new analysis session
-	cancelAnalysis := make(chan struct{})
-	d.cancelAnalysis = cancelAnalysis
-	go d.analyzeAndDistribute(cancelAnalysis, name, s, namespaces)
-}
-
-func (d *AnalyzingDistributor) isAnalysisSnapshot(s string) bool {
-	for _, sn := range d.s.AnalysisSnapshots {
-		if sn == s {
-			return true
-		}
-	}
-
-	return false
-}
-
-func (d *AnalyzingDistributor) analyzeAndDistribute(cancelCh chan struct{}, name string, s *Snapshot, namespaces map[resource.Namespace]struct{}) {
-	// For analysis, we use a combined snapshot
-	ctx := &context{
-		sn:                 d.getCombinedSnapshot(),
-		cancelCh:           cancelCh,
-		collectionReporter: d.s.CollectionReporter,
-	}
-
-	scope.Analysis.Debugf("Beginning analyzing the current snapshot")
-	d.s.Analyzer.Analyze(ctx)
-	scope.Analysis.Debugf("Finished analyzing the current snapshot, found messages: %v", ctx.messages)
-
-	msgs := filterMessages(ctx.messages, namespaces, d.s.Suppressions)
-	if !ctx.Canceled() {
-		d.s.StatusUpdater.Update(msgs.SortedDedupedCopy())
-	}
-
-	// Execution only reaches this point for trigger snapshot group
-	d.s.Distributor.Distribute(name, s)
-}
-
-// getCombinedSnapshot creates a new snapshot from the last snapshots of each snapshot group
-// Important assumption: the collections in each snapshot don't overlap.
-func (d *AnalyzingDistributor) getCombinedSnapshot() *Snapshot {
-	var collections []*coll.Instance
-
-	d.snapshotsMu.RLock()
-	defer d.snapshotsMu.RUnlock()
-
-	for _, s := range d.lastSnapshots {
-		for _, n := range s.set.Names() {
-			// Note that we don't clone the collections, so this combined snapshot is effectively a view into the
-			// component snapshots.
-			collections = append(collections, s.set.Collection(n))
-		}
-	}
-
-	return &Snapshot{set: coll.NewSetFromCollections(collections)}
-}
-
-func filterMessages(messages diag.Messages, namespaces map[resource.Namespace]struct{}, suppressions []AnalysisSuppression) diag.Messages {
-	nsNames := make(map[string]struct{})
-	for k := range namespaces {
-		nsNames[k.String()] = struct{}{}
-	}
-
-	var msgs diag.Messages
-FilterMessages:
-	for _, m := range messages {
-		// Only keep messages for resources in namespaces we want to analyze if the
-		// message doesn't have an origin (meaning we can't determine the
-		// namespace). Also kept are cluster-level resources where the namespace is
-		// the empty string. If no such limit is specified, keep them all.
-		if len(namespaces) > 0 && m.Resource != nil && m.Resource.Origin.Namespace() != "" {
-			if _, ok := nsNames[m.Resource.Origin.Namespace().String()]; !ok {
-				continue FilterMessages
-			}
-		}
-
-		// Filter out any messages on resources with suppression annotations.
-		if m.Resource != nil && m.Resource.Metadata.Annotations[annotation.GalleyAnalyzeSuppress.Name] != "" {
-			for _, code := range strings.Split(m.Resource.Metadata.Annotations[annotation.GalleyAnalyzeSuppress.Name], ",") {
-				if code == "*" || m.Type.Code() == code {
-					scope.Analysis.Debugf("Suppressing code %s on resource %s due to resource annotation", m.Type.Code(), m.Resource.Origin.FriendlyName())
-					continue FilterMessages
-				}
-			}
-		}
-
-		// Filter out any messages that match our suppressions.
-		for _, s := range suppressions {
-			if m.Resource == nil || s.Code != m.Type.Code() {
-				continue
-			}
-
-			if !glob.Glob(s.ResourceName, m.Resource.Origin.FriendlyName()) {
-				continue
-			}
-			scope.Analysis.Debugf("Suppressing code %s on resource %s due to suppressions list", m.Type.Code(), m.Resource.Origin.FriendlyName())
-			continue FilterMessages
-		}
-
-		msgs = append(msgs, m)
-	}
-	return msgs
-}
-
-type context struct {
-	sn                 *Snapshot
-	cancelCh           chan struct{}
-	messages           diag.Messages
-	collectionReporter CollectionReporterFn
-}
-
-var _ analysis.Context = &context{}
-
-// Report implements analysis.Context
-func (c *context) Report(_ collection.Name, m diag.Message) {
-	c.messages.Add(m)
-}
-
-// Find implements analysis.Context
-func (c *context) Find(col collection.Name, name resource.FullName) *resource.Instance {
-	c.collectionReporter(col)
-	return c.sn.Find(col, name)
-}
-
-// Exists implements analysis.Context
-func (c *context) Exists(col collection.Name, name resource.FullName) bool {
-	c.collectionReporter(col)
-	return c.Find(col, name) != nil
-}
-
-// ForEach implements analysis.Context
-func (c *context) ForEach(col collection.Name, fn analysis.IteratorFn) {
-	c.collectionReporter(col)
-	c.sn.ForEach(col, fn)
-}
-
-// Canceled implements analysis.Context
-func (c *context) Canceled() bool {
-	select {
-	case <-c.cancelCh:
-		return true
-	default:
-		return false
-	}
-}
diff --git a/galley/pkg/config/processing/snapshotter/analyzingdistributor_test.go b/galley/pkg/config/processing/snapshotter/analyzingdistributor_test.go
deleted file mode 100644
index afb955fd57..0000000000
--- a/galley/pkg/config/processing/snapshotter/analyzingdistributor_test.go
+++ /dev/null
@@ -1,542 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"sync"
-	"testing"
-	"time"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-	resource2 "istio.io/istio/pkg/config/schema/resource"
-	"istio.io/istio/pkg/config/schema/snapshots"
-	"istio.io/istio/pkg/mcp/snapshot"
-)
-
-type updaterMock struct {
-	m        sync.RWMutex
-	messages diag.Messages
-
-	waitCh      chan struct{}
-	waitTimeout time.Duration
-}
-
-// Update implements StatusUpdater
-func (u *updaterMock) Update(messages diag.Messages) {
-	u.m.Lock()
-	defer u.m.Unlock()
-	u.messages = messages
-
-	if u.waitCh != nil {
-		close(u.waitCh)
-		u.waitCh = nil
-	}
-}
-
-func (u *updaterMock) getMessages() diag.Messages {
-	u.m.Lock()
-	ms := u.messages
-	if ms != nil {
-		u.m.Unlock()
-		return ms
-	}
-
-	if u.waitCh == nil {
-		u.waitCh = make(chan struct{})
-	}
-	ch := u.waitCh
-	u.m.Unlock()
-
-	select {
-	case <-time.After(u.waitTimeout):
-		return nil
-	case <-ch:
-		u.m.RLock()
-		m := u.messages
-		u.m.RUnlock()
-		return m
-	}
-}
-
-type analyzerMock struct {
-	m                  sync.RWMutex
-	analyzeCalls       []*Snapshot
-	collectionToAccess collection.Name
-	resourcesToReport  []*resource.Instance
-}
-
-// Analyze implements Analyzer
-func (a *analyzerMock) Analyze(c analysis.Context) {
-	a.m.Lock()
-	defer a.m.Unlock()
-
-	ctx := *c.(*context)
-
-	c.Exists(a.collectionToAccess, resource.NewFullName("", ""))
-
-	for _, r := range a.resourcesToReport {
-		c.Report(a.collectionToAccess, msg.NewInternalError(r, ""))
-	}
-
-	a.analyzeCalls = append(a.analyzeCalls, ctx.sn)
-}
-
-// Name implements Analyzer
-func (a *analyzerMock) Metadata() analysis.Metadata {
-	return analysis.Metadata{
-		Name:   "",
-		Inputs: collection.Names{},
-	}
-}
-
-func (a *analyzerMock) getAnalyzeCalls() []*Snapshot {
-	a.m.RLock()
-	defer a.m.RUnlock()
-
-	out := make([]*Snapshot, len(a.analyzeCalls))
-	copy(out, a.analyzeCalls)
-	return out
-}
-
-func TestAnalyzeAndDistributeSnapshots(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{}
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport: []*resource.Instance{
-			{
-				Origin: &rt.Origin{
-					Collection: basicmeta.K8SCollection1.Name(),
-					FullName:   resource.NewFullName("includedNamespace", "r1"),
-				},
-			},
-			{
-				Origin: &rt.Origin{
-					Collection: basicmeta.K8SCollection1.Name(),
-					FullName:   resource.NewFullName("excludedNamespace", "r2"),
-				},
-			},
-		},
-	}
-	d := NewInMemoryDistributor()
-
-	var collectionAccessed collection.Name
-	cr := func(col collection.Name) {
-		collectionAccessed = col
-	}
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: cr,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	schemaA := newSchema("a")
-	schemaB := newSchema("b")
-	schemaD := newSchema("d")
-
-	sDefault := getTestSnapshot(schemaA, schemaB)
-	sOther := getTestSnapshot(schemaA, schemaD)
-
-	ad.Distribute(snapshots.Default, sDefault)
-	ad.Distribute("other", sOther)
-
-	// Assert we sent every received snapshot to the distributor
-	g.Eventually(func() snapshot.Snapshot { return d.GetSnapshot(snapshots.Default) }).Should(Equal(sDefault))
-	g.Eventually(func() snapshot.Snapshot { return d.GetSnapshot("other") }).Should(Equal(sOther))
-
-	// Assert we triggered analysis only once, with the expected combination of snapshots
-	sCombined := getTestSnapshot(schemaA, schemaB)
-	g.Eventually(a.getAnalyzeCalls).Should(ConsistOf(sCombined))
-
-	// Verify the collection reporter hook was called
-	g.Expect(collectionAccessed).To(Equal(a.collectionToAccess))
-
-	// Verify we only reported messages in the AnalysisNamespaces
-	g.Eventually(u.getMessages()).Should(HaveLen(1))
-	for _, m := range u.getMessages() {
-		g.Expect(m.Resource.Origin.Namespace()).To(Equal(resource.Namespace("includedNamespace")))
-	}
-}
-
-func TestAnalyzeNamespaceMessageHasNoResource(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{waitTimeout: 1 * time.Second}
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport: []*resource.Instance{
-			nil,
-		},
-	}
-	d := NewInMemoryDistributor()
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: nil,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	sDefault := getTestSnapshot()
-
-	ad.Distribute(snapshots.Default, sDefault)
-	g.Eventually(a.getAnalyzeCalls).Should(Not(BeEmpty()))
-	g.Eventually(u.getMessages()).Should(HaveLen(1))
-}
-
-func TestAnalyzeNamespaceMessageHasOriginWithNoNamespace(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{waitTimeout: 1 * time.Second}
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport: []*resource.Instance{
-			{
-				Origin: fakeOrigin{
-					friendlyName: "myFriendlyName",
-					// explicitly set namespace to the empty string
-					namespace: "",
-				},
-			},
-		},
-	}
-	d := NewInMemoryDistributor()
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: nil,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	sDefault := getTestSnapshot()
-
-	ad.Distribute(snapshots.Default, sDefault)
-	g.Eventually(a.getAnalyzeCalls).Should(Not(BeEmpty()))
-	g.Eventually(u.getMessages()).Should(HaveLen(1))
-}
-
-func TestAnalyzeSortsMessages(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{waitTimeout: 1 * time.Second}
-	r1 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r2"),
-		},
-	}
-	r2 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r1"),
-		},
-	}
-
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport:  []*resource.Instance{r1, r2},
-	}
-	d := NewInMemoryDistributor()
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: nil,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	sDefault := getTestSnapshot()
-
-	ad.Distribute(snapshots.Default, sDefault)
-
-	g.Eventually(a.getAnalyzeCalls).Should(ConsistOf(sDefault))
-
-	g.Eventually(u.getMessages()).Should(HaveLen(2))
-	g.Eventually(u.getMessages()[0].Resource).Should(Equal(r2))
-	g.Eventually(u.getMessages()[1].Resource).Should(Equal(r1))
-}
-
-func TestAnalyzeSuppressesMessages(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{waitTimeout: 1 * time.Second}
-	r1 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r2"),
-			Kind:       "Kind1",
-		},
-	}
-	r2 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r1"),
-			Kind:       "Kind1",
-		},
-	}
-
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport:  []*resource.Instance{r1, r2},
-	}
-	s := AnalysisSuppression{
-		Code:         "IST0001", // InternalError, reported by analyzerMock
-		ResourceName: "Kind1 includedNamespace/r2",
-	}
-	d := NewInMemoryDistributor()
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: nil,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-		Suppressions:       []AnalysisSuppression{s},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	sDefault := getTestSnapshot()
-
-	ad.Distribute(snapshots.Default, sDefault)
-
-	g.Eventually(a.getAnalyzeCalls).Should(ConsistOf(sDefault))
-
-	g.Eventually(u.getMessages()).Should(HaveLen(1))
-	g.Eventually(u.getMessages()[0].Resource).Should(Equal(r2))
-}
-
-func TestAnalyzeSuppressesMessagesWithWildcards(t *testing.T) {
-	g := NewWithT(t)
-
-	u := &updaterMock{waitTimeout: 1 * time.Second}
-	// r1 and r2 have the same prefix, but r3 does not
-	r1 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r2"),
-			Kind:       "Kind1",
-		},
-	}
-	r2 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "r1"),
-			Kind:       "Kind1",
-		},
-	}
-	r3 := &resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("includedNamespace", "x1"),
-			Kind:       "Kind1",
-		},
-	}
-	a := &analyzerMock{
-		collectionToAccess: basicmeta.K8SCollection1.Name(),
-		resourcesToReport:  []*resource.Instance{r1, r2, r3},
-	}
-	s := AnalysisSuppression{
-		Code:         "IST0001",                    // InternalError, reported by analyzerMock
-		ResourceName: "Kind1 includedNamespace/r*", // should catch r1/r2 but not x1
-	}
-	d := NewInMemoryDistributor()
-
-	settings := AnalyzingDistributorSettings{
-		StatusUpdater:      u,
-		Analyzer:           analysis.Combine("testCombined", a),
-		Distributor:        d,
-		AnalysisSnapshots:  []string{snapshots.Default},
-		TriggerSnapshot:    snapshots.Default,
-		CollectionReporter: nil,
-		AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-		Suppressions:       []AnalysisSuppression{s},
-	}
-	ad := NewAnalyzingDistributor(settings)
-
-	sDefault := getTestSnapshot()
-
-	ad.Distribute(snapshots.Default, sDefault)
-
-	g.Eventually(a.getAnalyzeCalls).Should(ConsistOf(sDefault))
-
-	g.Eventually(u.getMessages()).Should(HaveLen(1))
-	g.Eventually(u.getMessages()[0].Resource).Should(Equal(r3))
-}
-
-func TestAnalyzeSuppressesMessagesWhenResourceIsAnnotated(t *testing.T) {
-	// AnalyzerMock always throws IST0001.
-	tests := map[string]struct {
-		annotations  map[string]string
-		wantSuppress bool
-	}{
-		"basic match": {
-			annotations: map[string]string{
-				"galley.istio.io/analyze-suppress": "IST0001",
-			},
-			wantSuppress: true,
-		},
-		"non-matching code": {
-			annotations: map[string]string{
-				"galley.istio.io/analyze-suppress": "IST0234",
-			},
-			wantSuppress: false,
-		},
-		"code matches inside list of codes": {
-			annotations: map[string]string{
-				"galley.istio.io/analyze-suppress": "IST123,IST0101,IST0001,BEEF1",
-			},
-			wantSuppress: true,
-		},
-		"invalid suppression format does not suppress": {
-			annotations: map[string]string{
-				"galley.istio.io/analyze-suppress": ",,some text, in here1!,",
-			},
-			wantSuppress: false,
-		},
-		"wrong annotation does not suppress": {
-			annotations: map[string]string{
-				"galley.istio.io/plz-suppress": "IST0001",
-			},
-			wantSuppress: false,
-		},
-		"wildcard matches": {
-			annotations: map[string]string{
-				"galley.istio.io/analyze-suppress": "*",
-			},
-			wantSuppress: true,
-		},
-	}
-
-	for name, tc := range tests {
-		t.Run(name, func(t *testing.T) {
-			g := NewWithT(t)
-			u := &updaterMock{waitTimeout: 1 * time.Second}
-			r := &resource.Instance{
-				Metadata: resource.Metadata{
-					Annotations: tc.annotations,
-				},
-				Origin: &rt.Origin{
-					Collection: basicmeta.K8SCollection1.Name(),
-					Kind:       "foobar",
-					FullName:   resource.NewFullName("includedNamespace", "r1"),
-				},
-			}
-			a := &analyzerMock{
-				collectionToAccess: basicmeta.K8SCollection1.Name(),
-				resourcesToReport:  []*resource.Instance{r},
-			}
-			d := NewInMemoryDistributor()
-			settings := AnalyzingDistributorSettings{
-				StatusUpdater:      u,
-				Analyzer:           analysis.Combine("testCombined", a),
-				Distributor:        d,
-				AnalysisSnapshots:  []string{snapshots.Default},
-				TriggerSnapshot:    snapshots.Default,
-				CollectionReporter: nil,
-				AnalysisNamespaces: []resource.Namespace{"includedNamespace"},
-			}
-			ad := NewAnalyzingDistributor(settings)
-			sDefault := getTestSnapshot()
-
-			ad.Distribute(snapshots.Default, sDefault)
-
-			g.Eventually(a.getAnalyzeCalls).Should(ConsistOf(sDefault))
-			if tc.wantSuppress {
-				g.Eventually(u.getMessages()).Should(HaveLen(0))
-			} else {
-				g.Eventually(u.getMessages()).Should(HaveLen(1))
-				g.Eventually(u.getMessages()[0].Resource).Should(Equal(r))
-			}
-		})
-	}
-}
-
-func getTestSnapshot(schemas ...collection.Schema) *Snapshot {
-	c := make([]*coll.Instance, 0)
-	for _, s := range schemas {
-		c = append(c, coll.New(s))
-	}
-	return &Snapshot{
-		set: coll.NewSetFromCollections(c),
-	}
-}
-
-func newSchema(name string) collection.Schema {
-	return collection.Builder{
-		Name: name,
-		Resource: resource2.Builder{
-			Kind:         name,
-			Plural:       name + "s",
-			ProtoPackage: "github.com/gogo/protobuf/types",
-			Proto:        "google.protobuf.Empty",
-		}.MustBuild(),
-	}.MustBuild()
-}
-
-var (
-	_ resource.Origin    = fakeOrigin{}
-	_ resource.Reference = fakeReference{}
-)
-
-type fakeOrigin struct {
-	namespace    resource.Namespace
-	friendlyName string
-	reference    fakeReference
-}
-
-func (f fakeOrigin) Namespace() resource.Namespace { return f.namespace }
-func (f fakeOrigin) FriendlyName() string          { return f.friendlyName }
-func (f fakeOrigin) Comparator() string            { return f.friendlyName }
-func (f fakeOrigin) Reference() resource.Reference { return f.reference }
-func (f fakeOrigin) FieldMap() map[string]int      { return make(map[string]int) }
-
-type fakeReference struct {
-	name string
-}
-
-func (r fakeReference) String() string {
-	return r.name
-}
diff --git a/galley/pkg/config/processing/snapshotter/distributor.go b/galley/pkg/config/processing/snapshotter/distributor.go
deleted file mode 100644
index 8536d41c92..0000000000
--- a/galley/pkg/config/processing/snapshotter/distributor.go
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"sync"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/mcp/snapshot"
-)
-
-// Distributor interface abstracts the snapshotImpl distribution mechanism. Typically, this is implemented by the
-// MCP layer.
-type Distributor interface {
-	Distribute(name string, s *Snapshot)
-}
-
-// MCPDistributor distributes a snapshot to the MCP layer.
-type MCPDistributor struct {
-	mcpCache *snapshot.Cache
-}
-
-// Distribute is an implementation of SetSnapshot
-func (d *MCPDistributor) Distribute(name string, s *Snapshot) {
-	d.mcpCache.SetSnapshot(name, s)
-}
-
-// NewMCPDistributor returns a new instance of MCPDistributor
-func NewMCPDistributor(c *snapshot.Cache) *MCPDistributor {
-	return &MCPDistributor{mcpCache: c}
-}
-
-// InMemoryDistributor is an in-memory Distributor implementation.
-type InMemoryDistributor struct {
-	snapshotsLock sync.Mutex
-	snapshots     map[string]snapshot.Snapshot
-}
-
-var _ Distributor = &InMemoryDistributor{}
-
-// NewInMemoryDistributor returns a new instance of InMemoryDistributor
-func NewInMemoryDistributor() *InMemoryDistributor {
-	return &InMemoryDistributor{
-		snapshots: make(map[string]snapshot.Snapshot),
-	}
-}
-
-// Distribute is an implementation of Distributor.Distribute
-func (d *InMemoryDistributor) Distribute(name string, s *Snapshot) {
-	d.snapshotsLock.Lock()
-	defer d.snapshotsLock.Unlock()
-
-	scope.Processing.Debugf("InmemoryDistributor.Distribute: %s: %v", name, s)
-	d.snapshots[name] = s
-}
-
-// GetSnapshot get the snapshotImpl of the specified name
-func (d *InMemoryDistributor) GetSnapshot(name string) snapshot.Snapshot {
-	d.snapshotsLock.Lock()
-	defer d.snapshotsLock.Unlock()
-	if s, ok := d.snapshots[name]; ok {
-		return s
-	}
-	return nil
-}
-
-// NumSnapshots returns the current number of snapshots.
-func (d *InMemoryDistributor) NumSnapshots() int {
-	return len(d.snapshots)
-}
diff --git a/galley/pkg/config/processing/snapshotter/distributor_test.go b/galley/pkg/config/processing/snapshotter/distributor_test.go
deleted file mode 100644
index 9ab8a3ff76..0000000000
--- a/galley/pkg/config/processing/snapshotter/distributor_test.go
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"testing"
-
-	"istio.io/istio/galley/pkg/config/collection"
-	collection2 "istio.io/istio/pkg/config/schema/collection"
-)
-
-func TestDistributor_Distribute(t *testing.T) {
-	d := NewInMemoryDistributor()
-
-	s := &Snapshot{
-		set: collection.NewSet(collection2.NewSchemasBuilder().Build()),
-	}
-	d.Distribute("foo", s)
-	if _, ok := d.snapshots["foo"]; !ok {
-		t.Fatal("The snapshotImpl should have been set")
-	}
-}
-
-func TestDistributor_GetSnapshot(t *testing.T) {
-	d := NewInMemoryDistributor()
-
-	s := &Snapshot{
-		set: collection.NewSet(collection2.NewSchemasBuilder().Build()),
-	}
-	d.Distribute("foo", s)
-
-	sn := d.GetSnapshot("foo")
-	if sn != s {
-		t.Fatal("The snapshots should have been the same")
-	}
-}
-
-func TestDistributor_GetSnapshot_Unknown(t *testing.T) {
-	d := NewInMemoryDistributor()
-
-	s := &Snapshot{
-		set: collection.NewSet(collection2.NewSchemasBuilder().Build()),
-	}
-	d.Distribute("foo", s)
-
-	sn := d.GetSnapshot("bar")
-	if sn != nil {
-		t.Fatal("The snapshots should have been nil")
-	}
-}
-
-func TestDistributor_NumSnapshots(t *testing.T) {
-	d := NewInMemoryDistributor()
-
-	s := &Snapshot{
-		set: collection.NewSet(collection2.NewSchemasBuilder().Build()),
-	}
-	d.Distribute("foo", s)
-
-	if d.NumSnapshots() != 1 {
-		t.Fatal("The snapshots should have been 1")
-	}
-}
diff --git a/galley/pkg/config/processing/snapshotter/snapshot.go b/galley/pkg/config/processing/snapshotter/snapshot.go
deleted file mode 100644
index e617287791..0000000000
--- a/galley/pkg/config/processing/snapshotter/snapshot.go
+++ /dev/null
@@ -1,115 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"fmt"
-	"strconv"
-	"strings"
-
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/mcp/snapshot"
-)
-
-// Snapshot is an implementation of MCP's snapshot.Snapshot interface. It also exposes additional query methods
-// for analysis purposes.
-type Snapshot struct {
-	set *coll.Set
-}
-
-var _ snapshot.Snapshot = &Snapshot{}
-
-// Resources implements snapshotImpl.Snapshot
-func (s *Snapshot) Resources(col string) []*mcp.Resource {
-	c := s.set.Collection(collection.NewName(col))
-
-	if c == nil {
-		return nil
-	}
-
-	result := make([]*mcp.Resource, 0, c.Size())
-
-	s.set.Collection(collection.NewName(col)).ForEach(func(r *resource.Instance) bool {
-		// TODO: We should add (LRU based) caching of serialized content here.
-		rs, err := resource.Serialize(r)
-		if err != nil {
-			scope.Processing.Errorf("Unable to serialize resource.Instance: %v", err)
-		} else {
-			result = append(result, rs)
-		}
-		return true
-	})
-
-	return result
-}
-
-// Version implements snapshotImpl.Snapshot
-func (s *Snapshot) Version(col string) string {
-	coll := s.set.Collection(collection.NewName(col))
-	if coll == nil {
-		return ""
-	}
-	g := coll.Generation()
-	return col + "/" + strconv.FormatInt(g, 10)
-}
-
-// Collections implements snapshotImpl.Snapshot
-func (s *Snapshot) Collections() []string {
-	names := s.set.Names()
-	result := make([]string, 0, len(names))
-
-	for _, name := range names {
-		result = append(result, name.String())
-	}
-
-	return result
-}
-
-// Find the resource with the given name and collection.
-func (s *Snapshot) Find(cpl collection.Name, name resource.FullName) *resource.Instance {
-	c := s.set.Collection(cpl)
-	if c == nil {
-		return nil
-	}
-	return c.Get(name)
-}
-
-// ForEach iterates all resources in a given collection.
-func (s *Snapshot) ForEach(col collection.Name, fn analysis.IteratorFn) {
-	c := s.set.Collection(col)
-	if c == nil {
-		return
-	}
-	c.ForEach(fn)
-}
-
-// String implements io.Stringer
-func (s *Snapshot) String() string {
-	var b strings.Builder
-
-	for i, n := range s.set.Names() {
-		b.WriteString(fmt.Sprintf("[%d] %s (@%s)\n", i, n.String(), s.Version(n.String())))
-		for j, e := range s.Resources(n.String()) {
-			b.WriteString(fmt.Sprintf("  [%d] %s\n", j, e.Metadata.Name))
-		}
-	}
-
-	return b.String()
-}
diff --git a/galley/pkg/config/processing/snapshotter/snapshot_test.go b/galley/pkg/config/processing/snapshotter/snapshot_test.go
deleted file mode 100644
index fc1424cff6..0000000000
--- a/galley/pkg/config/processing/snapshotter/snapshot_test.go
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-func TestSnapshot_Basics(t *testing.T) {
-	g := NewWithT(t)
-
-	set := coll.NewSet(collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).Build())
-	set.Collection(basicmeta.K8SCollection1.Name()).Set(data.EntryN1I1V1)
-	sn := &Snapshot{set: set}
-
-	resources := sn.Resources(basicmeta.K8SCollection1.Name().String())
-	g.Expect(resources).To(HaveLen(1))
-
-	r, err := resource.Deserialize(resources[0], basicmeta.K8SCollection1.Resource())
-	g.Expect(err).To(BeNil())
-	fixtures.ExpectEqual(t, r, data.EntryN1I1V1)
-
-	v := sn.Version(basicmeta.K8SCollection1.Name().String())
-	g.Expect(v).To(Equal(basicmeta.K8SCollection1.Name().String() + "/1"))
-
-	expected := `[0] k8s/collection1 (@k8s/collection1/1)
-  [0] n1/i1
-`
-	g.Expect(sn.String()).To(Equal(expected))
-}
-
-func TestSnapshot_SerializeError(t *testing.T) {
-	g := NewWithT(t)
-
-	set := coll.NewSet(collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).Build())
-	e := data.Event1Col1AddItem1.Resource.Clone()
-	e.Message = nil
-	set.Collection(basicmeta.K8SCollection1.Name()).Set(e)
-	sn := &Snapshot{set: set}
-
-	resources := sn.Resources(basicmeta.K8SCollection1.Name().String())
-	g.Expect(resources).To(HaveLen(0))
-}
-
-func TestSnapshot_WrongCollection(t *testing.T) {
-	g := NewWithT(t)
-
-	set := coll.NewSet(collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).Build())
-	set.Collection(basicmeta.K8SCollection1.Name()).Set(data.Event1Col1AddItem1.Resource)
-	sn := &Snapshot{set: set}
-
-	g.Expect(sn.Version("foo")).To(Equal(""))
-	g.Expect(sn.Resources("foo")).To(BeEmpty())
-}
diff --git a/galley/pkg/config/processing/snapshotter/snapshotoptions.go b/galley/pkg/config/processing/snapshotter/snapshotoptions.go
deleted file mode 100644
index 04b2bbb327..0000000000
--- a/galley/pkg/config/processing/snapshotter/snapshotoptions.go
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"istio.io/istio/galley/pkg/config/processing/snapshotter/strategy"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// SnapshotOptions is settings for a single snapshotImpl target.
-type SnapshotOptions struct {
-	Distributor Distributor
-
-	// The group name for the snapshotImpl.
-	Group string
-
-	// The publishing strategy for the snapshotImpl.
-	Strategy strategy.Instance
-
-	// The set of collections to Snapshot.
-	Collections []collection.Name
-}
diff --git a/galley/pkg/config/processing/snapshotter/snapshotter.go b/galley/pkg/config/processing/snapshotter/snapshotter.go
deleted file mode 100644
index 8f272b96d5..0000000000
--- a/galley/pkg/config/processing/snapshotter/snapshotter.go
+++ /dev/null
@@ -1,268 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"fmt"
-	"sync/atomic"
-	"time"
-
-	coll "istio.io/istio/galley/pkg/config/collection"
-	"istio.io/istio/galley/pkg/config/monitoring"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter/strategy"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Snapshotter is a processor that handles input events and creates snapshotImpl collections.
-type Snapshotter struct {
-	// pendingEvents must be at start of struct to ensure 64bit alignment for atomics on
-	// 32bit architectures. See also: https://golang.org/pkg/sync/atomic/#pkg-note-BUG
-
-	// pendingEvents counts the number of events awaiting publishing.
-	pendingEvents int64
-
-	// lastSnapshotTime records the last time a snapshotImpl was published.
-	lastSnapshotTime atomic.Value
-
-	accumulators   map[collection.Name]*accumulator
-	selector       event.Router
-	xforms         []event.Transformer
-	settings       []SnapshotOptions
-	snapshotGroups []*snapshotGroup
-
-	// lastEventTime records the last time an event was received.
-	lastEventTime time.Time
-}
-
-var _ event.Processor = &Snapshotter{}
-
-type accumulator struct {
-	reqSyncCount   int32
-	syncCount      int32
-	collection     *coll.Instance
-	snapshotGroups []*snapshotGroup
-}
-
-// snapshotGroup represents a group of collections that all need to be synced before any of them publish events,
-// and also share a set of strategies.
-// Members of a snapshot group are defined via the per-collection accumulators that point to a group.
-type snapshotGroup struct {
-	// How many collections in the current group still need to receive a FullSync before we start publishing.
-	remaining int32
-	// Set of collections that have already received a FullSync. If we get a duplicate, it will be ignored.
-	synced atomic.Value
-	// Strategy to execute on handled events only after all collections in the group have been synced.
-	strategy strategy.Instance
-}
-
-// Handle implements event.Handler
-func (a *accumulator) Handle(e event.Event) {
-	switch e.Kind {
-	case event.Added:
-		a.collection.Set(e.Resource)
-		monitoring.RecordStateTypeCount(e.Source.Name().String(), a.collection.Size())
-		monitorEntry(e.Source, e.Resource.Metadata.FullName, true)
-
-	case event.Updated:
-		a.collection.Set(e.Resource)
-
-	case event.Deleted:
-		a.collection.Remove(e.Resource.Metadata.FullName)
-		monitoring.RecordStateTypeCount(e.Source.Name().String(), a.collection.Size())
-		monitorEntry(e.Source, e.Resource.Metadata.FullName, false)
-
-	case event.FullSync:
-		atomic.AddInt32(&a.syncCount, 1)
-
-	default:
-		panic(fmt.Errorf("accumulator.Handle: unhandled event type: %v", e.Kind))
-	}
-
-	// Update the group sync counter if we received all required FullSync events for a collection
-	for _, sg := range a.snapshotGroups {
-		if atomic.LoadInt32(&a.syncCount) >= a.reqSyncCount {
-			sg.onSync(a.collection)
-		}
-	}
-}
-
-func (a *accumulator) reset() {
-	atomic.StoreInt32(&a.syncCount, 0)
-	a.collection.Clear()
-}
-
-func monitorEntry(col collection.Schema, resourceName resource.FullName, added bool) {
-	value := 1
-	if !added {
-		value = 0
-	}
-	colName := collection.Name("")
-	if col != nil {
-		colName = col.Name()
-	}
-	monitoring.RecordDetailedStateType(string(resourceName.Namespace), string(resourceName.Name), colName, value)
-}
-
-// NewSnapshotter returns a new Snapshotter.
-func NewSnapshotter(xforms []event.Transformer, settings []SnapshotOptions) (*Snapshotter, error) {
-	s := &Snapshotter{
-		accumulators:  make(map[collection.Name]*accumulator),
-		selector:      event.NewRouter(),
-		xforms:        xforms,
-		settings:      settings,
-		lastEventTime: time.Now(),
-	}
-
-	for _, xform := range xforms {
-		xform.Inputs().ForEach(func(i collection.Schema) (done bool) {
-			s.selector = event.AddToRouter(s.selector, i, xform)
-			return
-		})
-
-		xform.Outputs().ForEach(func(o collection.Schema) (done bool) {
-			a, found := s.accumulators[o.Name()]
-			if !found {
-				a = &accumulator{
-					collection: coll.New(o),
-				}
-				s.accumulators[o.Name()] = a
-			}
-			a.reqSyncCount++
-			xform.DispatchFor(o, a)
-			return
-		})
-	}
-
-	for _, o := range settings {
-		sg := newSnapshotGroup(len(o.Collections), o.Strategy)
-		s.snapshotGroups = append(s.snapshotGroups, sg)
-		for _, c := range o.Collections {
-			a := s.accumulators[c]
-			if a == nil {
-				return nil, fmt.Errorf("unrecognized collection in SnapshotOptions: %v (Group: %s)", c, o.Group)
-			}
-
-			a.snapshotGroups = append(a.snapshotGroups, sg)
-		}
-	}
-
-	return s, nil
-}
-
-func newSnapshotGroup(size int, strategy strategy.Instance) *snapshotGroup {
-	sg := &snapshotGroup{
-		strategy: strategy,
-	}
-	sg.reset(size)
-	return sg
-}
-
-func (sg *snapshotGroup) onSync(c *coll.Instance) {
-	synced := sg.synced.Load().(map[*coll.Instance]bool)
-	if !synced[c] {
-		atomic.AddInt32(&sg.remaining, -1)
-		synced[c] = true
-		scope.Processing.Debugf("sg.onSync: %v fully synced, %d remaining", c.Name(), sg.remaining)
-	}
-
-	// proceed with triggering the strategy OnChange only after we've full synced every collection in a group.
-	if atomic.LoadInt32(&sg.remaining) <= 0 {
-		scope.Processing.Debugf("sg.onSync: all collections synced, proceeding with strategy.OnChange()")
-		sg.strategy.OnChange()
-	}
-}
-
-func (sg *snapshotGroup) reset(size int) {
-	atomic.StoreInt32(&sg.remaining, int32(size))
-	sg.synced.Store(make(map[*coll.Instance]bool))
-}
-
-// Start implements Processor
-func (s *Snapshotter) Start() {
-	for _, x := range s.xforms {
-		x.Start()
-	}
-
-	for _, o := range s.settings {
-		// Capture the iteration variable in a local
-		opt := o
-		o.Strategy.Start(func() {
-			s.publish(opt)
-		})
-	}
-}
-
-func (s *Snapshotter) publish(o SnapshotOptions) {
-	var collections []*coll.Instance
-
-	for _, n := range o.Collections {
-		col := s.accumulators[n].collection.Clone()
-		collections = append(collections, col)
-	}
-
-	set := coll.NewSetFromCollections(collections)
-	sn := &Snapshot{set: set}
-
-	s.markSnapshotTime()
-	atomic.StoreInt64(&s.pendingEvents, 0)
-	scope.Processing.Info("Publishing snapshot for group: ", o.Group)
-	scope.Processing.Debug(sn)
-	o.Distributor.Distribute(o.Group, sn)
-}
-
-// Stop implements Processor
-func (s *Snapshotter) Stop() {
-	for _, o := range s.settings {
-		o.Strategy.Stop()
-	}
-
-	for _, x := range s.xforms {
-		x.Stop()
-	}
-
-	for _, a := range s.accumulators {
-		a.reset()
-	}
-
-	for i, o := range s.settings {
-		s.snapshotGroups[i].reset(len(o.Collections))
-	}
-}
-
-// Handle implements Processor
-func (s *Snapshotter) Handle(e event.Event) {
-	now := time.Now()
-	monitoring.RecordProcessorEventProcessed(now.Sub(s.lastEventTime))
-	s.lastEventTime = now
-	atomic.AddInt64(&s.pendingEvents, 1)
-	s.selector.Handle(e)
-}
-
-func (s *Snapshotter) markSnapshotTime() {
-	now := time.Now()
-	lst := s.lastSnapshotTime.Load()
-	if lst == nil {
-		lst = time.Time{}
-	}
-	lastSnapshotTime := lst.(time.Time)
-
-	pe := atomic.SwapInt64(&s.pendingEvents, 0)
-
-	monitoring.RecordProcessorSnapshotPublished(pe, now.Sub(lastSnapshotTime))
-	s.lastSnapshotTime.Store(lastSnapshotTime)
-}
diff --git a/galley/pkg/config/processing/snapshotter/snapshotter_test.go b/galley/pkg/config/processing/snapshotter/snapshotter_test.go
deleted file mode 100644
index 56cd7370c6..0000000000
--- a/galley/pkg/config/processing/snapshotter/snapshotter_test.go
+++ /dev/null
@@ -1,155 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/processing/snapshotter/strategy"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-func TestSnapshotter_Basic(t *testing.T) {
-	g := NewWithT(t)
-
-	tr := fixtures.NewTransformer(
-		collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).Build(),
-		collection.NewSchemasBuilder().MustAdd(basicmeta.Collection2).Build(),
-		func(tr *fixtures.Transformer, e event.Event) {
-			switch e.Kind {
-			case event.Reset:
-				tr.Publish(basicmeta.Collection2.Name(), e)
-			default:
-				e.Source = basicmeta.Collection2
-				tr.Publish(basicmeta.Collection2.Name(), e)
-			}
-		})
-
-	d := NewInMemoryDistributor()
-
-	options := []SnapshotOptions{
-		{
-			Collections: []collection.Name{basicmeta.Collection2.Name()},
-			Strategy:    strategy.NewImmediate(),
-			Group:       "default",
-			Distributor: d,
-		},
-	}
-
-	s, err := NewSnapshotter([]event.Transformer{tr}, options)
-	g.Expect(err).To(BeNil())
-	s.Start()
-
-	g.Expect(tr.Started).To(BeTrue())
-
-	s.Stop()
-	g.Expect(tr.Started).To(BeFalse())
-
-	s.Start()
-
-	sn := d.GetSnapshot("default")
-	g.Expect(sn).To(BeNil())
-
-	s.Handle(data.Event1Col1AddItem1)
-	s.Handle(data.Event1Col1Synced)
-
-	sn = d.GetSnapshot("default")
-	g.Expect(sn).NotTo(BeNil())
-	g.Expect(sn.Version(basicmeta.Collection2.Name().String())).To(Equal("collection2/2"))
-	g.Expect(sn.Resources(basicmeta.Collection2.Name().String())).To(HaveLen(1))
-
-	s.Handle(data.Event1Col1UpdateItem1)
-	s.Handle(data.Event1Col1DeleteItem1)
-	s.Handle(data.Event1Col1Synced)
-
-	sn = d.GetSnapshot("default")
-	g.Expect(sn).NotTo(BeNil())
-	g.Expect(sn.Version(basicmeta.Collection2.Name().String())).To(Equal("collection2/4"))
-	g.Expect(sn.Resources(basicmeta.Collection2.Name().String())).To(HaveLen(0))
-}
-
-func TestSnapshotter_SnapshotMismatch(t *testing.T) {
-	g := NewWithT(t)
-
-	tr := fixtures.NewTransformer(
-		collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).Build(),
-		collection.NewSchemasBuilder().MustAdd(basicmeta.Collection2).Build(),
-		func(tr *fixtures.Transformer, e event.Event) {
-			switch e.Kind {
-			case event.Reset:
-				tr.Publish(basicmeta.Collection2.Name(), e)
-			default:
-				e.Source = basicmeta.Collection2
-				tr.Publish(basicmeta.Collection2.Name(), e)
-			}
-		})
-
-	d := NewInMemoryDistributor()
-
-	options := []SnapshotOptions{
-		{
-			Collections: []collection.Name{data.Foo.Name()},
-			Strategy:    strategy.NewImmediate(),
-			Group:       "default",
-			Distributor: d,
-		},
-	}
-
-	_, err := NewSnapshotter([]event.Transformer{tr}, options)
-	g.Expect(err).NotTo(BeNil())
-}
-
-// All collections should be synced before any snapshots are made available
-func TestSnapshotterWaitForAllSync(t *testing.T) {
-	g := NewWithT(t)
-
-	tr := fixtures.NewTransformer(
-		collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).MustAdd(basicmeta.Collection2).Build(),
-		collection.NewSchemasBuilder().MustAdd(basicmeta.K8SCollection1).MustAdd(basicmeta.Collection2).Build(),
-		func(tr *fixtures.Transformer, e event.Event) {
-			tr.Publish(e.Source.Name(), e)
-		})
-
-	d := NewInMemoryDistributor()
-
-	options := []SnapshotOptions{
-		{
-			Collections: []collection.Name{basicmeta.K8SCollection1.Name(), basicmeta.Collection2.Name()},
-			Strategy:    strategy.NewImmediate(),
-			Group:       "default",
-			Distributor: d,
-		},
-	}
-
-	s, err := NewSnapshotter([]event.Transformer{tr}, options)
-	g.Expect(err).To(BeNil())
-	s.Start()
-
-	s.Handle(data.Event1Col1Synced)
-
-	sn := d.GetSnapshot("default")
-	g.Expect(sn).To(BeNil())
-
-	s.Handle(data.Event1Col2Synced)
-
-	sn = d.GetSnapshot("default")
-	g.Expect(sn).NotTo(BeNil())
-}
diff --git a/galley/pkg/config/processing/snapshotter/statusupdater.go b/galley/pkg/config/processing/snapshotter/statusupdater.go
deleted file mode 100644
index 028caf484f..0000000000
--- a/galley/pkg/config/processing/snapshotter/statusupdater.go
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"fmt"
-	"sync"
-	"time"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-)
-
-// StatusUpdater updates resource statuses, based on the given diagnostic messages.
-type StatusUpdater interface {
-	Update(messages diag.Messages)
-}
-
-// InMemoryStatusUpdater is an in-memory implementation of StatusUpdater
-type InMemoryStatusUpdater struct {
-	WaitTimeout time.Duration
-
-	mu      sync.RWMutex
-	m       diag.Messages
-	updated bool
-	waitCh  chan struct{}
-}
-
-var _ StatusUpdater = &InMemoryStatusUpdater{}
-
-// Update implements StatusUpdater
-func (u *InMemoryStatusUpdater) Update(m diag.Messages) {
-	u.mu.Lock()
-	defer u.mu.Unlock()
-	u.m = m
-
-	// Why an explicit flag here? Go treats an empty slice as if it were nil, so if no messages ever got recorded "u.m == nil" evaluates to true,
-	// and the short-circuit in WaitForReport wouldn't ever fire.
-	u.updated = true
-
-	if u.waitCh != nil {
-		close(u.waitCh)
-		u.waitCh = nil
-	}
-}
-
-// Get returns the current set of captured diag.Messages
-func (u *InMemoryStatusUpdater) Get() diag.Messages {
-	u.mu.RLock()
-	defer u.mu.RUnlock()
-	return u.m
-}
-
-// WaitForReport blocks until a report is available. Returns nil if a report is available, or an error representing why we couldn't get it.
-func (u *InMemoryStatusUpdater) WaitForReport(cancelCh chan struct{}) error {
-	// Short-circuit to handle the case where Update got called before WaitForReport
-	u.mu.Lock()
-	if u.updated {
-		u.mu.Unlock()
-		return nil
-	}
-
-	if u.waitCh == nil {
-		u.waitCh = make(chan struct{})
-	}
-	ch := u.waitCh
-	u.mu.Unlock()
-
-	select {
-	case <-cancelCh:
-		return fmt.Errorf("cancelled")
-	case <-time.After(u.WaitTimeout):
-		return fmt.Errorf("timed out after %s", u.WaitTimeout)
-	case <-ch:
-		return nil
-	}
-}
diff --git a/galley/pkg/config/processing/snapshotter/statusupdater_test.go b/galley/pkg/config/processing/snapshotter/statusupdater_test.go
deleted file mode 100644
index d3d4a1eb1e..0000000000
--- a/galley/pkg/config/processing/snapshotter/statusupdater_test.go
+++ /dev/null
@@ -1,105 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package snapshotter
-
-import (
-	"testing"
-	"time"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-)
-
-func TestInMemoryStatusUpdaterWriteThenWait(t *testing.T) {
-	g := NewWithT(t)
-
-	su := &InMemoryStatusUpdater{WaitTimeout: 1 * time.Second}
-
-	msgs := diag.Messages{
-		diag.NewMessage(diag.NewMessageType(diag.Error, "test", "test"), nil),
-	}
-
-	cancelCh := make(chan struct{})
-
-	su.Update(msgs)
-	g.Expect(su.WaitForReport(cancelCh)).To(BeNil())
-	g.Expect(su.Get()).To(Equal(msgs))
-}
-
-func TestInMemoryStatusUpdaterWriteNothingThenWait(t *testing.T) {
-	g := NewWithT(t)
-
-	su := &InMemoryStatusUpdater{WaitTimeout: 1 * time.Second}
-
-	var msgs diag.Messages
-
-	cancelCh := make(chan struct{})
-
-	su.Update(msgs)
-	g.Expect(su.WaitForReport(cancelCh)).To(BeNil())
-	g.Expect(su.Get()).To(Equal(msgs))
-}
-
-func TestInMemoryStatusUpdaterWaitThenWrite(t *testing.T) {
-	g := NewWithT(t)
-
-	su := &InMemoryStatusUpdater{WaitTimeout: 1 * time.Second}
-
-	msgs := diag.Messages{
-		diag.NewMessage(diag.NewMessageType(diag.Error, "test", "test"), nil),
-	}
-
-	cancelCh := make(chan struct{})
-
-	go func() {
-		g.Expect(su.WaitForReport(cancelCh)).To(BeNil())
-	}()
-
-	su.Update(msgs)
-	g.Expect(su.Get()).To(Equal(msgs))
-}
-
-func TestInMemoryStatusUpdaterTimesOut(t *testing.T) {
-	g := NewWithT(t)
-
-	su := &InMemoryStatusUpdater{WaitTimeout: 0}
-
-	cancelCh := make(chan struct{})
-
-	err := su.WaitForReport(cancelCh)
-	g.Expect(err).To(Not(BeNil()))
-}
-
-func TestInMemoryStatusUpdaterCancelled(t *testing.T) {
-	g := NewWithT(t)
-
-	su := &InMemoryStatusUpdater{WaitTimeout: 1 * time.Second}
-
-	cancelCh := make(chan struct{})
-	testDone := make(chan struct{})
-
-	var err error
-	go func() {
-		err = su.WaitForReport(cancelCh)
-		close(testDone)
-	}()
-
-	close(cancelCh)
-	<-testDone
-
-	g.Expect(err).To(Not(BeNil()))
-	g.Expect(err.Error()).To(ContainSubstring("cancelled"))
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/create.go b/galley/pkg/config/processing/snapshotter/strategy/create.go
deleted file mode 100644
index 44f0a1d631..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/create.go
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import "fmt"
-
-const (
-	debounce  = "debounce"
-	immediate = "immediate"
-)
-
-// Create a strategy with the given name.
-func Create(name string) (Instance, error) {
-	switch name {
-	case debounce:
-		return NewDebounceWithDefaults(), nil
-	case immediate:
-		return NewImmediate(), nil
-	default:
-		return nil, fmt.Errorf("unknown strategy: %q", name)
-	}
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/create_test.go b/galley/pkg/config/processing/snapshotter/strategy/create_test.go
deleted file mode 100644
index f093b94000..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/create_test.go
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import (
-	"reflect"
-	"testing"
-
-	. "github.com/onsi/gomega"
-)
-
-func TestCreate_Immediate(t *testing.T) {
-	g := NewWithT(t)
-
-	s, err := Create(immediate)
-	g.Expect(err).To(BeNil())
-
-	g.Expect(reflect.TypeOf(s)).To(Equal(reflect.TypeOf(&Immediate{})))
-}
-
-func TestCreate_Debounce(t *testing.T) {
-	g := NewWithT(t)
-
-	s, err := Create(debounce)
-	g.Expect(err).To(BeNil())
-
-	g.Expect(reflect.TypeOf(s)).To(Equal(reflect.TypeOf(&Debounce{})))
-}
-
-func TestCreate_Unknown(t *testing.T) {
-	g := NewWithT(t)
-
-	_, err := Create("foo")
-	g.Expect(err).NotTo(BeNil())
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/debounce.go b/galley/pkg/config/processing/snapshotter/strategy/debounce.go
deleted file mode 100644
index 6095200515..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/debounce.go
+++ /dev/null
@@ -1,191 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import (
-	"sync"
-	"time"
-
-	"istio.io/istio/galley/pkg/config/monitoring"
-)
-
-const (
-	// Maximum wait time before deciding to publish the events.
-	defaultMaxWaitDuration = time.Second
-
-	// Minimum time distance between two events for deciding on the quiesce point. If the time delay
-	// between two events is larger than this, then we can deduce that we hit a quiesce point.
-	defaultQuiesceDuration = time.Second / 2
-)
-
-// Debounce is a heuristic model for deciding when to publish snapshots. It tries to detect
-// quiesce points for events with a total bounded wait time.
-type Debounce struct {
-	mu sync.Mutex
-
-	maxWaitDuration time.Duration
-	quiesceDuration time.Duration
-
-	changeCh chan struct{}
-	stopCh   chan struct{}
-	doneCh   chan struct{}
-}
-
-var _ Instance = &Debounce{}
-
-// NewDebounceWithDefaults creates a new debounce strategy with default values.
-func NewDebounceWithDefaults() *Debounce {
-	return NewDebounce(defaultMaxWaitDuration, defaultQuiesceDuration)
-}
-
-// NewDebounce creates a new debounce strategy with the given values.
-func NewDebounce(maxWaitDuration, quiesceDuration time.Duration) *Debounce {
-	return &Debounce{
-		maxWaitDuration: maxWaitDuration,
-		quiesceDuration: quiesceDuration,
-		changeCh:        make(chan struct{}, 1),
-	}
-}
-
-// Start implements Instance
-func (d *Debounce) Start(fn OnSnapshotFn) {
-	d.mu.Lock()
-	defer d.mu.Unlock()
-
-	if d.stopCh != nil {
-		scope.Debug("Debounce.Start: already started")
-		return
-	}
-	d.stopCh = make(chan struct{})
-	d.doneCh = make(chan struct{})
-
-	// Drain the changeCh, to avoid events from a previous incarnation.
-	drainCh(d.changeCh)
-
-	go d.run(d.stopCh, d.doneCh, fn)
-}
-
-// Stop implements Instance
-func (d *Debounce) Stop() {
-	d.mu.Lock()
-
-	if d.stopCh != nil {
-		scope.Debug("Debounce.Stop: stopping")
-		close(d.stopCh)
-		d.stopCh = nil
-	} else {
-		scope.Debug("Debounce.Stop: already stopped")
-	}
-	d.mu.Unlock()
-
-	<-d.doneCh
-}
-
-func (d *Debounce) run(stopCh, doneCh chan struct{}, fn OnSnapshotFn) {
-	var maxDurationTimer *time.Timer
-	var quiesceTimer *time.Timer
-
-mainloop:
-	for {
-		select {
-		case <-stopCh:
-			scope.Debug("Debounce.run: stopping")
-			break mainloop
-
-		case <-d.changeCh:
-			scope.Debug("Debounce.run: change")
-			monitoring.RecordStrategyOnChange()
-			// fallthrough to start the timer.
-		}
-
-		maxDurationTimer = time.NewTimer(d.maxWaitDuration)
-		quiesceTimer = time.NewTimer(d.quiesceDuration)
-
-	loop:
-		for {
-			select {
-			case <-stopCh:
-				scope.Debug("Debounce.run: stopping")
-				break mainloop
-
-			case <-d.changeCh:
-				scope.Debug("Debounce.run: change")
-				monitoring.RecordStrategyOnChange()
-
-				quiesceTimer.Stop()
-				drainTimeCh(quiesceTimer.C)
-				quiesceTimer.Reset(d.quiesceDuration)
-				monitoring.RecordOnTimer(false, false, true)
-
-			case <-quiesceTimer.C:
-				scope.Debug("Debounce.run: quiesce timer")
-				monitoring.RecordOnTimer(false, true, false)
-				break loop
-
-			case <-maxDurationTimer.C:
-				scope.Debug("Debounce.run: maxDuration timer")
-				monitoring.RecordOnTimer(true, false, false)
-				break loop
-			}
-		}
-
-		quiesceTimer.Stop()
-		drainTimeCh(quiesceTimer.C)
-		maxDurationTimer.Stop()
-		drainTimeCh(maxDurationTimer.C)
-		scope.Debug("Debounce.run: calling callback...")
-		fn()
-	}
-
-	close(doneCh)
-}
-
-// OnChange implements Instance
-func (d *Debounce) OnChange() {
-	select {
-	case d.changeCh <- struct{}{}:
-	default:
-	}
-}
-
-func drainCh(ch chan struct{}) {
-loop:
-	for {
-		select {
-		case _, ok := <-ch:
-			if !ok {
-				break loop
-			}
-		default:
-			break loop
-
-		}
-	}
-}
-
-func drainTimeCh(ch <-chan time.Time) {
-loop:
-	for {
-		select {
-		case _, ok := <-ch:
-			if !ok {
-				break loop
-			}
-		default:
-			break loop
-
-		}
-	}
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/debounce_test.go b/galley/pkg/config/processing/snapshotter/strategy/debounce_test.go
deleted file mode 100644
index 8bc30d4177..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/debounce_test.go
+++ /dev/null
@@ -1,222 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import (
-	"sync/atomic"
-	"testing"
-	"time"
-
-	. "github.com/onsi/gomega"
-)
-
-func TestStrategy_StartStop(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Minute, time.Millisecond*500)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	s.Stop()
-
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_DoubleStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Minute, time.Millisecond*500)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_DoubleStop(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Hour, time.Millisecond*500)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	s.Stop()
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_ChangeBeforeStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Millisecond*100, time.Millisecond)
-	s.OnChange()
-	s.OnChange()
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	defer s.Stop()
-
-	time.Sleep(time.Millisecond * 500)
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_FireEvent(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Millisecond*200, time.Millisecond*100)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-	defer s.Stop()
-
-	s.OnChange()
-
-	time.Sleep(time.Millisecond * 210)
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(1)))
-}
-
-func TestStrategy_StopBeforeMaxTimeout(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Second*5, time.Second)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-
-	s.OnChange()
-	time.Sleep(time.Millisecond * 200)
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_ChangeBeforeQuiesce(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Second*5, time.Second)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-
-	s.OnChange()
-	time.Sleep(time.Millisecond * 10)
-	s.OnChange()
-
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(0)))
-}
-
-func TestStrategy_MaxTimeout(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewDebounce(time.Second, time.Millisecond*500)
-
-	var called int32
-	s.Start(func() {
-		atomic.StoreInt32(&called, 1)
-	})
-
-	for i := 0; i < 120; i++ {
-		s.OnChange()
-		time.Sleep(time.Millisecond * 10)
-	}
-	s.Stop()
-
-	g.Expect(atomic.LoadInt32(&called)).To(Equal(int32(1)))
-}
-
-func TestStrategy_NewWithDefaults(t *testing.T) {
-	g := NewWithT(t)
-	s := NewDebounceWithDefaults()
-	g.Expect(s.quiesceDuration).To(Equal(defaultQuiesceDuration))
-	g.Expect(s.maxWaitDuration).To(Equal(defaultMaxWaitDuration))
-}
-
-func TestDrainCh(t *testing.T) {
-	ch := make(chan struct{}, 1)
-	ch <- struct{}{}
-
-	drainCh(ch)
-	select {
-	case <-ch:
-		t.Fail()
-	default:
-	}
-}
-
-func TestDrainCh_Empty(t *testing.T) {
-	ch := make(chan struct{}, 1)
-	drainCh(ch)
-	// Does not block or crash
-}
-
-func TestDrainCh_Closed(t *testing.T) {
-	ch := make(chan struct{}, 1)
-	ch <- struct{}{}
-	close(ch)
-	drainCh(ch)
-	// Does not block or crash
-}
-
-func TestDrainTimeCh(t *testing.T) {
-	ch := make(chan time.Time, 1)
-	ch <- time.Now()
-
-	drainTimeCh(ch)
-	select {
-	case <-ch:
-		t.Fail()
-	default:
-	}
-}
-
-func TestDrainTimeCh_Empty(t *testing.T) {
-	ch := make(chan time.Time, 1)
-	drainTimeCh(ch)
-	// Does not block or crash
-}
-
-func TestDrainTimeCh_Closed(t *testing.T) {
-	ch := make(chan time.Time, 1)
-	ch <- time.Now()
-	close(ch)
-	drainTimeCh(ch)
-	// Does not block or crash
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/immediate.go b/galley/pkg/config/processing/snapshotter/strategy/immediate.go
deleted file mode 100644
index 090cae2166..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/immediate.go
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import (
-	"sync/atomic"
-
-	"istio.io/istio/galley/pkg/config/monitoring"
-)
-
-// Immediate is a snapshotting strategy for creating snapshots immediately, as events arrive.
-type Immediate struct {
-	handler atomic.Value
-}
-
-var sentinelOnSnapshot OnSnapshotFn = func() {}
-
-var _ Instance = &Immediate{}
-
-// NewImmediate returns a new Immediate.
-func NewImmediate() *Immediate {
-	i := &Immediate{}
-	i.handler.Store(sentinelOnSnapshot)
-
-	return i
-}
-
-// Start implements processing.Debounce
-func (i *Immediate) Start(handler OnSnapshotFn) {
-	i.handler.Store(handler)
-}
-
-// Stop implements processing.Debounce
-func (i *Immediate) Stop() {
-	i.handler.Store(sentinelOnSnapshot)
-}
-
-// OnChange implements processing.Debounce
-func (i *Immediate) OnChange() {
-	scope.Debug("Immediate.OnChange")
-	fn := i.handler.Load().(OnSnapshotFn)
-
-	monitoring.RecordStrategyOnChange()
-	fn()
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/immediate_test.go b/galley/pkg/config/processing/snapshotter/strategy/immediate_test.go
deleted file mode 100644
index ebba9cde2d..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/immediate_test.go
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-)
-
-func TestNewImmediate(t *testing.T) {
-	g := NewWithT(t)
-	s := NewImmediate()
-
-	var changed bool
-	onChange := func() {
-		changed = true
-	}
-	g.Expect(changed).To(BeFalse())
-	s.Start(onChange)
-	s.OnChange()
-	g.Expect(changed).To(BeTrue())
-
-	changed = false
-	s.Stop()
-	s.OnChange()
-	g.Expect(changed).To(BeFalse())
-}
diff --git a/galley/pkg/config/processing/snapshotter/strategy/instance.go b/galley/pkg/config/processing/snapshotter/strategy/instance.go
deleted file mode 100644
index ddc17412f3..0000000000
--- a/galley/pkg/config/processing/snapshotter/strategy/instance.go
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package strategy
-
-// Instance is a strategy for publishing snapshots. It listens to to the given snapshotters
-// and creates snapshots that get published to the given Distributor.
-type Instance interface {
-	Start(fn OnSnapshotFn)
-	OnChange()
-	Stop()
-}
-
-// OnSnapshotFn is called to indicate that the snapshot
-type OnSnapshotFn func()
diff --git a/galley/pkg/config/processor/build.go b/galley/pkg/config/processor/build.go
deleted file mode 100644
index a2f963ba50..0000000000
--- a/galley/pkg/config/processor/build.go
+++ /dev/null
@@ -1,89 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processor
-
-import (
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter/strategy"
-	"istio.io/istio/galley/pkg/config/processing/transformer"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema"
-)
-
-// Settings is the settings that are needed for creating a config processing pipeline that can read
-// from a file system, or API Server, and can publish snapshots via MCP.
-type Settings struct {
-	Metadata           *schema.Metadata
-	DomainSuffix       string
-	Source             event.Source
-	TransformProviders transformer.Providers
-	Distributor        snapshotter.Distributor
-	EnabledSnapshots   []string
-}
-
-// Initialize a processing runtime for Galley.
-func Initialize(settings Settings) (*processing.Runtime, error) {
-	var options []snapshotter.SnapshotOptions
-	for _, s := range settings.Metadata.AllSnapshots() {
-		if !isEnabled(s.Name, settings.EnabledSnapshots) {
-			continue
-		}
-
-		str, err := strategy.Create(s.Strategy)
-		if err != nil {
-			return nil, err
-		}
-
-		opt := snapshotter.SnapshotOptions{
-			Group:       s.Name,
-			Distributor: settings.Distributor,
-			Collections: s.Collections,
-			Strategy:    str,
-		}
-		options = append(options, opt)
-	}
-
-	// TODO: Add a precondition test here to ensure the panic below will not fire during runtime.
-
-	// This is passed as a provider so it can be evaluated once ProcessorOptions become available
-	procProvider := func(o processing.ProcessorOptions) event.Processor {
-		xforms := settings.TransformProviders.Create(o)
-
-		s, err := snapshotter.NewSnapshotter(xforms, options)
-		if err != nil {
-			panic(err)
-		}
-		return s
-	}
-
-	rtOpt := processing.RuntimeOptions{
-		ProcessorProvider: procProvider,
-		DomainSuffix:      settings.DomainSuffix,
-		Source:            settings.Source,
-	}
-
-	return processing.NewRuntime(rtOpt), nil
-}
-
-func isEnabled(snapshotName string, enabledSnapshots []string) bool {
-	for _, es := range enabledSnapshots {
-		if snapshotName == es {
-			return true
-		}
-	}
-
-	return false
-}
diff --git a/galley/pkg/config/processor/build_test.go b/galley/pkg/config/processor/build_test.go
deleted file mode 100644
index 125095d3c0..0000000000
--- a/galley/pkg/config/processor/build_test.go
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package processor
-
-import (
-	"testing"
-	"time"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/processor/transforms"
-	"istio.io/istio/galley/pkg/config/source/kube/inmemory"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema"
-	"istio.io/istio/pkg/config/schema/snapshots"
-)
-
-const yml = `
-apiVersion: networking.istio.io/v1alpha3
-kind: Gateway
-metadata:
-  name: helloworld-gateway
-spec:
-  selector:
-    istio: ingressgateway # use istio default controller
-  servers:
-  - port:
-      number: 80
-      name: http
-      protocol: HTTP
-    hosts:
-    - "*"
-
-`
-
-func TestProcessor(t *testing.T) {
-	g := NewWithT(t)
-
-	meshSrc := mesh.NewInmemoryMeshCfg()
-	src := inmemory.NewKubeSource(schema.MustGet().KubeCollections())
-	srcs := []event.Source{
-		meshSrc,
-		src,
-	}
-
-	meshSrc.Set(mesh.DefaultMeshConfig())
-	distributor := snapshotter.NewInMemoryDistributor()
-	transformProviders := transforms.Providers(schema.MustGet())
-
-	processorSettings := Settings{
-		Metadata:           schema.MustGet(),
-		DomainSuffix:       "svc.local",
-		Source:             event.CombineSources(srcs...),
-		TransformProviders: transformProviders,
-		Distributor:        distributor,
-		EnabledSnapshots:   []string{snapshots.Default},
-	}
-
-	rt, err := Initialize(processorSettings)
-	g.Expect(err).To(BeNil())
-
-	rt.Start()
-
-	err = src.ApplyContent("foo", yml)
-	g.Expect(err).To(BeNil())
-
-	time.Sleep(time.Second)
-	_ = distributor.GetSnapshot("default")
-}
diff --git a/galley/pkg/config/processor/groups/groups.go b/galley/pkg/config/processor/groups/groups.go
deleted file mode 100644
index 2d480ebbc5..0000000000
--- a/galley/pkg/config/processor/groups/groups.go
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package groups
-
-import (
-	mcp "istio.io/api/mcp/v1alpha1"
-	"istio.io/istio/pkg/mcp/snapshot"
-)
-
-// Default group for MCP requests.
-const Default = "default"
-
-var _ snapshot.GroupIndexFn = IndexFunction
-
-// IndexFunction is a snapshot.GroupIndexFn used internally by Galley.
-func IndexFunction(collection string, _ *mcp.SinkNode) string {
-	return Default
-}
diff --git a/galley/pkg/config/processor/groups/groups_test.go b/galley/pkg/config/processor/groups/groups_test.go
deleted file mode 100644
index 4371b353e6..0000000000
--- a/galley/pkg/config/processor/groups/groups_test.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package groups_test
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/processor/groups"
-)
-
-func TestDefault(t *testing.T) {
-	g := NewWithT(t)
-	actual := groups.IndexFunction("bogus", nil)
-	g.Expect(actual).To(Equal(groups.Default))
-}
diff --git a/galley/pkg/config/scope/scopes.go b/galley/pkg/config/scope/scopes.go
deleted file mode 100644
index 64e3756d87..0000000000
--- a/galley/pkg/config/scope/scopes.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package scope
-
-import "istio.io/pkg/log"
-
-var (
-	// Analysis is a logging scope used by configuration analysis component.
-	Analysis = log.RegisterScope("analysis", "Scope for configuration analysis runtime", 0)
-
-	// Processing is a logging scope used by configuration processing pipeline.
-	Processing = log.RegisterScope("processing", "Scope for configuration processing runtime", 0)
-
-	// Source is a logging scope for config event sources.
-	Source = log.RegisterScope("source", "Scope for configuration event sources", 0)
-)
diff --git a/galley/pkg/config/source/inmemory/collection.go b/galley/pkg/config/source/inmemory/collection.go
deleted file mode 100644
index b671291261..0000000000
--- a/galley/pkg/config/source/inmemory/collection.go
+++ /dev/null
@@ -1,169 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
-
-import (
-	"sort"
-	"strings"
-	"sync"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Collection is an in-memory collection that implements event.Source
-type Collection struct {
-	mu        sync.RWMutex // TODO: We should be able to get rid of this mutex.
-	schema    collection.Schema
-	handler   event.Handler
-	resources map[resource.FullName]*resource.Instance
-	synced    bool
-}
-
-var _ event.Source = &Collection{}
-
-// NewCollection returns a new in-memory collection.
-func NewCollection(s collection.Schema) *Collection {
-	scope.Source.Debug("  Creating in-memory collection: ", s.Name())
-
-	return &Collection{
-		schema:    s,
-		resources: make(map[resource.FullName]*resource.Instance),
-	}
-}
-
-// Start dispatching events for the collection.
-func (c *Collection) Start() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	c.synced = true
-
-	for _, e := range c.resources {
-		c.dispatchFor(e, event.Added)
-	}
-
-	c.dispatchEvent(event.FullSyncFor(c.schema))
-}
-
-// Stop dispatching events and reset internal state.
-func (c *Collection) Stop() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	c.synced = false
-}
-
-// Dispatch an event handler to receive resource events.
-func (c *Collection) Dispatch(handler event.Handler) {
-	if scope.Source.DebugEnabled() {
-		scope.Source.Debugf("Collection.Dispatch: (collection: %-50v, handler: %T)", c.schema.Name(), handler)
-	}
-
-	c.handler = event.CombineHandlers(c.handler, handler)
-}
-
-// Set the entry in the collection
-func (c *Collection) Set(entry *resource.Instance) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	kind := event.Added
-	_, found := c.resources[entry.Metadata.FullName]
-	if found {
-		kind = event.Updated
-	}
-
-	c.resources[entry.Metadata.FullName] = entry
-
-	if c.synced {
-		c.dispatchFor(entry, kind)
-	}
-}
-
-// Clear the contents of this collection.
-func (c *Collection) Clear() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	if c.synced {
-		for _, entry := range c.resources {
-			e := event.Event{
-				Kind:     event.Deleted,
-				Source:   c.schema,
-				Resource: entry,
-			}
-
-			c.dispatchEvent(e)
-		}
-	}
-
-	c.resources = make(map[resource.FullName]*resource.Instance)
-}
-
-func (c *Collection) dispatchEvent(e event.Event) {
-	if scope.Source.DebugEnabled() {
-		scope.Source.Debugf("Collection.dispatchEvent: (col: %-50s): %v", c.schema.Name(), e)
-	}
-	if c.handler != nil {
-		c.handler.Handle(e)
-	}
-}
-
-func (c *Collection) dispatchFor(r *resource.Instance, kind event.Kind) {
-	e := event.Event{
-		Source:   c.schema,
-		Resource: r,
-		Kind:     kind,
-	}
-	c.dispatchEvent(e)
-}
-
-// Remove the entry from the collection
-func (c *Collection) Remove(n resource.FullName) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	entry, found := c.resources[n]
-	if found {
-		e := event.Event{
-			Kind:     event.Deleted,
-			Source:   c.schema,
-			Resource: entry,
-		}
-
-		delete(c.resources, n)
-		c.dispatchEvent(e)
-	}
-}
-
-// AllSorted returns all entries in this collection, in sort order.
-// Warning: This is not performant!
-func (c *Collection) AllSorted() []*resource.Instance {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	var result []*resource.Instance
-	for _, e := range c.resources {
-		result = append(result, e)
-	}
-
-	sort.Slice(result, func(i, j int) bool {
-		return strings.Compare(result[i].Metadata.FullName.String(), result[j].Metadata.FullName.String()) < 0
-	})
-
-	return result
-}
diff --git a/galley/pkg/config/source/inmemory/collection_test.go b/galley/pkg/config/source/inmemory/collection_test.go
deleted file mode 100644
index 1789ccce88..0000000000
--- a/galley/pkg/config/source/inmemory/collection_test.go
+++ /dev/null
@@ -1,211 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/pkg/log"
-)
-
-func TestCollection_Start_Empty(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Start()
-
-	expected := []event.Event{event.FullSyncFor(basicmeta.K8SCollection1)}
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Start_Element(t *testing.T) {
-	g := NewWithT(t)
-
-	old := scope.Source.GetOutputLevel()
-	defer func() {
-		scope.Source.SetOutputLevel(old)
-	}()
-	scope.Source.SetOutputLevel(log.DebugLevel)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.Event1Col1AddItem1.Resource)
-	col.Start()
-
-	expected := []event.Event{data.Event1Col1AddItem1, event.FullSyncFor(basicmeta.K8SCollection1)}
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Update(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.Event1Col1AddItem1.Resource)
-	col.Start()
-
-	col.Set(data.Event1Col1UpdateItem1.Resource)
-
-	expected := []event.Event{
-		data.Event1Col1AddItem1,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		data.Event1Col1UpdateItem1,
-	}
-
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Delete(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.Event1Col1AddItem1.Resource)
-	col.Start()
-
-	col.Remove(data.Event1Col1AddItem1.Resource.Metadata.FullName)
-
-	expected := []event.Event{
-		data.Event1Col1AddItem1,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		data.Event1Col1DeleteItem1,
-	}
-
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Delete_NoItem(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.EntryN1I1V1)
-	col.Start()
-
-	col.Remove(data.EntryN2I2V2.Metadata.FullName)
-
-	expected := []event.Event{
-		data.Event1Col1AddItem1,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-	}
-
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Clear_BeforeStart(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.EntryN1I1V1)
-	col.Set(data.EntryN2I2V2)
-	col.Clear()
-
-	col.Start()
-
-	expected := []event.Event{event.FullSyncFor(basicmeta.K8SCollection1)}
-	actual := acc.Events()
-	g.Expect(actual).To(Equal(expected))
-}
-
-func TestCollection_Clear_AfterStart(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.EntryN1I1V1)
-	col.Set(data.EntryN2I2V2)
-	col.Start()
-	col.Clear()
-
-	expected := []interface{}{
-		data.Event1Col1AddItem1,
-		data.Event2Col1AddItem2,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		data.Event1Col1DeleteItem1,
-		data.Event1Col1DeleteItem2,
-	}
-
-	actual := acc.Events()
-	g.Expect(actual).To(ConsistOf(expected...))
-}
-
-func TestCollection_StopStart(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-	acc := &fixtures.Accumulator{}
-	col.Dispatch(acc)
-
-	col.Set(data.Event1Col1AddItem1.Resource)
-	col.Start()
-
-	expected := []event.Event{
-		data.Event1Col1AddItem1,
-		event.FullSyncFor(basicmeta.K8SCollection1),
-	}
-
-	g.Eventually(acc.Events).Should(Equal(expected))
-
-	col.Stop()
-	acc.Clear()
-	col.Start()
-
-	g.Eventually(acc.Events).Should(Equal(expected))
-}
-
-func TestCollection_AllSorted(t *testing.T) {
-	g := NewWithT(t)
-
-	col := NewCollection(basicmeta.K8SCollection1)
-
-	col.Set(data.EntryN1I1V1)
-	col.Set(data.EntryN2I2V2)
-
-	expected := []*resource.Instance{
-		data.EntryN1I1V1,
-		data.EntryN2I2V2,
-	}
-
-	g.Expect(col.AllSorted()).To(Equal(expected))
-}
diff --git a/galley/pkg/config/source/inmemory/source.go b/galley/pkg/config/source/inmemory/source.go
deleted file mode 100644
index 2c8101d72b..0000000000
--- a/galley/pkg/config/source/inmemory/source.go
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
-
-import (
-	"fmt"
-	"sync"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-var inMemoryNameDiscriminator int64
-
-// Source is an in-memory processor.Source implementation.
-type Source struct {
-	mu      sync.Mutex
-	started bool
-
-	collections map[collection.Name]*Collection
-	name        string
-}
-
-var _ event.Source = &Source{}
-
-// New returns a new in-memory source, based on given collections.
-func New(collections collection.Schemas) *Source {
-	name := fmt.Sprintf("inmemory-%d", inMemoryNameDiscriminator)
-	inMemoryNameDiscriminator++
-
-	all := collections.All()
-	scope.Source.Debugf("Creating new in-memory source (collections: %d)", len(all))
-
-	s := &Source{
-		collections: make(map[collection.Name]*Collection),
-		name:        name,
-	}
-
-	for _, c := range all {
-		s.collections[c.Name()] = NewCollection(c)
-	}
-
-	return s
-}
-
-// Dispatch implements event.Source
-func (s *Source) Dispatch(h event.Handler) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	for _, c := range s.collections {
-		c.Dispatch(h)
-	}
-}
-
-// Start implements processor.Source
-func (s *Source) Start() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if s.started {
-		return
-	}
-
-	for _, c := range s.collections {
-		c.Start()
-	}
-
-	s.started = true
-}
-
-// Stop implements processor.Source
-func (s *Source) Stop() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if !s.started {
-		return
-	}
-
-	s.started = false
-
-	for _, c := range s.collections {
-		c.Stop()
-	}
-}
-
-// Clear contents of this source
-func (s *Source) Clear() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	for _, c := range s.collections {
-		c.Clear()
-	}
-}
-
-// Get returns the named collection.
-func (s *Source) Get(collection collection.Name) *Collection {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	return s.collections[collection]
-}
diff --git a/galley/pkg/config/source/inmemory/source_test.go b/galley/pkg/config/source/inmemory/source_test.go
deleted file mode 100644
index ec8c7cc5fa..0000000000
--- a/galley/pkg/config/source/inmemory/source_test.go
+++ /dev/null
@@ -1,276 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
-
-import (
-	"testing"
-
-	"github.com/gogo/protobuf/types"
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-var cols = collection.SchemasFor(basicmeta.K8SCollection1)
-
-func TestInMemory_Register_Empty(t *testing.T) {
-	g := NewWithT(t)
-
-	i := New(cols)
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_Set_BeforeSync(t *testing.T) {
-	g := NewWithT(t)
-
-	r := &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: resource.NewFullName("ns1", "l1"),
-			Version:  "v1",
-		},
-		Message: &types.Empty{},
-	}
-
-	i := New(cols)
-	i.Get(basicmeta.K8SCollection1.Name()).Set(r)
-
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:     event.Added,
-			Source:   basicmeta.K8SCollection1,
-			Resource: r,
-		},
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_Set_Add(t *testing.T) {
-	g := NewWithT(t)
-
-	r := &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: resource.NewFullName("ns1", "l1"),
-			Version:  "v1",
-		},
-		Message: &types.Empty{},
-	}
-
-	i := New(cols)
-
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-
-	i.Get(basicmeta.K8SCollection1.Name()).Set(r)
-
-	expected = []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-		{
-			Kind:     event.Added,
-			Source:   basicmeta.K8SCollection1,
-			Resource: r,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_Set_Update(t *testing.T) {
-	g := NewWithT(t)
-
-	r1 := &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: resource.NewFullName("ns1", "l1"),
-			Version:  "v1",
-		},
-		Message: &types.Empty{},
-	}
-	r2 := &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName: resource.NewFullName("ns1", "l1"),
-			Version:  "v2",
-		},
-		Message: &types.Empty{},
-	}
-
-	i := New(cols)
-
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-
-	i.Get(basicmeta.K8SCollection1.Name()).Set(r1)
-	i.Get(basicmeta.K8SCollection1.Name()).Set(r2)
-
-	expected = []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-		{
-			Kind:     event.Added,
-			Source:   basicmeta.K8SCollection1,
-			Resource: r1,
-		},
-		{
-			Kind:     event.Updated,
-			Source:   basicmeta.K8SCollection1,
-			Resource: r2,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_Clear_BeforeSync(t *testing.T) {
-	g := NewWithT(t)
-
-	i := New(cols)
-	i.Get(basicmeta.K8SCollection1.Name()).Set(data.EntryN1I1V1)
-
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-
-	i.Clear()
-
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_Clear_AfterSync(t *testing.T) {
-	g := NewWithT(t)
-
-	i := New(cols)
-	i.Get(basicmeta.K8SCollection1.Name()).Set(data.EntryN1I1V1)
-
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-
-	i.Start()
-	defer i.Stop()
-
-	i.Clear()
-
-	expected := []event.Event{
-		data.Event1Col1AddItem1,
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-		data.Event1Col1DeleteItem1,
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_DoubleStart(t *testing.T) {
-	g := NewWithT(t)
-
-	i := New(cols)
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-	i.Start()
-	defer i.Stop()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-}
-
-func TestInMemory_DoubleStop(t *testing.T) {
-	g := NewWithT(t)
-
-	i := New(cols)
-	h := &fixtures.Accumulator{}
-	i.Dispatch(h)
-	i.Start()
-
-	expected := []event.Event{
-		{
-			Kind:   event.FullSync,
-			Source: basicmeta.K8SCollection1,
-		},
-	}
-
-	g.Expect(h.Events()).To(Equal(expected))
-
-	i.Stop()
-	i.Stop()
-}
diff --git a/galley/pkg/config/source/kube/apiserver/options.go b/galley/pkg/config/source/kube/apiserver/options.go
deleted file mode 100644
index 917c598b03..0000000000
--- a/galley/pkg/config/source/kube/apiserver/options.go
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package apiserver
-
-import (
-	"time"
-
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/status"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Options for the kube controller
-type Options struct {
-	// The Client interfaces to use for connecting to the API server.
-	Client kube.Interfaces
-
-	ResyncPeriod time.Duration
-
-	Schemas collection.Schemas
-
-	StatusController status.Controller
-
-	WatchedNamespaces string
-}
diff --git a/galley/pkg/config/source/kube/apiserver/source.go b/galley/pkg/config/source/kube/apiserver/source.go
deleted file mode 100644
index 5ecce5c226..0000000000
--- a/galley/pkg/config/source/kube/apiserver/source.go
+++ /dev/null
@@ -1,289 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package apiserver
-
-import (
-	"fmt"
-	"sort"
-	"strings"
-	"sync"
-
-	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/status"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/config/schema/resource"
-)
-
-// crdKubeResource is metadata for listening to CRD resource on the API Server.
-var crdKubeResource = collection.Builder{
-	Name: "k8s/crd",
-	Resource: resource.Builder{
-		Group:   "apiextensions.k8s.io",
-		Version: "v1",
-		Plural:  "customresourcedefinitions",
-		Kind:    "CustomResourceDefinition",
-	}.BuildNoValidate(),
-}.MustBuild()
-
-// Source is an implementation of processing.KubeSource
-type Source struct { // nolint:maligned
-	mu      sync.RWMutex
-	options Options
-
-	// Keep the handlers that are registered by this Source. As we're recreating watchers, we need to seed them correctly
-	// with each incarnation.
-	handlers *event.Handlers
-
-	// Indicates whether this source is started or not.
-	started bool
-
-	// Set of resources that we're waiting CRD events for. As CRD events arrive, if they match to entries in
-	// expectedResources, the watchers for those resources will be created.
-	expectedResources map[string]collection.Schema
-
-	// Set of resources that have been found so far.
-	foundResources map[string]bool
-
-	// publishing indicates that the CRD discovery phase is over and actual data events are being published. Until
-	// publishing set, the incoming CRD events will cause new watchers to come online. Once the publishing is set,
-	// any new CRD event will cause an event.RESET to be published.
-	publishing bool
-
-	provider *rt.Provider
-
-	// crdWatcher is a specialized watcher just for listening to CRDs.
-	crdWatcher *watcher
-
-	// watchers for each collection that were created as part of CRD discovery.
-	watchers map[collection.Name]*watcher
-
-	statusCtl status.Controller
-}
-
-var (
-	_ event.Source              = &Source{}
-	_ snapshotter.StatusUpdater = &Source{}
-)
-
-// New returns a new kube.Source.
-func New(o Options) *Source {
-	s := &Source{
-		options:   o,
-		handlers:  &event.Handlers{},
-		statusCtl: o.StatusController,
-	}
-
-	return s
-}
-
-// Dispatch implements processor.Source
-func (s *Source) Dispatch(h event.Handler) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	s.handlers.Add(h)
-}
-
-// Start implements processor.Source
-func (s *Source) Start() {
-	s.mu.Lock()
-	if s.started {
-		scope.Source.Warn("Source.Start: already started")
-		s.mu.Unlock()
-		return
-	}
-	s.started = true
-
-	// Create a set of pending resources. These will be matched up with incoming CRD events for creating watchers for
-	// each resource that we expect.
-	// We also keep track of what resources have been found in the metadata.
-	s.expectedResources = make(map[string]collection.Schema)
-	s.foundResources = make(map[string]bool)
-	for _, r := range s.options.Schemas.All() {
-		key := asKey(r.Resource().Group(), r.Resource().Kind())
-		s.expectedResources[key] = r
-	}
-	// Releasing the lock here to avoid deadlock on crdWatcher between the existing one and a newly started one.
-	s.mu.Unlock()
-
-	// Start the CRD listener. When the listener is fully-synced, the listening of actual resources will start.
-	scope.Source.Infof("Beginning CRD Discovery, to figure out resources that are available...")
-	s.provider = rt.NewProvider(s.options.Client, s.options.WatchedNamespaces, s.options.ResyncPeriod)
-	a := s.provider.GetAdapter(crdKubeResource.Resource())
-	s.crdWatcher = newWatcher(crdKubeResource, a, s.statusCtl)
-	s.crdWatcher.dispatch(event.HandlerFromFn(s.onCrdEvent))
-	s.crdWatcher.start()
-}
-
-func (s *Source) onCrdEvent(e event.Event) {
-	scope.Source.Debug("onCrdEvent: ", e)
-
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	if !s.started {
-		// Avoid any potential timings with .Stop() being called while an event being received.
-		return
-	}
-
-	if s.publishing {
-		// Any event in publishing state causes a reset
-		scope.Source.Infof("Detected a CRD change while processing configuration events. Sending Reset event.")
-		s.handlers.Handle(event.Event{Kind: event.Reset})
-		return
-	}
-
-	switch e.Kind {
-	case event.Added:
-		crd := e.Resource.Message.(*apiextensions.CustomResourceDefinitionSpec)
-		g := crd.Group
-		k := crd.Names.Kind
-		key := asKey(g, k)
-		r, ok := s.expectedResources[key]
-		if ok {
-			scope.Source.Debugf("Marking resource as available: %v", r.Resource().GroupVersionKind())
-			s.foundResources[key] = true
-			s.expectedResources[key] = r
-		}
-
-	case event.FullSync:
-		scope.Source.Infof("CRD Discovery complete, starting listening to resources...")
-		s.startWatchers()
-		s.publishing = true
-
-	case event.Updated, event.Deleted, event.Reset:
-		// The code is currently not equipped to deal with this. Simply publish a reset event to get everything
-		// restarted later.
-		s.handlers.Handle(event.Event{Kind: event.Reset})
-
-	default:
-		panic(fmt.Errorf("onCrdEvent: unrecognized event: %v", e))
-	}
-}
-
-func (s *Source) startWatchers() {
-	// must be called under lock
-
-	// sort resources by name for consistent logging
-	resources := make([]collection.Schema, 0, len(s.expectedResources))
-	for _, r := range s.expectedResources {
-		resources = append(resources, r)
-	}
-
-	sort.Slice(resources, func(i, j int) bool {
-		return strings.Compare(resources[i].Resource().GroupVersionKind().String(), resources[j].Resource().GroupVersionKind().String()) < 0
-	})
-
-	scope.Source.Info("Creating watchers for Kubernetes CRDs")
-	s.watchers = make(map[collection.Name]*watcher)
-	for i, r := range resources {
-		if s.provider == nil {
-			scope.Source.Warn("stopped before finished starting watchers")
-			return
-		}
-		a := s.provider.GetAdapter(r.Resource())
-
-		found := s.foundResources[asKey(r.Resource().Group(), r.Resource().Kind())]
-
-		scope.Source.Infof("[%d]", i)
-		scope.Source.Infof("  Source:       %s", r.Resource().GroupVersionKind())
-		scope.Source.Infof("  Name:  		 %s", r.Name())
-		scope.Source.Infof("  Built-in:     %v", a.IsBuiltIn())
-		scope.Source.Infof("  Disabled:     %v", r.IsDisabled())
-		if !a.IsBuiltIn() {
-			scope.Source.Infof("  Found:  %v", found)
-		}
-
-		// Send a Full Sync event immediately for custom resources that were never found, or that are disabled.
-		// For everything else, create a watcher.
-		if (!a.IsBuiltIn() && !found) || r.IsDisabled() {
-			scope.Source.Debug("Source.Start: sending immediate FullSync for: ", r.Name())
-			s.handlers.Handle(event.FullSyncFor(r))
-		} else {
-			col := newWatcher(r, a, s.statusCtl)
-			col.dispatch(s.handlers)
-			s.watchers[r.Name()] = col
-		}
-	}
-
-	if s.statusCtl != nil {
-		scope.Source.Infof("Starting status controller...")
-		s.statusCtl.Start(s.provider, resources)
-	}
-
-	for c, w := range s.watchers {
-		scope.Source.Debug("Source.Start: starting watcher: ", c)
-		w.start()
-	}
-}
-
-// Stop implements processor.Source
-func (s *Source) Stop() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if !s.started {
-		scope.Source.Warn("Source.Stop: Already stopped")
-		return
-	}
-
-	s.stop()
-}
-
-// Update implements processing.StatusUpdater
-func (s *Source) Update(messages diag.Messages) {
-	s.mu.RLock()
-	defer s.mu.RUnlock()
-	if s.statusCtl == nil {
-		panic("received diagnostic messages while the source is not configured with a status controller")
-	}
-
-	s.statusCtl.Report(messages)
-}
-
-func (s *Source) stop() {
-	// must be called under lock
-
-	if s.statusCtl != nil {
-		s.statusCtl.Stop()
-	}
-
-	if s.watchers != nil {
-		for c, w := range s.watchers {
-			scope.Source.Debug("Source.Stop: stopping watcher: ", c)
-			w.stop()
-		}
-		s.watchers = nil
-	}
-
-	if s.crdWatcher != nil {
-		s.crdWatcher.stop()
-		s.crdWatcher = nil
-	}
-
-	s.provider = nil
-	s.publishing = false
-	s.expectedResources = nil
-
-	s.started = false
-}
-
-func asKey(group, kind string) string {
-	return group + "/" + kind
-}
diff --git a/galley/pkg/config/source/kube/apiserver/source_builtin_test.go b/galley/pkg/config/source/kube/apiserver/source_builtin_test.go
deleted file mode 100644
index f8de6b5d71..0000000000
--- a/galley/pkg/config/source/kube/apiserver/source_builtin_test.go
+++ /dev/null
@@ -1,415 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package apiserver_test
-
-import (
-	"context"
-	"testing"
-	"time"
-
-	"github.com/gogo/protobuf/proto"
-	. "github.com/onsi/gomega"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/galley/pkg/config/testing/k8smeta"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	resource2 "istio.io/istio/pkg/config/schema/resource"
-	"istio.io/istio/pkg/kube"
-	"istio.io/pkg/log"
-)
-
-const (
-	name      = "fakeResource"
-	namespace = "fakeNamespace"
-)
-
-var (
-	fakeCreateTime, _ = time.Parse(time.RFC3339, "2009-02-04T21:00:57-08:00")
-	fakeObjectMeta    = metav1.ObjectMeta{
-		Name:      name,
-		Namespace: namespace,
-		CreationTimestamp: metav1.Time{
-			Time: fakeCreateTime,
-		},
-		Labels: map[string]string{
-			"lk1": "lv1",
-		},
-		Annotations: map[string]string{
-			"ak1": "av1",
-		},
-		ResourceVersion: "rv1",
-	}
-
-	metadata = k8smeta.MustGet().KubeCollections()
-)
-
-func TestBasic(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set the log level to debug for codecov.
-	prevLevel := setDebugLogLevel()
-	defer restoreLogLevel(prevLevel)
-
-	k := kube.NewFakeClient()
-
-	// Start the source.
-	s := newOrFail(t, k, k8smeta.MustGet().KubeCollections(), nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.EventsWithoutOrigins).Should(HaveLen(7))
-	for i := 0; i < 7; i++ {
-		g.Expect(acc.EventsWithoutOrigins()[i].Kind).Should(Equal(event.FullSync))
-	}
-
-	acc.Clear()
-
-	node := &corev1.Node{
-		ObjectMeta: fakeObjectMeta,
-		Spec: corev1.NodeSpec{
-			PodCIDR: "10.40.0.0/24",
-		},
-	}
-	node.Namespace = "" // nodes don't have namespaces.
-
-	// Add the resource.
-	if _, err := k.CoreV1().Nodes().Create(context.TODO(), node, metav1.CreateOptions{}); err != nil {
-		t.Fatalf("failed creating node: %v", err)
-	}
-
-	expected := event.AddFor(k8smeta.K8SCoreV1Nodes, toResource(node, &node.Spec, k8smeta.K8SCoreV1Nodes.Resource()))
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-}
-
-func TestNodes(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set the log level to debug for codecov.
-	prevLevel := setDebugLogLevel()
-	defer restoreLogLevel(prevLevel)
-
-	k := kube.NewFakeClient()
-
-	// Start the source.
-	s := newOrFail(t, k, metadata, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.EventsWithoutOrigins).Should(HaveLen(7))
-	for i := 0; i < 7; i++ {
-		g.Expect(acc.EventsWithoutOrigins()[i].Kind).Should(Equal(event.FullSync))
-	}
-	acc.Clear()
-
-	node := &corev1.Node{
-		ObjectMeta: fakeObjectMeta,
-		Spec: corev1.NodeSpec{
-			PodCIDR: "10.40.0.0/24",
-		},
-	}
-	node.Namespace = "" // nodes don't have namespaces.
-
-	// Add the resource.
-	if _, err := k.CoreV1().Nodes().Create(context.TODO(), node, metav1.CreateOptions{}); err != nil {
-		t.Fatalf("failed creating node: %v", err)
-	}
-
-	expected := event.AddFor(k8smeta.K8SCoreV1Nodes, toResource(node, &node.Spec, k8smeta.K8SCoreV1Nodes.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update the resource.
-	node = node.DeepCopy()
-	node.Spec.PodCIDR = "10.20.0.0/32"
-	node.ResourceVersion = "rv2"
-	if _, err := k.CoreV1().Nodes().Update(context.TODO(), node, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating node: %v", err)
-	}
-
-	expected = event.UpdateFor(k8smeta.K8SCoreV1Nodes, toResource(node, &node.Spec, k8smeta.K8SCoreV1Nodes.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	if _, err := k.CoreV1().Nodes().Update(context.TODO(), node, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating node: %v", err)
-	}
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	acc.Clear()
-
-	// Delete the resource.
-	if err := k.CoreV1().Nodes().Delete(context.TODO(), node.Name, metav1.DeleteOptions{}); err != nil {
-		t.Fatalf("failed deleting node: %v", err)
-	}
-	expected = event.DeleteForResource(k8smeta.K8SCoreV1Nodes, toResource(node, &node.Spec, k8smeta.K8SCoreV1Nodes.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-}
-
-func TestPods(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set the log level to debug for codecov.
-	prevLevel := setDebugLogLevel()
-	defer restoreLogLevel(prevLevel)
-
-	k := kube.NewFakeClient()
-
-	// Start the source.
-	s := newOrFail(t, k, metadata, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.EventsWithoutOrigins).Should(HaveLen(7))
-	for i := 0; i < 7; i++ {
-		g.Expect(acc.EventsWithoutOrigins()[i].Kind).Should(Equal(event.FullSync))
-	}
-	acc.Clear()
-
-	pod := &corev1.Pod{
-		ObjectMeta: fakeObjectMeta,
-		Spec: corev1.PodSpec{
-			Containers: []corev1.Container{
-				{
-					Name:            "c1",
-					Image:           "someImage",
-					ImagePullPolicy: corev1.PullIfNotPresent,
-					Ports: []corev1.ContainerPort{
-						{
-							Name:     "http",
-							Protocol: corev1.ProtocolTCP,
-							HostPort: 80,
-						},
-					},
-				},
-			},
-		},
-	}
-
-	if _, err := k.CoreV1().Pods(namespace).Create(context.TODO(), pod, metav1.CreateOptions{}); err != nil {
-		t.Fatalf("failed creating pod: %v", err)
-	}
-	expected := event.AddFor(k8smeta.K8SCoreV1Pods, toResource(pod, pod, k8smeta.K8SCoreV1Pods.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update the resource.
-	pod = pod.DeepCopy()
-	pod.Spec.Containers[0].Name = "c2"
-	pod.ResourceVersion = "rv2"
-	if _, err := k.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating pod: %v", err)
-	}
-	expected = event.UpdateFor(k8smeta.K8SCoreV1Pods, toResource(pod, pod, k8smeta.K8SCoreV1Pods.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update event with no changes, should yield no events.
-	if _, err := k.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating pod: %v", err)
-	}
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	acc.Clear()
-
-	// Delete the resource.
-	if err := k.CoreV1().Pods(namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{}); err != nil {
-		t.Fatalf("failed deleting pod: %v", err)
-	}
-	expected = event.DeleteForResource(k8smeta.K8SCoreV1Pods, toResource(pod, pod, k8smeta.K8SCoreV1Pods.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-}
-
-func TestServices(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set the log level to debug for codecov.
-	prevLevel := setDebugLogLevel()
-	defer restoreLogLevel(prevLevel)
-
-	client := kube.NewFakeClient()
-
-	// Start the source.
-	s := newOrFail(t, client, metadata, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.EventsWithoutOrigins).Should(HaveLen(7))
-	for i := 0; i < 7; i++ {
-		g.Expect(acc.EventsWithoutOrigins()[i].Kind).Should(Equal(event.FullSync))
-	}
-	acc.Clear()
-
-	svc := &corev1.Service{
-		ObjectMeta: fakeObjectMeta,
-		Spec: corev1.ServiceSpec{
-			Type: corev1.ServiceTypeClusterIP,
-			Ports: []corev1.ServicePort{
-				{
-					Name:     "http",
-					Protocol: corev1.ProtocolTCP,
-					Port:     80,
-				},
-			},
-		},
-	}
-
-	// Add the resource.
-	if _, err := client.CoreV1().Services(namespace).Create(context.TODO(), svc, metav1.CreateOptions{}); err != nil {
-		t.Fatalf("failed creating service: %v", err)
-	}
-	expected := event.AddFor(k8smeta.K8SCoreV1Services, toResource(svc, &svc.Spec, k8smeta.K8SCoreV1Services.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update the resource.
-	svc = svc.DeepCopy()
-	svc.Spec.Ports[0].Port = 8080
-	svc.ResourceVersion = "rv2"
-	if _, err := client.CoreV1().Services(namespace).Update(context.TODO(), svc, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating service: %v", err)
-	}
-	expected = event.UpdateFor(k8smeta.K8SCoreV1Services, toResource(svc, &svc.Spec, k8smeta.K8SCoreV1Services.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update event with no changes, should yield no events.
-	if _, err := client.CoreV1().Services(namespace).Update(context.TODO(), svc, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating service: %v", err)
-	}
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	acc.Clear()
-
-	// Delete the resource.
-	if err := client.CoreV1().Services(namespace).Delete(context.TODO(), svc.Name, metav1.DeleteOptions{}); err != nil {
-		t.Fatalf("failed deleting service: %v", err)
-	}
-	expected = event.DeleteForResource(k8smeta.K8SCoreV1Services, toResource(svc, &svc.Spec, k8smeta.K8SCoreV1Services.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-}
-
-func TestEndpoints(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set the log level to debug for codecov.
-	prevLevel := setDebugLogLevel()
-	defer restoreLogLevel(prevLevel)
-
-	client := kube.NewFakeClient()
-
-	// Start the source.
-	s := newOrFail(t, client, metadata, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.EventsWithoutOrigins).Should(HaveLen(7))
-	for i := 0; i < 7; i++ {
-		g.Expect(acc.EventsWithoutOrigins()[i].Kind).Should(Equal(event.FullSync))
-	}
-	acc.Clear()
-
-	eps := &corev1.Endpoints{
-		ObjectMeta: fakeObjectMeta,
-		Subsets: []corev1.EndpointSubset{
-			{
-				Addresses: []corev1.EndpointAddress{
-					{
-						Hostname: "fake.host.com",
-						IP:       "10.40.0.0",
-					},
-				},
-				Ports: []corev1.EndpointPort{
-					{
-						Name:     "http",
-						Protocol: corev1.ProtocolTCP,
-						Port:     80,
-					},
-				},
-			},
-		},
-	}
-
-	var err error
-	// Add the resource.
-	if eps, err = client.CoreV1().Endpoints(namespace).Create(context.TODO(), eps, metav1.CreateOptions{}); err != nil {
-		t.Fatalf("failed creating endpoints: %v", err)
-	}
-	expected := event.AddFor(k8smeta.K8SCoreV1Endpoints, toResource(eps, eps, k8smeta.K8SCoreV1Endpoints.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update the resource.
-	eps = eps.DeepCopy()
-	eps.Subsets[0].Ports[0].Port = 8080
-	eps.ResourceVersion = "rv2"
-	if _, err = client.CoreV1().Endpoints(namespace).Update(context.TODO(), eps, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating endpoints: %v", err)
-	}
-	expected = event.UpdateFor(k8smeta.K8SCoreV1Endpoints, toResource(eps, eps, k8smeta.K8SCoreV1Endpoints.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-
-	acc.Clear()
-
-	// Update event with no changes, should yield no events.
-	// Changing only the resource version, should have not result in an update.
-	eps = eps.DeepCopy()
-	eps.ResourceVersion = "rv3"
-	if _, err = client.CoreV1().Endpoints(namespace).Update(context.TODO(), eps, metav1.UpdateOptions{}); err != nil {
-		t.Fatalf("failed updating endpoints: %v", err)
-	}
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	// Delete the resource.
-	if err = client.CoreV1().Endpoints(namespace).Delete(context.TODO(), eps.Name, metav1.DeleteOptions{}); err != nil {
-		t.Fatalf("failed deleting endpoints: %v", err)
-	}
-	expected = event.DeleteForResource(k8smeta.K8SCoreV1Endpoints, toResource(eps, eps, k8smeta.K8SCoreV1Endpoints.Resource()))
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, expected)
-}
-
-func toResource(objectMeta metav1.Object, item proto.Message, schema resource2.Schema) *resource.Instance {
-	return &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName:    resource.NewFullName(resource.Namespace(objectMeta.GetNamespace()), resource.LocalName(objectMeta.GetName())),
-			Version:     resource.Version(objectMeta.GetResourceVersion()),
-			CreateTime:  fakeCreateTime,
-			Labels:      objectMeta.GetLabels(),
-			Annotations: objectMeta.GetAnnotations(),
-			Schema:      schema,
-		},
-		Message: item,
-	}
-}
-
-func setDebugLogLevel() log.Level {
-	prev := scope.Source.GetOutputLevel()
-	scope.Source.SetOutputLevel(log.DebugLevel)
-	return prev
-}
-
-func restoreLogLevel(level log.Level) {
-	scope.Source.SetOutputLevel(level)
-}
diff --git a/galley/pkg/config/source/kube/apiserver/source_dynamic_test.go b/galley/pkg/config/source/kube/apiserver/source_dynamic_test.go
deleted file mode 100644
index 0119fbc7ee..0000000000
--- a/galley/pkg/config/source/kube/apiserver/source_dynamic_test.go
+++ /dev/null
@@ -1,567 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-package apiserver_test
-
-import (
-	"fmt"
-	"sync"
-	"sync/atomic"
-	"testing"
-
-	"github.com/gogo/protobuf/types"
-	. "github.com/onsi/gomega"
-	uatomic "go.uber.org/atomic"
-	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
-	extfake "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset/fake"
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	k8sRuntime "k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/watch"
-	"k8s.io/client-go/dynamic/fake"
-	k8sTesting "k8s.io/client-go/testing"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/status"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/galley/pkg/testing/mock"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-	resource2 "istio.io/istio/pkg/config/schema/resource"
-	kubelib "istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/test"
-)
-
-func TestStartTwice(t *testing.T) {
-	r := basicmeta.MustGet().KubeCollections()
-	s := newOrFail(t, kubelib.NewFakeClient(), r, nil)
-
-	// Start it once.
-	_ = start(s)
-	defer s.Stop()
-
-	// Start again should fail
-	s.Start()
-}
-
-func TestStartStop_WithStatusCtl(t *testing.T) {
-	g := NewWithT(t)
-
-	sc := &statusCtl{}
-	r := basicmeta.MustGet().KubeCollections()
-	s := newOrFail(t, kubelib.NewFakeClient(), r, sc)
-
-	s.Start()
-	g.Eventually(sc.hasStarted).Should(BeTrue())
-
-	s.Stop()
-	g.Eventually(sc.hasStopped).Should(BeTrue())
-}
-
-func TestStopTwiceShouldSucceed(t *testing.T) {
-	r := basicmeta.MustGet().KubeCollections()
-	s := newOrFail(t, kubelib.NewFakeClient(), r, nil)
-
-	// Start it once.
-	_ = start(s)
-
-	s.Stop()
-	s.Stop()
-}
-
-func TestReport(t *testing.T) {
-	g := NewWithT(t)
-
-	sc := &statusCtl{}
-	r := basicmeta.MustGet().KubeCollections()
-	s := newOrFail(t, kubelib.NewFakeClient(), r, sc)
-
-	s.Start()
-	defer s.Stop()
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"),
-		},
-	}
-	m := msg.NewInternalError(&e, "foo")
-
-	s.Update(diag.Messages{m})
-	g.Expect(sc.latestReport()).To(Equal(diag.Messages{m}))
-}
-
-func TestEvents(t *testing.T) {
-	g := NewWithT(t)
-
-	w, wcrd, cl := createMocks(t)
-	defer wcrd.Stop()
-	defer w.Stop()
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-
-	// Create and start the source
-	s := newOrFail(t, cl, r, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.FullSyncFor(basicmeta.K8SCollection1))
-	acc.Clear()
-
-	obj := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"apiVersion": "testdata.istio.io/v1alpha1",
-			"kind":       "Kind1",
-			"metadata": map[string]interface{}{
-				"name":            "i1",
-				"namespace":       "ns",
-				"resourceVersion": "v1",
-			},
-			"spec": map[string]interface{}{},
-		},
-	}
-
-	obj = obj.DeepCopy()
-	w.Send(watch.Event{Type: watch.Added, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.AddFor(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-
-	acc.Clear()
-
-	obj = obj.DeepCopy()
-	obj.SetResourceVersion("rv2")
-
-	w.Send(watch.Event{Type: watch.Modified, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.UpdateFor(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-
-	acc.Clear()
-
-	// Make a copy so we can change it without affecting the original.
-	objCopy := obj.DeepCopy()
-	objCopy.SetResourceVersion("rv2")
-
-	w.Send(watch.Event{Type: watch.Modified, Object: objCopy})
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	w.Send(watch.Event{Type: watch.Deleted, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.DeleteForResource(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-}
-
-func TestEvents_WatchUpdatesStatusCtl(t *testing.T) {
-	g := NewWithT(t)
-
-	w, wcrd, cl := createMocks(t)
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-
-	sc := &statusCtl{}
-
-	// Create and start the source
-	s := newOrFail(t, cl, r, sc)
-	acc := start(s)
-	defer s.Stop()
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.FullSyncFor(basicmeta.K8SCollection1))
-	acc.Clear()
-
-	obj := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"apiVersion": "testdata.istio.io/v1alpha1",
-			"kind":       "Kind1",
-			"metadata": map[string]interface{}{
-				"name":            "i1",
-				"namespace":       "ns",
-				"resourceVersion": "v1",
-			},
-			"spec": map[string]interface{}{},
-		},
-	}
-
-	obj = obj.DeepCopy()
-	w.Send(watch.Event{Type: watch.Added, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.AddFor(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-
-	g.Eventually(sc.latestStatusCall).ShouldNot(BeNil())
-	g.Expect(sc.latestStatusCall()).To(Equal(&statusInput{
-		col:     basicmeta.K8SCollection1.Name(),
-		name:    resource.NewFullName("ns", "i1"),
-		version: "v1",
-		status:  nil,
-	}))
-	acc.Clear()
-
-	obj = obj.DeepCopy()
-	obj.SetResourceVersion("rv2")
-	obj.Object["status"] = "stat"
-
-	w.Send(watch.Event{Type: watch.Modified, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.UpdateFor(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-
-	g.Expect(sc.latestStatusCall()).To(Equal(&statusInput{
-		col:     basicmeta.K8SCollection1.Name(),
-		name:    resource.NewFullName("ns", "i1"),
-		version: "rv2",
-		status:  "stat",
-	}))
-
-	acc.Clear()
-
-	// Make a copy so we can change it without affecting the original.
-	objCopy := obj.DeepCopy()
-	objCopy.SetResourceVersion("rv2")
-
-	w.Send(watch.Event{Type: watch.Modified, Object: objCopy})
-	g.Consistently(acc.EventsWithoutOrigins).Should(BeEmpty())
-
-	w.Send(watch.Event{Type: watch.Deleted, Object: obj})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.DeleteForResource(basicmeta.K8SCollection1,
-		toEntry(obj, basicmeta.K8SCollection1.Resource())))
-}
-
-func TestEvents_CRDEventAfterFullSync(t *testing.T) {
-	_, wcrd, cl := createMocks(t)
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-
-	// Create and start the source
-	s := newOrFail(t, cl, r, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.FullSyncFor(basicmeta.K8SCollection1))
-
-	acc.Clear()
-	c := toCrd(r.All()[0])
-	c.ResourceVersion = "v2"
-	wcrd.Send(watch.Event{
-		Type:   watch.Modified,
-		Object: c,
-	})
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.Event{Kind: event.Reset})
-}
-
-func TestEvents_NonAddEvent(t *testing.T) {
-	g := NewWithT(t)
-
-	_, wcrd, cl := createMocks(t)
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-	c := toCrd(r.All()[0])
-	c.ResourceVersion = "v2"
-	wcrd.Send(watch.Event{
-		Type:   watch.Modified,
-		Object: c,
-	})
-
-	// Create and start the source
-	s := newOrFail(t, cl, r, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.Events).Should(ContainElement(
-		event.Event{Kind: event.Reset},
-	))
-}
-
-func TestEvents_NoneForDisabled(t *testing.T) {
-	g := NewWithT(t)
-
-	_, wcrd, cl := createMocks(t)
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-
-	// Create and start the source
-	s := newOrFail(t, cl, r, nil)
-	acc := start(s)
-	defer s.Stop()
-
-	g.Eventually(acc.Events).Should(BeEmpty())
-}
-
-func TestSource_WatcherFailsCreatingInformer(t *testing.T) {
-	// Setup a lock so we can dynamically change the watch returned
-	mu := sync.Mutex{}
-	errRet := uatomic.NewString("")
-	k := kubelib.NewFakeClient()
-
-	// Setup mock watch
-	w := mock.NewWatch()
-	k.Dynamic().(*fake.FakeDynamicClient).PrependWatchReactor("*", func(_ k8sTesting.Action) (handled bool, ret watch.Interface, err error) {
-		mu.Lock()
-		defer mu.Unlock()
-		return true, w, nil
-	})
-	t.Cleanup(w.Stop)
-
-	wcrd := mockCrdWatch(k.Ext().(*extfake.Clientset))
-	t.Cleanup(wcrd.Stop)
-
-	r := basicmeta.MustGet().KubeCollections()
-	addCrdEvents(wcrd, r.All())
-	k.Dynamic().(*fake.FakeDynamicClient).PrependReactor("*", "*", func(action k8sTesting.Action) (handled bool, ret k8sRuntime.Object, err error) {
-		e := errRet.Load() // Fetch the error and wipe it out
-		errRet.Store("")
-		if e == "" {
-			return false, nil, nil
-		}
-		return true, nil, fmt.Errorf(e)
-	})
-
-	errRet.Store("no cheese found")
-
-	// Create and start the source
-	s := newOrFail(t, k, r, nil)
-	// Start/stop when informer is not created. It should not crash or cause errors.
-	acc := start(s)
-
-	// we should get a full sync event, even if the watcher doesn't properly start.
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc, event.FullSyncFor(basicmeta.K8SCollection1))
-
-	s.Stop()
-
-	acc.Clear()
-	wcrd.Stop()
-
-	wcrd = mockCrdWatch(k.Ext().(*extfake.Clientset))
-	addCrdEvents(wcrd, r.All())
-
-	// Now start properly and get events
-	errRet.Store("")
-	mu.Lock()
-	w = mock.NewWatch()
-	mu.Unlock()
-
-	s.Start()
-
-	obj := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"apiVersion": "testdata.istio.io/v1alpha1",
-			"kind":       "Kind1",
-			"metadata": map[string]interface{}{
-				"name":            "i1",
-				"namespace":       "ns",
-				"resourceVersion": "v1",
-			},
-			"spec": map[string]interface{}{},
-		},
-	}
-	obj = obj.DeepCopy()
-
-	w.Send(watch.Event{Type: watch.Added, Object: obj})
-
-	defer s.Stop()
-
-	fixtures.ExpectEventsWithoutOriginsEventually(t, acc,
-		event.AddFor(basicmeta.K8SCollection1, toEntry(obj, basicmeta.K8SCollection1.Resource())),
-		event.FullSyncFor(basicmeta.K8SCollection1))
-}
-
-func TestUpdateMessage_NoStatusController_Panic(t *testing.T) {
-	g := NewWithT(t)
-
-	defer func() {
-		r := recover()
-		g.Expect(r).NotTo(BeNil())
-	}()
-
-	r := basicmeta.MustGet().KubeCollections()
-
-	s := newOrFail(t, kubelib.NewFakeClient(), r, nil)
-
-	start(s)
-	defer s.Stop()
-	s.Update(diag.Messages{})
-}
-
-func newOrFail(t *testing.T, client kubelib.Client, r collection.Schemas, sc status.Controller) *apiserver.Source {
-	t.Helper()
-	o := apiserver.Options{
-		Schemas:          r,
-		ResyncPeriod:     0,
-		Client:           kube.NewInterfacesFromClient(client),
-		StatusController: sc,
-	}
-	s := apiserver.New(o)
-	if s == nil {
-		t.Fatal("Expected non nil source")
-	}
-	return s
-}
-
-func start(s *apiserver.Source) *fixtures.Accumulator {
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Start()
-	return acc
-}
-
-func createMocks(t test.Failer) (*mock.Watch, *mock.Watch, kubelib.ExtendedClient) {
-	c := kubelib.NewFakeClient()
-	w := mockWatch(c.Dynamic().(*fake.FakeDynamicClient))
-	t.Cleanup(w.Stop)
-	wcrd := mockCrdWatch(c.Ext().(*extfake.Clientset))
-	t.Cleanup(wcrd.Stop)
-	return w, wcrd, c
-}
-
-func addCrdEvents(w *mock.Watch, res []collection.Schema) {
-	for _, r := range res {
-		w.Send(watch.Event{
-			Object: toCrd(r),
-			Type:   watch.Added,
-		})
-	}
-}
-
-func mockWatch(cl *fake.FakeDynamicClient) *mock.Watch {
-	w := mock.NewWatch()
-	cl.PrependWatchReactor("*", func(_ k8sTesting.Action) (handled bool, ret watch.Interface, err error) {
-		return true, w, nil
-	})
-	return w
-}
-
-func mockCrdWatch(cl *extfake.Clientset) *mock.Watch {
-	w := mock.NewWatch()
-	cl.PrependWatchReactor("*", func(_ k8sTesting.Action) (handled bool, ret watch.Interface, err error) {
-		return true, w, nil
-	})
-	return w
-}
-
-func toEntry(obj *unstructured.Unstructured, schema resource2.Schema) *resource.Instance {
-	return &resource.Instance{
-		Metadata: resource.Metadata{
-			FullName:    resource.NewFullName(resource.Namespace(obj.GetNamespace()), resource.LocalName(obj.GetName())),
-			Labels:      obj.GetLabels(),
-			Annotations: obj.GetAnnotations(),
-			Version:     resource.Version(obj.GetResourceVersion()),
-			Schema:      schema,
-		},
-		Message: &types.Struct{
-			Fields: make(map[string]*types.Value),
-		},
-	}
-}
-
-func toCrd(schema collection.Schema) *apiextensions.CustomResourceDefinition {
-	r := schema.Resource()
-	return &apiextensions.CustomResourceDefinition{
-		ObjectMeta: v1.ObjectMeta{
-			Name:            r.Plural() + "." + r.Group(),
-			ResourceVersion: "v1",
-		},
-
-		Spec: apiextensions.CustomResourceDefinitionSpec{
-			Group: r.Group(),
-			Names: apiextensions.CustomResourceDefinitionNames{
-				Plural: r.Plural(),
-				Kind:   r.Kind(),
-			},
-			Versions: []apiextensions.CustomResourceDefinitionVersion{
-				{
-					Name: r.Version(),
-				},
-			},
-			Scope: apiextensions.NamespaceScoped,
-		},
-	}
-}
-
-type statusCtl struct {
-	started int32
-	stopped int32
-
-	lastStatusInput atomic.Value
-	lastReport      atomic.Value
-}
-
-type statusInput struct {
-	col     collection.Name
-	name    resource.FullName
-	version resource.Version
-	status  interface{}
-}
-
-var _ status.Controller = &statusCtl{}
-
-func (s *statusCtl) Start(*rt.Provider, []collection.Schema) {
-	atomic.StoreInt32(&s.started, 1)
-}
-
-func (s *statusCtl) Stop() {
-	atomic.StoreInt32(&s.stopped, 1)
-}
-
-func (s *statusCtl) UpdateResourceStatus(
-	col collection.Name, name resource.FullName, version resource.Version, status interface{}) {
-	i := &statusInput{
-		col:     col,
-		name:    name,
-		version: version,
-		status:  status,
-	}
-	s.lastStatusInput.Store(i)
-}
-
-func (s *statusCtl) Report(messages diag.Messages) {
-	s.lastReport.Store(messages)
-}
-
-func (s *statusCtl) hasStarted() bool {
-	return atomic.LoadInt32(&s.started) != 0
-}
-
-func (s *statusCtl) hasStopped() bool {
-	return atomic.LoadInt32(&s.stopped) != 0
-}
-
-func (s *statusCtl) latestStatusCall() *statusInput {
-	i := s.lastStatusInput.Load()
-	if i == nil {
-		return nil
-	}
-	return i.(*statusInput)
-}
-
-func (s *statusCtl) latestReport() diag.Messages {
-	i := s.lastReport.Load()
-	if i == nil {
-		return nil
-	}
-	return i.(diag.Messages)
-}
diff --git a/galley/pkg/config/source/kube/apiserver/stats/stats.go b/galley/pkg/config/source/kube/apiserver/stats/stats.go
deleted file mode 100644
index c064820bb4..0000000000
--- a/galley/pkg/config/source/kube/apiserver/stats/stats.go
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package stats
-
-import (
-	"context"
-
-	"go.opencensus.io/stats"
-	"go.opencensus.io/stats/view"
-	"go.opencensus.io/tag"
-
-	"istio.io/istio/galley/pkg/config/scope"
-)
-
-const (
-	apiVersion = "apiVersion"
-	group      = "group"
-	kind       = "kind"
-	errorStr   = "error"
-)
-
-var (
-	// APIVersionTag holds the API version of the resource.
-	APIVersionTag tag.Key
-	// GroupTag holds the group of the resource.
-	GroupTag tag.Key
-	// KindTag holds the kind of the resource.
-	KindTag tag.Key
-	// ErrorTag holds the error message of a handleEvent failure.
-	ErrorTag tag.Key
-)
-
-var (
-	sourceEventError = stats.Int64(
-		"galley/source/kube/event_error_total",
-		"The number of times a kubernetes source encountered errored while handling an event",
-		stats.UnitDimensionless)
-	sourceEventSuccess = stats.Int64(
-		"galley/source/kube/event_success_total",
-		"The number of times a kubernetes source successfully handled an event",
-		stats.UnitDimensionless)
-
-	sourceConversionSuccess = stats.Int64(
-		"galley/source/kube/dynamic/converter_success_total",
-		"The number of times a dynamic kubernetes source successfully converted a resource",
-		stats.UnitDimensionless)
-	sourceConversionFailure = stats.Int64(
-		"galley/source/kube/dynamic/converter_failure_total",
-		"The number of times a dynamnic kubernetes source failed converting a resources",
-		stats.UnitDimensionless)
-)
-
-// RecordEventError records an error handling a kube event.
-func RecordEventError(msg string) {
-	ctx, ctxErr := tag.New(context.Background(), tag.Insert(ErrorTag, msg))
-	if ctxErr != nil {
-		scope.Source.Errorf("error creating context to record handleEvent error")
-	} else {
-		stats.Record(ctx, sourceEventError.M(1))
-	}
-}
-
-// RecordEventSuccess records successfully handling a kube event.
-func RecordEventSuccess() {
-	stats.Record(context.Background(), sourceEventSuccess.M(1))
-}
-
-func newTagKey(label string) tag.Key {
-	if t, err := tag.NewKey(label); err != nil {
-		panic(err)
-	} else {
-		return t
-	}
-}
-
-func newView(measure stats.Measure, keys []tag.Key, aggregation *view.Aggregation) *view.View {
-	return &view.View{
-		Name:        measure.Name(),
-		Description: measure.Description(),
-		Measure:     measure,
-		TagKeys:     keys,
-		Aggregation: aggregation,
-	}
-}
-
-func init() {
-	APIVersionTag = newTagKey(apiVersion)
-	GroupTag = newTagKey(group)
-	KindTag = newTagKey(kind)
-	ErrorTag = newTagKey(errorStr)
-
-	errorKey := []tag.Key{ErrorTag}
-	conversionKeys := []tag.Key{APIVersionTag, GroupTag, KindTag}
-	var noKeys []tag.Key
-
-	err := view.Register(
-		newView(sourceEventError, errorKey, view.Count()),
-		newView(sourceEventSuccess, noKeys, view.Count()),
-		newView(sourceConversionSuccess, conversionKeys, view.Count()),
-		newView(sourceConversionFailure, conversionKeys, view.Count()),
-	)
-	if err != nil {
-		panic(err)
-	}
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/controller.go b/galley/pkg/config/source/kube/apiserver/status/controller.go
deleted file mode 100644
index cdcbd98a96..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/controller.go
+++ /dev/null
@@ -1,217 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"context"
-	"sync"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/dynamic"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Controller is the interface for a status controller. It is mainly used to separate implementation from
-// interface, so that code can be tested separately.
-type Controller interface {
-	Start(p *rt.Provider, resources []collection.Schema)
-	Stop()
-	UpdateResourceStatus(col collection.Name, name resource.FullName, version resource.Version, status interface{})
-	Report(messages diag.Messages)
-}
-
-// ControllerImpl keeps track of status information for a given K8s style collection and continuously reconciles.
-type ControllerImpl struct {
-	// Protects the top-level start/stop state of the controller
-	mu sync.RWMutex
-
-	// Internal state of the controller. It keeps track of known status, desired status, and work queue.
-	state *state
-
-	// Wait group for synchronizing the exit of the background go routine.
-	wg sync.WaitGroup
-
-	// Subfield of status that this controller manages
-	subfield string
-}
-
-var _ Controller = &ControllerImpl{}
-
-// NewController returns a new instance of controller.
-func NewController(subfield string) *ControllerImpl {
-	return &ControllerImpl{
-		subfield: subfield,
-	}
-}
-
-// Start the controller. This will reset the internal state.
-func (c *ControllerImpl) Start(p *rt.Provider, resources []collection.Schema) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-
-	if c.state != nil {
-		return
-	}
-	c.state = newState()
-
-	ifaces := make(map[collection.Name]dynamic.NamespaceableResourceInterface)
-	for _, r := range resources {
-		if r.IsDisabled() {
-			continue
-		}
-
-		iface, err := p.GetDynamicResourceInterface(r.Resource())
-		if err != nil {
-			scope.Source.Errorf("Unable to create a dynamic resource interface for resource %v", r.Resource().GroupVersionKind())
-		}
-		ifaces[r.Name()] = iface
-	}
-
-	c.wg.Add(1)
-	go run(c.state, c.subfield, ifaces, &c.wg)
-}
-
-// Stop the controller
-func (c *ControllerImpl) Stop() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.state != nil {
-		c.state.quiesceWork()
-		c.wg.Wait()
-		c.state = nil
-	}
-}
-
-// UpdateResourceStatus is called by the source to relay the currently observed status of a resource.
-func (c *ControllerImpl) UpdateResourceStatus(
-	col collection.Name, name resource.FullName, version resource.Version, status interface{}) {
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	if c.state != nil {
-		// Extract the subfield this controller manages
-		// If the status field was something other than a map, treat it like it was an empty map
-		// for the purpose of "observed"
-		statusMap, _ := status.(map[string]interface{})
-
-		c.state.setObserved(col, name, version, statusMap[c.subfield])
-	}
-}
-
-// Report the given set of messages towards particular resources.
-func (c *ControllerImpl) Report(messages diag.Messages) {
-	// TODO: Translating messages in this fashion is expensive, especially on a hot path. We should look for ways
-	// to perform this mapping early on, possibly by directly filling up a MessageSet at the analysis context level.
-	msgs := NewMessageSet()
-
-	for _, m := range messages {
-
-		if m.Resource == nil {
-			// This should not happen. All messages should be reported against at least one resource.
-			scope.Source.Errorf("Encountered a diagnostic message without a resource: %v", m)
-			continue
-		}
-
-		if m.Resource.Origin == nil {
-			// This should not happen. All messages should be reported against at least one origin.
-			scope.Source.Errorf("Encountered a diagnostic message without an origin: %v", m)
-			continue
-		}
-
-		origin, ok := m.Resource.Origin.(*rt.Origin)
-		if !ok {
-			// This should not happen. All messages should be routed back to the appropriate source.
-			scope.Source.Errorf("Encountered a diagnostic message with unrecognized origin: %v", m)
-			continue
-		}
-
-		msgs.Add(origin, m)
-	}
-
-	c.mu.RLock()
-	defer c.mu.RUnlock()
-	if c.state == nil {
-		scope.Analysis.Warn("Analysis reporting after controller stopped")
-		return
-	}
-	c.state.applyMessages(msgs)
-}
-
-func run(state *state, subfield string, ifaces map[collection.Name]dynamic.NamespaceableResourceInterface, wg *sync.WaitGroup) {
-mainloop:
-	for {
-		st, ok := state.dequeueWork()
-		if !ok {
-			break mainloop
-		}
-
-		iface := ifaces[st.key.col]
-		if iface == nil {
-			scope.Source.Errorf("No updater available for diagnostic message(s) for '%v/%v'.", st.key.col, st.key.res)
-			continue
-		}
-
-		ns := string(st.key.res.Namespace)
-		n := string(st.key.res.Name)
-		u, err := iface.Namespace(ns).Get(context.TODO(), n, metav1.GetOptions{ResourceVersion: string(st.observedVersion)})
-		if err != nil {
-			scope.Source.Errorf("Unable to read the resource while trying to update status: %v(%v): %v",
-				st.key.col, st.key.res, err)
-			continue mainloop
-		}
-
-		// Ensure that the resource we read has the same version as the version for which diagnostic message was
-		// generated for.
-		if st.desiredStatusVersion != resource.Version("") && u.GetResourceVersion() != string(st.desiredStatusVersion) {
-			scope.Source.Debugf("Skipping due to version mismatch: %v(%v): %v !=% v",
-				st.key.col, st.key.res, u.GetResourceVersion(), st.desiredStatusVersion)
-			continue mainloop
-		}
-
-		// Get the map of status objects. If it doesn't already exist, create it.
-		statusObj, ok := u.Object["status"]
-		if !ok {
-			statusObj = make(map[string]interface{})
-		}
-		statusMap, ok := statusObj.(map[string]interface{})
-		if !ok {
-			scope.Source.Warnf("Failed to parse the status field as a map. Previous status value will be discarded! Status value was: %v", statusObj)
-			statusMap = make(map[string]interface{})
-		}
-
-		// Update the status field (for the subfield this controller manages) to match desired status
-		// If there are no other subfields left, also delete the status field
-		if st.desiredStatus != nil {
-			statusMap[subfield] = st.desiredStatus
-			u.Object["status"] = statusMap
-		} else {
-			delete(statusMap, subfield)
-			if len(statusMap) == 0 {
-				delete(u.Object, "status")
-			}
-		}
-
-		_, err = iface.Namespace(ns).UpdateStatus(context.TODO(), u, metav1.UpdateOptions{})
-		if err != nil {
-			// TODO: Reinsert work? It probably makes sense to reinsert (with a delay), in case of a transient failure.
-			scope.Source.Errorf("Unable to update status of Resource %v(%v): %v", st.key.col, st.key.res, err)
-		}
-	}
-	wg.Done()
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/controller_test.go b/galley/pkg/config/source/kube/apiserver/status/controller_test.go
deleted file mode 100644
index 244d2c8ef6..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/controller_test.go
+++ /dev/null
@@ -1,394 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"fmt"
-	"testing"
-
-	. "github.com/onsi/gomega"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/client-go/dynamic/fake"
-	k8stesting "k8s.io/client-go/testing"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/pkg/config/resource"
-	kubelib "istio.io/istio/pkg/kube"
-)
-
-const subfield = "testMessages"
-
-func TestBasicStartStop(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-	k, cl := setupClient()
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	defer c.Stop()
-
-	c.Report(diag.Messages{})
-	g.Consistently(cl.Actions).Should(BeEmpty())
-}
-
-func TestDoubleStart(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-	k, cl := setupClient()
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	defer c.Stop()
-
-	c.Report(diag.Messages{})
-	g.Consistently(cl.Actions).Should(BeEmpty())
-}
-
-func TestDoubleStop(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-	k, cl := setupClient()
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.Report(diag.Messages{})
-	g.Consistently(cl.Actions).Should(BeEmpty())
-	c.Stop()
-	c.Stop()
-}
-
-func TestNoReconcilation(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-	k, cl := setupClient()
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.UpdateResourceStatus(basicmeta.K8SCollection1.Name(), resource.NewFullName("foo", "bar"), "v1", "s1")
-	defer c.Stop()
-
-	g.Consistently(cl.Actions).Should(BeEmpty())
-}
-
-func TestBasicReconcilation_BeforeUpdate(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	s := map[string]interface{}{
-		subfield: "s1",
-	}
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"status": s,
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.UpdateResourceStatus(basicmeta.K8SCollection1.Name(), resource.NewFullName("foo", "bar"), "v1", s)
-	c.Report(diag.Messages{})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-	g.Expect(u.Object["status"]).To(BeNil())
-}
-
-func TestBasicReconcilation_AfterUpdate(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	s := map[string]interface{}{
-		subfield: "s1",
-	}
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"status": s,
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.Report(diag.Messages{})
-	c.UpdateResourceStatus(
-		basicmeta.K8SCollection1.Name(), resource.NewFullName("foo", "bar"), "v1", s)
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-	g.Expect(u.Object["status"]).To(BeNil())
-}
-
-func TestBasicReconcilation_AfterUpdate_Othersubfield(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	otherSubfield := "otherMessages"
-	s := map[string]interface{}{
-		subfield:      "s1",
-		otherSubfield: "s2",
-	}
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"status": s,
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	c.Report(diag.Messages{})
-	c.UpdateResourceStatus(
-		basicmeta.K8SCollection1.Name(), resource.NewFullName("foo", "bar"), "v1", s)
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-
-	g.Expect(u.Object["status"]).To(Not(BeNil()))
-	actualStatusMap := u.Object["status"].(map[string]interface{})
-	g.Expect(actualStatusMap).To(Not(HaveKey(subfield)))
-	g.Expect(actualStatusMap).To(HaveKeyWithValue(otherSubfield, "s2"))
-}
-
-func TestBasicReconcilation_NewStatus(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"metadata": map[string]interface{}{
-				"name":            "foo",
-				"namespace":       "bar",
-				"resourceVersion": "v1",
-			},
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"),
-		},
-	}
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	m := msg.NewInternalError(&e, "foo")
-	c.Report(diag.Messages{m})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-
-	actualStatusMap := u.Object["status"].(map[string]interface{})
-
-	g.Expect(actualStatusMap[subfield]).To(ConsistOf(expectedMessage(m).UnstructuredAnalysisMessageBase()))
-}
-
-func TestBasicReconcilation_NewStatusOldNonMap(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"metadata": map[string]interface{}{
-				"name":            "foo",
-				"namespace":       "bar",
-				"resourceVersion": "v1",
-			},
-			"status": "s1", // Should be overwritten without breaking
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"),
-		},
-	}
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	m := msg.NewInternalError(&e, "foo")
-	c.Report(diag.Messages{m})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-
-	actualStatusMap := u.Object["status"].(map[string]interface{})
-	g.Expect(actualStatusMap[subfield]).To(ConsistOf(expectedMessage(m).UnstructuredAnalysisMessageBase()))
-}
-
-func TestBasicReconcilation_UpdateError(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"metadata": map[string]interface{}{
-				"resourceVersion": "v1",
-			},
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, fmt.Errorf("cheese not found"))
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"),
-		},
-	}
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	m := msg.NewInternalError(&e, "foo")
-	c.Report(diag.Messages{m})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(2))
-	g.Expect(cl.Actions()[1]).To(BeAssignableToTypeOf(k8stesting.UpdateActionImpl{}))
-	u := cl.Actions()[1].(k8stesting.UpdateActionImpl).Object.(*unstructured.Unstructured)
-
-	actualStatusMap := u.Object["status"].(map[string]interface{})
-	g.Expect(actualStatusMap[subfield]).To(ConsistOf(expectedMessage(m).UnstructuredAnalysisMessageBase()))
-}
-
-func TestBasicReconcilation_GetError(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	k, cl := setupClientWithReactors(nil, nil)
-
-	cl.ReactionChain = nil
-	cl.AddReactor("get", "Kind1s", func(action k8stesting.Action) (handled bool, ret runtime.Object, err error) {
-		handled = true
-		err = fmt.Errorf("cheese not found")
-		return
-	})
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"),
-		},
-	}
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	m := msg.NewInternalError(&e, "foo")
-	c.Report(diag.Messages{m})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(1))
-	g.Consistently(cl.Actions).Should(HaveLen(1))
-}
-
-func TestBasicReconcilation_VersionMismatch(t *testing.T) {
-	g := NewWithT(t)
-
-	c := NewController(subfield)
-
-	r := &unstructured.Unstructured{
-		Object: map[string]interface{}{
-			"metadata": map[string]interface{}{
-				"resourceVersion": "v2",
-			},
-		},
-	}
-
-	k, cl := setupClientWithReactors(r, nil)
-
-	e := resource.Instance{
-		Origin: &rt.Origin{
-			Collection: basicmeta.K8SCollection1.Name(),
-			FullName:   resource.NewFullName("foo", "bar"),
-			Version:    resource.Version("v1"), // message for an older version
-		},
-	}
-
-	c.Start(rt.NewProvider(k, metav1.NamespaceAll, 0), basicmeta.MustGet().KubeCollections().All())
-	m := msg.NewInternalError(&e, "foo")
-	c.Report(diag.Messages{m})
-	defer c.Stop()
-
-	g.Eventually(cl.Actions).Should(HaveLen(1))
-	g.Consistently(cl.Actions).Should(HaveLen(1))
-}
-
-func setupClient() (kube.Interfaces, *fake.FakeDynamicClient) {
-	k := kubelib.NewFakeClient()
-	return kube.NewInterfacesFromClient(k), k.Dynamic().(*fake.FakeDynamicClient)
-}
-
-func setupClientWithReactors(retVal runtime.Object, updateErrVal error) (kube.Interfaces, *fake.FakeDynamicClient) {
-	k, cl := setupClient()
-
-	cl.ReactionChain = nil
-	cl.AddReactor("get", "Kind1s", func(action k8stesting.Action) (
-		handled bool, ret runtime.Object, err error) {
-		handled = true
-		ret = retVal
-		return
-	})
-
-	cl.AddReactor("update", "Kind1s", func(action k8stesting.Action) (
-		handled bool, ret runtime.Object, err error) {
-		handled = true
-		err = updateErrVal
-		return
-	})
-
-	return k, cl
-}
-
-func expectedMessage(m diag.Message) *diag.Message {
-	return &diag.Message{
-		Type:       m.Type,
-		Parameters: m.Parameters,
-		Resource:   m.Resource,
-		DocRef:     DocRef,
-	}
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/messages.go b/galley/pkg/config/source/kube/apiserver/status/messages.go
deleted file mode 100644
index 06c219eb52..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/messages.go
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-)
-
-// Messages is a data structure for capturing incoming messages
-type Messages struct {
-	entries map[key]entry
-}
-
-type entry struct {
-	origin   *rt.Origin
-	messages diag.Messages
-}
-
-// NewMessageSet returns a new instance of message set.
-func NewMessageSet() Messages {
-	return Messages{
-		entries: make(map[key]entry),
-	}
-}
-
-// Add a new message for a given origin.
-func (m *Messages) Add(origin *rt.Origin, msg diag.Message) {
-	k := key{col: origin.Collection, res: origin.FullName}
-	e := m.entries[k]
-	e.origin = origin
-	e.messages = append(e.messages, msg)
-	m.entries[k] = e
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/state.go b/galley/pkg/config/source/kube/apiserver/status/state.go
deleted file mode 100644
index ad4eaa4379..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/state.go
+++ /dev/null
@@ -1,233 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"sync"
-
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// use a sentinel value as the last item in a work queue. This allows doing a simple null check on the next to
-// detect whether a status is queued as work or not.
-var sentinel = &status{}
-
-// state is the core internal state of the status controller. It keeps track of lifecycle states, currently known &
-// desired status for resources and a work-queue for the reconciliation loop.
-//
-// The state is changed through 3 access points:
-// - Incoming watch events that allows observing of changes to the status field of resources.
-// - New set of diagnostic messages that need to be applied as state.
-// - Reconciliation worker, popping work items for performing actual status updates.
-//
-// Changes to the desired and/or observed state will cause desired/observed to go out of sync will cause a new work
-// item to be created for the work queue. Initially, observed state changes will be ignored (see reconcile flag) as
-// during Galley boot-up, we don't want to generate superfluous updates to existing status. Once status receives an
-// update with a new set of diagnostic messages (which could be empty), the reconciliation will be enabled.
-//
-// To reduce memory pressure, the state will only keep track of desired/observed status if it is set.
-//
-// The work queue is implemented as a linked-list over the status objects. This reduces memory foot-print and also helps
-// with scheduling work only once when things are updated successively.
-//
-// The worker(s) will get a copy of the needed update from the work queue and try to reconcile. If the reconciliation
-// fails, they will need to explicitly put the entries back into the queue (TBD). If there are no outstanding work items
-// for the reconciliation loop, then it will wait blocked in the dequeueWork call. During tear-down, the controller
-// will call quiesceWork() which will release these workers and let them exit.
-//
-type state struct {
-	mu sync.Mutex
-
-	// indicates that new work is available. This wakes up any sleeping go routines waiting in dequeue.
-	available *sync.Cond
-
-	// Indicates that we should start reconciling changes to the CRD status. We don't want immediate reconciliation:
-	// Galley may not have finished processing all resources while  existing status messages start trickling in.
-	// Wait until the first set of diagnostic messages arrive (which maybe empty) before starting the reconciling of
-	// status fields.
-	reconcile bool
-
-	// quiesce work. Go routine(s) that are blocked on dequeue will wake up and exit.
-	quiesce bool
-
-	// Keeps track of status for each resource. To reduce memory pressure, this will not contain entries for resources
-	// that has both its desired and actual status empty.
-	states map[key]*status
-
-	// linked list implementation for the work queue. We're not using channels intentionally, as channel size is fixed
-	// which can potentially cause unexpected blocking throughout the system.
-	head *status
-	tail *status
-}
-
-func newState() *state {
-	s := &state{
-		states: make(map[key]*status),
-	}
-	s.available = sync.NewCond(&s.mu)
-
-	return s
-}
-
-// set the last observed state of a resource status, based on the watch events. This can trigger creation of new
-// work, if the state is not as expected.
-func (s *state) setObserved(col collection.Name, res resource.FullName, version resource.Version, status interface{}) {
-	s.mu.Lock()
-	k := key{col: col, res: res}
-
-	st := s.states[k]
-
-	if status == nil && st == nil {
-		// The incoming state is empty. We only need to take action if the desired state we have is non-empty.
-		// If the state doesn't exist, it implies that there is no desired state, so we can simply ignore this.
-		s.mu.Unlock()
-		return
-	}
-
-	// There is no known state. get a status from pool and add it to the mapping.
-	if st == nil {
-		st = getStatusFromPool(k)
-		s.states[k] = st
-	}
-
-	// Set the last known status for this resource. If this causes a need for update, then enqueue work for thw workers.
-	if st.setObserved(version, status) {
-		if s.reconcile {
-			s.enqueueWork(st)
-		}
-	} else if st.isEmpty() && !st.isEnqueued() {
-		// The state is empty (and we want it to be empty), and we don't have this status enqueued in the work queue.
-		// We can simply remove it and stop tracking.
-		delete(s.states, k)
-		returnStatusToPool(st)
-	}
-
-	s.mu.Unlock()
-}
-
-// Apply the given set of messages to their target resources.
-func (s *state) applyMessages(messages Messages) {
-	s.mu.Lock()
-	// Start processing if we haven't already started to do so.
-	s.reconcile = true
-
-	// First, iterate through existing states and try to apply the message to that.
-	for k, st := range s.states {
-		e := messages.entries[k]
-
-		if len(e.messages) > 0 {
-			st.setDesired(e.origin.Version, toStatusValue(e.messages))
-			// We applied the state and this caused a need for change. Enqueue work.
-			s.enqueueWork(st)
-		} else {
-			// The desired state for the resource is empty.
-
-			// Ignoring the return value, as the state should always change. Otherwise, the e would have been
-			// removed when it was previously set to nil.
-			_ = st.setDesired("", nil)
-			s.enqueueWork(st)
-		}
-
-		// Delete the processed message.
-		delete(messages.entries, k)
-	}
-
-	// Iterate over messages that didn't have an existing status and create new status & work.
-	for k, e := range messages.entries {
-		if len(e.messages) == 0 {
-			continue
-		}
-
-		st := getStatusFromPool(k)
-		s.states[k] = st
-
-		_ = st.setDesired(e.origin.Version, toStatusValue(e.messages))
-		s.enqueueWork(st)
-	}
-
-	s.mu.Unlock()
-}
-
-func (s *state) enqueueWork(st *status) {
-	// must be called under lock
-
-	if st.next != nil {
-		// this status is already enqueued for work. Nothing to do.
-		return
-	}
-
-	if s.head == nil {
-		s.head = st
-	} else {
-		s.tail.next = st
-	}
-	// use sentinel value to tag work items that are in queue. This way, we can immediately tell if an item is enqueued
-	// for work or not by looking at st.next.
-	st.next = sentinel
-
-	s.tail = st
-
-	s.available.Broadcast()
-}
-
-// dequeue work and return it. If the dequeue was successful, then it returns a copy of the status and true. If
-// the state is asked to quiesce work, it will return false. Otherwise, the call will be blocked until new work arrives.
-func (s *state) dequeueWork() (status, bool) {
-	s.mu.Lock()
-
-	for {
-		if s.quiesce {
-			s.mu.Unlock()
-			return status{}, false
-		}
-
-		if s.head != nil {
-			st := s.head
-			s.head = st.next
-			if s.head == sentinel {
-				s.head = nil
-				s.tail = nil
-			}
-			st.next = nil
-
-			if st.needsChange() {
-				s.mu.Unlock()
-				return *st, true
-			}
-
-			if st.isEmpty() {
-				delete(s.states, st.key)
-				returnStatusToPool(st)
-			}
-			continue
-		}
-
-		s.available.Wait()
-	}
-}
-
-func (s *state) quiesceWork() {
-	s.mu.Lock()
-	s.quiesce = true
-	s.available.Broadcast()
-	s.mu.Unlock()
-}
-
-func (s *state) hasWork() bool {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	return s.head != nil
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/state_test.go b/galley/pkg/config/source/kube/apiserver/status/state_test.go
deleted file mode 100644
index 5f3e072aab..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/state_test.go
+++ /dev/null
@@ -1,291 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"sync"
-	"testing"
-	"time"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/pkg/config/resource"
-)
-
-func TestState_SetLastKnown_NoEntry(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-
-	g.Expect(s.hasWork()).To(BeTrue())
-
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("foo"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN1I1V1.Metadata.Version))
-	g.Expect(st.desiredStatus).To(BeNil())
-	g.Expect(st.desiredStatusVersion).To(Equal(resource.Version("")))
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_SetLastKnown_NoReconciliation(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_SetLastKnown_TwoEntries(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-	s.setObserved(basicmeta.Collection2.Name(), data.EntryN2I2V1.Metadata.FullName, data.EntryN2I2V1.Metadata.Version, "bar")
-
-	g.Expect(s.hasWork()).To(BeTrue())
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("foo"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN1I1V1.Metadata.Version))
-	g.Expect(st.desiredStatus).To(BeNil())
-	g.Expect(st.desiredStatusVersion).To(Equal(resource.Version("")))
-
-	g.Expect(s.hasWork()).To(BeTrue())
-	st, ok = s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.Collection2.Name()))
-	g.Expect(st.key.res).To(Equal(data.EntryN2I2V1.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("bar"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN2I2V1.Metadata.Version))
-	g.Expect(st.desiredStatus).To(BeNil())
-	g.Expect(st.desiredStatusVersion).To(Equal(resource.Version("")))
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_SetLastKnown_ExistingEntry(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V2.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, "bar")
-
-	g.Expect(s.hasWork()).To(BeTrue())
-
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(data.EntryN1I1V2.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("bar"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN1I1V2.Metadata.Version))
-	g.Expect(st.desiredStatus).To(BeNil())
-	g.Expect(st.desiredStatusVersion).To(Equal(resource.Version("")))
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_ClearLastKnown_NoEntry(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-
-	g.Expect(s.hasWork()).To(BeFalse())
-
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V2.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, nil)
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_ClearLastKnown_ExistingEntry(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V2.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, nil)
-
-	// Even though we reverted to the original state before dequeueing, it is still in the queue. Let the dequeueWork()
-	// call deal with this.
-	g.Expect(s.hasWork()).To(BeTrue())
-
-	// Add work for another collection, so that dequeueWork would complete.
-	s.setObserved(basicmeta.Collection2.Name(), data.EntryN1I1V2.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, "zzz")
-
-	// Simulate removal of work.
-	_, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, nil)
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
-
-func TestState_Quiesce_PendingWork(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V2.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, "bar")
-
-	s.quiesceWork()
-
-	_, ok := s.dequeueWork()
-	g.Expect(ok).To(BeFalse())
-}
-
-func TestState_Quiesce_WaitingForWork(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-
-	var ok bool
-	var wg1, wg2 sync.WaitGroup
-	wg1.Add(1)
-	wg2.Add(1)
-	go func() {
-		wg1.Done()
-		_, ok = s.dequeueWork()
-		wg2.Done()
-	}()
-
-	wg1.Wait()
-	time.Sleep(time.Second)
-	s.quiesceWork()
-
-	wg2.Wait()
-	g.Expect(ok).To(BeFalse())
-}
-
-func TestState_ApplyMessages_New(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-
-	res := *data.EntryN1I1V1
-	res.Origin = &rt.Origin{
-		Collection: basicmeta.K8SCollection1.Name(),
-		Kind:       "k1",
-		FullName:   res.Metadata.FullName,
-		Version:    res.Metadata.Version,
-	}
-
-	ms := msg.NewInternalError(&res, "t")
-	msgs := NewMessageSet()
-	msgs.Add(res.Origin.(*rt.Origin), ms)
-	s.applyMessages(msgs)
-
-	g.Expect(s.hasWork()).To(BeTrue())
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(res.Metadata.FullName))
-	g.Expect(st.observedStatus).To(BeNil())
-	g.Expect(st.observedVersion).To(Equal(resource.Version("")))
-	g.Expect(st.desiredStatus).To(Equal(toStatusValue(diag.Messages{ms})))
-	g.Expect(st.desiredStatusVersion).To(Equal(res.Metadata.Version))
-}
-
-func TestState_ApplyMessages_AgainstExistingUnappliedState(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V2.Metadata.Version, "foo")
-
-	_, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-
-	res := *data.EntryN1I1V1
-	res.Origin = &rt.Origin{
-		Collection: basicmeta.K8SCollection1.Name(),
-		Kind:       "k1",
-		FullName:   res.Metadata.FullName,
-		Version:    res.Metadata.Version,
-	}
-
-	ms := msg.NewInternalError(&res, "t")
-
-	msgs := NewMessageSet()
-	msgs.Add(res.Origin.(*rt.Origin), ms)
-	s.applyMessages(msgs)
-
-	g.Expect(s.hasWork()).To(BeTrue())
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(res.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("foo"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN1I1V2.Metadata.Version))
-	g.Expect(st.desiredStatus).To(Equal(toStatusValue(diag.Messages{ms})))
-	g.Expect(st.desiredStatusVersion).To(Equal(res.Metadata.Version))
-}
-
-func TestState_ClearMessages_AgainstAppliedState(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-
-	_, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-
-	s.applyMessages(NewMessageSet())
-
-	g.Expect(s.hasWork()).To(BeTrue())
-	st, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-	g.Expect(st.key.col).To(Equal(basicmeta.K8SCollection1.Name()))
-	g.Expect(st.key.res).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	g.Expect(st.observedStatus).To(Equal("foo"))
-	g.Expect(st.observedVersion).To(Equal(data.EntryN1I1V1.Metadata.Version))
-	g.Expect(st.desiredStatus).To(BeNil())
-	g.Expect(st.desiredStatusVersion).To(Equal(resource.Version("")))
-}
-
-func TestState_ClearMessages_AgainstAppliedEmptyState(t *testing.T) {
-	g := NewWithT(t)
-
-	s := newState()
-	s.applyMessages(NewMessageSet()) // start reconciliation
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, "foo")
-
-	_, ok := s.dequeueWork()
-	g.Expect(ok).To(BeTrue())
-
-	s.setObserved(basicmeta.K8SCollection1.Name(), data.EntryN1I1V1.Metadata.FullName, data.EntryN1I1V1.Metadata.Version, nil)
-
-	s.applyMessages(NewMessageSet())
-
-	g.Expect(s.hasWork()).To(BeFalse())
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/status.go b/galley/pkg/config/source/kube/apiserver/status/status.go
deleted file mode 100644
index 24d276b53a..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/status.go
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"reflect"
-	"sync"
-
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-// Status state for a given resource. This contains both desired and last known status of the resource. It also acts
-// as a linked list node for tracking the work of the reconciliation loop.
-type status struct {
-	key key
-
-	// observedStatus comes from watch events
-	observedStatus  interface{}
-	observedVersion resource.Version
-
-	// desiredStatus comes from internal processing engine. The desiredStatusVersion is used to ensure that the status
-	// will be applied to the right version of the resource.
-	desiredStatus        interface{}
-	desiredStatusVersion resource.Version
-
-	// next implements a singly-linked list for work tracking purposes.
-	next *status
-}
-
-type key struct {
-	col collection.Name
-	res resource.FullName
-}
-
-var statusPool = sync.Pool{
-	New: func() interface{} {
-		return &status{}
-	},
-}
-
-func getStatusFromPool(k key) *status {
-	st := statusPool.Get().(*status)
-	st.key = k
-	return st
-}
-
-func returnStatusToPool(s *status) {
-	s.key = key{}
-	s.observedStatus = nil
-	s.observedVersion = ""
-	s.desiredStatus = nil
-	s.desiredStatusVersion = ""
-}
-
-func (r *status) setObserved(v resource.Version, status interface{}) bool {
-	r.observedVersion = v
-	r.observedStatus = status
-
-	return r.needsChange()
-}
-
-// nolint: unparam
-func (r *status) setDesired(v resource.Version, status interface{}) bool {
-	r.desiredStatus = status
-	r.desiredStatusVersion = v
-
-	return r.needsChange()
-}
-
-func (r *status) isEmpty() bool {
-	return r.desiredStatus == nil && r.observedStatus == nil
-}
-
-func (r *status) isEnqueued() bool {
-	return r.next != nil
-}
-
-func (r *status) needsChange() bool {
-	// Status may be a slice, in which case equality isn't defined, so we use reflect.DeepEqual instead
-	return !reflect.DeepEqual(r.observedStatus, r.desiredStatus)
-}
diff --git a/galley/pkg/config/source/kube/apiserver/status/util.go b/galley/pkg/config/source/kube/apiserver/status/util.go
deleted file mode 100644
index 904e24a929..0000000000
--- a/galley/pkg/config/source/kube/apiserver/status/util.go
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package status
-
-import (
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-)
-
-// DocRef is the doc ref value used by the status controller
-const DocRef = "status-controller"
-
-// toStatusValue converts a set of diag.Messages to a status value.
-func toStatusValue(msgs diag.Messages) interface{} {
-	if len(msgs) == 0 {
-		return nil
-	}
-
-	result := make([]interface{}, 0, len(msgs))
-	for _, m := range msgs {
-		m.DocRef = DocRef
-
-		result = append(result, m.UnstructuredAnalysisMessageBase())
-	}
-
-	return result
-}
diff --git a/galley/pkg/config/source/kube/apiserver/tombstone/recover.go b/galley/pkg/config/source/kube/apiserver/tombstone/recover.go
deleted file mode 100644
index 1c83e535e1..0000000000
--- a/galley/pkg/config/source/kube/apiserver/tombstone/recover.go
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package tombstone
-
-import (
-	"fmt"
-	"reflect"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/stats"
-)
-
-// RecoverResource from a kubernetes tombstone (cache.DeletedFinalStateUnknown). Returns the resource or nil if
-// recovery failed.
-func RecoverResource(obj interface{}) metav1.Object {
-	var tombstone cache.DeletedFinalStateUnknown
-	var ok bool
-	if tombstone, ok = obj.(cache.DeletedFinalStateUnknown); !ok {
-		msg := fmt.Sprintf("error decoding object, invalid type: %v", reflect.TypeOf(obj))
-		scope.Source.Error(msg)
-		stats.RecordEventError(msg)
-		return nil
-	}
-
-	var objectMeta metav1.Object
-	if objectMeta, ok = tombstone.Obj.(metav1.Object); !ok {
-		msg := fmt.Sprintf("error decoding object tombstone, invalid type: %v",
-			reflect.TypeOf(tombstone.Obj))
-		scope.Source.Error(msg)
-		stats.RecordEventError(msg)
-		return nil
-	}
-
-	scope.Source.Infof("Recovered deleted object '%s' from tombstone", objectMeta.GetName())
-	return objectMeta
-}
diff --git a/galley/pkg/config/source/kube/apiserver/tombstone/recover_test.go b/galley/pkg/config/source/kube/apiserver/tombstone/recover_test.go
deleted file mode 100644
index ead43a1eac..0000000000
--- a/galley/pkg/config/source/kube/apiserver/tombstone/recover_test.go
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package tombstone_test
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/tombstone"
-)
-
-func TestRecoverySuccessful(t *testing.T) {
-	g := NewWithT(t)
-	expected := &corev1.Node{
-		ObjectMeta: metav1.ObjectMeta{
-			Name: "mynode",
-		},
-	}
-	obj := tombstone.RecoverResource(cache.DeletedFinalStateUnknown{
-		Obj: expected,
-	})
-	g.Expect(obj).To(Equal(expected))
-}
-
-func TestUnkownTypeShouldFail(t *testing.T) {
-	g := NewWithT(t)
-	obj := tombstone.RecoverResource(&struct{}{})
-	g.Expect(obj).To(BeNil())
-}
-
-func TestUnkownTombstoneObjectShouldFail(t *testing.T) {
-	g := NewWithT(t)
-	obj := tombstone.RecoverResource(cache.DeletedFinalStateUnknown{
-		Obj: &struct{}{},
-	})
-	g.Expect(obj).To(BeNil())
-}
diff --git a/galley/pkg/config/source/kube/apiserver/watcher.go b/galley/pkg/config/source/kube/apiserver/watcher.go
deleted file mode 100644
index 0f5a010d5c..0000000000
--- a/galley/pkg/config/source/kube/apiserver/watcher.go
+++ /dev/null
@@ -1,143 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package apiserver
-
-import (
-	"sync"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/stats"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/status"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/tombstone"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/collection"
-)
-
-type watcher struct {
-	mu sync.Mutex
-
-	adapter   *rt.Adapter
-	schema    collection.Schema
-	statusCtl status.Controller
-
-	handler event.Handler
-
-	done chan struct{}
-}
-
-func newWatcher(r collection.Schema, a *rt.Adapter, s status.Controller) *watcher {
-	return &watcher{
-		schema:    r,
-		adapter:   a,
-		statusCtl: s,
-		handler:   event.SentinelHandler(),
-	}
-}
-
-func (w *watcher) start() {
-	w.mu.Lock()
-	defer w.mu.Unlock()
-	if w.done != nil {
-		panic("watcher.start: already started")
-	}
-
-	scope.Source.Debugf("Starting watcher for %q (%q)", w.schema.Name(), w.schema.Resource().GroupVersionKind())
-
-	informer, err := w.adapter.NewInformer()
-	if err != nil {
-		scope.Source.Errorf("unable to start watcher for %q: %v", w.schema.Resource().GroupVersionKind(), err)
-		// Send a FullSync event, even if the informer is not available. This will ensure that the processing backend
-		// will still work, in absence of CRDs.
-		w.handler.Handle(event.FullSyncFor(w.schema))
-		return
-	}
-
-	informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
-		AddFunc: func(obj interface{}) { w.handleEvent(event.Added, obj) },
-		UpdateFunc: func(old, new interface{}) {
-			if w.adapter.IsEqual(old, new) {
-				// Periodic resync will send update events for all known resources.
-				// Two different versions of the same resource will always have different RVs.
-				return
-			}
-
-			w.handleEvent(event.Updated, new)
-		},
-		DeleteFunc: func(obj interface{}) { w.handleEvent(event.Deleted, obj) },
-	})
-
-	done := make(chan struct{})
-	w.done = done
-
-	// Start CRD shared informer and wait for it to exit.
-	go informer.Run(done)
-	// Send the FullSync event after the cache syncs.
-	if cache.WaitForCacheSync(done, informer.HasSynced) {
-		go w.handler.Handle(event.FullSyncFor(w.schema))
-	}
-}
-
-func (w *watcher) stop() {
-	w.mu.Lock()
-	defer w.mu.Unlock()
-	if w.done != nil {
-		close(w.done)
-		w.done = nil
-	}
-}
-
-func (w *watcher) dispatch(h event.Handler) {
-	w.handler = event.CombineHandlers(w.handler, h)
-}
-
-func (w *watcher) handleEvent(c event.Kind, obj interface{}) {
-	if _, ok := obj.(metav1.Object); !ok {
-		recoveredObject := tombstone.RecoverResource(obj)
-		if recoveredObject == nil {
-			// Tombstone recovery failed.
-			scope.Source.Warnf("Unable to extract object for event: %v", obj)
-			return
-		}
-		obj = recoveredObject
-	}
-
-	object := w.adapter.ExtractObject(obj)
-	res, err := w.adapter.ExtractResource(obj)
-	if err != nil {
-		scope.Source.Warnf("unable to extract resource: %v: %e", obj, err)
-		return
-	}
-
-	r := rt.ToResource(object, w.schema, res, nil, nil)
-
-	if w.statusCtl != nil && !w.adapter.IsBuiltIn() {
-		w.statusCtl.UpdateResourceStatus(
-			w.schema.Name(), r.Metadata.FullName, r.Metadata.Version, w.adapter.GetStatus(obj))
-	}
-
-	e := event.Event{
-		Kind:     c,
-		Source:   w.schema,
-		Resource: r,
-	}
-
-	w.handler.Handle(e)
-
-	stats.RecordEventSuccess()
-}
diff --git a/galley/pkg/config/source/kube/inmemory/kubesource_test.go b/galley/pkg/config/source/kube/inmemory/kubesource_test.go
deleted file mode 100644
index edcba0b073..0000000000
--- a/galley/pkg/config/source/kube/inmemory/kubesource_test.go
+++ /dev/null
@@ -1,413 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
-
-import (
-	"fmt"
-	"testing"
-
-	. "github.com/onsi/gomega"
-	yamlv3 "gopkg.in/yaml.v3"
-
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-	"istio.io/istio/galley/pkg/config/testing/k8smeta"
-	"istio.io/istio/galley/pkg/config/util/kubeyaml"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/resource"
-)
-
-func TestKubeSource_ApplyContent(t *testing.T) {
-	g := NewWithT(t)
-
-	s, acc := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", data.YamlN1I1V1)
-	g.Expect(err).To(BeNil())
-
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"foo": {}}))
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-
-	g.Expect(actual[0].Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-
-	g.Expect(acc.Events()).To(HaveLen(2))
-	g.Expect(acc.Events()[0].Kind).To(Equal(event.FullSync))
-	g.Expect(acc.Events()[1].Kind).To(Equal(event.Added))
-	g.Expect(acc.Events()[1].Resource.Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-}
-
-func TestKubeSource_ApplyContent_BeforeStart(t *testing.T) {
-	g := NewWithT(t)
-
-	s, acc := setupKubeSource()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", data.YamlN1I1V1)
-	g.Expect(err).To(BeNil())
-	s.Start()
-
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"foo": {}}))
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-
-	g.Expect(actual[0].Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-
-	g.Expect(acc.Events()).To(HaveLen(2))
-	g.Expect(acc.Events()[0].Kind).To(Equal(event.Added))
-	g.Expect(acc.Events()[0].Resource.Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	g.Expect(acc.Events()[1].Kind).To(Equal(event.FullSync))
-}
-
-func TestKubeSource_ApplyContent_Unchanged0Add1(t *testing.T) {
-	g := NewWithT(t)
-
-	s, acc := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlN2I2V1))
-	g.Expect(err).To(BeNil())
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(2))
-	g.Expect(actual[0].Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	g.Expect(actual[1].Metadata.FullName).To(Equal(data.EntryN2I2V1.Metadata.FullName))
-
-	err = s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN2I2V2, data.YamlN3I3V1))
-	g.Expect(err).To(BeNil())
-
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"foo": {}}))
-
-	actual = s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(2))
-	g.Expect(actual[0].Metadata.FullName).To(Equal(data.EntryN2I2V2.Metadata.FullName))
-	g.Expect(actual[1].Metadata.FullName).To(Equal(data.EntryN3I3V1.Metadata.FullName))
-
-	events := acc.EventsWithoutOrigins()
-	g.Expect(events).To(HaveLen(6))
-	g.Expect(events[0].Kind).To(Equal(event.FullSync))
-	g.Expect(events[1].Kind).To(Equal(event.Added))
-	fixtures.ExpectEqual(t, events[1].Resource, data.EntryN1I1V1)
-	g.Expect(events[2].Kind).To(Equal(event.Added))
-	fixtures.ExpectEqual(t, events[2].Resource, withVersion(data.EntryN2I2V1, "v2"))
-	g.Expect(events[3].Kind).To(Equal(event.Updated))
-	fixtures.ExpectEqual(t, events[3].Resource, withVersion(data.EntryN2I2V2, "v3"))
-	g.Expect(events[4].Kind).To(Equal(event.Added))
-	fixtures.ExpectEqual(t, events[4].Resource, withVersion(data.EntryN3I3V1, "v4"))
-	g.Expect(events[5].Kind).To(Equal(event.Deleted))
-	g.Expect(events[5].Resource.Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-}
-
-func TestKubeSource_RemoveContent(t *testing.T) {
-	g := NewWithT(t)
-
-	s, acc := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlN2I2V1))
-	g.Expect(err).To(BeNil())
-	err = s.ApplyContent("bar", kubeyaml.JoinString(data.YamlN3I3V1))
-	g.Expect(err).To(BeNil())
-
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"bar": {}, "foo": {}}))
-
-	s.RemoveContent("foo")
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"bar": {}}))
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-
-	events := acc.EventsWithoutOrigins()
-	g.Expect(events).To(HaveLen(6))
-	fixtures.ExpectContainEvents(t, events[0:4],
-		event.FullSyncFor(basicmeta.K8SCollection1),
-		event.AddFor(basicmeta.K8SCollection1, data.EntryN1I1V1),
-		event.AddFor(basicmeta.K8SCollection1, withVersion(data.EntryN2I2V1, "v2")),
-		event.AddFor(basicmeta.K8SCollection1, withVersion(data.EntryN3I3V1, "v3")))
-
-	//  Delete events can appear out of order.
-	g.Expect(events[4].Kind).To(Equal(event.Deleted))
-	g.Expect(events[5].Kind).To(Equal(event.Deleted))
-
-	if events[4].Resource.Metadata.FullName == data.EntryN1I1V1.Metadata.FullName {
-		fixtures.ExpectContainEvents(t, events[4:],
-			event.DeleteForResource(basicmeta.K8SCollection1, data.EntryN1I1V1),
-			event.DeleteForResource(basicmeta.K8SCollection1, withVersion(data.EntryN2I2V1, "v2")))
-	} else {
-		fixtures.ExpectContainEvents(t, events[4:],
-			event.DeleteForResource(basicmeta.K8SCollection1, withVersion(data.EntryN2I2V1, "v2")),
-			event.DeleteForResource(basicmeta.K8SCollection1, data.EntryN1I1V1))
-	}
-}
-
-func TestKubeSource_Clear(t *testing.T) {
-	g := NewWithT(t)
-
-	s, acc := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlN2I2V1))
-	g.Expect(err).To(BeNil())
-
-	s.Clear()
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(0))
-
-	events := acc.EventsWithoutOrigins()
-	g.Expect(events).To(HaveLen(5))
-	g.Expect(events[0].Kind).To(Equal(event.FullSync))
-	g.Expect(events[1].Kind).To(Equal(event.Added))
-	fixtures.ExpectEqual(t, events[1].Resource, data.EntryN1I1V1)
-	g.Expect(events[2].Kind).To(Equal(event.Added))
-	fixtures.ExpectEqual(t, events[2].Resource, withVersion(data.EntryN2I2V1, "v2"))
-
-	g.Expect(events[3].Kind).To(Equal(event.Deleted))
-	g.Expect(events[4].Kind).To(Equal(event.Deleted))
-
-	if events[3].Resource.Metadata.FullName == data.EntryN1I1V1.Metadata.FullName {
-		g.Expect(events[3].Resource.Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-		g.Expect(events[4].Resource.Metadata.FullName).To(Equal(data.EntryN2I2V1.Metadata.FullName))
-	} else {
-		g.Expect(events[3].Resource.Metadata.FullName).To(Equal(data.EntryN2I2V1.Metadata.FullName))
-		g.Expect(events[4].Resource.Metadata.FullName).To(Equal(data.EntryN1I1V1.Metadata.FullName))
-	}
-}
-
-func TestKubeSource_UnparseableSegment(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, "invalidyaml\n", data.YamlN2I2V1))
-	g.Expect(err).To(Not(BeNil()))
-
-	actual := removeEntryOrigins(s.Get(basicmeta.K8SCollection1.Name()).AllSorted())
-	g.Expect(actual).To(HaveLen(2))
-	fixtures.ExpectEqual(t, actual[0], data.EntryN1I1V1)
-	fixtures.ExpectEqual(t, actual[1], withVersion(data.EntryN2I2V1, "v2"))
-}
-
-func TestKubeSource_Unrecognized(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlUnrecognized))
-	g.Expect(err).To(BeNil())
-
-	// Even though we got no error, we still only parsed one resource as the unrecognized one was ignored.
-	actual := removeEntryOrigins(s.Get(basicmeta.K8SCollection1.Name()).AllSorted())
-	g.Expect(actual).To(HaveLen(1))
-	fixtures.ExpectEqual(t, actual[0], data.EntryN1I1V1)
-}
-
-func TestKubeSource_UnparseableResource(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlUnparseableResource))
-	g.Expect(err).To(Not(BeNil()))
-
-	actual := removeEntryOrigins(s.Get(basicmeta.K8SCollection1.Name()).AllSorted())
-	g.Expect(actual).To(HaveLen(1))
-	fixtures.ExpectEqual(t, actual[0], data.EntryN1I1V1)
-}
-
-func TestKubeSource_NonStringKey(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlNonStringKey))
-	g.Expect(err).To(Not(BeNil()))
-
-	actual := removeEntryOrigins(s.Get(basicmeta.K8SCollection1.Name()).AllSorted())
-	g.Expect(actual).To(HaveLen(1))
-	fixtures.ExpectEqual(t, actual[0], data.EntryN1I1V1)
-}
-
-func TestKubeSource_Service(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSourceWithK8sMeta()
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", data.GetService())
-	g.Expect(err).To(BeNil())
-
-	actual := s.Get(k8smeta.K8SCoreV1Services.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-	g.Expect(actual[0].Metadata.FullName).To(Equal(resource.NewFullName("kube-system", "kube-dns")))
-}
-
-func TestSameNameDifferentKind(t *testing.T) {
-	g := NewWithT(t)
-
-	meta := basicmeta.MustGet2().KubeCollections()
-	col1 := meta.MustFind(basicmeta.K8SCollection1.Name().String())
-
-	s := NewKubeSource(meta)
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-	s.Start()
-	defer s.Stop()
-
-	err := s.ApplyContent("foo", kubeyaml.JoinString(data.YamlN1I1V1, data.YamlN1I1V1Kind2))
-	g.Expect(err).To(BeNil())
-
-	events := acc.EventsWithoutOrigins()
-	g.Expect(events).To(HaveLen(4))
-	fixtures.ExpectContainEvents(t, events,
-		event.FullSyncFor(col1),
-		event.FullSyncFor(data.K8SCollection2),
-		event.AddFor(col1, data.EntryN1I1V1),
-		event.AddFor(data.K8SCollection2, withVersion(data.EntryN1I1V1ClusterScoped, "v2")))
-}
-
-func TestKubeSource_DefaultNamespace(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	defaultNs := resource.Namespace("default")
-	s.SetDefaultNamespace(defaultNs)
-
-	err := s.ApplyContent("foo", data.YamlI1V1NoNamespace)
-	g.Expect(err).To(BeNil())
-
-	expectedName := data.EntryI1V1NoNamespace.Metadata.FullName.Name
-
-	actual := s.Get(basicmeta.K8SCollection1.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-	g.Expect(actual[0].Metadata.FullName).To(Equal(resource.NewFullName(defaultNs, expectedName)))
-}
-
-func TestKubeSource_DefaultNamespaceSkipClusterScoped(t *testing.T) {
-	g := NewWithT(t)
-
-	s := NewKubeSource(basicmeta.MustGet2().KubeCollections())
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-	s.Start()
-	defer s.Stop()
-
-	defaultNs := resource.Namespace("default")
-	s.SetDefaultNamespace(defaultNs)
-
-	err := s.ApplyContent("foo", data.YamlI1V1NoNamespaceKind2)
-	g.Expect(err).To(BeNil())
-
-	actual := s.Get(data.K8SCollection2.Name()).AllSorted()
-	g.Expect(actual).To(HaveLen(1))
-	g.Expect(actual[0].Metadata.FullName).To(Equal(data.EntryI1V1NoNamespace.Metadata.FullName))
-}
-
-func TestKubeSource_CanHandleDocumentSeparatorInComments(t *testing.T) {
-	g := NewWithT(t)
-
-	s, _ := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	s.SetDefaultNamespace("default")
-
-	err := s.ApplyContent("foo", data.YamlI1V1WithCommentContainingDocumentSeparator)
-	g.Expect(err).To(BeNil())
-	g.Expect(s.ContentNames()).To(Equal(map[string]struct{}{"foo": {}}))
-}
-
-func setupKubeSource() (*KubeSource, *fixtures.Accumulator) {
-	s := NewKubeSource(basicmeta.MustGet().KubeCollections())
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	return s, acc
-}
-
-func setupKubeSourceWithK8sMeta() (*KubeSource, *fixtures.Accumulator) {
-	s := NewKubeSource(k8smeta.MustGet().KubeCollections())
-
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-
-	s.Start()
-	return s, acc
-}
-
-func withVersion(r *resource.Instance, v string) *resource.Instance {
-	r = r.Clone()
-	r.Metadata.Version = resource.Version(v)
-	return r
-}
-
-func removeEntryOrigins(resources []*resource.Instance) []*resource.Instance {
-	result := make([]*resource.Instance, len(resources))
-	for i, r := range resources {
-		r = r.Clone()
-		r.Origin = nil
-		result[i] = r
-	}
-	return result
-}
-
-func TestBuildFieldPathMap(t *testing.T) {
-	yamlResource := map[string]interface{}{
-		"key":    "value",
-		"array":  []string{"a", "b", "c", "d", "e"},
-		"number": 1,
-		"sliceMap": []map[string]string{
-			{"a": "1"}, {"b": "2"},
-		},
-	}
-
-	g := NewWithT(t)
-
-	yamlMarshal, err := yamlv3.Marshal(&yamlResource)
-	g.Expect(err).To(BeNil())
-
-	result := make(map[string]int)
-
-	yamlNode := yamlv3.Node{}
-
-	err = yamlv3.Unmarshal(yamlMarshal, &yamlNode)
-	g.Expect(err).To(BeNil())
-
-	BuildFieldPathMap(yamlNode.Content[0], 1, "", result)
-
-	g.Expect(fmt.Sprintf("%v", result)).To(Equal("map[{.array[0]}:2 {.array[1]}:3 {.array[2]}:4 " +
-		"{.array[3]}:5 {.array[4]}:6 {.key}:7 {.number}:8 {.sliceMap[0].a}:10 {.sliceMap[1].b}:11]"))
-}
diff --git a/galley/pkg/config/source/kube/interfaces.go b/galley/pkg/config/source/kube/interfaces.go
deleted file mode 100644
index 7cd66a35b3..0000000000
--- a/galley/pkg/config/source/kube/interfaces.go
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package kube
-
-import (
-	"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
-	"k8s.io/client-go/dynamic"
-	"k8s.io/client-go/kubernetes"
-
-	//  import GKE cluster authentication plugin
-	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
-	"k8s.io/client-go/rest"
-	"k8s.io/client-go/tools/clientcmd"
-
-	"istio.io/istio/pkg/kube"
-)
-
-// Interfaces interface allows access to the Kubernetes API Service methods. It is mainly used for
-// test/injection purposes.
-type Interfaces interface {
-	DynamicInterface() (dynamic.Interface, error)
-	APIExtensionsClientset() (clientset.Interface, error)
-	KubeClient() (kubernetes.Interface, error)
-}
-
-type interfaces struct {
-	cfg *rest.Config
-}
-
-var _ Interfaces = &interfaces{}
-
-// NewInterfacesFromConfigFile returns a new instance of Interfaces.
-func NewInterfacesFromConfigFile(kubeconfig string) (Interfaces, error) {
-	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
-	if err != nil {
-		return nil, err
-	}
-
-	return NewInterfaces(config), nil
-}
-
-// NewInterfaces returns a new instance of Interfaces.
-func NewInterfaces(cfg *rest.Config) Interfaces {
-	return &interfaces{
-		cfg: cfg,
-	}
-}
-
-// DynamicInterface returns a new dynamic.Interface for the specified API Group/Version.
-func (k *interfaces) DynamicInterface() (dynamic.Interface, error) {
-	return dynamic.NewForConfig(k.cfg)
-}
-
-// APIExtensionsClientset returns a new apiextensions clientset
-func (k *interfaces) APIExtensionsClientset() (clientset.Interface, error) {
-	return clientset.NewForConfig(k.cfg)
-}
-
-// KubeClient returns a new kubernetes Interface client.
-func (k *interfaces) KubeClient() (kubernetes.Interface, error) {
-	return kubernetes.NewForConfig(k.cfg)
-}
-
-type wrapper struct {
-	kube.Client
-}
-
-func (w wrapper) DynamicInterface() (dynamic.Interface, error) {
-	return w.Dynamic(), nil
-}
-
-func (w wrapper) APIExtensionsClientset() (clientset.Interface, error) {
-	return w.Client.Ext(), nil
-}
-
-func (w wrapper) KubeClient() (kubernetes.Interface, error) {
-	return w.Kube(), nil
-}
-
-var _ Interfaces = &wrapper{}
-
-func NewInterfacesFromClient(client kube.Client) Interfaces {
-	return wrapper{client}
-}
diff --git a/galley/pkg/config/source/kube/interfaces_test.go b/galley/pkg/config/source/kube/interfaces_test.go
deleted file mode 100644
index 53364de848..0000000000
--- a/galley/pkg/config/source/kube/interfaces_test.go
+++ /dev/null
@@ -1,49 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package kube_test
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-	"k8s.io/client-go/rest"
-
-	"istio.io/istio/galley/pkg/config/source/kube"
-)
-
-func TestCreateConfig(t *testing.T) {
-	k := kube.NewInterfaces(&rest.Config{})
-
-	if _, err := k.DynamicInterface(); err != nil {
-		t.Fatalf("Unexpected error: %v", err)
-	}
-	if _, err := k.APIExtensionsClientset(); err != nil {
-		t.Fatalf("Unexpected error: %v", err)
-	}
-	if _, err := k.KubeClient(); err != nil {
-		t.Fatalf("Unexpected error: %v", err)
-	}
-}
-
-func TestNewKubeWithInvalidConfigFileShouldFail(t *testing.T) {
-	g := NewWithT(t)
-	_, err := kube.NewInterfacesFromConfigFile("badconfigfile")
-	g.Expect(err).ToNot(BeNil())
-}
-
-func TestNewKube(t *testing.T) {
-	// Should not panic
-	_ = kube.NewInterfaces(&rest.Config{})
-}
diff --git a/galley/pkg/config/source/kube/rt/adapter.go b/galley/pkg/config/source/kube/rt/adapter.go
deleted file mode 100644
index 23ec553fab..0000000000
--- a/galley/pkg/config/source/kube/rt/adapter.go
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"fmt"
-	"reflect"
-
-	"github.com/gogo/protobuf/proto"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/stats"
-	"istio.io/istio/pkg/config/resource"
-)
-
-// Adapter provides core functions that are necessary to interact with a Kubernetes resource.
-type Adapter struct {
-	extractObject                 extractObjectFn
-	extractResource               extractResourceFn
-	newInformer                   newInformerFn
-	parseJSON                     parseJSONFn
-	getStatus                     getStatusFn
-	isEqual                       isEqualFn
-	isBuiltIn                     bool
-	isDefaultExcluded             bool
-	isRequiredForServiceDiscovery bool
-}
-
-// ExtractObject extracts the k8s object metadata from the given object of this type.
-func (p *Adapter) ExtractObject(o interface{}) metav1.Object {
-	return p.extractObject(o)
-}
-
-// ExtractResource extracts the resource proto from the given object of this type.
-func (p *Adapter) ExtractResource(o interface{}) (proto.Message, error) {
-	return p.extractResource(o)
-}
-
-// NewInformer creates a new k8s informer for resources of this type.
-func (p *Adapter) NewInformer() (cache.SharedInformer, error) {
-	return p.newInformer()
-}
-
-// ParseJSON parses the given JSON into a k8s object of this type.
-func (p *Adapter) ParseJSON(input []byte) (interface{}, error) {
-	return p.parseJSON(input)
-}
-
-// GetStatus returns the status of the resource.
-func (p *Adapter) GetStatus(o interface{}) interface{} {
-	return p.getStatus(o)
-}
-
-// IsEqual checks whether the given two resources are equal
-func (p *Adapter) IsEqual(o1, o2 interface{}) bool {
-	return p.isEqual(o1, o2)
-}
-
-// IsBuiltIn returns true if the adapter uses built-in client libraries.
-func (p *Adapter) IsBuiltIn() bool {
-	return p.isBuiltIn
-}
-
-// IsDefaultExcluded returns true if the adapter is excluded from the default set of resources to watch.
-func (p *Adapter) IsDefaultExcluded() bool {
-	return p.isDefaultExcluded
-}
-
-// IsRequiredForServiceDiscovery returns true if the adapter is required for service discovery.
-func (p *Adapter) IsRequiredForServiceDiscovery() bool {
-	return p.isRequiredForServiceDiscovery
-}
-
-// JSONToEntry parses the K8s Resource in JSON form and converts it to resource entry.
-func (p *Adapter) JSONToEntry(s string) (*resource.Instance, error) {
-	i, err := p.ParseJSON([]byte(s))
-	if err != nil {
-		return nil, err
-	}
-
-	obj := p.ExtractObject(i)
-	item, err := p.ExtractResource(i)
-	if err != nil {
-		return nil, err
-	}
-
-	return ToResource(obj, nil, item, nil, nil), nil
-}
-
-type (
-	extractObjectFn   func(o interface{}) metav1.Object
-	extractResourceFn func(o interface{}) (proto.Message, error)
-	newInformerFn     func() (cache.SharedIndexInformer, error)
-	parseJSONFn       func(input []byte) (interface{}, error)
-	getStatusFn       func(o interface{}) interface{}
-	isEqualFn         func(o1 interface{}, o2 interface{}) bool
-)
-
-// resourceVersionsMatch is a resourceEqualFn that determines equality by the resource version.
-func resourceVersionsMatch(o1 interface{}, o2 interface{}) bool {
-	r1, ok1 := o1.(metav1.Object)
-	r2, ok2 := o2.(metav1.Object)
-	if !ok1 || !ok2 {
-		msg := fmt.Sprintf("error decoding kube objects during update, o1 type: %v, o2 type: %v",
-			reflect.TypeOf(o1),
-			reflect.TypeOf(o2))
-		scope.Source.Error(msg)
-		stats.RecordEventError(msg)
-		return false
-	}
-	return r1.GetResourceVersion() == r2.GetResourceVersion()
-}
diff --git a/galley/pkg/config/source/kube/rt/dynamic.go b/galley/pkg/config/source/kube/rt/dynamic.go
deleted file mode 100644
index 236f6aabf6..0000000000
--- a/galley/pkg/config/source/kube/rt/dynamic.go
+++ /dev/null
@@ -1,112 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"context"
-	"encoding/json"
-	"fmt"
-
-	"github.com/gogo/protobuf/proto"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/watch"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/util/pb"
-	"istio.io/istio/pkg/config/schema/resource"
-	"istio.io/istio/pkg/listwatch"
-)
-
-func (p *Provider) getDynamicAdapter(r resource.Schema) *Adapter {
-	return &Adapter{
-		extractObject: func(o interface{}) metav1.Object {
-			res, ok := o.(*unstructured.Unstructured)
-			if !ok {
-				return nil
-			}
-			return res
-		},
-
-		extractResource: func(o interface{}) (proto.Message, error) {
-			u, ok := o.(*unstructured.Unstructured)
-			if !ok {
-				return nil, fmt.Errorf("extractResource: not unstructured: %v", o)
-			}
-
-			pr := r.MustNewInstance().(proto.Message)
-			if err := pb.UnmarshalData(pr, u.Object["spec"]); err != nil {
-				return nil, err
-			}
-
-			return pr, nil
-		},
-
-		newInformer: func() (cache.SharedIndexInformer, error) {
-			d, err := p.GetDynamicResourceInterface(r)
-			if err != nil {
-				return nil, err
-			}
-
-			mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces, func(namespace string) cache.ListerWatcher {
-				return &cache.ListWatch{
-					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-						return d.List(context.TODO(), options)
-					},
-					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-						options.Watch = true
-						return d.Watch(context.TODO(), options)
-					},
-				}
-			})
-
-			informer := cache.NewSharedIndexInformer(mlw, &unstructured.Unstructured{}, p.resyncPeriod,
-				cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-			return informer, nil
-		},
-
-		parseJSON: func(data []byte) (interface{}, error) {
-			u := &unstructured.Unstructured{}
-			if err := json.Unmarshal(data, u); err != nil {
-				return nil, fmt.Errorf("failed marshaling into unstructured: %v", err)
-			}
-
-			if empty(u) {
-				return nil, nil
-			}
-
-			return u, nil
-		},
-		getStatus: func(o interface{}) interface{} {
-			u, ok := o.(*unstructured.Unstructured)
-			if !ok {
-				return nil
-			}
-			return u.Object["status"]
-		},
-		isEqual:   resourceVersionsMatch,
-		isBuiltIn: false,
-	}
-}
-
-// Check if the parsed resource is empty
-func empty(r *unstructured.Unstructured) bool {
-	if r.Object == nil || len(r.Object) == 0 {
-		return true
-	}
-	return false
-}
diff --git a/galley/pkg/config/source/kube/rt/dynamic_test.go b/galley/pkg/config/source/kube/rt/dynamic_test.go
deleted file mode 100644
index 5575df5885..0000000000
--- a/galley/pkg/config/source/kube/rt/dynamic_test.go
+++ /dev/null
@@ -1,107 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt_test
-
-import (
-	"testing"
-
-	"github.com/gogo/protobuf/proto"
-	"github.com/gogo/protobuf/types"
-	. "github.com/onsi/gomega"
-	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	"k8s.io/apimachinery/pkg/util/yaml"
-
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/pkg/config"
-)
-
-func TestParseDynamic(t *testing.T) {
-	g := NewWithT(t)
-	input, err := yaml.ToJSON([]byte(data.YamlN1I1V1))
-	g.Expect(err).To(BeNil())
-	objMeta, objResource := parseDynamic(t, input, "Kind1")
-
-	// Just validate a couple of things...
-	_, ok := objResource.(*types.Struct)
-	if !ok {
-		t.Fatal("failed casting item to Endpoints")
-	}
-	g.Expect(objMeta.GetNamespace()).To(Equal("n1"))
-	g.Expect(objMeta.GetName()).To(Equal("i1"))
-}
-
-func TestExtractObjectDynamic(t *testing.T) {
-	for _, r := range basicmeta.MustGet().KubeCollections().All() {
-		a := rt.DefaultProvider().GetAdapter(r.Resource())
-
-		t.Run(r.Resource().Kind(), func(t *testing.T) {
-			t.Run("WrongTypeShouldReturnNil", func(t *testing.T) {
-				out := a.ExtractObject(struct{}{})
-				g := NewWithT(t)
-				g.Expect(out).To(BeNil())
-			})
-
-			t.Run("Success", func(t *testing.T) {
-				out := a.ExtractObject(&unstructured.Unstructured{})
-				g := NewWithT(t)
-				g.Expect(out).ToNot(BeNil())
-			})
-		})
-	}
-}
-
-func TestExtractResourceDynamic(t *testing.T) {
-	for _, r := range basicmeta.MustGet().KubeCollections().All() {
-		a := rt.DefaultProvider().GetAdapter(r.Resource())
-
-		t.Run(r.Resource().Kind(), func(t *testing.T) {
-			t.Run("WrongTypeShouldReturnNil", func(t *testing.T) {
-				_, err := a.ExtractResource(struct{}{})
-				g := NewWithT(t)
-				g.Expect(err).NotTo(BeNil())
-			})
-
-			t.Run("Success", func(t *testing.T) {
-				out, err := a.ExtractResource(&unstructured.Unstructured{})
-				g := NewWithT(t)
-				g.Expect(err).To(BeNil())
-				g.Expect(out).ToNot(BeNil())
-			})
-		})
-	}
-}
-
-func parseDynamic(t *testing.T, input []byte, kind string) (metaV1.Object, proto.Message) {
-	t.Helper()
-	g := NewWithT(t)
-
-	pr := rt.DefaultProvider()
-	a := pr.GetAdapter(basicmeta.MustGet().KubeCollections().MustFindByGroupVersionKind(config.GroupVersionKind{
-		Group:   "testdata.istio.io",
-		Version: "v1alpha1",
-		Kind:    kind,
-	}).Resource())
-
-	obj, err := a.ParseJSON(input)
-	g.Expect(err).To(BeNil())
-
-	p, err := a.ExtractResource(obj)
-	g.Expect(err).To(BeNil())
-
-	return a.ExtractObject(obj), p
-}
diff --git a/galley/pkg/config/source/kube/rt/extract.go b/galley/pkg/config/source/kube/rt/extract.go
deleted file mode 100644
index ac9b30c035..0000000000
--- a/galley/pkg/config/source/kube/rt/extract.go
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"github.com/gogo/protobuf/proto"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"istio.io/istio/pkg/config/resource"
-	"istio.io/istio/pkg/config/schema/collection"
-	resource2 "istio.io/istio/pkg/config/schema/resource"
-)
-
-// ToResource converts the given object and proto to a resource.Instance
-func ToResource(object metav1.Object, schema collection.Schema, item proto.Message, source resource.Reference, fieldMap map[string]int) *resource.Instance {
-	var o *Origin
-
-	name := resource.NewFullName(resource.Namespace(object.GetNamespace()), resource.LocalName(object.GetName()))
-	version := resource.Version(object.GetResourceVersion())
-
-	var resourceSchema resource2.Schema
-	if schema != nil {
-		resourceSchema = schema.Resource()
-		o = &Origin{
-			FullName:   name,
-			Collection: schema.Name(),
-			Kind:       schema.Resource().Kind(),
-			Version:    version,
-			Ref:        source,
-			FieldsMap:  fieldMap,
-		}
-	}
-
-	return &resource.Instance{
-		Metadata: resource.Metadata{
-			Schema:      resourceSchema,
-			FullName:    name,
-			Version:     version,
-			Annotations: object.GetAnnotations(),
-			Labels:      object.GetLabels(),
-			CreateTime:  object.GetCreationTimestamp().Time,
-		},
-		Message: item,
-		Origin:  o,
-	}
-}
diff --git a/galley/pkg/config/source/kube/rt/known.go b/galley/pkg/config/source/kube/rt/known.go
deleted file mode 100644
index 6c473b6689..0000000000
--- a/galley/pkg/config/source/kube/rt/known.go
+++ /dev/null
@@ -1,520 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"context"
-	"fmt"
-	"reflect"
-
-	"github.com/gogo/protobuf/proto"
-	webhookv1 "k8s.io/api/admissionregistration/v1"
-	appsv1 "k8s.io/api/apps/v1"
-	v1 "k8s.io/api/core/v1"
-	"k8s.io/api/extensions/v1beta1"
-	crdv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/serializer"
-	"k8s.io/apimachinery/pkg/watch"
-	"k8s.io/client-go/tools/cache"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/stats"
-	"istio.io/istio/pkg/listwatch"
-)
-
-func (p *Provider) initKnownAdapters() {
-	runtimeScheme := runtime.NewScheme()
-	codecs := serializer.NewCodecFactory(runtimeScheme)
-	deserializer := codecs.UniversalDeserializer()
-
-	p.known = map[string]*Adapter{
-		asTypesKey("", "Service"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.Service); ok {
-					return &obj.Spec, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Service: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.CoreV1().Services(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.CoreV1().Services(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1.Service{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Service{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus:                     noStatus,
-			isEqual:                       resourceVersionsMatch,
-			isBuiltIn:                     true,
-			isDefaultExcluded:             true,
-			isRequiredForServiceDiscovery: true,
-		},
-
-		asTypesKey("", "Namespace"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.Namespace); ok {
-					return &obj.Spec, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Namespace: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				informer, err := p.sharedInformerFactory()
-				if err != nil {
-					return nil, err
-				}
-
-				return informer.Core().V1().Namespaces().Informer(), nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Namespace{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus:                     noStatus,
-			isEqual:                       resourceVersionsMatch,
-			isBuiltIn:                     true,
-			isDefaultExcluded:             true,
-			isRequiredForServiceDiscovery: true,
-		},
-
-		asTypesKey("", "Node"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.Node); ok {
-					return &obj.Spec, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Node: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				informer, err := p.sharedInformerFactory()
-				if err != nil {
-					return nil, err
-				}
-
-				return informer.Core().V1().Nodes().Informer(), nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Node{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus:                     noStatus,
-			isEqual:                       resourceVersionsMatch,
-			isBuiltIn:                     true,
-			isDefaultExcluded:             true,
-			isRequiredForServiceDiscovery: true,
-		},
-
-		asTypesKey("", "Pod"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.Pod); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Pod: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.CoreV1().Pods(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.CoreV1().Pods(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1.Pod{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Pod{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus:                     noStatus,
-			isEqual:                       resourceVersionsMatch,
-			isBuiltIn:                     true,
-			isDefaultExcluded:             true,
-			isRequiredForServiceDiscovery: true,
-		},
-
-		asTypesKey("", "Secret"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.Secret); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Secret: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.CoreV1().Secrets(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.CoreV1().Secrets(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1.Secret{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Secret{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-
-		asTypesKey("", "Endpoints"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				// TODO(nmittler): This copies ObjectMeta since Endpoints have no spec.
-				if obj, ok := o.(*v1.Endpoints); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Endpoints: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.CoreV1().Endpoints(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.CoreV1().Endpoints(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1.Endpoints{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.Endpoints{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			isEqual: func(o1 interface{}, o2 interface{}) bool {
-				r1, ok1 := o1.(*v1.Endpoints)
-				r2, ok2 := o2.(*v1.Endpoints)
-				if !ok1 || !ok2 {
-					msg := fmt.Sprintf("error decoding kube endpoints during update, o1 type: %T, o2 type: %T",
-						o1, o2)
-					scope.Source.Error(msg)
-					stats.RecordEventError(msg)
-					return false
-				}
-				// Endpoint updates can be noisy. Make sure that the subsets have actually changed.
-				return reflect.DeepEqual(r1.Subsets, r2.Subsets)
-			},
-			getStatus:                     noStatus,
-			isBuiltIn:                     true,
-			isDefaultExcluded:             true,
-			isRequiredForServiceDiscovery: true,
-		},
-		asTypesKey("extensions", "Ingress"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1beta1.Ingress); ok {
-					return &obj.Spec, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1beta1.Ingress: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.ExtensionsV1beta1().Ingresses(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.ExtensionsV1beta1().Ingresses(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1beta1.Ingress{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1beta1.Ingress{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-		asTypesKey("apiextensions.k8s.io", "CustomResourceDefinition"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*crdv1.CustomResourceDefinition); ok {
-					return &obj.Spec, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1beta1.Ingress: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				ext, err := p.interfaces.APIExtensionsClientset()
-				if err != nil {
-					return nil, err
-				}
-				inf := cache.NewSharedIndexInformer(
-					&cache.ListWatch{
-						ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-							return ext.ApiextensionsV1().CustomResourceDefinitions().List(context.TODO(), options)
-						},
-						WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-							return ext.ApiextensionsV1().CustomResourceDefinitions().Watch(context.TODO(), options)
-						},
-					},
-					&crdv1.CustomResourceDefinition{},
-					0,
-					cache.Indexers{})
-
-				return inf, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &crdv1.CustomResourceDefinition{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-		asTypesKey("admissionregistration.k8s.io", "MutatingWebhookConfiguration"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*webhookv1.MutatingWebhookConfiguration); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to webhookv1.MutatingWebhookConfiguration: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				ext, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-				inf := cache.NewSharedIndexInformer(
-					&cache.ListWatch{
-						ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
-							return ext.AdmissionregistrationV1().MutatingWebhookConfigurations().List(context.TODO(), options)
-						},
-						WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
-							return ext.AdmissionregistrationV1().MutatingWebhookConfigurations().Watch(context.TODO(), options)
-						},
-					},
-					&crdv1.CustomResourceDefinition{},
-					0,
-					cache.Indexers{})
-
-				return inf, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &webhookv1.MutatingWebhookConfiguration{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-
-		asTypesKey("apps", "Deployment"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*appsv1.Deployment); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.Deployment: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.AppsV1().Deployments(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.AppsV1().Deployments(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &appsv1.Deployment{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &appsv1.Deployment{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-
-		asTypesKey("", "ConfigMap"): {
-			extractObject: defaultExtractObject,
-			extractResource: func(o interface{}) (proto.Message, error) {
-				if obj, ok := o.(*v1.ConfigMap); ok {
-					return obj, nil
-				}
-				return nil, fmt.Errorf("unable to convert to v1.ConfigMap: %T", o)
-			},
-			newInformer: func() (cache.SharedIndexInformer, error) {
-				client, err := p.interfaces.KubeClient()
-				if err != nil {
-					return nil, err
-				}
-
-				mlw := listwatch.MultiNamespaceListerWatcher(p.namespaces,
-					func(namespace string) cache.ListerWatcher {
-						return &cache.ListWatch{
-							ListFunc: func(opts metav1.ListOptions) (runtime.Object, error) {
-								return client.CoreV1().ConfigMaps(namespace).List(context.TODO(), opts)
-							},
-							WatchFunc: func(opts metav1.ListOptions) (watch.Interface, error) {
-								return client.CoreV1().ConfigMaps(namespace).Watch(context.TODO(), opts)
-							},
-						}
-					})
-
-				informer := cache.NewSharedIndexInformer(mlw, &v1.ConfigMap{}, p.resyncPeriod,
-					cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
-
-				return informer, nil
-			},
-			parseJSON: func(input []byte) (interface{}, error) {
-				out := &v1.ConfigMap{}
-				if _, _, err := deserializer.Decode(input, nil, out); err != nil {
-					return nil, err
-				}
-				return out, nil
-			},
-			getStatus: noStatus,
-			isEqual:   resourceVersionsMatch,
-			isBuiltIn: true,
-		},
-	}
-}
-
-func asTypesKey(group, kind string) string {
-	if group == "" {
-		return kind
-	}
-	return fmt.Sprintf("%s/%s", group, kind)
-}
-
-func defaultExtractObject(o interface{}) metav1.Object {
-	if obj, ok := o.(metav1.Object); ok {
-		return obj
-	}
-	return nil
-}
-
-func noStatus(_ interface{}) interface{} {
-	return nil
-}
diff --git a/galley/pkg/config/source/kube/rt/known_test.go b/galley/pkg/config/source/kube/rt/known_test.go
deleted file mode 100644
index d16d1f2125..0000000000
--- a/galley/pkg/config/source/kube/rt/known_test.go
+++ /dev/null
@@ -1,213 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt_test
-
-import (
-	"fmt"
-	"testing"
-
-	"github.com/gogo/protobuf/proto"
-	. "github.com/onsi/gomega"
-	appsV1 "k8s.io/api/apps/v1"
-	coreV1 "k8s.io/api/core/v1"
-	"k8s.io/api/extensions/v1beta1"
-	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/k8smeta"
-	"istio.io/istio/pkg/config"
-)
-
-func TestParse(t *testing.T) {
-	t.Run("Endpoints", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetEndpoints()
-
-		objMeta, objResource := parse(t, []byte(input), "", "Endpoints", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*coreV1.Endpoints)
-		if !ok {
-			t.Fatal("failed casting item to Endpoints")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("kube-dns"))
-	})
-
-	t.Run("Namespace", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetNamespace()
-
-		objMeta, objResource := parse(t, []byte(input), "", "Namespace", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*coreV1.NamespaceSpec)
-		if !ok {
-			t.Fatal("failed casting item to Namespace")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("somens"))
-	})
-
-	t.Run("Ingress", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetIngress()
-
-		objMeta, objResource := parse(t, []byte(input), "extensions", "Ingress", "v1beta1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*v1beta1.IngressSpec)
-		if !ok {
-			t.Fatal("failed casting item to IngressSpec")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("secured-ingress"))
-	})
-
-	t.Run("Node", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetNode()
-
-		objMeta, objResource := parse(t, []byte(input), "", "Node", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*coreV1.NodeSpec)
-		if !ok {
-			t.Fatal("failed casting item to NodeSpec")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("gke-istio-test-default-pool-866a0405-420r"))
-	})
-
-	t.Run("Pod", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetPod()
-
-		objMeta, objResource := parse(t, []byte(input), "", "Pod", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*coreV1.Pod)
-		if !ok {
-			t.Fatal("failed casting item to Pod")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("kube-dns-548976df6c-d9kkv"))
-	})
-
-	t.Run("Service", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetService()
-
-		objMeta, objResource := parse(t, []byte(input), "", "Service", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*coreV1.ServiceSpec)
-		if !ok {
-			t.Fatal("failed casting item to ServiceSpec")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("kube-dns"))
-	})
-
-	t.Run("Deployment", func(t *testing.T) {
-		g := NewWithT(t)
-		input := data.GetDeployment()
-
-		objMeta, objResource := parse(t, []byte(input), "apps", "Deployment", "v1")
-
-		// Just validate a couple of things...
-		_, ok := objResource.(*appsV1.Deployment)
-		if !ok {
-			t.Fatal("failed casting item to Deployment")
-		}
-		g.Expect(objMeta.GetName()).To(Equal("httpbin"))
-	})
-}
-
-func TestExtractObject(t *testing.T) {
-	for _, r := range k8smeta.MustGet().KubeCollections().All() {
-		a := rt.DefaultProvider().GetAdapter(r.Resource())
-
-		t.Run(r.Resource().Kind(), func(t *testing.T) {
-			t.Run("WrongTypeShouldReturnNil", func(t *testing.T) {
-				out := a.ExtractObject(struct{}{})
-				g := NewWithT(t)
-				g.Expect(out).To(BeNil())
-			})
-
-			t.Run("Success", func(t *testing.T) {
-				out := a.ExtractObject(empty(r.Resource().Kind()))
-				g := NewWithT(t)
-				g.Expect(out).ToNot(BeNil())
-			})
-		})
-	}
-}
-
-func TestExtractResource(t *testing.T) {
-	for _, r := range k8smeta.MustGet().KubeCollections().All() {
-		a := rt.DefaultProvider().GetAdapter(r.Resource())
-
-		t.Run(r.Resource().Kind(), func(t *testing.T) {
-			t.Run("WrongTypeShouldReturnNil", func(t *testing.T) {
-				_, err := a.ExtractResource(struct{}{})
-				g := NewWithT(t)
-				g.Expect(err).NotTo(BeNil())
-			})
-
-			t.Run("Success", func(t *testing.T) {
-				out, err := a.ExtractResource(empty(r.Resource().Kind()))
-				g := NewWithT(t)
-				g.Expect(err).To(BeNil())
-				g.Expect(out).ToNot(BeNil())
-			})
-		})
-	}
-}
-
-func parse(t *testing.T, input []byte, group, kind, version string) (metaV1.Object, proto.Message) {
-	t.Helper()
-	g := NewWithT(t)
-
-	pr := rt.DefaultProvider()
-	a := pr.GetAdapter(k8smeta.MustGet().KubeCollections().MustFindByGroupVersionKind(config.GroupVersionKind{
-		Group:   group,
-		Version: version,
-		Kind:    kind,
-	}).Resource())
-	obj, err := a.ParseJSON(input)
-	g.Expect(err).To(BeNil())
-
-	p, err := a.ExtractResource(obj)
-	g.Expect(err).To(BeNil())
-
-	return a.ExtractObject(obj), p
-}
-
-func empty(kind string) metaV1.Object {
-	switch kind {
-	case "Node":
-		return &coreV1.Node{}
-	case "Service":
-		return &coreV1.Service{}
-	case "Pod":
-		return &coreV1.Pod{}
-	case "Endpoints":
-		return &coreV1.Endpoints{}
-	case "Namespace":
-		return &coreV1.Namespace{}
-	case "Ingress":
-		return &v1beta1.Ingress{}
-	case "Deployment":
-		return &appsV1.Deployment{}
-	default:
-		panic(fmt.Sprintf("unsupported kind: %v", kind))
-	}
-}
diff --git a/galley/pkg/config/source/kube/rt/origin_test.go b/galley/pkg/config/source/kube/rt/origin_test.go
deleted file mode 100644
index d502295853..0000000000
--- a/galley/pkg/config/source/kube/rt/origin_test.go
+++ /dev/null
@@ -1,64 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"fmt"
-	"testing"
-
-	. "github.com/onsi/gomega"
-)
-
-func TestPositionString(t *testing.T) {
-	testcases := []struct {
-		filename string
-		line     int
-		output   string
-	}{
-		{
-			filename: "test.yaml",
-			line:     1,
-			output:   "test.yaml:1",
-		},
-		{
-			filename: "test.yaml",
-			line:     0,
-			output:   "test.yaml",
-		},
-		{
-			filename: "test.json",
-			line:     1,
-			output:   "test.json",
-		},
-		{
-			filename: "-",
-			line:     1,
-			output:   "-:1",
-		},
-		{
-			filename: "",
-			line:     1,
-			output:   "",
-		},
-	}
-	for i, tc := range testcases {
-		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
-			g := NewWithT(t)
-
-			p := Position{Filename: tc.filename, Line: tc.line}
-			g.Expect(p.String()).To(Equal(tc.output))
-		})
-	}
-}
diff --git a/galley/pkg/config/source/kube/rt/provider.go b/galley/pkg/config/source/kube/rt/provider.go
deleted file mode 100644
index 82bc74dcdf..0000000000
--- a/galley/pkg/config/source/kube/rt/provider.go
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
-
-import (
-	"errors"
-	"strings"
-	"sync"
-	"time"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	kubeSchema "k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/client-go/dynamic"
-	"k8s.io/client-go/informers"
-
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/pkg/config/schema/resource"
-)
-
-var defaultProvider = NewProvider(nil, metav1.NamespaceAll, 0)
-
-// DefaultProvider returns a default provider that has no K8s connectivity enabled.
-func DefaultProvider() *Provider {
-	return defaultProvider
-}
-
-// Provider for adapters. It closes over K8s connection-related infrastructure.
-type Provider struct {
-	mu sync.Mutex
-
-	resyncPeriod time.Duration
-	interfaces   kube.Interfaces
-	namespaces   []string
-	known        map[string]*Adapter
-
-	informers        informers.SharedInformerFactory
-	dynamicInterface dynamic.Interface
-}
-
-// NewProvider returns a new instance of Provider.
-func NewProvider(interfaces kube.Interfaces, namespaces string, resyncPeriod time.Duration) *Provider {
-	p := &Provider{
-		resyncPeriod: resyncPeriod,
-		interfaces:   interfaces,
-		namespaces:   strings.Split(namespaces, ","),
-	}
-
-	p.initKnownAdapters()
-
-	return p
-}
-
-// GetAdapter returns a type for the group/kind. If the type is a well-known type, then the returned type will have
-// a specialized implementation. Otherwise, it will be using the dynamic conversion logic.
-func (p *Provider) GetAdapter(r resource.Schema) *Adapter {
-	if t, found := p.known[asTypesKey(r.Group(), r.Kind())]; found {
-		return t
-	}
-
-	return p.getDynamicAdapter(r)
-}
-
-func (p *Provider) sharedInformerFactory() (informers.SharedInformerFactory, error) {
-	p.mu.Lock()
-	defer p.mu.Unlock()
-
-	if p.informers == nil {
-		if p.interfaces == nil {
-			return nil, errors.New("client interfaces was not initialized")
-		}
-		cl, err := p.interfaces.KubeClient()
-		if err != nil {
-			return nil, err
-		}
-		p.informers = informers.NewSharedInformerFactory(cl, p.resyncPeriod)
-	}
-
-	return p.informers, nil
-}
-
-// GetDynamicResourceInterface returns a dynamic.NamespaceableResourceInterface for the given resource.
-func (p *Provider) GetDynamicResourceInterface(r resource.Schema) (dynamic.NamespaceableResourceInterface, error) {
-	p.mu.Lock()
-	defer p.mu.Unlock()
-
-	if p.dynamicInterface == nil {
-		if p.interfaces == nil {
-			return nil, errors.New("client interfaces was not initialized")
-		}
-		d, err := p.interfaces.DynamicInterface()
-		if err != nil {
-			return nil, err
-		}
-		p.dynamicInterface = d
-	}
-
-	return p.dynamicInterface.Resource(kubeSchema.GroupVersionResource{
-		Group:    r.Group(),
-		Version:  r.Version(),
-		Resource: r.Plural(),
-	}), nil
-}
diff --git a/galley/pkg/config/source/mcp/origin.go b/galley/pkg/config/source/mcp/origin.go
deleted file mode 100644
index 63e8b4e7ec..0000000000
--- a/galley/pkg/config/source/mcp/origin.go
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mcp
-
-import (
-	"istio.io/istio/pkg/config/resource"
-)
-
-const (
-	defaultOrigin    = origin("mcp")
-	defaultReference = reference("mcp")
-)
-
-var (
-	_ resource.Origin    = defaultOrigin
-	_ resource.Reference = defaultReference
-)
-
-type origin string
-
-func (o origin) FriendlyName() string {
-	return string(o)
-}
-
-func (o origin) Comparator() string {
-	return o.FriendlyName()
-}
-
-func (o origin) Namespace() resource.Namespace {
-	return ""
-}
-
-func (o origin) Reference() resource.Reference {
-	return defaultReference
-}
-
-func (o origin) FieldMap() map[string]int {
-	return make(map[string]int)
-}
-
-type reference string
-
-func (r reference) String() string {
-	return string(r)
-}
diff --git a/galley/pkg/config/source/mcp/origin_test.go b/galley/pkg/config/source/mcp/origin_test.go
deleted file mode 100644
index 70c9554e85..0000000000
--- a/galley/pkg/config/source/mcp/origin_test.go
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mcp
-
-import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/pkg/config/resource"
-)
-
-func TestOrigin(t *testing.T) {
-	g := NewWithT(t)
-
-	o := resource.Origin(origin("hello"))
-	g.Expect(o.Namespace()).Should(Equal(resource.Namespace("")))
-	g.Expect(o.FriendlyName()).Should(Equal("hello"))
-}
diff --git a/galley/pkg/config/util/pb/proto.go b/galley/pkg/config/util/pb/proto.go
deleted file mode 100644
index 827dd8ddf0..0000000000
--- a/galley/pkg/config/util/pb/proto.go
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package pb
-
-import (
-	"strings"
-
-	"github.com/gogo/protobuf/jsonpb"
-	"github.com/gogo/protobuf/proto"
-	yaml2 "gopkg.in/yaml.v2"
-	"sigs.k8s.io/yaml"
-)
-
-// UnmarshalData data into the proto.
-func UnmarshalData(pb proto.Message, data interface{}) error {
-	js, err := toJSON(data)
-	if err == nil {
-		u := jsonpb.Unmarshaler{AllowUnknownFields: true}
-		err = u.Unmarshal(strings.NewReader(js), pb)
-	}
-	return err
-}
-
-func toJSON(data interface{}) (string, error) {
-	var result string
-	b, err := yaml2.Marshal(data)
-	if err == nil {
-		if b, err = yaml.YAMLToJSON(b); err == nil {
-			result = string(b)
-		}
-	}
-
-	return result, err
-}
diff --git a/galley/pkg/config/util/pb/proto_test.go b/galley/pkg/config/util/pb/proto_test.go
deleted file mode 100644
index bb4cce2f22..0000000000
--- a/galley/pkg/config/util/pb/proto_test.go
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package pb
-
-import (
-	"testing"
-
-	gogoTypes "github.com/gogo/protobuf/types"
-	. "github.com/onsi/gomega"
-)
-
-func TestToProto_Success(t *testing.T) {
-	g := NewWithT(t)
-
-	data := map[string]interface{}{
-		"foo": "bar",
-		"boo": "baz",
-	}
-
-	p := &gogoTypes.Struct{}
-	err := UnmarshalData(p, data)
-	g.Expect(err).To(BeNil())
-	expected := &gogoTypes.Struct{
-		Fields: map[string]*gogoTypes.Value{
-			"foo": {
-				Kind: &gogoTypes.Value_StringValue{StringValue: "bar"},
-			},
-			"boo": {
-				Kind: &gogoTypes.Value_StringValue{StringValue: "baz"},
-			},
-		},
-	}
-
-	g.Expect(p).To(Equal(expected))
-}
-
-func TestToProto_UnknownFields(t *testing.T) {
-	g := NewWithT(t)
-
-	data := map[string]interface{}{
-		"foo": "bar",
-		"boo": "baz",
-	}
-
-	p := &gogoTypes.Empty{}
-	err := UnmarshalData(p, data)
-	g.Expect(err).To(BeNil())
-	expected := &gogoTypes.Empty{}
-
-	g.Expect(p).To(Equal(expected))
-}
-
-func TestToProto_Error(t *testing.T) {
-	g := NewWithT(t)
-
-	data := map[string]interface{}{
-		"value": 23,
-	}
-
-	p := &gogoTypes.Any{}
-	err := UnmarshalData(p, data)
-	g.Expect(err).NotTo(BeNil())
-}
diff --git a/galley/pkg/server/components/patchtable.go b/galley/pkg/server/components/patchtable.go
deleted file mode 100644
index 6603e2c1cb..0000000000
--- a/galley/pkg/server/components/patchtable.go
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package components
-
-import (
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/processor"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/pkg/config/event"
-)
-
-// The patch table for external dependencies for code in components.
-var (
-	newInterfaces = kube.NewInterfacesFromConfigFile
-
-	meshcfgNewFS        = func(path string) (event.Source, error) { return mesh.NewMeshConfigFS(path) }
-	processorInitialize = processor.Initialize
-)
-
-func resetPatchTable() {
-	newInterfaces = kube.NewInterfacesFromConfigFile
-
-	meshcfgNewFS = func(path string) (event.Source, error) { return mesh.NewMeshConfigFS(path) }
-	processorInitialize = processor.Initialize
-}
diff --git a/galley/pkg/server/components/processing.go b/galley/pkg/server/components/processing.go
deleted file mode 100644
index 54c3e2fc67..0000000000
--- a/galley/pkg/server/components/processing.go
+++ /dev/null
@@ -1,167 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package components
-
-import (
-	"istio.io/istio/galley/pkg/config/analysis/analyzers"
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/processor"
-	"istio.io/istio/galley/pkg/config/processor/groups"
-	"istio.io/istio/galley/pkg/config/processor/transforms"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver/status"
-	"istio.io/istio/galley/pkg/config/util/kuberesource"
-	"istio.io/istio/galley/pkg/server/settings"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/mcp/snapshot"
-)
-
-// Processing component is the main config processing component that will listen to a config source and publish
-// resources through an MCP server, or a dialout connection.
-type Processing struct {
-	args *settings.Args
-
-	mcpCache *snapshot.Cache
-
-	k kube.Interfaces
-
-	runtime *processing.Runtime
-	stopCh  chan struct{}
-}
-
-// NewProcessing returns a new processing component.
-func NewProcessing(a *settings.Args) *Processing {
-	mcpCache := snapshot.New(groups.IndexFunction)
-	return &Processing{
-		args:     a,
-		mcpCache: mcpCache,
-	}
-}
-
-// Start implements process.Component
-func (p *Processing) Start() (err error) {
-	var mesh event.Source
-	var src event.Source
-	var updater snapshotter.StatusUpdater
-
-	if p.args.MeshSource != nil {
-		mesh = p.args.MeshSource
-	} else {
-		mesh, err = meshcfgNewFS(p.args.MeshConfigFile)
-		if err != nil {
-			return
-		}
-	}
-
-	m := schema.MustGet()
-
-	transformProviders := transforms.Providers(m)
-
-	// Disable any unnecessary resources, including resources not in configured snapshots
-	var colsInSnapshots collection.Names
-	for _, c := range m.AllCollectionsInSnapshots(p.args.Snapshots) {
-		colsInSnapshots = append(colsInSnapshots, collection.NewName(c))
-	}
-	kubeResources := kuberesource.DisableExcludedCollections(m.KubeCollections(), transformProviders,
-		colsInSnapshots, p.args.ExcludedResourceKinds, p.args.EnableServiceDiscovery)
-
-	if src, updater, err = p.createSourceAndStatusUpdater(kubeResources); err != nil {
-		return
-	}
-
-	var distributor snapshotter.Distributor = snapshotter.NewMCPDistributor(p.mcpCache)
-
-	if p.args.EnableConfigAnalysis {
-		combinedAnalyzer := analyzers.AllCombined()
-		combinedAnalyzer.RemoveSkipped(colsInSnapshots, kubeResources.DisabledCollectionNames(), transformProviders)
-
-		distributor = snapshotter.NewAnalyzingDistributor(snapshotter.AnalyzingDistributorSettings{
-			StatusUpdater:     updater,
-			Analyzer:          combinedAnalyzer,
-			Distributor:       distributor,
-			AnalysisSnapshots: p.args.Snapshots,
-			TriggerSnapshot:   p.args.TriggerSnapshot,
-		})
-	}
-
-	processorSettings := processor.Settings{
-		Metadata:           m,
-		DomainSuffix:       p.args.DomainSuffix,
-		Source:             event.CombineSources(mesh, src),
-		TransformProviders: transformProviders,
-		Distributor:        distributor,
-		EnabledSnapshots:   p.args.Snapshots,
-	}
-	if p.runtime, err = processorInitialize(processorSettings); err != nil {
-		return
-	}
-
-	p.stopCh = make(chan struct{})
-
-	p.runtime.Start()
-
-	return nil
-}
-
-func (p *Processing) getKubeInterfaces() (k kube.Interfaces, err error) {
-	if p.k == nil {
-		p.k, err = newInterfaces(p.args.KubeConfig)
-	}
-	k = p.k
-	return
-}
-
-func (p *Processing) createSourceAndStatusUpdater(schemas collection.Schemas) (
-	src event.Source, updater snapshotter.StatusUpdater, err error) {
-	var k kube.Interfaces
-	if k, err = p.getKubeInterfaces(); err != nil {
-		return
-	}
-
-	var statusCtl status.Controller
-	if p.args.EnableConfigAnalysis {
-		statusCtl = status.NewController("validationMessages")
-	}
-
-	o := apiserver.Options{
-		Client:            k,
-		WatchedNamespaces: p.args.WatchedNamespaces,
-		ResyncPeriod:      p.args.ResyncPeriod,
-		Schemas:           schemas,
-		StatusController:  statusCtl,
-	}
-	s := apiserver.New(o)
-	src = s
-	updater = s
-
-	return
-}
-
-// Stop implements process.Component
-func (p *Processing) Stop() {
-	if p.stopCh != nil {
-		close(p.stopCh)
-		p.stopCh = nil
-	}
-
-	if p.runtime != nil {
-		p.runtime.Stop()
-		p.runtime = nil
-	}
-}
diff --git a/galley/pkg/server/components/processing_test.go b/galley/pkg/server/components/processing_test.go
deleted file mode 100644
index 88a54999f6..0000000000
--- a/galley/pkg/server/components/processing_test.go
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package components
-
-import (
-	"fmt"
-	"os"
-	"path"
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/processor"
-	"istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/server/settings"
-	"istio.io/istio/pkg/config/event"
-	kubelib "istio.io/istio/pkg/kube"
-)
-
-func TestProcessing_StartErrors(t *testing.T) {
-	g := NewWithT(t)
-	defer resetPatchTable()
-
-loop:
-	for i := 0; ; i++ {
-		resetPatchTable()
-		newInterfaces = func(string) (kube.Interfaces, error) {
-			return kube.NewInterfacesFromClient(kubelib.NewFakeClient()), nil
-		}
-
-		e := fmt.Errorf("err%d", i)
-
-		tmpDir, err := os.MkdirTemp(os.TempDir(), t.Name())
-		g.Expect(err).To(BeNil())
-
-		meshCfgDir := path.Join(tmpDir, "meshcfg")
-		err = os.Mkdir(meshCfgDir, os.ModePerm)
-		g.Expect(err).To(BeNil())
-
-		meshCfgFile := path.Join(tmpDir, "meshcfg.yaml")
-		_, err = os.Create(meshCfgFile)
-		g.Expect(err).To(BeNil())
-
-		args := settings.DefaultArgs()
-		args.MeshConfigFile = meshCfgFile
-
-		switch i {
-		case 0:
-			newInterfaces = func(string) (kube.Interfaces, error) {
-				return nil, e
-			}
-		case 1:
-			meshcfgNewFS = func(path string) (event.Source, error) { return nil, e }
-		case 2:
-			processorInitialize = func(processor.Settings) (*processing.Runtime, error) {
-				return nil, e
-			}
-		default:
-			break loop
-
-		}
-
-		p := NewProcessing(args)
-		err = p.Start()
-		g.Expect(err).NotTo(BeNil())
-		t.Logf("%d) err: %v", i, err)
-		p.Stop()
-	}
-}
-
-func TestProcessing_Basic(t *testing.T) {
-	g := NewWithT(t)
-	resetPatchTable()
-	defer resetPatchTable()
-
-	newInterfaces = func(string) (kube.Interfaces, error) {
-		return kube.NewInterfacesFromClient(kubelib.NewFakeClient()), nil
-	}
-	meshcfgNewFS = func(path string) (event.Source, error) { return mesh.NewInmemoryMeshCfg(), nil }
-
-	args := settings.DefaultArgs()
-
-	p := NewProcessing(args)
-	err := p.Start()
-	g.Expect(err).To(BeNil())
-
-	p.Stop()
-}
diff --git a/galley/pkg/server/settings/args.go b/galley/pkg/server/settings/args.go
deleted file mode 100644
index 5a5ad3468b..0000000000
--- a/galley/pkg/server/settings/args.go
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package settings
-
-import (
-	"bytes"
-	"fmt"
-	"time"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"istio.io/istio/galley/pkg/config/util/kuberesource"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/event"
-	"istio.io/istio/pkg/config/schema/snapshots"
-)
-
-const (
-	defaultMeshConfigFolder = "/etc/mesh-config/"
-	defaultMeshConfigFile   = defaultMeshConfigFolder + "mesh"
-)
-
-// Args contains the startup arguments to instantiate Galley.
-type Args struct { // nolint:maligned
-	// The path to kube configuration file.
-	KubeConfig string
-
-	// List of namespaces watched, separated by comma; if not set, watch all namespaces.
-	WatchedNamespaces string
-
-	// resync period to be passed to the K8s machinery.
-	ResyncPeriod time.Duration
-
-	// ExcludedResourceKinds is a list of resource kinds for which no source events will be triggered.
-	// DEPRECATED
-	ExcludedResourceKinds []string
-
-	// MeshConfigFile is the path for mesh config
-	MeshConfigFile string
-	MeshSource     event.Source
-
-	// DNS Domain suffix to use while constructing Ingress based resources.
-	DomainSuffix string
-
-	// Enable service discovery / endpoint processing.
-	EnableServiceDiscovery bool
-
-	// Enable Config Analysis service, that will analyze and update CRD status. UseOldProcessor must be set to false.
-	EnableConfigAnalysis bool
-
-	Snapshots       []string
-	TriggerSnapshot string
-}
-
-// DefaultArgs allocates an Args struct initialized with Galley's default configuration.
-func DefaultArgs() *Args {
-	return &Args{
-		ResyncPeriod:          0,
-		KubeConfig:            "",
-		WatchedNamespaces:     metav1.NamespaceAll,
-		MeshConfigFile:        defaultMeshConfigFile,
-		DomainSuffix:          constants.DefaultKubernetesDomain,
-		ExcludedResourceKinds: kuberesource.DefaultExcludedResourceKinds(),
-		EnableConfigAnalysis:  false,
-		Snapshots:             []string{snapshots.Default},
-		TriggerSnapshot:       snapshots.Default,
-	}
-}
-
-// String produces a stringified version of the arguments for debugging.
-func (a *Args) String() string {
-	buf := &bytes.Buffer{}
-
-	_, _ = fmt.Fprintf(buf, "Kubeconfigs: %s\n", a.KubeConfig)
-	_, _ = fmt.Fprintf(buf, "WatchedNamespaces: %s\n", a.WatchedNamespaces)
-	_, _ = fmt.Fprintf(buf, "ResyncPeriod: %v\n", a.ResyncPeriod)
-	_, _ = fmt.Fprintf(buf, "MeshConfigFile: %s\n", a.MeshConfigFile)
-	_, _ = fmt.Fprintf(buf, "DomainSuffix: %s\n", a.DomainSuffix)
-	_, _ = fmt.Fprintf(buf, "ExcludedResourceKinds: %v\n", a.ExcludedResourceKinds)
-
-	return buf.String()
-}
diff --git a/galley/pkg/server/settings/args_test.go b/galley/pkg/server/settings/args_test.go
deleted file mode 100644
index 04ca727d87..0000000000
--- a/galley/pkg/server/settings/args_test.go
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package settings
-
-import (
-	"testing"
-
-	"istio.io/istio/pkg/config/constants"
-)
-
-func TestDefaultArgs(t *testing.T) {
-	a := DefaultArgs()
-
-	if a.MeshConfigFile != defaultMeshConfigFile {
-		t.Fatalf("unexpected MeshConfigFile: %s", a.MeshConfigFile)
-	}
-
-	if a.DomainSuffix != constants.DefaultKubernetesDomain {
-		t.Fatalf("unexpected DomainSuffix: %s", a.DomainSuffix)
-	}
-}
-
-func TestArgs_String(t *testing.T) {
-	a := DefaultArgs()
-	// Should not crash
-	_ = a.String()
-}
diff --git a/galley/pkg/testing/mock/watch.go b/galley/pkg/testing/mock/watch.go
deleted file mode 100644
index 3d58f41378..0000000000
--- a/galley/pkg/testing/mock/watch.go
+++ /dev/null
@@ -1,132 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mock
-
-import (
-	"sync"
-
-	"k8s.io/apimachinery/pkg/watch"
-)
-
-var defaultWatchQueueSize = 1024 * 10
-
-// Watch is a mock implementation of watch.Interface.
-type Watch struct {
-	ch       chan watch.Event
-	q        []watch.Event
-	qIndex   int
-	qcond    *sync.Cond
-	stopping bool
-	stopCh   chan struct{}
-}
-
-type Watches []*Watch
-
-func (arr Watches) Send(event watch.Event) {
-	for _, w := range arr {
-		w.Send(event)
-	}
-}
-
-var _ watch.Interface = &Watch{}
-
-// NewWatch returns a new Watch instance.
-func NewWatch() *Watch {
-	w := &Watch{
-		ch:     make(chan watch.Event),
-		q:      make([]watch.Event, defaultWatchQueueSize),
-		qcond:  sync.NewCond(&sync.Mutex{}),
-		stopCh: make(chan struct{}, 1),
-	}
-
-	go w.run()
-
-	return w
-}
-
-// Stop is an implementation of watch.Interface.Watch.
-func (w *Watch) Stop() {
-	w.qcond.L.Lock()
-	if !w.stopping {
-		w.stopping = true
-		close(w.stopCh)
-		w.qcond.Signal()
-	}
-	w.qcond.L.Unlock()
-}
-
-// ResultChan is an implementation of watch.Interface.ResultChan.
-func (w *Watch) ResultChan() <-chan watch.Event {
-	return w.ch
-}
-
-// Send a watch event through the result channel.
-func (w *Watch) Send(event watch.Event) {
-	w.qcond.L.Lock()
-
-	// Add the element to the queue. Avoiding append if possible to avoid extra array allocation.
-	if w.qIndex < len(w.q) {
-		w.q[w.qIndex] = event
-	} else {
-		w.q = append(w.q, event)
-	}
-	w.qIndex++
-
-	w.qcond.Signal()
-	w.qcond.L.Unlock()
-}
-
-func (w *Watch) run() {
-	// Only the sender can close the channel safely.
-	defer close(w.ch)
-
-	tempQ := make([]watch.Event, defaultWatchQueueSize)
-	for {
-		w.qcond.L.Lock()
-
-		if !w.stopping && w.qIndex == 0 {
-			// Wait until we have an event.
-			w.qcond.Wait()
-		}
-
-		if w.stopping {
-			w.qcond.L.Unlock()
-			return
-		}
-
-		// Copy all of the current events to tempQ
-		numCopied := copy(tempQ, w.q[:w.qIndex])
-		if numCopied < w.qIndex {
-			// We've filled tempQ, but there are still elements remaining. Append them and allow
-			// tempQ to grow appropriately.
-			tempQ = append(tempQ, w.q[numCopied:w.qIndex]...)
-			numCopied = w.qIndex
-		}
-		// We've emptied the queue - reset the index.
-		w.qIndex = 0
-
-		w.qcond.L.Unlock()
-
-		// Push all of the events to the channel.
-		for i := 0; i < numCopied; i++ {
-			select {
-			case <-w.stopCh:
-				// Just return since we're shutting down.
-				return
-			case w.ch <- tempQ[i]:
-			}
-		}
-	}
-}
diff --git a/go.mod b/go.mod
index ec1cd2683f..80908c9084 100644
--- a/go.mod
+++ b/go.mod
@@ -29,6 +29,7 @@ require (
 	github.com/containernetworking/cni v1.0.1
 	github.com/containernetworking/plugins v1.0.1
 	github.com/coreos/go-oidc/v3 v3.1.0
+	github.com/cpuguy83/go-md2man/v2 v2.0.1 // indirect
 	github.com/davecgh/go-spew v1.1.1
 	github.com/distribution/distribution/v3 v3.0.0-20210926092439-1563384b69df
 	github.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021
@@ -53,7 +54,9 @@ require (
 	github.com/kylelemons/godebug v1.1.0
 	github.com/lestrrat-go/jwx v1.2.0
 	github.com/lucas-clemente/quic-go v0.24.0
+	github.com/mattn/go-colorable v0.1.11 // indirect
 	github.com/mattn/go-isatty v0.0.14
+	github.com/mattn/go-runewidth v0.0.13 // indirect
 	github.com/miekg/dns v1.1.43
 	github.com/mitchellh/copystructure v1.2.0
 	github.com/mitchellh/go-homedir v1.1.0
@@ -73,12 +76,13 @@ require (
 	github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb // indirect
 	github.com/yl2chen/cidranger v1.0.2
 	go.opencensus.io v0.23.0
+	go.starlark.net v0.0.0-20211013185944-b0039bd2cfe3 // indirect
 	go.uber.org/atomic v1.9.0
 	go.uber.org/multierr v1.7.0
 	golang.org/x/net v0.0.0-20211020060615-d418f374d309
 	golang.org/x/oauth2 v0.0.0-20211005180243-6b3c2da341f1
 	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c
-	golang.org/x/sys v0.0.0-20211020174200-9d6173849985
+	golang.org/x/sys v0.0.0-20211109184856-51b60fd695b3
 	golang.org/x/time v0.0.0-20210723032227-1f47c861a9ac
 	gomodules.xyz/jsonpatch/v3 v3.0.1
 	google.golang.org/api v0.59.0
diff --git a/go.sum b/go.sum
index 2380b7efc5..ec23ba6189 100644
--- a/go.sum
+++ b/go.sum
@@ -358,8 +358,9 @@ github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfc
 github.com/cpuguy83/go-md2man v1.0.10 h1:BSKMNlYxDvnunlTymqtgONjNnaRV1sTpcovwwjF22jk=
 github.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=
 github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
-github.com/cpuguy83/go-md2man/v2 v2.0.0 h1:EoUDS0afbrsXAZ9YQ9jdu/mZ2sXgT1/2yyNng4PGlyM=
 github.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
+github.com/cpuguy83/go-md2man/v2 v2.0.1 h1:r/myEWzV9lfsM1tFLgDyu0atFtJ1fXn261LKYj/3DxU=
+github.com/cpuguy83/go-md2man/v2 v2.0.1/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
 github.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=
 github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
 github.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=
@@ -848,8 +849,9 @@ github.com/marten-seemann/qtls-go1-17 v0.1.0/go.mod h1:fz4HIxByo+LlWcreM4CZOYNuz
 github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
 github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
 github.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
-github.com/mattn/go-colorable v0.1.9 h1:sqDoxXbdeALODt0DAeJCVp38ps9ZogZEAXjus69YV3U=
 github.com/mattn/go-colorable v0.1.9/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
+github.com/mattn/go-colorable v0.1.11 h1:nQ+aFkoE2TMGc0b68U2OKSexC+eq46+XwZzWXHRmPYs=
+github.com/mattn/go-colorable v0.1.11/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
 github.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
 github.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
 github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
@@ -860,8 +862,9 @@ github.com/mattn/go-oci8 v0.1.1/go.mod h1:wjDx6Xm9q7dFtHJvIlrI99JytznLw5wQ4R+9mN
 github.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
 github.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
 github.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
-github.com/mattn/go-runewidth v0.0.12 h1:Y41i/hVW3Pgwr8gV+J23B9YEY0zxjptBuCWEaxmAOow=
 github.com/mattn/go-runewidth v0.0.12/go.mod h1:RAqKPSqVFrSLVXbA8x7dzmKdmGzieGRCM46jaSJTDAk=
+github.com/mattn/go-runewidth v0.0.13 h1:lTGmDsbAYt5DmK6OnoV7EuIF1wEIFAcxld6ypU4OSgU=
+github.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
 github.com/mattn/go-shellwords v1.0.3/go.mod h1:3xCvwCdWdlDJUrvuMn7Wuy9eWs4pE8vqg+NOMyg4B2o=
 github.com/mattn/go-shellwords v1.0.11/go.mod h1:EZzvwXDESEeg03EKmM+RmDnNOPKG4lLtQsUlTZDWQ8Y=
 github.com/mattn/go-shellwords v1.0.12/go.mod h1:EZzvwXDESEeg03EKmM+RmDnNOPKG4lLtQsUlTZDWQ8Y=
@@ -1260,8 +1263,9 @@ go.opentelemetry.io/otel/sdk/metric v0.20.0/go.mod h1:knxiS8Xd4E/N+ZqKmUPf3gTTZ4
 go.opentelemetry.io/otel/trace v0.20.0/go.mod h1:6GjCW8zgDjwGHGa6GkyeB8+/5vjT16gUEi0Nf1iBdgw=
 go.opentelemetry.io/proto/otlp v0.7.0 h1:rwOQPCuKAKmwGKq2aVNnYIibI6wnV7EvzgfTCzcdGg8=
 go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
-go.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5 h1:+FNtrFTmVw0YZGpBGX56XDee331t6JAXeK2bcyhLOOc=
 go.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5/go.mod h1:nmDLcffg48OtT/PSW0Hg7FvpRQsQh5OSqIylirxKC7o=
+go.starlark.net v0.0.0-20211013185944-b0039bd2cfe3 h1:oBcONsksxvpeodDrLjiMDaKHXKAVVfAydhe/792CE/o=
+go.starlark.net v0.0.0-20211013185944-b0039bd2cfe3/go.mod h1:t3mmBBPzAVvK0L0n1drDmrQsJ8FoIx4INCqVMTr/Zo0=
 go.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
 go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
 go.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=
@@ -1569,9 +1573,10 @@ golang.org/x/sys v0.0.0-20210817190340-bfb29a6856f2/go.mod h1:oPkhp1MJrh7nUepCBc
 golang.org/x/sys v0.0.0-20210823070655-63515b42dcdf/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210908233432-aa78b53d3365/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210917161153-d61c044b1678/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20211007075335-d3039528d8ac/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20211020174200-9d6173849985 h1:LOlKVhfDyahgmqa97awczplwkjzNaELFg3zRIJ13RYo=
-golang.org/x/sys v0.0.0-20211020174200-9d6173849985/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20211109184856-51b60fd695b3 h1:T6tyxxvHMj2L1R2kZg0uNMpS8ZhB9lRa9XRGTCSA65w=
+golang.org/x/sys v0.0.0-20211109184856-51b60fd695b3/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=
 golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
 golang.org/x/term v0.0.0-20210220032956-6a3ed077a48d h1:SZxvLBoTP5yHO3Frd4z4vrF+DBX9vMVanchswa69toE=
diff --git a/istioctl/cmd/analyze.go b/istioctl/cmd/analyze.go
index 11ce63d0b5..a7ab67840e 100644
--- a/istioctl/cmd/analyze.go
+++ b/istioctl/cmd/analyze.go
@@ -29,15 +29,13 @@
 	"k8s.io/apimachinery/pkg/api/errors"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	cfgKube "istio.io/istio/galley/pkg/config/source/kube"
 	"istio.io/istio/istioctl/pkg/util/formatting"
 	"istio.io/istio/istioctl/pkg/util/handlers"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/kube"
@@ -148,11 +146,12 @@ func Analyze() *cobra.Command {
 				selectedNamespace = ""
 			}
 
-			sa := local.NewSourceAnalyzer(schema.MustGet(), analyzers.AllCombined(),
-				resource.Namespace(selectedNamespace), resource.Namespace(istioNamespace), nil, true, analysisTimeout)
+			sa := local.NewIstiodAnalyzer(schema.NewMustGet(), analyzers.AllCombined(),
+				resource.Namespace(selectedNamespace),
+				resource.Namespace(istioNamespace), nil, true)
 
 			// Check for suppressions and add them to our SourceAnalyzer
-			suppressions := make([]snapshotter.AnalysisSuppression, 0, len(suppress))
+			suppressions := make([]local.AnalysisSuppression, 0, len(suppress))
 			for _, s := range suppress {
 				parts := strings.Split(s, "=")
 				if len(parts) != 2 {
@@ -171,7 +170,7 @@ func Analyze() *cobra.Command {
 				if !codeIsValid {
 					fmt.Fprintf(cmd.ErrOrStderr(), "Warning: Supplied message code '%s' is an unknown message code and will not have any effect.\n", parts[0])
 				}
-				suppressions = append(suppressions, snapshotter.AnalysisSuppression{
+				suppressions = append(suppressions, local.AnalysisSuppression{
 					Code:         parts[0],
 					ResourceName: parts[1],
 				})
@@ -185,7 +184,10 @@ func Analyze() *cobra.Command {
 				if err != nil {
 					return err
 				}
-				k := cfgKube.NewInterfaces(restConfig)
+				k, err := kube.NewClient(kube.NewClientConfigForRestConfig(restConfig))
+				if err != nil {
+					return err
+				}
 				sa.AddRunningKubeSource(k)
 			}
 
diff --git a/istioctl/cmd/analyze_test.go b/istioctl/cmd/analyze_test.go
index 37353c40c5..28669a72a2 100644
--- a/istioctl/cmd/analyze_test.go
+++ b/istioctl/cmd/analyze_test.go
@@ -19,7 +19,7 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 )
 
 func TestErrorOnIssuesFound(t *testing.T) {
diff --git a/istioctl/cmd/injector-list.go b/istioctl/cmd/injector-list.go
index 4b0b905668..52a68c7e54 100644
--- a/istioctl/cmd/injector-list.go
+++ b/istioctl/cmd/injector-list.go
@@ -31,9 +31,9 @@
 
 	"istio.io/api/annotation"
 	"istio.io/api/label"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/injection"
-	analyzer_util "istio.io/istio/galley/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/istioctl/pkg/clioptions"
+	"istio.io/istio/pkg/config/analysis/analyzers/injection"
+	analyzer_util "istio.io/istio/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/kube"
 )
diff --git a/istioctl/cmd/precheck.go b/istioctl/cmd/precheck.go
index 7967a062c3..588ff454f8 100644
--- a/istioctl/cmd/precheck.go
+++ b/istioctl/cmd/precheck.go
@@ -31,17 +31,16 @@
 	authorizationapi "k8s.io/api/authorization/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/maturity"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	cfgKube "istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
 	"istio.io/istio/istioctl/pkg/clioptions"
 	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	"istio.io/istio/istioctl/pkg/util/formatting"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/maturity"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
+	"istio.io/istio/pkg/config/analysis/msg"
+	kube3 "istio.io/istio/pkg/config/legacy/source/kube"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -129,7 +128,11 @@ func checkControlPlane(cli kube.ExtendedClient) (diag.Messages, error) {
 	if err != nil {
 		return nil, err
 	}
-	k := cfgKube.NewInterfaces(restConfig)
+
+	k, err := kube.NewClient(kube.NewClientConfigForRestConfig(restConfig))
+	if err != nil {
+		return nil, err
+	}
 	sa.AddRunningKubeSource(k)
 	cancel := make(chan struct{})
 	result, err := sa.Analyze(cancel)
@@ -347,7 +350,7 @@ func checkListeners(cli kube.ExtendedClient, namespace string) (diag.Messages, e
 				}
 			}
 
-			origin := &rt.Origin{
+			origin := &kube3.Origin{
 				Collection: collections.K8SCoreV1Pods.Name(),
 				Kind:       collections.K8SCoreV1Pods.Resource().Kind(),
 				FullName: resource.FullName{
diff --git a/istioctl/cmd/remove-from-mesh.go b/istioctl/cmd/remove-from-mesh.go
index 43f8c0a62d..d8101256f1 100644
--- a/istioctl/cmd/remove-from-mesh.go
+++ b/istioctl/cmd/remove-from-mesh.go
@@ -21,7 +21,7 @@
 	"io"
 	"strings"
 
-	multierror "github.com/hashicorp/go-multierror"
+	"github.com/hashicorp/go-multierror"
 	"github.com/spf13/cobra"
 	appsv1 "k8s.io/api/apps/v1"
 	apierror "k8s.io/apimachinery/pkg/api/errors"
@@ -31,8 +31,8 @@
 	"k8s.io/client-go/kubernetes"
 
 	"istio.io/api/annotation"
-	analyzer_util "istio.io/istio/galley/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/istioctl/pkg/util/handlers"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/kube/inject"
@@ -93,7 +93,7 @@ func deploymentUnMeshifyCmd() *cobra.Command {
 				return fmt.Errorf("expecting deployment name")
 			}
 			ns := handlers.HandleNamespace(namespace, defaultNamespace)
-			if analyzer_util.IsSystemNamespace(resource.Namespace(ns)) || ns == istioNamespace {
+			if util.IsSystemNamespace(resource.Namespace(ns)) || ns == istioNamespace {
 				return fmt.Errorf("namespace %s is a system namespace and has no Istio sidecar injected", ns)
 			}
 			client, err := interfaceFactory(kubeconfig)
@@ -137,7 +137,7 @@ func svcUnMeshifyCmd() *cobra.Command {
 				return fmt.Errorf("expecting service name")
 			}
 			ns := handlers.HandleNamespace(namespace, defaultNamespace)
-			if analyzer_util.IsSystemNamespace(resource.Namespace(ns)) || ns == istioNamespace {
+			if util.IsSystemNamespace(resource.Namespace(ns)) || ns == istioNamespace {
 				return fmt.Errorf("namespace %s is a system namespace and has no Istio sidecar injected", ns)
 			}
 			client, err := interfaceFactory(kubeconfig)
diff --git a/istioctl/cmd/root.go b/istioctl/cmd/root.go
index f49c011191..0ca60a0f36 100644
--- a/istioctl/cmd/root.go
+++ b/istioctl/cmd/root.go
@@ -90,13 +90,13 @@ func defaultLogOptions() *log.Options {
 	// These scopes are, at the default "INFO" level, too chatty for command line use
 	o.SetOutputLevel("validation", log.ErrorLevel)
 	o.SetOutputLevel("processing", log.ErrorLevel)
-	o.SetOutputLevel("source", log.ErrorLevel)
 	o.SetOutputLevel("analysis", log.WarnLevel)
 	o.SetOutputLevel("installer", log.WarnLevel)
 	o.SetOutputLevel("translator", log.WarnLevel)
 	o.SetOutputLevel("adsc", log.WarnLevel)
 	o.SetOutputLevel("default", log.WarnLevel)
 	o.SetOutputLevel("klog", log.WarnLevel)
+	o.SetOutputLevel("kube", log.ErrorLevel)
 
 	return o
 }
diff --git a/istioctl/cmd/tag.go b/istioctl/cmd/tag.go
index 4ae84ce61d..3a481bea77 100644
--- a/istioctl/cmd/tag.go
+++ b/istioctl/cmd/tag.go
@@ -25,14 +25,13 @@
 	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/rest"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/webhook"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	cfgKube "istio.io/istio/galley/pkg/config/source/kube"
 	"istio.io/istio/istioctl/pkg/tag"
 	"istio.io/istio/istioctl/pkg/util/formatting"
 	"istio.io/istio/operator/cmd/mesh"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/webhook"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/kube"
@@ -318,7 +317,10 @@ func analyzeWebhook(name, wh string, config *rest.Config) error {
 	if err := sa.AddReaderKubeSource([]local.ReaderSource{{Name: "", Reader: strings.NewReader(wh)}}); err != nil {
 		return err
 	}
-	k := cfgKube.NewInterfaces(config)
+	k, err := kube.NewClient(kube.NewClientConfigForRestConfig(config))
+	if err != nil {
+		return err
+	}
 	sa.AddRunningKubeSource(k)
 	res, err := sa.Analyze(make(chan struct{}))
 	if err != nil {
diff --git a/istioctl/pkg/util/formatting/formatter.go b/istioctl/pkg/util/formatting/formatter.go
index 21bfd5788a..c9d4eb8387 100644
--- a/istioctl/pkg/util/formatting/formatter.go
+++ b/istioctl/pkg/util/formatting/formatter.go
@@ -24,7 +24,7 @@
 	"github.com/mattn/go-isatty"
 	"sigs.k8s.io/yaml"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/pkg/env"
 )
 
diff --git a/istioctl/pkg/util/formatting/formatter_test.go b/istioctl/pkg/util/formatting/formatter_test.go
index 797b631e45..8778440b5f 100644
--- a/istioctl/pkg/util/formatting/formatter_test.go
+++ b/istioctl/pkg/util/formatting/formatter_test.go
@@ -19,7 +19,7 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/url"
 )
 
diff --git a/istioctl/pkg/util/formatting/msg_threshold.go b/istioctl/pkg/util/formatting/msg_threshold.go
index a71100100a..4aff14cbd2 100644
--- a/istioctl/pkg/util/formatting/msg_threshold.go
+++ b/istioctl/pkg/util/formatting/msg_threshold.go
@@ -18,7 +18,7 @@
 	"errors"
 	"strings"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 )
 
 // MessageThreshold is a wrapper around Level to be used as a cobra command line argument.
diff --git a/operator/cmd/mesh/manifest-generate_test.go b/operator/cmd/mesh/manifest-generate_test.go
index c54638623e..81656b0a1a 100644
--- a/operator/cmd/mesh/manifest-generate_test.go
+++ b/operator/cmd/mesh/manifest-generate_test.go
@@ -217,7 +217,7 @@ func TestManifestGenerateWithDuplicateMutatingWebhookConfig(t *testing.T) {
 			name:  "Duplicate MutatingWebhookConfiguration should not be allowed when --force is disabled",
 			force: false,
 			assertFunc: func(g *WithT, objs *ObjectSet, err error) {
-				g.Expect(strings.Contains(err.Error(), "Webhook overlaps with others")).Should(BeTrue())
+				g.Expect(err.Error()).To(ContainSubstring("Webhook overlaps with others"))
 				g.Expect(objs).Should(BeNil())
 			},
 		},
diff --git a/operator/pkg/helmreconciler/reconciler.go b/operator/pkg/helmreconciler/reconciler.go
index 0d616e6355..e623db953a 100644
--- a/operator/pkg/helmreconciler/reconciler.go
+++ b/operator/pkg/helmreconciler/reconciler.go
@@ -35,10 +35,6 @@
 
 	"istio.io/api/label"
 	"istio.io/api/operator/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/webhook"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	cfgKube "istio.io/istio/galley/pkg/config/source/kube"
 	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	"istio.io/istio/istioctl/pkg/util/formatting"
 	istioV1Alpha1 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
@@ -48,9 +44,13 @@
 	"istio.io/istio/operator/pkg/util"
 	"istio.io/istio/operator/pkg/util/clog"
 	"istio.io/istio/operator/pkg/util/progress"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/webhook"
+	"istio.io/istio/pkg/config/analysis/local"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/resource"
 	istioConfigSchema "istio.io/istio/pkg/config/schema"
+	"istio.io/istio/pkg/kube"
 	"istio.io/pkg/version"
 )
 
@@ -563,7 +563,7 @@ func (h *HelmReconciler) analyzeWebhooks(whs []string) error {
 		return nil
 	}
 
-	sa := local.NewSourceAnalyzer(istioConfigSchema.MustGet(), analysis.Combine("webhook", &webhook.Analyzer{
+	sa := local.NewSourceAnalyzer(istioConfigSchema.NewMustGet(), analysis.Combine("webhook", &webhook.Analyzer{
 		SkipServiceCheck: true,
 	}),
 		resource.Namespace(h.iop.Spec.GetNamespace()), resource.Namespace(istioV1Alpha1.Namespace(h.iop.Spec)), nil, true, 30*time.Second)
@@ -591,7 +591,10 @@ func (h *HelmReconciler) analyzeWebhooks(whs []string) error {
 	}
 
 	if h.restConfig != nil {
-		k := cfgKube.NewInterfaces(h.restConfig)
+		k, err := kube.NewClient(kube.NewClientConfigForRestConfig(h.restConfig))
+		if err != nil {
+			return err
+		}
 		sa.AddRunningKubeSource(k)
 	}
 
diff --git a/pilot/pkg/bootstrap/configcontroller.go b/pilot/pkg/bootstrap/configcontroller.go
index 495e9c4226..0254f5ed26 100644
--- a/pilot/pkg/bootstrap/configcontroller.go
+++ b/pilot/pkg/bootstrap/configcontroller.go
@@ -19,9 +19,6 @@
 	"net/url"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/server/components"
-	"istio.io/istio/galley/pkg/server/settings"
 	configaggregate "istio.io/istio/pilot/pkg/config/aggregate"
 	"istio.io/istio/pilot/pkg/config/kube/crdclient"
 	"istio.io/istio/pilot/pkg/config/kube/gateway"
@@ -33,8 +30,9 @@
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/leaderelection"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pilot/pkg/status/distribution"
 	"istio.io/istio/pkg/adsc"
+	"istio.io/istio/pkg/config/analysis/incluster"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/pkg/log"
@@ -159,6 +157,9 @@ func (s *Server) initK8SConfigStore(args *PilotArgs) error {
 	}
 	s.ConfigStores = append(s.ConfigStores, configController)
 	if features.EnableGatewayAPI {
+		if s.statusManager == nil && features.EnableGatewayAPIStatus {
+			s.initStatusManager(args)
+		}
 		gwc := gateway.NewController(s.kubeClient, configController, args.RegistryOptions.KubeOptions)
 		s.environment.GatewayAPIController = gwc
 		s.ConfigStores = append(s.ConfigStores, s.environment.GatewayAPIController)
@@ -167,7 +168,7 @@ func (s *Server) initK8SConfigStore(args *PilotArgs) error {
 				NewLeaderElection(args.Namespace, args.PodName, leaderelection.GatewayStatusController, args.Revision, s.kubeClient).
 				AddRunFunction(func(leaderStop <-chan struct{}) {
 					log.Infof("Starting gateway status writer")
-					gwc.SetStatusWrite(true)
+					gwc.SetStatusWrite(true, s.statusManager)
 
 					// Trigger a push so we can recompute status
 					s.XDSServer.ConfigUpdate(&model.PushRequest{
@@ -176,7 +177,7 @@ func (s *Server) initK8SConfigStore(args *PilotArgs) error {
 					})
 					<-leaderStop
 					log.Infof("Stopping gateway status writer")
-					gwc.SetStatusWrite(false)
+					gwc.SetStatusWrite(false, nil)
 				}).
 				Run(stop)
 			return nil
@@ -287,45 +288,19 @@ func (s *Server) initConfigSources(args *PilotArgs) (err error) {
 // running Analyzers for status updates.  The Status Updater will eventually need to allow input from istiod
 // to support config distribution status as well.
 func (s *Server) initInprocessAnalysisController(args *PilotArgs) error {
-	processingArgs := settings.DefaultArgs()
-	processingArgs.KubeConfig = args.RegistryOptions.KubeConfig
-	processingArgs.EnableConfigAnalysis = true
-	meshSource := mesh.NewInmemoryMeshCfg()
-	meshSource.Set(s.environment.Mesh())
-	s.environment.Watcher.AddMeshHandler(func() {
-		meshSource.Set(s.environment.Mesh())
-	})
-	processingArgs.MeshSource = meshSource
-
-	processing := components.NewProcessing(processingArgs)
-
+	if s.statusManager == nil {
+		s.initStatusManager(args)
+	}
 	s.addStartFunc(func(stop <-chan struct{}) error {
 		go leaderelection.
 			NewLeaderElection(args.Namespace, args.PodName, leaderelection.AnalyzeController, args.Revision, s.kubeClient).
 			AddRunFunction(func(stop <-chan struct{}) {
-				// to protect pilot from panics in analysis (which should never cause pilot to exit), recover from
-				// panics in analysis and, unless stop is called, restart the analysis controller.
-				for {
-					select {
-					case <-stop:
-						return
-					default:
-						func() {
-							defer func() {
-								if r := recover(); r != nil {
-									log.Warnf("Analysis experienced fatal error, requires restart", r)
-								}
-							}()
-							log.Info("Starting Background Analysis")
-							if err := processing.Start(); err != nil {
-								log.Fatalf("Error starting Background Analysis: %s", err)
-							}
-							<-stop
-							log.Warnf("Stopping Background Analysis")
-							processing.Stop()
-						}()
-					}
+				cont, err := incluster.NewController(stop, s.RWConfigStore, s.configController,
+					s.kubeClient, args.Namespace, s.statusManager, args.RegistryOptions.KubeOptions.DomainSuffix)
+				if err != nil {
+					return
 				}
+				cont.Run(stop)
 			}).Run(stop)
 		return nil
 	})
@@ -333,7 +308,10 @@ func() {
 }
 
 func (s *Server) initStatusController(args *PilotArgs, writeStatus bool) {
-	s.statusReporter = &status.Reporter{
+	if s.statusManager == nil && writeStatus {
+		s.initStatusManager(args)
+	}
+	s.statusReporter = &distribution.Reporter{
 		UpdateInterval: features.StatusUpdateInterval,
 		PodName:        args.PodName,
 	}
@@ -355,7 +333,7 @@ func (s *Server) initStatusController(args *PilotArgs, writeStatus bool) {
 				AddRunFunction(func(stop <-chan struct{}) {
 					// Controller should be created for calling the run function every time, so it can
 					// avoid concurrently calling of informer Run() for controller in controller.Start
-					controller := status.NewController(s.kubeClient.RESTConfig(), args.Namespace, s.RWConfigStore)
+					controller := distribution.NewController(s.kubeClient.RESTConfig(), args.Namespace, s.RWConfigStore, s.statusManager)
 					s.statusReporter.SetController(controller)
 					controller.Start(stop)
 				}).Run(stop)
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index dc34f687e7..e30259764e 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -53,6 +53,7 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pilot/pkg/serviceregistry/serviceentry"
 	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pilot/pkg/status/distribution"
 	tb "istio.io/istio/pilot/pkg/trustbundle"
 	"istio.io/istio/pilot/pkg/xds"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
@@ -181,7 +182,8 @@ type Server struct {
 	// in AddStartFunc
 	internalStop chan struct{}
 
-	statusReporter *status.Reporter
+	statusReporter *distribution.Reporter
+	statusManager  *status.Manager
 	// RWConfigStore is the configstore which allows updates, particularly for status.
 	RWConfigStore model.ConfigStoreCache
 }
@@ -1247,3 +1249,11 @@ func (s *Server) initWorkloadTrustBundle(args *PilotArgs) error {
 func (s *Server) isDisableCa() bool {
 	return features.PilotCertProvider == constants.CertProviderKubernetes && s.RA != nil
 }
+
+func (s *Server) initStatusManager(_ *PilotArgs) {
+	s.addStartFunc(func(stop <-chan struct{}) error {
+		s.statusManager = status.NewManager(s.RWConfigStore)
+		s.statusManager.Start(stop)
+		return nil
+	})
+}
diff --git a/pilot/pkg/config/aggregate/config_test.go b/pilot/pkg/config/aggregate/config_test.go
index 943be114ff..373fda9be2 100644
--- a/pilot/pkg/config/aggregate/config_test.go
+++ b/pilot/pkg/config/aggregate/config_test.go
@@ -22,10 +22,10 @@
 	"github.com/onsi/gomega"
 	"go.uber.org/atomic"
 
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pilot/pkg/config/memory"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
diff --git a/galley/pkg/config/source/kube/inmemory/kubesource.go b/pilot/pkg/config/file/store.go
similarity index 57%
rename from galley/pkg/config/source/kube/inmemory/kubesource.go
rename to pilot/pkg/config/file/store.go
index 5bb13d110a..f8ef2ae160 100644
--- a/galley/pkg/config/source/kube/inmemory/kubesource.go
+++ b/pilot/pkg/config/file/store.go
@@ -1,23 +1,26 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package inmemory
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package file
 
 import (
 	"bufio"
 	"bytes"
-	"crypto/sha1"
+	"crypto/sha256"
+	"encoding/json"
 	"errors"
 	"fmt"
 	"io"
@@ -26,20 +29,31 @@
 
 	"github.com/hashicorp/go-multierror"
 	yamlv3 "gopkg.in/yaml.v3"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/serializer"
 	kubeJson "k8s.io/apimachinery/pkg/runtime/serializer/json"
 	"k8s.io/apimachinery/pkg/util/yaml"
-
-	"istio.io/istio/galley/pkg/config/scope"
-	"istio.io/istio/galley/pkg/config/source/inmemory"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
-	"istio.io/istio/galley/pkg/config/util/kubeyaml"
-	"istio.io/istio/pkg/config/event"
+	"k8s.io/client-go/tools/cache"
+
+	kubeyaml2 "istio.io/istio/pilot/pkg/config/file/util/kubeyaml"
+	"istio.io/istio/pilot/pkg/config/kube/arbitraryclient"
+	"istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	kube2 "istio.io/istio/pkg/config/legacy/source/kube"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	schemaresource "istio.io/istio/pkg/config/schema/resource"
+	"istio.io/istio/pkg/kube"
+	"istio.io/pkg/log"
 )
 
-var inMemoryKubeNameDiscriminator int64
+var (
+	inMemoryKubeNameDiscriminator int64
+	scope                         = log.RegisterScope("file", "File client messages", 0)
+)
 
 // KubeSource is an in-memory source implementation that can handle K8s style resources.
 type KubeSource struct {
@@ -47,49 +61,100 @@ type KubeSource struct {
 
 	name      string
 	schemas   *collection.Schemas
-	source    *inmemory.Source
+	inner     model.ConfigStore
 	defaultNs resource.Namespace
 
 	versionCtr int64
 	shas       map[kubeResourceKey]resourceSha
-	byFile     map[string]map[kubeResourceKey]collection.Name
+	byFile     map[string]map[kubeResourceKey]config.GroupVersionKind
+}
+
+func (s *KubeSource) Schemas() collection.Schemas {
+	return *s.schemas
+}
+
+func (s *KubeSource) Get(typ config.GroupVersionKind, name, namespace string) *config.Config {
+	return s.inner.Get(typ, name, namespace)
+}
+
+func (s *KubeSource) List(typ config.GroupVersionKind, namespace string) ([]config.Config, error) {
+	return s.inner.List(typ, namespace)
+}
+
+func (s *KubeSource) Create(config config.Config) (revision string, err error) {
+	return s.inner.Create(config)
+}
+
+func (s *KubeSource) Update(config config.Config) (newRevision string, err error) {
+	return s.inner.Update(config)
+}
+
+func (s *KubeSource) UpdateStatus(config config.Config) (newRevision string, err error) {
+	return s.inner.UpdateStatus(config)
 }
 
-type resourceSha [sha1.Size]byte
+func (s *KubeSource) Patch(orig config.Config, patchFn config.PatchFunc) (string, error) {
+	return s.inner.Patch(orig, patchFn)
+}
+
+func (s *KubeSource) Delete(typ config.GroupVersionKind, name, namespace string, resourceVersion *string) error {
+	return s.inner.Delete(typ, name, namespace, resourceVersion)
+}
+
+func (s *KubeSource) RegisterEventHandler(kind config.GroupVersionKind, handler model.EventHandler) {
+	panic("implement me")
+}
+
+func (s *KubeSource) Run(stop <-chan struct{}) {
+}
+
+func (s *KubeSource) SetWatchErrorHandler(f func(r *cache.Reflector, err error)) error {
+	panic("implement me")
+}
+
+func (s *KubeSource) HasSynced() bool {
+	return true
+}
+
+type resourceSha [sha256.Size]byte
 
 type kubeResource struct {
-	resource *resource.Instance
-	schema   collection.Schema
-	sha      resourceSha
+	// resource *resource.Instance
+	config *config.Config
+	schema collection.Schema
+	sha    resourceSha
 }
 
 func (r *kubeResource) newKey() kubeResourceKey {
 	return kubeResourceKey{
 		kind:     r.schema.Resource().Kind(),
-		fullName: r.resource.Metadata.FullName,
+		fullName: r.fullName(),
 	}
 }
 
+func (r *kubeResource) fullName() resource.FullName {
+	return resource.NewFullName(resource.Namespace(r.config.Namespace),
+		resource.LocalName(r.config.Name))
+}
+
 type kubeResourceKey struct {
 	fullName resource.FullName
 	kind     string
 }
 
-var _ event.Source = &KubeSource{}
+var _ model.ConfigStore = &KubeSource{}
 
 // NewKubeSource returns a new in-memory Source that works with Kubernetes resources.
 func NewKubeSource(schemas collection.Schemas) *KubeSource {
 	name := fmt.Sprintf("kube-inmemory-%d", inMemoryKubeNameDiscriminator)
 	inMemoryKubeNameDiscriminator++
 
-	s := inmemory.New(schemas)
-
 	return &KubeSource{
 		name:    name,
 		schemas: &schemas,
-		source:  s,
+		inner:   memory.MakeSkipValidation(schemas),
 		shas:    make(map[kubeResourceKey]resourceSha),
-		byFile:  make(map[string]map[kubeResourceKey]collection.Name),
+		byFile:  make(map[string]map[kubeResourceKey]config.GroupVersionKind),
 	}
 }
 
@@ -98,32 +163,12 @@ func (s *KubeSource) SetDefaultNamespace(defaultNs resource.Namespace) {
 	s.defaultNs = defaultNs
 }
 
-// Start implements processor.Source
-func (s *KubeSource) Start() {
-	s.source.Start()
-}
-
-// Stop implements processor.Source
-func (s *KubeSource) Stop() {
-	s.source.Stop()
-}
-
 // Clear the contents of this source
 func (s *KubeSource) Clear() {
 	s.versionCtr = 0
 	s.shas = make(map[kubeResourceKey]resourceSha)
-	s.byFile = make(map[string]map[kubeResourceKey]collection.Name)
-	s.source.Clear()
-}
-
-// Dispatch implements processor.Source
-func (s *KubeSource) Dispatch(h event.Handler) {
-	s.source.Dispatch(h)
-}
-
-// Get returns the named collection.
-func (s *KubeSource) Get(collection collection.Name) *inmemory.Collection {
-	return s.source.Get(collection)
+	s.byFile = make(map[string]map[kubeResourceKey]config.GroupVersionKind)
+	s.inner = memory.MakeSkipValidation(*s.schemas)
 }
 
 // ContentNames returns the names known to this source.
@@ -151,7 +196,7 @@ func (s *KubeSource) ApplyContent(name, yamlText string) error {
 	resources, parseErrs := s.parseContent(s.schemas, name, yamlText)
 
 	oldKeys := s.byFile[name]
-	newKeys := make(map[kubeResourceKey]collection.Name)
+	newKeys := make(map[kubeResourceKey]config.GroupVersionKind)
 
 	for _, r := range resources {
 		key := r.newKey()
@@ -159,20 +204,32 @@ func (s *KubeSource) ApplyContent(name, yamlText string) error {
 		oldSha, found := s.shas[key]
 		if !found || oldSha != r.sha {
 			s.versionCtr++
-			r.resource.Metadata.Version = resource.Version(fmt.Sprintf("v%d", s.versionCtr))
-			scope.Source.Debug("KubeSource.ApplyContent: Set: ", r.schema.Name(), r.resource.Metadata.FullName)
-			s.source.Get(r.schema.Name()).Set(r.resource)
+			r.config.ResourceVersion = fmt.Sprintf("v%d", s.versionCtr)
+			scope.Debug("KubeSource.ApplyContent: Set: ", r.schema.Name(), r.fullName())
+			// apply is idempotent, but configstore is not, thus the odd logic here
+			_, err := s.inner.Update(*r.config)
+			if err != nil {
+				_, err = s.inner.Create(*r.config)
+				if err != nil {
+					return fmt.Errorf("cannot store config %v from reader: %s",
+						r.config.Meta, err)
+				}
+			}
 			s.shas[key] = r.sha
 		}
-		newKeys[key] = r.schema.Name()
+		newKeys[key] = r.schema.Resource().GroupVersionKind()
 		if oldKeys != nil {
-			scope.Source.Debug("KubeSource.ApplyContent: Delete: ", r.schema.Name(), key)
+			scope.Debug("KubeSource.ApplyContent: Delete: ", r.schema.Name(), key)
 			delete(oldKeys, key)
 		}
 	}
 
 	for k, col := range oldKeys {
-		s.source.Get(col).Remove(k.fullName)
+		empty := ""
+		err := s.inner.Delete(col, k.fullName.Name.String(), k.fullName.Namespace.String(), &empty)
+		if err != nil {
+			scope.Errorf("encountered unexpected error removing resource from filestore: %s", err)
+		}
 	}
 	s.byFile[name] = newKeys
 
@@ -190,7 +247,11 @@ func (s *KubeSource) RemoveContent(name string) {
 	keys := s.byFile[name]
 	if keys != nil {
 		for key, col := range keys {
-			s.source.Get(col).Remove(key.fullName)
+			empty := ""
+			err := s.inner.Delete(col, key.fullName.Name.String(), key.fullName.Namespace.String(), &empty)
+			if err != nil {
+				scope.Errorf("encountered unexpected error removing resource from filestore: %s", err)
+			}
 			delete(s.shas, key)
 		}
 
@@ -203,7 +264,7 @@ func (s *KubeSource) parseContent(r *collection.Schemas, name, yamlText string)
 	var errs error
 
 	reader := bufio.NewReader(strings.NewReader(yamlText))
-	decoder := kubeyaml.NewYAMLReader(reader)
+	decoder := kubeyaml2.NewYAMLReader(reader)
 	chunkCount := -1
 
 	for {
@@ -214,8 +275,8 @@ func (s *KubeSource) parseContent(r *collection.Schemas, name, yamlText string)
 		}
 		if err != nil {
 			e := fmt.Errorf("error reading documents in %s[%d]: %v", name, chunkCount, err)
-			scope.Source.Warnf("%v - skipping", e)
-			scope.Source.Debugf("Failed to parse yamlText chunk: %v", yamlText)
+			scope.Warnf("%v - skipping", e)
+			scope.Debugf("Failed to parse yamlText chunk: %v", yamlText)
 			errs = multierror.Append(errs, e)
 			break
 		}
@@ -226,11 +287,11 @@ func (s *KubeSource) parseContent(r *collection.Schemas, name, yamlText string)
 			var uerr *unknownSchemaError
 			if errors.As(err, &uerr) {
 				// Note the error to the debug log but continue
-				scope.Source.Debugf("skipping unknown yaml chunk %s: %s", name, uerr.Error())
+				scope.Debugf("skipping unknown yaml chunk %s: %s", name, uerr.Error())
 			} else {
 				e := fmt.Errorf("error processing %s[%d]: %v", name, chunkCount, err)
-				scope.Source.Warnf("%v - skipping", e)
-				scope.Source.Debugf("Failed to parse yaml chunk: %v", string(chunk))
+				scope.Warnf("%v - skipping", e)
+				scope.Debugf("Failed to parse yaml chunk: %v", string(chunk))
 				errs = multierror.Append(errs, e)
 			}
 			continue
@@ -293,19 +354,25 @@ func (s *KubeSource) parseChunk(r *collection.Schemas, name string, lineNum int,
 		}
 	}
 
-	t := rt.DefaultProvider().GetAdapter(schema.Resource())
-	obj, err := t.ParseJSON(jsonChunk)
+	runtimeScheme := runtime.NewScheme()
+	codecs := serializer.NewCodecFactory(runtimeScheme)
+	deserializer := codecs.UniversalDeserializer()
+	obj, err := kube.IstioScheme.New(schema.Resource().GroupVersionKind().Kubernetes())
+	if err != nil {
+		return kubeResource{}, fmt.Errorf("failed to initialize interface for built-in type: %v", err)
+	}
+	_, _, err = deserializer.Decode(jsonChunk, nil, obj)
 	if err != nil {
 		return kubeResource{}, fmt.Errorf("failed parsing JSON for built-in type: %v", err)
 	}
-	objMeta := t.ExtractObject(obj)
+	objMeta := obj.(metav1.Object)
 
 	// If namespace is blank and we have a default set, fill in the default
 	// (This mirrors the behavior if you kubectl apply a resource without a namespace defined)
 	// Don't do this for cluster scoped resources
 	if !schema.Resource().IsClusterScoped() {
 		if objMeta.GetNamespace() == "" && s.defaultNs != "" {
-			scope.Source.Debugf("KubeSource.parseChunk: namespace not specified for %q, using %q", objMeta.GetName(), s.defaultNs)
+			scope.Debugf("KubeSource.parseChunk: namespace not specified for %q, using %q", objMeta.GetName(), s.defaultNs)
 			objMeta.SetNamespace(string(s.defaultNs))
 		}
 	} else {
@@ -313,11 +380,6 @@ func (s *KubeSource) parseChunk(r *collection.Schemas, name string, lineNum int,
 		objMeta.SetNamespace("")
 	}
 
-	item, err := t.ExtractResource(obj)
-	if err != nil {
-		return kubeResource{}, err
-	}
-
 	// Build flat map for analyzers if the line JSON object exists, if the YAML text is ill-formed, this will be nil
 	fieldMap := make(map[string]int)
 
@@ -332,14 +394,52 @@ func (s *KubeSource) parseChunk(r *collection.Schemas, name string, lineNum int,
 		BuildFieldPathMap(yamlNode, lineNum, "", fieldMap)
 	}
 
-	pos := rt.Position{Filename: name, Line: lineNum}
+	pos := kube2.Position{Filename: name, Line: lineNum}
+	c, err := ToConfig(objMeta, schema, &pos, fieldMap)
+	if err != nil {
+		return kubeResource{}, err
+	}
 	return kubeResource{
-		schema:   schema,
-		sha:      sha1.Sum(yamlChunk),
-		resource: rt.ToResource(objMeta, schema, item, &pos, fieldMap),
+		schema: schema,
+		sha:    sha256.Sum256(yamlChunk),
+		config: c,
 	}, nil
 }
 
+const (
+	FieldMapKey  = "istiofilefieldmap"
+	ReferenceKey = "istiosource"
+)
+
+// ToConfig converts the given object and proto to a config.Config
+func ToConfig(object metav1.Object, schema collection.Schema, source resource.Reference, fieldMap map[string]int) (*config.Config, error) {
+	m, err := runtime.DefaultUnstructuredConverter.ToUnstructured(object)
+	if err != nil {
+		return nil, err
+	}
+	u := &unstructured.Unstructured{Object: m}
+	if len(fieldMap) > 0 || source != nil {
+		// TODO: populate
+		annots := u.GetAnnotations()
+		if annots == nil {
+			annots = map[string]string{}
+		}
+		jsonfm, err := json.Marshal(fieldMap)
+		if err != nil {
+			return nil, err
+		}
+		annots[FieldMapKey] = string(jsonfm)
+		jsonsource, err := json.Marshal(source)
+		if err != nil {
+			return nil, err
+		}
+		annots[ReferenceKey] = string(jsonsource)
+		u.SetAnnotations(annots)
+	}
+	result := arbitraryclient.TranslateObject(u, "", schema)
+	return result, nil
+}
+
 // BuildFieldPathMap builds the flat map for each field of the YAML resource
 func BuildFieldPathMap(yamlNode *yamlv3.Node, startLineNum int, curPath string, fieldPathMap map[string]int) {
 	// If no content in the node, terminate the DFS search
diff --git a/galley/pkg/config/util/kubeyaml/kubeyaml.go b/pilot/pkg/config/file/util/kubeyaml/kubeyaml.go
similarity index 100%
rename from galley/pkg/config/util/kubeyaml/kubeyaml.go
rename to pilot/pkg/config/file/util/kubeyaml/kubeyaml.go
diff --git a/galley/pkg/config/util/kubeyaml/kubeyaml_test.go b/pilot/pkg/config/file/util/kubeyaml/kubeyaml_test.go
diff --git a/galley/pkg/config/util/kubeyaml/kubeyaml_test.go b/pilot/pkg/config/file/util/kubeyaml/kubeyaml_test.go
similarity index 100%
rename from galley/pkg/config/util/kubeyaml/kubeyaml_test.go
rename to pilot/pkg/config/file/util/kubeyaml/kubeyaml_test.go
diff --git a/pilot/pkg/config/kube/arbitraryclient/client.go b/pilot/pkg/config/kube/arbitraryclient/client.go
diff --git a/pilot/pkg/config/kube/arbitraryclient/client.go b/pilot/pkg/config/kube/arbitraryclient/client.go
new file mode 100644
index 0000000000..f31bddd52d
--- /dev/null
+++ b/pilot/pkg/config/kube/arbitraryclient/client.go
@@ -0,0 +1,491 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package arbitraryclient provides an implementation of the config store and cache
+// using Kubernetes Resources and the informer framework from Kubernetes.  It is read-only
+// and is intended only for use with analyzers due to poor performance.
+//
+// To implement the Istio store interface, we need to take dynamic inputs. Using the dynamic informers results in poor
+// performance, as the cache will store unstructured objects which need to be marshaled on each Get/List call.
+// Therefore this store is appropriate only for applications where low performance is acceptable.
+package arbitraryclient
+
+import (
+	"context"
+	"errors"
+	"sync"
+	"time"
+
+	"github.com/hashicorp/go-multierror"
+	"go.uber.org/atomic"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	klabels "k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/client-go/discovery"
+	"k8s.io/client-go/informers"
+
+	//  import GKE cluster authentication plugin
+	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
+
+	//  import OIDC cluster authentication plugin, e.g. for Tectonic
+	_ "k8s.io/client-go/plugin/pkg/client/auth/oidc"
+	"k8s.io/client-go/tools/cache"
+
+	"istio.io/api/label"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/config/schema/resource"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/queue"
+	"istio.io/pkg/log"
+	"istio.io/pkg/monitoring"
+)
+
+var scope = log.RegisterScope("kube", "Kubernetes client messages", 0)
+
+// Client is a client for Istio CRDs, implementing config store cache
+// This is used for CRUD operators on Istio configuration, as well as handling of events on config changes
+type Client struct {
+	// schemas defines the set of schemas used by this client.
+	// Note: this must be a subset of the schemas defined in the codegen
+	schemas collection.Schemas
+
+	// domainSuffix for the config metadata
+	domainSuffix string
+
+	// revision for this control plane instance. We will only read configs that match this revision.
+	revision string
+
+	// kinds keeps track of all cache handlers for known types
+	kinds   map[config.GroupVersionKind]*cacheHandler
+	kindsMu sync.RWMutex
+	queue   queue.Instance
+
+	// handlers defines a list of event handlers per-type
+	handlers map[config.GroupVersionKind][]model.EventHandler
+
+	// beginSync is set to true when calling SyncAll, it indicates the controller has began sync resources.
+	beginSync *atomic.Bool
+	// initialSync is set to true after performing an initial processing of all objects.
+	initialSync *atomic.Bool
+}
+
+var _ model.ConfigStoreCache = &Client{}
+
+func New(client kube.Client, revision, domainSuffix string) (model.ConfigStoreCache, error) {
+	schemas := collections.Kube
+	if features.EnableGatewayAPI {
+		schemas = collections.PilotGatewayAPI
+	}
+	return NewForSchemas(context.Background(), client, revision, domainSuffix, schemas)
+}
+
+func NewForSchemas(ctx context.Context, client kube.Client, revision, domainSuffix string, schemas collection.Schemas) (model.ConfigStoreCache, error) {
+	out := &Client{
+		domainSuffix: domainSuffix,
+		schemas:      schemas,
+		revision:     revision,
+		queue:        queue.NewQueue(1 * time.Second),
+		kinds:        map[config.GroupVersionKind]*cacheHandler{},
+		handlers:     map[config.GroupVersionKind][]model.EventHandler{},
+		beginSync:    atomic.NewBool(false),
+		initialSync:  atomic.NewBool(false),
+	}
+
+	rc := availableResourceCache(client.Kube().Discovery())
+	for _, s := range schemas.All() {
+		if !rc.recognizes(s.Resource()) {
+			scope.Warnf("arbitraryclient cannot watch resource %s, as k8s doesn't recognize it.", s.Resource().GroupVersionKind())
+			out.schemas.Remove(s)
+			continue
+		}
+		i := client.DynamicInformer().ForResource(s.Resource().GroupVersionResource())
+		out.kinds[s.Resource().GroupVersionKind()] = createCacheHandler(out, s, i)
+	}
+
+	return out, nil
+}
+
+type resourceCache struct {
+	knownGroups map[string]*v1.APIResourceList
+	discovery   discovery.DiscoveryInterface
+}
+
+func (r *resourceCache) get(gv schema.GroupVersion) (*v1.APIResourceList, error) {
+	if res, ok := r.knownGroups[gv.String()]; ok {
+		return res, nil
+	}
+	res, err := r.discovery.ServerResourcesForGroupVersion(gv.String())
+	if err == nil {
+		r.knownGroups[gv.String()] = res
+	}
+	return res, err
+}
+
+func (r *resourceCache) recognizes(s resource.Schema) bool {
+	group, err := r.get(s.GroupVersionResource().GroupVersion())
+	if err != nil {
+		scope.Warnf("failed listing available apis for groupversion %s: %s",
+			s.GroupVersionResource().GroupVersion(), err)
+		// TODO: is returning false correct here?  should we retry?
+		return false
+	}
+	for _, api := range group.APIResources {
+		if api.Kind == s.Kind() {
+			return true
+		}
+	}
+	return false
+}
+
+func availableResourceCache(discovery discovery.DiscoveryInterface) *resourceCache {
+	return &resourceCache{
+		knownGroups: map[string]*v1.APIResourceList{},
+		discovery:   discovery,
+	}
+}
+
+// Validate we are ready to handle events. Until the informers are synced, we will block the queue
+func (cl *Client) checkReadyForEvents(curr interface{}) error {
+	if !cl.informerSynced() {
+		return errors.New("waiting till full synchronization")
+	}
+	_, err := cache.DeletionHandlingMetaNamespaceKeyFunc(curr)
+	if err != nil {
+		scope.Infof("Error retrieving key: %v", err)
+	}
+	return nil
+}
+
+func (cl *Client) RegisterEventHandler(kind config.GroupVersionKind, handler model.EventHandler) {
+	cl.handlers[kind] = append(cl.handlers[kind], handler)
+}
+
+func (cl *Client) SetWatchErrorHandler(handler func(r *cache.Reflector, err error)) error {
+	var errs error
+	for _, h := range cl.allKinds() {
+		if err := h.informer.SetWatchErrorHandler(handler); err != nil {
+			errs = multierror.Append(errs, err)
+		}
+	}
+	return errs
+}
+
+// Run the queue and all informers. Callers should  wait for HasSynced() before depending on results.
+func (cl *Client) Run(stop <-chan struct{}) {
+	t0 := time.Now()
+	scope.Info("Starting Pilot K8S CRD controller")
+
+	if !cache.WaitForCacheSync(stop, cl.informerSynced) {
+		scope.Error("Failed to sync Pilot K8S CRD controller cache")
+		return
+	}
+	cl.SyncAll()
+	cl.initialSync.Store(true)
+	scope.Info("Pilot K8S CRD controller synced ", time.Since(t0))
+
+	cl.queue.Run(stop)
+	scope.Info("controller terminated")
+}
+
+func (cl *Client) informerSynced() bool {
+	for _, ctl := range cl.allKinds() {
+		if !ctl.informer.HasSynced() {
+			scope.Infof("controller %q is syncing...", ctl.schema.Resource().GroupVersionKind())
+			return false
+		}
+	}
+	return true
+}
+
+func (cl *Client) HasSynced() bool {
+	return cl.initialSync.Load()
+}
+
+// SyncAll syncs all the objects during bootstrap to make the configs updated to caches
+func (cl *Client) SyncAll() {
+	cl.beginSync.Store(true)
+	wg := sync.WaitGroup{}
+	for _, h := range cl.allKinds() {
+		handlers := cl.handlers[h.schema.Resource().GroupVersionKind()]
+		if len(handlers) == 0 {
+			continue
+		}
+		h := h
+		wg.Add(1)
+		go func() {
+			defer wg.Done()
+			objects := h.informer.GetIndexer().List()
+			for _, object := range objects {
+				currItem, ok := object.(*unstructured.Unstructured)
+				if !ok {
+					scope.Warnf("New Object can not be converted to runtime Object %v, is type %T", object, object)
+					return
+				}
+				currConfig := *TranslateObject(currItem, h.client.domainSuffix, h.schema)
+				for _, f := range handlers {
+					f(config.Config{}, currConfig, model.EventAdd)
+				}
+			}
+		}()
+	}
+	wg.Wait()
+}
+
+func TranslateObject(obj *unstructured.Unstructured, domainSuffix string, schema collection.Schema) *config.Config {
+	mv2, err := schema.Resource().NewInstance()
+	if err != nil {
+		panic(err)
+	}
+	if spec, ok := obj.UnstructuredContent()["spec"]; ok {
+		err = runtime.DefaultUnstructuredConverter.FromUnstructured(spec.(map[string]interface{}), mv2)
+	} else {
+		err = runtime.DefaultUnstructuredConverter.FromUnstructured(obj.UnstructuredContent(), mv2)
+	}
+	if err != nil {
+		panic(err)
+	}
+
+	m := obj
+	return &config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: config.GroupVersionKind{
+				Group:   m.GetObjectKind().GroupVersionKind().Group,
+				Version: m.GetObjectKind().GroupVersionKind().Version,
+				Kind:    m.GetObjectKind().GroupVersionKind().Kind,
+			},
+			UID:               string(m.GetUID()),
+			Name:              m.GetName(),
+			Namespace:         m.GetNamespace(),
+			Labels:            m.GetLabels(),
+			Annotations:       m.GetAnnotations(),
+			ResourceVersion:   m.GetResourceVersion(),
+			CreationTimestamp: m.GetCreationTimestamp().Time,
+			OwnerReferences:   m.GetOwnerReferences(),
+			Generation:        m.GetGeneration(),
+			Domain:            domainSuffix,
+		},
+		Spec: mv2,
+	}
+}
+
+// Schemas for the store
+func (cl *Client) Schemas() collection.Schemas {
+	return cl.schemas
+}
+
+// Get implements store interface
+func (cl *Client) Get(typ config.GroupVersionKind, name, namespace string) *config.Config {
+	h, f := cl.kind(typ)
+	if !f {
+		scope.Warnf("unknown type: %s", typ)
+		return nil
+	}
+
+	obj, err := h.lister(namespace).Get(name)
+	if err != nil {
+		// TODO we should be returning errors not logging
+		scope.Warnf("error on get %v/%v: %v", name, namespace, err)
+		return nil
+	}
+
+	cfg := TranslateObject(obj.(*unstructured.Unstructured), cl.domainSuffix, h.schema)
+	if !cl.objectInRevision(cfg) {
+		return nil
+	}
+	return cfg
+}
+
+// Create implements store interface
+func (cl *Client) Create(cfg config.Config) (string, error) {
+	panic("Create not implemented: this cache is read-only")
+}
+
+// Update implements store interface
+func (cl *Client) Update(cfg config.Config) (string, error) {
+	panic("Update not implemented: this cache is read-only")
+}
+
+func (cl *Client) UpdateStatus(cfg config.Config) (string, error) {
+	panic("UpdateStatus not implemented: this cache is read-only")
+}
+
+// Patch applies only the modifications made in the PatchFunc rather than doing a full replace. Useful to avoid
+// read-modify-write conflicts when there are many concurrent-writers to the same resource.
+func (cl *Client) Patch(orig config.Config, patchFn config.PatchFunc) (string, error) {
+	panic("Patch not implemented: this cache is read-only")
+}
+
+// Delete implements store interface
+// `resourceVersion` must be matched before deletion is carried out. If not possible, a 409 Conflict status will be
+func (cl *Client) Delete(typ config.GroupVersionKind, name, namespace string, resourceVersion *string) error {
+	panic("Delete not implemented: this cache is read-only")
+}
+
+// List implements store interface
+func (cl *Client) List(kind config.GroupVersionKind, namespace string) ([]config.Config, error) {
+	h, f := cl.kind(kind)
+	if !f {
+		return nil, nil
+	}
+
+	list, err := h.lister(namespace).List(klabels.Everything())
+	if err != nil {
+		return nil, err
+	}
+	out := make([]config.Config, 0, len(list))
+	for _, item := range list {
+		cfg := TranslateObject(item.(*unstructured.Unstructured), cl.domainSuffix, h.schema)
+		if cl.objectInRevision(cfg) {
+			out = append(out, *cfg)
+		}
+	}
+
+	return out, err
+}
+
+func (cl *Client) objectInRevision(o *config.Config) bool {
+	configEnv, f := o.Labels[label.IoIstioRev.Name]
+	if !f {
+		// This is a global object, and always included
+		return true
+	}
+	// Otherwise, only return if the
+	return configEnv == cl.revision
+}
+
+func (cl *Client) allKinds() []*cacheHandler {
+	cl.kindsMu.RLock()
+	defer cl.kindsMu.RUnlock()
+	ret := make([]*cacheHandler, 0, len(cl.kinds))
+	for _, k := range cl.kinds {
+		ret = append(ret, k)
+	}
+	return ret
+}
+
+func (cl *Client) kind(r config.GroupVersionKind) (*cacheHandler, bool) {
+	cl.kindsMu.RLock()
+	defer cl.kindsMu.RUnlock()
+	ch, ok := cl.kinds[r]
+	return ch, ok
+}
+
+// cacheHandler abstracts the logic of an informer with a set of handlers. Handlers can be added at runtime
+// and will be invoked on each informer event.
+type cacheHandler struct {
+	client   *Client
+	informer cache.SharedIndexInformer
+	schema   collection.Schema
+	lister   func(namespace string) cache.GenericNamespaceLister
+}
+
+func (h *cacheHandler) onEvent(old interface{}, curr interface{}, event model.Event) error {
+	if err := h.client.checkReadyForEvents(curr); err != nil {
+		return err
+	}
+
+	currItem, ok := curr.(*unstructured.Unstructured)
+	if !ok {
+		scope.Warnf("New Object can not be converted to unstructured %v, is type %T", curr, curr)
+		return nil
+	}
+	currConfig := *TranslateObject(currItem, h.client.domainSuffix, h.schema)
+
+	var oldConfig config.Config
+	if old != nil {
+		oldItem, ok := old.(*unstructured.Unstructured)
+		if !ok {
+			log.Warnf("Old Object can not be converted to runtime Object %v, is type %T", old, old)
+			return nil
+		}
+		oldConfig = *TranslateObject(oldItem, h.client.domainSuffix, h.schema)
+	}
+
+	// TODO we may consider passing a pointer to handlers instead of the value. While spec is a pointer, the meta will be copied
+	for _, f := range h.client.handlers[h.schema.Resource().GroupVersionKind()] {
+		f(oldConfig, currConfig, event)
+	}
+	return nil
+}
+
+func createCacheHandler(cl *Client, schema collection.Schema, i informers.GenericInformer) *cacheHandler {
+	scope.Debugf("registered CRD %v", schema.Resource().GroupVersionKind())
+	h := &cacheHandler{
+		client:   cl,
+		schema:   schema,
+		informer: i.Informer(),
+	}
+	h.lister = func(namespace string) cache.GenericNamespaceLister {
+		if schema.Resource().IsClusterScoped() {
+			return i.Lister()
+		}
+		return i.Lister().ByNamespace(namespace)
+	}
+	kind := schema.Resource().Kind()
+	i.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
+		AddFunc: func(obj interface{}) {
+			incrementEvent(kind, "add")
+			if !cl.beginSync.Load() {
+				return
+			}
+			cl.queue.Push(func() error {
+				return h.onEvent(nil, obj, model.EventAdd)
+			})
+		},
+		UpdateFunc: func(old, cur interface{}) {
+			incrementEvent(kind, "update")
+			if !cl.beginSync.Load() {
+				return
+			}
+			cl.queue.Push(func() error {
+				return h.onEvent(old, cur, model.EventUpdate)
+			})
+		},
+		DeleteFunc: func(obj interface{}) {
+			incrementEvent(kind, "delete")
+			if !cl.beginSync.Load() {
+				return
+			}
+			cl.queue.Push(func() error {
+				return h.onEvent(nil, obj, model.EventDelete)
+			})
+		},
+	})
+	return h
+}
+
+var (
+	typeTag  = monitoring.MustCreateLabel("type")
+	eventTag = monitoring.MustCreateLabel("event")
+
+	k8sEvents = monitoring.NewSum(
+		"pilot_k8s_cfg_events",
+		"Events from k8s config.",
+		monitoring.WithLabels(typeTag, eventTag),
+	)
+)
+
+func init() {
+	monitoring.MustRegister(k8sEvents)
+}
+
+func incrementEvent(kind, event string) {
+	k8sEvents.With(typeTag.Value(kind), eventTag.Value(event)).Increment()
+}
diff --git a/pilot/pkg/config/kube/crd/conversion_test.go b/pilot/pkg/config/kube/crd/conversion_test.go
index f953699bc1..29765c07d3 100644
--- a/pilot/pkg/config/kube/crd/conversion_test.go
+++ b/pilot/pkg/config/kube/crd/conversion_test.go
@@ -20,7 +20,7 @@
 
 	"istio.io/api/meta/v1alpha1"
 	"istio.io/istio/pilot/test/mock"
-	config2 "istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collections"
 )
 
@@ -28,8 +28,8 @@ func TestConvert(t *testing.T) {
 	if _, err := ConvertObject(collections.IstioNetworkingV1Alpha3Virtualservices, &IstioKind{Spec: map[string]interface{}{"x": 1}}, "local"); err != nil {
 		t.Errorf("error for converting object: %s", err)
 	}
-	config := config2.Config{
-		Meta: config2.Meta{
+	cfg := config.Config{
+		Meta: config.Meta{
 			GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
 			Name:             "test",
 			Namespace:        "default",
@@ -46,7 +46,7 @@ func TestConvert(t *testing.T) {
 		},
 	}
 
-	obj, err := ConvertConfig(config)
+	obj, err := ConvertConfig(cfg)
 	if err != nil {
 		t.Errorf("ConvertConfig() => unexpected error %v", err)
 	}
@@ -54,8 +54,8 @@ func TestConvert(t *testing.T) {
 	if err != nil {
 		t.Errorf("ConvertObject() => unexpected error %v", err)
 	}
-	if !reflect.DeepEqual(&config, got) {
-		t.Errorf("ConvertObject(ConvertConfig(%#v)) => got %#v", config, got)
+	if !reflect.DeepEqual(&cfg, got) {
+		t.Errorf("ConvertObject(ConvertConfig(%#v)) => got %#v", cfg, got)
 	}
 }
 
diff --git a/pilot/pkg/config/kube/crdclient/client.go b/pilot/pkg/config/kube/crdclient/client.go
index 299765e63d..44cab27b15 100644
--- a/pilot/pkg/config/kube/crdclient/client.go
+++ b/pilot/pkg/config/kube/crdclient/client.go
@@ -110,8 +110,20 @@ func New(client kube.Client, revision, domainSuffix string) (model.ConfigStoreCa
 	return NewForSchemas(context.Background(), client, revision, domainSuffix, schemas)
 }
 
-var crdWatches = map[config.GroupVersionKind]chan struct{}{
-	gvk.KubernetesGateway: make(chan struct{}),
+var crdWatches = map[config.GroupVersionKind]*waiter{
+	gvk.KubernetesGateway: newWaiter(),
+}
+
+type waiter struct {
+	once sync.Once
+	stop chan struct{}
+}
+
+func newWaiter() *waiter {
+	return &waiter{
+		once: sync.Once{},
+		stop: make(chan struct{}),
+	}
 }
 
 // WaitForCRD waits until the request CRD exists, and returns true on success. A false return value
@@ -126,7 +138,7 @@ func WaitForCRD(k config.GroupVersionKind, stop <-chan struct{}) bool {
 	select {
 	case <-stop:
 		return false
-	case <-ch:
+	case <-ch.stop:
 		return true
 	}
 }
@@ -509,7 +521,9 @@ func handleCRDAdd(cl *Client, name string, stop <-chan struct{}) {
 	cl.kinds[resourceGVK] = createCacheHandler(cl, s, i)
 	if w, f := crdWatches[resourceGVK]; f {
 		scope.Infof("notifying watchers %v was created", resourceGVK)
-		close(w)
+		w.once.Do(func() {
+			close(w.stop)
+		})
 	}
 	if stop != nil {
 		// Start informer factory, only if stop is defined. In startup case, we will not start here as
diff --git a/pilot/pkg/config/kube/gateway/controller.go b/pilot/pkg/config/kube/gateway/controller.go
index 0563f35e76..fb36c633ba 100644
--- a/pilot/pkg/config/kube/gateway/controller.go
+++ b/pilot/pkg/config/kube/gateway/controller.go
@@ -75,30 +75,17 @@ type Controller struct {
 	state   OutputResources
 	stateMu sync.RWMutex
 
-	// status controls the status working queue. Status will only be written if statusEnabled is true, which
+	// statusController controls the status working queue. Status will only be written if statusEnabled is true, which
 	// is only the case when we are the leader.
-	status        status.WorkerQueue
-	statusEnabled *atomic.Bool
+	statusController *status.Controller
+	statusEnabled    *atomic.Bool
 }
 
 var _ model.GatewayController = &Controller{}
 
 func NewController(client kube.Client, c model.ConfigStoreCache, options controller.Options) *Controller {
-	var statusQueue status.WorkerQueue
-	if features.EnableGatewayAPIStatus {
-		statusQueue = status.NewWorkerPool(func(resource status.Resource, resourceStatus status.ResourceStatus) {
-			log.Debugf("updating status for %v", resource.String())
-			_, err := c.UpdateStatus(config.Config{
-				// TODO stop round tripping this status.Resource<->config.Meta
-				Meta:   status.ResourceToModelConfig(resource),
-				Status: resourceStatus.(config.Status),
-			})
-			if err != nil {
-				// TODO should we requeue or wait for another event to trigger an update?
-				log.Errorf("failed to update status for %v/: %v", resource.String(), err)
-			}
-		}, uint(features.StatusMaxWorkers))
-	}
+	var ctl *status.Controller
+
 	nsInformer := client.KubeInformer().Core().V1().Namespaces().Informer()
 	gatewayController := &Controller{
 		client:            client,
@@ -106,7 +93,7 @@ func NewController(client kube.Client, c model.ConfigStoreCache, options control
 		namespaceLister:   client.KubeInformer().Core().V1().Namespaces().Lister(),
 		namespaceInformer: nsInformer,
 		domain:            options.DomainSuffix,
-		status:            statusQueue,
+		statusController:  ctl,
 		// Disabled by default, we will enable only if we win the leader election
 		statusEnabled: atomic.NewBool(false),
 	}
@@ -151,8 +138,15 @@ func (c *Controller) List(typ config.GroupVersionKind, namespace string) ([]conf
 	}
 }
 
-func (c *Controller) SetStatusWrite(enabled bool) {
+func (c *Controller) SetStatusWrite(enabled bool, statusManager *status.Manager) {
 	c.statusEnabled.Store(enabled)
+	if enabled && features.EnableGatewayAPIStatus && statusManager != nil {
+		c.statusController = statusManager.CreateGenericController(func(status interface{}, context interface{}) status.GenerationProvider {
+			return &gatewayGeneration{context}
+		})
+	} else {
+		c.statusController = nil
+	}
 }
 
 // Recompute takes in a current snapshot of the gateway-api configs, and regenerates our internal state.
@@ -236,14 +230,14 @@ func (c *Controller) QueueStatusUpdates(r *KubernetesResources) {
 }
 
 func (c *Controller) handleStatusUpdates(configs []config.Config) {
-	if c.status == nil || !c.statusEnabled.Load() {
+	if c.statusController == nil || !c.statusEnabled.Load() {
 		return
 	}
 	for _, cfg := range configs {
 		ws := cfg.Status.(*kstatus.WrappedStatus)
 		if ws.Dirty {
 			res := status.ResourceFromModelConfig(cfg)
-			c.status.Push(res, ws.Unwrap())
+			c.statusController.EnqueueStatusUpdateResource(ws.Unwrap(), res)
 		}
 	}
 }
diff --git a/pilot/pkg/config/kube/gateway/generation_adapter.go b/pilot/pkg/config/kube/gateway/generation_adapter.go
new file mode 100644
index 0000000000..5b04b2d05a
--- /dev/null
+++ b/pilot/pkg/config/kube/gateway/generation_adapter.go
@@ -0,0 +1,32 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package gateway
+
+type gatewayGeneration struct {
+	inner interface{}
+}
+
+func (g *gatewayGeneration) SetObservedGeneration(i int64) {
+	// Intentionally blank.  The observed generation of a gateway
+	// status type is contained in the individual conditions
+	// not at the top level, and is the responsibility
+	// of the condition functions to update.
+}
+
+func (g *gatewayGeneration) Unwrap() interface{} {
+	return g.inner
+}
diff --git a/pilot/pkg/networking/apigen/apigen.go b/pilot/pkg/networking/apigen/apigen.go
index 04926765a2..dd918b1de6 100644
--- a/pilot/pkg/networking/apigen/apigen.go
+++ b/pilot/pkg/networking/apigen/apigen.go
@@ -21,7 +21,6 @@
 	gogotypes "github.com/gogo/protobuf/types"
 	golangany "google.golang.org/protobuf/types/known/anypb"
 
-	mcp "istio.io/api/mcp/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pilot/pkg/serviceregistry/serviceentry"
@@ -114,7 +113,7 @@ func (g *APIGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *
 		// Right now model.Config is not a proto - until we change it, mcp.Resource.
 		// This also helps migrating MCP users.
 
-		b, err := configToResource(&c)
+		b, err := config.PilotConfigToResource(&c)
 		if err != nil {
 			log.Warn("Resource error ", err, " ", c.Namespace, "/", c.Name)
 			continue
@@ -146,7 +145,7 @@ func (g *APIGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *
 				continue
 			}
 			c := serviceentry.ServiceToServiceEntry(s, proxy)
-			b, err := configToResource(c)
+			b, err := config.PilotConfigToResource(c)
 			if err != nil {
 				log.Warn("Resource error ", err, " ", c.Namespace, "/", c.Name)
 				continue
@@ -169,30 +168,3 @@ func (g *APIGenerator) Generate(proxy *model.Proxy, push *model.PushContext, w *
 
 	return resp, model.DefaultXdsLogDetails, nil
 }
-
-// Convert from model.Config, which has no associated proto, to MCP Resource proto.
-// TODO: define a proto matching Config - to avoid useless superficial conversions.
-func configToResource(c *config.Config) (*mcp.Resource, error) {
-	r := &mcp.Resource{}
-
-	// MCP, K8S and Istio configs use gogo configs
-	// On the wire it's the same as golang proto.
-	a, err := config.ToProtoGogo(c.Spec)
-	if err != nil {
-		return nil, err
-	}
-	r.Body = a
-	ts, err := gogotypes.TimestampProto(c.CreationTimestamp)
-	if err != nil {
-		return nil, err
-	}
-	r.Metadata = &mcp.Metadata{
-		Name:        c.Namespace + "/" + c.Name,
-		CreateTime:  ts,
-		Version:     c.ResourceVersion,
-		Labels:      c.Labels,
-		Annotations: c.Annotations,
-	}
-
-	return r, nil
-}
diff --git a/pilot/pkg/status/leak_test.go b/pilot/pkg/status/distribution/leak_test.go
similarity index 97%
rename from pilot/pkg/status/leak_test.go
rename to pilot/pkg/status/distribution/leak_test.go
index 0074b39b2e..9185a81f90 100644
--- a/pilot/pkg/status/leak_test.go
+++ b/pilot/pkg/status/distribution/leak_test.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"testing"
diff --git a/pilot/pkg/status/ledger.go b/pilot/pkg/status/distribution/ledger.go
similarity index 98%
rename from pilot/pkg/status/ledger.go
rename to pilot/pkg/status/distribution/ledger.go
index 52457b7f25..f2c5433468 100644
--- a/pilot/pkg/status/ledger.go
+++ b/pilot/pkg/status/distribution/ledger.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"strconv"
diff --git a/galley/pkg/config/mesh/defaults_test.go b/pilot/pkg/status/distribution/report.go
similarity index 62%
rename from galley/pkg/config/mesh/defaults_test.go
rename to pilot/pkg/status/distribution/report.go
index f5526ae831..33a26af534 100644
--- a/galley/pkg/config/mesh/defaults_test.go
+++ b/pilot/pkg/status/distribution/report.go
@@ -12,23 +12,20 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package mesh
+package distribution
 
 import (
-	"testing"
-
-	. "github.com/onsi/gomega"
-
-	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/pkg/config/mesh"
+	"gopkg.in/yaml.v2"
 )
 
-func TestDefaults(t *testing.T) {
-	g := NewWithT(t)
+type Report struct {
+	Reporter            string         `json:"reporter"`
+	DataPlaneCount      int            `json:"dataPlaneCount"`
+	InProgressResources map[string]int `json:"inProgressResources"`
+}
 
-	m := DefaultMeshConfig()
-	expect := mesh.DefaultMeshConfig()
-	expect.IngressClass = "istio"
-	expect.IngressControllerMode = v1alpha1.MeshConfig_STRICT
-	g.Expect(*m).To(Equal(expect))
+func ReportFromYaml(content []byte) (Report, error) {
+	out := Report{}
+	err := yaml.Unmarshal(content, &out)
+	return out, err
 }
diff --git a/pilot/pkg/status/report_test.go b/pilot/pkg/status/distribution/report_test.go
similarity index 91%
rename from pilot/pkg/status/report_test.go
rename to pilot/pkg/status/distribution/report_test.go
index 10d4e30f27..b32fd03693 100644
--- a/pilot/pkg/status/report_test.go
+++ b/pilot/pkg/status/distribution/report_test.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"reflect"
@@ -20,14 +20,16 @@
 
 	"github.com/onsi/gomega"
 	"gopkg.in/yaml.v2"
+
+	"istio.io/istio/pilot/pkg/status"
 )
 
 func TestReportSerialization(t *testing.T) {
-	in := DistributionReport{
+	in := Report{
 		Reporter:       "Me",
 		DataPlaneCount: 10,
 		InProgressResources: map[string]int{
-			(&Resource{
+			(&status.Resource{
 				Name:      "water",
 				Namespace: "default",
 			}).String(): 1,
@@ -36,7 +38,7 @@ func TestReportSerialization(t *testing.T) {
 	outbytes, err := yaml.Marshal(in)
 	gomega.RegisterTestingT(t)
 	gomega.Expect(err).To(gomega.BeNil())
-	out := DistributionReport{}
+	out := Report{}
 	err = yaml.Unmarshal(outbytes, &out)
 	gomega.Expect(err).To(gomega.BeNil())
 	if !reflect.DeepEqual(out, in) {
diff --git a/pilot/pkg/status/reporter.go b/pilot/pkg/status/distribution/reporter.go
similarity index 95%
rename from pilot/pkg/status/reporter.go
rename to pilot/pkg/status/distribution/reporter.go
index a17bca5030..689cb85f51 100644
--- a/pilot/pkg/status/reporter.go
+++ b/pilot/pkg/status/distribution/reporter.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"context"
@@ -28,6 +28,7 @@
 	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
 	"k8s.io/utils/clock"
 
+	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config"
 	"istio.io/pkg/ledger"
@@ -38,18 +39,9 @@ func GenStatusReporterMapKey(conID string, distributionType xds.EventType) strin
 	return key
 }
 
-func NewIstioContext(stop <-chan struct{}) context.Context {
-	ctx, cancel := context.WithCancel(context.Background())
-	go func() {
-		<-stop
-		cancel()
-	}()
-	return ctx
-}
-
 type inProgressEntry struct {
 	// the resource, including resourceVersion, we are currently tracking
-	Resource
+	status.Resource
 	// the number of reports we have written with this resource at 100%
 	completedIterations int
 }
@@ -69,7 +61,7 @@ type Reporter struct {
 	clock                  clock.Clock
 	ledger                 ledger.Ledger
 	distributionEventQueue chan distributionEvent
-	controller             *DistributionController
+	controller             *Controller
 }
 
 var _ xds.DistributionStatusCache = &Reporter{}
@@ -106,7 +98,7 @@ func (r *Reporter) Start(clientSet kubernetes.Interface, namespace string, podna
 		Data: make(map[string]string),
 	}
 	t := r.clock.Tick(r.UpdateInterval)
-	ctx := NewIstioContext(stop)
+	ctx := status.NewIstioContext(stop)
 	x, err := clientSet.CoreV1().Pods(namespace).Get(ctx, podname, metav1.GetOptions{})
 	if err != nil {
 		scope.Errorf("can't identify pod %s context: %s", podname, err)
@@ -136,11 +128,11 @@ func (r *Reporter) Start(clientSet kubernetes.Interface, namespace string, podna
 }
 
 // build a distribution report to send to status leader
-func (r *Reporter) buildReport() (DistributionReport, []Resource) {
+func (r *Reporter) buildReport() (Report, []status.Resource) {
 	r.mu.RLock()
 	defer r.mu.RUnlock()
-	var finishedResources []Resource
-	out := DistributionReport{
+	var finishedResources []status.Resource
+	out := Report{
 		Reporter:            r.PodName,
 		DataPlaneCount:      len(r.status),
 		InProgressResources: map[string]int{},
@@ -181,10 +173,10 @@ func (r *Reporter) buildReport() (DistributionReport, []Resource) {
 
 // For efficiency, we don't want to be checking on resources that have already reached 100% distribution.
 // When this happens, we remove them from our watch list.
-func (r *Reporter) removeCompletedResource(completedResources []Resource) {
+func (r *Reporter) removeCompletedResource(completedResources []status.Resource) {
 	r.mu.Lock()
 	defer r.mu.Unlock()
-	var toDelete []Resource
+	var toDelete []status.Resource
 	for _, item := range completedResources {
 		// TODO: handle cache miss
 		// if cache miss, need to skip current loop, otherwise is will cause errors like
@@ -210,8 +202,8 @@ func (r *Reporter) removeCompletedResource(completedResources []Resource) {
 // only the resources we expect to be in flight, not the ones that have already distributed
 func (r *Reporter) AddInProgressResource(res config.Config) {
 	tryLedgerPut(r.ledger, res)
-	myRes := ResourceFromModelConfig(res)
-	if myRes == (Resource{}) {
+	myRes := status.ResourceFromModelConfig(res)
+	if myRes == (status.Resource{}) {
 		scope.Errorf("Unable to locate schema for %v, will not update status.", res)
 		return
 	}
@@ -353,6 +345,6 @@ func (r *Reporter) RegisterDisconnect(conID string, types []xds.EventType) {
 	}
 }
 
-func (r *Reporter) SetController(controller *DistributionController) {
+func (r *Reporter) SetController(controller *Controller) {
 	r.controller = controller
 }
diff --git a/pilot/pkg/status/reporter_test.go b/pilot/pkg/status/distribution/reporter_test.go
similarity index 96%
rename from pilot/pkg/status/reporter_test.go
rename to pilot/pkg/status/distribution/reporter_test.go
index 10a65c9d2e..ce05881039 100644
--- a/pilot/pkg/status/reporter_test.go
+++ b/pilot/pkg/status/distribution/reporter_test.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"testing"
@@ -21,6 +21,7 @@
 	. "github.com/onsi/gomega"
 	"k8s.io/utils/clock"
 
+	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -86,12 +87,12 @@ func TestBuildReport(t *testing.T) {
 		},
 	}
 	// cast our model.Configs to Resource because these types aren't compatible
-	var myResources []Resource
+	var myResources []status.Resource
 	col := collections.IstioNetworkingV1Alpha3Virtualservices.Resource()
 	for _, res := range resources {
 		// Set Group Version and GroupVersionKind to real world values from VS
 		res.GroupVersionKind = col.GroupVersionKind()
-		myResources = append(myResources, ResourceFromModelConfig(*res))
+		myResources = append(myResources, status.ResourceFromModelConfig(*res))
 		// Add each resource to our ledger for tracking history
 		// mark each of our resources as in flight so they are included in the report.
 		r.AddInProgressResource(*res)
diff --git a/galley/pkg/config/processing/snapshotter/strategy/scope.go b/pilot/pkg/status/distribution/resourcelock.go
similarity index 85%
rename from galley/pkg/config/processing/snapshotter/strategy/scope.go
rename to pilot/pkg/status/distribution/resourcelock.go
index 5b0a53f367..c66b82ad0b 100644
--- a/galley/pkg/config/processing/snapshotter/strategy/scope.go
+++ b/pilot/pkg/status/distribution/resourcelock.go
@@ -12,10 +12,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package strategy
+package distribution
 
-import (
-	"istio.io/pkg/log"
-)
-
-var scope = log.RegisterScope("processing", "", 0)
+type ResourceStatus interface{}
diff --git a/pilot/pkg/status/state.go b/pilot/pkg/status/distribution/state.go
similarity index 61%
rename from pilot/pkg/status/state.go
rename to pilot/pkg/status/distribution/state.go
index d4b549b1ba..75080da619 100644
--- a/pilot/pkg/status/state.go
+++ b/pilot/pkg/status/distribution/state.go
@@ -12,12 +12,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"fmt"
-	"strconv"
-	"strings"
 	"sync"
 	"time"
 
@@ -35,8 +33,8 @@
 	"istio.io/api/meta/v1alpha1"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/pkg/log"
 )
 
@@ -53,27 +51,34 @@ func (p *Progress) PlusEquals(p2 Progress) {
 	p.AckedInstances += p2.AckedInstances
 }
 
-type DistributionController struct {
+type Controller struct {
 	configStore     model.ConfigStore
 	mu              sync.RWMutex
-	CurrentState    map[Resource]map[string]Progress
+	CurrentState    map[status.Resource]map[string]Progress
 	ObservationTime map[string]time.Time
 	UpdateInterval  time.Duration
 	dynamicClient   dynamic.Interface
 	clock           clock.Clock
-	workers         WorkerQueue
+	workers         *status.Controller
 	StaleInterval   time.Duration
 	cmInformer      cache.SharedIndexInformer
 }
 
-func NewController(restConfig *rest.Config, namespace string, cs model.ConfigStore) *DistributionController {
-	c := &DistributionController{
-		CurrentState:    make(map[Resource]map[string]Progress),
+func NewController(restConfig *rest.Config, namespace string, cs model.ConfigStore, m *status.Manager) *Controller {
+	c := &Controller{
+		CurrentState:    make(map[status.Resource]map[string]Progress),
 		ObservationTime: make(map[string]time.Time),
 		UpdateInterval:  200 * time.Millisecond,
 		StaleInterval:   time.Minute,
 		clock:           clock.RealClock{},
 		configStore:     cs,
+		workers: m.CreateIstioStatusController(func(status *v1alpha1.IstioStatus, context interface{}) *v1alpha1.IstioStatus {
+			distributionState := context.(Progress)
+			if needsReconcile, desiredStatus := ReconcileStatuses(status, distributionState); needsReconcile {
+				return desiredStatus
+			}
+			return status
+		}),
 	}
 
 	// client-go defaults to 5 QPS, with 10 Boost, which is insufficient for updating status on all the config
@@ -98,18 +103,13 @@ func NewController(restConfig *rest.Config, namespace string, cs model.ConfigSto
 	return c
 }
 
-func (c *DistributionController) Start(stop <-chan struct{}) {
+func (c *Controller) Start(stop <-chan struct{}) {
 	scope.Info("Starting status leader controller")
 
 	// this will list all existing configmaps, as well as updates, right?
-	ctx := NewIstioContext(stop)
+	ctx := status.NewIstioContext(stop)
 	go c.cmInformer.Run(ctx.Done())
 
-	c.workers = NewProgressWorkerPool(func(resource Resource, progress Progress) {
-		c.writeStatus(resource, progress)
-	}, uint(features.StatusMaxWorkers))
-	c.workers.Run(ctx)
-
 	//  create Status Writer
 	t := c.clock.Tick(c.UpdateInterval)
 
@@ -128,11 +128,11 @@ func (c *DistributionController) Start(stop <-chan struct{}) {
 	}()
 }
 
-func (c *DistributionController) handleReport(d DistributionReport) {
+func (c *Controller) handleReport(d Report) {
 	defer c.mu.Unlock()
 	c.mu.Lock()
 	for resstr := range d.InProgressResources {
-		res := *ResourceFromString(resstr)
+		res := *status.ResourceFromString(resstr)
 		if _, ok := c.CurrentState[res]; !ok {
 			c.CurrentState[res] = make(map[string]Progress)
 		}
@@ -141,7 +141,7 @@ func (c *DistributionController) handleReport(d DistributionReport) {
 	c.ObservationTime[d.Reporter] = c.clock.Now()
 }
 
-func (c *DistributionController) writeAllStatus() (staleReporters []string) {
+func (c *Controller) writeAllStatus() (staleReporters []string) {
 	defer c.mu.RUnlock()
 	c.mu.RLock()
 	for config, fractions := range c.CurrentState {
@@ -163,50 +163,13 @@ func (c *DistributionController) writeAllStatus() (staleReporters []string) {
 	return
 }
 
-func (c *DistributionController) writeStatus(config Resource, distributionState Progress) {
-	schema, _ := collections.All.FindByGroupVersionResource(config.GroupVersionResource)
-	if schema == nil {
-		scope.Warnf("schema %v could not be identified", schema)
-		c.pruneOldVersion(config)
-		return
-	}
-	if !strings.HasSuffix(schema.Resource().Group(), "istio.io") {
-		// we don't write status for objects we don't own
-		return
-	}
-	current := c.configStore.Get(schema.Resource().GroupVersionKind(), config.Name, config.Namespace)
-	if current == nil {
-		scope.Warnf("config store missing entry %v, status will not update", config)
-		// this happens when resources are rapidly deleted, such as the validation-readiness checker
-		c.pruneOldVersion(config)
-		return
-	}
-	if config.Generation != strconv.FormatInt(current.Generation, 10) {
-		// this distribution report is for an old version of the object.  Prune and continue.
-		c.pruneOldVersion(config)
-		return
-	}
-
-	// check if status needs updating
-	if needsReconcile, desiredStatus := ReconcileStatuses(current, distributionState, current.Generation); needsReconcile {
-		// technically, we should be updating probe time even when reconciling isn't needed, but
-		// I'm skipping that for efficiency.
-		current.Status = desiredStatus
-		_, err := c.configStore.UpdateStatus(*current)
-		if err != nil {
-			scope.Errorf("Encountered unexpected error updating status for %v, will try again later: %s", config, err)
-			return
-		}
-	}
-}
-
-func (c *DistributionController) pruneOldVersion(config Resource) {
+func (c *Controller) pruneOldVersion(config status.Resource) {
 	defer c.mu.Unlock()
 	c.mu.Lock()
 	delete(c.CurrentState, config)
 }
 
-func (c *DistributionController) removeStaleReporters(staleReporters []string) {
+func (c *Controller) removeStaleReporters(staleReporters []string) {
 	defer c.mu.Unlock()
 	c.mu.Lock()
 	for key, fractions := range c.CurrentState {
@@ -217,22 +180,15 @@ func (c *DistributionController) removeStaleReporters(staleReporters []string) {
 	}
 }
 
-func (c *DistributionController) queueWriteStatus(config Resource, state Progress) {
-	c.workers.Push(config, state)
+func (c *Controller) queueWriteStatus(config status.Resource, state Progress) {
+	c.workers.EnqueueStatusUpdateResource(state, config)
 }
 
-func (c *DistributionController) configDeleted(res config.Config) {
-	r := ResourceFromModelConfig(res)
+func (c *Controller) configDeleted(res config.Config) {
+	r := status.ResourceFromModelConfig(res)
 	c.workers.Delete(r)
 }
 
-func GetTypedStatus(in interface{}) (out *v1alpha1.IstioStatus, err error) {
-	if ret, ok := in.(*v1alpha1.IstioStatus); ok {
-		return ret, nil
-	}
-	return nil, fmt.Errorf("cannot cast %T: %v to IstioStatus", in, in)
-}
-
 func boolToConditionStatus(b bool) string {
 	if b {
 		return "True"
@@ -240,9 +196,8 @@ func boolToConditionStatus(b bool) string {
 	return "False"
 }
 
-func ReconcileStatuses(current *config.Config, desired Progress, generation int64) (bool, *v1alpha1.IstioStatus) {
+func ReconcileStatuses(current *v1alpha1.IstioStatus, desired Progress) (bool, *v1alpha1.IstioStatus) {
 	needsReconcile := false
-	currentStatus, err := GetTypedStatus(current.Status)
 	desiredCondition := v1alpha1.IstioCondition{
 		Type:               "Reconciled",
 		Status:             boolToConditionStatus(desired.AckedInstances == desired.TotalInstances),
@@ -250,25 +205,12 @@ func ReconcileStatuses(current *config.Config, desired Progress, generation int6
 		LastTransitionTime: types.TimestampNow(),
 		Message:            fmt.Sprintf("%d/%d proxies up to date.", desired.AckedInstances, desired.TotalInstances),
 	}
-	if err != nil {
-		// the status field is in an unexpected state.
-		if scope.DebugEnabled() {
-			scope.Debugf("Encountered unexpected status content.  Overwriting status: %v", current.Status)
-		} else {
-			scope.Warn("Encountered unexpected status content.  Overwriting status.")
-		}
-		currentStatus = &v1alpha1.IstioStatus{
-			Conditions: []*v1alpha1.IstioCondition{&desiredCondition},
-		}
-		currentStatus.ObservedGeneration = generation
-		return true, currentStatus
-	}
-	currentStatus = currentStatus.DeepCopy()
+	current = current.DeepCopy()
 	var currentCondition *v1alpha1.IstioCondition
 	conditionIndex := -1
-	for i, c := range currentStatus.Conditions {
+	for i, c := range current.Conditions {
 		if c.Type == "Reconciled" {
-			currentCondition = currentStatus.Conditions[i]
+			currentCondition = current.Conditions[i]
 			conditionIndex = i
 			break
 		}
@@ -279,16 +221,15 @@ func ReconcileStatuses(current *config.Config, desired Progress, generation int6
 		needsReconcile = true
 	}
 	if conditionIndex > -1 {
-		currentStatus.Conditions[conditionIndex] = &desiredCondition
+		current.Conditions[conditionIndex] = &desiredCondition
 	} else {
-		currentStatus.Conditions = append(currentStatus.Conditions, &desiredCondition)
+		current.Conditions = append(current.Conditions, &desiredCondition)
 	}
-	currentStatus.ObservedGeneration = generation
-	return needsReconcile, currentStatus
+	return needsReconcile, current
 }
 
 type DistroReportHandler struct {
-	dc *DistributionController
+	dc *Controller
 }
 
 func (drh *DistroReportHandler) OnAdd(obj interface{}) {
diff --git a/pilot/pkg/status/state_test.go b/pilot/pkg/status/distribution/state_test.go
similarity index 86%
rename from pilot/pkg/status/state_test.go
rename to pilot/pkg/status/distribution/state_test.go
index bcae408459..ac478ead15 100644
--- a/pilot/pkg/status/state_test.go
+++ b/pilot/pkg/status/distribution/state_test.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package status
+package distribution
 
 import (
 	"encoding/json"
@@ -20,6 +20,7 @@
 	"testing"
 
 	"istio.io/api/meta/v1alpha1"
+	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pkg/config"
 )
 
@@ -78,7 +79,6 @@ type args struct {
 					},
 				},
 				ValidationMessages: nil,
-				ObservedGeneration: int64(1234),
 			},
 		}, {
 			name: "Simple Reconcile to false",
@@ -101,24 +101,6 @@ type args struct {
 					},
 				},
 				ValidationMessages: nil,
-				ObservedGeneration: int64(1234),
-			},
-		}, {
-			name: "Graceful handling of random status",
-			args: args{
-				current: &config.Config{Status: "random"},
-				desired: Progress{2, 2},
-			},
-			want: true,
-			want1: &v1alpha1.IstioStatus{
-				Conditions: []*v1alpha1.IstioCondition{
-					{
-						Type:    "Reconciled",
-						Status:  "True",
-						Message: "2/2 proxies up to date.",
-					},
-				},
-				ObservedGeneration: int64(1234),
 			},
 		}, {
 			name: "Reconcile for message difference",
@@ -140,13 +122,12 @@ type args struct {
 						Message: "2/3 proxies up to date.",
 					},
 				},
-				ObservedGeneration: int64(1234),
 			},
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			got, got1 := ReconcileStatuses(tt.args.current, tt.args.desired, int64(1234))
+			got, got1 := ReconcileStatuses(tt.args.current.Status.(*v1alpha1.IstioStatus), tt.args.desired)
 			if got != tt.want {
 				t.Errorf("ReconcileStatuses() got = %v, want %v", got, tt.want)
 			}
@@ -186,7 +167,7 @@ type args struct {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			gotOut, err := GetTypedStatus(tt.args.in)
+			gotOut, err := status.GetTypedStatus(tt.args.in)
 			if (err != nil) != tt.wantErr {
 				t.Errorf("GetTypedStatus() error = %v, wantErr %v", err, tt.wantErr)
 				return
diff --git a/pilot/pkg/status/manager.go b/pilot/pkg/status/manager.go
new file mode 100644
index 0000000000..7c2723d37c
--- /dev/null
+++ b/pilot/pkg/status/manager.go
@@ -0,0 +1,125 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package status
+
+import (
+	"istio.io/api/meta/v1alpha1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collections"
+)
+
+// Manager allows multiple controllers to provide input into configuration
+// status without needlessly doubling the number of writes, or overwriting
+// one another.  Each status controller calls newController, passing in
+// an arbitrary status modification function, and then calls EnqueueStatusUpdate
+// when an individual resource is ready to be updated with the relevant data.
+type Manager struct {
+	// TODO: is Resource the right abstraction?
+	store   model.ConfigStore
+	workers WorkerQueue
+}
+
+func NewManager(store model.ConfigStore) *Manager {
+	writeFunc := func(m *config.Config, istatus interface{}) {
+		scope.Debugf("writing status for resource %s/%s", m.Namespace, m.Name)
+		status := istatus.(GenerationProvider)
+		m.Status = status.Unwrap()
+		_, err := store.UpdateStatus(*m)
+		if err != nil {
+			// TODO: need better error handling
+			scope.Errorf("Encountered unexpected error updating status for %v, will try again later: %s", m, err)
+			return
+		}
+	}
+	retrieveFunc := func(resource Resource) *config.Config {
+		scope.Debugf("retrieving config for status update: %s/%s", resource.Namespace, resource.Name)
+		schema, _ := collections.All.FindByGroupVersionResource(resource.GroupVersionResource)
+		if schema == nil {
+			scope.Warnf("schema %v could not be identified", schema)
+			return nil
+		}
+
+		current := store.Get(schema.Resource().GroupVersionKind(), resource.Name, resource.Namespace)
+		return current
+	}
+	return &Manager{
+		store:   store,
+		workers: NewWorkerPool(writeFunc, retrieveFunc, uint(features.StatusMaxWorkers)),
+	}
+}
+
+func (m *Manager) Start(stop <-chan struct{}) {
+	scope.Info("Starting status manager")
+
+	ctx := NewIstioContext(stop)
+	m.workers.Run(ctx)
+}
+
+// CreateGenericController provides an interface for a status update function to be
+// called in series with other controllers, minimizing the number of actual
+// api server writes sent from various status controllers.  The UpdateFunc
+// must take the target resrouce status and arbitrary context information as
+// parameters, and return the updated status value.  Multiple controllers
+// will be called in series, so the input status may not have been written
+// to the API server yet, and the output status may be modified by other
+// controllers before it is written to the server.
+func (m *Manager) CreateGenericController(fn UpdateFunc) *Controller {
+	result := &Controller{
+		fn:      fn,
+		workers: m.workers,
+	}
+	return result
+}
+
+func (m *Manager) CreateIstioStatusController(fn func(status *v1alpha1.IstioStatus, context interface{}) *v1alpha1.IstioStatus) *Controller {
+	wrapper := func(status interface{}, context interface{}) GenerationProvider {
+		var input *v1alpha1.IstioStatus
+		if status != nil {
+			converted := status.(*IstioGenerationProvider)
+			input = converted.IstioStatus
+		}
+		result := fn(input, context)
+		return &IstioGenerationProvider{result}
+	}
+	result := &Controller{
+		fn:      wrapper,
+		workers: m.workers,
+	}
+	return result
+}
+
+type UpdateFunc func(status interface{}, context interface{}) GenerationProvider
+
+type Controller struct {
+	fn      UpdateFunc
+	workers WorkerQueue
+}
+
+// EnqueueStatusUpdateResource informs the manager that this controller would like to
+// update the status of target, using the information in context.  Once the status
+// workers are ready to perform this update, the controller's UpdateFunc
+// will be called with target and context as input.
+func (c *Controller) EnqueueStatusUpdateResource(context interface{}, target Resource) {
+	// TODO: buffer this with channel
+	c.workers.Push(target, c, context)
+}
+
+func (c *Controller) Delete(r Resource) {
+	c.workers.Delete(r)
+}
diff --git a/pilot/pkg/status/report.go b/pilot/pkg/status/resource.go
similarity index 50%
rename from pilot/pkg/status/report.go
rename to pilot/pkg/status/resource.go
index d177aab116..16d406f1e8 100644
--- a/pilot/pkg/status/report.go
+++ b/pilot/pkg/status/resource.go
@@ -1,41 +1,38 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
 
 package status
 
 import (
+	"context"
+	"fmt"
 	"strconv"
 	"strings"
 
-	"gopkg.in/yaml.v2"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 
+	"istio.io/api/meta/v1alpha1"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/pkg/log"
 )
 
-type DistributionReport struct {
-	Reporter            string         `json:"reporter"`
-	DataPlaneCount      int            `json:"dataPlaneCount"`
-	InProgressResources map[string]int `json:"inProgressResources"`
-}
-
-func ReportFromYaml(content []byte) (DistributionReport, error) {
-	out := DistributionReport{}
-	err := yaml.Unmarshal(content, &out)
-	return out, err
-}
+var scope = log.RegisterScope("status",
+	"status controller for istio", 0)
 
 func ResourceFromString(s string) *Resource {
 	pieces := strings.Split(s, "/")
@@ -58,14 +55,13 @@ func ResourceFromString(s string) *Resource {
 // TODO: maybe replace with a kubernetes resource identifier, if that's a thing
 type Resource struct {
 	schema.GroupVersionResource
-	Namespace       string
-	Name            string
-	Generation      string
-	ResourceVersion string
+	Namespace  string
+	Name       string
+	Generation string
 }
 
 func (r Resource) String() string {
-	return strings.Join([]string{r.Group, r.Version, r.Resource, r.Namespace, r.Name, r.Generation}, "/")
+	return strings.Join([]string{r.Group, r.Version, r.GroupVersionResource.Resource, r.Namespace, r.Name, r.Generation}, "/")
 }
 
 func (r *Resource) ToModelKey() string {
@@ -76,6 +72,15 @@ func (r *Resource) ToModelKey() string {
 		r.Name, r.Namespace)
 }
 
+func ResourceFromMetadata(i resource.Metadata) Resource {
+	return Resource{
+		GroupVersionResource: i.Schema.GroupVersionResource(),
+		Namespace:            i.FullName.Namespace.String(),
+		Name:                 i.FullName.Name.String(),
+		Generation:           strconv.FormatInt(i.Generation, 10),
+	}
+}
+
 func ResourceFromModelConfig(c config.Config) Resource {
 	gvr := GVKtoGVR(c.GroupVersionKind)
 	if gvr == nil {
@@ -86,20 +91,38 @@ func ResourceFromModelConfig(c config.Config) Resource {
 		Namespace:            c.Namespace,
 		Name:                 c.Name,
 		Generation:           strconv.FormatInt(c.Generation, 10),
-		ResourceVersion:      c.ResourceVersion,
 	}
 }
 
 func ResourceToModelConfig(c Resource) config.Meta {
 	gvk := GVRtoGVK(c.GroupVersionResource)
+	gen, err := strconv.Atoi(c.Generation)
+	if err != nil {
+		log.Errorf("failed to convert resource generation %s to int: %s", c.Generation, err)
+		return config.Meta{}
+	}
 	return config.Meta{
 		GroupVersionKind: gvk,
 		Namespace:        c.Namespace,
 		Name:             c.Name,
-		ResourceVersion:  c.ResourceVersion,
+		Generation:       int64(gen),
 	}
 }
 
+func GetTypedStatus(in interface{}) (out *v1alpha1.IstioStatus, err error) {
+	if ret, ok := in.(*v1alpha1.IstioStatus); ok {
+		return ret, nil
+	}
+	return nil, fmt.Errorf("cannot cast %T: %v to IstioStatus", in, in)
+}
+
+func GetOGProvider(in interface{}) (out GenerationProvider, err error) {
+	if ret, ok := in.(*v1alpha1.IstioStatus); ok {
+		return &IstioGenerationProvider{ret}, nil
+	}
+	return nil, fmt.Errorf("cannot cast %T: %v to GenerationProvider", in, in)
+}
+
 func GVKtoGVR(in config.GroupVersionKind) *schema.GroupVersionResource {
 	found, ok := collections.All.FindByGroupVersionKind(in)
 	if !ok {
@@ -119,3 +142,12 @@ func GVRtoGVK(in schema.GroupVersionResource) config.GroupVersionKind {
 	}
 	return found.Resource().GroupVersionKind()
 }
+
+func NewIstioContext(stop <-chan struct{}) context.Context {
+	ctx, cancel := context.WithCancel(context.Background())
+	go func() {
+		<-stop
+		cancel()
+	}()
+	return ctx
+}
diff --git a/pilot/pkg/status/resourcelock.go b/pilot/pkg/status/resourcelock.go
index bd538bdcf4..86683506ad 100644
--- a/pilot/pkg/status/resourcelock.go
+++ b/pilot/pkg/status/resourcelock.go
@@ -16,22 +16,24 @@
 
 import (
 	"context"
+	"strconv"
 	"sync"
 
 	"k8s.io/apimachinery/pkg/runtime/schema"
+
+	"istio.io/api/meta/v1alpha1"
+	"istio.io/istio/pkg/config"
 )
 
 // Task to be performed.
 type Task func(entry cacheEntry)
 
-type ResourceStatus interface{}
-
 // WorkerQueue implements an expandable goroutine pool which executes at most one concurrent routine per target
 // resource.  Multiple calls to Push() will not schedule multiple executions per target resource, but will ensure that
 // the single execution uses the latest value.
 type WorkerQueue interface {
 	// Push a task.
-	Push(target Resource, progress ResourceStatus)
+	Push(target Resource, controller *Controller, context interface{})
 	// Run the loop until a signal on the context
 	Run(ctx context.Context)
 	// Delete a task
@@ -41,8 +43,8 @@ type WorkerQueue interface {
 type cacheEntry struct {
 	// the cacheVale represents the latest version of the resource, including ResourceVersion
 	cacheResource Resource
-	// the cacheStatus represents the latest version of the ResourceStatus
-	cacheStatus ResourceStatus
+	// the perControllerStatus represents the latest version of the ResourceStatus
+	perControllerStatus map[*Controller]interface{}
 }
 
 type lockResource struct {
@@ -70,15 +72,17 @@ type WorkQueue struct {
 	OnPush func()
 }
 
-func (wq *WorkQueue) Push(target Resource, progress ResourceStatus) {
+func (wq *WorkQueue) Push(target Resource, ctl *Controller, progress interface{}) {
 	wq.lock.Lock()
 	key := convert(target)
-	_, inqueue := wq.cache[key]
-	wq.cache[key] = cacheEntry{
-		cacheResource: target,
-		cacheStatus:   progress,
-	}
-	if !inqueue {
+	if item, inqueue := wq.cache[key]; inqueue {
+		item.perControllerStatus[ctl] = progress
+		wq.cache[key] = item
+	} else {
+		wq.cache[key] = cacheEntry{
+			cacheResource:       target,
+			perControllerStatus: map[*Controller]interface{}{ctl: progress},
+		}
 		wq.tasks = append(wq.tasks, key)
 	}
 	wq.lock.Unlock()
@@ -88,7 +92,7 @@ func (wq *WorkQueue) Push(target Resource, progress ResourceStatus) {
 }
 
 // Pop returns the first item in the queue not in exclusion, along with it's latest progress
-func (wq *WorkQueue) Pop(exclusion map[lockResource]struct{}) (target Resource, progress ResourceStatus) {
+func (wq *WorkQueue) Pop(exclusion map[lockResource]struct{}) (target Resource, progress map[*Controller]interface{}) {
 	wq.lock.Lock()
 	defer wq.lock.Unlock()
 	for i := 0; i < len(wq.tasks); i++ {
@@ -99,7 +103,7 @@ func (wq *WorkQueue) Pop(exclusion map[lockResource]struct{}) (target Resource,
 			if !ok {
 				return Resource{}, nil
 			}
-			return t.cacheResource, t.cacheStatus
+			return t.cacheResource, t.perControllerStatus
 		}
 	}
 	return Resource{}, nil
@@ -122,7 +126,9 @@ type WorkerPool struct {
 	// indicates the queue is closing
 	closing bool
 	// the function which will be run for each task in queue
-	work func(Resource, ResourceStatus)
+	write func(*config.Config, interface{})
+	// the function to retrieve the initial status
+	get func(Resource) *config.Config
 	// current worker routine count
 	workerCount uint
 	// maximum worker routine count
@@ -131,16 +137,10 @@ type WorkerPool struct {
 	lock             sync.Mutex
 }
 
-func NewProgressWorkerPool(work func(Resource, Progress), maxWorkers uint) WorkerQueue {
-	untypedWork := func(r Resource, s ResourceStatus) {
-		work(r, s.(Progress))
-	}
-	return NewWorkerPool(untypedWork, maxWorkers)
-}
-
-func NewWorkerPool(work func(Resource, ResourceStatus), maxWorkers uint) WorkerQueue {
+func NewWorkerPool(write func(*config.Config, interface{}), get func(Resource) *config.Config, maxWorkers uint) WorkerQueue {
 	return &WorkerPool{
-		work:             work,
+		write:            write,
+		get:              get,
 		maxWorkers:       maxWorkers,
 		currentlyWorking: make(map[lockResource]struct{}),
 		q: WorkQueue{
@@ -155,8 +155,8 @@ func (wp *WorkerPool) Delete(target Resource) {
 	wp.q.Delete(target)
 }
 
-func (wp *WorkerPool) Push(target Resource, progress ResourceStatus) {
-	wp.q.Push(target, progress)
+func (wp *WorkerPool) Push(target Resource, controller *Controller, context interface{}) {
+	wp.q.Push(target, controller, context)
 	wp.maybeAddWorker()
 }
 
@@ -188,7 +188,7 @@ func (wp *WorkerPool) maybeAddWorker() {
 				return
 			}
 
-			target, c := wp.q.Pop(wp.currentlyWorking)
+			target, perControllerWork := wp.q.Pop(wp.currentlyWorking)
 
 			if target == (Resource{}) {
 				// continue or return?
@@ -200,11 +200,44 @@ func (wp *WorkerPool) maybeAddWorker() {
 			wp.currentlyWorking[convert(target)] = struct{}{}
 			wp.lock.Unlock()
 			// work should be done without holding the lock
-			wp.work(target, c)
-
+			cfg := wp.get(target)
+			if cfg != nil {
+				// Check that generation matches
+				if strconv.FormatInt(cfg.Generation, 10) == target.Generation {
+					var x GenerationProvider
+					x, err := GetOGProvider(cfg.Status)
+					if err != nil {
+						scope.Warnf("status has no observed generation, overwriting: %s", err)
+					} else {
+						x.SetObservedGeneration(cfg.Generation)
+					}
+					for c, i := range perControllerWork {
+						// TODO: this does not guarantee controller order.  perhaps it should?
+						x = c.fn(x, i)
+					}
+					wp.write(cfg, x)
+				}
+			}
 			wp.lock.Lock()
 			delete(wp.currentlyWorking, convert(target))
 			wp.lock.Unlock()
 		}
 	}()
 }
+
+type GenerationProvider interface {
+	SetObservedGeneration(int64)
+	Unwrap() interface{}
+}
+
+type IstioGenerationProvider struct {
+	*v1alpha1.IstioStatus
+}
+
+func (i *IstioGenerationProvider) SetObservedGeneration(in int64) {
+	i.ObservedGeneration = in
+}
+
+func (i *IstioGenerationProvider) Unwrap() interface{} {
+	return i.IstioStatus
+}
diff --git a/pilot/pkg/status/resourcelock_test.go b/pilot/pkg/status/resourcelock_test.go
index a2d55c7d7b..1fa2b1583f 100644
--- a/pilot/pkg/status/resourcelock_test.go
+++ b/pilot/pkg/status/resourcelock_test.go
@@ -21,6 +21,9 @@
 
 	. "github.com/onsi/gomega"
 	"k8s.io/apimachinery/pkg/runtime/schema"
+
+	"istio.io/api/meta/v1alpha1"
+	"istio.io/istio/pkg/config"
 )
 
 func TestResourceLock_Lock(t *testing.T) {
@@ -46,21 +49,40 @@ func TestResourceLock_Lock(t *testing.T) {
 	var runCount int32
 	x := make(chan struct{})
 	y := make(chan struct{})
-	workers := NewProgressWorkerPool(func(resource Resource, progress Progress) {
+	mgr := NewManager(nil)
+	fakefunc := func(status *v1alpha1.IstioStatus, context interface{}) *v1alpha1.IstioStatus {
 		x <- struct{}{}
 		atomic.AddInt32(&runCount, 1)
 		y <- struct{}{}
+		return nil
+	}
+	c1 := mgr.CreateIstioStatusController(fakefunc)
+	c2 := mgr.CreateIstioStatusController(fakefunc)
+	workers := NewWorkerPool(func(_ *config.Config, _ interface{}) {
+	}, func(resource Resource) *config.Config {
+		return &config.Config{
+			Meta: config.Meta{Generation: 11},
+		}
 	}, 10)
 	ctx, cancel := context.WithCancel(context.Background())
 	workers.Run(ctx)
-	workers.Push(r1, Progress{1, 1})
+	workers.Push(r1, c1, nil)
+	workers.Push(r1, c2, nil)
+	workers.Push(r1, c1, nil)
 	<-x
-	workers.Push(r1, Progress{2, 2})
-	workers.Push(r1a, Progress{3, 3})
 	<-y
 	<-x
+	workers.Push(r1, c1, nil)
+	workers.Push(r1a, c1, nil)
+	<-y
+	<-x
+	select {
+	case <-x:
+		t.FailNow()
+	default:
+	}
 	<-y
 	result := atomic.LoadInt32(&runCount)
-	g.Expect(result).To(Equal(int32(2)))
+	g.Expect(result).To(Equal(int32(3)))
 	cancel()
 }
diff --git a/galley/pkg/config/analysis/README.md b/pkg/config/analysis/README.md
similarity index 100%
rename from galley/pkg/config/analysis/README.md
rename to pkg/config/analysis/README.md
diff --git a/galley/pkg/config/analysis/analyzer.go b/pkg/config/analysis/analyzer.go
diff --git a/galley/pkg/config/analysis/analyzer.go b/pkg/config/analysis/analyzer.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzer.go
rename to pkg/config/analysis/analyzer.go
index 06f05fafcb..0a7509eede 100644
--- a/galley/pkg/config/analysis/analyzer.go
+++ b/pkg/config/analysis/analyzer.go
@@ -15,8 +15,8 @@
 package analysis
 
 import (
-	"istio.io/istio/galley/pkg/config/processing/transformer"
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis/scope"
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
@@ -67,15 +67,12 @@ func (c *CombinedAnalyzer) Analyze(ctx Context) {
 // Transformer information is used to determine, based on the disabled input collections, which output collections
 // should be disabled. Any analyzers that require those output collections will be removed.
 // 2. The analyzer requires a collection not available in the current snapshot(s)
-func (c *CombinedAnalyzer) RemoveSkipped(colsInSnapshots, disabledInputs collection.Names, xformProviders transformer.Providers) []string {
+func (c *CombinedAnalyzer) RemoveSkipped(colsInSnapshots collection.Schemas, disabledInputs collection.Names, xformProviders transformer.Providers) []string {
 	disabledOutputs := getDisabledOutputs(disabledInputs, xformProviders)
 	var enabled []Analyzer
 	var removedNames []string
 
-	snapshotCols := make(map[collection.Name]bool)
-	for _, col := range colsInSnapshots {
-		snapshotCols[col] = true
-	}
+	snapshotCols := ContainmentMap(colsInSnapshots)
 
 mainloop:
 	for _, a := range c.analyzers {
diff --git a/galley/pkg/config/analysis/analyzer_test.go b/pkg/config/analysis/analyzer_test.go
similarity index 78%
rename from galley/pkg/config/analysis/analyzer_test.go
rename to pkg/config/analysis/analyzer_test.go
index 5d9b0597da..b496c12726 100644
--- a/galley/pkg/config/analysis/analyzer_test.go
+++ b/pkg/config/analysis/analyzer_test.go
@@ -19,10 +19,11 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/processing/transformer"
+	"istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/event"
+	util "istio.io/istio/pkg/config/legacy/processing"
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	resource2 "istio.io/istio/pkg/config/schema/resource"
@@ -73,8 +74,13 @@ func TestCombinedAnalyzer(t *testing.T) {
 	a := Combine("combined", a1, a2, a3, a4)
 	g.Expect(a.Metadata().Inputs).To(ConsistOf(col1.Name(), col2.Name(), col3.Name(), col4.Name()))
 
+	avalableSchemas := collection.NewSchemasBuilder()
+	avalableSchemas.Add(&testSchemaImpl{col1.Name()})
+	avalableSchemas.Add(&testSchemaImpl{col2.Name()})
+	avalableSchemas.Add(&testSchemaImpl{col3.Name()})
+
 	removed := a.RemoveSkipped(
-		collection.Names{col1.Name(), col2.Name(), col3.Name()},
+		avalableSchemas.Build(),
 		collection.Names{col3.Name()},
 		transformer.Providers{xform})
 
@@ -89,6 +95,12 @@ func TestCombinedAnalyzer(t *testing.T) {
 	g.Expect(a4.ran).To(BeFalse())
 }
 
+// ProcessorOptions are options that are passed to event.Processors during startup.
+type ProcessorOptions struct {
+	MeshConfig   *v1alpha1.MeshConfig
+	DomainSuffix string
+}
+
 func TestGetDisabledOutputs(t *testing.T) {
 	g := NewWithT(t)
 
@@ -102,7 +114,7 @@ func TestGetDisabledOutputs(t *testing.T) {
 	out3 := newSchema("out3")
 	out4 := newSchema("out4")
 
-	blankFn := func(_ processing.ProcessorOptions) event.Transformer {
+	blankFn := func(_ util.ProcessorOptions) event.Transformer {
 		return event.NewFnTransform(collection.SchemasFor(), collection.SchemasFor(), func() {}, func() {}, func(e event.Event, handler event.Handler) {})
 	}
 
@@ -137,3 +149,36 @@ func newSchema(name string) collection.Schema {
 		}.MustBuild(),
 	}.MustBuild()
 }
+
+type testSchemaImpl struct {
+	name collection.Name
+}
+
+// String interface method implementation.
+func (s *testSchemaImpl) String() string {
+	return string(s.Name())
+}
+
+func (s *testSchemaImpl) Name() collection.Name {
+	return s.name
+}
+
+func (s *testSchemaImpl) VariableName() string {
+	panic("implement me")
+}
+
+func (s *testSchemaImpl) Resource() resource2.Schema {
+	panic("implement me")
+}
+
+func (s *testSchemaImpl) IsDisabled() bool {
+	panic("implement me")
+}
+
+func (s *testSchemaImpl) Disable() collection.Schema {
+	panic("implement me")
+}
+
+func (s *testSchemaImpl) Equal(o collection.Schema) bool {
+	panic("implement me")
+}
diff --git a/galley/pkg/config/analysis/analyzers/all.go b/pkg/config/analysis/analyzers/all.go
similarity index 67%
rename from galley/pkg/config/analysis/analyzers/all.go
rename to pkg/config/analysis/analyzers/all.go
index fe2b52bba0..f3bba7b6fc 100644
--- a/galley/pkg/config/analysis/analyzers/all.go
+++ b/pkg/config/analysis/analyzers/all.go
@@ -15,21 +15,21 @@
 package analyzers
 
 import (
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/annotations"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/authz"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/deployment"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/deprecation"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/destinationrule"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/gateway"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/injection"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/multicluster"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/schema"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/service"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/serviceentry"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/sidecar"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/virtualservice"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/webhook"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/annotations"
+	"istio.io/istio/pkg/config/analysis/analyzers/authz"
+	"istio.io/istio/pkg/config/analysis/analyzers/deployment"
+	"istio.io/istio/pkg/config/analysis/analyzers/deprecation"
+	"istio.io/istio/pkg/config/analysis/analyzers/destinationrule"
+	"istio.io/istio/pkg/config/analysis/analyzers/gateway"
+	"istio.io/istio/pkg/config/analysis/analyzers/injection"
+	"istio.io/istio/pkg/config/analysis/analyzers/multicluster"
+	"istio.io/istio/pkg/config/analysis/analyzers/schema"
+	"istio.io/istio/pkg/config/analysis/analyzers/service"
+	"istio.io/istio/pkg/config/analysis/analyzers/serviceentry"
+	"istio.io/istio/pkg/config/analysis/analyzers/sidecar"
+	"istio.io/istio/pkg/config/analysis/analyzers/virtualservice"
+	"istio.io/istio/pkg/config/analysis/analyzers/webhook"
 )
 
 // All returns all analyzers
diff --git a/galley/pkg/config/analysis/analyzers/analyzers_bench_test.go b/pkg/config/analysis/analyzers/analyzers_bench_test.go
similarity index 50%
rename from galley/pkg/config/analysis/analyzers/analyzers_bench_test.go
rename to pkg/config/analysis/analyzers/analyzers_bench_test.go
index c17afd8e59..93006259a6 100644
--- a/galley/pkg/config/analysis/analyzers/analyzers_bench_test.go
+++ b/pkg/config/analysis/analyzers/analyzers_bench_test.go
@@ -1,16 +1,18 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
 
 package analyzers
 
@@ -18,11 +20,9 @@
 	"fmt"
 	"testing"
 
-	"github.com/gogo/protobuf/proto"
-
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	coll "istio.io/istio/galley/pkg/config/collection"
+	"istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/analysis/local"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collection"
@@ -31,67 +31,6 @@
 	"istio.io/pkg/log"
 )
 
-type context struct {
-	set      *coll.Set
-	messages diag.Messages
-}
-
-var _ analysis.Context = &context{}
-
-// Report implements analysis.Context
-func (ctx *context) Report(_ collection.Name, m diag.Message) {
-	ctx.messages.Add(m)
-}
-
-// Find implements analysis.Context
-func (ctx *context) Find(col collection.Name, name resource.FullName) *resource.Instance {
-	c := ctx.set.Collection(col)
-	if c == nil {
-		return nil
-	}
-	return c.Get(name)
-}
-
-// Exists implements analysis.Context
-func (ctx *context) Exists(col collection.Name, name resource.FullName) bool {
-	return ctx.Find(col, name) != nil
-}
-
-// ForEach implements analysis.Context
-func (ctx *context) ForEach(col collection.Name, fn analysis.IteratorFn) {
-	c := ctx.set.Collection(col)
-	if c == nil {
-		return
-	}
-	c.ForEach(fn)
-}
-
-// Canceled implements analysis.Context
-func (ctx *context) Canceled() bool {
-	return false
-}
-
-type origin struct {
-	friendlyName string
-}
-
-var (
-	_ resource.Origin    = &origin{}
-	_ resource.Reference = &reference{}
-)
-
-func (o origin) Namespace() resource.Namespace { return "" }
-func (o origin) FriendlyName() string          { return o.friendlyName }
-func (o origin) Comparator() string            { return o.friendlyName }
-func (o origin) Reference() resource.Reference { return reference{name: ""} }
-func (o origin) FieldMap() map[string]int      { return map[string]int{o.friendlyName: 0} }
-
-type reference struct {
-	name string
-}
-
-func (r reference) String() string { return r.name }
-
 // This is a very basic benchmark on unit test data, so it doesn't tell us anything about how an analyzer performs at scale
 func BenchmarkAnalyzers(b *testing.B) {
 	for _, tc := range testGrid {
@@ -146,7 +85,7 @@ func benchmarkAnalyzersArtificialBlankData(count int, b *testing.B) {
 	}
 
 	// Generate blank test data
-	set := coll.NewSet(collections.All)
+	store := memory.MakeSkipValidation(collections.All)
 	collections.All.ForEach(func(s collection.Schema) bool {
 		// Skip over collections that the Galley pipeline would always ignore
 		if !isUsedCollection[s.Name().String()] {
@@ -155,20 +94,19 @@ func benchmarkAnalyzersArtificialBlankData(count int, b *testing.B) {
 
 		for i := 0; i < count; i++ {
 			name := resource.NewFullName("default", resource.LocalName(fmt.Sprintf("%s-%d", s.Name(), i)))
-			r := &resource.Instance{
-				Metadata: resource.Metadata{
-					Schema:   s.Resource(),
-					FullName: name,
+			_, _ = store.Create(config.Config{
+				Meta: config.Meta{
+					GroupVersionKind: s.Resource().GroupVersionKind(),
+					Name:             name.Name.String(),
+					Namespace:        name.Namespace.String(),
 				},
-				Message: s.Resource().MustNewInstance().(proto.Message),
-				Origin:  &origin{friendlyName: name.String()},
-			}
-			set.Collection(s.Name()).Set(r)
+				Spec: s.Resource().MustNewInstance(),
+			})
 		}
 
 		return false
 	})
-	ctx := &context{set: set}
+	ctx := local.NewContext(store, make(chan struct{}), func(name collection.Name) {})
 
 	b.ResetTimer()
 	for _, a := range All() {
diff --git a/galley/pkg/config/analysis/analyzers/analyzers_test.go b/pkg/config/analysis/analyzers/analyzers_test.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/analyzers_test.go
rename to pkg/config/analysis/analyzers/analyzers_test.go
index 5a4f34bd06..9641a159b3 100644
--- a/galley/pkg/config/analysis/analyzers/analyzers_test.go
+++ b/pkg/config/analysis/analyzers/analyzers_test.go
@@ -24,31 +24,28 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/annotations"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/authz"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/deployment"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/deprecation"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/destinationrule"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/gateway"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/injection"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/maturity"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/multicluster"
-	schemaValidation "istio.io/istio/galley/pkg/config/analysis/analyzers/schema"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/service"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/serviceentry"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/sidecar"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/virtualservice"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/webhook"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/processing/snapshotter"
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/annotations"
+	"istio.io/istio/pkg/config/analysis/analyzers/authz"
+	"istio.io/istio/pkg/config/analysis/analyzers/deployment"
+	"istio.io/istio/pkg/config/analysis/analyzers/deprecation"
+	"istio.io/istio/pkg/config/analysis/analyzers/destinationrule"
+	"istio.io/istio/pkg/config/analysis/analyzers/gateway"
+	"istio.io/istio/pkg/config/analysis/analyzers/injection"
+	"istio.io/istio/pkg/config/analysis/analyzers/maturity"
+	"istio.io/istio/pkg/config/analysis/analyzers/multicluster"
+	schemaValidation "istio.io/istio/pkg/config/analysis/analyzers/schema"
+	"istio.io/istio/pkg/config/analysis/analyzers/service"
+	"istio.io/istio/pkg/config/analysis/analyzers/serviceentry"
+	"istio.io/istio/pkg/config/analysis/analyzers/sidecar"
+	"istio.io/istio/pkg/config/analysis/analyzers/virtualservice"
+	"istio.io/istio/pkg/config/analysis/analyzers/webhook"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
-	"istio.io/pkg/log"
 )
 
 type message struct {
@@ -734,8 +731,8 @@ func TestAnalyzersHaveDescription(t *testing.T) {
 	}
 }
 
-func setupAnalyzerForCase(tc testCase, cr snapshotter.CollectionReporterFn) (*local.SourceAnalyzer, error) {
-	sa := local.NewSourceAnalyzer(schema.MustGet(), analysis.Combine("testCase", tc.analyzer), "", "istio-system", cr, true, 10*time.Second)
+func setupAnalyzerForCase(tc testCase, cr local.CollectionReporterFn) (*local.IstiodAnalyzer, error) {
+	sa := local.NewSourceAnalyzer(schema.NewMustGet(), analysis.Combine("testCase", tc.analyzer), "", "istio-system", cr, true, 10*time.Second)
 
 	// If a mesh config file is specified, use it instead of the defaults
 	if tc.meshConfigFile != "" {
@@ -777,12 +774,7 @@ func setupAnalyzerForCase(tc testCase, cr snapshotter.CollectionReporterFn) (*lo
 	return sa, nil
 }
 
-func runAnalyzer(sa *local.SourceAnalyzer) (local.AnalysisResult, error) {
-	// Default processing log level is too chatty for these tests
-	prevLogLevel := scope.Processing.GetOutputLevel()
-	scope.Processing.SetOutputLevel(log.ErrorLevel)
-	defer scope.Processing.SetOutputLevel(prevLogLevel)
-
+func runAnalyzer(sa *local.IstiodAnalyzer) (local.AnalysisResult, error) {
 	cancel := make(chan struct{})
 	result, err := sa.Analyze(cancel)
 	if err != nil {
diff --git a/galley/pkg/config/analysis/analyzers/annotations/annotations.go b/pkg/config/analysis/analyzers/annotations/annotations.go
similarity index 97%
rename from galley/pkg/config/analysis/analyzers/annotations/annotations.go
rename to pkg/config/analysis/analyzers/annotations/annotations.go
index 1dfd605ec2..7c31491666 100644
--- a/galley/pkg/config/analysis/analyzers/annotations/annotations.go
+++ b/pkg/config/analysis/analyzers/annotations/annotations.go
@@ -18,9 +18,9 @@
 	"strings"
 
 	"istio.io/api/annotation"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/authz/authorizationpolicies.go b/pkg/config/analysis/analyzers/authz/authorizationpolicies.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/authz/authorizationpolicies.go
rename to pkg/config/analysis/analyzers/authz/authorizationpolicies.go
index b790fe2f35..a4b63e100f 100644
--- a/galley/pkg/config/analysis/analyzers/authz/authorizationpolicies.go
+++ b/pkg/config/analysis/analyzers/authz/authorizationpolicies.go
@@ -18,14 +18,13 @@
 	"fmt"
 	"strings"
 
-	v1 "k8s.io/api/core/v1"
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/mesh/v1alpha1"
 	"istio.io/api/security/v1beta1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -193,15 +192,15 @@ func initPodLabelsMap(c analysis.Context) map[string][]k8s_labels.Set {
 	podLabelsMap := make(map[string][]k8s_labels.Set)
 
 	c.ForEach(collections.K8SCoreV1Pods.Name(), func(r *resource.Instance) bool {
-		p := r.Message.(*v1.Pod)
-		pLabels := k8s_labels.Set(p.Labels)
+		pLabels := k8s_labels.Set(r.Metadata.Labels)
 
-		if podLabelsMap[p.Namespace] == nil {
-			podLabelsMap[p.Namespace] = make([]k8s_labels.Set, 0)
+		ns := r.Metadata.FullName.Namespace.String()
+		if podLabelsMap[ns] == nil {
+			podLabelsMap[ns] = make([]k8s_labels.Set, 0)
 		}
 
 		if util.PodInMesh(r, c) {
-			podLabelsMap[p.Namespace] = append(podLabelsMap[p.Namespace], pLabels)
+			podLabelsMap[ns] = append(podLabelsMap[ns], pLabels)
 		}
 
 		return true
diff --git a/galley/pkg/config/analysis/analyzers/authz/authorizationpolicies_test.go b/pkg/config/analysis/analyzers/authz/authorizationpolicies_test.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/authz/authorizationpolicies_test.go
rename to pkg/config/analysis/analyzers/authz/authorizationpolicies_test.go
diff --git a/galley/pkg/config/analysis/analyzers/deployment/pod.go b/pkg/config/analysis/analyzers/deployment/pod.go
diff --git a/galley/pkg/config/analysis/analyzers/deployment/pod.go b/pkg/config/analysis/analyzers/deployment/pod.go
similarity index 87%
rename from galley/pkg/config/analysis/analyzers/deployment/pod.go
rename to pkg/config/analysis/analyzers/deployment/pod.go
index a4dfeffb1d..265e61d719 100644
--- a/galley/pkg/config/analysis/analyzers/deployment/pod.go
+++ b/pkg/config/analysis/analyzers/deployment/pod.go
@@ -18,9 +18,9 @@
 	apps_v1 "k8s.io/api/apps/v1"
 	v1 "k8s.io/api/core/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -57,19 +57,19 @@ func (appUID *ApplicationUIDAnalyzer) Analyze(context analysis.Context) {
 }
 
 func (appUID *ApplicationUIDAnalyzer) analyzeAppUIDForPod(resource *resource.Instance, context analysis.Context) {
-	p := resource.Message.(*v1.Pod)
+	p := resource.Message.(*v1.PodSpec)
 	// Skip analyzing control plane for IST0144
 	if util.IsIstioControlPlane(resource) {
 		return
 	}
 	message := msg.NewInvalidApplicationUID(resource)
 
-	if p.Spec.SecurityContext != nil && p.Spec.SecurityContext.RunAsUser != nil {
-		if *p.Spec.SecurityContext.RunAsUser == UserID {
+	if p.SecurityContext != nil && p.SecurityContext.RunAsUser != nil {
+		if *p.SecurityContext.RunAsUser == UserID {
 			context.Report(collections.K8SCoreV1Pods.Name(), message)
 		}
 	}
-	for _, container := range p.Spec.Containers {
+	for _, container := range p.Containers {
 		if container.Name != util.IstioProxyName && container.Name != util.IstioOperator {
 			if container.SecurityContext != nil && container.SecurityContext.RunAsUser != nil {
 				if *container.SecurityContext.RunAsUser == UserID {
@@ -81,13 +81,13 @@ func (appUID *ApplicationUIDAnalyzer) analyzeAppUIDForPod(resource *resource.Ins
 }
 
 func (appUID *ApplicationUIDAnalyzer) analyzeAppUIDForDeployment(resource *resource.Instance, context analysis.Context) {
-	d := resource.Message.(*apps_v1.Deployment)
+	d := resource.Message.(*apps_v1.DeploymentSpec)
 	// Skip analyzing control plane for IST0144
 	if util.IsIstioControlPlane(resource) {
 		return
 	}
 	message := msg.NewInvalidApplicationUID(resource)
-	spec := d.Spec.Template.Spec
+	spec := d.Template.Spec
 
 	if spec.SecurityContext != nil && spec.SecurityContext.RunAsUser != nil {
 		if *spec.SecurityContext.RunAsUser == UserID {
diff --git a/galley/pkg/config/analysis/analyzers/deployment/services.go b/pkg/config/analysis/analyzers/deployment/services.go
similarity index 88%
rename from galley/pkg/config/analysis/analyzers/deployment/services.go
rename to pkg/config/analysis/analyzers/deployment/services.go
index d7090a3c14..264470afc5 100644
--- a/galley/pkg/config/analysis/analyzers/deployment/services.go
+++ b/pkg/config/analysis/analyzers/deployment/services.go
@@ -21,9 +21,9 @@
 	core_v1 "k8s.io/api/core/v1"
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -70,10 +70,8 @@ func (s *ServiceAssociationAnalyzer) Analyze(c analysis.Context) {
 
 // analyzeDeploymentPortProtocol analyzes the specific service mesh deployment
 func (s *ServiceAssociationAnalyzer) analyzeDeploymentPortProtocol(r *resource.Instance, c analysis.Context) {
-	d := r.Message.(*apps_v1.Deployment)
-
 	// Find matching services with resulting pod from deployment
-	matchingSvcs := s.findMatchingServices(d, c)
+	matchingSvcs := s.findMatchingServices(r, c)
 
 	// If there isn't any matching service, generate message: At least one service is needed.
 	if len(matchingSvcs) == 0 {
@@ -96,7 +94,7 @@ func (s *ServiceAssociationAnalyzer) analyzeDeploymentPortProtocol(r *resource.I
 			for protocol := range protMap {
 				svcNames = append(svcNames, protMap[protocol]...)
 			}
-			m := msg.NewDeploymentAssociatedToMultipleServices(r, d.Name, port, svcNames)
+			m := msg.NewDeploymentAssociatedToMultipleServices(r, r.Metadata.FullName.Name.String(), port, svcNames)
 
 			if line, ok := util.ErrorLine(r, fmt.Sprintf(util.MetadataName)); ok {
 				m.Line = line
@@ -110,10 +108,8 @@ func (s *ServiceAssociationAnalyzer) analyzeDeploymentPortProtocol(r *resource.I
 
 // analyzeDeploymentPortProtocol analyzes the targetPorts conflicting
 func (s *ServiceAssociationAnalyzer) analyzeDeploymentTargetPorts(r *resource.Instance, c analysis.Context) {
-	d := r.Message.(*apps_v1.Deployment)
-
 	// Find matching services with resulting pod from deployment
-	matchingSvcs := s.findMatchingServices(d, c)
+	matchingSvcs := s.findMatchingServices(r, c)
 
 	// If there isn't any matching service, generate message: At least one service is needed.
 	if len(matchingSvcs) == 0 {
@@ -133,7 +129,7 @@ func (s *ServiceAssociationAnalyzer) analyzeDeploymentTargetPorts(r *resource.In
 				svcNames = append(svcNames, s)
 				ports = append(ports, p)
 			}
-			m := msg.NewDeploymentConflictingPorts(r, d.Name, svcNames, targetPort, ports)
+			m := msg.NewDeploymentConflictingPorts(r, r.Metadata.FullName.Name.String(), svcNames, targetPort, ports)
 
 			if line, ok := util.ErrorLine(r, fmt.Sprintf(util.MetadataName)); ok {
 				m.Line = line
@@ -146,16 +142,17 @@ func (s *ServiceAssociationAnalyzer) analyzeDeploymentTargetPorts(r *resource.In
 }
 
 // findMatchingServices returns an slice of Services that matches with deployment's pods.
-func (s *ServiceAssociationAnalyzer) findMatchingServices(d *apps_v1.Deployment, c analysis.Context) []ServiceSpecWithName {
+func (s *ServiceAssociationAnalyzer) findMatchingServices(r *resource.Instance, c analysis.Context) []ServiceSpecWithName {
 	matchingSvcs := make([]ServiceSpecWithName, 0)
+	d := r.Message.(*apps_v1.DeploymentSpec)
+	deploymentNS := r.Metadata.FullName.Namespace.String()
 
 	c.ForEach(collections.K8SCoreV1Services.Name(), func(r *resource.Instance) bool {
 		s := r.Message.(*core_v1.ServiceSpec)
-		ns := r.Metadata.FullName.Namespace.String()
 
 		sSelector := k8s_labels.SelectorFromSet(s.Selector)
-		pLabels := k8s_labels.Set(d.Spec.Template.Labels)
-		if sSelector.Matches(pLabels) && d.Namespace == ns {
+		pLabels := k8s_labels.Set(d.Template.Labels)
+		if sSelector.Matches(pLabels) && r.Metadata.FullName.Namespace.String() == deploymentNS {
 			matchingSvcs = append(matchingSvcs, ServiceSpecWithName{r.Metadata.FullName.String(), s})
 		}
 
diff --git a/galley/pkg/config/analysis/analyzers/deprecation/deprecation.go b/pkg/config/analysis/analyzers/deprecation/deprecation.go
similarity index 98%
rename from galley/pkg/config/analysis/analyzers/deprecation/deprecation.go
rename to pkg/config/analysis/analyzers/deprecation/deprecation.go
index 40461a567c..5b9d06613e 100644
--- a/galley/pkg/config/analysis/analyzers/deprecation/deprecation.go
+++ b/pkg/config/analysis/analyzers/deprecation/deprecation.go
@@ -20,8 +20,8 @@
 	k8sext "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/destinationrule/ca-certificates.go b/pkg/config/analysis/analyzers/destinationrule/ca-certificates.go
similarity index 94%
rename from galley/pkg/config/analysis/analyzers/destinationrule/ca-certificates.go
rename to pkg/config/analysis/analyzers/destinationrule/ca-certificates.go
index d4384c11ba..666051f0cd 100644
--- a/galley/pkg/config/analysis/analyzers/destinationrule/ca-certificates.go
+++ b/pkg/config/analysis/analyzers/destinationrule/ca-certificates.go
@@ -18,9 +18,9 @@
 	"fmt"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/gateway/certificate.go b/pkg/config/analysis/analyzers/gateway/certificate.go
similarity index 97%
rename from galley/pkg/config/analysis/analyzers/gateway/certificate.go
rename to pkg/config/analysis/analyzers/gateway/certificate.go
index 9e3f881c25..66bd51dd48 100644
--- a/galley/pkg/config/analysis/analyzers/gateway/certificate.go
+++ b/pkg/config/analysis/analyzers/gateway/certificate.go
@@ -16,10 +16,10 @@
 
 import (
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/gateway/conflictinggateway.go b/pkg/config/analysis/analyzers/gateway/conflictinggateway.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/gateway/conflictinggateway.go
rename to pkg/config/analysis/analyzers/gateway/conflictinggateway.go
index e9f5479795..2d6460752f 100644
--- a/galley/pkg/config/analysis/analyzers/gateway/conflictinggateway.go
+++ b/pkg/config/analysis/analyzers/gateway/conflictinggateway.go
@@ -22,9 +22,9 @@
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
diff --git a/galley/pkg/config/analysis/analyzers/gateway/gateway.go b/pkg/config/analysis/analyzers/gateway/gateway.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/gateway/gateway.go
rename to pkg/config/analysis/analyzers/gateway/gateway.go
index 0a933c646b..240dafc2ec 100644
--- a/galley/pkg/config/analysis/analyzers/gateway/gateway.go
+++ b/pkg/config/analysis/analyzers/gateway/gateway.go
@@ -21,9 +21,9 @@
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -69,13 +69,12 @@ func (*IngressGatewayPortAnalyzer) analyzeGateway(r *resource.Instance, c analys
 	// For pods selected by gw.Selector, find Services that select them and remember those ports
 	gwSelector := k8s_labels.SelectorFromSet(gw.Selector)
 	c.ForEach(collections.K8SCoreV1Pods.Name(), func(rPod *resource.Instance) bool {
-		pod := rPod.Message.(*v1.Pod)
-		podLabels := k8s_labels.Set(pod.ObjectMeta.Labels)
+		podLabels := k8s_labels.Set(rPod.Metadata.Labels)
 		if gwSelector.Matches(podLabels) {
 			gwSelectorMatches++
 			c.ForEach(collections.K8SCoreV1Services.Name(), func(rSvc *resource.Instance) bool {
 				nsSvc := string(rSvc.Metadata.FullName.Namespace)
-				if nsSvc != pod.ObjectMeta.Namespace {
+				if nsSvc != rPod.Metadata.FullName.Namespace.String() {
 					return true // Services only select pods in their namespace
 				}
 
diff --git a/galley/pkg/config/analysis/analyzers/gateway/secret.go b/pkg/config/analysis/analyzers/gateway/secret.go
similarity index 92%
rename from galley/pkg/config/analysis/analyzers/gateway/secret.go
rename to pkg/config/analysis/analyzers/gateway/secret.go
index abd4fad5d6..0099fd21d2 100644
--- a/galley/pkg/config/analysis/analyzers/gateway/secret.go
+++ b/pkg/config/analysis/analyzers/gateway/secret.go
@@ -17,13 +17,12 @@
 import (
 	"fmt"
 
-	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -101,8 +100,7 @@ func getGatewayNamespace(ctx analysis.Context, gw *v1alpha3.Gateway) resource.Na
 
 	gwSelector := labels.SelectorFromSet(gw.Selector)
 	ctx.ForEach(collections.K8SCoreV1Pods.Name(), func(rPod *resource.Instance) bool {
-		pod := rPod.Message.(*v1.Pod)
-		if gwSelector.Matches(labels.Set(pod.ObjectMeta.Labels)) {
+		if gwSelector.Matches(labels.Set(rPod.Metadata.Labels)) {
 			ns = rPod.Metadata.FullName.Namespace
 			return false
 		}
diff --git a/galley/pkg/config/analysis/analyzers/injection/image-auto.go b/pkg/config/analysis/analyzers/injection/image-auto.go
similarity index 87%
rename from galley/pkg/config/analysis/analyzers/injection/image-auto.go
rename to pkg/config/analysis/analyzers/injection/image-auto.go
index d61e3da688..d1d0457fb0 100644
--- a/galley/pkg/config/analysis/analyzers/injection/image-auto.go
+++ b/pkg/config/analysis/analyzers/injection/image-auto.go
@@ -23,8 +23,8 @@
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	klabels "k8s.io/apimachinery/pkg/labels"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -67,23 +67,23 @@ func (a *ImageAutoAnalyzer) Analyze(c analysis.Context) {
 		return true
 	})
 	c.ForEach(collections.K8SCoreV1Pods.Name(), func(resource *resource.Instance) bool {
-		p := resource.Message.(*v1.Pod)
+		p := resource.Message.(*v1.PodSpec)
 		// If a pod has `image: auto` it is broken whether the webhooks match or not
-		if !hasAutoImage(&p.Spec) {
+		if !hasAutoImage(p) {
 			return true
 		}
-		m := msg.NewImageAutoWithoutInjectionError(resource, "Pod", p.Name)
+		m := msg.NewImageAutoWithoutInjectionError(resource, "Pod", resource.Metadata.FullName.Name.String())
 		c.Report(collections.K8SCoreV1Pods.Name(), m)
 		return true
 	})
 	c.ForEach(collections.K8SAppsV1Deployments.Name(), func(resource *resource.Instance) bool {
-		d := resource.Message.(*apps_v1.Deployment)
-		if !hasAutoImage(&d.Spec.Template.Spec) {
+		d := resource.Message.(*apps_v1.DeploymentSpec)
+		if !hasAutoImage(&d.Template.Spec) {
 			return true
 		}
-		nsLabels := getNamespaceLabels(c, d.Namespace)
-		if !matchesWebhooks(nsLabels, d.Spec.Template.Labels, istioWebhooks) {
-			m := msg.NewImageAutoWithoutInjectionWarning(resource, "Deployment", d.Name)
+		nsLabels := getNamespaceLabels(c, resource.Metadata.FullName.Namespace.String())
+		if !matchesWebhooks(nsLabels, d.Template.Labels, istioWebhooks) {
+			m := msg.NewImageAutoWithoutInjectionWarning(resource, "Deployment", resource.Metadata.FullName.Name.String())
 			c.Report(collections.K8SAppsV1Deployments.Name(), m)
 		}
 		return true
diff --git a/galley/pkg/config/analysis/analyzers/injection/injection-image.go b/pkg/config/analysis/analyzers/injection/injection-image.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/injection/injection-image.go
rename to pkg/config/analysis/analyzers/injection/injection-image.go
index b37f9993bf..c518842b28 100644
--- a/galley/pkg/config/analysis/analyzers/injection/injection-image.go
+++ b/pkg/config/analysis/analyzers/injection/injection-image.go
@@ -22,9 +22,9 @@
 
 	v1 "k8s.io/api/core/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -104,9 +104,9 @@ func (a *ImageAnalyzer) Analyze(c analysis.Context) {
 
 	c.ForEach(collections.K8SCoreV1Pods.Name(), func(r *resource.Instance) bool {
 		var injectionCMName string
-		pod := r.Message.(*v1.Pod)
+		pod := r.Message.(*v1.PodSpec)
 
-		if nsRevision, ok := injectedNamespaces[pod.GetNamespace()]; ok {
+		if nsRevision, ok := injectedNamespaces[r.Metadata.FullName.Namespace.String()]; ok {
 			// Generate the injection configmap name with different revision for every pod
 			injectionCMName = util.GetInjectorConfigMapName(nsRevision)
 		} else {
@@ -119,7 +119,7 @@ func (a *ImageAnalyzer) Analyze(c analysis.Context) {
 			return true
 		}
 
-		for i, container := range pod.Spec.Containers {
+		for i, container := range pod.Containers {
 			if container.Name != util.IstioProxyName {
 				continue
 			}
diff --git a/galley/pkg/config/analysis/analyzers/injection/injection.go b/pkg/config/analysis/analyzers/injection/injection.go
similarity index 92%
rename from galley/pkg/config/analysis/analyzers/injection/injection.go
rename to pkg/config/analysis/analyzers/injection/injection.go
index ff87c8530c..5c499cba3e 100644
--- a/galley/pkg/config/analysis/analyzers/injection/injection.go
+++ b/pkg/config/analysis/analyzers/injection/injection.go
@@ -23,9 +23,9 @@
 
 	"istio.io/api/annotation"
 	"istio.io/api/label"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
@@ -128,19 +128,19 @@ func (a *Analyzer) Analyze(c analysis.Context) {
 	})
 
 	c.ForEach(collections.K8SCoreV1Pods.Name(), func(r *resource.Instance) bool {
-		pod := r.Message.(*v1.Pod)
+		pod := r.Message.(*v1.PodSpec)
 
-		if !injectedNamespaces[pod.GetNamespace()] {
+		if !injectedNamespaces[r.Metadata.FullName.Namespace.String()] {
 			return true
 		}
 
 		// If a pod has injection explicitly disabled, no need to check further
-		if val := pod.GetAnnotations()[annotation.SidecarInject.Name]; strings.EqualFold(val, "false") {
+		if val := r.Metadata.Annotations[annotation.SidecarInject.Name]; strings.EqualFold(val, "false") {
 			return true
 		}
 
 		proxyImage := ""
-		for _, container := range pod.Spec.Containers {
+		for _, container := range pod.Containers {
 			if container.Name == util.IstioProxyName {
 				proxyImage = container.Image
 				break
diff --git a/galley/pkg/config/analysis/analyzers/maturity/maturity.go b/pkg/config/analysis/analyzers/maturity/maturity.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/maturity/maturity.go
rename to pkg/config/analysis/analyzers/maturity/maturity.go
index c94be99628..5909be241f 100644
--- a/galley/pkg/config/analysis/analyzers/maturity/maturity.go
+++ b/pkg/config/analysis/analyzers/maturity/maturity.go
@@ -18,9 +18,9 @@
 	"strings"
 
 	"istio.io/api/annotation"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/multicluster/meshnetworks.go b/pkg/config/analysis/analyzers/multicluster/meshnetworks.go
similarity index 94%
rename from galley/pkg/config/analysis/analyzers/multicluster/meshnetworks.go
rename to pkg/config/analysis/analyzers/multicluster/meshnetworks.go
index a2059dfd14..e5be1c3381 100644
--- a/galley/pkg/config/analysis/analyzers/multicluster/meshnetworks.go
+++ b/pkg/config/analysis/analyzers/multicluster/meshnetworks.go
@@ -20,10 +20,10 @@
 	v1 "k8s.io/api/core/v1"
 
 	"istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/schema/validation.go b/pkg/config/analysis/analyzers/schema/validation.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/schema/validation.go
rename to pkg/config/analysis/analyzers/schema/validation.go
index 6237170b5d..31ff6a031b 100644
--- a/galley/pkg/config/analysis/analyzers/schema/validation.go
+++ b/pkg/config/analysis/analyzers/schema/validation.go
@@ -18,10 +18,10 @@
 
 	"github.com/hashicorp/go-multierror"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/schema/validation_test.go b/pkg/config/analysis/analyzers/schema/validation_test.go
similarity index 97%
rename from galley/pkg/config/analysis/analyzers/schema/validation_test.go
rename to pkg/config/analysis/analyzers/schema/validation_test.go
index 9344fa4c48..415010b403 100644
--- a/galley/pkg/config/analysis/analyzers/schema/validation_test.go
+++ b/pkg/config/analysis/analyzers/schema/validation_test.go
@@ -21,9 +21,9 @@
 	. "github.com/onsi/gomega"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/analysis/testing/fixtures"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis/testing/fixtures"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/service/portname.go b/pkg/config/analysis/analyzers/service/portname.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/service/portname.go
rename to pkg/config/analysis/analyzers/service/portname.go
index 31b0437269..5b4943b08f 100644
--- a/galley/pkg/config/analysis/analyzers/service/portname.go
+++ b/pkg/config/analysis/analyzers/service/portname.go
@@ -19,9 +19,9 @@
 
 	v1 "k8s.io/api/core/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	configKube "istio.io/istio/pkg/config/kube"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
diff --git a/galley/pkg/config/analysis/analyzers/serviceentry/protocoladresses.go b/pkg/config/analysis/analyzers/serviceentry/protocoladresses.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/serviceentry/protocoladresses.go
rename to pkg/config/analysis/analyzers/serviceentry/protocoladresses.go
index 29da28112d..61f74fb04b 100644
--- a/galley/pkg/config/analysis/analyzers/serviceentry/protocoladresses.go
+++ b/pkg/config/analysis/analyzers/serviceentry/protocoladresses.go
@@ -18,9 +18,9 @@
 	"fmt"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/sidecar/defaultselector.go b/pkg/config/analysis/analyzers/sidecar/defaultselector.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/sidecar/defaultselector.go
rename to pkg/config/analysis/analyzers/sidecar/defaultselector.go
index 7084aec756..bb1d03fa40 100644
--- a/galley/pkg/config/analysis/analyzers/sidecar/defaultselector.go
+++ b/pkg/config/analysis/analyzers/sidecar/defaultselector.go
@@ -15,8 +15,8 @@
 
 import (
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/sidecar/selector.go b/pkg/config/analysis/analyzers/sidecar/selector.go
similarity index 93%
rename from galley/pkg/config/analysis/analyzers/sidecar/selector.go
rename to pkg/config/analysis/analyzers/sidecar/selector.go
index 1932800d6e..7c79be93c7 100644
--- a/galley/pkg/config/analysis/analyzers/sidecar/selector.go
+++ b/pkg/config/analysis/analyzers/sidecar/selector.go
@@ -16,13 +16,12 @@
 import (
 	"fmt"
 
-	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
@@ -68,9 +67,8 @@ func (a *SelectorAnalyzer) Analyze(c analysis.Context) {
 
 		foundPod := false
 		c.ForEach(collections.K8SCoreV1Pods.Name(), func(rp *resource.Instance) bool {
-			pod := rp.Message.(*v1.Pod)
 			pNs := rp.Metadata.FullName.Namespace
-			podLabels := labels.Set(pod.ObjectMeta.Labels)
+			podLabels := labels.Set(rp.Metadata.Labels)
 
 			// Only attempt to match in the same namespace
 			if pNs != sNs {
diff --git a/galley/pkg/config/analysis/analyzers/sidecar/util.go b/pkg/config/analysis/analyzers/sidecar/util.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/sidecar/util.go
rename to pkg/config/analysis/analyzers/sidecar/util.go
diff --git a/galley/pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml b/pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml b/pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml
rename to pkg/config/analysis/analyzers/testdata/authorizationpolicies.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml b/pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml b/pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml
rename to pkg/config/analysis/analyzers/testdata/common/meshnetworks.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml b/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml b/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml
rename to pkg/config/analysis/analyzers/testdata/common/sidecar-injector-configmap.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml b/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml b/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml
rename to pkg/config/analysis/analyzers/testdata/common/sidecar-injector-enabled-nsbydefault.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml b/pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml b/pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml
rename to pkg/config/analysis/analyzers/testdata/conflicting-gateways.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml
rename to pkg/config/analysis/analyzers/testdata/deployment-con-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml b/pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml b/pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml
rename to pkg/config/analysis/analyzers/testdata/deployment-multi-service-different-ns.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml b/pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml b/pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml
rename to pkg/config/analysis/analyzers/testdata/deployment-multi-service.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml
rename to pkg/config/analysis/analyzers/testdata/deployment-pod-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deprecation.yaml b/pkg/config/analysis/analyzers/testdata/deprecation.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/deprecation.yaml b/pkg/config/analysis/analyzers/testdata/deprecation.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/deprecation.yaml
rename to pkg/config/analysis/analyzers/testdata/deprecation.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-compound-mutual-simple.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-compound-simple-mutual.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-mutual-destination.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-mutual-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-simple-destination.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-simple-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml b/pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml
rename to pkg/config/analysis/analyzers/testdata/destinationrule-with-ca.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml b/pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml b/pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-correct-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-badport.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway-svcselector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml b/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-custom-ingressgateway.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml b/pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml b/pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-duplicate-certificate.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml b/pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml b/pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-no-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml b/pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml b/pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-no-workload.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml b/pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml b/pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml
rename to pkg/config/analysis/analyzers/testdata/gateway-secrets.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/image-auto.yaml b/pkg/config/analysis/analyzers/testdata/image-auto.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/image-auto.yaml b/pkg/config/analysis/analyzers/testdata/image-auto.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/image-auto.yaml
rename to pkg/config/analysis/analyzers/testdata/image-auto.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml b/pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml b/pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml
rename to pkg/config/analysis/analyzers/testdata/injection-with-mismatched-sidecar.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/injection.yaml b/pkg/config/analysis/analyzers/testdata/injection.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/injection.yaml b/pkg/config/analysis/analyzers/testdata/injection.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/injection.yaml
rename to pkg/config/analysis/analyzers/testdata/injection.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml b/pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml b/pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml
rename to pkg/config/analysis/analyzers/testdata/mesh-with-automtls.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/misannotated.yaml b/pkg/config/analysis/analyzers/testdata/misannotated.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/misannotated.yaml b/pkg/config/analysis/analyzers/testdata/misannotated.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/misannotated.yaml
rename to pkg/config/analysis/analyzers/testdata/misannotated.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-exports.yaml b/pkg/config/analysis/analyzers/testdata/mtls-exports.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-exports.yaml b/pkg/config/analysis/analyzers/testdata/mtls-exports.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-exports.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-exports.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-global-dr-no-meshpolicy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml b/pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml b/pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-ignores-istio-control-plane.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml b/pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml b/pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-ignores-system-namespaces.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml b/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml b/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-meshpolicy-permissive.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-meshpolicy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-no-dr.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-no-policy.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml b/pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-no-sidecar.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml b/pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml b/pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml
rename to pkg/config/analysis/analyzers/testdata/mtls-with-port.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml b/pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml b/pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml
rename to pkg/config/analysis/analyzers/testdata/multicluster-unknown-serviceregistry.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml b/pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml b/pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml
rename to pkg/config/analysis/analyzers/testdata/peerauthentication-crd.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml
rename to pkg/config/analysis/analyzers/testdata/pod-con-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml b/pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml
rename to pkg/config/analysis/analyzers/testdata/pod-sec-uid.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml b/pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml b/pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml
rename to pkg/config/analysis/analyzers/testdata/service-no-port-name-system-namespace.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml b/pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml b/pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml
rename to pkg/config/analysis/analyzers/testdata/service-no-port-name.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-port-name.yaml b/pkg/config/analysis/analyzers/testdata/service-port-name.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/service-port-name.yaml b/pkg/config/analysis/analyzers/testdata/service-port-name.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/service-port-name.yaml
rename to pkg/config/analysis/analyzers/testdata/service-port-name.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml b/pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml b/pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml
rename to pkg/config/analysis/analyzers/testdata/serviceentry-missing-addresses-protocol.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml
rename to pkg/config/analysis/analyzers/testdata/sidecar-default-selector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml
rename to pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-absolute-override.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml
rename to pkg/config/analysis/analyzers/testdata/sidecar-injector-configmap-with-revision-canary.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml b/pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml
rename to pkg/config/analysis/analyzers/testdata/sidecar-selector.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_conflictingmeshgatewayhosts.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_destinationhosts.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_destinationrules.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_dupmatches.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_gateways.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_host_not_found_gateway_with_ns_prefix.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_overlappingmatches.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_regexes.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml b/pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml
rename to pkg/config/analysis/analyzers/testdata/virtualservice_route_rule_no_effects_ingress.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/webhook.yaml b/pkg/config/analysis/analyzers/testdata/webhook.yaml
diff --git a/galley/pkg/config/analysis/analyzers/testdata/webhook.yaml b/pkg/config/analysis/analyzers/testdata/webhook.yaml
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/testdata/webhook.yaml
rename to pkg/config/analysis/analyzers/testdata/webhook.yaml
diff --git a/galley/pkg/config/analysis/analyzers/util/config.go b/pkg/config/analysis/analyzers/util/config.go
diff --git a/galley/pkg/config/analysis/analyzers/util/config.go b/pkg/config/analysis/analyzers/util/config.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/config.go
rename to pkg/config/analysis/analyzers/util/config.go
diff --git a/galley/pkg/config/analysis/analyzers/util/constants.go b/pkg/config/analysis/analyzers/util/constants.go
diff --git a/galley/pkg/config/analysis/analyzers/util/constants.go b/pkg/config/analysis/analyzers/util/constants.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/constants.go
rename to pkg/config/analysis/analyzers/util/constants.go
diff --git a/galley/pkg/config/analysis/analyzers/util/exportto.go b/pkg/config/analysis/analyzers/util/exportto.go
diff --git a/galley/pkg/config/analysis/analyzers/util/exportto.go b/pkg/config/analysis/analyzers/util/exportto.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/exportto.go
rename to pkg/config/analysis/analyzers/util/exportto.go
diff --git a/galley/pkg/config/analysis/analyzers/util/exportto_test.go b/pkg/config/analysis/analyzers/util/exportto_test.go
diff --git a/galley/pkg/config/analysis/analyzers/util/exportto_test.go b/pkg/config/analysis/analyzers/util/exportto_test.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/exportto_test.go
rename to pkg/config/analysis/analyzers/util/exportto_test.go
diff --git a/galley/pkg/config/analysis/analyzers/util/find_errorline_utils.go b/pkg/config/analysis/analyzers/util/find_errorline_utils.go
diff --git a/galley/pkg/config/analysis/analyzers/util/find_errorline_utils.go b/pkg/config/analysis/analyzers/util/find_errorline_utils.go
similarity index 98%
rename from galley/pkg/config/analysis/analyzers/util/find_errorline_utils.go
rename to pkg/config/analysis/analyzers/util/find_errorline_utils.go
index 737a06667c..23ed8c70d3 100644
--- a/galley/pkg/config/analysis/analyzers/util/find_errorline_utils.go
+++ b/pkg/config/analysis/analyzers/util/find_errorline_utils.go
@@ -18,7 +18,7 @@
 	"fmt"
 	"strings"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 )
 
diff --git a/galley/pkg/config/analysis/analyzers/util/find_errorline_utils_test.go b/pkg/config/analysis/analyzers/util/find_errorline_utils_test.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/util/find_errorline_utils_test.go
rename to pkg/config/analysis/analyzers/util/find_errorline_utils_test.go
index 45fe27681b..fa2dc836c4 100644
--- a/galley/pkg/config/analysis/analyzers/util/find_errorline_utils_test.go
+++ b/pkg/config/analysis/analyzers/util/find_errorline_utils_test.go
@@ -20,7 +20,7 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
+	kube2 "istio.io/istio/pkg/config/legacy/source/kube"
 	"istio.io/istio/pkg/config/resource"
 )
 
@@ -53,7 +53,7 @@ func TestExtractLabelFromSelectorString(t *testing.T) {
 
 func TestErrorLine(t *testing.T) {
 	g := NewWithT(t)
-	r := &resource.Instance{Origin: &rt.Origin{FieldsMap: fieldMap}}
+	r := &resource.Instance{Origin: &kube2.Origin{FieldsMap: fieldMap}}
 	test1, err1 := ErrorLine(r, "{.metadata.name}")
 	test2, err2 := ErrorLine(r, "{.metadata.fake}")
 	g.Expect(test1).To(Equal(1))
diff --git a/galley/pkg/config/analysis/analyzers/util/hosts.go b/pkg/config/analysis/analyzers/util/hosts.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/hosts.go
rename to pkg/config/analysis/analyzers/util/hosts.go
diff --git a/galley/pkg/config/analysis/analyzers/util/hosts_test.go b/pkg/config/analysis/analyzers/util/hosts_test.go
diff --git a/galley/pkg/config/analysis/analyzers/util/hosts_test.go b/pkg/config/analysis/analyzers/util/hosts_test.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/util/hosts_test.go
rename to pkg/config/analysis/analyzers/util/hosts_test.go
diff --git a/galley/pkg/config/analysis/analyzers/util/in_mesh.go b/pkg/config/analysis/analyzers/util/in_mesh.go
diff --git a/galley/pkg/config/analysis/analyzers/util/in_mesh.go b/pkg/config/analysis/analyzers/util/in_mesh.go
similarity index 90%
rename from galley/pkg/config/analysis/analyzers/util/in_mesh.go
rename to pkg/config/analysis/analyzers/util/in_mesh.go
index c36a4dc8c3..7dd339f533 100644
--- a/galley/pkg/config/analysis/analyzers/util/in_mesh.go
+++ b/pkg/config/analysis/analyzers/util/in_mesh.go
@@ -19,21 +19,21 @@
 	v1 "k8s.io/api/core/v1"
 
 	"istio.io/api/annotation"
-	"istio.io/istio/galley/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collections"
 )
 
 // DeploymentinMesh returns true if deployment is in the service mesh (has sidecar)
 func DeploymentInMesh(r *resource.Instance, c analysis.Context) bool {
-	d := r.Message.(*apps_v1.Deployment)
-	return inMesh(d.Spec.Template.Annotations, resource.Namespace(d.Namespace), d.Spec.Template.Spec.Containers, c)
+	d := r.Message.(*apps_v1.DeploymentSpec)
+	return inMesh(d.Template.Annotations, resource.Namespace(r.Metadata.FullName.Namespace.String()), d.Template.Spec.Containers, c)
 }
 
 // PodInMesh returns true if a Pod is in the service mesh (has sidecar)
 func PodInMesh(r *resource.Instance, c analysis.Context) bool {
-	p := r.Message.(*v1.Pod)
-	return inMesh(p.Annotations, resource.Namespace(p.Namespace), p.Spec.Containers, c)
+	p := r.Message.(*v1.PodSpec)
+	return inMesh(r.Metadata.Annotations, r.Metadata.FullName.Namespace, p.Containers, c)
 }
 
 func inMesh(annos map[string]string, namespace resource.Namespace, containers []v1.Container, c analysis.Context) bool {
diff --git a/galley/pkg/config/analysis/analyzers/util/service_lookup.go b/pkg/config/analysis/analyzers/util/service_lookup.go
similarity index 98%
rename from galley/pkg/config/analysis/analyzers/util/service_lookup.go
rename to pkg/config/analysis/analyzers/util/service_lookup.go
index b7827062b8..b7dae2b199 100644
--- a/galley/pkg/config/analysis/analyzers/util/service_lookup.go
+++ b/pkg/config/analysis/analyzers/util/service_lookup.go
@@ -21,7 +21,7 @@
 
 	"istio.io/api/annotation"
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collections"
 )
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go b/pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go
rename to pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go
index 79a659ff79..403dfda9a4 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go
+++ b/pkg/config/analysis/analyzers/virtualservice/conflictingmeshgatewayhosts.go
@@ -19,9 +19,9 @@
 	"strings"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/destinationhosts.go b/pkg/config/analysis/analyzers/virtualservice/destinationhosts.go
similarity index 97%
rename from galley/pkg/config/analysis/analyzers/virtualservice/destinationhosts.go
rename to pkg/config/analysis/analyzers/virtualservice/destinationhosts.go
index 2aea299d8e..7e0f0bd538 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/destinationhosts.go
+++ b/pkg/config/analysis/analyzers/virtualservice/destinationhosts.go
@@ -18,9 +18,9 @@
 	"fmt"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/destinationrules.go b/pkg/config/analysis/analyzers/virtualservice/destinationrules.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/virtualservice/destinationrules.go
rename to pkg/config/analysis/analyzers/virtualservice/destinationrules.go
index 675c5dc8b7..ede519f100 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/destinationrules.go
+++ b/pkg/config/analysis/analyzers/virtualservice/destinationrules.go
@@ -18,9 +18,9 @@
 	"fmt"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/gateways.go b/pkg/config/analysis/analyzers/virtualservice/gateways.go
similarity index 96%
rename from galley/pkg/config/analysis/analyzers/virtualservice/gateways.go
rename to pkg/config/analysis/analyzers/virtualservice/gateways.go
index 55a65b2bd8..0a3e417123 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/gateways.go
+++ b/pkg/config/analysis/analyzers/virtualservice/gateways.go
@@ -19,9 +19,9 @@
 	"strings"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go b/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
similarity index 92%
rename from galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
rename to pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
index 19f666975d..21beb22953 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
+++ b/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
@@ -17,15 +17,14 @@
 import (
 	"strings"
 
-	v1 "k8s.io/api/core/v1"
 	k8s_labels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/networking/v1alpha3"
 	"istio.io/api/security/v1beta1"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/pilot/pkg/util/constant"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
@@ -97,8 +96,7 @@ func (s *JWTClaimRouteAnalyzer) analyze(r *resource.Instance, c analysis.Context
 
 		// Check each pod selected by the gateway.
 		c.ForEach(collections.K8SCoreV1Pods.Name(), func(rPod *resource.Instance) bool {
-			pod := rPod.Message.(*v1.Pod)
-			podLabels := k8s_labels.Set(pod.ObjectMeta.Labels)
+			podLabels := k8s_labels.Set(rPod.Metadata.Labels)
 			if !gwSelector.Matches(podLabels) {
 				return true
 			}
@@ -107,7 +105,7 @@ func (s *JWTClaimRouteAnalyzer) analyze(r *resource.Instance, c analysis.Context
 			var hasRequestAuthNForPod bool
 
 			raSelectors := requestAuthNByNamespace[constants.IstioSystemNamespace]
-			raSelectors = append(raSelectors, requestAuthNByNamespace[pod.Namespace]...)
+			raSelectors = append(raSelectors, requestAuthNByNamespace[rPod.Metadata.FullName.Namespace.String()]...)
 			for _, raSelector := range raSelectors {
 				if raSelector.Matches(podLabels) {
 					hasRequestAuthNForPod = true
@@ -115,7 +113,7 @@ func (s *JWTClaimRouteAnalyzer) analyze(r *resource.Instance, c analysis.Context
 				}
 			}
 			if !hasRequestAuthNForPod {
-				m := msg.NewJwtClaimBasedRoutingWithoutRequestAuthN(r, vsRouteKey, gwFullName.String(), pod.Name)
+				m := msg.NewJwtClaimBasedRoutingWithoutRequestAuthN(r, vsRouteKey, gwFullName.String(), rPod.Metadata.FullName.Name.String())
 				c.Report(collections.IstioNetworkingV1Alpha3Virtualservices.Name(), m)
 			}
 			return true
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/regexes.go b/pkg/config/analysis/analyzers/virtualservice/regexes.go
similarity index 95%
rename from galley/pkg/config/analysis/analyzers/virtualservice/regexes.go
rename to pkg/config/analysis/analyzers/virtualservice/regexes.go
index dddd8bcc2b..ea33f0f2a6 100644
--- a/galley/pkg/config/analysis/analyzers/virtualservice/regexes.go
+++ b/pkg/config/analysis/analyzers/virtualservice/regexes.go
@@ -19,9 +19,9 @@
 	"regexp"
 
 	"istio.io/api/networking/v1alpha3"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/util.go b/pkg/config/analysis/analyzers/virtualservice/util.go
similarity index 100%
rename from galley/pkg/config/analysis/analyzers/virtualservice/util.go
rename to pkg/config/analysis/analyzers/virtualservice/util.go
diff --git a/galley/pkg/config/analysis/analyzers/webhook/webhook.go b/pkg/config/analysis/analyzers/webhook/webhook.go
diff --git a/galley/pkg/config/analysis/analyzers/webhook/webhook.go b/pkg/config/analysis/analyzers/webhook/webhook.go
similarity index 98%
rename from galley/pkg/config/analysis/analyzers/webhook/webhook.go
rename to pkg/config/analysis/analyzers/webhook/webhook.go
index d492370a70..1e94e19be6 100644
--- a/galley/pkg/config/analysis/analyzers/webhook/webhook.go
+++ b/pkg/config/analysis/analyzers/webhook/webhook.go
@@ -23,9 +23,9 @@
 	klabels "k8s.io/apimachinery/pkg/labels"
 
 	"istio.io/api/label"
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/pilot/pkg/util/sets"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/pkg/config/analysis/context.go b/pkg/config/analysis/context.go
similarity index 96%
rename from galley/pkg/config/analysis/context.go
rename to pkg/config/analysis/context.go
index bf88c31c76..8a53da2d99 100644
--- a/galley/pkg/config/analysis/context.go
+++ b/pkg/config/analysis/context.go
@@ -15,7 +15,7 @@
 package analysis
 
 import (
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 )
diff --git a/galley/pkg/config/analysis/diag/helper.go b/pkg/config/analysis/diag/helper.go
similarity index 100%
rename from galley/pkg/config/analysis/diag/helper.go
rename to pkg/config/analysis/diag/helper.go
diff --git a/galley/pkg/config/analysis/diag/level.go b/pkg/config/analysis/diag/level.go
diff --git a/galley/pkg/config/analysis/diag/level.go b/pkg/config/analysis/diag/level.go
similarity index 100%
rename from galley/pkg/config/analysis/diag/level.go
rename to pkg/config/analysis/diag/level.go
diff --git a/galley/pkg/config/analysis/diag/message.go b/pkg/config/analysis/diag/message.go
diff --git a/galley/pkg/config/analysis/diag/message.go b/pkg/config/analysis/diag/message.go
similarity index 97%
rename from galley/pkg/config/analysis/diag/message.go
rename to pkg/config/analysis/diag/message.go
index 4da9aeee0f..529a4b80c1 100644
--- a/galley/pkg/config/analysis/diag/message.go
+++ b/pkg/config/analysis/diag/message.go
@@ -92,22 +92,26 @@ func (m *Message) Unstructured(includeOrigin bool) map[string]interface{} {
 	return result
 }
 
-// UnstructuredAnalysisMessageBase returns this message as a JSON-style unstructured map in AnalaysisMessageBase
-// TODO(jasonwzm): Remove once message implements AnalysisMessageBase
-func (m *Message) UnstructuredAnalysisMessageBase() map[string]interface{} {
+func (m *Message) AnalysisMessageBase() *v1alpha1.AnalysisMessageBase {
 	docQueryString := ""
 	if m.DocRef != "" {
 		docQueryString = fmt.Sprintf("?ref=%s", m.DocRef)
 	}
 	docURL := fmt.Sprintf("%s/%s/%s", url.ConfigAnalysis, strings.ToLower(m.Type.Code()), docQueryString)
 
-	mb := v1alpha1.AnalysisMessageBase{
+	return &v1alpha1.AnalysisMessageBase{
 		DocumentationUrl: docURL,
 		Level:            v1alpha1.AnalysisMessageBase_Level(v1alpha1.AnalysisMessageBase_Level_value[strings.ToUpper(m.Type.Level().String())]),
 		Type: &v1alpha1.AnalysisMessageBase_Type{
 			Code: m.Type.Code(),
 		},
 	}
+}
+
+// UnstructuredAnalysisMessageBase returns this message as a JSON-style unstructured map in AnalaysisMessageBase
+// TODO(jasonwzm): Remove once message implements AnalysisMessageBase
+func (m *Message) UnstructuredAnalysisMessageBase() map[string]interface{} {
+	mb := m.AnalysisMessageBase()
 
 	var r map[string]interface{}
 
diff --git a/galley/pkg/config/analysis/diag/message_test.go b/pkg/config/analysis/diag/message_test.go
similarity index 95%
rename from galley/pkg/config/analysis/diag/message_test.go
rename to pkg/config/analysis/diag/message_test.go
index 41380c4bda..36cc36f811 100644
--- a/galley/pkg/config/analysis/diag/message_test.go
+++ b/pkg/config/analysis/diag/message_test.go
@@ -91,8 +91,8 @@ func TestMessage_UnstructuredAnalysisMessageBase(t *testing.T) {
 	m.DocRef = "test-ref"
 
 	mb := m.UnstructuredAnalysisMessageBase()
-	g.Expect(mb["documentation_url"]).To(Equal(fmt.Sprintf("%s/%s/%s", url.ConfigAnalysis, "ist0042", "?ref=test-ref")))
-	g.Expect(mb["level"]).To(Equal(3.))
+	g.Expect(mb["documentationUrl"]).To(Equal(fmt.Sprintf("%s/%s/%s", url.ConfigAnalysis, "ist0042", "?ref=test-ref")))
+	g.Expect(mb["level"]).To(Equal("ERROR"))
 	g.Expect(mb["type"]).To(Equal(
 		map[string]interface{}{
 			"code": "IST0042",
diff --git a/galley/pkg/config/analysis/diag/messages.go b/pkg/config/analysis/diag/messages.go
similarity index 100%
rename from galley/pkg/config/analysis/diag/messages.go
rename to pkg/config/analysis/diag/messages.go
diff --git a/galley/pkg/config/analysis/diag/messages_test.go b/pkg/config/analysis/diag/messages_test.go
diff --git a/galley/pkg/config/analysis/diag/messages_test.go b/pkg/config/analysis/diag/messages_test.go
similarity index 100%
rename from galley/pkg/config/analysis/diag/messages_test.go
rename to pkg/config/analysis/diag/messages_test.go
diff --git a/pkg/config/analysis/equivalence.go b/pkg/config/analysis/equivalence.go
diff --git a/pkg/config/analysis/equivalence.go b/pkg/config/analysis/equivalence.go
new file mode 100644
index 0000000000..df0bdc0301
--- /dev/null
+++ b/pkg/config/analysis/equivalence.go
@@ -0,0 +1,74 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package analysis
+
+import (
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+)
+
+var globals = map[collection.Schema]collection.Schema{
+	collections.K8SExtensionsIstioIoV1Alpha1Wasmplugins:         collections.IstioExtensionsV1Alpha1Wasmplugins,
+	collections.K8SNetworkingIstioIoV1Alpha3Destinationrules:    collections.IstioNetworkingV1Alpha3Destinationrules,
+	collections.K8SNetworkingIstioIoV1Alpha3Envoyfilters:        collections.IstioNetworkingV1Alpha3Envoyfilters,
+	collections.K8SNetworkingIstioIoV1Alpha3Gateways:            collections.IstioNetworkingV1Alpha3Gateways,
+	collections.K8SNetworkingIstioIoV1Alpha3Serviceentries:      collections.IstioNetworkingV1Alpha3Serviceentries,
+	collections.K8SNetworkingIstioIoV1Alpha3Sidecars:            collections.IstioNetworkingV1Alpha3Sidecars,
+	collections.K8SNetworkingIstioIoV1Alpha3Virtualservices:     collections.IstioNetworkingV1Alpha3Virtualservices,
+	collections.K8SNetworkingIstioIoV1Alpha3Workloadentries:     collections.IstioNetworkingV1Alpha3Workloadentries,
+	collections.K8SNetworkingIstioIoV1Alpha3Workloadgroups:      collections.IstioNetworkingV1Alpha3Workloadgroups,
+	collections.K8SNetworkingIstioIoV1Beta1Proxyconfigs:         collections.IstioNetworkingV1Beta1Proxyconfigs,
+	collections.K8SSecurityIstioIoV1Beta1Authorizationpolicies:  collections.IstioSecurityV1Beta1Authorizationpolicies,
+	collections.K8SSecurityIstioIoV1Beta1Peerauthentications:    collections.IstioSecurityV1Beta1Peerauthentications,
+	collections.K8SSecurityIstioIoV1Beta1Requestauthentications: collections.IstioSecurityV1Beta1Requestauthentications,
+	collections.K8STelemetryIstioIoV1Alpha1Telemetries:          collections.IstioTelemetryV1Alpha1Telemetries,
+}
+
+func AreEquivalent(one, two collection.Schema) bool {
+	if eq, ok := globals[one]; ok {
+		return two == eq
+	}
+	if eq, ok := globals[two]; ok {
+		return one == eq
+	}
+	return one == two
+}
+
+func ContainmentMap(schemas collection.Schemas) map[collection.Name]struct{} {
+	out := map[collection.Name]struct{}{}
+	for schema := range ContainmentMapSchema(schemas) {
+		out[schema.Name()] = struct{}{}
+	}
+	return out
+}
+
+func ContainmentMapSchema(schemas collection.Schemas) map[collection.Schema]struct{} {
+	reverseMap := map[collection.Schema]collection.Schema{}
+	for k, v := range globals {
+		reverseMap[v] = k
+	}
+	out := map[collection.Schema]struct{}{}
+	for _, schema := range schemas.All() {
+		out[schema] = struct{}{}
+		if val, ok := globals[schema]; ok {
+			out[val] = struct{}{}
+		} else if val, ok := reverseMap[schema]; ok {
+			out[val] = struct{}{}
+		}
+	}
+	return out
+}
diff --git a/pkg/config/analysis/incluster/controller.go b/pkg/config/analysis/incluster/controller.go
new file mode 100644
index 0000000000..8d0b89b121
--- /dev/null
+++ b/pkg/config/analysis/incluster/controller.go
@@ -0,0 +1,125 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package incluster
+
+import (
+	"fmt"
+	"strings"
+	"time"
+
+	v1alpha12 "istio.io/api/analysis/v1alpha1"
+	"istio.io/api/meta/v1alpha1"
+	"istio.io/istio/pilot/pkg/config/kube/arbitraryclient"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
+	"istio.io/istio/pkg/config/resource"
+	"istio.io/istio/pkg/config/schema"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/kube"
+	"istio.io/pkg/log"
+)
+
+// Controller manages repeatedly running analyzers in istiod, and reporting results
+// via istio status fields.
+type Controller struct {
+	analyzer  *local.IstiodAnalyzer
+	statusctl *status.Controller
+}
+
+func NewController(stop <-chan struct{}, rwConfigStore, configController model.ConfigStoreCache,
+	kubeClient kube.Client, namespace string, statusManager *status.Manager, domainSuffix string) (*Controller, error) {
+	ia := local.NewIstiodAnalyzer(schema.MustBuildMetadata(configController.Schemas()), analyzers.AllCombined(),
+		"", resource.Namespace(namespace), func(name collection.Name) {}, true)
+	ia.AddSource(rwConfigStore)
+	ctx := status.NewIstioContext(stop)
+	// TODO: many of the types in PilotGatewayAPI (watched above) are duplicated
+	// I'm not sure why, but we shouldn't watch them twice.
+	duplicates := []collection.Schema{}
+	for k := range analysis.ContainmentMapSchema(rwConfigStore.Schemas()) {
+		duplicates = append(duplicates, k)
+	}
+	store, err := arbitraryclient.NewForSchemas(ctx, kubeClient, "default",
+		domainSuffix, collections.All.Remove(duplicates...))
+	if err != nil {
+		return nil, fmt.Errorf("unable to load common types for analysis, releasing lease: %v", err)
+	}
+	ia.AddSource(store)
+	kubeClient.RunAndWait(stop)
+	err = ia.Init(stop)
+	if err != nil {
+		return nil, fmt.Errorf("unable to initialize analysis controller, releasing lease: %s", err)
+	}
+	ctl := statusManager.CreateIstioStatusController(func(status *v1alpha1.IstioStatus, context interface{}) *v1alpha1.IstioStatus {
+		msgs := context.(diag.Messages)
+		// zero out analysis messages, as this is the sole controller for those
+		status.ValidationMessages = []*v1alpha12.AnalysisMessageBase{}
+		for _, msg := range msgs {
+			status.ValidationMessages = append(status.ValidationMessages, msg.AnalysisMessageBase())
+		}
+		return status
+	})
+	return &Controller{analyzer: ia, statusctl: ctl}, nil
+}
+
+// Run is blocking
+func (c *Controller) Run(stop <-chan struct{}) {
+	t := time.NewTicker(10 * time.Second)
+	oldmsgs := diag.Messages{}
+	for {
+		select {
+		case <-t.C:
+			res, err := c.analyzer.ReAnalyze(stop)
+			if err != nil {
+				log.Errorf("In-cluster analysis has failed: %s", err)
+				continue
+			}
+			// reorganize messages to map
+			index := map[status.Resource]diag.Messages{}
+			for _, m := range res.Messages {
+				key := status.ResourceFromMetadata(m.Resource.Metadata)
+				index[key] = append(index[key], m)
+			}
+			// if we previously had a message that has been removed, ensure it is removed
+			// TODO: this creates a state destruction problem when istiod crashes
+			// in that old messages may not be removed.  Not sure how to fix this
+			// other than write every object's status every loop.
+			for _, m := range oldmsgs {
+				key := status.ResourceFromMetadata(m.Resource.Metadata)
+				if _, ok := index[key]; !ok {
+					index[key] = diag.Messages{}
+				}
+			}
+			for r, m := range index {
+				// don't try to write status for non-istio types
+				if strings.HasSuffix(r.Group, "istio.io") {
+					log.Debugf("enqueueing update for %s/%s", r.Namespace, r.Name)
+					c.statusctl.EnqueueStatusUpdateResource(m, r)
+				}
+			}
+			oldmsgs = res.Messages
+			log.Debugf("finished enqueueing all statuses")
+		case <-stop:
+			t.Stop()
+			break
+		}
+	}
+}
diff --git a/galley/pkg/config/analysis/local/analyze_test.go b/pkg/config/analysis/local/analyze_test.go
similarity index 58%
rename from galley/pkg/config/analysis/local/analyze_test.go
rename to pkg/config/analysis/local/analyze_test.go
index a4f5bfeb5a..d65f58c579 100644
--- a/galley/pkg/config/analysis/local/analyze_test.go
+++ b/pkg/config/analysis/local/analyze_test.go
@@ -17,6 +17,7 @@
 	"context"
 	"fmt"
 	"os"
+	"strings"
 	"testing"
 	"time"
 
@@ -24,17 +25,11 @@
 	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/source/inmemory"
-	kubesource "istio.io/istio/galley/pkg/config/source/kube"
-	"istio.io/istio/galley/pkg/config/source/kube/apiserver"
-	kube_inmemory "istio.io/istio/galley/pkg/config/source/kube/inmemory"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/k8smeta"
-	"istio.io/istio/galley/pkg/config/util/kubeyaml"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/legacy/testing/k8smeta"
+	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collection"
@@ -52,6 +47,16 @@ type testAnalyzer struct {
 }
 
 var (
+	// YamlN1I1V1 is a testing resource in Yaml form
+	YamlN1I1V1 = `
+apiVersion: testdata.istio.io/v1alpha1
+kind: Kind1
+metadata:
+  namespace: n1
+  name: i1
+spec:
+  n1_i1: v1
+`
 	blankCombinedAnalyzer = analysis.Combine("testCombined", blankTestAnalyzer)
 	timeout               = 1 * time.Second
 )
@@ -74,7 +79,7 @@ func TestAbortWithNoSources(t *testing.T) {
 
 	cancel := make(chan struct{})
 
-	sa := NewSourceAnalyzer(k8smeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(k8smeta.NewMustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 	_, err := sa.Analyze(cancel)
 	g.Expect(err).To(Not(BeNil()))
 }
@@ -88,8 +93,8 @@ func TestAnalyzersRun(t *testing.T) {
 	m := msg.NewInternalError(r, "msg")
 	a := &testAnalyzer{
 		fn: func(ctx analysis.Context) {
-			ctx.Exists(basicmeta.K8SCollection1.Name(), resource.NewFullName("", ""))
-			ctx.Report(basicmeta.K8SCollection1.Name(), m)
+			ctx.Exists(K8SCollection1.Name(), resource.NewFullName("", ""))
+			ctx.Report(K8SCollection1.Name(), m)
 		},
 	}
 
@@ -98,14 +103,14 @@ func TestAnalyzersRun(t *testing.T) {
 		collectionAccessed = col
 	}
 
-	sa := NewSourceAnalyzer(schema.MustGet(), analysis.Combine("a", a), "", "", cr, false, timeout)
+	sa := NewSourceAnalyzer(schema.NewMustGet(), analysis.Combine("a", a), "", "", cr, false, timeout)
 	err := sa.AddReaderKubeSource(nil)
 	g.Expect(err).To(BeNil())
 
 	result, err := sa.Analyze(cancel)
 	g.Expect(err).To(BeNil())
 	g.Expect(result.Messages).To(ConsistOf(m))
-	g.Expect(collectionAccessed).To(Equal(basicmeta.K8SCollection1.Name()))
+	g.Expect(collectionAccessed).To(Equal(K8SCollection1.Name()))
 	g.Expect(result.ExecutedAnalyzers).To(ConsistOf(a.Metadata().Name))
 }
 
@@ -120,12 +125,12 @@ func TestFilterOutputByNamespace(t *testing.T) {
 	msg2 := msg.NewInternalError(r2, "msg")
 	a := &testAnalyzer{
 		fn: func(ctx analysis.Context) {
-			ctx.Report(basicmeta.K8SCollection1.Name(), msg1)
-			ctx.Report(basicmeta.K8SCollection1.Name(), msg2)
+			ctx.Report(K8SCollection1.Name(), msg1)
+			ctx.Report(K8SCollection1.Name(), msg2)
 		},
 	}
 
-	sa := NewSourceAnalyzer(schema.MustGet(), analysis.Combine("a", a), "ns1", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(schema.NewMustGet(), analysis.Combine("a", a), "ns1", "", nil, false, timeout)
 	err := sa.AddReaderKubeSource(nil)
 	g.Expect(err).To(BeNil())
 
@@ -137,14 +142,13 @@ func TestFilterOutputByNamespace(t *testing.T) {
 func TestAddInMemorySource(t *testing.T) {
 	g := NewWithT(t)
 
-	sa := NewSourceAnalyzer(k8smeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(k8smeta.NewMustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 
-	src := inmemory.New(sa.kubeResources)
-	sa.AddInMemorySource(src)
-	g.Expect(*sa.meshCfg).To(Equal(*mesh.DefaultMeshConfig())) // Base default meshcfg
+	src := model.NewFakeStore()
+	sa.AddSource(dfCache{ConfigStore: src})
+	g.Expect(*sa.meshCfg).To(Equal(mesh.DefaultMeshConfig())) // Base default meshcfg
 	g.Expect(sa.meshNetworks.Networks).To(HaveLen(0))
-	g.Expect(sa.sources).To(HaveLen(1))
-	g.Expect(sa.sources[0].src).To(BeAssignableToTypeOf(&inmemory.Source{})) // Resources via in-memory server
+	g.Expect(sa.stores).To(HaveLen(1))
 }
 
 func TestAddRunningKubeSource(t *testing.T) {
@@ -152,13 +156,12 @@ func TestAddRunningKubeSource(t *testing.T) {
 
 	mk := kube.NewFakeClient()
 
-	sa := NewSourceAnalyzer(k8smeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(k8smeta.NewMustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 
-	sa.AddRunningKubeSource(kubesource.NewInterfacesFromClient(mk))
-	g.Expect(*sa.meshCfg).To(Equal(*mesh.DefaultMeshConfig())) // Base default meshcfg
+	sa.AddRunningKubeSource(mk)
+	g.Expect(*sa.meshCfg).To(Equal(mesh.DefaultMeshConfig())) // Base default meshcfg
 	g.Expect(sa.meshNetworks.Networks).To(HaveLen(0))
-	g.Expect(sa.sources).To(HaveLen(1))
-	g.Expect(sa.sources[0].src).To(BeAssignableToTypeOf(&apiserver.Source{})) // Resources via api server
+	g.Expect(sa.stores).To(HaveLen(2))
 }
 
 func TestAddRunningKubeSourceWithIstioMeshConfigMap(t *testing.T) {
@@ -183,28 +186,26 @@ func TestAddRunningKubeSourceWithIstioMeshConfigMap(t *testing.T) {
 		t.Fatalf("Error creating mesh config configmap: %v", err)
 	}
 
-	sa := NewSourceAnalyzer(k8smeta.MustGet(), blankCombinedAnalyzer, "", istioNamespace, nil, false, timeout)
+	sa := NewSourceAnalyzer(k8smeta.NewMustGet(), blankCombinedAnalyzer, "", istioNamespace, nil, false, timeout)
 
-	sa.AddRunningKubeSource(kubesource.NewInterfacesFromClient(mk))
+	sa.AddRunningKubeSource(mk)
 	g.Expect(sa.meshCfg.RootNamespace).To(Equal(testRootNamespace))
 	g.Expect(sa.meshNetworks.Networks).To(HaveLen(2))
-	g.Expect(sa.sources).To(HaveLen(1))
-	g.Expect(sa.sources[0].src).To(BeAssignableToTypeOf(&apiserver.Source{})) // Resources via api server
+	g.Expect(sa.stores).To(HaveLen(2))
 }
 
 func TestAddReaderKubeSource(t *testing.T) {
 	g := NewWithT(t)
 
-	sa := NewSourceAnalyzer(basicmeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(schema.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 
-	tmpfile := tempFileFromString(t, data.YamlN1I1V1)
+	tmpfile := tempFileFromString(t, YamlN1I1V1)
 	defer os.Remove(tmpfile.Name())
 
 	err := sa.AddReaderKubeSource([]ReaderSource{{Reader: tmpfile}})
 	g.Expect(err).To(BeNil())
-	g.Expect(*sa.meshCfg).To(Equal(*mesh.DefaultMeshConfig())) // Base default meshcfg
-	g.Expect(sa.sources).To(HaveLen(1))
-	g.Expect(sa.sources[0].src).To(BeAssignableToTypeOf(&kube_inmemory.KubeSource{})) // Resources via files
+	g.Expect(*sa.meshCfg).To(Equal(mesh.DefaultMeshConfig())) // Base default meshcfg
+	g.Expect(sa.stores).To(HaveLen(0))
 
 	// Note that a blank file for mesh cfg is equivalent to specifying all the defaults
 	testRootNamespace := "testNamespace"
@@ -219,20 +220,45 @@ func TestAddReaderKubeSource(t *testing.T) {
 func TestAddReaderKubeSourceSkipsBadEntries(t *testing.T) {
 	g := NewWithT(t)
 
-	sa := NewSourceAnalyzer(basicmeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(schema.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 
-	tmpfile := tempFileFromString(t, kubeyaml.JoinString(data.YamlN1I1V1, "bogus resource entry\n"))
+	tmpfile := tempFileFromString(t, JoinString(YamlN1I1V1, "bogus resource entry\n"))
 	defer func() { _ = os.Remove(tmpfile.Name()) }()
 
 	err := sa.AddReaderKubeSource([]ReaderSource{{Reader: tmpfile}})
 	g.Expect(err).To(Not(BeNil()))
-	g.Expect(sa.sources).To(HaveLen(1))
+}
+
+const (
+	yamlSeparator = "---\n"
+)
+
+// JoinString joins the given yaml parts into a single multipart document.
+func JoinString(parts ...string) string {
+	var st strings.Builder
+
+	var lastIsNewLine bool
+	for _, p := range parts {
+		if len(p) == 0 {
+			continue
+		}
+		if st.Len() != 0 {
+			if !lastIsNewLine {
+				_, _ = st.WriteString("\n")
+			}
+			st.WriteString(yamlSeparator)
+		}
+		_, _ = st.WriteString(p)
+		lastIsNewLine = p[len(p)-1] == '\n'
+	}
+
+	return st.String()
 }
 
 func TestDefaultResourcesRespectsMeshConfig(t *testing.T) {
 	g := NewWithT(t)
 
-	sa := NewSourceAnalyzer(basicmeta.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
+	sa := NewSourceAnalyzer(schema.MustGet(), blankCombinedAnalyzer, "", "", nil, false, timeout)
 
 	// With ingress off, we shouldn't generate any default resources
 	ingressOffMeshCfg := tempFileFromString(t, "ingressControllerMode: 'OFF'")
@@ -241,7 +267,7 @@ func TestDefaultResourcesRespectsMeshConfig(t *testing.T) {
 	err := sa.AddFileKubeMeshConfig(ingressOffMeshCfg.Name())
 	g.Expect(err).To(BeNil())
 	sa.AddDefaultResources()
-	g.Expect(sa.sources).To(BeEmpty())
+	g.Expect(sa.stores).To(BeEmpty())
 
 	// With ingress on, though, we should.
 	ingressStrictMeshCfg := tempFileFromString(t, "ingressControllerMode: 'STRICT'")
@@ -250,39 +276,7 @@ func TestDefaultResourcesRespectsMeshConfig(t *testing.T) {
 	err = sa.AddFileKubeMeshConfig(ingressStrictMeshCfg.Name())
 	g.Expect(err).To(BeNil())
 	sa.AddDefaultResources()
-	g.Expect(sa.sources).To(HaveLen(1))
-}
-
-func TestResourceFiltering(t *testing.T) {
-	g := NewWithT(t)
-
-	// Set up mock apiServer so we can peek at the options it gets started with
-	prevApiserverNew := apiserverNew
-	defer func() { apiserverNew = prevApiserverNew }()
-	var recordedOptions apiserver.Options
-	apiserverNew = func(o apiserver.Options) *apiserver.Source {
-		recordedOptions = o
-		return nil
-	}
-
-	usedCollection := k8smeta.K8SCoreV1Services
-	a := &testAnalyzer{
-		fn:     func(_ analysis.Context) {},
-		inputs: []collection.Name{usedCollection.Name()},
-	}
-	mk := kube.NewFakeClient()
-
-	sa := NewSourceAnalyzer(schema.MustGet(), analysis.Combine("a", a), "", "", nil, true, timeout)
-	sa.AddRunningKubeSource(kubesource.NewInterfacesFromClient(mk))
-
-	// All but the used collection should be disabled
-	for _, r := range recordedOptions.Schemas.All() {
-		if r.Name() == usedCollection.Name() {
-			g.Expect(r.IsDisabled()).To(BeFalse(), fmt.Sprintf("%s should not be disabled", r.Name()))
-		} else {
-			g.Expect(r.IsDisabled()).To(BeTrue(), fmt.Sprintf("%s should be disabled", r.Name()))
-		}
-	}
+	g.Expect(sa.stores).To(HaveLen(0))
 }
 
 func tempFileFromString(t *testing.T, content string) *os.File {
diff --git a/pkg/config/analysis/local/context.go b/pkg/config/analysis/local/context.go
new file mode 100644
index 0000000000..052170ac4b
--- /dev/null
+++ b/pkg/config/analysis/local/context.go
@@ -0,0 +1,202 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package local
+
+import (
+	"encoding/json"
+	"fmt"
+
+	"istio.io/istio/pilot/pkg/config/file"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/legacy/source/kube"
+	"istio.io/istio/pkg/config/resource"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/pkg/log"
+)
+
+// NewContext allows tests to use istiodContext without exporting it.  returned context is not threadsafe.
+func NewContext(store model.ConfigStore, cancelCh <-chan struct{}, collectionReporter CollectionReporterFn) analysis.Context {
+	return &istiodContext{
+		store:              store,
+		cancelCh:           cancelCh,
+		messages:           diag.Messages{},
+		collectionReporter: collectionReporter,
+		found:              map[key]*resource.Instance{},
+		foundCollections:   map[collection.Name]map[resource.FullName]*resource.Instance{},
+	}
+}
+
+type istiodContext struct {
+	store              model.ConfigStore
+	cancelCh           <-chan struct{}
+	messages           diag.Messages
+	collectionReporter CollectionReporterFn
+	found              map[key]*resource.Instance
+	foundCollections   map[collection.Name]map[resource.FullName]*resource.Instance
+}
+
+type key struct {
+	collectionName collection.Name
+	name           resource.FullName
+}
+
+func (i *istiodContext) Report(c collection.Name, m diag.Message) {
+	i.messages.Add(m)
+}
+
+func (i *istiodContext) Find(col collection.Name, name resource.FullName) *resource.Instance {
+	i.collectionReporter(col)
+	if result, ok := i.found[key{col, name}]; ok {
+		return result
+	}
+	if cache, ok := i.foundCollections[col]; ok {
+		if result, ok2 := cache[name]; ok2 {
+			return result
+		}
+	}
+	colschema, ok := collections.All.Find(col.String())
+	if !ok {
+		log.Warnf("collection %s could not be found", col.String())
+		return nil
+	}
+	cfg := i.store.Get(colschema.Resource().GroupVersionKind(), name.Name.String(), name.Namespace.String())
+	if cfg == nil {
+		return nil
+	}
+	result, err := cfgToInstance(*cfg, col, colschema)
+	if err != nil {
+		log.Errorf("failed converting found config %s %s/%s to instance: %s, ",
+			cfg.Meta.GroupVersionKind.Kind, cfg.Meta.Namespace, cfg.Meta.Namespace, err)
+		return nil
+	}
+	i.found[key{col, name}] = result
+	return result
+}
+
+func (i *istiodContext) Exists(col collection.Name, name resource.FullName) bool {
+	i.collectionReporter(col)
+	return i.Find(col, name) != nil
+}
+
+func (i *istiodContext) ForEach(col collection.Name, fn analysis.IteratorFn) {
+	i.collectionReporter(col)
+	if cached, ok := i.foundCollections[col]; ok {
+		for _, res := range cached {
+			if !fn(res) {
+				break
+			}
+		}
+		return
+	}
+	colschema, ok := collections.All.Find(col.String())
+	if !ok {
+		// TODO: demote this log before merging
+		log.Errorf("collection %s could not be found", col.String())
+		return
+	}
+	// TODO: this needs to include file source as well
+	cfgs, err := i.store.List(colschema.Resource().GroupVersionKind(), "")
+	if err != nil {
+		// TODO: demote this log before merging
+		log.Errorf("collection %s could not be listed: %s", col.String(), err)
+		return
+	}
+	broken := false
+	cache := map[resource.FullName]*resource.Instance{}
+	for _, cfg := range cfgs {
+		k := key{
+			col, resource.FullName{
+				Name:      resource.LocalName(cfg.Name),
+				Namespace: resource.Namespace(cfg.Namespace),
+			},
+		}
+		if res, ok := i.found[k]; ok {
+			if !broken && !fn(res) {
+				broken = true
+			}
+			cache[res.Metadata.FullName] = res
+			continue
+		}
+		res, err := cfgToInstance(cfg, col, colschema)
+		if err != nil {
+			// TODO: demote this log before merging
+			log.Error(err)
+			// TODO: is continuing the right thing here?
+			continue
+		}
+		if !broken && !fn(res) {
+			broken = true
+		}
+		cache[res.Metadata.FullName] = res
+	}
+	if len(cache) > 0 {
+		i.foundCollections[col] = cache
+	}
+}
+
+func (i *istiodContext) Canceled() bool {
+	select {
+	case <-i.cancelCh:
+		return true
+	default:
+		return false
+	}
+}
+
+func cfgToInstance(cfg config.Config, col collection.Name, colschema collection.Schema) (*resource.Instance, error) {
+	mcpr, err := config.PilotConfigToResource(&cfg)
+	if err != nil {
+		return nil, fmt.Errorf("failed converting cfg %s to mcp resource: %s", cfg.Name, err)
+	}
+	res, err := resource.Deserialize(mcpr, colschema.Resource())
+	// TODO: why does this leave origin empty?
+	if err != nil {
+		return nil, fmt.Errorf("failed deserializing mcp resource %s to instance: %s", cfg.Name, err)
+	}
+	fmstring := cfg.Meta.Annotations[file.FieldMapKey]
+	var out map[string]int
+	if fmstring != "" {
+		err := json.Unmarshal([]byte(fmstring), &out)
+		if err != nil {
+			return nil, fmt.Errorf("error parsing fieldmap: %s", err)
+		}
+	}
+	refstring := cfg.Meta.Annotations[file.ReferenceKey]
+	var outref resource.Reference
+	if refstring != "" {
+		outref = &kube.Position{}
+		err := json.Unmarshal([]byte(refstring), outref)
+		if err != nil {
+			return nil, fmt.Errorf("error parsing reference: %s", err)
+		}
+	}
+	res.Origin = &kube.Origin{
+		Collection: col,
+		Kind:       colschema.Resource().Kind(),
+		FullName:   res.Metadata.FullName,
+		Version:    resource.Version(cfg.ResourceVersion),
+		Ref:        outref,
+		FieldsMap:  out,
+	}
+	// MCP is not aware of generation, add that here.
+	res.Metadata.Generation = cfg.Generation
+	return res, nil
+}
diff --git a/galley/pkg/config/analysis/local/defaults.go b/pkg/config/analysis/local/defaults.go
similarity index 100%
rename from galley/pkg/config/analysis/local/defaults.go
rename to pkg/config/analysis/local/defaults.go
diff --git a/pkg/config/analysis/local/helpers_test.go b/pkg/config/analysis/local/helpers_test.go
diff --git a/pkg/config/analysis/local/helpers_test.go b/pkg/config/analysis/local/helpers_test.go
new file mode 100644
index 0000000000..d1a5b952df
--- /dev/null
+++ b/pkg/config/analysis/local/helpers_test.go
@@ -0,0 +1,80 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package local
+
+// Test helpers common to this package
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/gogo/protobuf/types"
+
+	"istio.io/istio/pkg/config/legacy/source/kube"
+	"istio.io/istio/pkg/config/resource"
+	"istio.io/istio/pkg/config/schema/collection"
+	r2 "istio.io/istio/pkg/config/schema/resource"
+	"istio.io/istio/pkg/config/validation"
+)
+
+// K8SCollection1 describes the collection k8s/collection1
+var K8SCollection1 = collection.Builder{
+	Name:         "k8s/collection1",
+	VariableName: "K8SCollection1",
+	Disabled:     false,
+	Resource: r2.Builder{
+		Group:         "testdata.istio.io",
+		Kind:          "Kind1",
+		Plural:        "Kind1s",
+		Version:       "v1alpha1",
+		Proto:         "google.protobuf.Struct",
+		ReflectType:   reflect.TypeOf(&types.Struct{}).Elem(),
+		ProtoPackage:  "github.com/gogo/protobuf/types",
+		ClusterScoped: false,
+		ValidateProto: validation.EmptyValidate,
+	}.MustBuild(),
+}.MustBuild()
+
+// Collection2 describes the collection collection2
+var Collection2 = collection.Builder{
+	Name:         "collection2",
+	VariableName: "Collection2",
+	Disabled:     false,
+	Resource: r2.Builder{
+		Group:         "testdata.istio.io",
+		Kind:          "Kind1",
+		Plural:        "Kind1s",
+		Version:       "v1alpha1",
+		Proto:         "google.protobuf.Struct",
+		ReflectType:   reflect.TypeOf(&types.Struct{}).Elem(),
+		ProtoPackage:  "github.com/gogo/protobuf/types",
+		ClusterScoped: false,
+		ValidateProto: validation.EmptyValidate,
+	}.MustBuild(),
+}.MustBuild()
+
+func createTestResource(t *testing.T, ns, name, version string) *resource.Instance {
+	t.Helper()
+	rname := resource.NewFullName(resource.Namespace(ns), resource.LocalName(name))
+	return &resource.Instance{
+		Metadata: resource.Metadata{
+			FullName: rname,
+			Version:  resource.Version(version),
+		},
+		Message: &types.Empty{},
+		Origin: &kube.Origin{
+			FullName: rname,
+		},
+	}
+}
diff --git a/pkg/config/analysis/local/istiod_analyze.go b/pkg/config/analysis/local/istiod_analyze.go
new file mode 100644
index 0000000000..444a4000aa
--- /dev/null
+++ b/pkg/config/analysis/local/istiod_analyze.go
@@ -0,0 +1,493 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package local
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"os"
+	"strings"
+	"time"
+
+	"github.com/hashicorp/go-multierror"
+	"github.com/ryanuber/go-glob"
+	kerrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/tools/cache"
+
+	"istio.io/api/annotation"
+	"istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pilot/pkg/config/aggregate"
+	"istio.io/istio/pilot/pkg/config/file"
+	"istio.io/istio/pilot/pkg/config/kube/arbitraryclient"
+	"istio.io/istio/pilot/pkg/config/kube/crdclient"
+	"istio.io/istio/pilot/pkg/config/memory"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/scope"
+	mesh_const "istio.io/istio/pkg/config/legacy/mesh"
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
+	"istio.io/istio/pkg/config/legacy/processor/transforms"
+	"istio.io/istio/pkg/config/legacy/util/kuberesource"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/config/resource"
+	"istio.io/istio/pkg/config/schema"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	kubelib "istio.io/istio/pkg/kube"
+)
+
+// IstiodAnalyzer handles local analysis of k8s event sources, both live and file-based
+type IstiodAnalyzer struct {
+	m *schema.Metadata
+	// sources              []precedenceSourceInput
+	internalStore        model.ConfigStore
+	stores               []model.ConfigStoreCache
+	analyzer             *analysis.CombinedAnalyzer
+	transformerProviders transformer.Providers
+	namespace            resource.Namespace
+	istioNamespace       resource.Namespace
+
+	initializedStore model.ConfigStoreCache
+
+	// List of code and resource suppressions to exclude messages on
+	suppressions []AnalysisSuppression
+
+	// Mesh config for this analyzer. This can come from multiple sources, and the last added version will take precedence.
+	meshCfg *v1alpha1.MeshConfig
+
+	// Mesh networks config for this analyzer.
+	meshNetworks *v1alpha1.MeshNetworks
+
+	// Which kube resources are used by this analyzer
+	// Derived from metadata and the specified analyzer and transformer providers
+	kubeResources collection.Schemas
+
+	// Hook function called when a collection is used in analysis
+	collectionReporter CollectionReporterFn
+
+	fileSource   *file.KubeSource
+	clientsToRun []kubelib.Client
+}
+
+// NewSourceAnalyzer is a drop-in replacement for the galley function, adapting to istiod analyzer.
+func NewSourceAnalyzer(m *schema.Metadata, analyzer *analysis.CombinedAnalyzer, namespace, istioNamespace resource.Namespace,
+	cr CollectionReporterFn, serviceDiscovery bool, _ time.Duration) *IstiodAnalyzer {
+	return NewIstiodAnalyzer(m, analyzer, namespace, istioNamespace, cr, serviceDiscovery)
+}
+
+// NewIstiodAnalyzer creates a new IstiodAnalyzer with no sources. Use the Add*Source
+// methods to add sources in ascending precedence order,
+// then execute Analyze to perform the analysis
+func NewIstiodAnalyzer(m *schema.Metadata, analyzer *analysis.CombinedAnalyzer, namespace,
+	istioNamespace resource.Namespace, cr CollectionReporterFn, serviceDiscovery bool) *IstiodAnalyzer {
+	// collectionReporter hook function defaults to no-op
+	if cr == nil {
+		cr = func(collection.Name) {}
+	}
+
+	transformerProviders := transforms.Providers(m)
+
+	// Get the closure of all input collections for our analyzer, paying attention to transforms
+	kubeResources := kuberesource.DisableExcludedCollections(
+		m.KubeCollections(),
+		transformerProviders,
+		analyzer.Metadata().Inputs,
+		kuberesource.DefaultExcludedResourceKinds(),
+		serviceDiscovery)
+
+	kubeResources = kubeResources.WithoutDisabledCollections()
+
+	mcfg := mesh.DefaultMeshConfig()
+	sa := &IstiodAnalyzer{
+		m:                    m,
+		meshCfg:              &mcfg,
+		meshNetworks:         mesh.DefaultMeshNetworks(),
+		analyzer:             analyzer,
+		transformerProviders: transformerProviders,
+		namespace:            namespace,
+		internalStore:        memory.Make(collection.SchemasFor(collections.IstioMeshV1Alpha1MeshNetworks, collections.IstioMeshV1Alpha1MeshConfig)),
+		istioNamespace:       istioNamespace,
+		kubeResources:        kubeResources,
+		collectionReporter:   cr,
+	}
+
+	return sa
+}
+
+// ReAnalyze loads the sources and executes the analysis, assuming init is already called
+func (sa *IstiodAnalyzer) ReAnalyze(cancel <-chan struct{}) (AnalysisResult, error) {
+	var result AnalysisResult
+	store := sa.initializedStore
+	allSchemas := store.Schemas()
+	result.SkippedAnalyzers = sa.analyzer.RemoveSkipped(allSchemas,
+		sa.kubeResources.DisabledCollectionNames(), sa.transformerProviders)
+	result.ExecutedAnalyzers = sa.analyzer.AnalyzerNames()
+
+	cache.WaitForCacheSync(cancel,
+		store.HasSynced)
+
+	ctx := NewContext(store, cancel, sa.collectionReporter)
+
+	sa.analyzer.Analyze(ctx)
+
+	namespaces := make(map[resource.Namespace]struct{})
+	if sa.namespace != "" {
+		namespaces[sa.namespace] = struct{}{}
+	}
+	// TODO: analysis is run for all namespaces, even if they are requested to be filtered.
+	msgs := filterMessages(ctx.(*istiodContext).messages, namespaces, sa.suppressions)
+	result.Messages = msgs.SortedDedupedCopy()
+
+	return result, nil
+}
+
+// Analyze loads the sources and executes the analysis
+func (sa *IstiodAnalyzer) Analyze(cancel <-chan struct{}) (AnalysisResult, error) {
+	err2 := sa.Init(cancel)
+	if err2 != nil {
+		return AnalysisResult{}, err2
+	}
+	return sa.ReAnalyze(cancel)
+}
+
+func (sa *IstiodAnalyzer) Init(cancel <-chan struct{}) error {
+	// We need at least one non-meshcfg source
+	if len(sa.stores) == 0 && sa.fileSource == nil {
+		return fmt.Errorf("at least one file and/or Kubernetes source must be provided")
+	}
+
+	// TODO: there's gotta be a better way to convert v1meshconfig to config.Config...
+	// Create a store containing mesh config. There should be exactly one.
+	_, err := sa.internalStore.Create(config.Config{
+		Meta: config.Meta{
+			Name:             mesh_const.MeshConfigResourceName.Name.String(),
+			Namespace:        mesh_const.MeshConfigResourceName.Namespace.String(),
+			GroupVersionKind: collections.IstioMeshV1Alpha1MeshConfig.Resource().GroupVersionKind(),
+		},
+		Spec: sa.meshCfg,
+	})
+	if err != nil {
+		return fmt.Errorf("something unexpected happened while creating the meshconfig: %s", err)
+	}
+	// Create a store containing meshnetworks. There should be exactly one.
+	_, err = sa.internalStore.Create(config.Config{
+		Meta: config.Meta{
+			Name:             mesh_const.MeshNetworksResourceName.Name.String(),
+			Namespace:        mesh_const.MeshNetworksResourceName.Namespace.String(),
+			GroupVersionKind: collections.IstioMeshV1Alpha1MeshNetworks.Resource().GroupVersionKind(),
+		},
+		Spec: sa.meshNetworks,
+	})
+	if err != nil {
+		return fmt.Errorf("something unexpected happened while creating the meshnetworks: %s", err)
+	}
+	allstores := append(sa.stores, dfCache{ConfigStore: sa.internalStore})
+	if sa.fileSource != nil {
+		allstores = append(allstores, sa.fileSource)
+	}
+
+	for _, c := range sa.clientsToRun {
+		// TODO: this could be parallel
+		c.RunAndWait(cancel)
+	}
+
+	store, err := aggregate.MakeWriteableCache(allstores, nil)
+	if err != nil {
+		return err
+	}
+	go store.Run(cancel)
+	sa.initializedStore = store
+	return nil
+}
+
+type dfCache struct {
+	model.ConfigStore
+}
+
+func (d dfCache) RegisterEventHandler(kind config.GroupVersionKind, handler model.EventHandler) {
+	panic("implement me")
+}
+
+// Run intentionally left empty
+func (d dfCache) Run(_ <-chan struct{}) {
+}
+
+func (d dfCache) SetWatchErrorHandler(f func(r *cache.Reflector, err error)) error {
+	panic("implement me")
+}
+
+func (d dfCache) HasSynced() bool {
+	return true
+}
+
+// SetSuppressions will set the list of suppressions for the analyzer. Any
+// resource that matches the provided suppression will not be included in the
+// final message output.
+func (sa *IstiodAnalyzer) SetSuppressions(suppressions []AnalysisSuppression) {
+	sa.suppressions = suppressions
+}
+
+// AddReaderKubeSource adds a source based on the specified k8s yaml files to the current IstiodAnalyzer
+func (sa *IstiodAnalyzer) AddReaderKubeSource(readers []ReaderSource) error {
+	var src *file.KubeSource
+	if sa.fileSource != nil {
+		src = sa.fileSource
+	} else {
+		src = file.NewKubeSource(sa.kubeResources)
+		sa.fileSource = src
+	}
+	src.SetDefaultNamespace(sa.namespace)
+
+	var errs error
+
+	// If we encounter any errors reading or applying files, track them but attempt to continue
+	for _, r := range readers {
+		by, err := io.ReadAll(r.Reader)
+		if err != nil {
+			errs = multierror.Append(errs, err)
+			continue
+		}
+
+		if err = src.ApplyContent(r.Name, string(by)); err != nil {
+			errs = multierror.Append(errs, err)
+		}
+	}
+	return errs
+}
+
+// AddRunningKubeSource adds a source based on a running k8s cluster to the current IstiodAnalyzer
+// Also tries to get mesh config from the running cluster, if it can
+func (sa *IstiodAnalyzer) AddRunningKubeSource(c kubelib.Client) {
+	// TODO: are either of these string constants intended to vary?
+	store, err := crdclient.NewForSchemas(context.Background(), c, "default",
+		"cluster.local", sa.kubeResources.Intersect(collections.PilotGatewayAPI))
+	// RunAndWait must be called after NewForSchema so that the informers are all created and started.
+	if err != nil {
+		scope.Analysis.Errorf("error adding kube crdclient: %v", err)
+		return
+	}
+	sa.stores = append(sa.stores, store)
+	err = store.SetWatchErrorHandler(func(r *cache.Reflector, err error) {
+		// failed resources will never be synced, which causes the process to hang indefinitely.
+		// better to fail fast, and get a good idea for the failure.
+		scope.Analysis.Errorf("Failed to watch crd resource for analysis: %s", err)
+	})
+	if err != nil {
+		scope.Analysis.Errorf("error setting up error handling for kube crdclient: %v", err)
+		return
+	}
+
+	// TODO: many of the types in PilotGatewayAPI (watched above) are duplicated
+	// I'm not sure why, but we shouldn't watch them twice.
+	duplicates := []collection.Schema{}
+	for k := range analysis.ContainmentMapSchema(collections.PilotGatewayAPI) {
+		duplicates = append(duplicates, k)
+	}
+
+	store, err = arbitraryclient.NewForSchemas(context.Background(), c, "default",
+		"cluster.local", sa.kubeResources.Remove(duplicates...))
+	if err != nil {
+		scope.Analysis.Errorf("error adding kube arbitraryclient: %v", err)
+		return
+	}
+	err = store.SetWatchErrorHandler(func(r *cache.Reflector, err error) {
+		// failed resources will never be synced, which causes the process to hang indefinitely.
+		// better to fail fast, and get a good idea for the failure.
+		scope.Analysis.Errorf("Failed to watch arbitrary resource for analysis: %s", err)
+	})
+	if err != nil {
+		scope.Analysis.Errorf("error setting up error handling for kube arbitraryclient: %v", err)
+		return
+	}
+	sa.clientsToRun = append(sa.clientsToRun, c)
+	sa.stores = append(sa.stores, store)
+
+	// Since we're using a running k8s source, try to get meshconfig and meshnetworks from the configmap.
+	if err := sa.addRunningKubeIstioConfigMapSource(c); err != nil {
+		_, err := c.CoreV1().Namespaces().Get(context.TODO(), sa.istioNamespace.String(), metav1.GetOptions{})
+		if kerrors.IsNotFound(err) {
+			// An AnalysisMessage already show up to warn the absence of istio-system namespace, so making it debug level.
+			scope.Analysis.Debugf("%v namespace not found. Istio may not be installed in the target cluster. "+
+				"Using default mesh configuration values for analysis", sa.istioNamespace.String())
+		} else if err != nil {
+			scope.Analysis.Errorf("error getting mesh config from running kube source: %v", err)
+		}
+	}
+}
+
+// AddSource adds a source based on user supplied configstore to the current IstiodAnalyzer
+// Assumes that the source has same or subset of resource types that this analyzer is configured with.
+// This can be used by external users who import the analyzer as a module within their own controllers.
+func (sa *IstiodAnalyzer) AddSource(src model.ConfigStoreCache) {
+	sa.stores = append(sa.stores, src)
+}
+
+// AddFileKubeMeshConfig gets mesh config from the specified yaml file
+func (sa *IstiodAnalyzer) AddFileKubeMeshConfig(file string) error {
+	by, err := os.ReadFile(file)
+	if err != nil {
+		return err
+	}
+
+	cfg, err := mesh.ApplyMeshConfigDefaults(string(by))
+	if err != nil {
+		return err
+	}
+
+	sa.meshCfg = cfg
+	return nil
+}
+
+// AddFileKubeMeshNetworks gets a file meshnetworks and add it to the analyzer.
+func (sa *IstiodAnalyzer) AddFileKubeMeshNetworks(file string) error {
+	mn, err := mesh.ReadMeshNetworks(file)
+	if err != nil {
+		return err
+	}
+
+	sa.meshNetworks = mn
+	return nil
+}
+
+// AddDefaultResources adds some basic dummy Istio resources, based on mesh configuration.
+// This is useful for files-only analysis cases where we don't expect the user to be including istio system resources
+// and don't want to generate false positives because they aren't there.
+// Respect mesh config when deciding which default resources should be generated
+func (sa *IstiodAnalyzer) AddDefaultResources() error {
+	var readers []ReaderSource
+
+	if sa.meshCfg.GetIngressControllerMode() != v1alpha1.MeshConfig_OFF {
+		ingressResources, err := getDefaultIstioIngressGateway(sa.istioNamespace.String(), sa.meshCfg.GetIngressService())
+		if err != nil {
+			return err
+		}
+		readers = append(readers, ReaderSource{Reader: strings.NewReader(ingressResources), Name: "internal-ingress"})
+	}
+
+	if len(readers) == 0 {
+		return nil
+	}
+
+	return sa.AddReaderKubeSource(readers)
+}
+
+func (sa *IstiodAnalyzer) addRunningKubeIstioConfigMapSource(client kubelib.Client) error {
+	meshConfigMap, err := client.CoreV1().ConfigMaps(string(sa.istioNamespace)).Get(context.TODO(), meshConfigMapName, metav1.GetOptions{})
+	if err != nil {
+		return fmt.Errorf("could not read configmap %q from namespace %q: %v", meshConfigMapName, sa.istioNamespace, err)
+	}
+
+	configYaml, ok := meshConfigMap.Data[meshConfigMapKey]
+	if !ok {
+		return fmt.Errorf("missing config map key %q", meshConfigMapKey)
+	}
+
+	cfg, err := mesh.ApplyMeshConfigDefaults(configYaml)
+	if err != nil {
+		return fmt.Errorf("error parsing mesh config: %v", err)
+	}
+
+	sa.meshCfg = cfg
+
+	meshNetworksYaml, ok := meshConfigMap.Data[meshNetworksMapKey]
+	if !ok {
+		return fmt.Errorf("missing config map key %q", meshNetworksMapKey)
+	}
+
+	mn, err := mesh.ParseMeshNetworks(meshNetworksYaml)
+	if err != nil {
+		return fmt.Errorf("error parsing mesh networks: %v", err)
+	}
+
+	sa.meshNetworks = mn
+	return nil
+}
+
+// CollectionReporterFn is a hook function called whenever a collection is accessed through the AnalyzingDistributor's context
+type CollectionReporterFn func(collection.Name)
+
+// copied from processing/snapshotter/analyzingdistributor.go
+func filterMessages(messages diag.Messages, namespaces map[resource.Namespace]struct{}, suppressions []AnalysisSuppression) diag.Messages {
+	nsNames := make(map[string]struct{})
+	for k := range namespaces {
+		nsNames[k.String()] = struct{}{}
+	}
+
+	var msgs diag.Messages
+FilterMessages:
+	for _, m := range messages {
+		// Only keep messages for resources in namespaces we want to analyze if the
+		// message doesn't have an origin (meaning we can't determine the
+		// namespace). Also kept are cluster-level resources where the namespace is
+		// the empty string. If no such limit is specified, keep them all.
+		if len(namespaces) > 0 && m.Resource != nil && m.Resource.Origin.Namespace() != "" {
+			if _, ok := nsNames[m.Resource.Origin.Namespace().String()]; !ok {
+				continue FilterMessages
+			}
+		}
+
+		// Filter out any messages on resources with suppression annotations.
+		if m.Resource != nil && m.Resource.Metadata.Annotations[annotation.GalleyAnalyzeSuppress.Name] != "" {
+			for _, code := range strings.Split(m.Resource.Metadata.Annotations[annotation.GalleyAnalyzeSuppress.Name], ",") {
+				if code == "*" || m.Type.Code() == code {
+					scope.Analysis.Debugf("Suppressing code %s on resource %s due to resource annotation", m.Type.Code(), m.Resource.Origin.FriendlyName())
+					continue FilterMessages
+				}
+			}
+		}
+
+		// Filter out any messages that match our suppressions.
+		for _, s := range suppressions {
+			if m.Resource == nil || s.Code != m.Type.Code() {
+				continue
+			}
+
+			if !glob.Glob(s.ResourceName, m.Resource.Origin.FriendlyName()) {
+				continue
+			}
+			scope.Analysis.Debugf("Suppressing code %s on resource %s due to suppressions list", m.Type.Code(), m.Resource.Origin.FriendlyName())
+			continue FilterMessages
+		}
+
+		msgs = append(msgs, m)
+	}
+	return msgs
+}
+
+// AnalysisSuppression describes a resource and analysis code to be suppressed
+// (e.g. ignored) during analysis. Used when a particular message code is to be
+// ignored for a specific resource.
+type AnalysisSuppression struct {
+	// Code is the analysis code to suppress (e.g. "IST0104").
+	Code string
+
+	// ResourceName is the name of the resource to suppress the message for. For
+	// K8s resources it has the same form as used by istioctl (e.g.
+	// "DestinationRule default.istio-system"). Note that globbing wildcards are
+	// supported (e.g. "DestinationRule *.istio-system").
+	ResourceName string
+}
+
+// ReaderSource is a tuple of a io.Reader and filepath.
+type ReaderSource struct {
+	// Name is the name of the source (commonly the path to a file, but can be "-" for sources read from stdin or "" if completely synthetic).
+	Name string
+	// Reader is the reader instance to use.
+	Reader io.Reader
+}
diff --git a/pkg/config/analysis/local/local.go b/pkg/config/analysis/local/local.go
new file mode 100644
index 0000000000..a9c768976b
--- /dev/null
+++ b/pkg/config/analysis/local/local.go
@@ -0,0 +1,34 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package local
+
+import (
+	"istio.io/istio/pkg/config/analysis/diag"
+)
+
+const (
+	meshConfigMapKey   = "mesh"
+	meshConfigMapName  = "istio"
+	meshNetworksMapKey = "meshNetworks"
+)
+
+// AnalysisResult represents the returnable results of an analysis execution
+type AnalysisResult struct {
+	Messages          diag.Messages
+	SkippedAnalyzers  []string
+	ExecutedAnalyzers []string
+}
diff --git a/galley/pkg/config/analysis/metadata.go b/pkg/config/analysis/metadata.go
similarity index 100%
rename from galley/pkg/config/analysis/metadata.go
rename to pkg/config/analysis/metadata.go
diff --git a/galley/pkg/config/analysis/msg/generate.main.go b/pkg/config/analysis/msg/generate.main.go
diff --git a/galley/pkg/config/analysis/msg/generate.main.go b/pkg/config/analysis/msg/generate.main.go
similarity index 98%
rename from galley/pkg/config/analysis/msg/generate.main.go
rename to pkg/config/analysis/msg/generate.main.go
index 8a58e90a2a..c189c560b3 100644
--- a/galley/pkg/config/analysis/msg/generate.main.go
+++ b/pkg/config/analysis/msg/generate.main.go
@@ -123,7 +123,7 @@ func validate(ms *messages) error {
 package msg
 
 import (
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 )
 
diff --git a/galley/pkg/config/analysis/msg/messages.gen.go b/pkg/config/analysis/msg/messages.gen.go
similarity index 99%
rename from galley/pkg/config/analysis/msg/messages.gen.go
rename to pkg/config/analysis/msg/messages.gen.go
index 7ed58c9de9..f1f8105d1d 100755
--- a/galley/pkg/config/analysis/msg/messages.gen.go
+++ b/pkg/config/analysis/msg/messages.gen.go
@@ -4,7 +4,7 @@
 package msg
 
 import (
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 )
 
diff --git a/galley/pkg/config/analysis/msg/messages.go b/pkg/config/analysis/msg/messages.go
similarity index 74%
rename from galley/pkg/config/analysis/msg/messages.go
rename to pkg/config/analysis/msg/messages.go
index 1b774272af..b5460a4b21 100644
--- a/galley/pkg/config/analysis/msg/messages.go
+++ b/pkg/config/analysis/msg/messages.go
@@ -15,6 +15,6 @@
 package msg
 
 // Create static initializers file
-//go:generate go run "$REPO_ROOT/galley/pkg/config/analysis/msg/generate.main.go" messages.yaml messages.gen.go
+//go:generate go run "$REPO_ROOT/pkg/config/analysis/msg/generate.main.go" messages.yaml messages.gen.go
 
-//go:generate goimports -w -local istio.io "$REPO_ROOT/galley/pkg/config/analysis/msg/messages.gen.go"
+//go:generate goimports -w -local istio.io "$REPO_ROOT/pkg/config/analysis/msg/messages.gen.go"
diff --git a/galley/pkg/config/analysis/msg/messages.yaml b/pkg/config/analysis/msg/messages.yaml
similarity index 100%
rename from galley/pkg/config/analysis/msg/messages.yaml
rename to pkg/config/analysis/msg/messages.yaml
diff --git a/pkg/config/analysis/scope/scope.go b/pkg/config/analysis/scope/scope.go
diff --git a/pkg/config/analysis/scope/scope.go b/pkg/config/analysis/scope/scope.go
new file mode 100644
index 0000000000..4d135b3a45
--- /dev/null
+++ b/pkg/config/analysis/scope/scope.go
@@ -0,0 +1,26 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package scope
+
+import "istio.io/pkg/log"
+
+var (
+	// Analysis is a logging scope used by configuration analysis component.
+	Analysis = log.RegisterScope("analysis", "Scope for configuration analysis runtime", 0)
+	// Processing is a logging scope used by configuration processing pipeline.
+	Processing = log.RegisterScope("processing", "Scope for configuration processing runtime", 0)
+)
diff --git a/galley/pkg/config/analysis/testing/fixtures/context.go b/pkg/config/analysis/testing/fixtures/context.go
similarity index 94%
rename from galley/pkg/config/analysis/testing/fixtures/context.go
rename to pkg/config/analysis/testing/fixtures/context.go
index ddc4cd6a68..fce803a323 100644
--- a/galley/pkg/config/analysis/testing/fixtures/context.go
+++ b/pkg/config/analysis/testing/fixtures/context.go
@@ -15,8 +15,8 @@
 package fixtures
 
 import (
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 )
diff --git a/pkg/config/conversion.go b/pkg/config/conversion.go
new file mode 100644
index 0000000000..d1d25f9d0c
--- /dev/null
+++ b/pkg/config/conversion.go
@@ -0,0 +1,50 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package config
+
+import (
+	gogotypes "github.com/gogo/protobuf/types"
+
+	mcp "istio.io/api/mcp/v1alpha1"
+)
+
+// Convert from model.Config, which has no associated proto, to MCP Resource proto.
+// TODO: define a proto matching Config - to avoid useless superficial conversions.
+func PilotConfigToResource(c *Config) (*mcp.Resource, error) {
+	r := &mcp.Resource{}
+
+	// MCP, K8S and Istio configs use gogo configs
+	// On the wire it's the same as golang proto.
+	a, err := ToProtoGogo(c.Spec)
+	if err != nil {
+		return nil, err
+	}
+	r.Body = a
+	ts, err := gogotypes.TimestampProto(c.CreationTimestamp)
+	if err != nil {
+		return nil, err
+	}
+	r.Metadata = &mcp.Metadata{
+		Name:        c.Namespace + "/" + c.Name,
+		CreateTime:  ts,
+		Version:     c.ResourceVersion,
+		Labels:      c.Labels,
+		Annotations: c.Annotations,
+	}
+
+	return r, nil
+}
diff --git a/pkg/config/event/buffer.go b/pkg/config/event/buffer.go
index 02afd7b309..01dbe1e295 100644
--- a/pkg/config/event/buffer.go
+++ b/pkg/config/event/buffer.go
@@ -17,7 +17,7 @@
 import (
 	"sync"
 
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis/scope"
 )
 
 // Buffer is a growing event buffer.
diff --git a/pkg/config/event/buffer_test.go b/pkg/config/event/buffer_test.go
index d8ca5d38a1..11d8f241f3 100644
--- a/pkg/config/event/buffer_test.go
+++ b/pkg/config/event/buffer_test.go
@@ -21,9 +21,9 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	"istio.io/istio/pkg/config/legacy/testing/data"
+	"istio.io/istio/pkg/config/legacy/testing/fixtures"
 )
 
 func TestBuffer_Basics(t *testing.T) {
diff --git a/pkg/config/event/event_test.go b/pkg/config/event/event_test.go
index 704fbb1e73..348ebe716e 100644
--- a/pkg/config/event/event_test.go
+++ b/pkg/config/event/event_test.go
@@ -21,8 +21,8 @@
 	"github.com/gogo/protobuf/types"
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
 	"istio.io/istio/pkg/config/event"
+	"istio.io/istio/pkg/config/legacy/testing/data"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collection"
 )
diff --git a/pkg/config/event/handlers_test.go b/pkg/config/event/handlers_test.go
index f8835531af..b96cffea2b 100644
--- a/pkg/config/event/handlers_test.go
+++ b/pkg/config/event/handlers_test.go
@@ -19,9 +19,9 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 )
 
 func TestHandlers_Handle_Zero(t *testing.T) {
diff --git a/pkg/config/event/router.go b/pkg/config/event/router.go
index 0322f1b2f4..1535fd3c1d 100644
--- a/pkg/config/event/router.go
+++ b/pkg/config/event/router.go
@@ -17,7 +17,7 @@
 import (
 	"fmt"
 
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis/scope"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
diff --git a/pkg/config/event/router_test.go b/pkg/config/event/router_test.go
index c2e563d894..91876a62bf 100644
--- a/pkg/config/event/router_test.go
+++ b/pkg/config/event/router_test.go
@@ -19,10 +19,10 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	basicmeta "istio.io/istio/pkg/config/legacy/testing/basicmeta"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 )
 
 func TestRouter_Empty(t *testing.T) {
diff --git a/pkg/config/event/source_test.go b/pkg/config/event/source_test.go
index c44759a2c7..5483eb4e90 100644
--- a/pkg/config/event/source_test.go
+++ b/pkg/config/event/source_test.go
@@ -19,8 +19,8 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 )
 
 func TestMergeSources_Basic(t *testing.T) {
diff --git a/pkg/config/event/transformer.go b/pkg/config/event/transformer.go
index 15625332ae..7fe41e7d4a 100644
--- a/pkg/config/event/transformer.go
+++ b/pkg/config/event/transformer.go
@@ -17,7 +17,7 @@
 import (
 	"sync/atomic"
 
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis/scope"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
diff --git a/pkg/config/event/transformer_test.go b/pkg/config/event/transformer_test.go
index 47993d2894..474af80e01 100644
--- a/pkg/config/event/transformer_test.go
+++ b/pkg/config/event/transformer_test.go
@@ -19,9 +19,9 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	"istio.io/istio/pkg/config/legacy/testing/data"
+	"istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
diff --git a/galley/pkg/config/mesh/const.go b/pkg/config/legacy/mesh/const.go
similarity index 100%
rename from galley/pkg/config/mesh/const.go
rename to pkg/config/legacy/mesh/const.go
diff --git a/pkg/config/legacy/processing/processor.go b/pkg/config/legacy/processing/processor.go
diff --git a/pkg/config/legacy/processing/processor.go b/pkg/config/legacy/processing/processor.go
new file mode 100644
index 0000000000..b6d9e80d3d
--- /dev/null
+++ b/pkg/config/legacy/processing/processor.go
@@ -0,0 +1,25 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package util
+
+import "istio.io/api/mesh/v1alpha1"
+
+// ProcessorOptions are options that are passed to event.Processors during startup.
+type ProcessorOptions struct {
+	MeshConfig   *v1alpha1.MeshConfig
+	DomainSuffix string
+}
diff --git a/galley/pkg/config/processing/transformer/provider.go b/pkg/config/legacy/processing/transformer/provider.go
similarity index 89%
rename from galley/pkg/config/processing/transformer/provider.go
rename to pkg/config/legacy/processing/transformer/provider.go
index cf24d15226..c75dd14811 100644
--- a/galley/pkg/config/processing/transformer/provider.go
+++ b/pkg/config/legacy/processing/transformer/provider.go
@@ -18,8 +18,8 @@
 package transformer
 
 import (
-	"istio.io/istio/galley/pkg/config/processing"
 	"istio.io/istio/pkg/config/event"
+	util "istio.io/istio/pkg/config/legacy/processing"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
@@ -30,11 +30,11 @@
 type Provider struct {
 	inputs   collection.Schemas
 	outputs  collection.Schemas
-	createFn func(processing.ProcessorOptions) event.Transformer
+	createFn func(util.ProcessorOptions) event.Transformer
 }
 
 // NewProvider creates a new transformer Provider
-func NewProvider(inputs, outputs collection.Schemas, createFn func(processing.ProcessorOptions) event.Transformer) Provider {
+func NewProvider(inputs, outputs collection.Schemas, createFn func(util.ProcessorOptions) event.Transformer) Provider {
 	return Provider{
 		inputs:   inputs,
 		outputs:  outputs,
@@ -53,7 +53,7 @@ func (p *Provider) Outputs() collection.Schemas {
 }
 
 // Create returns the actual Transformer for this provider
-func (p *Provider) Create(o processing.ProcessorOptions) event.Transformer {
+func (p *Provider) Create(o util.ProcessorOptions) event.Transformer {
 	return p.createFn(o)
 }
 
@@ -61,7 +61,7 @@ func (p *Provider) Create(o processing.ProcessorOptions) event.Transformer {
 type Providers []Provider
 
 // Create creates a list of providers from a list of Transformers
-func (t Providers) Create(o processing.ProcessorOptions) []event.Transformer {
+func (t Providers) Create(o util.ProcessorOptions) []event.Transformer {
 	xforms := make([]event.Transformer, 0)
 	for _, i := range t {
 		xforms = append(xforms, i.Create(o))
@@ -90,6 +90,9 @@ func (t Providers) RequiredInputsFor(outputs collection.Names) map[collection.Na
 	// 2. For each input collection, get its inputs using the above mapping and include them in the output set
 	inputs := make(map[collection.Name]struct{})
 	for _, c := range outputs {
+		if len(outToIn[c]) == 0 {
+			inputs[c] = struct{}{}
+		}
 		for in := range outToIn[c] {
 			inputs[in] = struct{}{}
 		}
@@ -103,7 +106,7 @@ func NewSimpleTransformerProvider(input, output collection.Schema, handleFn func
 	inputs := collection.NewSchemasBuilder().MustAdd(input).Build()
 	outputs := collection.NewSchemasBuilder().MustAdd(output).Build()
 
-	createFn := func(processing.ProcessorOptions) event.Transformer {
+	createFn := func(util.ProcessorOptions) event.Transformer {
 		return event.NewFnTransform(inputs, outputs, nil, nil, handleFn)
 	}
 	return NewProvider(inputs, outputs, createFn)
diff --git a/galley/pkg/config/processing/transformer/provider_test.go b/pkg/config/legacy/processing/transformer/provider_test.go
similarity index 87%
rename from galley/pkg/config/processing/transformer/provider_test.go
rename to pkg/config/legacy/processing/transformer/provider_test.go
index 4eedeecaa0..fab14a6c64 100644
--- a/galley/pkg/config/processing/transformer/provider_test.go
+++ b/pkg/config/legacy/processing/transformer/provider_test.go
@@ -19,10 +19,10 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	util "istio.io/istio/pkg/config/legacy/processing"
+	basicmeta "istio.io/istio/pkg/config/legacy/testing/basicmeta"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
@@ -32,7 +32,7 @@ func TestSimpleTransformerProvider(t *testing.T) {
 	input := basicmeta.K8SCollection1
 	output := basicmeta.Collection2
 	handleFn := func(e event.Event, h event.Handler) {}
-	opts := processing.ProcessorOptions{}
+	opts := util.ProcessorOptions{}
 
 	providers := Providers{
 		NewSimpleTransformerProvider(input, output, handleFn),
diff --git a/galley/pkg/config/processor/transforms/direct/create.go b/pkg/config/legacy/processor/transforms/direct/create.go
similarity index 95%
rename from galley/pkg/config/processor/transforms/direct/create.go
rename to pkg/config/legacy/processor/transforms/direct/create.go
index 13ed8155ee..1326843148 100644
--- a/galley/pkg/config/processor/transforms/direct/create.go
+++ b/pkg/config/legacy/processor/transforms/direct/create.go
@@ -15,8 +15,8 @@
 package direct
 
 import (
-	"istio.io/istio/galley/pkg/config/processing/transformer"
 	"istio.io/istio/pkg/config/event"
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
 	"istio.io/istio/pkg/config/schema"
 )
 
diff --git a/galley/pkg/config/processor/transforms/direct/create_test.go b/pkg/config/legacy/processor/transforms/direct/create_test.go
similarity index 94%
rename from galley/pkg/config/processor/transforms/direct/create_test.go
rename to pkg/config/legacy/processor/transforms/direct/create_test.go
index 1adda8ad0f..e2c89efa85 100644
--- a/galley/pkg/config/processor/transforms/direct/create_test.go
+++ b/pkg/config/legacy/processor/transforms/direct/create_test.go
@@ -19,11 +19,11 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/processing"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	util "istio.io/istio/pkg/config/legacy/processing"
+	"istio.io/istio/pkg/config/legacy/testing/basicmeta"
+	"istio.io/istio/pkg/config/legacy/testing/data"
+	"istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
@@ -125,7 +125,7 @@ func TestDirect_InvalidEventKind(t *testing.T) {
 func TestDirect_NoListeners(t *testing.T) {
 	g := NewWithT(t)
 
-	xforms := GetProviders(basicmeta.MustGet()).Create(processing.ProcessorOptions{})
+	xforms := GetProviders(basicmeta.MustGet()).Create(util.ProcessorOptions{})
 	g.Expect(xforms).To(HaveLen(1))
 
 	src := &fixtures.Source{}
@@ -232,7 +232,7 @@ func TestDirect_InvalidEvent(t *testing.T) {
 }
 
 func setup(g *GomegaWithT) (event.Transformer, *fixtures.Source, *fixtures.Accumulator) {
-	xforms := GetProviders(basicmeta.MustGet()).Create(processing.ProcessorOptions{})
+	xforms := GetProviders(basicmeta.MustGet()).Create(util.ProcessorOptions{})
 	g.Expect(xforms).To(HaveLen(1))
 
 	src := &fixtures.Source{}
diff --git a/galley/pkg/config/processor/transforms/transforms.go b/pkg/config/legacy/processor/transforms/transforms.go
similarity index 89%
rename from galley/pkg/config/processor/transforms/transforms.go
rename to pkg/config/legacy/processor/transforms/transforms.go
index d17614455b..426c7d8e00 100644
--- a/galley/pkg/config/processor/transforms/transforms.go
+++ b/pkg/config/legacy/processor/transforms/transforms.go
@@ -17,8 +17,8 @@
 package transforms
 
 import (
-	"istio.io/istio/galley/pkg/config/processing/transformer"
-	"istio.io/istio/galley/pkg/config/processor/transforms/direct"
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
+	"istio.io/istio/pkg/config/legacy/processor/transforms/direct"
 	"istio.io/istio/pkg/config/schema"
 )
 
diff --git a/galley/pkg/config/source/kube/rt/origin.go b/pkg/config/legacy/source/kube/origin.go
similarity index 78%
rename from galley/pkg/config/source/kube/rt/origin.go
rename to pkg/config/legacy/source/kube/origin.go
index 98785dbc37..ffd6d7c70b 100644
--- a/galley/pkg/config/source/kube/rt/origin.go
+++ b/pkg/config/legacy/source/kube/origin.go
@@ -1,18 +1,20 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package rt
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package kube
 
 import (
 	"fmt"
diff --git a/galley/pkg/config/testing/basicmeta/basicmeta.gen.go b/pkg/config/legacy/testing/basicmeta/basicmeta.gen.go
similarity index 100%
rename from galley/pkg/config/testing/basicmeta/basicmeta.gen.go
rename to pkg/config/legacy/testing/basicmeta/basicmeta.gen.go
diff --git a/galley/pkg/config/testing/basicmeta/basicmeta.yaml b/pkg/config/legacy/testing/basicmeta/basicmeta.yaml
diff --git a/galley/pkg/config/testing/basicmeta/basicmeta.yaml b/pkg/config/legacy/testing/basicmeta/basicmeta.yaml
similarity index 100%
rename from galley/pkg/config/testing/basicmeta/basicmeta.yaml
rename to pkg/config/legacy/testing/basicmeta/basicmeta.yaml
diff --git a/galley/pkg/config/testing/basicmeta/basicmeta2.yaml b/pkg/config/legacy/testing/basicmeta/basicmeta2.yaml
diff --git a/galley/pkg/config/testing/basicmeta/basicmeta2.yaml b/pkg/config/legacy/testing/basicmeta/basicmeta2.yaml
similarity index 100%
rename from galley/pkg/config/testing/basicmeta/basicmeta2.yaml
rename to pkg/config/legacy/testing/basicmeta/basicmeta2.yaml
diff --git a/galley/pkg/config/testing/basicmeta/collections.gen.go b/pkg/config/legacy/testing/basicmeta/collections.gen.go
diff --git a/galley/pkg/config/testing/basicmeta/collections.gen.go b/pkg/config/legacy/testing/basicmeta/collections.gen.go
similarity index 100%
rename from galley/pkg/config/testing/basicmeta/collections.gen.go
rename to pkg/config/legacy/testing/basicmeta/collections.gen.go
diff --git a/galley/pkg/config/testing/basicmeta/generate.go b/pkg/config/legacy/testing/basicmeta/generate.go
diff --git a/galley/pkg/config/testing/basicmeta/generate.go b/pkg/config/legacy/testing/basicmeta/generate.go
similarity index 89%
rename from galley/pkg/config/testing/basicmeta/generate.go
rename to pkg/config/legacy/testing/basicmeta/generate.go
index 2075254b01..e3d463c6cc 100644
--- a/galley/pkg/config/testing/basicmeta/generate.go
+++ b/pkg/config/legacy/testing/basicmeta/generate.go
@@ -20,4 +20,4 @@
 // Create collection constants
 //go:generate go run $REPO_ROOT/pkg/config/schema/codegen/tools/collections.main.go basicmeta basicmeta.yaml collections.gen.go
 
-//go:generate goimports -w -local istio.io "$REPO_ROOT/galley/pkg/config/testing/basicmeta/collections.gen.go"
+//go:generate goimports -w -local istio.io "$REPO_ROOT/pkg/config/legacy/testing/basicmeta/collections.gen.go"
diff --git a/galley/pkg/config/testing/basicmeta/get.go b/pkg/config/legacy/testing/basicmeta/get.go
similarity index 100%
rename from galley/pkg/config/testing/basicmeta/get.go
rename to pkg/config/legacy/testing/basicmeta/get.go
diff --git a/galley/pkg/config/testing/data/builtin.gen.go b/pkg/config/legacy/testing/data/builtin.gen.go
diff --git a/galley/pkg/config/testing/data/builtin.gen.go b/pkg/config/legacy/testing/data/builtin.gen.go
similarity index 100%
rename from galley/pkg/config/testing/data/builtin.gen.go
rename to pkg/config/legacy/testing/data/builtin.gen.go
diff --git a/galley/pkg/config/testing/data/builtin.go b/pkg/config/legacy/testing/data/builtin.go
diff --git a/galley/pkg/config/testing/data/builtin.go b/pkg/config/legacy/testing/data/builtin.go
similarity index 100%
rename from galley/pkg/config/testing/data/builtin.go
rename to pkg/config/legacy/testing/data/builtin.go
diff --git a/galley/pkg/config/testing/data/builtin/deployment.yaml b/pkg/config/legacy/testing/data/builtin/deployment.yaml
diff --git a/galley/pkg/config/testing/data/builtin/deployment.yaml b/pkg/config/legacy/testing/data/builtin/deployment.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/deployment.yaml
rename to pkg/config/legacy/testing/data/builtin/deployment.yaml
diff --git a/galley/pkg/config/testing/data/builtin/endpoints.yaml b/pkg/config/legacy/testing/data/builtin/endpoints.yaml
diff --git a/galley/pkg/config/testing/data/builtin/endpoints.yaml b/pkg/config/legacy/testing/data/builtin/endpoints.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/endpoints.yaml
rename to pkg/config/legacy/testing/data/builtin/endpoints.yaml
diff --git a/galley/pkg/config/testing/data/builtin/ingress.yaml b/pkg/config/legacy/testing/data/builtin/ingress.yaml
diff --git a/galley/pkg/config/testing/data/builtin/ingress.yaml b/pkg/config/legacy/testing/data/builtin/ingress.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/ingress.yaml
rename to pkg/config/legacy/testing/data/builtin/ingress.yaml
diff --git a/galley/pkg/config/testing/data/builtin/namespace.yaml b/pkg/config/legacy/testing/data/builtin/namespace.yaml
diff --git a/galley/pkg/config/testing/data/builtin/namespace.yaml b/pkg/config/legacy/testing/data/builtin/namespace.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/namespace.yaml
rename to pkg/config/legacy/testing/data/builtin/namespace.yaml
diff --git a/galley/pkg/config/testing/data/builtin/node.yaml b/pkg/config/legacy/testing/data/builtin/node.yaml
diff --git a/galley/pkg/config/testing/data/builtin/node.yaml b/pkg/config/legacy/testing/data/builtin/node.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/node.yaml
rename to pkg/config/legacy/testing/data/builtin/node.yaml
diff --git a/galley/pkg/config/testing/data/builtin/pod.yaml b/pkg/config/legacy/testing/data/builtin/pod.yaml
diff --git a/galley/pkg/config/testing/data/builtin/pod.yaml b/pkg/config/legacy/testing/data/builtin/pod.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/pod.yaml
rename to pkg/config/legacy/testing/data/builtin/pod.yaml
diff --git a/galley/pkg/config/testing/data/builtin/service.yaml b/pkg/config/legacy/testing/data/builtin/service.yaml
diff --git a/galley/pkg/config/testing/data/builtin/service.yaml b/pkg/config/legacy/testing/data/builtin/service.yaml
similarity index 100%
rename from galley/pkg/config/testing/data/builtin/service.yaml
rename to pkg/config/legacy/testing/data/builtin/service.yaml
diff --git a/galley/pkg/config/testing/data/collections.go b/pkg/config/legacy/testing/data/collections.go
diff --git a/galley/pkg/config/testing/data/collections.go b/pkg/config/legacy/testing/data/collections.go
similarity index 97%
rename from galley/pkg/config/testing/data/collections.go
rename to pkg/config/legacy/testing/data/collections.go
index 6c5e5dcf8b..57a69832e6 100644
--- a/galley/pkg/config/testing/data/collections.go
+++ b/pkg/config/legacy/testing/data/collections.go
@@ -15,7 +15,7 @@
 package data
 
 import (
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
+	"istio.io/istio/pkg/config/legacy/testing/basicmeta"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/resource"
 )
diff --git a/galley/pkg/config/testing/data/events.go b/pkg/config/legacy/testing/data/events.go
similarity index 97%
rename from galley/pkg/config/testing/data/events.go
rename to pkg/config/legacy/testing/data/events.go
index c5ef24ac6e..03f8e19fa7 100644
--- a/galley/pkg/config/testing/data/events.go
+++ b/pkg/config/legacy/testing/data/events.go
@@ -15,8 +15,8 @@
 package data
 
 import (
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
 	"istio.io/istio/pkg/config/event"
+	"istio.io/istio/pkg/config/legacy/testing/basicmeta"
 )
 
 var (
diff --git a/galley/pkg/config/testing/data/resources.go b/pkg/config/legacy/testing/data/resources.go
similarity index 98%
rename from galley/pkg/config/testing/data/resources.go
rename to pkg/config/legacy/testing/data/resources.go
index fa229bf92a..c3ed6034cb 100644
--- a/galley/pkg/config/testing/data/resources.go
+++ b/pkg/config/legacy/testing/data/resources.go
@@ -20,7 +20,7 @@
 	"github.com/gogo/protobuf/jsonpb"
 	"github.com/gogo/protobuf/types"
 
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
+	basicmeta "istio.io/istio/pkg/config/legacy/testing/basicmeta"
 	"istio.io/istio/pkg/config/resource"
 )
 
diff --git a/galley/pkg/config/testing/data/yaml.go b/pkg/config/legacy/testing/data/yaml.go
similarity index 93%
rename from galley/pkg/config/testing/data/yaml.go
rename to pkg/config/legacy/testing/data/yaml.go
index b659819dbb..24faa12146 100644
--- a/galley/pkg/config/testing/data/yaml.go
+++ b/pkg/config/legacy/testing/data/yaml.go
@@ -26,17 +26,6 @@
   n1_i1: v1
 `
 
-	// YamlN1I1V2 is a testing resource in Yaml form
-	YamlN1I1V2 = `
-apiVersion: testdata.istio.io/v1alpha1
-kind: Kind1
-metadata:
-  namespace: n1
-  name: i1
-spec:
-  n1_i1: v2
-`
-
 	// YamlN2I2V1 is a testing resource in Yaml form
 	YamlN2I2V1 = `
 apiVersion: testdata.istio.io/v1alpha1
diff --git a/galley/pkg/config/testing/fixtures/accumulator.go b/pkg/config/legacy/testing/fixtures/accumulator.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/accumulator.go
rename to pkg/config/legacy/testing/fixtures/accumulator.go
diff --git a/galley/pkg/config/testing/fixtures/accumulator_test.go b/pkg/config/legacy/testing/fixtures/accumulator_test.go
diff --git a/galley/pkg/config/testing/fixtures/accumulator_test.go b/pkg/config/legacy/testing/fixtures/accumulator_test.go
similarity index 96%
rename from galley/pkg/config/testing/fixtures/accumulator_test.go
rename to pkg/config/legacy/testing/fixtures/accumulator_test.go
index 6721dcc1b7..4ba8c40931 100644
--- a/galley/pkg/config/testing/fixtures/accumulator_test.go
+++ b/pkg/config/legacy/testing/fixtures/accumulator_test.go
@@ -19,8 +19,8 @@
 
 	"github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
 	"istio.io/istio/pkg/config/event"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
 )
 
 func TestAccumulator(t *testing.T) {
diff --git a/galley/pkg/config/testing/fixtures/expect.go b/pkg/config/legacy/testing/fixtures/expect.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/expect.go
rename to pkg/config/legacy/testing/fixtures/expect.go
diff --git a/galley/pkg/config/testing/fixtures/expect_test.go b/pkg/config/legacy/testing/fixtures/expect_test.go
diff --git a/galley/pkg/config/testing/fixtures/expect_test.go b/pkg/config/legacy/testing/fixtures/expect_test.go
similarity index 90%
rename from galley/pkg/config/testing/fixtures/expect_test.go
rename to pkg/config/legacy/testing/fixtures/expect_test.go
index 2d9c1de7a3..917032ac11 100644
--- a/galley/pkg/config/testing/fixtures/expect_test.go
+++ b/pkg/config/legacy/testing/fixtures/expect_test.go
@@ -17,9 +17,9 @@
 import (
 	"testing"
 
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
+	"istio.io/istio/pkg/config/legacy/testing/basicmeta"
+	"istio.io/istio/pkg/config/legacy/testing/data"
+	"istio.io/istio/pkg/config/legacy/testing/fixtures"
 )
 
 func TestExpect(t *testing.T) {
diff --git a/galley/pkg/config/testing/fixtures/filters.go b/pkg/config/legacy/testing/fixtures/filters.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/filters.go
rename to pkg/config/legacy/testing/fixtures/filters.go
diff --git a/galley/pkg/config/testing/fixtures/filters_test.go b/pkg/config/legacy/testing/fixtures/filters_test.go
diff --git a/galley/pkg/config/testing/fixtures/filters_test.go b/pkg/config/legacy/testing/fixtures/filters_test.go
similarity index 94%
rename from galley/pkg/config/testing/fixtures/filters_test.go
rename to pkg/config/legacy/testing/fixtures/filters_test.go
index 45c23005ae..0cdc5e4b83 100644
--- a/galley/pkg/config/testing/fixtures/filters_test.go
+++ b/pkg/config/legacy/testing/fixtures/filters_test.go
@@ -19,9 +19,9 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/pkg/config/event"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/resource"
 )
 
diff --git a/galley/pkg/config/testing/fixtures/listener.go b/pkg/config/legacy/testing/fixtures/listener.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/listener.go
rename to pkg/config/legacy/testing/fixtures/listener.go
diff --git a/galley/pkg/config/testing/fixtures/listener_test.go b/pkg/config/legacy/testing/fixtures/listener_test.go
diff --git a/galley/pkg/config/testing/fixtures/listener_test.go b/pkg/config/legacy/testing/fixtures/listener_test.go
similarity index 94%
rename from galley/pkg/config/testing/fixtures/listener_test.go
rename to pkg/config/legacy/testing/fixtures/listener_test.go
index 92e722416f..9a328cadeb 100644
--- a/galley/pkg/config/testing/fixtures/listener_test.go
+++ b/pkg/config/legacy/testing/fixtures/listener_test.go
@@ -19,8 +19,8 @@
 
 	"github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/data"
 	"istio.io/istio/pkg/config/event"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
 )
 
 func TestDispatcher(t *testing.T) {
diff --git a/galley/pkg/config/testing/fixtures/source.go b/pkg/config/legacy/testing/fixtures/source.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/source.go
rename to pkg/config/legacy/testing/fixtures/source.go
diff --git a/galley/pkg/config/testing/fixtures/source_test.go b/pkg/config/legacy/testing/fixtures/source_test.go
diff --git a/galley/pkg/config/testing/fixtures/source_test.go b/pkg/config/legacy/testing/fixtures/source_test.go
similarity index 95%
rename from galley/pkg/config/testing/fixtures/source_test.go
rename to pkg/config/legacy/testing/fixtures/source_test.go
index 803e4564e8..6a82a0f44c 100644
--- a/galley/pkg/config/testing/fixtures/source_test.go
+++ b/pkg/config/legacy/testing/fixtures/source_test.go
@@ -19,8 +19,8 @@
 
 	"github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
 	"istio.io/istio/pkg/config/event"
+	basicmeta "istio.io/istio/pkg/config/legacy/testing/basicmeta"
 )
 
 func TestSource(t *testing.T) {
diff --git a/galley/pkg/config/testing/fixtures/transformer.go b/pkg/config/legacy/testing/fixtures/transformer.go
similarity index 100%
rename from galley/pkg/config/testing/fixtures/transformer.go
rename to pkg/config/legacy/testing/fixtures/transformer.go
diff --git a/galley/pkg/config/testing/k8smeta/collections.gen.go b/pkg/config/legacy/testing/k8smeta/collections.gen.go
diff --git a/galley/pkg/config/testing/k8smeta/collections.gen.go b/pkg/config/legacy/testing/k8smeta/collections.gen.go
similarity index 100%
rename from galley/pkg/config/testing/k8smeta/collections.gen.go
rename to pkg/config/legacy/testing/k8smeta/collections.gen.go
diff --git a/galley/pkg/config/testing/k8smeta/generate.go b/pkg/config/legacy/testing/k8smeta/generate.go
diff --git a/galley/pkg/config/testing/k8smeta/generate.go b/pkg/config/legacy/testing/k8smeta/generate.go
similarity index 89%
rename from galley/pkg/config/testing/k8smeta/generate.go
rename to pkg/config/legacy/testing/k8smeta/generate.go
index 1b63511a75..b483624600 100644
--- a/galley/pkg/config/testing/k8smeta/generate.go
+++ b/pkg/config/legacy/testing/k8smeta/generate.go
@@ -20,4 +20,4 @@
 // Create collection constants
 //go:generate go run $REPO_ROOT/pkg/config/schema/codegen/tools/collections.main.go k8smeta k8smeta.yaml collections.gen.go
 
-//go:generate goimports -w -local istio.io "$REPO_ROOT/galley/pkg/config/testing/k8smeta/collections.gen.go"
+//go:generate goimports -w -local istio.io "$REPO_ROOT/pkg/config/legacy/testing/k8smeta/collections.gen.go"
diff --git a/galley/pkg/config/testing/k8smeta/get.go b/pkg/config/legacy/testing/k8smeta/get.go
similarity index 92%
rename from galley/pkg/config/testing/k8smeta/get.go
rename to pkg/config/legacy/testing/k8smeta/get.go
index 227e3ff759..31ddb53293 100644
--- a/galley/pkg/config/testing/k8smeta/get.go
+++ b/pkg/config/legacy/testing/k8smeta/get.go
@@ -43,3 +43,8 @@ func MustGet() *schema.Metadata {
 	}
 	return s
 }
+
+func NewMustGet() *schema.Metadata {
+	s := MustGet()
+	return schema.NewMustGetWrapper(s)
+}
diff --git a/galley/pkg/config/testing/k8smeta/k8smeta.gen.go b/pkg/config/legacy/testing/k8smeta/k8smeta.gen.go
similarity index 100%
rename from galley/pkg/config/testing/k8smeta/k8smeta.gen.go
rename to pkg/config/legacy/testing/k8smeta/k8smeta.gen.go
diff --git a/galley/pkg/config/testing/k8smeta/k8smeta.yaml b/pkg/config/legacy/testing/k8smeta/k8smeta.yaml
diff --git a/galley/pkg/config/testing/k8smeta/k8smeta.yaml b/pkg/config/legacy/testing/k8smeta/k8smeta.yaml
similarity index 100%
rename from galley/pkg/config/testing/k8smeta/k8smeta.yaml
rename to pkg/config/legacy/testing/k8smeta/k8smeta.yaml
diff --git a/galley/pkg/config/util/kuberesource/resources.go b/pkg/config/legacy/util/kuberesource/resources.go
diff --git a/galley/pkg/config/util/kuberesource/resources.go b/pkg/config/legacy/util/kuberesource/resources.go
similarity index 73%
rename from galley/pkg/config/util/kuberesource/resources.go
rename to pkg/config/legacy/util/kuberesource/resources.go
index af0d140c7c..2a0d4ec940 100644
--- a/galley/pkg/config/util/kuberesource/resources.go
+++ b/pkg/config/legacy/util/kuberesource/resources.go
@@ -15,10 +15,12 @@
 package kuberesource
 
 import (
-	"istio.io/istio/galley/pkg/config/processing/transformer"
-	"istio.io/istio/galley/pkg/config/source/kube/rt"
+	"fmt"
+
+	"istio.io/istio/pkg/config/legacy/processing/transformer"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/resource"
 )
 
 // DisableExcludedCollections is a helper that filters collection.Schemas to disable some resources
@@ -41,8 +43,7 @@ func DisableExcludedCollections(in collection.Schemas, providers transformer.Pro
 
 			// Check and see if this is needed for Service Discovery. If needed, we will need to re-enable.
 			if enableServiceDiscovery {
-				a := rt.DefaultProvider().GetAdapter(s.Resource())
-				if a.IsRequiredForServiceDiscovery() {
+				if IsRequiredForServiceDiscovery(s.Resource()) {
 					// This is needed for service discovery. Re-enable.
 					disabled = false
 				}
@@ -68,8 +69,7 @@ func DisableExcludedCollections(in collection.Schemas, providers transformer.Pro
 func DefaultExcludedResourceKinds() []string {
 	resources := make([]string, 0)
 	for _, r := range schema.MustGet().KubeCollections().All() {
-		a := rt.DefaultProvider().GetAdapter(r.Resource())
-		if a.IsDefaultExcluded() {
+		if IsDefaultExcluded(r.Resource()) {
 			resources = append(resources, r.Resource().Kind())
 		}
 	}
@@ -85,3 +85,31 @@ func isKindExcluded(excludedResourceKinds []string, kind string) bool {
 
 	return false
 }
+
+// the following code minimally duplicates logic from galley/pkg/config/source/kube/rt/known.go
+// without propagating the many dependencies it comes with.
+
+var knownTypes = map[string]struct{}{
+	asTypesKey("", "Service"):   struct{}{},
+	asTypesKey("", "Namespace"): struct{}{},
+	asTypesKey("", "Node"):      struct{}{},
+	asTypesKey("", "Pod"):       struct{}{},
+	asTypesKey("", "Secret"):    struct{}{},
+}
+
+func asTypesKey(group, kind string) string {
+	if group == "" {
+		return kind
+	}
+	return fmt.Sprintf("%s/%s", group, kind)
+}
+
+func IsRequiredForServiceDiscovery(res resource.Schema) bool {
+	key := asTypesKey(res.Group(), res.Kind())
+	_, ok := knownTypes[key]
+	return ok
+}
+
+func IsDefaultExcluded(res resource.Schema) bool {
+	return IsRequiredForServiceDiscovery(res)
+}
diff --git a/pkg/config/mesh/mesh.go b/pkg/config/mesh/mesh.go
index 4eaf9387c0..e2f9592e5d 100644
--- a/pkg/config/mesh/mesh.go
+++ b/pkg/config/mesh/mesh.go
@@ -63,6 +63,13 @@ func DefaultProxyConfig() meshconfig.ProxyConfig {
 	}
 }
 
+// DefaultMeshNetworks returns a default meshnetworks configuration.
+// By default, it is empty.
+func DefaultMeshNetworks() *meshconfig.MeshNetworks {
+	mn := EmptyMeshNetworks()
+	return &mn
+}
+
 // DefaultMeshConfig returns the default mesh config.
 // This is merged with values from the mesh config map.
 func DefaultMeshConfig() meshconfig.MeshConfig {
diff --git a/pkg/config/resource/metadata.go b/pkg/config/resource/metadata.go
index d7bcc0d411..81747a5a91 100644
--- a/pkg/config/resource/metadata.go
+++ b/pkg/config/resource/metadata.go
@@ -26,6 +26,7 @@ type Metadata struct {
 	FullName    FullName
 	CreateTime  time.Time
 	Version     Version
+	Generation  int64
 	Labels      StringMap
 	Annotations StringMap
 }
diff --git a/pkg/config/resource/serialization_test.go b/pkg/config/resource/serialization_test.go
index 47fab9650e..533b96d647 100644
--- a/pkg/config/resource/serialization_test.go
+++ b/pkg/config/resource/serialization_test.go
@@ -27,7 +27,7 @@
 	"github.com/gogo/protobuf/proto"
 	"github.com/gogo/protobuf/types"
 
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema/collections"
 )
diff --git a/pkg/config/schema/collection/names_test.go b/pkg/config/schema/collection/names_test.go
index de710c9b72..09511d1948 100644
--- a/pkg/config/schema/collection/names_test.go
+++ b/pkg/config/schema/collection/names_test.go
@@ -19,8 +19,8 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/data"
+	basicmeta "istio.io/istio/pkg/config/legacy/testing/basicmeta"
+	data "istio.io/istio/pkg/config/legacy/testing/data"
 	"istio.io/istio/pkg/config/schema/collection"
 )
 
diff --git a/pkg/config/schema/collection/schemas.go b/pkg/config/schema/collection/schemas.go
index 61ed936b36..26519b97c3 100644
--- a/pkg/config/schema/collection/schemas.go
+++ b/pkg/config/schema/collection/schemas.go
@@ -95,6 +95,17 @@ func (s Schemas) ForEach(handleSchema func(Schema) (done bool)) {
 	}
 }
 
+func (s Schemas) Intersect(otherSchemas Schemas) Schemas {
+	resultBuilder := NewSchemasBuilder()
+	for _, myschema := range s.All() {
+		if _, ok := otherSchemas.FindByGroupVersionResource(myschema.Resource().GroupVersionResource()); ok {
+			// an error indicates the schema has already been added, which doesn't negatively impact intersect
+			_ = resultBuilder.Add(myschema)
+		}
+	}
+	return resultBuilder.Build()
+}
+
 // Find looks up a Schema by its collection name.
 func (s Schemas) Find(collection string) (Schema, bool) {
 	i, ok := s.byCollection[Name(collection)]
@@ -225,6 +236,16 @@ func (s Schemas) Kinds() []string {
 	return out
 }
 
+func (s Schemas) WithoutDisabledCollections() Schemas {
+	result := NewSchemasBuilder()
+	for _, i := range s.byAddOrder {
+		if !i.IsDisabled() {
+			_ = result.Add(i)
+		}
+	}
+	return result.Build()
+}
+
 // DisabledCollectionNames returns the names of disabled collections
 func (s Schemas) DisabledCollectionNames() Names {
 	disabledCollections := make(Names, 0)
diff --git a/pkg/config/schema/collections/collections_test.go b/pkg/config/schema/collections/collections_test.go
deleted file mode 100644
index ae7aac836f..0000000000
--- a/pkg/config/schema/collections/collections_test.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package collections
-
-import (
-	"testing"
-
-	"istio.io/istio/pkg/config/schema"
-)
-
-func TestCollectionNames(t *testing.T) {
-	c := All.CollectionNames()
-	if len(c) != len(schema.MustGet().AllCollections().CollectionNames()) {
-		t.Fatalf("Unexpected number of collections: %v", len(c))
-	}
-}
diff --git a/pkg/config/schema/collections_test.go b/pkg/config/schema/collections_test.go
new file mode 100644
index 0000000000..473ad1ed14
--- /dev/null
+++ b/pkg/config/schema/collections_test.go
@@ -0,0 +1,31 @@
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package schema
+
+import (
+	"testing"
+
+	"istio.io/istio/pkg/config/schema/collections"
+)
+
+// this test moved out of collections subdir to avoid circular reference
+func TestCollectionNames(t *testing.T) {
+	c := collections.All.CollectionNames()
+	if len(c) != len(MustGet().AllCollections().CollectionNames()) {
+		t.Fatalf("Unexpected number of collections: %v", len(c))
+	}
+}
diff --git a/pkg/config/schema/get.go b/pkg/config/schema/get.go
index 88f289860a..d39849ec09 100644
--- a/pkg/config/schema/get.go
+++ b/pkg/config/schema/get.go
@@ -16,6 +16,9 @@
 
 import (
 	"fmt"
+
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
 )
 
 // Get returns the contained resources.yaml file, in parsed form.
@@ -41,3 +44,27 @@ func MustGet() *Metadata {
 	}
 	return s
 }
+
+func NewMustGet() *Metadata {
+	s, err := Get()
+	if err != nil {
+		panic(fmt.Sprintf("metadata.MustGet: %v", err))
+	}
+	return NewMustGetWrapper(s)
+}
+
+func NewMustGetWrapper(s *Metadata) *Metadata {
+	return &Metadata{
+		collections:       collections.All,
+		kubeCollections:   collections.All.Intersect(s.KubeCollections()),
+		snapshots:         s.snapshots,
+		transformSettings: s.transformSettings,
+	}
+}
+
+// BuildMetadata assists with pilot
+func MustBuildMetadata(s collection.Schemas) *Metadata {
+	m := NewMustGet()
+	m.kubeCollections = s
+	return m
+}
diff --git a/pkg/config/schema/schema_test.go b/pkg/config/schema/schema_test.go
index 27b5135938..2f4b2a89f6 100644
--- a/pkg/config/schema/schema_test.go
+++ b/pkg/config/schema/schema_test.go
@@ -19,7 +19,7 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
+	fixtures "istio.io/istio/pkg/config/legacy/testing/fixtures"
 	"istio.io/istio/pkg/config/schema/ast"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/istio/pkg/config/schema/collections"
diff --git a/galley/testdatasets/Readme.md b/pkg/test/datasets/Readme.md
similarity index 94%
rename from galley/testdatasets/Readme.md
rename to pkg/test/datasets/Readme.md
index cbfaf8f14a..e0333ad652 100644
--- a/galley/testdatasets/Readme.md
+++ b/pkg/test/datasets/Readme.md
@@ -1,5 +1,7 @@
 # How To Use Galley Test Data Set
 
+## Some of this information is out-of-date.  It is preserved for reference, though the datasets may still be used
+
 The Galley Test Data is designed to tests Galley from an inputs/outputs
 perspective. It uses an embedded set of input and golden files from which
 tests are calculated and executed.
diff --git a/galley/testdatasets/validation/dataset.go b/pkg/test/datasets/validation/dataset.go
similarity index 100%
rename from galley/testdatasets/validation/dataset.go
rename to pkg/test/datasets/validation/dataset.go
diff --git a/galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml b/pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml b/pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml
rename to pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml b/pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml b/pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml
rename to pkg/test/datasets/validation/dataset/extensions-v1alpha1-WasmPlugin-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-DestinationRule-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-EnvoyFilter-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-Gateway-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-ServiceEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-Sidecar-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-regexp-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-VirtualService-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1alpha3-WorkloadGroup-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-DestinationRule-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Gateway-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Gateway-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-Gateway-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-Gateway-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-Sidecar-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-VirtualService-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta-WorkloadEntry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml b/pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml
rename to pkg/test/datasets/validation/dataset/networking-v1beta1-ProxyConfig-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-AuthorizationPolicy-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-PeerAuthentication-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml b/pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml
rename to pkg/test/datasets/validation/dataset/security-v1beta1-RequestAuthentication-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml b/pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml b/pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml
rename to pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-invalid.yaml
diff --git a/galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml b/pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml
diff --git a/galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml b/pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml
similarity index 100%
rename from galley/testdatasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml
rename to pkg/test/datasets/validation/dataset/telemetry-v1alpha1-Telemetry-valid.yaml
diff --git a/tests/fuzz/analyzer_fuzzer.go b/tests/fuzz/analyzer_fuzzer.go
diff --git a/tests/fuzz/analyzer_fuzzer.go b/tests/fuzz/analyzer_fuzzer.go
index 7487266758..2299219abe 100644
--- a/tests/fuzz/analyzer_fuzzer.go
+++ b/tests/fuzz/analyzer_fuzzer.go
@@ -22,10 +22,10 @@
 
 	fuzz "github.com/AdaLogics/go-fuzz-headers"
 
-	"istio.io/istio/galley/pkg/config/analysis"
-	"istio.io/istio/galley/pkg/config/analysis/analyzers"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	"istio.io/istio/galley/pkg/config/scope"
+	"istio.io/istio/pkg/config/analysis"
+	"istio.io/istio/pkg/config/analysis/analyzers"
+	"istio.io/istio/pkg/config/analysis/local"
+	"istio.io/istio/pkg/config/analysis/scope"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/config/schema/collection"
 	"istio.io/pkg/log"
@@ -79,7 +79,7 @@ func createRandomConfigFiles(f *fuzz.ConsumeFuzzer) ([]local.ReaderSource, error
 }
 
 // runAnalyzer runs the analyzer
-func runAnalyzer(sa *local.SourceAnalyzer) (local.AnalysisResult, error) {
+func runAnalyzer(sa *local.IstiodAnalyzer) (local.AnalysisResult, error) {
 	prevLogLevel := scope.Processing.GetOutputLevel()
 	scope.Processing.SetOutputLevel(log.NoneLevel)
 	defer scope.Processing.SetOutputLevel(prevLogLevel)
diff --git a/tests/fuzz/kube_fuzzer.go b/tests/fuzz/kube_fuzzer.go
deleted file mode 100644
index 2716449ffe..0000000000
--- a/tests/fuzz/kube_fuzzer.go
+++ /dev/null
@@ -1,86 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// nolint: golint
-package fuzz
-
-import (
-	fuzz "github.com/AdaLogics/go-fuzz-headers"
-
-	"istio.io/istio/galley/pkg/config/source/kube/inmemory"
-	"istio.io/istio/galley/pkg/config/testing/basicmeta"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
-)
-
-func setupKubeSource() *inmemory.KubeSource {
-	s := inmemory.NewKubeSource(basicmeta.MustGet().KubeCollections())
-	acc := &fixtures.Accumulator{}
-	s.Dispatch(acc)
-	return s
-}
-
-func applyFuzzedContent(f *fuzz.ConsumeFuzzer, s *inmemory.KubeSource) error {
-	name, err := f.GetString()
-	if err != nil {
-		return err
-	}
-	yamlText, err := f.GetString()
-	if err != nil {
-		return err
-	}
-	_ = s.ApplyContent(name, yamlText)
-	return nil
-}
-
-func removeFuzzedContent(f *fuzz.ConsumeFuzzer, s *inmemory.KubeSource) error {
-	name, err := f.GetString()
-	if err != nil {
-		return err
-	}
-	s.RemoveContent(name)
-	return nil
-}
-
-func FuzzInmemoryKube(data []byte) int {
-	f := fuzz.NewConsumer(data)
-	s := setupKubeSource()
-	s.Start()
-	defer s.Stop()
-
-	numberOfIterations, err := f.GetInt()
-	if err != nil {
-		return 0
-	}
-	totalIters := numberOfIterations % 30
-	for i := 0; i < totalIters; i++ {
-		action, err := f.GetInt()
-		if err != nil {
-			return 0
-		}
-		if action%1 == 0 {
-			err = applyFuzzedContent(f, s)
-			if err != nil {
-				return 0
-			}
-		} else if action%2 == 0 {
-			err = removeFuzzedContent(f, s)
-			if err != nil {
-				return 0
-			}
-		} else if action%3 == 0 {
-			_ = s.ContentNames()
-		}
-	}
-	return 1
-}
diff --git a/tests/fuzz/misc_fuzzers.go b/tests/fuzz/misc_fuzzers.go
index ea1f59c454..a01681e30a 100644
--- a/tests/fuzz/misc_fuzzers.go
+++ b/tests/fuzz/misc_fuzzers.go
@@ -22,15 +22,9 @@
 package fuzz
 
 import (
-	"os"
-	"path/filepath"
-
 	fuzz "github.com/AdaLogics/go-fuzz-headers"
 
 	"istio.io/api/operator/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/mesh"
-	"istio.io/istio/galley/pkg/config/testing/fixtures"
 	"istio.io/istio/istioctl/pkg/verifier"
 	"istio.io/istio/operator/pkg/apis/istio"
 	"istio.io/istio/operator/pkg/apis/istio/v1alpha1/validation"
@@ -40,6 +34,7 @@
 	"istio.io/istio/operator/pkg/translate"
 	"istio.io/istio/operator/pkg/util"
 	"istio.io/istio/operator/pkg/validate"
+	"istio.io/istio/pkg/config/analysis/diag"
 	"istio.io/istio/pkg/config/resource"
 )
 
@@ -187,40 +182,6 @@ func FuzzYAMLManifestPatch(data []byte) int {
 	return 1
 }
 
-func FuzzGalleyMeshFs(data []byte) int {
-	f := fuzz.NewConsumer(data)
-
-	p, err := os.MkdirTemp("/tmp", "fuzz-data-")
-	if err != nil {
-		return 0
-	}
-	defer os.RemoveAll(p)
-	mcFile := filepath.Join(p, "meshconfig.yaml")
-	mcFileBytes, err := f.GetBytes()
-	if err != nil {
-		return 0
-	}
-	mcf, err := os.OpenFile(mcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
-	if err != nil {
-		return 0
-	}
-	defer mcf.Close()
-	_, err = mcf.Write(mcFileBytes)
-	if err != nil {
-		return 0
-	}
-	fs, err := mesh.NewMeshConfigFS(mcFile)
-	if err != nil {
-		return 0
-	}
-	defer fs.Close()
-	acc := &fixtures.Accumulator{}
-	fs.Dispatch(acc)
-	fs.Start()
-	fs.Stop()
-	return 1
-}
-
 func FuzzGalleyDiag(data []byte) int {
 	f := fuzz.NewConsumer(data)
 
diff --git a/tests/fuzz/oss_fuzz_build.sh b/tests/fuzz/oss_fuzz_build.sh
index 48c0dc4d65..4fa398ffaa 100755
--- a/tests/fuzz/oss_fuzz_build.sh
+++ b/tests/fuzz/oss_fuzz_build.sh
@@ -80,10 +80,8 @@ compile_go_fuzzer istio.io/istio/tests/fuzz FuzzOverlayIOP fuzz_overlay_iop
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzNewControlplane fuzz_new_control_plane
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzResolveK8sConflict fuzz_resolve_k8s_conflict
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzYAMLManifestPatch fuzz_yaml_manifest_patch
-compile_go_fuzzer istio.io/istio/tests/fuzz FuzzGalleyMeshFs fuzz_galley_mesh_fs
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzGalleyDiag fuzz_galley_diag
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzNewBootstrapServer fuzz_new_bootstrap_server
-compile_go_fuzzer istio.io/istio/tests/fuzz FuzzInmemoryKube fuzz_inmemory_kube
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzGenCSR fuzz_gen_csr
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzCreateCertE2EUsingClientCertAuthenticator fuzz_create_cert_e2e_using_client_cert_authenticator
 
diff --git a/tests/fuzz/regression_test.go b/tests/fuzz/regression_test.go
index a182b2074b..a1392aa5b1 100644
--- a/tests/fuzz/regression_test.go
+++ b/tests/fuzz/regression_test.go
@@ -35,10 +35,7 @@
 
 // brokenCases contains test cases that are currently failing. These should only be added if the
 // failure is publicly disclosed!
-var brokenCases = map[string]string{
-	"6169070276837376": "https://github.com/go-yaml/yaml/issues/666",
-	"6087702507290624": "https://github.com/go-yaml/yaml/issues/768",
-}
+var brokenCases = map[string]string{}
 
 func runRegressionTest(t *testing.T, name string, fuzz func(data []byte) int) {
 	dir := filepath.Join("testdata", name)
@@ -140,10 +137,8 @@ func TestFuzzers(t *testing.T) {
 		{"FuzzNewControlplane", FuzzNewControlplane},
 		{"FuzzResolveK8sConflict", FuzzResolveK8sConflict},
 		{"FuzzYAMLManifestPatch", FuzzYAMLManifestPatch},
-		{"FuzzGalleyMeshFs", FuzzGalleyMeshFs},
 		{"FuzzGalleyDiag", FuzzGalleyDiag},
 		{"FuzzNewBootstrapServer", FuzzNewBootstrapServer},
-		{"FuzzInmemoryKube", FuzzInmemoryKube},
 		{"FuzzGenCSR", FuzzGenCSR},
 		{"FuzzCreateCertE2EUsingClientCertAuthenticator", FuzzCreateCertE2EUsingClientCertAuthenticator},
 		{"FuzzConfigValidation3", FuzzConfigValidation3},
diff --git a/tests/integration/operator/operator_dumper.go b/tests/integration/operator/operator_dumper.go
new file mode 100644
index 0000000000..4a531977e4
--- /dev/null
+++ b/tests/integration/operator/operator_dumper.go
@@ -0,0 +1,59 @@
+//go:build integ
+// +build integ
+
+/*
+ Copyright Istio Authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+package operator
+
+import (
+	"istio.io/istio/pkg/test/framework/resource"
+	kube2 "istio.io/istio/pkg/test/kube"
+	"istio.io/istio/pkg/test/scopes"
+)
+
+// operatorDumper dumps the logs of in-cluster operator at suite completion
+type operatorDumper struct {
+	ns  string
+	rev string
+}
+
+func (d *operatorDumper) Dump(ctx resource.Context) {
+	scopes.Framework.Errorf("=== Dumping Istio Deployment State...")
+	ns := d.ns
+	if len(ns) < 1 {
+		ns = "istio-operator"
+	}
+
+	dir, err := ctx.CreateTmpDirectory("istio-operator-" + d.ID().String())
+	if err != nil {
+		scopes.Framework.Errorf("Unable to create directory for dumping operator contents: %v", err)
+		return
+	}
+	kube2.DumpPods(ctx, dir, ns, []string{"name=istio-operator"})
+}
+
+func (d *operatorDumper) ID() resource.ID {
+	return &operatorID{d.rev}
+}
+
+type operatorID struct {
+	content string
+}
+
+func (o *operatorID) String() string {
+	return o.content
+}
diff --git a/tests/integration/operator/switch_cr_test.go b/tests/integration/operator/switch_cr_test.go
index 9ae6e7829a..89136e03c3 100644
--- a/tests/integration/operator/switch_cr_test.go
+++ b/tests/integration/operator/switch_cr_test.go
@@ -92,6 +92,7 @@ func TestController(t *testing.T) {
 			}
 			// install istio with default config for the first time by running operator init command
 			istioCtl.InvokeOrFail(t, initCmd)
+			t.TrackResource(&operatorDumper{rev: ""})
 
 			if _, err := cs.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
 				ObjectMeta: kubeApiMeta.ObjectMeta{
@@ -119,6 +120,7 @@ func TestController(t *testing.T) {
 			}
 			// install second operator deployment with different revision
 			istioCtl.InvokeOrFail(t, initCmd)
+			t.TrackResource(&operatorDumper{rev: "v2"})
 			installWithCRFile(t, t, cs, s, istioCtl, "default", "v2")
 
 			// istio control plane resources expected to be deleted after deleting CRs
@@ -227,6 +229,7 @@ func checkInstallStatus(cs istioKube.ExtendedClient, revision string) error {
 		}
 		return errs.ToError()
 	}
+	scopes.Framework.Infof("waiting for IOP to become healthy")
 	err := retry.UntilSuccess(retryFunc, retry.Timeout(retryTimeOut), retry.Delay(retryDelay))
 	if err != nil {
 		return fmt.Errorf("istioOperator status is not healthy: %v", err)
@@ -256,6 +259,7 @@ func cleanupInClusterCRs(t framework.TestContext, cs cluster.Cluster) {
 		t.Logf("failed to list existing CR: %v", err.Error())
 	}
 
+	scopes.Framework.Infof("waiting for pods in istio-system to be deleted")
 	// wait for pods in istio-system to be deleted
 	err = retry.UntilSuccess(func() error {
 		podList, err := cs.Kube().CoreV1().Pods(IstioNamespace).List(context.TODO(), kubeApiMeta.ListOptions{})
@@ -270,6 +274,8 @@ func cleanupInClusterCRs(t framework.TestContext, cs cluster.Cluster) {
 
 	if err != nil {
 		t.Logf("failed to delete pods in %s: %v", IstioNamespace, err)
+	} else {
+		t.Logf("all pods in istio-system deleted")
 	}
 }
 
diff --git a/tests/integration/pilot/analysis/analysis_test.go b/tests/integration/pilot/analysis/analysis_test.go
index 0d9407799e..49bc1303ad 100644
--- a/tests/integration/pilot/analysis/analysis_test.go
+++ b/tests/integration/pilot/analysis/analysis_test.go
@@ -27,7 +27,7 @@
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"istio.io/api/meta/v1alpha1"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/features"
@@ -53,6 +53,21 @@ func TestAnalysisWritesStatus(t *testing.T) {
 				Revision: "",
 				Labels:   nil,
 			})
+			t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), `
+apiVersion: v1
+kind: Service
+metadata:
+  name: reviews
+spec:
+  selector:
+    app: reviews
+  type: ClusterIP
+  ports:
+  - name: http-monitoring
+    port: 15014
+    protocol: TCP
+    targetPort: 15014
+`)
 			// Apply bad config (referencing invalid host)
 			t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), `
 apiVersion: networking.istio.io/v1alpha3
@@ -232,7 +247,7 @@ func expectVirtualServiceStatus(t framework.TestContext, ns namespace.Instance,
 		if !found {
 			return fmt.Errorf("expected error %v to exist", msg.ReferencedResourceNotFound.Code())
 		}
-	} else if status.ValidationMessages != nil {
+	} else if status.ValidationMessages != nil && len(status.ValidationMessages) > 0 {
 		return fmt.Errorf("expected no validation messages, but got %d", len(status.ValidationMessages))
 	}
 
diff --git a/tests/integration/pilot/analyze_test.go b/tests/integration/pilot/analyze_test.go
index d8e8de3d22..cf50b0f602 100644
--- a/tests/integration/pilot/analyze_test.go
+++ b/tests/integration/pilot/analyze_test.go
@@ -25,9 +25,9 @@
 
 	. "github.com/onsi/gomega"
 
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/msg"
 	"istio.io/istio/istioctl/cmd"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/msg"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/istioctl"
diff --git a/tests/integration/pilot/validation_test.go b/tests/integration/pilot/validation_test.go
index e90839abd6..57ef91ed08 100644
--- a/tests/integration/pilot/validation_test.go
+++ b/tests/integration/pilot/validation_test.go
@@ -25,8 +25,8 @@
 	"gopkg.in/square/go-jose.v2/json"
 	"sigs.k8s.io/yaml"
 
-	"istio.io/istio/galley/testdatasets/validation"
 	"istio.io/istio/pkg/config/schema"
+	"istio.io/istio/pkg/test/datasets/validation"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/util/yml"
diff --git a/tools/bug-report/pkg/bugreport/bugreport.go b/tools/bug-report/pkg/bugreport/bugreport.go
index 23f28f68e7..e48030347e 100644
--- a/tools/bug-report/pkg/bugreport/bugreport.go
+++ b/tools/bug-report/pkg/bugreport/bugreport.go
@@ -32,8 +32,8 @@
 	"github.com/spf13/cobra"
 	"k8s.io/client-go/tools/clientcmd"
 
-	analyzer_util "istio.io/istio/galley/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/operator/pkg/util"
+	analyzer_util "istio.io/istio/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/proxy"
 	"istio.io/istio/tools/bug-report/pkg/archive"
diff --git a/tools/bug-report/pkg/bugreport/flags.go b/tools/bug-report/pkg/bugreport/flags.go
index 1ad0216854..986a7a82fa 100644
--- a/tools/bug-report/pkg/bugreport/flags.go
+++ b/tools/bug-report/pkg/bugreport/flags.go
@@ -24,7 +24,7 @@
 	"github.com/spf13/cobra"
 	"sigs.k8s.io/yaml"
 
-	analyzer_util "istio.io/istio/galley/pkg/config/analysis/analyzers/util"
+	analyzer_util "istio.io/istio/pkg/config/analysis/analyzers/util"
 	config2 "istio.io/istio/tools/bug-report/pkg/config"
 	"istio.io/pkg/log"
 )
diff --git a/tools/bug-report/pkg/cluster/cluster.go b/tools/bug-report/pkg/cluster/cluster.go
index ac5ed9c866..64b9177838 100644
--- a/tools/bug-report/pkg/cluster/cluster.go
+++ b/tools/bug-report/pkg/cluster/cluster.go
@@ -25,7 +25,7 @@
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/client-go/kubernetes"
 
-	analyzer_util "istio.io/istio/galley/pkg/config/analysis/analyzers/util"
+	analyzer_util "istio.io/istio/pkg/config/analysis/analyzers/util"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/tools/bug-report/pkg/common"
 	"istio.io/istio/tools/bug-report/pkg/util/path"
diff --git a/tools/bug-report/pkg/content/content.go b/tools/bug-report/pkg/content/content.go
index d2c2aa5f80..16272dca74 100644
--- a/tools/bug-report/pkg/content/content.go
+++ b/tools/bug-report/pkg/content/content.go
@@ -19,11 +19,10 @@
 	"strings"
 	"time"
 
-	"istio.io/istio/galley/pkg/config/analysis/analyzers"
-	"istio.io/istio/galley/pkg/config/analysis/diag"
-	"istio.io/istio/galley/pkg/config/analysis/local"
-	cfgKube "istio.io/istio/galley/pkg/config/source/kube"
 	"istio.io/istio/istioctl/pkg/util/formatting"
+	"istio.io/istio/pkg/config/analysis/analyzers"
+	"istio.io/istio/pkg/config/analysis/diag"
+	"istio.io/istio/pkg/config/analysis/local"
 	"istio.io/istio/pkg/config/resource"
 	"istio.io/istio/pkg/config/schema"
 	"istio.io/istio/pkg/kube"
@@ -221,10 +220,13 @@ func GetNetstat(p *Params) (map[string]string, error) {
 // GetAnalyze returns the output of istioctl analyze.
 func GetAnalyze(p *Params) (map[string]string, error) {
 	out := make(map[string]string)
-	sa := local.NewSourceAnalyzer(schema.MustGet(), analyzers.AllCombined(),
+	sa := local.NewSourceAnalyzer(schema.NewMustGet(), analyzers.AllCombined(),
 		resource.Namespace(p.Namespace), resource.Namespace(p.IstioNamespace), nil, true, 5*time.Minute)
 
-	k := cfgKube.NewInterfaces(p.Client.RESTConfig())
+	k, err := kube.NewClient(kube.NewClientConfigForRestConfig(p.Client.RESTConfig()))
+	if err != nil {
+		return nil, err
+	}
 	sa.AddRunningKubeSource(k)
 
 	cancel := make(chan struct{})
-- 
2.35.3

