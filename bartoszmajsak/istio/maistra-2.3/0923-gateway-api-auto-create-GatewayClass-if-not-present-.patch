From e2cbf58dfc649fe21bc414b76405ac246ed40d73 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Fri, 25 Mar 2022 15:03:31 -0700
Subject: gateway-api: auto-create GatewayClass if not present (#38118)

For https://github.com/istio/istio/issues/36971
---
 .../charts/base/files/gen-istio-cluster.yaml  |   3 +
 .../charts/base/templates/clusterrole.yaml    |   3 +
 .../istio-discovery/files/gen-istio.yaml      |   3 +
 .../templates/clusterrole.yaml                |   3 +
 .../istiod-remote/templates/clusterrole.yaml  |   3 +
 pilot/pkg/config/kube/crdclient/client.go     |   1 +
 pilot/pkg/config/kube/gateway/controller.go   |   8 ++
 pilot/pkg/config/kube/gateway/gatewayclass.go |  92 ++++++++++++++++
 .../config/kube/gateway/gatewayclass_test.go  | 101 ++++++++++++++++++
 pilot/pkg/status/distribution/state.go        |   8 ++
 10 files changed, 225 insertions(+)
 create mode 100644 pilot/pkg/config/kube/gateway/gatewayclass.go
 create mode 100644 pilot/pkg/config/kube/gateway/gatewayclass_test.go

diff --git a/manifests/charts/base/files/gen-istio-cluster.yaml b/manifests/charts/base/files/gen-istio-cluster.yaml
index ea4154793d..5c08e32099 100644
--- a/manifests/charts/base/files/gen-istio-cluster.yaml
+++ b/manifests/charts/base/files/gen-istio-cluster.yaml
@@ -6567,6 +6567,9 @@ rules:
   - apiGroups: ["networking.x-k8s.io", "gateway.networking.k8s.io"]
     resources: ["*"] # TODO: should be on just */status but wildcard is not supported
     verbs: ["update"]
+  - apiGroups: ["gateway.networking.k8s.io"]
+    resources: ["gatewayclasses"]
+    verbs: ["create", "update", "patch", "delete"]
 
   # Needed for multicluster secret reading, possibly ingress certs in the future
   - apiGroups: [""]
diff --git a/manifests/charts/base/templates/clusterrole.yaml b/manifests/charts/base/templates/clusterrole.yaml
index ef3300348a..e0cbea8fe3 100644
--- a/manifests/charts/base/templates/clusterrole.yaml
+++ b/manifests/charts/base/templates/clusterrole.yaml
@@ -105,6 +105,9 @@ rules:
   - apiGroups: ["networking.x-k8s.io", "gateway.networking.k8s.io"]
     resources: ["*"] # TODO: should be on just */status but wildcard is not supported
     verbs: ["update"]
+  - apiGroups: ["gateway.networking.k8s.io"]
+    resources: ["gatewayclasses"]
+    verbs: ["create", "update", "patch", "delete"]
 
   # Needed for multicluster secret reading, possibly ingress certs in the future
   - apiGroups: [""]
diff --git a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
index b635bfaaed..b319295705 100644
--- a/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
+++ b/manifests/charts/istio-control/istio-discovery/files/gen-istio.yaml
@@ -1296,6 +1296,9 @@ rules:
   - apiGroups: ["networking.x-k8s.io", "gateway.networking.k8s.io"]
     resources: ["*"] # TODO: should be on just */status but wildcard is not supported
     verbs: ["update", "patch"]
+  - apiGroups: ["gateway.networking.k8s.io"]
+    resources: ["gatewayclasses"]
+    verbs: ["create", "update", "patch", "delete"]
 
   # Needed for multicluster secret reading, possibly ingress certs in the future
   - apiGroups: [""]
diff --git a/manifests/charts/istio-control/istio-discovery/templates/clusterrole.yaml b/manifests/charts/istio-control/istio-discovery/templates/clusterrole.yaml
index 08c09edee0..4848fd37c0 100644
--- a/manifests/charts/istio-control/istio-discovery/templates/clusterrole.yaml
+++ b/manifests/charts/istio-control/istio-discovery/templates/clusterrole.yaml
@@ -101,6 +101,9 @@ rules:
   - apiGroups: ["networking.x-k8s.io", "gateway.networking.k8s.io"]
     resources: ["*"] # TODO: should be on just */status but wildcard is not supported
     verbs: ["update", "patch"]
+  - apiGroups: ["gateway.networking.k8s.io"]
+    resources: ["gatewayclasses"]
+    verbs: ["create", "update", "patch", "delete"]
 
   # Needed for multicluster secret reading, possibly ingress certs in the future
   - apiGroups: [""]
diff --git a/manifests/charts/istiod-remote/templates/clusterrole.yaml b/manifests/charts/istiod-remote/templates/clusterrole.yaml
index d2fba87db7..53bfe808ea 100644
--- a/manifests/charts/istiod-remote/templates/clusterrole.yaml
+++ b/manifests/charts/istiod-remote/templates/clusterrole.yaml
@@ -102,6 +102,9 @@ rules:
   - apiGroups: ["networking.x-k8s.io", "gateway.networking.k8s.io"]
     resources: ["*"] # TODO: should be on just */status but wildcard is not supported
     verbs: ["update", "patch"]
+  - apiGroups: ["gateway.networking.k8s.io"]
+    resources: ["gatewayclasses"]
+    verbs: ["create", "update", "patch", "delete"]
 
   # Needed for multicluster secret reading, possibly ingress certs in the future
   - apiGroups: [""]
diff --git a/pilot/pkg/config/kube/crdclient/client.go b/pilot/pkg/config/kube/crdclient/client.go
index 4b7c82f5a8..96dcd37e6c 100644
--- a/pilot/pkg/config/kube/crdclient/client.go
+++ b/pilot/pkg/config/kube/crdclient/client.go
@@ -112,6 +112,7 @@ func New(client kube.Client, revision, domainSuffix string) (model.ConfigStoreCa
 
 var crdWatches = map[config.GroupVersionKind]*waiter{
 	gvk.KubernetesGateway: newWaiter(),
+	gvk.GatewayClass:      newWaiter(),
 }
 
 type waiter struct {
diff --git a/pilot/pkg/config/kube/gateway/controller.go b/pilot/pkg/config/kube/gateway/controller.go
index cc8dad0dbb..84dd5332dc 100644
--- a/pilot/pkg/config/kube/gateway/controller.go
+++ b/pilot/pkg/config/kube/gateway/controller.go
@@ -27,6 +27,7 @@
 	"k8s.io/client-go/tools/cache"
 	k8s "sigs.k8s.io/gateway-api/apis/v1alpha2"
 
+	"istio.io/istio/pilot/pkg/config/kube/crdclient"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/model/credentials"
@@ -271,6 +272,13 @@ func (c *Controller) RegisterEventHandler(typ config.GroupVersionKind, handler m
 }
 
 func (c *Controller) Run(stop <-chan struct{}) {
+	go func() {
+		if crdclient.WaitForCRD(gvk.GatewayClass, stop) {
+			gcc := NewClassController(c.client)
+			c.client.RunAndWait(stop)
+			gcc.Run(stop)
+		}
+	}()
 	cache.WaitForCacheSync(stop, c.namespaceInformer.HasSynced)
 }
 
diff --git a/pilot/pkg/config/kube/gateway/gatewayclass.go b/pilot/pkg/config/kube/gateway/gatewayclass.go
new file mode 100644
index 0000000000..f1f8e44b06
--- /dev/null
+++ b/pilot/pkg/config/kube/gateway/gatewayclass.go
@@ -0,0 +1,92 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"context"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	gateway "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gatewayclient "sigs.k8s.io/gateway-api/pkg/client/clientset/gateway/versioned/typed/apis/v1alpha2"
+	lister "sigs.k8s.io/gateway-api/pkg/client/listers/gateway/apis/v1alpha2"
+
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+)
+
+// ClassController is a controller that creates the default Istio GatewayClass. This will not
+// continually reconcile the full state of the GatewayClass object, and instead only create the class
+// if it doesn't exist. This allows users to manage it through other means or modify it as they wish.
+// If it is deleted, however, it will be added back.
+// This controller intentionally does not do leader election for simplicity. Because we only create
+// and not update there is no need; the first controller to create the GatewayClass wins.
+type ClassController struct {
+	queue        controllers.Queue
+	classes      lister.GatewayClassLister
+	directClient gatewayclient.GatewayClassInterface
+}
+
+func NewClassController(client kube.Client) *ClassController {
+	gc := &ClassController{}
+	gc.queue = controllers.NewQueue("gateway class",
+		controllers.WithReconciler(gc.Reconcile),
+		controllers.WithMaxAttempts(25))
+
+	class := client.GatewayAPIInformer().Gateway().V1alpha2().GatewayClasses()
+	gc.classes = class.Lister()
+	gc.directClient = client.GatewayAPI().GatewayV1alpha2().GatewayClasses()
+	class.Informer().
+		AddEventHandler(controllers.FilteredObjectHandler(gc.queue.AddObject, func(o controllers.Object) bool {
+			return o.GetName() == DefaultClassName
+		}))
+	return gc
+}
+
+func (c *ClassController) Run(stop <-chan struct{}) {
+	// Ensure we initially reconcile the current state
+	c.queue.Add(types.NamespacedName{Name: DefaultClassName})
+	c.queue.Run(stop)
+}
+
+func (c *ClassController) Reconcile(_ types.NamespacedName) error {
+	_, err := c.classes.Get(DefaultClassName)
+	if err := controllers.IgnoreNotFound(err); err != nil {
+		log.Errorf("unable to fetch GatewayClass: %v", err)
+		return err
+	}
+	if !apierrors.IsNotFound(err) {
+		log.Debugf("GatewayClass/%v already exists, no action", DefaultClassName)
+		return nil
+	}
+	desc := "The default Istio GatewayClass"
+	gc := &gateway.GatewayClass{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: DefaultClassName,
+		},
+		Spec: gateway.GatewayClassSpec{
+			ControllerName: ControllerName,
+			Description:    &desc,
+		},
+	}
+	_, err = c.directClient.Create(context.Background(), gc, metav1.CreateOptions{})
+	if apierrors.IsConflict(err) {
+		// This is not really an error, just a race condition
+		log.Infof("Attempted to create GatewayClass/%v, but it was already created", DefaultClassName)
+		return nil
+	}
+	return err
+}
diff --git a/pilot/pkg/config/kube/gateway/gatewayclass_test.go b/pilot/pkg/config/kube/gateway/gatewayclass_test.go
new file mode 100644
index 0000000000..8f27fb86e8
--- /dev/null
+++ b/pilot/pkg/config/kube/gateway/gatewayclass_test.go
@@ -0,0 +1,101 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"context"
+	"fmt"
+	"testing"
+	"time"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	gateway "sigs.k8s.io/gateway-api/apis/v1alpha2"
+
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/test/util/retry"
+)
+
+func TestClassController(t *testing.T) {
+	client := kube.NewFakeClient()
+	cc := NewClassController(client)
+	stop := make(chan struct{})
+	t.Cleanup(func() {
+		close(stop)
+	})
+	client.RunAndWait(stop)
+	go cc.Run(stop)
+	createClass := func(name, controller string) {
+		gc := &gateway.GatewayClass{
+			ObjectMeta: metav1.ObjectMeta{
+				Name: name,
+			},
+			Spec: gateway.GatewayClassSpec{
+				ControllerName: gateway.GatewayController(controller),
+			},
+		}
+		_, err := client.GatewayAPI().GatewayV1alpha2().GatewayClasses().Create(context.Background(), gc, metav1.CreateOptions{})
+		if apierrors.IsAlreadyExists(err) {
+			_, _ = client.GatewayAPI().GatewayV1alpha2().GatewayClasses().Update(context.Background(), gc, metav1.UpdateOptions{})
+		}
+	}
+	deleteClass := func(name string) {
+		client.GatewayAPI().GatewayV1alpha2().GatewayClasses().Delete(context.Background(), name, metav1.DeleteOptions{})
+	}
+	expectClass := func(name, controller string) {
+		t.Helper()
+		retry.UntilSuccessOrFail(t, func() error {
+			gc, err := client.GatewayAPI().GatewayV1alpha2().GatewayClasses().Get(context.Background(), name, metav1.GetOptions{})
+			if controllers.IgnoreNotFound(err) != nil {
+				return err
+			}
+			if controller == "" {
+				if gc == nil { // Expect none, got none
+					return nil
+				}
+				return fmt.Errorf("expected no class, got %v", gc.Spec.ControllerName)
+			}
+			if gc == nil {
+				return fmt.Errorf("expected class %v, got none", controller)
+			}
+			if gateway.GatewayController(controller) != gc.Spec.ControllerName {
+				return fmt.Errorf("expected class %v, got %v", controller, gc.Spec.ControllerName)
+			}
+			return nil
+		}, retry.Timeout(time.Second*3))
+	}
+
+	// Class should be created initially
+	expectClass(DefaultClassName, ControllerName)
+
+	// Once we delete it, it should be added back
+	deleteClass(DefaultClassName)
+	expectClass(DefaultClassName, ControllerName)
+
+	// Overwrite the class, controller should not reconcile it back
+	createClass(DefaultClassName, "different-controller")
+	expectClass(DefaultClassName, "different-controller")
+
+	// Once we delete it, it should be added back
+	deleteClass(DefaultClassName)
+	expectClass(DefaultClassName, ControllerName)
+
+	// Create an unrelated GatewayClass, we should not do anything to it
+	createClass("something-else", "different-controller")
+	expectClass("something-else", "different-controller")
+	deleteClass("something-else")
+	expectClass("something-else", "")
+}
diff --git a/pilot/pkg/status/distribution/state.go b/pilot/pkg/status/distribution/state.go
index eb0c45552d..aa59626615 100644
--- a/pilot/pkg/status/distribution/state.go
+++ b/pilot/pkg/status/distribution/state.go
@@ -16,6 +16,7 @@
 
 import (
 	"fmt"
+	"strings"
 	"sync"
 	"time"
 
@@ -73,6 +74,9 @@ func NewController(restConfig *rest.Config, namespace string, cs model.ConfigSto
 		clock:           clock.RealClock{},
 		configStore:     cs,
 		workers: m.CreateIstioStatusController(func(status *v1alpha1.IstioStatus, context interface{}) *v1alpha1.IstioStatus {
+			if status == nil {
+				return nil
+			}
 			distributionState := context.(Progress)
 			if needsReconcile, desiredStatus := ReconcileStatuses(status, distributionState); needsReconcile {
 				return desiredStatus
@@ -145,6 +149,10 @@ func (c *Controller) writeAllStatus() (staleReporters []string) {
 	defer c.mu.RUnlock()
 	c.mu.RLock()
 	for config, fractions := range c.CurrentState {
+		if !strings.HasSuffix(config.Group, "istio.io") {
+			// don't try to write status for non-istio types
+			continue
+		}
 		var distributionState Progress
 		for reporter, w := range fractions {
 			// check for stale data here
-- 
2.35.3

