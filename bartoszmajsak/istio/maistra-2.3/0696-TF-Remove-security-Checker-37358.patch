From 4971fe18ba9743bb7eb55c1f18719fc1b8993c76 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Wed, 2 Mar 2022 15:07:23 -0800
Subject: [TF] Remove security Checker (#37358)

This removes another major layer within the security tests.
---
 pkg/http/headers/wellknown.go                 |   8 +-
 pkg/test/echo/check/checkers.go               |  15 +
 .../ca_custom_root/multi_root_test.go         |  34 +-
 .../ca_custom_root/secure_naming_test.go      |  34 +-
 .../trust_domain_alias_secure_naming_test.go  |  38 +-
 .../trust_domain_validation_test.go           |  20 +-
 .../security/external_ca/reachability_test.go |  15 +-
 .../file_mounted_certs/p2p_mtls_test.go       |  44 +-
 .../destination_rule_tls_test.go              |  24 +-
 .../egress_gateway_origination_test.go        |  48 +-
 .../security/https_jwt/https_jwt_test.go      | 125 ++-
 tests/integration/security/jwt_test.go        | 964 +++++++++---------
 .../security/util/authn/authn_util.go         |  89 --
 .../security/util/connection/checker.go       |  82 --
 .../security/util/reachability/context.go     |  58 +-
 .../security/util/scheck/checkers.go          |  12 +
 16 files changed, 681 insertions(+), 929 deletions(-)
 delete mode 100644 tests/integration/security/util/authn/authn_util.go
 delete mode 100644 tests/integration/security/util/connection/checker.go

diff --git a/pkg/http/headers/wellknown.go b/pkg/http/headers/wellknown.go
index 2e8d90b85d..9cac5548d2 100644
--- a/pkg/http/headers/wellknown.go
+++ b/pkg/http/headers/wellknown.go
@@ -15,7 +15,9 @@
 package headers
 
 const (
-	Host          = "Host"
-	Authorization = "Authorization"
-	XForwardedFor = "X-Forwarded-For"
+	Host                       = "Host"
+	Authorization              = "Authorization"
+	XForwardedFor              = "X-Forwarded-For"
+	AccessControlRequestMethod = "Access-Control-Request-Method"
+	Origin                     = "Origin"
 )
diff --git a/pkg/test/echo/check/checkers.go b/pkg/test/echo/check/checkers.go
index e7e00e5cee..813c99ce9e 100644
--- a/pkg/test/echo/check/checkers.go
+++ b/pkg/test/echo/check/checkers.go
@@ -56,6 +56,21 @@ func And(checkers ...Checker) Checker {
 	}
 }
 
+// Or is an aggregate Checker that requires at least one Checker succeeds.
+func Or(checkers ...Checker) Checker {
+	return func(rs echo.Responses, err error) error {
+		out := istiomultierror.New()
+		for _, c := range checkers {
+			err := c(rs, err)
+			if err == nil {
+				return nil
+			}
+			out = multierror.Append(out, err)
+		}
+		return out.ErrorOrNil()
+	}
+}
+
 func filterNil(checkers []Checker) []Checker {
 	var out []Checker
 	for _, c := range checkers {
diff --git a/tests/integration/security/ca_custom_root/multi_root_test.go b/tests/integration/security/ca_custom_root/multi_root_test.go
index 6a51364974..aceef9b020 100644
--- a/tests/integration/security/ca_custom_root/multi_root_test.go
+++ b/tests/integration/security/ca_custom_root/multi_root_test.go
@@ -21,10 +21,11 @@
 	"fmt"
 	"testing"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/tests/integration/security/util/connection"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 func TestMultiRootSetup(t *testing.T) {
@@ -37,46 +38,41 @@ func TestMultiRootSetup(t *testing.T) {
 
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					verify := func(ctx framework.TestContext, src echo.Instance, dest echo.Instance, s scheme.Instance, success bool) {
+					verify := func(ctx framework.TestContext, from echo.Instance, to echo.Instances, s scheme.Instance, success bool) {
 						want := "success"
 						if !success {
 							want = "fail"
 						}
-						name := fmt.Sprintf("server:%s[%s]", dest.Config().Service, want)
+						name := fmt.Sprintf("server:%s[%s]", to[0].Config().Service, want)
 						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
-							opt := echo.CallOptions{
-								Target:   dest,
+							opts := echo.CallOptions{
+								Target:   to[0],
 								PortName: HTTPS,
-								Address:  dest.Config().Service,
+								Address:  to[0].Config().Service,
 								Scheme:   s,
 							}
-							checker := connection.Checker{
-								From:          src,
-								Options:       opt,
-								ExpectSuccess: success,
-								DestClusters:  t.Clusters(),
-							}
-							checker.CheckOrFail(t)
+							opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+
+							from.CallWithRetryOrFail(t, opts)
 						})
 					}
 
 					client := apps.Client.GetOrFail(t, echo.InCluster(cluster))
-					serverNakedFooAlt := apps.ServerNakedFooAlt.GetOrFail(t, echo.InCluster(cluster))
 					cases := []struct {
-						src    echo.Instance
-						dest   echo.Instance
+						from   echo.Instance
+						to     echo.Instances
 						expect bool
 					}{
 						{
-							src:    client,
-							dest:   serverNakedFooAlt,
+							from:   client,
+							to:     apps.ServerNakedFooAlt,
 							expect: true,
 						},
 					}
 
 					for _, tc := range cases {
-						verify(t, tc.src, tc.dest, scheme.HTTP, tc.expect)
+						verify(t, tc.from, tc.to, scheme.HTTP, tc.expect)
 					}
 				})
 			}
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index de675d7cd1..836241e106 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -27,6 +27,7 @@
 	kubeApiMeta "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -35,7 +36,7 @@
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/security/util/cert"
-	"istio.io/istio/tests/integration/security/util/connection"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 const (
@@ -105,9 +106,8 @@ func TestSecureNaming(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.peer.secure-naming").
 		Run(func(t framework.TestContext) {
-			// TODO https://github.com/istio/istio/issues/32292
 			if t.AllClusters().IsMulticluster() {
-				t.Skip()
+				t.Skip("https://github.com/istio/istio/issues/37307")
 			}
 			istioCfg := istio.DefaultConfigOrFail(t, t)
 			testNamespace := apps.Namespace
@@ -135,19 +135,14 @@ func TestSecureNaming(t *testing.T) {
 							verifyCertificatesWithPluginCA(t, out)
 
 							// Verify mTLS works between a and b
-							callOptions := echo.CallOptions{
+							opts := echo.CallOptions{
 								Target:   bSet[0],
 								PortName: "http",
 								Scheme:   scheme.HTTP,
 								Count:    callCount,
 							}
-							checker := connection.Checker{
-								From:          a,
-								Options:       callOptions,
-								ExpectSuccess: true,
-								DestClusters:  bSet.Clusters(),
-							}
-							checker.CheckOrFail(t)
+							opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
+							a.CallWithRetryOrFail(t, opts)
 						})
 
 					secureNamingTestCases := []struct {
@@ -182,22 +177,19 @@ func TestSecureNaming(t *testing.T) {
 								dr := strings.ReplaceAll(tc.destinationRule, "NS", testNamespace.Name())
 								t.ConfigIstio().YAML(dr).ApplyOrFail(t, testNamespace.Name())
 								// Verify mTLS works between a and b
-								callOptions := echo.CallOptions{
+								opts := echo.CallOptions{
 									Target:   bSet[0],
 									PortName: "http",
 									Scheme:   scheme.HTTP,
 									Count:    callCount,
 								}
-								checker := connection.Checker{
-									From:          a,
-									Options:       callOptions,
-									ExpectSuccess: tc.expectSuccess,
-									DestClusters:  bSet.Clusters(),
-								}
-								if err := retry.UntilSuccess(
-									checker.Check, retry.Delay(time.Second), retry.Timeout(15*time.Second), retry.Converge(5)); err != nil {
-									t.Fatal(err)
+								if tc.expectSuccess {
+									opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
+								} else {
+									opts.Check = scheck.NotOK()
 								}
+
+								a.CallWithRetryOrFail(t, opts)
 							})
 					}
 				})
diff --git a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
index 4fe390b9df..bdadc59e35 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
@@ -21,10 +21,11 @@
 	"fmt"
 	"testing"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/tests/integration/security/util/connection"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 const (
@@ -69,9 +70,8 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.peer.trust-domain-alias-secure-naming").
 		Run(func(t framework.TestContext) {
-			// TODO: https://github.com/istio/istio/issues/32292
 			if t.AllClusters().IsMulticluster() {
-				t.Skip()
+				t.Skip("https://github.com/istio/istio/issues/37307")
 			}
 			testNS := apps.Namespace
 
@@ -79,46 +79,44 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					verify := func(ctx framework.TestContext, src echo.Instance, dest echo.Instance, s scheme.Instance, success bool) {
+					verify := func(t framework.TestContext, from echo.Instance, to echo.Instances, s scheme.Instance, success bool) {
 						want := "success"
 						if !success {
 							want = "fail"
 						}
-						name := fmt.Sprintf("server:%s[%s]", dest.Config().Service, want)
-						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
+						name := fmt.Sprintf("server:%s[%s]", to[0].Config().Service, want)
+						t.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
-							opt := echo.CallOptions{
-								Target:   dest,
+							opts := echo.CallOptions{
+								Target:   to[0],
 								PortName: HTTPS,
-								Address:  dest.Config().Service,
+								Address:  to[0].Config().Service,
 								Scheme:   s,
 							}
-							checker := connection.Checker{
-								From:          src,
-								Options:       opt,
-								ExpectSuccess: success,
-								DestClusters:  t.Clusters(),
+							if success {
+								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
+							} else {
+								opts.Check = scheck.NotOK()
 							}
-							checker.CheckOrFail(t)
+
+							from.CallWithRetryOrFail(t, opts)
 						})
 					}
 
 					client := apps.Client.GetOrFail(t, echo.InCluster(cluster))
-					serverNakedFoo := apps.ServerNakedFoo.GetOrFail(t, echo.InCluster(cluster))
-					serverNakedBar := apps.ServerNakedBar.GetOrFail(t, echo.InCluster(cluster))
 					cases := []struct {
 						src    echo.Instance
-						dest   echo.Instance
+						dest   echo.Instances
 						expect bool
 					}{
 						{
 							src:    client,
-							dest:   serverNakedFoo,
+							dest:   apps.ServerNakedFoo,
 							expect: true,
 						},
 						{
 							src:    client,
-							dest:   serverNakedBar,
+							dest:   apps.ServerNakedBar,
 							expect: false,
 						},
 					}
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index c49c52d549..49fba5fb40 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -23,7 +23,6 @@
 	"net"
 	"os"
 	"path"
-	"strings"
 	"testing"
 	"time"
 
@@ -95,9 +94,8 @@
 func TestTrustDomainValidation(t *testing.T) {
 	framework.NewTest(t).Features("security.peer.trust-domain-validation").Run(
 		func(ctx framework.TestContext) {
-			// TODO https://github.com/istio/istio/issues/32294
 			if ctx.AllClusters().IsMulticluster() {
-				ctx.Skip()
+				ctx.Skip("https://github.com/istio/istio/issues/37307")
 			}
 
 			testNS := apps.Namespace
@@ -158,21 +156,9 @@ func(ctx framework.TestContext) {
 									resp, err = from.Call(opt)
 								}
 								if allow {
-									if err != nil {
-										return fmt.Errorf("want allow but got error: %v", err)
-									} else if err := check.OK().Check(resp, nil); err != nil {
-										return fmt.Errorf("want allow but got %v: %v", resp, err)
-									}
-								} else {
-									if err == nil {
-										return fmt.Errorf("want deny but got allow: %v", resp)
-									}
-									// Look up for the specific "tls: unknown certificate" error when trust domain validation failed.
-									if tlsErr := "tls: unknown certificate"; !strings.Contains(err.Error(), tlsErr) {
-										return fmt.Errorf("want error %q but got %v", tlsErr, err)
-									}
+									return check.OK().Check(resp, err)
 								}
-								return nil
+								return check.ErrorContains("tls: unknown certificate").Check(resp, err)
 							}, retry.Delay(250*time.Millisecond), retry.Timeout(30*time.Second), retry.Converge(5))
 						})
 					}
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index 3d83c705e1..1b3f19ab1f 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -21,13 +21,14 @@
 	"fmt"
 	"testing"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/connection"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 // TestReachability verifies:
@@ -58,19 +59,15 @@ func TestReachability(t *testing.T) {
 					t.NewSubTest("Basic reachability with external ca").
 						Run(func(t framework.TestContext) {
 							// Verify mTLS works between a and b
-							callOptions := echo.CallOptions{
+							opts := echo.CallOptions{
 								Target:   bSet[0],
 								PortName: "http",
 								Scheme:   scheme.HTTP,
 								Count:    callCount,
 							}
-							checker := connection.Checker{
-								From:          a,
-								Options:       callOptions,
-								ExpectSuccess: true,
-								DestClusters:  bSet.Clusters(),
-							}
-							checker.CheckOrFail(t)
+							opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
+
+							a.CallWithRetryOrFail(t, opts)
 						})
 				})
 			}
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index 0cc22be6af..1df4d50fef 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -18,15 +18,12 @@
 package filemountedcerts
 
 import (
-	"fmt"
-	"net/http"
-	"reflect"
-	"strconv"
 	"strings"
 	"testing"
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -56,34 +53,17 @@ func TestClientToServiceTls(t *testing.T) {
 			createObject(t, serviceNamespace.Name(), DestinationRuleConfigMutual)
 			createObject(t, "istio-system", PeerAuthenticationConfig)
 
-			retry.UntilSuccessOrFail(t, func() error {
-				resp, err := client.Call(echo.CallOptions{
-					Target:   server,
-					PortName: "http",
-					Scheme:   scheme.HTTP,
-				})
-				if err != nil {
-					return fmt.Errorf("request failed: %v", err)
-				}
-
-				codes := make([]string, 0, len(resp))
-				for _, r := range resp {
-					codes = append(codes, r.Code)
-				}
-				if !reflect.DeepEqual(codes, []string{strconv.Itoa(http.StatusOK)}) {
-					return fmt.Errorf("got codes %q, expected %q", codes, []string{strconv.Itoa(http.StatusOK)})
-				}
-				for _, r := range resp {
-					if xfcc, f := r.RequestHeaders["X-Forwarded-Client-Cert"]; f {
-						if xfcc[0] != ExpectedXfccHeader {
-							return fmt.Errorf("XFCC header's value is incorrect. Expected [%s], received [%s]", ExpectedXfccHeader, r)
-						}
-					} else {
-						return fmt.Errorf("expected to see XFCC header, but none found. response: %s", r)
-					}
-				}
-				return nil
-			}, retry.Delay(5*time.Second), retry.Timeout(1*time.Minute))
+			opts := echo.CallOptions{
+				Target:   server,
+				PortName: "http",
+				Scheme:   scheme.HTTP,
+				Check: check.And(
+					check.OK(),
+					check.RequestHeader("X-Forwarded-Client-Cert", ExpectedXfccHeader)),
+			}
+
+			client.CallWithRetryOrFail(t, opts,
+				retry.Delay(5*time.Second), retry.Timeout(1*time.Minute))
 		})
 }
 
diff --git a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
index 6721f67ea6..1aa04ee062 100644
--- a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
+++ b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
@@ -21,7 +21,6 @@
 	"os"
 	"path"
 	"testing"
-	"time"
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/echo/check"
@@ -32,7 +31,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
 	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/util/retry"
 )
 
 func mustReadFile(t framework.TestContext, f string) string {
@@ -131,19 +129,15 @@ func TestDestinationRuleTls(t *testing.T) {
 
 			for _, tt := range []string{"grpc", "http", "tcp"} {
 				t.NewSubTest(tt).Run(func(t framework.TestContext) {
-					retry.UntilSuccessOrFail(t, func() error {
-						opts := echo.CallOptions{
-							Target:   server,
-							PortName: tt,
-						}
-						if tt == "tcp" {
-							opts.Scheme = scheme.TCP
-						}
-						resp, err := client.Call(opts)
-						return check.And(
-							check.NoError(),
-							check.OK()).Check(resp, err)
-					}, retry.Delay(time.Millisecond*100))
+					opts := echo.CallOptions{
+						Target:   server,
+						PortName: tt,
+						Check:    check.OK(),
+					}
+					if tt == "tcp" {
+						opts.Scheme = scheme.TCP
+					}
+					client.CallWithRetryOrFail(t, opts)
 				})
 			}
 		})
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index 7db5c687f7..1335b1e727 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -24,8 +24,6 @@
 	"net/http"
 	"os"
 	"path"
-	"reflect"
-	"strconv"
 	"testing"
 	"time"
 
@@ -33,6 +31,8 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -127,31 +127,25 @@ func TestEgressGatewayTls(t *testing.T) {
 
 						t.ConfigIstio().YAML(bufDestinationRule.String()).ApplyOrFail(t, systemNamespace.Name())
 
-						retry.UntilSuccessOrFail(t, func() error {
-							resp, err := internalClient.Call(echo.CallOptions{
-								Target:   externalServer,
-								PortName: "http",
-								Headers: map[string][]string{
-									"Host": {host},
-								},
-							})
-							if err != nil {
-								return fmt.Errorf("request failed: %v", err)
-							}
-							codes := make([]string, 0, len(resp))
-							for _, r := range resp {
-								codes = append(codes, r.Code)
-							}
-							if !reflect.DeepEqual(codes, []string{strconv.Itoa(tc.code)}) {
-								return fmt.Errorf("got codes %q, expected %q", codes, []string{strconv.Itoa(tc.code)})
-							}
-							for _, r := range resp {
-								if _, f := r.RequestHeaders["Handled-By-Egress-Gateway"]; tc.gateway && !f {
-									return fmt.Errorf("expected to be handled by gateway. response: %s", r)
-								}
-							}
-							return nil
-						}, retry.Delay(1*time.Second), retry.Timeout(2*time.Minute))
+						opts := echo.CallOptions{
+							Target:   externalServer,
+							PortName: "http",
+							Headers: map[string][]string{
+								"Host": {host},
+							},
+							Check: check.And(
+								check.NoError(),
+								check.Status(tc.code),
+								check.Each(func(r echoClient.Response) error {
+									if _, f := r.RequestHeaders["Handled-By-Egress-Gateway"]; tc.gateway && !f {
+										return fmt.Errorf("expected to be handled by gateway. response: %s", r)
+									}
+									return nil
+								})),
+						}
+
+						internalClient.CallWithRetryOrFail(t, opts,
+							retry.Delay(1*time.Second), retry.Timeout(2*time.Minute))
 					})
 			}
 		})
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index d4fba19e53..60fcbc4be8 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -18,12 +18,12 @@
 package security
 
 import (
-	"fmt"
-	"net/http"
 	"path/filepath"
 	"strings"
 	"testing"
 
+	"istio.io/istio/pkg/http/headers"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -32,16 +32,9 @@
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/kube"
-	"istio.io/istio/pkg/test/util/file"
-	"istio.io/istio/pkg/test/util/tmpl"
-	"istio.io/istio/pkg/test/util/yml"
 	"istio.io/istio/tests/common/jwt"
 	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/authn"
-)
-
-const (
-	authHeaderKey = "Authorization"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 // TestJWTHTTPS tests the requestauth policy with https jwks server.
@@ -51,12 +44,16 @@ func TestJWTHTTPS(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.authentication.jwt").
 		Run(func(t framework.TestContext) {
+			if t.Clusters().IsMulticluster() {
+				t.Skip("https://github.com/istio/istio/issues/37307")
+			}
+
 			ns := apps.Namespace1
 			istioSystemNS := istio.ClaimSystemNamespaceOrFail(t, t)
 
-			args := map[string]string{"Namespace": istioSystemNS.Name()}
-			policyFile := filepath.Join(env.IstioSrc, "samples/jwt-server", "jwt-server.yaml")
-			t.ConfigKube().EvalFile(args, policyFile).ApplyOrFail(t, istioSystemNS.Name())
+			t.ConfigKube().EvalFile(map[string]string{
+				"Namespace": istioSystemNS.Name(),
+			}, filepath.Join(env.IstioSrc, "samples/jwt-server", "jwt-server.yaml")).ApplyOrFail(t, istioSystemNS.Name())
 
 			for _, cluster := range t.AllClusters() {
 				fetchFn := kube.NewSinglePodFetch(cluster, istioSystemNS.Name(), "app=jwt-server")
@@ -78,63 +75,57 @@ func TestJWTHTTPS(t *testing.T) {
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
 
-			t.NewSubTest("jwt-authn").Run(func(t framework.TestContext) {
-				testCase := authn.TestCase{
-					Name:   "valid-token-forward-remote-jwks",
-					Config: "remotehttps",
-					CallOpts: echo.CallOptions{
-						PortName: "http",
-						Scheme:   scheme.HTTP,
-						Headers: map[string][]string{
-							authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-						},
-						Path:  "/valid-token-forward-remote-jwks",
-						Count: callCount,
-					},
-					ExpectResponseCode: http.StatusOK,
-					ExpectHeaders: map[string]string{
-						authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
-						"X-Test-Payload": payload1,
+			cases := []struct {
+				name          string
+				policyFile    string
+				customizeCall func(to echo.Instances, opts *echo.CallOptions)
+			}{
+				{
+					name:       "valid-token-forward-remote-jwks",
+					policyFile: "./testdata/remotehttps.yaml.tmpl",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token-forward-remote-jwks"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeaders(map[string]string{
+								headers.Authorization: "Bearer " + jwt.TokenIssuer1,
+								"X-Test-Payload":      payload1,
+							}))
 					},
-					// This test does not generate cross-cluster traffic, but is flaky
-					// in multicluster test. Skip in multicluster mesh.
-					// TODO(JimmyCYJ): enable the test in multicluster mesh.
-					SkipMultiCluster: true,
-				}
+				},
+			}
 
-				if testCase.SkipMultiCluster && t.Clusters().IsMulticluster() {
-					t.Skip()
-				}
-				echotest.New(t, apps.All).
-					SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
-						if testCase.Config != "" {
-							policy := yml.MustApplyNamespace(t, tmpl.MustEvaluate(
-								file.AsStringOrFail(t, fmt.Sprintf("./testdata/%s.yaml.tmpl", testCase.Config)),
-								map[string]string{
-									"Namespace": ns.Name(),
-									"dst":       dst[0].Config().Service,
-								},
-							), ns.Name())
-							if err := t.ConfigIstio().YAML(policy).Apply(ns.Name(), resource.Wait); err != nil {
-								t.Logf("failed to apply security config %s: %v", testCase.Config, err)
-								return err
+			for _, c := range cases {
+				t.NewSubTest(c.name).Run(func(t framework.TestContext) {
+					echotest.New(t, apps.All).
+						SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
+							args := map[string]string{
+								"Namespace": ns.Name(),
+								"dst":       dst[0].Config().Service,
+							}
+							return t.ConfigIstio().EvalFile(args, c.policyFile).
+								Apply(ns.Name(), resource.Wait)
+						}).
+						From(
+							// TODO(JimmyCYJ): enable VM for all test cases.
+							util.SourceFilter(t, apps, ns.Name(), true)...).
+						ConditionallyTo(echotest.ReachableDestinations).
+						To(util.DestFilter(t, apps, ns.Name(), true)...).
+						Run(func(t framework.TestContext, from echo.Instance, to echo.Instances) {
+							opts := echo.CallOptions{
+								Target:   to[0],
+								PortName: "http",
+								Scheme:   scheme.HTTP,
+								Count:    callCount,
 							}
-						}
-						return nil
-					}).
-					From(
-						// TODO(JimmyCYJ): enable VM for all test cases.
-						util.SourceFilter(t, apps, ns.Name(), true)...).
-					ConditionallyTo(echotest.ReachableDestinations).
-					To(util.DestFilter(t, apps, ns.Name(), true)...).
-					Run(func(t framework.TestContext, src echo.Instance, dest echo.Instances) {
-						t.NewSubTest(testCase.Name).Run(func(t framework.TestContext) {
-							testCase.CallOpts.Target = dest[0]
-							testCase.DestClusters = dest.Match(echo.InCluster(src.Config().Cluster)).Clusters()
-							testCase.CallOpts.Check = testCase.CheckAuthn
-							src.CallWithRetryOrFail(t, testCase.CallOpts, echo.DefaultCallRetryOptions()...)
+
+							c.customizeCall(to, &opts)
+
+							from.CallWithRetryOrFail(t, opts)
 						})
-					})
-			})
+				})
+			}
 		})
 }
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index 8d1101c046..64e78e2901 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -18,11 +18,13 @@
 package security
 
 import (
-	"fmt"
 	"net/http"
 	"strings"
 	"testing"
 
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -30,16 +32,9 @@
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
-	"istio.io/istio/pkg/test/util/file"
-	"istio.io/istio/pkg/test/util/tmpl"
-	"istio.io/istio/pkg/test/util/yml"
 	"istio.io/istio/tests/common/jwt"
 	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/authn"
-)
-
-const (
-	authHeaderKey = "Authorization"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 // TestRequestAuthentication tests beta authn policy for jwt.
@@ -51,8 +46,9 @@ func TestRequestAuthentication(t *testing.T) {
 		Features("security.authentication.jwt").
 		Run(func(t framework.TestContext) {
 			ns := apps.Namespace1
-			args := map[string]string{"Namespace": ns.Name()}
-			t.ConfigKube().EvalFile(args, "../../../samples/jwt-server/jwt-server.yaml").ApplyOrFail(t, ns.Name())
+			t.ConfigKube().EvalFile(map[string]string{
+				"Namespace": ns.Name(),
+			}, "../../../samples/jwt-server/jwt-server.yaml").ApplyOrFail(t, ns.Name())
 
 			callCount := 1
 			if t.Clusters().IsMulticluster() {
@@ -60,403 +56,336 @@ func TestRequestAuthentication(t *testing.T) {
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
 
-			t.NewSubTest("jwt-authn").Run(func(t framework.TestContext) {
-				testCases := []authn.TestCase{
-					{
-						Name:   "valid-token-noauthz",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Path:  "/valid-token-noauthz",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
-						ExpectHeaders: map[string]string{
-							authHeaderKey:    "",
-							"X-Test-Payload": payload1,
-						},
+			type testCase struct {
+				name          string
+				customizeCall func(to echo.Instances, opts *echo.CallOptions)
+			}
+
+			newTest := func(policy string, cases []testCase) func(framework.TestContext) {
+				return func(t framework.TestContext) {
+					echotest.New(t, apps.All).
+						SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
+							if policy != "" {
+								args := map[string]string{
+									"Namespace": ns.Name(),
+									"dst":       dst[0].Config().Service,
+								}
+								return t.ConfigIstio().EvalFile(args, policy).Apply(ns.Name(), resource.Wait)
+							}
+							return nil
+						}).
+						From(
+							// TODO(JimmyCYJ): enable VM for all test cases.
+							util.SourceFilter(t, apps, ns.Name(), true)...).
+						ConditionallyTo(echotest.ReachableDestinations).
+						To(util.DestFilter(t, apps, ns.Name(), true)...).
+						Run(func(t framework.TestContext, from echo.Instance, to echo.Instances) {
+							for _, c := range cases {
+								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
+									opts := echo.CallOptions{
+										Target:   to[0],
+										PortName: "http",
+										Scheme:   scheme.HTTP,
+										Count:    callCount,
+									}
+
+									// Apply any custom options for the test.
+									c.customizeCall(to, &opts)
+
+									from.CallWithRetryOrFail(t, opts)
+								})
+							}
+						})
+				}
+			}
+
+			t.NewSubTest("authn-only").Run(newTest("testdata/requestauthn/authn-only.yaml.tmpl", []testCase{
+				{
+					name: "valid-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token-noauthz"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeaders(map[string]string{
+								headers.Authorization: "",
+								"X-Test-Payload":      payload1,
+							}))
 					},
-					{
-						Name:   "valid-token-2-noauthz",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer2},
-							},
-							Path:  "/valid-token-2-noauthz",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
-						ExpectHeaders: map[string]string{
-							authHeaderKey:    "",
-							"X-Test-Payload": payload2,
-						},
+				},
+				{
+					name: "valid-token-2-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token-2-noauthz"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeaders(map[string]string{
+								headers.Authorization: "",
+								"X-Test-Payload":      payload2,
+							}))
 					},
-					{
-						Name:   "expired-token-noauthz",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenExpired},
-							},
-							Path:  "/expired-token-noauthz",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+				{
+					name: "expired-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/expired-token-noauthz"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "expired-token-cors-preflight-request-allowed",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey:                   {"Bearer " + jwt.TokenExpired},
-								"Access-Control-Request-Method": {"POST"},
-								"Origin":                        {"https://istio.io"},
-							},
-							Method: "OPTIONS",
-							Path:   "/expired-token-cors-preflight-request-allowed",
-							Count:  callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "expired-token-cors-preflight-request-allowed",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/expired-token-cors-preflight-request-allowed"
+						opts.Method = "OPTIONS"
+						opts.Headers = headers.New().
+							WithAuthz(jwt.TokenExpired).
+							With(headers.AccessControlRequestMethod, "POST").
+							With(headers.Origin, "https://istio.io").
+							Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "expired-token-bad-cors-preflight-request-rejected",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey:                   {"Bearer " + jwt.TokenExpired},
-								"Access-Control-Request-Method": {"POST"},
-								// the required Origin header is missing.
-							},
-							Method: "OPTIONS",
-							Path:   "/expired-token-cors-preflight-request-allowed",
-							Count:  callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+				{
+					name: "expired-token-bad-cors-preflight-request-rejected",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/expired-token-cors-preflight-request-allowed"
+						opts.Method = "OPTIONS"
+						opts.Headers = headers.New().
+							WithAuthz(jwt.TokenExpired).
+							With(headers.AccessControlRequestMethod, "POST").
+							// the required Origin header is missing.
+							Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "no-token-noauthz",
-						Config: "authn-only",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/no-token-noauthz",
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "no-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/no-token-noauthz"
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					// Destination app is configured with authorization, only request with valid JWT succeed.
-					{
-						Name:   "valid-token",
-						Config: "authn-authz",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Path:  "/valid-token",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
-						ExpectHeaders: map[string]string{
-							authHeaderKey: "",
-						},
+				},
+			}))
+
+			t.NewSubTest("authn-authz").Run(newTest("testdata/requestauthn/authn-authz.yaml.tmpl", []testCase{
+				{
+					name: "valid-token",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeader(headers.Authorization, ""))
 					},
-					{
-						Name:   "expired-token",
-						Config: "authn-authz",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenExpired},
-							},
-							Path:  "/expired-token",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+				{
+					name: "expired-token",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/expired-token"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "no-token",
-						Config: "authn-authz",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/no-token",
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusForbidden,
+				},
+				{
+					name: "no-token",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/no-token"
+						opts.Check = check.Status(http.StatusForbidden)
 					},
-					{
-						Name: "no-authn-authz",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/no-authn-authz",
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+			}))
+
+			t.NewSubTest("no-authn-authz").Run(newTest("", []testCase{
+				{
+					name: "no-authn-authz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/no-authn-authz"
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "valid-token-forward",
-						Config: "forward",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Path:  "/valid-token-forward",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
-						ExpectHeaders: map[string]string{
-							authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
-							"X-Test-Payload": payload1,
-						},
+				},
+			}))
+
+			t.NewSubTest("forward").Run(newTest("testdata/requestauthn/forward.yaml.tmpl", []testCase{
+				{
+					name: "valid-token-forward",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token-forward"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeaders(map[string]string{
+								headers.Authorization: "Bearer " + jwt.TokenIssuer1,
+								"X-Test-Payload":      payload1,
+							}))
 					},
-					{
-						Name:   "valid-token-forward-remote-jwks",
-						Config: "remote",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Path:  "/valid-token-forward-remote-jwks",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
-						ExpectHeaders: map[string]string{
-							authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
-							"X-Test-Payload": payload1,
-						},
+				},
+			}))
+
+			t.NewSubTest("remote").Run(newTest("testdata/requestauthn/remote.yaml.tmpl", []testCase{
+				{
+					name: "valid-token-forward-remote-jwks",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token-forward-remote-jwks"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts),
+							check.RequestHeaders(map[string]string{
+								headers.Authorization: "Bearer " + jwt.TokenIssuer1,
+								"X-Test-Payload":      payload1,
+							}))
 					},
-					{
-						Name:   "invalid-aud",
-						Config: "aud",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Path:  "/valid-aud",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusForbidden,
+				},
+			}))
+
+			t.NewSubTest("aud").Run(newTest("testdata/requestauthn/aud.yaml.tmpl", []testCase{
+				{
+					name: "invalid-aud",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-aud"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.Status(http.StatusForbidden)
 					},
-					{
-						Name:   "valid-aud",
-						Config: "aud",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1WithAud},
-							},
-							Path:  "/valid-aud",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "valid-aud",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-aud"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1WithAud).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "verify-policies-are-combined",
-						Config: "aud",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer2},
-							},
-							Path:  "/verify-policies-are-combined",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "verify-policies-are-combined",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/verify-policies-are-combined"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "invalid-jwks-valid-token-noauthz",
-						Config: "invalid-jwks",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenIssuer1},
-							},
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+			}))
+
+			t.NewSubTest("invalid-jwks").Run(newTest("testdata/requestauthn/invalid-jwks.yaml.tmpl", []testCase{
+				{
+					name: "invalid-jwks-valid-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = ""
+						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "invalid-jwks-expired-token-noauthz",
-						Config: "invalid-jwks",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenExpired},
-							},
-							Path:  "/invalid-jwks-valid-token-noauthz",
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+				{
+					name: "invalid-jwks-expired-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/invalid-jwks-valid-token-noauthz"
+						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "invalid-jwks-no-token-noauthz",
-						Config: "invalid-jwks",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/invalid-jwks-no-token-noauthz",
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "invalid-jwks-no-token-noauthz",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/invalid-jwks-no-token-noauthz"
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "valid-params",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/valid-token?token=" + jwt.TokenIssuer1,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+			}))
+
+			t.NewSubTest("headers-params").Run(newTest("testdata/requestauthn/headers-params.yaml.tmpl", []testCase{
+				{
+					name: "valid-params",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "valid-params-secondary",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/valid-token?secondary_token=" + jwt.TokenIssuer1,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "valid-params-secondary",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token?secondary_token=" + jwt.TokenIssuer1
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "invalid-params",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/valid-token?token_value=" + jwt.TokenIssuer1,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusForbidden,
+				},
+				{
+					name: "invalid-params",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token?token_value=" + jwt.TokenIssuer1
+						opts.Check = check.Status(http.StatusForbidden)
 					},
-					{
-						Name:   "valid-token-set",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenIssuer1,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "valid-token-set",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenIssuer1
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "invalid-token-set",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Path:     "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenExpired,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+				},
+				{
+					name: "invalid-token-set",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenExpired
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name:   "valid-header",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								"X-Jwt-Token": {"Value " + jwt.TokenIssuer1},
-							},
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "valid-header",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = ""
+						opts.Headers = headers.New().
+							With("X-Jwt-Token", "Value "+jwt.TokenIssuer1).
+							Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "valid-header-secondary",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								"Auth-Token": {"Token " + jwt.TokenIssuer1},
-							},
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "valid-header-secondary",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = ""
+						opts.Headers = headers.New().
+							With("Auth-Token", "Token "+jwt.TokenIssuer1).
+							Build()
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-					{
-						Name:   "invalid-header",
-						Config: "headers-params",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								"Auth-Header-Param": {"Bearer " + jwt.TokenIssuer1},
-							},
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusForbidden,
+				},
+				{
+					name: "invalid-header",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Path = ""
+						opts.Headers = headers.New().
+							With("Auth-Header-Param", "Bearer "+jwt.TokenIssuer1).
+							Build()
+						opts.Check = check.Status(http.StatusForbidden)
 					},
-				}
-				for _, c := range testCases {
-					if c.SkipMultiCluster && t.Clusters().IsMulticluster() {
-						t.Skip()
-					}
-					echotest.New(t, apps.All).
-						SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
-							if c.Config != "" {
-								policy := yml.MustApplyNamespace(t, tmpl.MustEvaluate(
-									file.AsStringOrFail(t, fmt.Sprintf("testdata/requestauthn/%s.yaml.tmpl", c.Config)),
-									map[string]string{
-										"Namespace": ns.Name(),
-										"dst":       dst[0].Config().Service,
-									},
-								), ns.Name())
-								if err := t.ConfigIstio().YAML(policy).Apply(ns.Name(), resource.Wait); err != nil {
-									t.Logf("failed to apply security config %s: %v", c.Config, err)
-									return err
-								}
-							}
-							return nil
-						}).
-						From(
-							// TODO(JimmyCYJ): enable VM for all test cases.
-							util.SourceFilter(t, apps, ns.Name(), true)...).
-						ConditionallyTo(echotest.ReachableDestinations).
-						To(util.DestFilter(t, apps, ns.Name(), true)...).
-						Run(func(t framework.TestContext, src echo.Instance, dest echo.Instances) {
-							t.NewSubTest(c.Name).Run(func(t framework.TestContext) {
-								c.CallOpts.Target = dest[0]
-								c.DestClusters = dest.Match(echo.InCluster(src.Config().Cluster)).Clusters()
-								c.CallOpts.Check = c.CheckAuthn
-								src.CallWithRetryOrFail(t, c.CallOpts, echo.DefaultCallRetryOptions()...)
-							})
-						})
-				}
-			})
+				},
+			}))
 		})
 }
 
@@ -470,12 +399,10 @@ func TestIngressRequestAuthentication(t *testing.T) {
 			ns := apps.Namespace1
 
 			// Apply the policy.
-			args := map[string]string{
+			t.ConfigIstio().EvalFile(map[string]string{
 				"Namespace":     ns.Name(),
 				"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
-			}
-			t.ConfigIstio().EvalFile(args, "testdata/requestauthn/global-jwt.yaml.tmpl").
-				ApplyOrFail(t, newRootNS(t).Name(), resource.Wait)
+			}, "testdata/requestauthn/global-jwt.yaml.tmpl").ApplyOrFail(t, newRootNS(t).Name(), resource.Wait)
 
 			callCount := 1
 			if t.Clusters().IsMulticluster() {
@@ -483,149 +410,190 @@ func TestIngressRequestAuthentication(t *testing.T) {
 				callCount = util.CallsPerCluster * len(t.Clusters())
 			}
 
-			t.NewSubTest("in-mesh-authn").Run(func(t framework.TestContext) {
-				// These test cases verify in-mesh traffic doesn't need tokens.
-				testCases := []authn.TestCase{
-					{
-						Name: "in-mesh-with-expired-token",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Headers: map[string][]string{
-								authHeaderKey: {"Bearer " + jwt.TokenExpired},
-							},
-							Count: callCount,
-						},
-						ExpectResponseCode: http.StatusUnauthorized,
+			type testCase struct {
+				name          string
+				customizeCall func(to echo.Instances, opts *echo.CallOptions)
+			}
+
+			newTest := func(policy string, cases []testCase) func(framework.TestContext) {
+				return func(t framework.TestContext) {
+					echotest.New(t, apps.All).
+						SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
+							if policy != "" {
+								args := map[string]string{
+									"Namespace": ns.Name(),
+									"dst":       dst[0].Config().Service,
+								}
+								return t.ConfigIstio().EvalFile(args, policy).Apply(ns.Name(), resource.Wait)
+							}
+							return nil
+						}).
+						From(util.SourceFilter(t, apps, ns.Name(), false)...).
+						ConditionallyTo(echotest.ReachableDestinations).
+						ConditionallyTo(func(from echo.Instance, to echo.Instances) echo.Instances {
+							return to.Match(echo.InCluster(from.Config().Cluster))
+						}).
+						To(util.DestFilter(t, apps, ns.Name(), false)...).
+						Run(func(t framework.TestContext, from echo.Instance, to echo.Instances) {
+							for _, c := range cases {
+								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
+									opts := echo.CallOptions{
+										Target:   to[0],
+										PortName: "http",
+										Scheme:   scheme.HTTP,
+										Count:    callCount,
+									}
+
+									// Apply any custom options for the test.
+									c.customizeCall(to, &opts)
+
+									from.CallWithRetryOrFail(t, opts)
+								})
+							}
+						})
+				}
+			}
+
+			t.NewSubTest("in-mesh-authn").Run(newTest("testdata/requestauthn/ingress.yaml.tmpl", []testCase{
+				{
+					name: "in-mesh-with-expired-token",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.Check = check.Status(http.StatusUnauthorized)
 					},
-					{
-						Name: "in-mesh-without-token",
-						CallOpts: echo.CallOptions{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
-							Count:    callCount,
-						},
-						ExpectResponseCode: http.StatusOK,
+				},
+				{
+					name: "in-mesh-without-token",
+					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
+						opts.Check = check.And(
+							check.OK(),
+							scheck.ReachedClusters(to, opts))
 					},
-				}
-				echotest.New(t, apps.All).
-					SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
-						policy := yml.MustApplyNamespace(t, tmpl.MustEvaluate(
-							file.AsStringOrFail(t, "testdata/requestauthn/ingress.yaml.tmpl"),
-							map[string]string{
-								"Namespace": ns.Name(),
-								"dst":       dst[0].Config().Service,
-							},
-						), ns.Name())
-						if err := t.ConfigIstio().YAML(policy).Apply(ns.Name(), resource.Wait); err != nil {
-							t.Logf("failed to deploy ingress: %v", err)
-							return err
-						}
-						return nil
-					}).
-					From(util.SourceFilter(t, apps, ns.Name(), false)...).
-					ConditionallyTo(echotest.ReachableDestinations).
-					ConditionallyTo(func(from echo.Instance, to echo.Instances) echo.Instances {
-						return to.Match(echo.InCluster(from.Config().Cluster))
-					}).
-					To(util.DestFilter(t, apps, ns.Name(), false)...).
-					Run(func(t framework.TestContext, src echo.Instance, dest echo.Instances) {
-						for _, c := range testCases {
-							t.NewSubTest(c.Name).Run(func(t framework.TestContext) {
-								c.CallOpts.Target = dest[0]
-								c.DestClusters = dest.Clusters()
-								c.CallOpts.Check = c.CheckAuthn
-								src.CallWithRetryOrFail(t, c.CallOpts, echo.DefaultCallRetryOptions()...)
-							})
-						}
-					})
-			})
+				},
+			}))
 
-			// TODO(JimmyCYJ): add workload-agnostic test pattern to support ingress gateway tests.
-			policy := yml.MustApplyNamespace(t, tmpl.MustEvaluate(
-				file.AsStringOrFail(t, "testdata/requestauthn/ingress.yaml.tmpl"),
-				map[string]string{
+			t.NewSubTest("ingress-authn").Run(func(t framework.TestContext) {
+				// TODO(JimmyCYJ): add workload-agnostic test pattern to support ingress gateway tests.
+				t.ConfigIstio().EvalFile(map[string]string{
 					"Namespace": ns.Name(),
 					"dst":       util.BSvc,
-				},
-			), ns.Name())
-			t.ConfigIstio().YAML(policy).ApplyOrFail(t, ns.Name())
-			t.NewSubTest("ingress-authn").Run(func(t framework.TestContext) {
+				}, "testdata/requestauthn/ingress.yaml.tmpl").ApplyOrFail(t, ns.Name())
+
 				for _, cluster := range t.Clusters() {
 					ingr := ist.IngressFor(cluster)
+
 					// These test cases verify requests go through ingress will be checked for validate token.
 					ingTestCases := []struct {
-						Name               string
-						Host               string
-						Path               string
-						Token              string
-						ExpectResponseCode int
+						name          string
+						customizeCall func(opts *echo.CallOptions)
 					}{
 						{
-							Name:               "deny without token",
-							Host:               "example.com",
-							Path:               "/",
-							ExpectResponseCode: http.StatusForbidden,
+							name: "deny without token",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().WithHost("example.com").Build()
+								opts.Check = check.Status(http.StatusForbidden)
+							},
 						},
 						{
-							Name:               "allow with sub-1 token",
-							Host:               "example.com",
-							Path:               "/",
-							Token:              jwt.TokenIssuer1,
-							ExpectResponseCode: http.StatusOK,
+							name: "allow with sub-1 token",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("example.com").
+									WithAuthz(jwt.TokenIssuer1).
+									Build()
+								opts.Check = check.OK()
+							},
 						},
 						{
-							Name:               "deny with sub-2 token",
-							Host:               "example.com",
-							Path:               "/",
-							Token:              jwt.TokenIssuer2,
-							ExpectResponseCode: http.StatusForbidden,
+							name: "deny with sub-2 token",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("example.com").
+									WithAuthz(jwt.TokenIssuer2).
+									Build()
+								opts.Check = check.Status(http.StatusForbidden)
+							},
 						},
 						{
-							Name:               "deny with expired token",
-							Host:               "example.com",
-							Path:               "/",
-							Token:              jwt.TokenExpired,
-							ExpectResponseCode: http.StatusUnauthorized,
+							name: "deny with expired token",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("example.com").
+									WithAuthz(jwt.TokenExpired).
+									Build()
+								opts.Check = check.Status(http.StatusUnauthorized)
+							},
 						},
 						{
-							Name:               "allow with sub-1 token on any.com",
-							Host:               "any-request-principlal-ok.com",
-							Path:               "/",
-							Token:              jwt.TokenIssuer1,
-							ExpectResponseCode: http.StatusOK,
+							name: "allow with sub-1 token on any.com",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("any-request-principlal-ok.com").
+									WithAuthz(jwt.TokenIssuer1).
+									Build()
+								opts.Check = check.OK()
+							},
 						},
 						{
-							Name:               "allow with sub-2 token on any.com",
-							Host:               "any-request-principlal-ok.com",
-							Path:               "/",
-							Token:              jwt.TokenIssuer2,
-							ExpectResponseCode: http.StatusOK,
+							name: "allow with sub-2 token on any.com",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("any-request-principlal-ok.com").
+									WithAuthz(jwt.TokenIssuer2).
+									Build()
+								opts.Check = check.OK()
+							},
 						},
 						{
-							Name:               "deny without token on any.com",
-							Host:               "any-request-principlal-ok.com",
-							Path:               "/",
-							ExpectResponseCode: http.StatusForbidden,
+							name: "deny without token on any.com",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("any-request-principlal-ok.com").
+									Build()
+								opts.Check = check.Status(http.StatusForbidden)
+							},
 						},
 						{
-							Name:               "deny with token on other host",
-							Host:               "other-host.com",
-							Path:               "/",
-							Token:              jwt.TokenIssuer1,
-							ExpectResponseCode: http.StatusForbidden,
+							name: "deny with token on other host",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/"
+								opts.Headers = headers.New().
+									WithHost("other-host.com").
+									WithAuthz(jwt.TokenIssuer1).
+									Build()
+								opts.Check = check.Status(http.StatusForbidden)
+							},
 						},
 						{
-							Name:               "allow healthz",
-							Host:               "example.com",
-							Path:               "/healthz",
-							ExpectResponseCode: http.StatusOK,
+							name: "allow healthz",
+							customizeCall: func(opts *echo.CallOptions) {
+								opts.Path = "/healthz"
+								opts.Headers = headers.New().
+									WithHost("example.com").
+									Build()
+								opts.Check = check.OK()
+							},
 						},
 					}
 
 					for _, c := range ingTestCases {
-						t.NewSubTest(c.Name).Run(func(t framework.TestContext) {
-							authn.CheckIngressOrFail(t, ingr, c.Host, c.Path, nil, c.Token, c.ExpectResponseCode)
+						t.NewSubTest(c.name).Run(func(t framework.TestContext) {
+							opts := echo.CallOptions{
+								Port: &echo.Port{
+									Protocol: protocol.HTTP,
+								},
+							}
+
+							c.customizeCall(&opts)
+
+							ingr.CallWithRetryOrFail(t, opts)
 						})
 					}
 				}
diff --git a/tests/integration/security/util/authn/authn_util.go b/tests/integration/security/util/authn/authn_util.go
deleted file mode 100644
index 297934a368..0000000000
--- a/tests/integration/security/util/authn/authn_util.go
+++ /dev/null
@@ -1,89 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package authn
-
-import (
-	"fmt"
-	"net/http"
-
-	"istio.io/istio/pkg/config/protocol"
-	echoclient "istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/istio/ingress"
-)
-
-type TestCase struct {
-	Name               string
-	Config             string
-	ExpectResponseCode int
-	// Use empty value to express the header with such key must not exist.
-	ExpectHeaders    map[string]string
-	CallOpts         echo.CallOptions
-	DestClusters     cluster.Clusters
-	SkipMultiCluster bool
-}
-
-func (c *TestCase) String() string {
-	return fmt.Sprintf("requests to %s%s expected code %d, headers %v",
-		c.CallOpts.Target.Config().Service,
-		c.CallOpts.Path,
-		c.ExpectResponseCode,
-		c.ExpectHeaders)
-}
-
-// CheckAuthn checks a request based on ExpectResponseCode.
-func (c *TestCase) CheckAuthn(responses echoclient.Responses, err error) error {
-	return check.And(
-		check.Status(c.ExpectResponseCode),
-		check.RequestHeaders(c.ExpectHeaders),
-		check.Each(func(r echoclient.Response) error {
-			if c.ExpectResponseCode == http.StatusOK && c.DestClusters.IsMulticluster() {
-				return check.ReachedClusters(c.DestClusters).Check(responses, nil)
-			}
-			return nil
-		})).Check(responses, err)
-}
-
-// CheckIngressOrFail checks a request for the ingress gateway.
-func CheckIngressOrFail(ctx framework.TestContext, ingr ingress.Instance, host string, path string,
-	headers map[string][]string, token string, expectResponseCode int) {
-	if headers == nil {
-		headers = map[string][]string{
-			"Host": {host},
-		}
-	} else {
-		headers["Host"] = []string{host}
-	}
-	opts := echo.CallOptions{
-		Port: &echo.Port{
-			Protocol: protocol.HTTP,
-		},
-		Path:    path,
-		Headers: headers,
-		Check:   check.Status(expectResponseCode),
-	}
-	if len(token) != 0 {
-		opts.Headers["Authorization"] = []string{
-			fmt.Sprintf("Bearer %s", token),
-		}
-	}
-	ingr.CallWithRetryOrFail(ctx, opts)
-}
diff --git a/tests/integration/security/util/connection/checker.go b/tests/integration/security/util/connection/checker.go
deleted file mode 100644
index ee81a32356..0000000000
--- a/tests/integration/security/util/connection/checker.go
+++ /dev/null
@@ -1,82 +0,0 @@
-//go:build integ
-// +build integ
-
-//  Copyright Istio Authors
-//
-//  Licensed under the Apache License, Version 2.0 (the "License");
-//  you may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-
-package connection
-
-import (
-	"fmt"
-
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
-	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/util/retry"
-)
-
-// Checker is a test utility for testing the network connectivity between two endpoints.
-type Checker struct {
-	From          echo.Instance
-	DestClusters  cluster.Clusters
-	Options       echo.CallOptions
-	ExpectSuccess bool
-	ExpectMTLS    bool
-}
-
-// Check whether the target endpoint is reachable from the source.
-func (c *Checker) Check() error {
-	results, err := c.From.Call(c.Options)
-	if c.ExpectSuccess {
-		if err == nil {
-			err = check.OK().Check(results, err)
-		}
-		if err != nil {
-			return fmt.Errorf("%s to %s:%s using %s: expected success but failed: %v",
-				c.From.Config().Service, c.Options.Target.Config().Service, c.Options.PortName, c.Options.Scheme, err)
-		}
-		// TODO: check why grpc can not reach all clusters
-		// headless will have inconsistent loadbalancing, so we don't check clusters
-		if c.DestClusters.IsMulticluster() && c.Options.Scheme != scheme.GRPC && c.Options.Count > 1 && !c.Options.Target.Config().IsHeadless() {
-			err = check.ReachedClusters(c.DestClusters).Check(results, nil)
-			if err != nil {
-				return err
-			}
-		}
-		if c.ExpectMTLS {
-			err := check.MTLSForHTTP().Check(results, nil)
-			gotMtls := err == nil
-			if gotMtls != c.ExpectMTLS {
-				return fmt.Errorf("%s to %s:%s using %s: expected mtls=%v, got mtls=%v",
-					c.From.Config().Service, c.Options.Target.Config().Service, c.Options.PortName, c.Options.Scheme, c.ExpectMTLS, gotMtls)
-			}
-		}
-		return nil
-	}
-
-	// Expect failure...
-	if err == nil && check.OK().Check(results, nil) == nil {
-		return fmt.Errorf("%s to %s:%s using %s: expected failed, actually success",
-			c.From.Config().Service, c.Options.Target.Config().Service, c.Options.PortName, c.Options.Scheme)
-	}
-	return nil
-}
-
-func (c *Checker) CheckOrFail(t test.Failer) {
-	if err := retry.UntilSuccess(c.Check, echo.DefaultCallRetryOptions()...); err != nil {
-		t.Fatal(err)
-	}
-}
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index faa298e455..e23356618f 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -23,6 +23,7 @@
 	"strings"
 	"time"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -30,7 +31,7 @@
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/connection"
+	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
 // TestCase represents reachability test cases.
@@ -48,9 +49,6 @@ type TestCase struct {
 	// Indicates whether a test should be created for the given configuration.
 	Include func(src echo.Instance, opts echo.CallOptions) bool
 
-	// Handler called when the given test is being run.
-	OnRun func(t framework.TestContext, src echo.Instance, opts echo.CallOptions)
-
 	// Indicates whether the test should expect a successful response.
 	ExpectSuccess func(src echo.Instance, opts echo.CallOptions) bool
 
@@ -136,19 +134,11 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 							}
 							// grabbing the 0th assumes all echos in destinations have the same service name
 							destination := destinations[0]
-							// TODO: fix Multiversion related test in multicluster
-							if t.Clusters().IsMulticluster() && apps.Multiversion.Contains(destination) {
-								continue
-							}
-							if (apps.IsNaked(client)) && len(destClusters) > 1 {
-								// TODO use echotest to generate the cases that would work for multi-network + naked
-								t.SkipNow()
-								continue
-							}
 							if isNakedToVM(apps, client, destination) {
 								// No need to waste time on these tests which will time out on connection instead of fail-fast
 								continue
 							}
+
 							callCount := 1
 							if len(destClusters) > 1 {
 								// so we can validate all clusters are hit
@@ -165,23 +155,33 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 								src := client
 								dest := destination
 								opts := opts
-								onPreRun := c.OnRun
 
 								// Set the target on the call options.
 								opts.Target = dest
 								opts.Count = callCount
 
+								expectSuccess := c.ExpectSuccess(src, opts)
+								expectMTLS := c.ExpectMTLS(src, opts)
+								var tpe string
+								if expectSuccess {
+									tpe = "positive"
+									opts.Check = check.And(
+										check.OK(),
+										scheck.ReachedClusters(destinations, &opts))
+									if expectMTLS {
+										opts.Check = check.And(opts.Check,
+											check.MTLSForHTTP())
+									}
+								} else {
+									tpe = "negative"
+									opts.Check = scheck.NotOK()
+								}
+
 								include := c.Include
 								if include == nil {
 									include = func(_ echo.Instance, _ echo.CallOptions) bool { return true }
 								}
 								if include(src, opts) {
-									expectSuccess := c.ExpectSuccess(src, opts)
-									expectMTLS := c.ExpectMTLS(src, opts)
-									tpe := "positive"
-									if !expectSuccess {
-										tpe = "negative"
-									}
 									subTestName := fmt.Sprintf("%s to %s:%s%s %s",
 										opts.Scheme,
 										dest.Config().Service,
@@ -191,18 +191,16 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 
 									t.NewSubTest(subTestName).
 										RunParallel(func(t framework.TestContext) {
-											if onPreRun != nil {
-												onPreRun(t, src, opts)
+											// TODO: fix Multiversion related test in multicluster
+											if t.Clusters().IsMulticluster() && apps.Multiversion.Contains(destination) {
+												t.Skip("https://github.com/istio/istio/issues/37307")
 											}
-
-											checker := connection.Checker{
-												From:          src,
-												DestClusters:  destClusters,
-												Options:       opts,
-												ExpectSuccess: expectSuccess,
-												ExpectMTLS:    expectMTLS,
+											if (apps.IsNaked(client)) && len(destClusters) > 1 {
+												// TODO use echotest to generate the cases that would work for multi-network + naked
+												t.Skip("https://github.com/istio/istio/issues/37307")
 											}
-											checker.CheckOrFail(t)
+
+											src.CallWithRetryOrFail(t, opts)
 										})
 								}
 							}
diff --git a/tests/integration/security/util/scheck/checkers.go b/tests/integration/security/util/scheck/checkers.go
index d74dd7b8b0..7921559136 100644
--- a/tests/integration/security/util/scheck/checkers.go
+++ b/tests/integration/security/util/scheck/checkers.go
@@ -18,9 +18,11 @@
 package scheck
 
 import (
+	"errors"
 	"fmt"
 	"net/http"
 	"sort"
+	"strconv"
 	"strings"
 
 	echoClient "istio.io/istio/pkg/test/echo"
@@ -29,6 +31,16 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 )
 
+func NotOK() check.Checker {
+	strCode := strconv.Itoa(http.StatusOK)
+	return check.Or(check.Error(), check.Each(func(r echoClient.Response) error {
+		if r.Code == strCode {
+			return errors.New("response status code was 100 (OK), but expected failure")
+		}
+		return nil
+	}))
+}
+
 func ReachedClusters(to echo.Instances, opts *echo.CallOptions) check.Checker {
 	// TODO(https://github.com/istio/istio/issues/37307): Investigate why we don't reach all clusters.
 	if to.Clusters().IsMulticluster() && opts.Count > 1 && opts.Scheme != scheme.GRPC && !opts.Target.Config().IsHeadless() {
-- 
2.35.3

