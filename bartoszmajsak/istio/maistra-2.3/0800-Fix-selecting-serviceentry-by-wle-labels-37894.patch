From a12209407d60b2d4387eac09636f35868df72087 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Tue, 15 Mar 2022 15:29:40 +0800
Subject: Fix selecting serviceentry by wle labels (#37894)

---
 .../serviceentry/conversion.go                | 12 ++------
 .../serviceentry/servicediscovery.go          | 28 +++++++++++++++++--
 2 files changed, 27 insertions(+), 13 deletions(-)

diff --git a/pilot/pkg/serviceregistry/serviceentry/conversion.go b/pilot/pkg/serviceregistry/serviceentry/conversion.go
index 539b5b44a0..9ad7108626 100644
--- a/pilot/pkg/serviceregistry/serviceentry/conversion.go
+++ b/pilot/pkg/serviceregistry/serviceentry/conversion.go
@@ -376,15 +376,7 @@ func convertWorkloadInstanceToServiceInstance(workloadInstance *model.IstioEndpo
 // Convenience function to convert a workloadEntry into a WorkloadInstance object encoding the endpoint (without service
 // port names) and the namespace - k8s will consume this workload instance when selecting workload entries
 func (s *ServiceEntryStore) convertWorkloadEntryToWorkloadInstance(cfg config.Config, clusterID cluster.ID) *model.WorkloadInstance {
-	we := cfg.Spec.(*networking.WorkloadEntry)
-	// we will merge labels from metadata with spec, with precedence to the metadata
-	labels := map[string]string{}
-	for k, v := range we.Labels {
-		labels[k] = v
-	}
-	for k, v := range cfg.Labels {
-		labels[k] = v
-	}
+	we := convertWorkloadEntry(cfg)
 	addr := we.GetAddress()
 	dnsServiceEntryOnly := false
 	if strings.HasPrefix(addr, model.UnixAddressPrefix) {
@@ -401,7 +393,7 @@ func (s *ServiceEntryStore) convertWorkloadEntryToWorkloadInstance(cfg config.Co
 		sa = spiffe.MustGenSpiffeURI(cfg.Namespace, we.ServiceAccount)
 	}
 	networkID := s.workloadEntryNetwork(we)
-	labels = labelutil.AugmentLabels(labels, clusterID, we.Locality, networkID)
+	labels := labelutil.AugmentLabels(we.Labels, clusterID, we.Locality, networkID)
 	return &model.WorkloadInstance{
 		Endpoint: &model.IstioEndpoint{
 			Address: addr,
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
index 16acf1f9cd..b93eed32fc 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
@@ -159,14 +159,36 @@ func NewServiceDiscovery(
 	return s
 }
 
+// convertWorkloadEntry convert wle from Config.Spec and populate the metadata labels into it.
+func convertWorkloadEntry(cfg config.Config) *networking.WorkloadEntry {
+	wle := cfg.Spec.(*networking.WorkloadEntry)
+	if wle == nil {
+		return nil
+	}
+
+	labels := make(map[string]string, len(wle.Labels)+len(cfg.Labels))
+	for k, v := range wle.Labels {
+		labels[k] = v
+	}
+	// we will merge labels from metadata with spec, with precedence to the metadata
+	for k, v := range cfg.Labels {
+		labels[k] = v
+	}
+	// shallow copy
+	copied := *wle
+	copied.Labels = labels
+	return &copied
+}
+
 // workloadEntryHandler defines the handler for workload entries
 func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event model.Event) {
 	log.Debugf("Handle event %s for workload entry %s/%s", event, curr.Namespace, curr.Name)
 	var oldWle *networking.WorkloadEntry
 	if old.Spec != nil {
-		oldWle = old.Spec.(*networking.WorkloadEntry)
+		oldWle = convertWorkloadEntry(old)
 	}
-	wle := curr.Spec.(*networking.WorkloadEntry)
+	wle := convertWorkloadEntry(curr)
+	curr.Spec = wle
 	key := configKey{
 		kind:      workloadEntryConfigType,
 		name:      curr.Name,
@@ -208,7 +230,7 @@ func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event
 	currSes := getWorkloadServiceEntries(cfgs, wle)
 	var oldSes map[types.NamespacedName]*config.Config
 	if oldWle != nil {
-		if labels.Instance(oldWle.Labels).Equals(wle.Labels) {
+		if labels.Instance(oldWle.Labels).Equals(curr.Labels) {
 			oldSes = currSes
 		} else {
 			oldSes = getWorkloadServiceEntries(cfgs, oldWle)
-- 
2.35.3

