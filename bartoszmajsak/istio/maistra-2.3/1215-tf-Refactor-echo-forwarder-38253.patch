From 6dadecee1c459efb19a8ba22a0da9b6dbbfd2e54 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Tue, 10 May 2022 11:09:08 -0700
Subject: [tf] Refactor echo forwarder (#38253)

A number of improvements for better overall performance and code cleanup.

Connection pooling now better supported for grpc and http.]
---
 pkg/test/echo/cmd/client/main.go              |  88 ++---
 pkg/test/echo/fields.go                       |  70 +++-
 pkg/test/echo/proto/echo.pb.go                |  58 +++-
 pkg/test/echo/proto/echo.proto                |   6 +
 pkg/test/echo/server/endpoint/grpc.go         |  52 ++-
 pkg/test/echo/server/endpoint/http.go         |  26 +-
 pkg/test/echo/server/endpoint/util.go         |  12 -
 pkg/test/echo/server/forwarder/config.go      |  99 +++++-
 pkg/test/echo/server/forwarder/dns.go         |  39 ++-
 pkg/test/echo/server/forwarder/executor.go    |  88 +++++
 pkg/test/echo/server/forwarder/grpc.go        | 125 ++++---
 pkg/test/echo/server/forwarder/http.go        | 308 ++++++++++--------
 pkg/test/echo/server/forwarder/instance.go    | 170 +++-------
 pkg/test/echo/server/forwarder/protocol.go    |  41 +--
 pkg/test/echo/server/forwarder/tcp.go         |  60 ++--
 pkg/test/echo/server/forwarder/tls.go         |  61 ++--
 pkg/test/echo/server/forwarder/util.go        | 105 +++++-
 pkg/test/echo/server/forwarder/websocket.go   |  56 ++--
 pkg/test/echo/server/forwarder/xds.go         |  73 +++--
 .../framework/components/echo/calloptions.go  |  39 +++
 .../framework/components/echo/common/call.go  |  72 ++--
 .../components/echo/kube/instance.go          |  10 +-
 .../components/echo/kube/workload.go          |   7 +-
 .../framework/components/istio/ingress.go     |  10 +-
 .../framework/components/istio/operator.go    |   6 +-
 25 files changed, 1028 insertions(+), 653 deletions(-)
 create mode 100644 pkg/test/echo/server/forwarder/executor.go

diff --git a/pkg/test/echo/cmd/client/main.go b/pkg/test/echo/cmd/client/main.go
index 5ff2b9c102..29cf0d8d6c 100644
--- a/pkg/test/echo/cmd/client/main.go
+++ b/pkg/test/echo/cmd/client/main.go
@@ -38,24 +38,26 @@
 )
 
 var (
-	count              int
-	timeout            time.Duration
-	qps                int
-	uds                string
-	headers            []string
-	msg                string
-	expect             string
-	expectSet          bool
-	method             string
-	http2              bool
-	http3              bool
-	insecureSkipVerify bool
-	alpn               []string
-	serverName         string
-	serverFirst        bool
-	followRedirects    bool
-	clientCert         string
-	clientKey          string
+	count                   int
+	timeout                 time.Duration
+	qps                     int
+	uds                     string
+	headers                 []string
+	msg                     string
+	expect                  string
+	expectSet               bool
+	method                  string
+	http2                   bool
+	http3                   bool
+	insecureSkipVerify      bool
+	alpn                    []string
+	serverName              string
+	serverFirst             bool
+	followRedirects         bool
+	newConnectionPerRequest bool
+	forceDNSLookup          bool
+	clientCert              string
+	clientKey               string
 
 	caFile string
 
@@ -82,20 +84,16 @@
 			}
 
 			// Create a forwarder.
-			f, err := forwarder.New(forwarder.Config{
-				Request: request,
-				UDS:     uds,
-			})
-			if err != nil {
-				log.Fatalf("Failed to create forwarder: %v", err) // nolint: revive
-				os.Exit(-1)
-			}
-
-			// Run the forwarder.
+			f := forwarder.New()
 			defer func() {
 				_ = f.Close()
 			}()
-			response, err := f.Run(context.Background())
+
+			// Forward the requests.
+			response, err := f.ForwardEcho(context.Background(), &forwarder.Config{
+				Request: request,
+				UDS:     uds,
+			})
 			if err != nil {
 				log.Fatalf("Error %s\n", err) // nolint: revive
 				os.Exit(-1)
@@ -142,6 +140,12 @@ func init() {
 		"Treat as a server first protocol; do not send request until magic string is received")
 	rootCmd.PersistentFlags().BoolVarP(&followRedirects, "follow-redirects", "L", false,
 		"If enabled, will follow 3xx redirects with the Location header")
+	rootCmd.PersistentFlags().BoolVar(&newConnectionPerRequest, "new-connection-per-request", false,
+		"If enabled, a new connection will be made to the server for each individual request. "+
+			"If false, an attempt will be made to re-use the connection for the life of the forward request. "+
+			"This is automatically set for DNS, TCP, TLS, and WebSocket protocols.")
+	rootCmd.PersistentFlags().BoolVar(&forceDNSLookup, "force-dns-lookup", false,
+		"If enabled, each request will force a DNS lookup. Only applies if new-connection-per-request is also enabled.")
 	rootCmd.PersistentFlags().StringVar(&clientCert, "client-cert", "", "client certificate file to use for request")
 	rootCmd.PersistentFlags().StringVar(&clientKey, "client-key", "", "client certificate key file to use for request")
 	rootCmd.PersistentFlags().StringSliceVarP(&alpn, "alpn", "", nil, "alpn to set")
@@ -166,18 +170,20 @@ func defaultScheme(u string) string {
 
 func getRequest(url string) (*proto.ForwardEchoRequest, error) {
 	request := &proto.ForwardEchoRequest{
-		Url:                defaultScheme(url),
-		TimeoutMicros:      common.DurationToMicros(timeout),
-		Count:              int32(count),
-		Qps:                int32(qps),
-		Message:            msg,
-		Http2:              http2,
-		Http3:              http3,
-		ServerFirst:        serverFirst,
-		FollowRedirects:    followRedirects,
-		Method:             method,
-		ServerName:         serverName,
-		InsecureSkipVerify: insecureSkipVerify,
+		Url:                     defaultScheme(url),
+		TimeoutMicros:           common.DurationToMicros(timeout),
+		Count:                   int32(count),
+		Qps:                     int32(qps),
+		Message:                 msg,
+		Http2:                   http2,
+		Http3:                   http3,
+		ServerFirst:             serverFirst,
+		FollowRedirects:         followRedirects,
+		Method:                  method,
+		ServerName:              serverName,
+		InsecureSkipVerify:      insecureSkipVerify,
+		NewConnectionPerRequest: newConnectionPerRequest,
+		ForceDNSLookup:          forceDNSLookup,
 	}
 
 	if expectSet {
diff --git a/pkg/test/echo/fields.go b/pkg/test/echo/fields.go
index 3b31f69b13..692c578a15 100644
--- a/pkg/test/echo/fields.go
+++ b/pkg/test/echo/fields.go
@@ -14,6 +14,11 @@
 
 package echo
 
+import (
+	"fmt"
+	"io"
+)
+
 // Field is a list of fields returned in responses from the Echo server.
 type Field string
 
@@ -21,20 +26,55 @@ func (f Field) String() string {
 	return string(f)
 }
 
+func (f Field) Write(out io.StringWriter, value string) {
+	_, _ = out.WriteString(fmt.Sprintf("%s=%s\n", f, value))
+}
+
+func (f Field) WriteKeyValue(out io.StringWriter, key, value string) {
+	f.Write(out, key+":"+value)
+}
+
+func (f Field) WriteForRequest(out io.StringWriter, requestID int, value string) {
+	_, _ = out.WriteString(fmt.Sprintf("[%d] %s=%s\n", requestID, f, value))
+}
+
+func (f Field) WriteKeyValueForRequest(out io.StringWriter, requestID int, key, value string) {
+	f.WriteForRequest(out, requestID, key+":"+value)
+}
+
+func WriteBodyLine(out io.StringWriter, requestID int, line string) {
+	_, _ = out.WriteString(fmt.Sprintf("[%d body] %s\n", requestID, line))
+}
+
+func WriteError(out io.StringWriter, requestID int, err error) {
+	_, _ = out.WriteString(fmt.Sprintf("[%d error] %v\n", requestID, err))
+}
+
 const (
-	RequestIDField      Field = "X-Request-Id"
-	ServiceVersionField Field = "ServiceVersion"
-	ServicePortField    Field = "ServicePort"
-	StatusCodeField     Field = "StatusCode"
-	URLField            Field = "URL"
-	HostField           Field = "Host"
-	HostnameField       Field = "Hostname"
-	MethodField         Field = "Method"
-	ProtocolField       Field = "Proto"
-	AlpnField           Field = "Alpn"
-	RequestHeaderField  Field = "RequestHeader"
-	ResponseHeaderField Field = "ResponseHeader"
-	ClusterField        Field = "Cluster"
-	IstioVersionField   Field = "IstioVersion"
-	IPField             Field = "IP" // The Requester’s IP Address.
+	RequestIDField        Field = "X-Request-Id"
+	ServiceVersionField   Field = "ServiceVersion"
+	ServicePortField      Field = "ServicePort"
+	StatusCodeField       Field = "StatusCode"
+	URLField              Field = "URL"
+	ForwarderURLField     Field = "Url"
+	ForwarderMessageField Field = "Echo"
+	ForwarderHeaderField  Field = "Header"
+	HostField             Field = "Host"
+	HostnameField         Field = "Hostname"
+	MethodField           Field = "Method"
+	ProtocolField         Field = "Proto"
+	AlpnField             Field = "Alpn"
+	RequestHeaderField    Field = "RequestHeader"
+	ResponseHeaderField   Field = "ResponseHeader"
+	ClusterField          Field = "Cluster"
+	IstioVersionField     Field = "IstioVersion"
+	IPField               Field = "IP" // The Requester’s IP Address.
+	LatencyField          Field = "Latency"
+	ActiveRequestsField   Field = "ActiveRequests"
+	DNSProtocolField      Field = "Protocol"
+	DNSQueryField         Field = "Query"
+	DNSServerField        Field = "DnsServer"
+	CipherField           Field = "Cipher"
+	TLSVersionField       Field = "Version"
+	TLSServerName         Field = "ServerName"
 )
diff --git a/pkg/test/echo/proto/echo.pb.go b/pkg/test/echo/proto/echo.pb.go
index 7137231211..4173cae5ea 100644
--- a/pkg/test/echo/proto/echo.pb.go
+++ b/pkg/test/echo/proto/echo.pb.go
@@ -226,6 +226,12 @@ type ForwardEchoRequest struct {
 	// Expected response determines what string to look for in the response to validate TCP requests succeeded.
 	// If not set, defaults to "StatusCode=200"
 	ExpectedResponse *wrapperspb.StringValue `protobuf:"bytes,21,opt,name=expectedResponse,proto3" json:"expectedResponse,omitempty"`
+	// If set, a new connection will be made to the server for each individual request. If false, an attempt
+	// will be made to re-use the connection for the life of the forward request. This is automatically
+	// set for DNS, TCP, TLS, and WebSocket protocols.
+	NewConnectionPerRequest bool `protobuf:"varint,22,opt,name=newConnectionPerRequest,proto3" json:"newConnectionPerRequest,omitempty"`
+	// If set, each request will force a DNS lookup. Only applies if newConnectionPerRequest is set.
+	ForceDNSLookup bool `protobuf:"varint,23,opt,name=forceDNSLookup,proto3" json:"forceDNSLookup,omitempty"`
 }
 
 func (x *ForwardEchoRequest) Reset() {
@@ -407,6 +413,20 @@ func (x *ForwardEchoRequest) GetExpectedResponse() *wrapperspb.StringValue {
 	return nil
 }
 
+func (x *ForwardEchoRequest) GetNewConnectionPerRequest() bool {
+	if x != nil {
+		return x.NewConnectionPerRequest
+	}
+	return false
+}
+
+func (x *ForwardEchoRequest) GetForceDNSLookup() bool {
+	if x != nil {
+		return x.ForceDNSLookup
+	}
+	return false
+}
+
 type Alpn struct {
 	state         protoimpl.MessageState
 	sizeCache     protoimpl.SizeCache
@@ -516,7 +536,7 @@ func (x *ForwardEchoResponse) GetOutput() []string {
 	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x30, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72,
 	0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
 	0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
-	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x97, 0x05, 0x0a, 0x12, 0x46, 0x6f, 0x72,
+	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xf9, 0x05, 0x0a, 0x12, 0x46, 0x6f, 0x72,
 	0x77, 0x61, 0x72, 0x64, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
 	0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05,
 	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x71, 0x70, 0x73, 0x18, 0x02, 0x20, 0x01,
@@ -558,21 +578,27 @@ func (x *ForwardEchoResponse) GetOutput() []string {
 	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
 	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65,
 	0x52, 0x10, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
-	0x73, 0x65, 0x22, 0x1c, 0x0a, 0x04, 0x41, 0x6c, 0x70, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
-	0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
-	0x22, 0x2d, 0x0a, 0x13, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x45, 0x63, 0x68, 0x6f, 0x52,
-	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75,
-	0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x32,
-	0x88, 0x01, 0x0a, 0x0f, 0x45, 0x63, 0x68, 0x6f, 0x54, 0x65, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76,
-	0x69, 0x63, 0x65, 0x12, 0x2f, 0x0a, 0x04, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x12, 0x2e, 0x70, 0x72,
-	0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
-	0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x73, 0x70,
-	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0b, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x45,
-	0x63, 0x68, 0x6f, 0x12, 0x19, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x6f, 0x72, 0x77,
-	0x61, 0x72, 0x64, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a,
-	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x45, 0x63,
-	0x68, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2e,
-	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
+	0x73, 0x65, 0x12, 0x38, 0x0a, 0x17, 0x6e, 0x65, 0x77, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
+	0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x16, 0x20,
+	0x01, 0x28, 0x08, 0x52, 0x17, 0x6e, 0x65, 0x77, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
+	0x6f, 0x6e, 0x50, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x26, 0x0a, 0x0e,
+	0x66, 0x6f, 0x72, 0x63, 0x65, 0x44, 0x4e, 0x53, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x18, 0x17,
+	0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x44, 0x4e, 0x53, 0x4c, 0x6f,
+	0x6f, 0x6b, 0x75, 0x70, 0x22, 0x1c, 0x0a, 0x04, 0x41, 0x6c, 0x70, 0x6e, 0x12, 0x14, 0x0a, 0x05,
+	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
+	0x75, 0x65, 0x22, 0x2d, 0x0a, 0x13, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x45, 0x63, 0x68,
+	0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x75, 0x74,
+	0x70, 0x75, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75,
+	0x74, 0x32, 0x88, 0x01, 0x0a, 0x0f, 0x45, 0x63, 0x68, 0x6f, 0x54, 0x65, 0x73, 0x74, 0x53, 0x65,
+	0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x2f, 0x0a, 0x04, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x12, 0x2e,
+	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
+	0x74, 0x1a, 0x13, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65,
+	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0b, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72,
+	0x64, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x19, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x6f,
+	0x72, 0x77, 0x61, 0x72, 0x64, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
+	0x1a, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
+	0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x0a, 0x5a, 0x08,
+	0x2e, 0x2e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
 }
 
 var (
diff --git a/pkg/test/echo/proto/echo.proto b/pkg/test/echo/proto/echo.proto
index 6dacc3c446..d6a539c092 100644
--- a/pkg/test/echo/proto/echo.proto
+++ b/pkg/test/echo/proto/echo.proto
@@ -74,6 +74,12 @@ message ForwardEchoRequest {
   // Expected response determines what string to look for in the response to validate TCP requests succeeded.
   // If not set, defaults to "StatusCode=200"
   google.protobuf.StringValue expectedResponse = 21;
+  // If set, a new connection will be made to the server for each individual request. If false, an attempt
+  // will be made to re-use the connection for the life of the forward request. This is automatically
+  // set for DNS, TCP, TLS, and WebSocket protocols.
+  bool newConnectionPerRequest = 22;
+  // If set, each request will force a DNS lookup. Only applies if newConnectionPerRequest is set.
+  bool forceDNSLookup = 23;
 }
 
 message Alpn {
diff --git a/pkg/test/echo/server/endpoint/grpc.go b/pkg/test/echo/server/endpoint/grpc.go
index b14dee688b..d5be6a207f 100644
--- a/pkg/test/echo/server/endpoint/grpc.go
+++ b/pkg/test/echo/server/endpoint/grpc.go
@@ -61,11 +61,13 @@ type grpcInstance struct {
 	Config
 	server   grpcServer
 	cleanups []func()
+	f        *forwarder.Instance
 }
 
 func newGRPC(config Config) Instance {
 	return &grpcInstance{
 		Config: config,
+		f:      forwarder.New(),
 	}
 }
 
@@ -121,7 +123,8 @@ func (s *grpcInstance) Start(onReady OnReadyFunc) error {
 	grpcHealth.RegisterHealthServer(s.server, healthServer)
 
 	proto.RegisterEchoTestServiceServer(s.server, &EchoGrpcHandler{
-		Config: s.Config,
+		Config:    s.Config,
+		Forwarder: s.f,
 	})
 	reflection.Register(s.server)
 	if val, _ := env.GetBool("EXPOSE_GRPC_ADMIN", false); val {
@@ -166,18 +169,14 @@ func (s *grpcInstance) awaitReady(onReady OnReadyFunc, listener net.Listener) {
 			req.CaCertFile = ca
 			req.InsecureSkipVerify = true
 		}
-		f, err := forwarder.New(forwarder.Config{
-			XDSTestBootstrap: s.Port.XDSTestBootstrap,
-			Request:          req,
-		})
-		defer func() {
-			_ = f.Close()
-		}()
 
 		if err != nil {
 			return err
 		}
-		_, err = f.Run(context.Background())
+		_, err = s.f.ForwardEcho(context.Background(), &forwarder.Config{
+			XDSTestBootstrap: s.Port.XDSTestBootstrap,
+			Request:          req,
+		})
 		return err
 	}, retry.Timeout(readyTimeout), retry.Delay(readyInterval))
 	if err != nil {
@@ -222,6 +221,9 @@ func (s *grpcInstance) Close() error {
 	if s.server != nil {
 		s.server.Stop()
 	}
+	if s.f != nil {
+		_ = s.f.Close()
+	}
 	for _, cleanup := range s.cleanups {
 		cleanup()
 	}
@@ -231,6 +233,7 @@ func (s *grpcInstance) Close() error {
 type EchoGrpcHandler struct {
 	proto.UnimplementedEchoTestServiceServer
 	Config
+	Forwarder *forwarder.Instance
 }
 
 func (h *EchoGrpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.EchoResponse, error) {
@@ -248,12 +251,12 @@ func (h *EchoGrpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*pr
 
 			if key == ":authority" {
 				for _, value := range values {
-					writeField(&body, echo.HostField, value)
+					echo.HostField.Write(&body, value)
 				}
 			}
 
 			for _, value := range values {
-				writeRequestHeader(&body, field, value)
+				echo.RequestHeaderField.WriteKeyValue(&body, field, value)
 			}
 		}
 	}
@@ -271,17 +274,17 @@ func (h *EchoGrpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*pr
 		ip, _, _ = net.SplitHostPort(peerInfo.Addr.String())
 	}
 
-	writeField(&body, echo.StatusCodeField, strconv.Itoa(http.StatusOK))
-	writeField(&body, echo.ServiceVersionField, h.Version)
-	writeField(&body, echo.ServicePortField, strconv.Itoa(portNumber))
-	writeField(&body, echo.ClusterField, h.Cluster)
-	writeField(&body, echo.IPField, ip)
-	writeField(&body, echo.IstioVersionField, h.IstioVersion)
-	writeField(&body, echo.ProtocolField, "GRPC")
-	writeField(&body, "Echo", req.GetMessage())
+	echo.StatusCodeField.Write(&body, strconv.Itoa(http.StatusOK))
+	echo.ServiceVersionField.Write(&body, h.Version)
+	echo.ServicePortField.Write(&body, strconv.Itoa(portNumber))
+	echo.ClusterField.Write(&body, h.Cluster)
+	echo.IPField.Write(&body, ip)
+	echo.IstioVersionField.Write(&body, h.IstioVersion)
+	echo.ProtocolField.Write(&body, "GRPC")
+	echo.Field("Echo").Write(&body, req.GetMessage())
 
 	if hostname, err := os.Hostname(); err == nil {
-		writeField(&body, echo.HostnameField, hostname)
+		echo.HostnameField.Write(&body, hostname)
 	}
 
 	epLog.WithLabels("id", id).Infof("GRPC Response")
@@ -293,15 +296,8 @@ func (h *EchoGrpcHandler) ForwardEcho(ctx context.Context, req *proto.ForwardEch
 	l := epLog.WithLabels("url", req.Url, "id", id)
 	l.Infof("ForwardEcho request")
 	t0 := time.Now()
-	instance, err := forwarder.New(forwarder.Config{
-		Request: req,
-	})
-	if err != nil {
-		return nil, err
-	}
-	defer func() { _ = instance.Close() }()
 
-	ret, err := instance.Run(ctx)
+	ret, err := h.Forwarder.ForwardEcho(ctx, &forwarder.Config{Request: req})
 	if err == nil {
 		l.WithLabels("latency", time.Since(t0)).Infof("ForwardEcho response complete: %v", ret.GetOutput())
 	} else {
diff --git a/pkg/test/echo/server/endpoint/http.go b/pkg/test/echo/server/endpoint/http.go
index 384e83bd60..0659dd40a5 100644
--- a/pkg/test/echo/server/endpoint/http.go
+++ b/pkg/test/echo/server/endpoint/http.go
@@ -290,7 +290,7 @@ func (h *httpHandler) webSocketEcho(w http.ResponseWriter, r *http.Request) {
 	h.addResponsePayload(r, &body)
 	body.Write(message)
 
-	writeField(&body, echo.StatusCodeField, strconv.Itoa(http.StatusOK))
+	echo.StatusCodeField.Write(&body, strconv.Itoa(http.StatusOK))
 
 	// pong
 	err = c.WriteMessage(mt, body.Bytes())
@@ -307,18 +307,18 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 		port = strconv.Itoa(h.Port.Port)
 	}
 
-	writeField(body, echo.ServiceVersionField, h.Version)
-	writeField(body, echo.ServicePortField, port)
-	writeField(body, echo.HostField, r.Host)
+	echo.ServiceVersionField.Write(body, h.Version)
+	echo.ServicePortField.Write(body, port)
+	echo.HostField.Write(body, r.Host)
 	// Use raw path, we don't want golang normalizing anything since we use this for testing purposes
-	writeField(body, echo.URLField, r.RequestURI)
-	writeField(body, echo.ClusterField, h.Cluster)
-	writeField(body, echo.IstioVersionField, h.IstioVersion)
+	echo.URLField.Write(body, r.RequestURI)
+	echo.ClusterField.Write(body, h.Cluster)
+	echo.IstioVersionField.Write(body, h.IstioVersion)
 
-	writeField(body, echo.MethodField, r.Method)
-	writeField(body, echo.ProtocolField, r.Proto)
+	echo.MethodField.Write(body, r.Method)
+	echo.ProtocolField.Write(body, r.Proto)
 	ip, _, _ := net.SplitHostPort(r.RemoteAddr)
-	writeField(body, echo.IPField, ip)
+	echo.IPField.Write(body, ip)
 
 	// Note: since this is the NegotiatedProtocol, it will be set to empty if the client sends an ALPN
 	// not supported by the server (ie one of h2,http/1.1,http/1.0)
@@ -326,7 +326,7 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	if r.TLS != nil {
 		alpn = r.TLS.NegotiatedProtocol
 	}
-	writeField(body, echo.AlpnField, alpn)
+	echo.AlpnField.Write(body, alpn)
 
 	var keys []string
 	for k := range r.Header {
@@ -336,12 +336,12 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	for _, key := range keys {
 		values := r.Header[key]
 		for _, value := range values {
-			writeRequestHeader(body, key, value)
+			echo.RequestHeaderField.WriteKeyValue(body, key, value)
 		}
 	}
 
 	if hostname, err := os.Hostname(); err == nil {
-		writeField(body, echo.HostnameField, hostname)
+		echo.HostnameField.Write(body, hostname)
 	}
 }
 
diff --git a/pkg/test/echo/server/endpoint/util.go b/pkg/test/echo/server/endpoint/util.go
index 205cdb1e6b..954e64de53 100644
--- a/pkg/test/echo/server/endpoint/util.go
+++ b/pkg/test/echo/server/endpoint/util.go
@@ -15,13 +15,11 @@
 package endpoint
 
 import (
-	"bytes"
 	"crypto/tls"
 	"net"
 	"os"
 	"strconv"
 
-	"istio.io/istio/pkg/test/echo"
 	"istio.io/pkg/log"
 )
 
@@ -73,13 +71,3 @@ func listenOnUDS(uds string) (net.Listener, error) {
 
 	return ln, nil
 }
-
-// nolint: interfacer
-func writeField(out *bytes.Buffer, field echo.Field, value string) {
-	_, _ = out.WriteString(string(field) + "=" + value + "\n")
-}
-
-// nolint: interfacer
-func writeRequestHeader(out *bytes.Buffer, key, value string) {
-	writeField(out, echo.RequestHeaderField, key+":"+value)
-}
diff --git a/pkg/test/echo/server/forwarder/config.go b/pkg/test/echo/server/forwarder/config.go
index d8f2e61c94..33fc746fa9 100644
--- a/pkg/test/echo/server/forwarder/config.go
+++ b/pkg/test/echo/server/forwarder/config.go
@@ -40,14 +40,21 @@ type Config struct {
 	Proxy string
 
 	// Filled in values.
-	scheme               scheme.Instance
-	tlsConfig            *tls.Config
-	getClientCertificate func(info *tls.CertificateRequestInfo) (*tls.Certificate, error)
-	checkRedirect        func(req *http.Request, via []*http.Request) error
-	proxyURL             func(*http.Request) (*url.URL, error)
-	timeout              time.Duration
-	count                int
-	headers              http.Header
+	scheme                  scheme.Instance
+	tlsConfig               *tls.Config
+	getClientCertificate    func(info *tls.CertificateRequestInfo) (*tls.Certificate, error)
+	checkRedirect           func(req *http.Request, via []*http.Request) error
+	proxyURL                func(*http.Request) (*url.URL, error)
+	timeout                 time.Duration
+	count                   int
+	headers                 http.Header
+	newConnectionPerRequest bool
+	forceDNSLookup          bool
+	hostHeader              string
+	urlHost                 string
+	urlPath                 string
+	method                  string
+	secure                  bool
 }
 
 func (c *Config) fillDefaults() error {
@@ -56,6 +63,17 @@ func (c *Config) fillDefaults() error {
 	c.count = common.GetCount(c.Request)
 	c.headers = common.GetHeaders(c.Request)
 
+	// Extract the host from the headers and then remove it.
+	c.hostHeader = c.headers.Get(hostHeader)
+	c.headers.Del(hostHeader)
+
+	c.urlHost, c.urlPath = splitPath(c.Request.Url)
+
+	c.method = c.Request.Method
+	if c.method == "" {
+		c.method = "GET"
+	}
+
 	if i := strings.IndexByte(c.Request.Url, ':'); i > 0 {
 		c.scheme = scheme.Instance(strings.ToLower(c.Request.Url[0:i]))
 	} else {
@@ -67,7 +85,9 @@ func (c *Config) fillDefaults() error {
 	if err != nil {
 		return err
 	}
-	c.tlsConfig, err = newTLSConfig(c.Request, c.getClientCertificate)
+	c.secure = c.getClientCertificate != nil
+
+	c.tlsConfig, err = newTLSConfig(c)
 	if err != nil {
 		return err
 	}
@@ -82,9 +102,36 @@ func (c *Config) fillDefaults() error {
 		c.proxyURL = http.ProxyURL(proxyURL)
 	}
 
+	// Configure reuseConnection and forceDNSLookup as appropriate.
+	switch c.scheme {
+	case scheme.DNS:
+		c.newConnectionPerRequest = true
+		c.forceDNSLookup = true
+	case scheme.TCP, scheme.TLS, scheme.WebSocket, scheme.HTTPS:
+		c.newConnectionPerRequest = true
+		c.forceDNSLookup = c.Request.ForceDNSLookup
+	default:
+		c.newConnectionPerRequest = c.Request.NewConnectionPerRequest
+		c.forceDNSLookup = c.newConnectionPerRequest && c.Request.ForceDNSLookup
+	}
+
 	return nil
 }
 
+func splitPath(raw string) (url, path string) {
+	schemeSep := "://"
+	schemeBegin := strings.Index(raw, schemeSep)
+	if schemeBegin == -1 {
+		return raw, ""
+	}
+	schemeEnd := schemeBegin + len(schemeSep)
+	pathBegin := strings.IndexByte(raw[schemeEnd:], '/')
+	if pathBegin == -1 {
+		return raw, ""
+	}
+	return raw[:schemeEnd+pathBegin], raw[schemeEnd+pathBegin:]
+}
+
 func getClientCertificateFunc(r *proto.ForwardEchoRequest) (func(info *tls.CertificateRequestInfo) (*tls.Certificate, error), error) {
 	if r.KeyFile != "" && r.CertFile != "" {
 		certData, err := os.ReadFile(r.CertFile)
@@ -136,9 +183,10 @@ func getClientCertificateFunc(r *proto.ForwardEchoRequest) (func(info *tls.Certi
 	return nil, nil
 }
 
-func newTLSConfig(r *proto.ForwardEchoRequest, getClientCertificate func(info *tls.CertificateRequestInfo) (*tls.Certificate, error)) (*tls.Config, error) {
+func newTLSConfig(c *Config) (*tls.Config, error) {
+	r := c.Request
 	tlsConfig := &tls.Config{
-		GetClientCertificate: getClientCertificate,
+		GetClientCertificate: c.getClientCertificate,
 		NextProtos:           r.GetAlpn().GetValue(),
 		ServerName:           r.ServerName,
 	}
@@ -158,6 +206,35 @@ func newTLSConfig(r *proto.ForwardEchoRequest, getClientCertificate func(info *t
 		}
 		tlsConfig.RootCAs = certPool
 	}
+
+	setALPNForHTTP := func() {
+		if r.Alpn == nil {
+			switch {
+			case r.Http3:
+				// Do nothing.
+			case r.Http2:
+				tlsConfig.NextProtos = []string{"h2"}
+			default:
+				tlsConfig.NextProtos = []string{"http/1.1"}
+			}
+		}
+	}
+
+	// Per-protocol setup.
+	switch c.scheme {
+	case scheme.HTTPS:
+		// Set SNI value to be same as the request Host
+		// For use with SNI routing tests
+		if tlsConfig.ServerName == "" {
+			tlsConfig.ServerName = c.hostHeader
+		}
+		setALPNForHTTP()
+	case scheme.HTTP:
+		if r.Http3 {
+			return nil, fmt.Errorf("http3 requires HTTPS")
+		}
+		setALPNForHTTP()
+	}
 	return tlsConfig, nil
 }
 
diff --git a/pkg/test/echo/server/forwarder/dns.go b/pkg/test/echo/server/forwarder/dns.go
index 3c8f445cc3..10f027fd49 100644
--- a/pkg/test/echo/server/forwarder/dns.go
+++ b/pkg/test/echo/server/forwarder/dns.go
@@ -21,11 +21,25 @@
 	"net"
 	"net/url"
 	"strings"
+	"time"
+
+	"istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &dnsProtocol{}
 
-type dnsProtocol struct{}
+type dnsProtocol struct {
+	e *executor
+}
+
+func newDNSProtocol(e *executor) protocol {
+	return &dnsProtocol{e: e}
+}
+
+func (c *dnsProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	return doForward(ctx, cfg, c.e, c.makeRequest)
+}
 
 type dnsRequest struct {
 	hostname  string
@@ -71,12 +85,12 @@ func parseRequest(inputURL string) (dnsRequest, error) {
 	return req, nil
 }
 
-func (c *dnsProtocol) makeRequest(ctx context.Context, rreq *request) (string, error) {
-	req, err := parseRequest(rreq.URL)
+func (c *dnsProtocol) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	req, err := parseRequest(cfg.Request.Url)
 	if err != nil {
 		return "", err
 	}
-	r := newResolver(rreq.Timeout, req.protocol, req.dnsServer)
+	r := newResolver(cfg.timeout, req.protocol, req.dnsServer)
 	nt := func() string {
 		switch req.query {
 		case "A":
@@ -87,20 +101,25 @@ func (c *dnsProtocol) makeRequest(ctx context.Context, rreq *request) (string, e
 			return "ip"
 		}
 	}()
-	ctx, cancel := context.WithTimeout(ctx, rreq.Timeout)
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
 	defer cancel()
+
+	start := time.Now()
 	ips, err := r.LookupIP(ctx, nt, req.hostname)
 	if err != nil {
 		return "", err
 	}
 
 	var outBuffer bytes.Buffer
-	outBuffer.WriteString(fmt.Sprintf("[%d] Hostname=%s\n", rreq.RequestID, req.hostname))
-	outBuffer.WriteString(fmt.Sprintf("[%d] Protocol=%s\n", rreq.RequestID, req.protocol))
-	outBuffer.WriteString(fmt.Sprintf("[%d] Query=%s\n", rreq.RequestID, req.query))
-	outBuffer.WriteString(fmt.Sprintf("[%d] DnsServer=%s\n", rreq.RequestID, req.dnsServer))
+	echo.LatencyField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%v", time.Since(start)))
+	echo.ActiveRequestsField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%d", c.e.ActiveRequests()))
+	echo.HostnameField.WriteForRequest(&outBuffer, requestID, req.hostname)
+	echo.DNSProtocolField.WriteForRequest(&outBuffer, requestID, req.protocol)
+	echo.DNSQueryField.WriteForRequest(&outBuffer, requestID, req.query)
+	echo.DNSServerField.WriteForRequest(&outBuffer, requestID, req.dnsServer)
+
 	for n, i := range ips {
-		outBuffer.WriteString(fmt.Sprintf("[%d body] Response%d=%s\n", rreq.RequestID, n, i.String()))
+		echo.WriteBodyLine(&outBuffer, requestID, fmt.Sprintf("Response%d=%s", n, i.String()))
 	}
 	return outBuffer.String(), nil
 }
diff --git a/pkg/test/echo/server/forwarder/executor.go b/pkg/test/echo/server/forwarder/executor.go
new file mode 100644
index 0000000000..28606c7f50
--- /dev/null
+++ b/pkg/test/echo/server/forwarder/executor.go
@@ -0,0 +1,88 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package forwarder
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/hashicorp/go-multierror"
+	"go.uber.org/atomic"
+	"golang.org/x/sync/semaphore"
+)
+
+const (
+	maxConcurrencyPerForward = 20
+)
+
+type executor struct {
+	totalRequests  *atomic.Uint64
+	activeRequests *atomic.Uint64
+	stopCh         chan struct{}
+}
+
+func newExecutor() *executor {
+	e := &executor{
+		totalRequests:  atomic.NewUint64(0),
+		activeRequests: atomic.NewUint64(0),
+		stopCh:         make(chan struct{}),
+	}
+
+	return e
+}
+
+func (e *executor) ActiveRequests() uint64 {
+	return e.activeRequests.Load()
+}
+
+// NewGroup creates a new group of tasks that can be managed collectively.
+// Parallelism is limited by the global maxConcurrency of the executor.
+func (e *executor) NewGroup() *execGroup {
+	return &execGroup{
+		e:   e,
+		sem: semaphore.NewWeighted(int64(maxConcurrencyPerForward)),
+	}
+}
+
+type execGroup struct {
+	e   *executor
+	g   multierror.Group
+	sem *semaphore.Weighted
+}
+
+// Go runs the given work function asynchronously.
+func (g *execGroup) Go(ctx context.Context, work func() error) {
+	g.g.Go(func() error {
+		g.e.totalRequests.Inc()
+		g.e.activeRequests.Inc()
+		defer g.e.activeRequests.Dec()
+
+		// Acquire the group concurrency semaphore.
+		if err := g.sem.Acquire(ctx, 1); err != nil {
+			return fmt.Errorf("request set timed out: %v", err)
+		}
+		defer g.sem.Release(1)
+
+		return work()
+	})
+}
+
+func (g *execGroup) Wait() *multierror.Error {
+	return g.g.Wait()
+}
+
+func (e *executor) Close() {
+	close(e.stopCh)
+}
diff --git a/pkg/test/echo/server/forwarder/grpc.go b/pkg/test/echo/server/forwarder/grpc.go
index 795ada3096..c8bb23ccf4 100644
--- a/pkg/test/echo/server/forwarder/grpc.go
+++ b/pkg/test/echo/server/forwarder/grpc.go
@@ -21,12 +21,14 @@
 	"net"
 	"strconv"
 	"strings"
+	"time"
 
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials"
 	"google.golang.org/grpc/credentials/insecure"
 	"google.golang.org/grpc/metadata"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/proto"
 )
@@ -34,87 +36,126 @@
 var _ protocol = &grpcProtocol{}
 
 type grpcProtocol struct {
-	conn func() (conn *grpc.ClientConn, err error)
+	e *executor
 }
 
-func newGRPCProtocol(r *Config) (protocol, error) {
-	conn := func() (conn *grpc.ClientConn, err error) {
-		var opts []grpc.DialOption
-
-		// Force DNS lookup each time.
-		opts = append(opts, grpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {
-			return newDialer().DialContext(ctx, "tcp", addr)
-		}))
+func newGRPCProtocol(e *executor) protocol {
+	return &grpcProtocol{e: e}
+}
 
-		security := grpc.WithTransportCredentials(insecure.NewCredentials())
-		if r.getClientCertificate != nil {
-			security = grpc.WithTransportCredentials(credentials.NewTLS(r.tlsConfig))
+type grpcConnectionGetter func() (*grpc.ClientConn, func(), error)
+
+func (c *grpcProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	var getConn grpcConnectionGetter
+	if cfg.newConnectionPerRequest {
+		// Create a new connection per request.
+		getConn = func() (*grpc.ClientConn, func(), error) {
+			conn, err := newGRPCConnection(cfg)
+			if err != nil {
+				return nil, nil, err
+			}
+			return conn, func() { _ = conn.Close() }, nil
+		}
+	} else {
+		// Reuse the connection across all requests.
+		conn, err := newGRPCConnection(cfg)
+		if err != nil {
+			return nil, err
+		}
+		defer func() { _ = conn.Close() }()
+		getConn = func() (*grpc.ClientConn, func(), error) {
+			return conn, func() {}, nil
 		}
-
-		// Strip off the scheme from the address (for regular gRPC).
-		address := r.Request.Url[len(r.scheme+"://"):]
-
-		// Connect to the GRPC server.
-		ctx, cancel := context.WithTimeout(context.Background(), common.ConnectionTimeout)
-		defer cancel()
-		opts = append(opts, security, grpc.WithAuthority(r.headers.Get(hostHeader)))
-		return grpc.DialContext(ctx, address, opts...)
 	}
 
-	return &grpcProtocol{
-		conn: conn,
-	}, nil
-}
-
-func (c *grpcProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	conn, err := c.conn()
-	if err != nil {
-		return "", err
+	call := &grpcCall{
+		e:       c.e,
+		getConn: getConn,
 	}
-	defer func() { _ = conn.Close() }()
-
-	return makeGRPCRequest(ctx, conn, req)
+	return doForward(ctx, cfg, c.e, call.makeRequest)
 }
 
 func (c *grpcProtocol) Close() error {
 	return nil
 }
 
-func makeGRPCRequest(ctx context.Context, conn *grpc.ClientConn, req *request) (string, error) {
+type grpcCall struct {
+	e       *executor
+	getConn grpcConnectionGetter
+}
+
+func (c *grpcCall) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	conn, closeConn, err := c.getConn()
+	if err != nil {
+		return "", err
+	}
+	defer closeConn()
+
 	// Set the per-request timeout.
-	ctx, cancel := context.WithTimeout(ctx, req.Timeout)
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
 	defer cancel()
 
 	// Add headers to the request context.
 	outMD := make(metadata.MD)
-	for k, v := range req.Header {
+	for k, v := range cfg.headers {
 		// Exclude the Host header from the GRPC context.
 		if !strings.EqualFold(hostHeader, k) {
 			outMD.Set(k, v...)
 		}
 	}
-	outMD.Set("X-Request-Id", strconv.Itoa(req.RequestID))
+	outMD.Set("X-Request-Id", strconv.Itoa(requestID))
 	ctx = metadata.NewOutgoingContext(ctx, outMD)
 
 	var outBuffer bytes.Buffer
 	grpcReq := &proto.EchoRequest{
-		Message: req.Message,
+		Message: cfg.Request.Message,
 	}
-	outBuffer.WriteString(fmt.Sprintf("[%d] grpcecho.Echo(%v)\n", req.RequestID, req))
+	// TODO(nmittler): This doesn't fit in with the field pattern. Do we need this?
+	outBuffer.WriteString(fmt.Sprintf("[%d] grpcecho.Echo(%v)\n", requestID, cfg.Request))
 
+	start := time.Now()
 	client := proto.NewEchoTestServiceClient(conn)
 	resp, err := client.Echo(ctx, grpcReq)
 	if err != nil {
 		return "", err
 	}
 
-	// when the underlying HTTP2 request returns status 404, GRPC
+	echo.LatencyField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%v", time.Since(start)))
+	echo.ActiveRequestsField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%d", c.e.ActiveRequests()))
+
+	// When the underlying HTTP2 request returns status 404, GRPC
 	// request does not return an error in grpc-go.
-	// instead it just returns an empty response
+	// Instead, it just returns an empty response
 	for _, line := range strings.Split(resp.GetMessage(), "\n") {
 		if line != "" {
-			outBuffer.WriteString(fmt.Sprintf("[%d body] %s\n", req.RequestID, line))
+			echo.WriteBodyLine(&outBuffer, requestID, line)
 		}
 	}
 	return outBuffer.String(), nil
 }
+
+func newGRPCConnection(cfg *Config) (*grpc.ClientConn, error) {
+	var security grpc.DialOption
+	if cfg.secure {
+		security = grpc.WithTransportCredentials(credentials.NewTLS(cfg.tlsConfig))
+	} else {
+		security = grpc.WithTransportCredentials(insecure.NewCredentials())
+	}
+
+	forceDNSLookup := cfg.forceDNSLookup
+	opts := []grpc.DialOption{
+		grpc.WithAuthority(cfg.hostHeader),
+		grpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {
+			return newDialer(forceDNSLookup).DialContext(ctx, "tcp", addr)
+		}),
+		security,
+	}
+
+	// Strip off the scheme from the address (for regular gRPC).
+	address := cfg.Request.Url[len(cfg.scheme+"://"):]
+
+	// Connect to the GRPC server.
+	ctx, cancel := context.WithTimeout(context.Background(), common.ConnectionTimeout)
+	defer cancel()
+	return grpc.DialContext(ctx, address, opts...)
+}
diff --git a/pkg/test/echo/server/forwarder/http.go b/pkg/test/echo/server/forwarder/http.go
index 71a9266a5f..fd95dc5abb 100644
--- a/pkg/test/echo/server/forwarder/http.go
+++ b/pkg/test/echo/server/forwarder/http.go
@@ -22,9 +22,10 @@
 	"io"
 	"net"
 	"net/http"
-	"net/url"
 	"sort"
+	"strconv"
 	"strings"
+	"time"
 
 	"github.com/lucas-clemente/quic-go"
 	"github.com/lucas-clemente/quic-go/http3"
@@ -32,187 +33,227 @@
 
 	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &httpProtocol{}
 
 type httpProtocol struct {
-	*Config
+	e *executor
 }
 
-func newHTTPProtocol(r *Config) (*httpProtocol, error) {
-	// Per-protocol setup.
+func newHTTPProtocol(e *executor) *httpProtocol {
+	return &httpProtocol{e: e}
+}
+
+type httpTransportGetter func() (http.RoundTripper, func(), error)
+
+func (c *httpProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	var getTransport httpTransportGetter
+	var closeSharedTransport func()
+
 	switch {
-	case r.Request.Http3:
-		if r.scheme == scheme.HTTP {
-			return nil, fmt.Errorf("http3 requires HTTPS")
-		}
-	case r.Request.Http2:
-		if r.Request.Alpn == nil {
-			r.tlsConfig.NextProtos = []string{"h2"}
-		}
+	case cfg.Request.Http3:
+		getTransport, closeSharedTransport = newHTTP3TransportGetter(cfg)
+	case cfg.Request.Http2:
+		getTransport, closeSharedTransport = newHTTP2TransportGetter(cfg)
 	default:
-		if r.Request.Alpn == nil {
-			r.tlsConfig.NextProtos = []string{"http/1.1"}
-		}
+		getTransport, closeSharedTransport = newHTTPTransportGetter(cfg)
+	}
+
+	defer closeSharedTransport()
+
+	call := &httpCall{
+		httpProtocol: c,
+		getTransport: getTransport,
 	}
 
-	return &httpProtocol{
-		Config: r,
-	}, nil
+	return doForward(ctx, cfg, c.e, call.makeRequest)
 }
 
-func splitPath(raw string) (url, path string) {
-	schemeSep := "://"
-	schemeBegin := strings.Index(raw, schemeSep)
-	if schemeBegin == -1 {
-		return raw, ""
+func newHTTP3TransportGetter(cfg *Config) (httpTransportGetter, func()) {
+	newConn := func() *http3.RoundTripper {
+		return &http3.RoundTripper{
+			TLSClientConfig: cfg.tlsConfig,
+			QuicConfig:      &quic.Config{},
+		}
 	}
-	schemeEnd := schemeBegin + len(schemeSep)
-	pathBegin := strings.IndexByte(raw[schemeEnd:], '/')
-	if pathBegin == -1 {
-		return raw, ""
+	closeFn := func(conn *http3.RoundTripper) func() {
+		return func() {
+			_ = conn.Close()
+		}
 	}
-	return raw[:schemeEnd+pathBegin], raw[schemeEnd+pathBegin:]
-}
+	noCloseFn := func() {}
 
-func (c *httpProtocol) newClient() (*http.Client, error) {
-	client := &http.Client{
-		CheckRedirect: c.checkRedirect,
-		Timeout:       c.timeout,
+	if cfg.newConnectionPerRequest {
+		// Create a new transport (i.e. connection) for each request.
+		return func() (http.RoundTripper, func(), error) {
+			conn := newConn()
+			return conn, closeFn(conn), nil
+		}, noCloseFn
 	}
 
-	switch {
-	case c.Request.Http3:
-		client.Transport = &http3.RoundTripper{
-			TLSClientConfig: c.tlsConfig,
-			QuicConfig:      &quic.Config{},
-		}
-	case c.Request.Http2:
-		if c.scheme == scheme.HTTPS {
-			client.Transport = &http2.Transport{
-				TLSClientConfig: c.tlsConfig,
-				DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
-					return tls.DialWithDialer(newDialer(), network, addr, cfg)
-				},
-			}
-		} else {
-			client.Transport = &http2.Transport{
-				// Golang doesn't have first class support for h2c, so we provide some workarounds
-				// See https://www.mailgun.com/blog/http-2-cleartext-h2c-client-example-go/
-				// So http2.Transport doesn't complain the URL scheme isn't 'https'
-				AllowHTTP: true,
-				// Pretend we are dialing a TLS endpoint. (Note, we ignore the passed tls.Config)
-				DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
-					return newDialer().Dial(network, addr)
+	// Re-use the same transport for all requests. For HTTP3, this should result
+	// in multiplexing all requests over the same connection.
+	conn := newConn()
+	return func() (http.RoundTripper, func(), error) {
+		return conn, noCloseFn, nil
+	}, closeFn(conn)
+}
+
+func newHTTP2TransportGetter(cfg *Config) (httpTransportGetter, func()) {
+	newConn := func() *http2.Transport {
+		if cfg.scheme == scheme.HTTPS {
+			return &http2.Transport{
+				TLSClientConfig: cfg.tlsConfig,
+				DialTLS: func(network, addr string, tlsConfig *tls.Config) (net.Conn, error) {
+					return tls.DialWithDialer(newDialer(cfg.forceDNSLookup), network, addr, tlsConfig)
 				},
 			}
 		}
-	default:
+
+		return &http2.Transport{
+			// Golang doesn't have first class support for h2c, so we provide some workarounds
+			// See https://www.mailgun.com/blog/http-2-cleartext-h2c-client-example-go/
+			// So http2.Transport doesn't complain the URL scheme isn't 'https'
+			AllowHTTP: true,
+			// Pretend we are dialing a TLS endpoint. (Note, we ignore the passed tls.Config)
+			DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
+				return newDialer(cfg.forceDNSLookup).Dial(network, addr)
+			},
+		}
+	}
+	closeFn := func(conn *http2.Transport) func() {
+		return conn.CloseIdleConnections
+	}
+	noCloseFn := func() {}
+
+	if cfg.newConnectionPerRequest {
+		// Create a new transport (i.e. connection) for each request.
+		return func() (http.RoundTripper, func(), error) {
+			conn := newConn()
+			return conn, closeFn(conn), nil
+		}, noCloseFn
+	}
+
+	// Re-use the same transport for all requests. For HTTP2, this should result
+	// in multiplexing all requests over the same connection.
+	conn := newConn()
+	return func() (http.RoundTripper, func(), error) {
+		return conn, noCloseFn, nil
+	}, closeFn(conn)
+}
+
+func newHTTPTransportGetter(cfg *Config) (httpTransportGetter, func()) {
+	newConn := func() *http.Transport {
 		dialContext := func(ctx context.Context, network, addr string) (net.Conn, error) {
-			return newDialer().Dial(network, addr)
+			return newDialer(cfg.forceDNSLookup).DialContext(ctx, network, addr)
 		}
-		if len(c.UDS) > 0 {
+		if len(cfg.UDS) > 0 {
 			dialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {
-				return newDialer().Dial("unix", c.UDS)
+				return newDialer(cfg.forceDNSLookup).DialContext(ctx, "unix", cfg.UDS)
 			}
 		}
-		transport := &http.Transport{
+		out := &http.Transport{
 			// No connection pooling.
 			DisableKeepAlives: true,
-			TLSClientConfig:   c.tlsConfig,
+			TLSClientConfig:   cfg.tlsConfig,
 			DialContext:       dialContext,
 			Proxy:             http.ProxyFromEnvironment,
 		}
-		client.Transport = transport
 
 		// Set the proxy in the transport, if specified.
-		if len(c.Proxy) > 0 {
-			proxyURL, err := url.Parse(c.Proxy)
-			if err != nil {
-				return nil, err
-			}
-			transport.Proxy = http.ProxyURL(proxyURL)
-		}
+		out.Proxy = cfg.proxyURL
+		return out
 	}
+	noCloseFn := func() {}
 
-	return client, nil
+	// Always create a new HTTP transport for each request, since HTTP can't multiplex over
+	// a single connection.
+	return func() (http.RoundTripper, func(), error) {
+		conn := newConn()
+		return conn, noCloseFn, nil
+	}, noCloseFn
 }
 
-func (c *httpProtocol) setHost(client *http.Client, r *http.Request, host string) {
-	r.Host = host
-
-	if r.URL.Scheme == "https" {
-		// Set SNI value to be same as the request Host
-		// For use with SNI routing tests
-		httpTransport, ok := client.Transport.(*http.Transport)
-		if ok && httpTransport.TLSClientConfig.ServerName == "" {
-			httpTransport.TLSClientConfig.ServerName = host
-			return
-		}
+type httpCall struct {
+	*httpProtocol
+	getTransport httpTransportGetter
+}
 
-		http2Transport, ok := client.Transport.(*http2.Transport)
-		if ok && http2Transport.TLSClientConfig.ServerName == "" {
-			http2Transport.TLSClientConfig.ServerName = host
-			return
-		}
+func (c *httpCall) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	start := time.Now()
 
-		http3Transport, ok := client.Transport.(*http3.RoundTripper)
-		if ok && http3Transport.TLSClientConfig.ServerName == "" {
-			http3Transport.TLSClientConfig.ServerName = host
-			return
-		}
-	}
-}
+	r := cfg.Request
+	var outBuffer bytes.Buffer
+	echo.ForwarderURLField.WriteForRequest(&outBuffer, requestID, r.Url)
 
-func (c *httpProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	method := req.Method
-	if method == "" {
-		method = "GET"
-	}
+	// Set the per-request timeout.
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
+	defer cancel()
 
-	// Manually split the path from the URL, the http.NewRequest() will fail to parse paths with invalid encoding that we
-	// intentionally used in the test.
-	u, p := splitPath(req.URL)
-	httpReq, err := http.NewRequest(method, u, nil)
+	httpReq, err := http.NewRequestWithContext(ctx, cfg.method, cfg.urlHost, nil)
 	if err != nil {
-		return "", err
+		return outBuffer.String(), err
 	}
+
 	// Use raw path, we don't want golang normalizing anything since we use this for testing purposes
-	httpReq.URL.Opaque = p
+	httpReq.URL.Opaque = cfg.urlPath
 
-	// Set the per-request timeout.
-	ctx, cancel := context.WithTimeout(ctx, req.Timeout)
-	defer cancel()
-	httpReq = httpReq.WithContext(ctx)
+	// Use the host header as the host.
+	httpReq.Host = cfg.hostHeader
 
-	var outBuffer bytes.Buffer
-	outBuffer.WriteString(fmt.Sprintf("[%d] Url=%s\n", req.RequestID, req.URL))
-	host := ""
-	writeHeaders(req.RequestID, req.Header, outBuffer, func(key string, value string) {
-		if key == hostHeader {
-			host = value
-		} else {
-			// Avoid using .Add() to allow users to pass non-canonical forms
-			httpReq.Header[key] = append(httpReq.Header[key], value)
-		}
-	})
+	// Copy the headers.
+	httpReq.Header = cfg.headers.Clone()
+	writeForwardedHeaders(&outBuffer, requestID, cfg.headers)
 
-	// Create a new HTTP client.
-	client, err := c.newClient()
+	// Get the transport.
+	transport, closeTransport, err := c.getTransport()
 	if err != nil {
 		return outBuffer.String(), err
 	}
+	defer closeTransport()
 
-	c.setHost(client, httpReq, host)
+	// Create a new HTTP client.
+	client := &http.Client{
+		CheckRedirect: cfg.checkRedirect,
+		Timeout:       cfg.timeout,
+		Transport:     transport,
+	}
 
+	// Make the request.
 	httpResp, err := client.Do(httpReq)
 	if err != nil {
 		return outBuffer.String(), err
 	}
 
-	outBuffer.WriteString(fmt.Sprintf("[%d] %s=%d\n", req.RequestID, echo.StatusCodeField, httpResp.StatusCode))
+	echo.LatencyField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%v", time.Since(start)))
+	echo.ActiveRequestsField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%d", c.e.ActiveRequests()))
+
+	// Process the response.
+	err = processHTTPResponse(requestID, httpResp, &outBuffer)
 
+	// Extract the output string.
+	return outBuffer.String(), err
+}
+
+func processHTTPResponse(requestID int, httpResp *http.Response, outBuffer *bytes.Buffer) error {
+	// Make sure we close the body before exiting.
+	defer func() {
+		if err := httpResp.Body.Close(); err != nil {
+			echo.WriteError(outBuffer, requestID, err)
+		}
+	}()
+
+	echo.StatusCodeField.WriteForRequest(outBuffer, requestID, strconv.Itoa(httpResp.StatusCode))
+
+	// Read the entire body.
+	data, err := io.ReadAll(httpResp.Body)
+	if err != nil {
+		return err
+	}
+
+	// Write the response headers to the output buffer.
 	var keys []string
 	for k := range httpResp.Header {
 		keys = append(keys, k)
@@ -221,28 +262,17 @@ func (c *httpProtocol) makeRequest(ctx context.Context, req *request) (string, e
 	for _, key := range keys {
 		values := httpResp.Header[key]
 		for _, value := range values {
-			outBuffer.WriteString(fmt.Sprintf("[%d] %s=%s:%s\n", req.RequestID, echo.ResponseHeaderField, key, value))
+			echo.ResponseHeaderField.WriteKeyValueForRequest(outBuffer, requestID, key, value)
 		}
 	}
 
-	data, err := io.ReadAll(httpResp.Body)
-	defer func() {
-		if err = httpResp.Body.Close(); err != nil {
-			outBuffer.WriteString(fmt.Sprintf("[%d error] %s\n", req.RequestID, err))
-		}
-	}()
-
-	if err != nil {
-		return outBuffer.String(), err
-	}
-
+	// Write the lines of the body to the output buffer.
 	for _, line := range strings.Split(string(data), "\n") {
 		if line != "" {
-			outBuffer.WriteString(fmt.Sprintf("[%d body] %s\n", req.RequestID, line))
+			echo.WriteBodyLine(outBuffer, requestID, line)
 		}
 	}
-
-	return outBuffer.String(), nil
+	return nil
 }
 
 func (c *httpProtocol) Close() error {
diff --git a/pkg/test/echo/server/forwarder/instance.go b/pkg/test/echo/server/forwarder/instance.go
index 95b5b9c261..9d78309949 100644
--- a/pkg/test/echo/server/forwarder/instance.go
+++ b/pkg/test/echo/server/forwarder/instance.go
@@ -18,159 +18,69 @@
 	"context"
 	"fmt"
 	"io"
-	"net/http"
-	"sync"
-	"time"
-
-	"github.com/hashicorp/go-multierror"
-	"golang.org/x/sync/semaphore"
-	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
+	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ io.Closer = &Instance{}
 
-const maxConcurrency = 20
-
-// Instance processes a single proto.ForwardEchoRequest, sending individual echo requests to the destination URL.
+// Instance is a client for forwarding requests to echo servers.
 type Instance struct {
-	p           protocol
-	url         string
-	serverFirst bool
-	timeout     time.Duration
-	count       int
-	qps         int
-	header      http.Header
-	message     string
-	// Method for the request. Only valid for HTTP
-	method           string
-	expectedResponse *wrappers.StringValue
+	e           *executor
+	protocolMap map[scheme.Instance]protocol
+	protocols   []protocol
 }
 
 // New creates a new forwarder Instance.
-func New(cfg Config) (*Instance, error) {
-	if err := cfg.fillDefaults(); err != nil {
-		return nil, err
+func New() *Instance {
+	var protocols []protocol
+	add := func(p protocol) protocol {
+		protocols = append(protocols, p)
+		return p
 	}
 
-	p, err := newProtocol(&cfg)
-	if err != nil {
-		return nil, err
-	}
+	// Create the protocols and populate the map.
+	e := newExecutor()
+	protocolMap := make(map[scheme.Instance]protocol)
+	h := add(newHTTPProtocol(e))
+	protocolMap[scheme.HTTP] = h
+	protocolMap[scheme.HTTPS] = h
+	protocolMap[scheme.DNS] = add(newDNSProtocol(e))
+	protocolMap[scheme.GRPC] = add(newGRPCProtocol(e))
+	protocolMap[scheme.WebSocket] = add(newWebsocketProtocol(e))
+	protocolMap[scheme.TLS] = add(newTLSProtocol(e))
+	protocolMap[scheme.XDS] = add(newXDSProtocol(e))
+	protocolMap[scheme.TCP] = add(newTCPProtocol(e))
 
 	return &Instance{
-		p:                p,
-		url:              cfg.Request.Url,
-		serverFirst:      cfg.Request.ServerFirst,
-		method:           cfg.Request.Method,
-		timeout:          cfg.timeout,
-		count:            cfg.count,
-		qps:              int(cfg.Request.Qps),
-		header:           cfg.headers,
-		message:          cfg.Request.Message,
-		expectedResponse: cfg.Request.ExpectedResponse,
-	}, nil
-}
-
-// Run the forwarder and collect the responses.
-func (i *Instance) Run(ctx context.Context) (*proto.ForwardEchoResponse, error) {
-	g := multierror.Group{}
-	responsesMu := sync.RWMutex{}
-	responses, responseTimes := make([]string, i.count), make([]time.Duration, i.count)
-
-	var throttle *time.Ticker
-
-	if i.qps > 0 {
-		sleepTime := time.Second / time.Duration(i.qps)
-		fwLog.Debugf("Sleeping %v between requests", sleepTime)
-		throttle = time.NewTicker(sleepTime)
+		e:           e,
+		protocolMap: protocolMap,
+		protocols:   protocols,
 	}
+}
 
-	// make the timeout apply to the entire set of requests
-	ctx, cancel := context.WithTimeout(ctx, i.timeout)
-	var canceled bool
-	defer func() {
-		cancel()
-		canceled = true
-	}()
-
-	sem := semaphore.NewWeighted(maxConcurrency)
-	for reqIndex := 0; reqIndex < i.count; reqIndex++ {
-		r := request{
-			RequestID:        reqIndex,
-			URL:              i.url,
-			Message:          i.message,
-			ExpectedResponse: i.expectedResponse,
-			Header:           i.header,
-			Timeout:          i.timeout,
-			ServerFirst:      i.serverFirst,
-			Method:           i.method,
-		}
-
-		if throttle != nil {
-			<-throttle.C
-		}
-
-		if err := sem.Acquire(ctx, 1); err != nil {
-			// this should only occur for a timeout, fallthrough to the ctx.Done() select case
-			break
-		}
-		g.Go(func() error {
-			defer sem.Release(1)
-			if canceled {
-				return fmt.Errorf("request set timed out")
-			}
-			st := time.Now()
-			resp, err := i.p.makeRequest(ctx, &r)
-			rt := time.Since(st)
-			if err != nil {
-				return err
-			}
-			responsesMu.Lock()
-			responses[r.RequestID] = resp
-			responseTimes[r.RequestID] = rt
-			responsesMu.Unlock()
-			return nil
-		})
+// ForwardEcho sends the requests and collect the responses.
+func (i *Instance) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	if err := cfg.fillDefaults(); err != nil {
+		return nil, err
 	}
 
-	requestsDone := make(chan *multierror.Error)
-	go func() {
-		requestsDone <- g.Wait()
-	}()
-
-	select {
-	case err := <-requestsDone:
-		if err != nil {
-			return nil, fmt.Errorf("%d/%d requests had errors; first error: %v", err.Len(), i.count, err.Errors[0])
-		}
-	case <-ctx.Done():
-		responsesMu.RLock()
-		defer responsesMu.RUnlock()
-		var c int
-		var tt time.Duration
-		for id, res := range responses {
-			if res != "" && responseTimes[id] != 0 {
-				c++
-				tt += responseTimes[id]
-			}
-		}
-		var avgTime time.Duration
-		if c > 0 {
-			avgTime = tt / time.Duration(c)
-		}
-		return nil, fmt.Errorf("request set timed out after %v and only %d/%d requests completed (%v avg)", i.timeout, c, i.count, avgTime)
+	// Lookup the protocol.
+	p := i.protocolMap[cfg.scheme]
+	if p == nil {
+		return nil, fmt.Errorf("no protocol handler found for scheme %s", cfg.scheme)
 	}
 
-	return &proto.ForwardEchoResponse{
-		Output: responses,
-	}, nil
+	return p.ForwardEcho(ctx, cfg)
 }
 
 func (i *Instance) Close() error {
-	if i != nil && i.p != nil {
-		return i.p.Close()
+	i.e.Close()
+
+	for _, p := range i.protocols {
+		_ = p.Close()
 	}
+
 	return nil
 }
diff --git a/pkg/test/echo/server/forwarder/protocol.go b/pkg/test/echo/server/forwarder/protocol.go
index eec6de6789..39c1ba239e 100644
--- a/pkg/test/echo/server/forwarder/protocol.go
+++ b/pkg/test/echo/server/forwarder/protocol.go
@@ -18,48 +18,11 @@
 
 import (
 	"context"
-	"fmt"
-	"net/http"
-	"time"
 
-	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
-
-	"istio.io/istio/pkg/test/echo/common/scheme"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
-type request struct {
-	URL              string
-	Header           http.Header
-	RequestID        int
-	Message          string
-	ExpectedResponse *wrappers.StringValue
-	Timeout          time.Duration
-	ServerFirst      bool
-	Method           string
-}
-
 type protocol interface {
-	makeRequest(ctx context.Context, req *request) (string, error)
+	ForwardEcho(ctx context.Context, c *Config) (*proto.ForwardEchoResponse, error)
 	Close() error
 }
-
-func newProtocol(cfg *Config) (protocol, error) {
-	switch cfg.scheme {
-	case scheme.HTTP, scheme.HTTPS:
-		return newHTTPProtocol(cfg)
-	case scheme.GRPC:
-		return newGRPCProtocol(cfg)
-	case scheme.XDS:
-		return newXDSProtocol(cfg)
-	case scheme.WebSocket:
-		return newWebsocketProtocol(cfg)
-	case scheme.DNS:
-		return &dnsProtocol{}, nil
-	case scheme.TCP:
-		return newTCPProtocol(cfg)
-	case scheme.TLS:
-		return newTLSProtocol(cfg)
-	default:
-		return nil, fmt.Errorf("unrecognized protocol %q", cfg.scheme)
-	}
-}
diff --git a/pkg/test/echo/server/forwarder/tcp.go b/pkg/test/echo/server/forwarder/tcp.go
index c4efec4d70..71e3955ee6 100644
--- a/pkg/test/echo/server/forwarder/tcp.go
+++ b/pkg/test/echo/server/forwarder/tcp.go
@@ -27,47 +27,39 @@
 
 	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &tcpProtocol{}
 
 type tcpProtocol struct {
-	// conn returns a new connection. This is not just a shared connection as we will
-	// not re-use the connection for multiple requests with TCP
-	conn func() (net.Conn, error)
+	e *executor
 }
 
-func newTCPProtocol(r *Config) (protocol, error) {
-	return &tcpProtocol{
-		conn: func() (net.Conn, error) {
-			address := r.Request.Url[len(r.scheme+"://"):]
-
-			if r.getClientCertificate == nil {
-				ctx, cancel := context.WithTimeout(context.Background(), common.ConnectionTimeout)
-				defer cancel()
-				return newDialer().DialContext(ctx, "tcp", address)
-			}
-			return tls.DialWithDialer(newDialer(), "tcp", address, r.tlsConfig)
-		},
-	}, nil
+func newTCPProtocol(e *executor) protocol {
+	return &tcpProtocol{e: e}
 }
 
-func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	conn, err := c.conn()
+func (c *tcpProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	return doForward(ctx, cfg, c.e, c.makeRequest)
+}
+
+func (c *tcpProtocol) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	conn, err := newTCPConnection(cfg)
 	if err != nil {
 		return "", err
 	}
 	defer func() { _ = conn.Close() }()
 
 	msgBuilder := strings.Builder{}
-	msgBuilder.WriteString(fmt.Sprintf("[%d] Url=%s\n", req.RequestID, req.URL))
+	echo.ForwarderURLField.WriteForRequest(&msgBuilder, requestID, cfg.Request.Url)
 
-	if req.Message != "" {
-		msgBuilder.WriteString(fmt.Sprintf("[%d] Echo=%s\n", req.RequestID, req.Message))
+	if cfg.Request.Message != "" {
+		echo.ForwarderMessageField.WriteForRequest(&msgBuilder, requestID, cfg.Request.Message)
 	}
 
 	// Apply per-request timeout to calculate deadline for reads/writes.
-	ctx, cancel := context.WithTimeout(ctx, req.Timeout)
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
 	defer cancel()
 
 	// Apply the deadline to the connection.
@@ -80,7 +72,7 @@ func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, er
 	}
 
 	// For server first protocol, we expect the server to send us the magic string first
-	if req.ServerFirst {
+	if cfg.Request.ServerFirst {
 		readBytes, err := bufio.NewReader(conn).ReadBytes('\n')
 		if err != nil {
 			fwLog.Warnf("server first TCP read failed: %v", err)
@@ -93,8 +85,8 @@ func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, er
 
 	// Make sure the client writes something to the buffer
 	message := "HelloWorld"
-	if req.Message != "" {
-		message = req.Message
+	if cfg.Request.Message != "" {
+		message = cfg.Request.Message
 	}
 
 	if _, err := conn.Write([]byte(message + "\n")); err != nil {
@@ -119,14 +111,14 @@ func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, er
 	// format the output for forwarder response
 	for _, line := range strings.Split(resBuffer.String(), "\n") {
 		if line != "" {
-			msgBuilder.WriteString(fmt.Sprintf("[%d body] %s\n", req.RequestID, line))
+			echo.WriteBodyLine(&msgBuilder, requestID, line)
 		}
 	}
 
 	msg := msgBuilder.String()
 	expected := fmt.Sprintf("%s=%d", string(echo.StatusCodeField), http.StatusOK)
-	if req.ExpectedResponse != nil {
-		expected = req.ExpectedResponse.GetValue()
+	if cfg.Request.ExpectedResponse != nil {
+		expected = cfg.Request.ExpectedResponse.GetValue()
 	}
 	if !strings.Contains(msg, expected) {
 		return msg, fmt.Errorf("expect to recv message with %s, got %s. Return EOF", expected, msg)
@@ -137,3 +129,15 @@ func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, er
 func (c *tcpProtocol) Close() error {
 	return nil
 }
+
+func newTCPConnection(cfg *Config) (net.Conn, error) {
+	address := cfg.Request.Url[len(cfg.scheme+"://"):]
+
+	if cfg.secure {
+		return tls.DialWithDialer(newDialer(cfg.forceDNSLookup), "tcp", address, cfg.tlsConfig)
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), common.ConnectionTimeout)
+	defer cancel()
+	return newDialer(cfg.forceDNSLookup).DialContext(ctx, "tcp", address)
+}
diff --git a/pkg/test/echo/server/forwarder/tls.go b/pkg/test/echo/server/forwarder/tls.go
index b50ce9a211..6015ddf40e 100644
--- a/pkg/test/echo/server/forwarder/tls.go
+++ b/pkg/test/echo/server/forwarder/tls.go
@@ -20,41 +20,37 @@
 	"encoding/pem"
 	"fmt"
 	"strings"
+	"time"
+
+	"istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &tlsProtocol{}
 
 type tlsProtocol struct {
-	// conn returns a new connection. This is not just a shared connection as we will
-	// not re-use the connection for multiple requests with TCP
-	conn func() (*tls.Conn, error)
+	e *executor
+}
+
+func newTLSProtocol(e *executor) protocol {
+	return &tlsProtocol{e: e}
 }
 
-func newTLSProtocol(r *Config) (protocol, error) {
-	return &tlsProtocol{
-		conn: func() (*tls.Conn, error) {
-			address := r.Request.Url[len(r.scheme+"://"):]
-
-			con, err := tls.DialWithDialer(newDialer(), "tcp", address, r.tlsConfig)
-			if err != nil {
-				return nil, err
-			}
-			return con, nil
-		},
-	}, nil
+func (c *tlsProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	return doForward(ctx, cfg, c.e, c.makeRequest)
 }
 
-func (c *tlsProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	conn, err := c.conn()
+func (c *tlsProtocol) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	conn, err := newTLSConnection(cfg)
 	if err != nil {
 		return "", err
 	}
 	defer func() { _ = conn.Close() }()
 	msgBuilder := strings.Builder{}
-	msgBuilder.WriteString(fmt.Sprintf("[%d] Url=%s\n", req.RequestID, req.URL))
+	echo.ForwarderURLField.WriteForRequest(&msgBuilder, requestID, cfg.Request.Url)
 
 	// Apply per-request timeout to calculate deadline for reads/writes.
-	ctx, cancel := context.WithTimeout(ctx, req.Timeout)
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
 	defer cancel()
 
 	// Apply the deadline to the connection.
@@ -71,25 +67,28 @@ func (c *tlsProtocol) makeRequest(ctx context.Context, req *request) (string, er
 	}
 	// Make sure the client writes something to the buffer
 	message := "HelloWorld"
-	if req.Message != "" {
-		message = req.Message
+	if cfg.Request.Message != "" {
+		message = cfg.Request.Message
 	}
+
+	start := time.Now()
 	if _, err := conn.Write([]byte(message + "\n")); err != nil {
 		fwLog.Warnf("TCP write failed: %v", err)
 		return msgBuilder.String(), err
 	}
 
 	cs := conn.ConnectionState()
-	msgBuilder.WriteString(fmt.Sprintf("[%d] Cipher=%s\n", req.RequestID, tls.CipherSuiteName(cs.CipherSuite)))
-	msgBuilder.WriteString(fmt.Sprintf("[%d] Version=%s\n", req.RequestID, versionName(cs.Version)))
-	msgBuilder.WriteString(fmt.Sprintf("[%d] ServerName=%s\n", req.RequestID, cs.ServerName))
-	msgBuilder.WriteString(fmt.Sprintf("[%d] Alpn=%s\n", req.RequestID, cs.NegotiatedProtocol))
+	echo.LatencyField.WriteForRequest(&msgBuilder, requestID, fmt.Sprintf("%v", time.Since(start)))
+	echo.CipherField.WriteForRequest(&msgBuilder, requestID, tls.CipherSuiteName(cs.CipherSuite))
+	echo.TLSVersionField.WriteForRequest(&msgBuilder, requestID, versionName(cs.Version))
+	echo.TLSServerName.WriteForRequest(&msgBuilder, requestID, cs.ServerName)
+	echo.AlpnField.WriteForRequest(&msgBuilder, requestID, cs.NegotiatedProtocol)
 	for n, i := range cs.PeerCertificates {
 		pemBlock := pem.Block{
 			Type:  "CERTIFICATE",
 			Bytes: i.Raw,
 		}
-		msgBuilder.WriteString(fmt.Sprintf("[%d body] Response%d=%q\n", req.RequestID, n, string(pem.EncodeToMemory(&pemBlock))))
+		echo.WriteBodyLine(&msgBuilder, requestID, fmt.Sprintf("Response%d=%q", n, string(pem.EncodeToMemory(&pemBlock))))
 	}
 
 	msg := msgBuilder.String()
@@ -114,3 +113,13 @@ func versionName(v uint16) string {
 func (c *tlsProtocol) Close() error {
 	return nil
 }
+
+func newTLSConnection(cfg *Config) (*tls.Conn, error) {
+	address := cfg.Request.Url[len(cfg.scheme+"://"):]
+
+	con, err := tls.DialWithDialer(newDialer(cfg.forceDNSLookup), "tcp", address, cfg.tlsConfig)
+	if err != nil {
+		return nil, err
+	}
+	return con, nil
+}
diff --git a/pkg/test/echo/server/forwarder/util.go b/pkg/test/echo/server/forwarder/util.go
index eac94df5e3..95afda4cba 100644
--- a/pkg/test/echo/server/forwarder/util.go
+++ b/pkg/test/echo/server/forwarder/util.go
@@ -20,9 +20,14 @@
 	"fmt"
 	"net"
 	"net/http"
+	"sync"
 	"time"
 
+	"github.com/hashicorp/go-multierror"
+
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
+	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/pkg/log"
 )
 
@@ -32,24 +37,22 @@
 
 var fwLog = log.RegisterScope("forwarder", "echo clientside", 0)
 
-func writeHeaders(requestID int, header http.Header, outBuffer bytes.Buffer, addFn func(string, string)) {
+func writeForwardedHeaders(out *bytes.Buffer, requestID int, header http.Header) {
 	for key, values := range header {
 		for _, v := range values {
-			addFn(key, v)
-			if key == hostHeader {
-				outBuffer.WriteString(fmt.Sprintf("[%d] Host=%s\n", requestID, v))
-			} else {
-				outBuffer.WriteString(fmt.Sprintf("[%d] Header=%s:%s\n", requestID, key, v))
-			}
+			echo.ForwarderHeaderField.WriteKeyValueForRequest(out, requestID, key, v)
 		}
 	}
 }
 
-func newDialer() *net.Dialer {
-	return &net.Dialer{
-		Timeout:  common.ConnectionTimeout,
-		Resolver: newResolver(common.ConnectionTimeout, "", ""),
+func newDialer(forceDNSLookup bool) *net.Dialer {
+	out := &net.Dialer{
+		Timeout: common.ConnectionTimeout,
 	}
+	if forceDNSLookup {
+		out.Resolver = newResolver(common.ConnectionTimeout, "", "")
+	}
+	return out
 }
 
 func newResolver(timeout time.Duration, protocol, dnsServer string) *net.Resolver {
@@ -71,3 +74,83 @@ func newResolver(timeout time.Duration, protocol, dnsServer string) *net.Resolve
 		},
 	}
 }
+
+// doForward sends the requests and collect the responses.
+func doForward(ctx context.Context, cfg *Config, e *executor, doReq func(context.Context, *Config, int) (string, error)) (*proto.ForwardEchoResponse, error) {
+	if err := cfg.fillDefaults(); err != nil {
+		return nil, err
+	}
+
+	// make the timeout apply to the entire set of requests
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
+	defer cancel()
+
+	responses := make([]string, cfg.count)
+	responseTimes := make([]time.Duration, cfg.count)
+	var responsesMu sync.Mutex
+
+	var throttle *time.Ticker
+	qps := int(cfg.Request.Qps)
+	if qps > 0 {
+		sleepTime := time.Second / time.Duration(qps)
+		fwLog.Debugf("Sleeping %v between requests", sleepTime)
+		throttle = time.NewTicker(sleepTime)
+	}
+
+	g := e.NewGroup()
+	for index := 0; index < cfg.count; index++ {
+		index := index
+		if throttle != nil {
+			<-throttle.C
+		}
+
+		g.Go(ctx, func() error {
+			st := time.Now()
+			resp, err := doReq(ctx, cfg, index)
+			if err != nil {
+				return err
+			}
+
+			responsesMu.Lock()
+			responses[index] = resp
+			responseTimes[index] = time.Since(st)
+			responsesMu.Unlock()
+			return nil
+		})
+	}
+
+	// Convert the result of the wait into a channel.
+	requestsDone := make(chan *multierror.Error)
+	go func() {
+		requestsDone <- g.Wait()
+	}()
+
+	select {
+	case merr := <-requestsDone:
+		if err := merr.ErrorOrNil(); err != nil {
+			return nil, fmt.Errorf("%d/%d requests had errors; first error: %v", merr.Len(), cfg.count, merr.Errors[0])
+		}
+
+		return &proto.ForwardEchoResponse{
+			Output: responses,
+		}, nil
+	case <-ctx.Done():
+		responsesMu.Lock()
+		defer responsesMu.Unlock()
+
+		var c int
+		var tt time.Duration
+		for id, res := range responses {
+			if res != "" && responseTimes[id] != 0 {
+				c++
+				tt += responseTimes[id]
+			}
+		}
+		var avgTime time.Duration
+		if c > 0 {
+			avgTime = tt / time.Duration(c)
+		}
+		return nil, fmt.Errorf("request set timed out after %v and only %d/%d requests completed (%v avg)",
+			cfg.timeout, c, cfg.count, avgTime)
+	}
+}
diff --git a/pkg/test/echo/server/forwarder/websocket.go b/pkg/test/echo/server/forwarder/websocket.go
index e1f41cb740..1ccff2023d 100644
--- a/pkg/test/echo/server/forwarder/websocket.go
+++ b/pkg/test/echo/server/forwarder/websocket.go
@@ -19,56 +19,67 @@
 	"context"
 	"fmt"
 	"net"
-	"net/http"
 	"strings"
+	"time"
 
 	"github.com/gorilla/websocket"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &websocketProtocol{}
 
 type websocketProtocol struct {
-	*Config
+	e *executor
 }
 
-func newWebsocketProtocol(r *Config) (protocol, error) {
-	return &websocketProtocol{
-		Config: r,
-	}, nil
+func newWebsocketProtocol(e *executor) protocol {
+	return &websocketProtocol{e: e}
 }
 
-func (c *websocketProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	wsReq := make(http.Header)
+func (c *websocketProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	return doForward(ctx, cfg, c.e, c.makeRequest)
+}
+
+func (c *websocketProtocol) Close() error {
+	return nil
+}
 
+func (c *websocketProtocol) makeRequest(ctx context.Context, cfg *Config, requestID int) (string, error) {
+	req := cfg.Request
 	var outBuffer bytes.Buffer
-	outBuffer.WriteString(fmt.Sprintf("[%d] Url=%s\n", req.RequestID, req.URL))
-	writeHeaders(req.RequestID, req.Header, outBuffer, wsReq.Add)
+	echo.ForwarderURLField.WriteForRequest(&outBuffer, requestID, req.Url)
 
 	// Set the special header to trigger the upgrade to WebSocket.
+	wsReq := cfg.headers.Clone()
+	if len(cfg.hostHeader) > 0 {
+		echo.HostField.WriteForRequest(&outBuffer, requestID, hostHeader)
+	}
+	writeForwardedHeaders(&outBuffer, requestID, wsReq)
 	common.SetWebSocketHeader(wsReq)
 
 	if req.Message != "" {
-		outBuffer.WriteString(fmt.Sprintf("[%d] Echo=%s\n", req.RequestID, req.Message))
+		echo.ForwarderMessageField.WriteForRequest(&outBuffer, requestID, req.Message)
 	}
 
 	dialContext := func(network, addr string) (net.Conn, error) {
-		return newDialer().Dial(network, addr)
+		return newDialer(cfg.forceDNSLookup).Dial(network, addr)
 	}
-	if len(c.UDS) > 0 {
+	if len(cfg.UDS) > 0 {
 		dialContext = func(network, addr string) (net.Conn, error) {
-			return newDialer().Dial("unix", c.UDS)
+			return newDialer(cfg.forceDNSLookup).Dial("unix", cfg.UDS)
 		}
 	}
 
 	dialer := &websocket.Dialer{
-		TLSClientConfig:  c.tlsConfig,
+		TLSClientConfig:  cfg.tlsConfig,
 		NetDial:          dialContext,
-		HandshakeTimeout: c.timeout,
+		HandshakeTimeout: cfg.timeout,
 	}
 
-	conn, _, err := dialer.Dial(req.URL, wsReq)
+	conn, _, err := dialer.Dial(req.Url, wsReq)
 	if err != nil {
 		// timeout or bad handshake
 		return outBuffer.String(), err
@@ -78,7 +89,7 @@ func (c *websocketProtocol) makeRequest(ctx context.Context, req *request) (stri
 	}()
 
 	// Apply per-request timeout to calculate deadline for reads/writes.
-	ctx, cancel := context.WithTimeout(ctx, req.Timeout)
+	ctx, cancel := context.WithTimeout(ctx, cfg.timeout)
 	defer cancel()
 
 	// Apply the deadline to the connection.
@@ -90,6 +101,7 @@ func (c *websocketProtocol) makeRequest(ctx context.Context, req *request) (stri
 		return outBuffer.String(), err
 	}
 
+	start := time.Now()
 	err = conn.WriteMessage(websocket.TextMessage, []byte(req.Message))
 	if err != nil {
 		return outBuffer.String(), err
@@ -100,15 +112,13 @@ func (c *websocketProtocol) makeRequest(ctx context.Context, req *request) (stri
 		return outBuffer.String(), err
 	}
 
+	echo.LatencyField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%v", time.Since(start)))
+	echo.ActiveRequestsField.WriteForRequest(&outBuffer, requestID, fmt.Sprintf("%d", c.e.ActiveRequests()))
 	for _, line := range strings.Split(string(resp), "\n") {
 		if line != "" {
-			outBuffer.WriteString(fmt.Sprintf("[%d body] %s\n", req.RequestID, line))
+			echo.WriteBodyLine(&outBuffer, requestID, line)
 		}
 	}
 
 	return outBuffer.String(), nil
 }
-
-func (c *websocketProtocol) Close() error {
-	return nil
-}
diff --git a/pkg/test/echo/server/forwarder/xds.go b/pkg/test/echo/server/forwarder/xds.go
index c6a6ddba6e..691607c141 100644
--- a/pkg/test/echo/server/forwarder/xds.go
+++ b/pkg/test/echo/server/forwarder/xds.go
@@ -24,17 +24,55 @@
 	xdsresolver "google.golang.org/grpc/xds"
 
 	"istio.io/istio/pkg/test/echo/common"
+	"istio.io/istio/pkg/test/echo/proto"
 )
 
 var _ protocol = &grpcProtocol{}
 
 type xdsProtocol struct {
-	conn *grpc.ClientConn
+	e *executor
 }
 
-func newXDSProtocol(r *Config) (protocol, error) {
+func newXDSProtocol(e *executor) protocol {
+	return &xdsProtocol{e: e}
+}
+
+func (c *xdsProtocol) ForwardEcho(ctx context.Context, cfg *Config) (*proto.ForwardEchoResponse, error) {
+	var getConn grpcConnectionGetter
+	if cfg.newConnectionPerRequest {
+		// Create a new connection per request.
+		getConn = func() (*grpc.ClientConn, func(), error) {
+			conn, err := newXDSConnection(cfg)
+			if err != nil {
+				return nil, nil, err
+			}
+			return conn, func() { _ = conn.Close() }, nil
+		}
+	} else {
+		// Reuse the connection across all requests.
+		conn, err := newXDSConnection(cfg)
+		if err != nil {
+			return nil, err
+		}
+		defer func() { _ = conn.Close() }()
+		getConn = func() (*grpc.ClientConn, func(), error) {
+			return conn, func() {}, nil
+		}
+	}
+
+	call := grpcCall{
+		e:       c.e,
+		getConn: getConn,
+	}
+	return doForward(ctx, cfg, c.e, call.makeRequest)
+}
+
+func (c *xdsProtocol) Close() error {
+	return nil
+}
+
+func newXDSConnection(cfg *Config) (*grpc.ClientConn, error) {
 	var opts []grpc.DialOption
-	// grpc-go sets incorrect authority header
 
 	// transport security
 	creds, err := xds.NewClientCredentials(xds.ClientOptions{FallbackCreds: insecure.NewCredentials()})
@@ -42,38 +80,23 @@ func newXDSProtocol(r *Config) (protocol, error) {
 		return nil, err
 	}
 	security := grpc.WithTransportCredentials(creds)
-	if len(r.XDSTestBootstrap) > 0 {
-		r, err := xdsresolver.NewXDSResolverWithConfigForTesting(r.XDSTestBootstrap)
+	if len(cfg.XDSTestBootstrap) > 0 {
+		r, err := xdsresolver.NewXDSResolverWithConfigForTesting(cfg.XDSTestBootstrap)
 		if err != nil {
 			return nil, err
 		}
 		opts = append(opts, grpc.WithResolvers(r))
 	}
 
-	if r.getClientCertificate != nil {
-		security = grpc.WithTransportCredentials(credentials.NewTLS(r.tlsConfig))
+	if cfg.getClientCertificate != nil {
+		security = grpc.WithTransportCredentials(credentials.NewTLS(cfg.tlsConfig))
 	}
 
-	address := r.Request.Url
+	address := cfg.Request.Url
 
 	// Connect to the GRPC server.
 	ctx, cancel := context.WithTimeout(context.Background(), common.ConnectionTimeout)
 	defer cancel()
-	opts = append(opts, security, grpc.WithAuthority(r.headers.Get(hostHeader)))
-	conn, err := grpc.DialContext(ctx, address, opts...)
-	if err != nil {
-		return nil, err
-	}
-
-	return &xdsProtocol{
-		conn: conn,
-	}, nil
-}
-
-func (c *xdsProtocol) makeRequest(ctx context.Context, req *request) (string, error) {
-	return makeGRPCRequest(ctx, c.conn, req)
-}
-
-func (c *xdsProtocol) Close() error {
-	return c.conn.Close()
+	opts = append(opts, security, grpc.WithAuthority(cfg.hostHeader))
+	return grpc.DialContext(ctx, address, opts...)
 }
diff --git a/pkg/test/framework/components/echo/calloptions.go b/pkg/test/framework/components/echo/calloptions.go
index 8aaf2be338..92a7ba34f3 100644
--- a/pkg/test/framework/components/echo/calloptions.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -127,6 +127,17 @@ type CallOptions struct {
 	// Timeout used for each individual request. Must be > 0, otherwise 5 seconds is used.
 	Timeout time.Duration
 
+	// NewConnectionPerRequest if true, the forwarder will establish a new connection to the server for
+	// each individual request. If false, it will attempt to reuse the same connection for the duration
+	// of the forward call. This is ignored for DNS, TCP, and TLS protocols, as well as
+	// Headless/StatefulSet deployments.
+	NewConnectionPerRequest bool
+
+	// ForceDNSLookup if true, the forwarder will force a DNS lookup for each individual request. This is
+	// useful for any situation where DNS is used for load balancing (e.g. headless). This is ignored if
+	// NewConnectionPerRequest is false or if the deployment is Headless or StatefulSet.
+	ForceDNSLookup bool
+
 	// Retry options for the call.
 	Retry Retry
 
@@ -210,6 +221,9 @@ func (o *CallOptions) FillDefaults() error {
 		o.Count = common.DefaultCount
 	}
 
+	// Fill connection parameters based on scheme and workload type.
+	o.fillConnectionParams()
+
 	// Add any user-specified options after the default options (last option wins for each type of option).
 	o.Retry.Options = append(append([]retry.Option{}, DefaultCallRetryOptions()...), o.Retry.Options...)
 
@@ -228,6 +242,31 @@ func (o *CallOptions) FillDefaultsOrFail(t test.Failer) {
 	}
 }
 
+func (o *CallOptions) fillConnectionParams() {
+	// Overrides connection parameters for scheme.
+	switch o.Scheme {
+	case scheme.DNS:
+		o.NewConnectionPerRequest = true
+		o.ForceDNSLookup = true
+	case scheme.TCP, scheme.TLS, scheme.WebSocket:
+		o.NewConnectionPerRequest = true
+	}
+
+	// Override connection parameters for workload type.
+	if o.To != nil {
+		toCfg := o.To.Config()
+		if toCfg.IsHeadless() || toCfg.IsStatefulSet() {
+			// Headless uses DNS for load balancing. Force DNS lookup each time so
+			// that we get proper load balancing behavior.
+			o.NewConnectionPerRequest = true
+			o.ForceDNSLookup = true
+		}
+	}
+
+	// ForceDNSLookup only applies when using new connections per request.
+	o.ForceDNSLookup = o.NewConnectionPerRequest && o.ForceDNSLookup
+}
+
 func (o *CallOptions) fillAddress() error {
 	if o.Address == "" {
 		if o.To != nil {
diff --git a/pkg/test/framework/components/echo/common/call.go b/pkg/test/framework/components/echo/common/call.go
index 2be70e0c08..c7a7f56527 100644
--- a/pkg/test/framework/components/echo/common/call.go
+++ b/pkg/test/framework/components/echo/common/call.go
@@ -83,28 +83,36 @@ func callInternal(srcName string, from echo.Caller, opts echo.CallOptions, send
 	return result, err
 }
 
-func CallEcho(from echo.Caller, opts echo.CallOptions) (echo.CallResult, error) {
+type Caller struct {
+	f *forwarder.Instance
+}
+
+func NewCaller() *Caller {
+	return &Caller{
+		f: forwarder.New(),
+	}
+}
+
+func (c *Caller) Close() error {
+	return c.f.Close()
+}
+
+func (c *Caller) CallEcho(from echo.Caller, opts echo.CallOptions) (echo.CallResult, error) {
 	if err := opts.FillDefaults(); err != nil {
 		return echo.CallResult{}, err
 	}
 
 	send := func(req *proto.ForwardEchoRequest) (echoclient.Responses, error) {
-		instance, err := forwarder.New(forwarder.Config{
+		ctx, cancel := context.WithTimeout(context.Background(), opts.Timeout)
+		defer cancel()
+
+		ret, err := c.f.ForwardEcho(ctx, &forwarder.Config{
 			Request: req,
 			Proxy:   opts.HTTP.HTTPProxy,
 		})
 		if err != nil {
 			return nil, err
 		}
-		ctx, cancel := context.WithTimeout(context.Background(), opts.Timeout)
-		defer func() {
-			cancel()
-			_ = instance.Close()
-		}()
-		ret, err := instance.Run(ctx)
-		if err != nil {
-			return nil, err
-		}
 		resp := echoclient.ParseResponses(req, ret)
 		return resp, nil
 	}
@@ -113,26 +121,28 @@ func CallEcho(from echo.Caller, opts echo.CallOptions) (echo.CallResult, error)
 
 func newForwardRequest(opts echo.CallOptions) *proto.ForwardEchoRequest {
 	return &proto.ForwardEchoRequest{
-		Url:                getTargetURL(opts),
-		Count:              int32(opts.Count),
-		Headers:            common.HTTPToProtoHeaders(opts.HTTP.Headers),
-		TimeoutMicros:      common.DurationToMicros(opts.Timeout),
-		Message:            opts.Message,
-		ExpectedResponse:   opts.TCP.ExpectedResponse,
-		Http2:              opts.HTTP.HTTP2,
-		Http3:              opts.HTTP.HTTP3,
-		Method:             opts.HTTP.Method,
-		ServerFirst:        opts.Port.ServerFirst,
-		Cert:               opts.TLS.Cert,
-		Key:                opts.TLS.Key,
-		CaCert:             opts.TLS.CaCert,
-		CertFile:           opts.TLS.CertFile,
-		KeyFile:            opts.TLS.KeyFile,
-		CaCertFile:         opts.TLS.CaCertFile,
-		InsecureSkipVerify: opts.TLS.InsecureSkipVerify,
-		Alpn:               getProtoALPN(opts.TLS.Alpn),
-		FollowRedirects:    opts.HTTP.FollowRedirects,
-		ServerName:         opts.TLS.ServerName,
+		Url:                     getTargetURL(opts),
+		Count:                   int32(opts.Count),
+		Headers:                 common.HTTPToProtoHeaders(opts.HTTP.Headers),
+		TimeoutMicros:           common.DurationToMicros(opts.Timeout),
+		Message:                 opts.Message,
+		ExpectedResponse:        opts.TCP.ExpectedResponse,
+		Http2:                   opts.HTTP.HTTP2,
+		Http3:                   opts.HTTP.HTTP3,
+		Method:                  opts.HTTP.Method,
+		ServerFirst:             opts.Port.ServerFirst,
+		Cert:                    opts.TLS.Cert,
+		Key:                     opts.TLS.Key,
+		CaCert:                  opts.TLS.CaCert,
+		CertFile:                opts.TLS.CertFile,
+		KeyFile:                 opts.TLS.KeyFile,
+		CaCertFile:              opts.TLS.CaCertFile,
+		InsecureSkipVerify:      opts.TLS.InsecureSkipVerify,
+		Alpn:                    getProtoALPN(opts.TLS.Alpn),
+		FollowRedirects:         opts.HTTP.FollowRedirects,
+		ServerName:              opts.TLS.ServerName,
+		NewConnectionPerRequest: opts.NewConnectionPerRequest,
+		ForceDNSLookup:          opts.ForceDNSLookup,
 	}
 }
 
diff --git a/pkg/test/framework/components/echo/kube/instance.go b/pkg/test/framework/components/echo/kube/instance.go
index ca0ef4b142..296cccc36c 100644
--- a/pkg/test/framework/components/echo/kube/instance.go
+++ b/pkg/test/framework/components/echo/kube/instance.go
@@ -129,7 +129,7 @@ func (c *instance) Workloads() (echo.Workloads, error) {
 	if err != nil {
 		return nil, err
 	}
-	final := []echo.Workload{}
+	var final []echo.Workload
 	for _, wl := range wls {
 		filtered := false
 		for _, filter := range c.workloadFilter {
@@ -170,14 +170,6 @@ func (c *instance) Instances() echo.Instances {
 	return echo.Instances{c}
 }
 
-func (c *instance) firstClient() (*echoClient.Client, error) {
-	workloads, err := c.Workloads()
-	if err != nil {
-		return nil, err
-	}
-	return workloads[0].(*workload).Client()
-}
-
 func (c *instance) Close() (err error) {
 	return c.workloadMgr.Close()
 }
diff --git a/pkg/test/framework/components/echo/kube/workload.go b/pkg/test/framework/components/echo/kube/workload.go
index b3fa1ba69c..f5124b59c2 100644
--- a/pkg/test/framework/components/echo/kube/workload.go
+++ b/pkg/test/framework/components/echo/kube/workload.go
@@ -32,6 +32,7 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/errors"
 	"istio.io/istio/pkg/test/framework/resource"
+	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
 )
 
@@ -85,8 +86,8 @@ func (w *workload) Client() (c *echoClient.Client, err error) {
 	w.mutex.Lock()
 	c = w.client
 	if c == nil {
-		err = fmt.Errorf("attempt to use disconnected client for echo %s/%s",
-			w.pod.Namespace, w.pod.Name)
+		err = fmt.Errorf("attempt to use disconnected client for echo pod %s/%s (in cluster %s)",
+			w.pod.Namespace, w.pod.Name, w.cluster.Name())
 	}
 	w.mutex.Unlock()
 	return
@@ -102,6 +103,8 @@ func (w *workload) Update(pod kubeCore.Pod) error {
 			return err
 		}
 	} else if !isPodReady(pod) && w.isConnected() {
+		scopes.Framework.Infof("echo pod %s/%s (in cluster %s) transitioned to NOT READY. Pod Status=%s",
+			pod.Namespace, pod.Name, w.cluster.Name(), pod.Status)
 		w.pod = pod
 		return w.disconnect()
 	}
diff --git a/pkg/test/framework/components/istio/ingress.go b/pkg/test/framework/components/istio/ingress.go
index ccbca8baff..ec420b6121 100644
--- a/pkg/test/framework/components/istio/ingress.go
+++ b/pkg/test/framework/components/istio/ingress.go
@@ -18,6 +18,7 @@
 	"context"
 	"encoding/json"
 	"fmt"
+	"io"
 	"net"
 	"strconv"
 	"time"
@@ -52,6 +53,7 @@
 	getAddressDelay   = retry.BackoffDelay(500 * time.Millisecond)
 
 	_ ingress.Instance = &ingressImpl{}
+	_ io.Closer        = &ingressImpl{}
 )
 
 type ingressConfig struct {
@@ -79,6 +81,7 @@ func newIngress(ctx resource.Context, cfg ingressConfig) (i ingress.Instance) {
 		namespace:   cfg.Namespace,
 		env:         ctx.Environment().(*kube.Environment),
 		cluster:     ctx.Clusters().GetOrDefault(cfg.Cluster),
+		caller:      common.NewCaller(),
 	}
 	return c
 }
@@ -90,6 +93,11 @@ type ingressImpl struct {
 
 	env     *kube.Environment
 	cluster cluster.Cluster
+	caller  *common.Caller
+}
+
+func (c *ingressImpl) Close() error {
+	return c.caller.Close()
 }
 
 // getAddressInner returns the external address for the given port. When we don't have support for LoadBalancer,
@@ -229,7 +237,7 @@ func (c *ingressImpl) callEcho(opts echo.CallOptions) (echo.CallResult, error) {
 	if len(c.cluster.HTTPProxy()) > 0 {
 		opts.HTTP.HTTPProxy = c.cluster.HTTPProxy()
 	}
-	return common.CallEcho(c, opts)
+	return c.caller.CallEcho(c, opts)
 }
 
 func (c *ingressImpl) schemeFor(opts echo.CallOptions) (scheme.Instance, error) {
diff --git a/pkg/test/framework/components/istio/operator.go b/pkg/test/framework/components/istio/operator.go
index bffdff14b1..1df7b10008 100644
--- a/pkg/test/framework/components/istio/operator.go
+++ b/pkg/test/framework/components/istio/operator.go
@@ -157,12 +157,16 @@ func (i *operatorComponent) CustomIngressFor(c cluster.Cluster, serviceName, ist
 		i.ingress[c.Name()] = map[string]ingress.Instance{}
 	}
 	if _, ok := i.ingress[c.Name()][istioLabel]; !ok {
-		i.ingress[c.Name()][istioLabel] = newIngress(i.ctx, ingressConfig{
+		ingr := newIngress(i.ctx, ingressConfig{
 			Namespace:   i.settings.SystemNamespace,
 			Cluster:     c,
 			ServiceName: serviceName,
 			IstioLabel:  istioLabel,
 		})
+		if closer, ok := ingr.(io.Closer); ok {
+			i.ctx.Cleanup(func() { _ = closer.Close() })
+		}
+		i.ingress[c.Name()][istioLabel] = ingr
 	}
 	return i.ingress[c.Name()][istioLabel]
 }
-- 
2.35.3

