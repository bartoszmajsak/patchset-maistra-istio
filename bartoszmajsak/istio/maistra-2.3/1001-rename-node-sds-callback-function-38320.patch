From d681f7bca623d5bf19e6e16cddcc8be1035cd2eb Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Tue, 12 Apr 2022 01:31:15 +0800
Subject: rename node sds callback function (#38320)

* rename node sds callback function

* Update
---
 pkg/istio-agent/agent.go                      |  2 +-
 security/pkg/nodeagent/cache/secretcache.go   | 22 +++++++++----------
 .../pkg/nodeagent/cache/secretcache_test.go   |  2 +-
 security/pkg/nodeagent/sds/sdsservice_test.go |  2 +-
 security/pkg/nodeagent/sds/server.go          |  2 +-
 5 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/pkg/istio-agent/agent.go b/pkg/istio-agent/agent.go
index 6126da746f..e575422d89 100644
--- a/pkg/istio-agent/agent.go
+++ b/pkg/istio-agent/agent.go
@@ -505,7 +505,7 @@ func (a *Agent) initSdsServer() error {
 
 	pkpConf := a.proxyConfig.GetPrivateKeyProvider()
 	a.sdsServer = sds.NewServer(a.secOpts, a.secretCache, pkpConf)
-	a.secretCache.SetUpdateCallback(a.sdsServer.UpdateCallback)
+	a.secretCache.RegisterSecretHandler(a.sdsServer.OnSecretUpdate)
 
 	return nil
 }
diff --git a/security/pkg/nodeagent/cache/secretcache.go b/security/pkg/nodeagent/cache/secretcache.go
index 62d1473ed2..278a4b14bb 100644
--- a/security/pkg/nodeagent/cache/secretcache.go
+++ b/security/pkg/nodeagent/cache/secretcache.go
@@ -77,7 +77,7 @@
 // Callers are expected to only call GenerateSecret when a new certificate is required. Generally,
 // this should be done a single time at startup, then repeatedly when the certificate is near
 // expiration. To help users handle certificate expiration, any certificates created by the caClient
-// will be monitored; when they are near expiration the notifyCallback function is triggered,
+// will be monitored; when they are near expiration the secretHandler function is triggered,
 // prompting the client to call GenerateSecret again, if they still care about the certificate. For
 // files, this callback is instead triggered on any change to the file (triggering on expiration
 // would not be helpful, as all we can do is re-read the same file).
@@ -88,7 +88,7 @@ type SecretManagerClient struct {
 	configOptions *security.Options
 
 	// callback function to invoke when detecting secret change.
-	notifyCallback func(resourceName string)
+	secretHandler func(resourceName string)
 
 	// Cache of workload certificate and root certificate. File based certs are never cached, as
 	// lookup is cheap.
@@ -201,17 +201,17 @@ func (sc *SecretManagerClient) Close() {
 	close(sc.stop)
 }
 
-func (sc *SecretManagerClient) SetUpdateCallback(f func(resourceName string)) {
+func (sc *SecretManagerClient) RegisterSecretHandler(h func(resourceName string)) {
 	sc.certMutex.Lock()
 	defer sc.certMutex.Unlock()
-	sc.notifyCallback = f
+	sc.secretHandler = h
 }
 
-func (sc *SecretManagerClient) CallUpdateCallback(resourceName string) {
+func (sc *SecretManagerClient) OnSecretUpdate(resourceName string) {
 	sc.certMutex.RLock()
 	defer sc.certMutex.RUnlock()
-	if sc.notifyCallback != nil {
-		sc.notifyCallback(resourceName)
+	if sc.secretHandler != nil {
+		sc.secretHandler(resourceName)
 	}
 }
 
@@ -315,7 +315,7 @@ func (sc *SecretManagerClient) GenerateSecret(resourceName string) (secret *secu
 			cacheLog.Info("Root cert has changed, start rotating root cert")
 			// We store the oldRoot only for comparison and not for serving
 			sc.cache.SetRoot(ns.RootCert)
-			sc.CallUpdateCallback(security.RootCertReqResourceName)
+			sc.OnSecretUpdate(security.RootCertReqResourceName)
 		}
 	}
 
@@ -654,7 +654,7 @@ func (sc *SecretManagerClient) registerSecret(item security.SecretItem) {
 		// Clear the cache so the next call generates a fresh certificate
 		sc.cache.SetWorkload(nil)
 
-		sc.CallUpdateCallback(item.ResourceName)
+		sc.OnSecretUpdate(item.ResourceName)
 		return nil
 	}, delay)
 }
@@ -682,7 +682,7 @@ func (sc *SecretManagerClient) handleFileWatch() {
 			cacheLog.Infof("event for file certificate %s : %s, pushing to proxy", event.Name, event.Op.String())
 			for k := range resources {
 				if k.Filename == event.Name {
-					sc.CallUpdateCallback(k.ResourceName)
+					sc.OnSecretUpdate(k.ResourceName)
 				}
 			}
 			// If it is remove event - cleanup from file certs so that if it is added again, we can watch.
@@ -745,7 +745,7 @@ func (sc *SecretManagerClient) UpdateConfigTrustBundle(trustBundle []byte) error
 	}
 	sc.configTrustBundle = trustBundle
 	sc.configTrustBundleMutex.Unlock()
-	sc.CallUpdateCallback(security.RootCertReqResourceName)
+	sc.OnSecretUpdate(security.RootCertReqResourceName)
 	return nil
 }
 
diff --git a/security/pkg/nodeagent/cache/secretcache_test.go b/security/pkg/nodeagent/cache/secretcache_test.go
index 2062981d24..31663d89f5 100644
--- a/security/pkg/nodeagent/cache/secretcache_test.go
+++ b/security/pkg/nodeagent/cache/secretcache_test.go
@@ -51,7 +51,7 @@ func createCache(t *testing.T, caClient security.Client, notifyCb func(resourceN
 	if err != nil {
 		t.Fatal(err)
 	}
-	sc.SetUpdateCallback(notifyCb)
+	sc.RegisterSecretHandler(notifyCb)
 	t.Cleanup(sc.Close)
 	return sc
 }
diff --git a/security/pkg/nodeagent/sds/sdsservice_test.go b/security/pkg/nodeagent/sds/sdsservice_test.go
index 3d7685469a..b45406575a 100644
--- a/security/pkg/nodeagent/sds/sdsservice_test.go
+++ b/security/pkg/nodeagent/sds/sdsservice_test.go
@@ -80,7 +80,7 @@ func (s *TestServer) Connect() *xds.AdsTest {
 func (s *TestServer) UpdateSecret(name string, secret *ca2.SecretItem) {
 	s.t.Helper()
 	s.store.Set(name, secret)
-	s.server.UpdateCallback(name)
+	s.server.OnSecretUpdate(name)
 }
 
 type Expectation struct {
diff --git a/security/pkg/nodeagent/sds/server.go b/security/pkg/nodeagent/sds/server.go
index 4b6d0a49de..8239fa62e0 100644
--- a/security/pkg/nodeagent/sds/server.go
+++ b/security/pkg/nodeagent/sds/server.go
@@ -52,7 +52,7 @@ func NewServer(options *security.Options, workloadSecretCache security.SecretMan
 	return s
 }
 
-func (s *Server) UpdateCallback(resourceName string) {
+func (s *Server) OnSecretUpdate(resourceName string) {
 	if s.workloadSds == nil {
 		return
 	}
-- 
2.35.3

