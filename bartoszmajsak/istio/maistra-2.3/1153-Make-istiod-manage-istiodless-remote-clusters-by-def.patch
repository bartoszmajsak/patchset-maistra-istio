From 86184316a9c7cdd488d34f01279ea73ffb13812b Mon Sep 17 00:00:00 2001
From: Frank Budinsky <frankb@ca.ibm.com>
Date: Fri, 29 Apr 2022 12:20:45 -0400
Subject: Make istiod manage istiodless remote clusters by default (#38283)

* Make istiodless remotes the default

* test framework istiodless false by default

* fix comment

* regen values.yaml

* Guard webhook cert patching

* Remove webhook cert patch setup from bootstrap init

* fix lint

* suppress deploy eastwest gw

* Revert "suppress deploy eastwest gw"

This reverts commit cfe6df86d29945df837ecc07582c7bd73d5b00de.

* Revert "fix lint"

This reverts commit fd5be48b33a9c12cfd7c818f59935e98cabbf4ae.

* Put back patching in init
---
 .../charts/base/templates/endpoints.yaml      | 23 ++++-----
 manifests/charts/base/templates/services.yaml | 29 ++++-------
 .../istiod-remote/templates/endpoints.yaml    | 23 ++++-----
 .../istiod-remote/templates/services.yaml     | 29 ++++-------
 pilot/pkg/features/pilot.go                   |  2 +-
 .../kube/controller/multicluster.go           | 48 +++++++++----------
 .../framework/components/istio/operator.go    |  6 +--
 7 files changed, 63 insertions(+), 97 deletions(-)

diff --git a/manifests/charts/base/templates/endpoints.yaml b/manifests/charts/base/templates/endpoints.yaml
index fb4dd5efd3..2675b47a15 100644
--- a/manifests/charts/base/templates/endpoints.yaml
+++ b/manifests/charts/base/templates/endpoints.yaml
@@ -1,22 +1,13 @@
-{{- if .Values.global.remotePilotAddress }}
-  {{- if .Values.pilot.enabled }}
+{{- if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
+# if the remotePilotAddress is an IP addr
 apiVersion: v1
 kind: Endpoints
 metadata:
+  {{- if .Values.pilot.enabled }}
   name: istiod-remote
-  namespace: {{ .Release.Namespace }}
-subsets:
-- addresses:
-  - ip: {{ .Values.global.remotePilotAddress }}
-  ports:
-  - port: 15012
-    name: tcp-istiod
-    protocol: TCP
-  {{- else if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
-apiVersion: v1
-kind: Endpoints
-metadata:
+  {{- else }}
   name: istiod
+  {{- end }}
   namespace: {{ .Release.Namespace }}
 subsets:
 - addresses:
@@ -25,6 +16,8 @@ subsets:
   - port: 15012
     name: tcp-istiod
     protocol: TCP
-  {{- end }}
+  - port: 15017
+    name: tcp-webhook
+    protocol: TCP
 ---
 {{- end }}
diff --git a/manifests/charts/base/templates/services.yaml b/manifests/charts/base/templates/services.yaml
index 705c360019..2bc55e669b 100644
--- a/manifests/charts/base/templates/services.yaml
+++ b/manifests/charts/base/templates/services.yaml
@@ -1,37 +1,28 @@
 {{- if .Values.global.remotePilotAddress }}
-  {{- if .Values.pilot.enabled }}
-# when local istiod is enabled, we can't use istiod service name to reach the remote control plane
 apiVersion: v1
 kind: Service
 metadata:
+  {{- if .Values.pilot.enabled }}
+  # when local istiod is enabled, we can't use istiod service name to reach the remote control plane
   name: istiod-remote
-  namespace: {{ .Release.Namespace }}
-spec:
-  ports:
-  - port: 15012
-    name: tcp-istiod
-    protocol: TCP
-  clusterIP: None
   {{- else }}
-# when local istiod isn't enabled, we can use istiod service name to reach the remote control plane
-apiVersion: v1
-kind: Service
-metadata:
+  # when local istiod isn't enabled, we can use istiod service name to reach the remote control plane
   name: istiod
+  {{- end }}
   namespace: {{ .Release.Namespace }}
 spec:
   ports:
   - port: 15012
     name: tcp-istiod
     protocol: TCP
-  # if the remotePilotAddress is IP addr, we use clusterIP: None.
-  # else, we use externalName
-  {{- if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
-  clusterIP: None
-  {{- else }}
+  - port: 443
+    targetPort: 15017
+    name: tcp-webhook
+    protocol: TCP
+  {{- if not (regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress) }}
+  # if the remotePilotAddress is not an IP addr, we use ExternalName
   type: ExternalName
   externalName: {{ .Values.global.remotePilotAddress }}
   {{- end }}
-  {{- end }}
 ---
 {{- end }}
diff --git a/manifests/charts/istiod-remote/templates/endpoints.yaml b/manifests/charts/istiod-remote/templates/endpoints.yaml
index fb4dd5efd3..2675b47a15 100644
--- a/manifests/charts/istiod-remote/templates/endpoints.yaml
+++ b/manifests/charts/istiod-remote/templates/endpoints.yaml
@@ -1,22 +1,13 @@
-{{- if .Values.global.remotePilotAddress }}
-  {{- if .Values.pilot.enabled }}
+{{- if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
+# if the remotePilotAddress is an IP addr
 apiVersion: v1
 kind: Endpoints
 metadata:
+  {{- if .Values.pilot.enabled }}
   name: istiod-remote
-  namespace: {{ .Release.Namespace }}
-subsets:
-- addresses:
-  - ip: {{ .Values.global.remotePilotAddress }}
-  ports:
-  - port: 15012
-    name: tcp-istiod
-    protocol: TCP
-  {{- else if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
-apiVersion: v1
-kind: Endpoints
-metadata:
+  {{- else }}
   name: istiod
+  {{- end }}
   namespace: {{ .Release.Namespace }}
 subsets:
 - addresses:
@@ -25,6 +16,8 @@ subsets:
   - port: 15012
     name: tcp-istiod
     protocol: TCP
-  {{- end }}
+  - port: 15017
+    name: tcp-webhook
+    protocol: TCP
 ---
 {{- end }}
diff --git a/manifests/charts/istiod-remote/templates/services.yaml b/manifests/charts/istiod-remote/templates/services.yaml
index 705c360019..2bc55e669b 100644
--- a/manifests/charts/istiod-remote/templates/services.yaml
+++ b/manifests/charts/istiod-remote/templates/services.yaml
@@ -1,37 +1,28 @@
 {{- if .Values.global.remotePilotAddress }}
-  {{- if .Values.pilot.enabled }}
-# when local istiod is enabled, we can't use istiod service name to reach the remote control plane
 apiVersion: v1
 kind: Service
 metadata:
+  {{- if .Values.pilot.enabled }}
+  # when local istiod is enabled, we can't use istiod service name to reach the remote control plane
   name: istiod-remote
-  namespace: {{ .Release.Namespace }}
-spec:
-  ports:
-  - port: 15012
-    name: tcp-istiod
-    protocol: TCP
-  clusterIP: None
   {{- else }}
-# when local istiod isn't enabled, we can use istiod service name to reach the remote control plane
-apiVersion: v1
-kind: Service
-metadata:
+  # when local istiod isn't enabled, we can use istiod service name to reach the remote control plane
   name: istiod
+  {{- end }}
   namespace: {{ .Release.Namespace }}
 spec:
   ports:
   - port: 15012
     name: tcp-istiod
     protocol: TCP
-  # if the remotePilotAddress is IP addr, we use clusterIP: None.
-  # else, we use externalName
-  {{- if regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress }}
-  clusterIP: None
-  {{- else }}
+  - port: 443
+    targetPort: 15017
+    name: tcp-webhook
+    protocol: TCP
+  {{- if not (regexMatch "^([0-9]*\\.){3}[0-9]*$" .Values.global.remotePilotAddress) }}
+  # if the remotePilotAddress is not an IP addr, we use ExternalName
   type: ExternalName
   externalName: {{ .Values.global.remotePilotAddress }}
   {{- end }}
-  {{- end }}
 ---
 {{- end }}
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 63b0843b9f..1b42eebd76 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -384,7 +384,7 @@
 	ClusterName = env.RegisterStringVar("CLUSTER_ID", "Kubernetes",
 		"Defines the cluster and service registry that this Istiod instance is belongs to").Get()
 
-	ExternalIstiod = env.RegisterBoolVar("EXTERNAL_ISTIOD", false,
+	ExternalIstiod = env.RegisterBoolVar("EXTERNAL_ISTIOD", true,
 		"If this is set to true, one Istiod will control remote clusters including CA.").Get()
 
 	EnableCAServer = env.RegisterBoolVar("ENABLE_CA_SERVER", true,
diff --git a/pilot/pkg/serviceregistry/kube/controller/multicluster.go b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
index 6ef6aeeabf..17b83fe868 100644
--- a/pilot/pkg/serviceregistry/kube/controller/multicluster.go
+++ b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
@@ -36,7 +36,6 @@
 	kubelib "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/multicluster"
 	"istio.io/istio/pkg/webhooks"
-	"istio.io/istio/pkg/webhooks/validation/controller"
 )
 
 const (
@@ -206,7 +205,7 @@ func (m *Multicluster) ClusterAdded(cluster *multicluster.Cluster, clusterStopCh
 		m.s.RunComponentAsyncAndWait(func(_ <-chan struct{}) error {
 			log.Infof("joining leader-election for %s in %s on cluster %s",
 				leaderelection.NamespaceController, options.SystemNamespace, options.ClusterID)
-			leaderelection.
+			election := leaderelection.
 				NewLeaderElectionMulticluster(options.SystemNamespace, m.serverID, leaderelection.NamespaceController, m.revision, !localCluster, client).
 				AddRunFunction(func(leaderStop <-chan struct{}) {
 					log.Infof("starting namespace controller for cluster %s", cluster.ID)
@@ -218,40 +217,39 @@ func (m *Multicluster) ClusterAdded(cluster *multicluster.Cluster, clusterStopCh
 					// recreate it again.
 					client.RunAndWait(clusterStopCh)
 					nc.Run(leaderStop)
-				}).Run(clusterStopCh)
+				})
+			// Set up injection webhook patching for remote clusters we are controlling.
+			// The local cluster has this patching set up elsewhere. We may eventually want to move it here.
+			if features.ExternalIstiod && !localCluster && m.caBundleWatcher != nil {
+				// Patch injection webhook cert
+				// This requires RBAC permissions - a low-priv Istiod should not attempt to patch but rely on
+				// operator or CI/CD
+				if features.InjectionWebhookConfigName != "" {
+					election = election.
+						AddRunFunction(func(leaderStop <-chan struct{}) {
+							log.Infof("initializing webhook cert patch for cluster %s", cluster.ID)
+							patcher, err := webhooks.NewWebhookCertPatcher(client, m.revision, webhookName, m.caBundleWatcher)
+							if err != nil {
+								log.Errorf("could not initialize webhook cert patcher: %v", err)
+							} else {
+								patcher.Run(leaderStop)
+							}
+						})
+				}
+			}
+			election.Run(clusterStopCh)
 			return nil
 		})
 	}
 
-	// The local cluster has this patching set-up elsewhere. We may eventually want to move it here.
-	if features.ExternalIstiod && !localCluster && m.caBundleWatcher != nil {
-		// Patch injection webhook cert
-		// This requires RBAC permissions - a low-priv Istiod should not attempt to patch but rely on
-		// operator or CI/CD
-		if features.InjectionWebhookConfigName != "" {
-			// TODO prevent istiods in primary clusters from trying to patch eachother. should we also leader-elect?
-			log.Infof("initializing webhook cert patch for cluster %s", cluster.ID)
-			patcher, err := webhooks.NewWebhookCertPatcher(client, m.revision, webhookName, m.caBundleWatcher)
-			if err != nil {
-				log.Errorf("could not initialize webhook cert patcher: %v", err)
-			} else {
-				go patcher.Run(clusterStopCh)
-			}
-		}
-		// Patch validation webhook cert
-		go controller.NewValidatingWebhookController(client, m.revision, m.secretNamespace, m.caBundleWatcher).Run(clusterStopCh)
-
-	}
-
 	// setting up the serviceexport controller if and only if it is turned on in the meshconfig.
-	// TODO(nmittler): Need a better solution. Leader election doesn't take into account locality.
 	if features.EnableMCSAutoExport {
 		log.Infof("joining leader-election for %s in %s on cluster %s",
 			leaderelection.ServiceExportController, options.SystemNamespace, options.ClusterID)
 		// Block server exit on graceful termination of the leader controller.
 		m.s.RunComponentAsyncAndWait(func(_ <-chan struct{}) error {
 			leaderelection.
-				NewLeaderElection(options.SystemNamespace, m.serverID, leaderelection.ServiceExportController, m.revision, client).
+				NewLeaderElectionMulticluster(options.SystemNamespace, m.serverID, leaderelection.ServiceExportController, m.revision, !localCluster, client).
 				AddRunFunction(func(leaderStop <-chan struct{}) {
 					serviceExportController := newAutoServiceExportController(autoServiceExportOptions{
 						Client:       client,
diff --git a/pkg/test/framework/components/istio/operator.go b/pkg/test/framework/components/istio/operator.go
index 8ebefd6892..3b1d2849a2 100644
--- a/pkg/test/framework/components/istio/operator.go
+++ b/pkg/test/framework/components/istio/operator.go
@@ -528,9 +528,9 @@ func installControlPlaneCluster(s *resource.Settings, i *operatorComponent, cfg
 	}
 
 	if i.environment.IsMulticluster() {
-		if i.isExternalControlPlane() || cfg.IstiodlessRemotes {
-			// Enable namespace controller writing to remote clusters
-			installArgs.Set = append(installArgs.Set, "values.pilot.env.EXTERNAL_ISTIOD=true")
+		if !i.isExternalControlPlane() && !cfg.IstiodlessRemotes {
+			// Disable namespace controller writing to remote clusters
+			installArgs.Set = append(installArgs.Set, "values.pilot.env.EXTERNAL_ISTIOD=false")
 		}
 
 		// Set the clusterName for the local cluster.
-- 
2.35.3

