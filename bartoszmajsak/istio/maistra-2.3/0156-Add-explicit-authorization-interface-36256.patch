From a77af7803d4d325d4fa27f5a722753681b606a60 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Thu, 25 Nov 2021 21:10:20 +0800
Subject: Add explicit authorization interface (#36256)

---
 pilot/pkg/xds/ads.go                         | 38 +++-----------------
 pilot/pkg/xds/{authentication.go => auth.go} | 38 ++++++++++++++++++++
 pilot/pkg/xds/delta.go                       |  5 ++-
 pilot/pkg/xds/proxy_dependencies_test.go     |  7 ++--
 4 files changed, 49 insertions(+), 39 deletions(-)
 rename pilot/pkg/xds/{authentication.go => auth.go} (65%)

diff --git a/pilot/pkg/xds/ads.go b/pilot/pkg/xds/ads.go
index 13a04003fa..cf723a2f25 100644
--- a/pilot/pkg/xds/ads.go
+++ b/pilot/pkg/xds/ads.go
@@ -15,7 +15,6 @@
 package xds
 
 import (
-	"fmt"
 	"strconv"
 	"strings"
 	"sync/atomic"
@@ -37,7 +36,6 @@
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/spiffe"
 	"istio.io/pkg/env"
 	istiolog "istio.io/pkg/log"
 )
@@ -72,9 +70,6 @@ type Connection struct {
 	// PeerAddr is the address of the client, from network layer.
 	PeerAddr string
 
-	// Defines associated identities for the connection
-	Identities []string
-
 	// Time of connection, for debugging
 	Connect time.Time
 
@@ -304,7 +299,6 @@ func (s *DiscoveryServer) Stream(stream DiscoveryStream) error {
 		return status.Error(codes.Unavailable, "error reading config")
 	}
 	con := newConnection(peerAddr, stream)
-	con.Identities = ids
 
 	// Do not call: defer close(con.pushChannel). The push channel will be garbage collected
 	// when the connection is no longer used. Closing the channel can cause subtle race conditions
@@ -321,6 +315,10 @@ func (s *DiscoveryServer) Stream(stream DiscoveryStream) error {
 	// reqChannel and the connection not being enqueued for pushes to pushChannel until the
 	// initialization is complete.
 	<-con.initialized
+	// authorize client
+	if err = s.authorize(con, ids); err != nil {
+		return err
+	}
 
 	for {
 		select {
@@ -501,15 +499,6 @@ func (s *DiscoveryServer) initConnection(node *core.Node, con *Connection) error
 	con.ConID = connectionID(proxy.ID)
 	con.node = node
 	con.proxy = proxy
-	if features.EnableXDSIdentityCheck && con.Identities != nil {
-		// TODO: allow locking down, rejecting unauthenticated requests.
-		id, err := checkConnectionIdentity(con)
-		if err != nil {
-			log.Warnf("Unauthorized XDS: %v with identity %v: %v", con.PeerAddr, con.Identities, err)
-			return status.Newf(codes.PermissionDenied, "authorization failed: %v", err).Err()
-		}
-		con.proxy.VerifiedIdentity = id
-	}
 
 	// Register the connection. this allows pushes to be triggered for the proxy. Note: the timing of
 	// this and initializeProxy important. While registering for pushes *after* initialization is complete seems like
@@ -547,23 +536,6 @@ func (s *DiscoveryServer) closeConnection(con *Connection) {
 	s.WorkloadEntryController.QueueUnregisterWorkload(con.proxy, con.Connect)
 }
 
-func checkConnectionIdentity(con *Connection) (*spiffe.Identity, error) {
-	for _, rawID := range con.Identities {
-		spiffeID, err := spiffe.ParseIdentity(rawID)
-		if err != nil {
-			continue
-		}
-		if con.proxy.ConfigNamespace != "" && spiffeID.Namespace != con.proxy.ConfigNamespace {
-			continue
-		}
-		if con.proxy.Metadata.ServiceAccount != "" && spiffeID.ServiceAccount != con.proxy.Metadata.ServiceAccount {
-			continue
-		}
-		return &spiffeID, nil
-	}
-	return nil, fmt.Errorf("no identities (%v) matched %v/%v", con.Identities, con.proxy.ConfigNamespace, con.proxy.Metadata.ServiceAccount)
-}
-
 func connectionID(node string) string {
 	id := atomic.AddInt64(&connectionNumber, 1)
 	return node + "-" + strconv.FormatInt(id, 10)
@@ -1028,5 +1000,5 @@ func (conn *Connection) Watched(typeUrl string) *model.WatchedResource {
 }
 
 func (conn *Connection) Stop() {
-	conn.stop <- struct{}{}
+	close(conn.stop)
 }
diff --git a/pilot/pkg/xds/authentication.go b/pilot/pkg/xds/auth.go
similarity index 65%
rename from pilot/pkg/xds/authentication.go
rename to pilot/pkg/xds/auth.go
index 03948cc223..3fbe98e17d 100644
--- a/pilot/pkg/xds/authentication.go
+++ b/pilot/pkg/xds/auth.go
@@ -20,10 +20,14 @@
 	"fmt"
 	"strings"
 
+	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/credentials"
 	"google.golang.org/grpc/peer"
+	"google.golang.org/grpc/status"
 
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/spiffe"
 	"istio.io/pkg/env"
 )
 
@@ -65,3 +69,37 @@ func (s *DiscoveryServer) authenticate(ctx context.Context) ([]string, error) {
 	log.Errorf("Failed to authenticate client from %s: %s", peerInfo.Addr.String(), strings.Join(authFailMsgs, "; "))
 	return nil, errors.New("authentication failure")
 }
+
+func (s *DiscoveryServer) authorize(con *Connection, identities []string) error {
+	if con == nil || con.proxy == nil {
+		return nil
+	}
+
+	if features.EnableXDSIdentityCheck && identities != nil {
+		// TODO: allow locking down, rejecting unauthenticated requests.
+		id, err := checkConnectionIdentity(con.proxy, identities)
+		if err != nil {
+			log.Warnf("Unauthorized XDS: %v with identity %v: %v", con.PeerAddr, identities, err)
+			return status.Newf(codes.PermissionDenied, "authorization failed: %v", err).Err()
+		}
+		con.proxy.VerifiedIdentity = id
+	}
+	return nil
+}
+
+func checkConnectionIdentity(proxy *model.Proxy, identities []string) (*spiffe.Identity, error) {
+	for _, rawID := range identities {
+		spiffeID, err := spiffe.ParseIdentity(rawID)
+		if err != nil {
+			continue
+		}
+		if proxy.ConfigNamespace != "" && spiffeID.Namespace != proxy.ConfigNamespace {
+			continue
+		}
+		if proxy.Metadata.ServiceAccount != "" && spiffeID.ServiceAccount != proxy.Metadata.ServiceAccount {
+			continue
+		}
+		return &spiffeID, nil
+	}
+	return nil, fmt.Errorf("no identities (%v) matched %v/%v", identities, proxy.ConfigNamespace, proxy.Metadata.ServiceAccount)
+}
diff --git a/pilot/pkg/xds/delta.go b/pilot/pkg/xds/delta.go
index 262b0e36b6..69ff63455d 100644
--- a/pilot/pkg/xds/delta.go
+++ b/pilot/pkg/xds/delta.go
@@ -83,7 +83,6 @@ func (s *DiscoveryServer) StreamDeltas(stream DeltaDiscoveryStream) error {
 		return status.Error(codes.Unavailable, "error reading config")
 	}
 	con := newDeltaConnection(peerAddr, stream)
-	con.Identities = ids
 
 	// Do not call: defer close(con.pushChannel). The push channel will be garbage collected
 	// when the connection is no longer used. Closing the channel can cause subtle race conditions
@@ -100,6 +99,10 @@ func (s *DiscoveryServer) StreamDeltas(stream DeltaDiscoveryStream) error {
 	// reqChannel and the connection not being enqueued for pushes to pushChannel until the
 	// initialization is complete.
 	<-con.initialized
+	// authorize client
+	if err = s.authorize(con, ids); err != nil {
+		return err
+	}
 
 	for {
 		select {
diff --git a/pilot/pkg/xds/proxy_dependencies_test.go b/pilot/pkg/xds/proxy_dependencies_test.go
index b764064cd3..fe9f222507 100644
--- a/pilot/pkg/xds/proxy_dependencies_test.go
+++ b/pilot/pkg/xds/proxy_dependencies_test.go
@@ -250,11 +250,8 @@ func TestCheckConnectionIdentity(t *testing.T) {
 	}
 	for _, tt := range cases {
 		t.Run(tt.name, func(t *testing.T) {
-			con := &Connection{
-				proxy:      &model.Proxy{ConfigNamespace: tt.namespace, Metadata: &model.NodeMetadata{ServiceAccount: tt.sa}},
-				Identities: tt.identity,
-			}
-			if _, err := checkConnectionIdentity(con); (err == nil) != tt.success {
+			proxy := &model.Proxy{ConfigNamespace: tt.namespace, Metadata: &model.NodeMetadata{ServiceAccount: tt.sa}}
+			if _, err := checkConnectionIdentity(proxy, tt.identity); (err == nil) != tt.success {
 				t.Fatalf("expected success=%v, got err=%v", tt.success, err)
 			}
 		})
-- 
2.35.3

