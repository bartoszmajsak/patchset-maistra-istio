From 34d88379deaabc35231463663ac3738c5fff37a6 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 26 May 2022 14:20:56 -0700
Subject: [tf] Better echo call count default (#39150)

We currently have a number of places that attempt to reach all clusters by specifying a multipler on the number of workloads for the call target.

This PR generalizes this to apply a better default count when the call target is specified.
---
 .../framework/components/echo/calloptions.go  | 34 +++++++++++++--
 pkg/test/framework/components/echo/flags.go   |  9 ++++
 tests/integration/pilot/common/routing.go     |  7 ++--
 tests/integration/pilot/common/traffic.go     |  6 ---
 tests/integration/pilot/ingress_test.go       |  3 +-
 .../discoverability/discoverability_test.go   |  3 --
 .../pilot/multi_version_revision_test.go      |  3 +-
 tests/integration/pilot/multicluster_test.go  |  8 +---
 .../pilot/revisioned_upgrade_test.go          |  3 +-
 .../pilot/revisions/revisions_test.go         |  1 -
 tests/integration/pilot/vm_test.go            |  5 ++-
 .../security/authorization_test.go            | 29 +++++--------
 .../ca_custom_root/multi_root_test.go         |  3 +-
 .../ca_custom_root/secure_naming_test.go      |  4 --
 .../trust_domain_alias_secure_naming_test.go  |  3 +-
 .../trust_domain_validation_test.go           |  3 +-
 .../egress_gateway_origination_test.go        |  4 +-
 .../security/external_ca/reachability_test.go | 42 +++++++++----------
 .../file_mounted_certs/p2p_mtls_test.go       |  3 +-
 .../destination_rule_tls_test.go              |  3 +-
 .../egress_gateway_origination_test.go        |  3 +-
 .../security/https_jwt/https_jwt_test.go      |  1 -
 tests/integration/security/jwt_test.go        |  4 --
 .../security/normalization_test.go            |  3 +-
 .../pass_through_filter_chain_test.go         |  2 +-
 tests/integration/security/util/cert/cert.go  |  3 +-
 tests/integration/security/util/framework.go  |  3 --
 .../security/util/reachability/context.go     | 10 ++---
 tests/integration/telemetry/constants.go      | 24 -----------
 .../telemetry/outboundtrafficpolicy/helper.go |  3 +-
 .../telemetry/stackdriver/common.go           |  5 ---
 .../stackdriver_filter_audit_test.go          |  1 -
 .../stackdriver_tcp_filter_test.go            |  1 -
 .../customize_metrics_test.go                 | 10 ++---
 .../prometheus/nullvm/accesslogs_test.go      |  4 --
 .../telemetry/stats/prometheus/stats.go       |  5 ---
 .../integration/telemetry/tracing/tracing.go  |  2 -
 tests/util/sanitycheck/sanity_check.go        |  3 +-
 38 files changed, 112 insertions(+), 151 deletions(-)
 delete mode 100644 tests/integration/telemetry/constants.go

diff --git a/pkg/test/framework/components/echo/calloptions.go b/pkg/test/framework/components/echo/calloptions.go
index a430a159bd..57387354eb 100644
--- a/pkg/test/framework/components/echo/calloptions.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -121,7 +121,8 @@ type CallOptions struct {
 	Address string
 
 	// Count indicates the number of exchanges that should be made with the service endpoint.
-	// If Count <= 0, defaults to 1.
+	// If Count <= 0, a default will be selected. If To is specified, the value will be set to
+	// the numWorkloads * DefaultCallsPerWorkload. Otherwise, defaults to 1.
 	Count int
 
 	// Timeout used for each individual request. Must be > 0, otherwise 5 seconds is used.
@@ -217,9 +218,8 @@ func (o *CallOptions) FillDefaults() error {
 		o.Timeout = common.DefaultRequestTimeout
 	}
 
-	if o.Count <= 0 {
-		o.Count = common.DefaultCount
-	}
+	// Fill the number of calls to make.
+	o.fillCallCount()
 
 	// Fill connection parameters based on scheme and workload type.
 	o.fillConnectionParams()
@@ -242,6 +242,32 @@ func (o *CallOptions) FillDefaultsOrFail(t test.Failer) {
 	}
 }
 
+func (o *CallOptions) fillCallCount() {
+	if o.Count > 0 {
+		// Nothing to do.
+		return
+	}
+
+	o.Count = common.DefaultCount
+
+	// Try setting an appropriate count for the number of workloads.
+	newCount := DefaultCallsPerWorkload() * o.numWorkloads()
+	if newCount > o.Count {
+		o.Count = newCount
+	}
+}
+
+func (o *CallOptions) numWorkloads() int {
+	if o.To == nil {
+		return 0
+	}
+	workloads, err := o.To.Workloads()
+	if err != nil {
+		return 0
+	}
+	return len(workloads)
+}
+
 func (o *CallOptions) fillConnectionParams() {
 	// Overrides connection parameters for scheme.
 	switch o.Scheme {
diff --git a/pkg/test/framework/components/echo/flags.go b/pkg/test/framework/components/echo/flags.go
index f553f7fa23..7ec31ff859 100644
--- a/pkg/test/framework/components/echo/flags.go
+++ b/pkg/test/framework/components/echo/flags.go
@@ -26,6 +26,7 @@
 	callDelay        = 10 * time.Millisecond
 	callConverge     = 3
 	readinessTimeout = 10 * time.Minute
+	callsPerWorkload = 5
 )
 
 // init registers the command-line flags that we can exposed for "go test".
@@ -38,6 +39,9 @@ func init() {
 		"Specifies the number of successive retry attempts that must be successful when calling the Echo service")
 	flag.DurationVar(&readinessTimeout, "istio.test.echo.readinessTimeout", readinessTimeout,
 		"Specifies the default timeout for echo readiness check")
+	flag.IntVar(&callsPerWorkload, "istio.test.echo.callsPerWorkload", callsPerWorkload,
+		"Specifies the number of calls that will be made for each target workload. "+
+			"Only applies if the call count is zero (default) and a target was specified for the call")
 }
 
 // DefaultCallRetryOptions returns the default call retry options as specified in command-line flags.
@@ -49,3 +53,8 @@ func DefaultCallRetryOptions() []retry.Option {
 func DefaultReadinessTimeout() time.Duration {
 	return readinessTimeout
 }
+
+// DefaultCallsPerWorkload returns the number of calls that should be made per target workload by default.
+func DefaultCallsPerWorkload() int {
+	return callsPerWorkload
+}
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index f393f2ae26..ad85e507e7 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -1616,7 +1616,8 @@ function envoy_on_request(request_handle)
 			config: cfg,
 			call:   c.CallOrFail,
 			opts: echo.CallOptions{
-				To: t.Apps.B,
+				To:    t.Apps.B,
+				Count: 1,
 				Port: echo.Port{
 					Name: "http",
 				},
@@ -1666,7 +1667,8 @@ func hostCases(t TrafficContext) {
 				name: name,
 				call: c.CallOrFail,
 				opts: echo.CallOptions{
-					To: t.Apps.Headless,
+					To:    t.Apps.Headless,
+					Count: 1,
 					Port: echo.Port{
 						Name: "auto-http",
 					},
@@ -2619,7 +2621,6 @@ func VMTestCases(vms echo.Instances) func(t TrafficContext) {
 						Name: "http",
 					},
 					Address: c.host,
-					Count:   callCountMultiplier * c.to.MustWorkloads().Clusters().Len(),
 					Check:   checker,
 				},
 			})
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index fde422e982..0db608c9bb 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -33,9 +33,6 @@
 	"istio.io/istio/pkg/test/util/yml"
 )
 
-// callCountMultiplier is used to ensure cross-cluster load balancing has a chance to work
-const callCountMultiplier = 5
-
 type TrafficCall struct {
 	name string
 	call func(t test.Failer, options echo.CallOptions) echo.CallResult
@@ -154,9 +151,6 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 				if c.checkForN != nil {
 					opts.Check = c.checkForN(from, to, &opts)
 				}
-				if opts.Count == 0 {
-					opts.Count = callCountMultiplier * opts.To.WorkloadsOrFail(t).Len()
-				}
 				if c.setupOpts != nil {
 					c.setupOpts(from, &opts)
 				}
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index a5cf0b9a67..efed08aab1 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -219,7 +219,8 @@ func TestGateway(t *testing.T) {
 					})
 					t.NewSubTest("mesh").Run(func(t framework.TestContext) {
 						_ = apps.A[0].CallOrFail(t, echo.CallOptions{
-							To: apps.B,
+							To:    apps.B,
+							Count: 1,
 							Port: echo.Port{
 								Name: "http",
 							},
diff --git a/tests/integration/pilot/mcs/discoverability/discoverability_test.go b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
index b6d880f46c..8d5b7d7ef3 100644
--- a/tests/integration/pilot/mcs/discoverability/discoverability_test.go
+++ b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
@@ -63,8 +63,6 @@ func (ht hostType) String() string {
 const (
 	hostTypeClusterLocal    hostType = "cluster.local"
 	hostTypeClusterSetLocal hostType = "clusterset.local"
-
-	requestCountMultiplier = 20
 )
 
 var (
@@ -258,7 +256,6 @@ func callAndValidate(t framework.TestContext, ht hostType, from echo.Instance, t
 	_, err := from.Call(echo.CallOptions{
 		Address: address,
 		To:      to,
-		Count:   requestCountMultiplier * to.WorkloadsOrFail(t).Len(),
 		Port: echo.Port{
 			Name: "http",
 		},
diff --git a/tests/integration/pilot/multi_version_revision_test.go b/tests/integration/pilot/multi_version_revision_test.go
index da21091b86..395368cb0b 100644
--- a/tests/integration/pilot/multi_version_revision_test.go
+++ b/tests/integration/pilot/multi_version_revision_test.go
@@ -142,7 +142,8 @@ func testAllEchoCalls(t framework.TestContext, echoInstances []echo.Instance) {
 					Run(func(t framework.TestContext) {
 						retry.UntilSuccessOrFail(t, func() error {
 							result, err := from.Call(echo.CallOptions{
-								To: to,
+								To:    to,
+								Count: 1,
 								Port: echo.Port{
 									Name: trafficType,
 								},
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index fd74d5928b..67b4a09d42 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -35,8 +35,6 @@
 	"istio.io/istio/pkg/test/util/tmpl"
 )
 
-const multiclusterRequestCountMultiplier = 20
-
 var (
 	multiclusterRetryTimeout = retry.Timeout(1 * time.Minute)
 	multiclusterRetryDelay   = retry.Delay(500 * time.Millisecond)
@@ -122,8 +120,7 @@ func(t framework.TestContext) {
 						source := source
 						t.NewSubTest(source.Config().Cluster.StableName()).RunParallel(func(t framework.TestContext) {
 							source.CallOrFail(t, echo.CallOptions{
-								To:    to,
-								Count: multiclusterRequestCountMultiplier * to.WorkloadsOrFail(t).Clusters().Len(),
+								To: to,
 								Port: echo.Port{
 									Name: "http",
 								},
@@ -146,8 +143,7 @@ func(t framework.TestContext) {
 					source := source
 					t.NewSubTest(source.Config().Cluster.StableName()).Run(func(t framework.TestContext) {
 						source.CallOrFail(t, echo.CallOptions{
-							To:    to,
-							Count: multiclusterRequestCountMultiplier * to.WorkloadsOrFail(t).Clusters().Len(),
+							To: to,
 							Port: echo.Port{
 								Name: "http",
 							},
diff --git a/tests/integration/pilot/revisioned_upgrade_test.go b/tests/integration/pilot/revisioned_upgrade_test.go
index 198b7f7dba..b8b2f0c3d0 100644
--- a/tests/integration/pilot/revisioned_upgrade_test.go
+++ b/tests/integration/pilot/revisioned_upgrade_test.go
@@ -103,7 +103,8 @@ func testUpgradeFromVersion(t framework.TestContext, fromVersion string) {
 	g := traffic.NewGenerator(t, traffic.Config{
 		Source: apps.A[0],
 		Options: echo.CallOptions{
-			To: apps.B,
+			To:    apps.B,
+			Count: 1,
 			Port: echo.Port{
 				Name: "http",
 			},
diff --git a/tests/integration/pilot/revisions/revisions_test.go b/tests/integration/pilot/revisions/revisions_test.go
index 45e41b40ee..32c7d9d811 100644
--- a/tests/integration/pilot/revisions/revisions_test.go
+++ b/tests/integration/pilot/revisions/revisions_test.go
@@ -114,7 +114,6 @@ func TestMultiRevision(t *testing.T) {
 							Port: echo.Port{
 								Name: "http",
 							},
-							Count: 3 * to.WorkloadsOrFail(t).Len(),
 							Retry: echo.Retry{
 								NoRetry: true,
 							},
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 3b0bfe97fa..5810a59fc4 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -116,8 +116,9 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 			t.NewSubTest("initial registration").Run(func(t framework.TestContext) {
 				retry.UntilSuccessOrFail(t, func() error {
 					result, err := client.Call(echo.CallOptions{
-						To:   autoVM,
-						Port: autoVM.Config().Ports[0],
+						To:    autoVM,
+						Count: 1,
+						Port:  autoVM.Config().Ports[0],
 						Retry: echo.Retry{
 							NoRetry: true,
 						},
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 4f62594c6e..cba447dc44 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -61,7 +61,6 @@ func TestAuthorization_mTLS(t *testing.T) {
 					"Namespace2": apps.Namespace2.Name(),
 					"dst":        to.Config().Service,
 				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, apply.Wait)
-				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				for _, cluster := range t.Clusters() {
 					a := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
 					c := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace2)).GetMatches(apps.C)
@@ -80,7 +79,6 @@ func TestAuthorization_mTLS(t *testing.T) {
 									HTTP: echo.HTTP{
 										Path: path,
 									},
-									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -137,7 +135,6 @@ func TestAuthorization_JWT(t *testing.T) {
 
 					t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 						newTestCase := func(from echo.Instance, to echo.Target, namePrefix, jwt, path string, expectAllowed bool) func(t framework.TestContext) {
-							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
 									To: to,
@@ -148,7 +145,6 @@ func TestAuthorization_JWT(t *testing.T) {
 										Path:    path,
 										Headers: headers.New().WithAuthz(jwt).Build(),
 									},
-									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -231,7 +227,6 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 			newTestCase := func(from echo.Instance, to echo.Target, namePrefix, path string,
 				expectAllowed bool,
 			) func(t framework.TestContext) {
-				callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
 						To: to,
@@ -241,7 +236,6 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 						HTTP: echo.HTTP{
 							Path: path,
 						},
-						Count: callCount,
 					}
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -374,7 +368,6 @@ func TestAuthorization_Deny(t *testing.T) {
 
 				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-						callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
 								To: to,
@@ -384,7 +377,6 @@ func TestAuthorization_Deny(t *testing.T) {
 								HTTP: echo.HTTP{
 									Path: path,
 								},
-								Count: callCount,
 							}
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -474,7 +466,6 @@ type request struct {
 
 				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
 					newTestCaseWithRequest := func(from echo.Instance, to echo.Target, path string, expectAllowed bool, request request) func(t framework.TestContext) {
-						callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
 								To: to,
@@ -486,7 +477,6 @@ type request struct {
 									Method:  request.method,
 									Headers: headers.New().WithHost(request.host).Build(),
 								},
-								Count: callCount,
 							}
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -917,7 +907,8 @@ func TestAuthorization_TCP(t *testing.T) {
 			newTestCase := func(from echo.Instance, to echo.Target, s scheme.Instance, portName string, expectAllowed bool) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To: to,
+						To:    to,
+						Count: 1,
 						Port: echo.Port{
 							Name: portName,
 						},
@@ -1086,7 +1077,6 @@ func TestAuthorization_Conditions(t *testing.T) {
 
 							t.ConfigIstio().EvalFile("", args, "testdata/authz/v1beta1-conditions.yaml.tmpl").
 								ApplyOrFail(t)
-							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							newTestCase := func(from echo.Instance, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -1098,7 +1088,6 @@ func TestAuthorization_Conditions(t *testing.T) {
 											Path:    path,
 											Headers: headers,
 										},
-										Count: callCount,
 									}
 									if expectAllowed {
 										opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -1207,7 +1196,8 @@ func TestAuthorization_GRPC(t *testing.T) {
 							newTestCase := func(from echo.Instance, to echo.Target, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
-										To: to,
+										To:    to,
+										Count: 1,
 										Port: echo.Port{
 											Name: "grpc",
 										},
@@ -1264,7 +1254,6 @@ func TestAuthorization_Path(t *testing.T) {
 						t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-path.yaml.tmpl").ApplyOrFail(t, apply.Wait)
 
 						newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
 									To: to,
@@ -1274,7 +1263,6 @@ func TestAuthorization_Path(t *testing.T) {
 									HTTP: echo.HTTP{
 										Path: path,
 									},
-									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
@@ -1349,7 +1337,8 @@ func TestAuthorization_Audit(t *testing.T) {
 			) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To: to,
+						To:    to,
+						Count: 1,
 						Port: echo.Port{
 							Name: "http",
 						},
@@ -1480,7 +1469,8 @@ func TestAuthorization_Custom(t *testing.T) {
 			) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To: to,
+						To:    to,
+						Count: 1,
 						Port: echo.Port{
 							Name: port,
 						},
@@ -1576,7 +1566,8 @@ func TestAuthorization_Custom(t *testing.T) {
 				) func(t framework.TestContext) {
 					return func(t framework.TestContext) {
 						opts := echo.CallOptions{
-							To: to,
+							To:    to,
+							Count: 1,
 							Port: echo.Port{
 								Protocol: protocol.HTTP,
 							},
diff --git a/tests/integration/security/ca_custom_root/multi_root_test.go b/tests/integration/security/ca_custom_root/multi_root_test.go
index bdee750e31..5ea1782429 100644
--- a/tests/integration/security/ca_custom_root/multi_root_test.go
+++ b/tests/integration/security/ca_custom_root/multi_root_test.go
@@ -48,7 +48,8 @@ func TestMultiRootSetup(t *testing.T) {
 						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opts := echo.CallOptions{
-								To: to,
+								To:    to,
+								Count: 1,
 								Port: echo.Port{
 									Name: "https",
 								},
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 2572d118c6..8cd0848a4c 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -34,7 +34,6 @@
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/util/retry"
-	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/security/util/cert"
 	"istio.io/istio/tests/integration/security/util/scheck"
 )
@@ -116,7 +115,6 @@ func TestSecureNaming(t *testing.T) {
 				return checkCACert(t, testNamespace)
 			}, retry.Delay(time.Second), retry.Timeout(10*time.Second))
 			to := match.Namespace(testNamespace).GetMatches(apps.B)
-			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 			for _, cluster := range t.Clusters() {
 				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
 					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace)).GetMatches(apps.A)[0]
@@ -133,7 +131,6 @@ func TestSecureNaming(t *testing.T) {
 								Port: echo.Port{
 									Name: "http",
 								},
-								Count: callCount,
 							}
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 							a.CallOrFail(t, opts)
@@ -176,7 +173,6 @@ func TestSecureNaming(t *testing.T) {
 									Port: echo.Port{
 										Name: "http",
 									},
-									Count: callCount,
 								}
 								if tc.expectSuccess {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
diff --git a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
index 7c18858ac1..33ca5d22fe 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
@@ -85,7 +85,8 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 						t.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opts := echo.CallOptions{
-								To: to,
+								To:    to,
+								Count: 1,
 								Port: echo.Port{
 									Name: "https",
 								},
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index 3d14b577ea..6b329c34fe 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -126,7 +126,8 @@ func(ctx framework.TestContext) {
 						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opt := echo.CallOptions{
-								To: apps.Server,
+								To:    apps.Server,
+								Count: 1,
 								Port: echo.Port{
 									Name: port,
 								},
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index a827d0589a..edf6a7c954 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -39,7 +39,6 @@
 	"istio.io/istio/pkg/test/framework/resource"
 	ingressutil "istio.io/istio/tests/integration/security/sds_ingress/util"
 	sdstlsutil "istio.io/istio/tests/integration/security/sds_tls_origination/util"
-	"istio.io/istio/tests/integration/security/util"
 )
 
 // TestSimpleTlsOrigination test SIMPLE TLS mode with TLS origination happening at Gateway proxy
@@ -353,8 +352,7 @@ type TLSTestCase struct {
 
 func CallOpts(to echo.Target, host string, tc TLSTestCase) echo.CallOptions {
 	return echo.CallOptions{
-		To:    to,
-		Count: util.CallsPerCluster * to.MustWorkloads().Len(),
+		To: to,
 		Port: echo.Port{
 			Name: "http",
 		},
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index edb3832785..50a22c9e04 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -18,16 +18,15 @@
 package externalca
 
 import (
-	"fmt"
 	"testing"
 
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/check"
+	"istio.io/istio/pkg/test/framework/components/echo/echotest"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/security/util/scheck"
 )
 
@@ -50,28 +49,27 @@ func TestReachability(t *testing.T) {
 					"Istio Trust Domain")
 			}
 			istioCfg := istio.DefaultConfigOrFail(t, t)
-			testNamespace := apps.Namespace
 			namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
-			to := match.Namespace(testNamespace).GetMatches(apps.B)
-			callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-			for _, cluster := range t.Clusters() {
-				t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
-					a := match.And(match.Cluster(cluster), match.Namespace(testNamespace)).GetMatches(apps.A)[0]
-					t.NewSubTest("Basic reachability with external ca").
-						Run(func(t framework.TestContext) {
-							// Verify mTLS works between a and b
-							opts := echo.CallOptions{
-								To: to,
-								Port: echo.Port{
-									Name: "http",
-								},
-								Count: callCount,
-							}
-							opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
 
-							a.CallOrFail(t, opts)
-						})
+			from := apps.A
+			to := apps.B
+			fromAndTo := from.Append(to)
+
+			echotest.New(t, fromAndTo).
+				WithDefaultFilters().
+				FromMatch(match.ServiceName(from.NamespacedName())).
+				ToMatch(match.ServiceName(to.NamespacedName())).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					// Verify mTLS works between a and b
+					opts := echo.CallOptions{
+						To: to,
+						Port: echo.Port{
+							Name: "http",
+						},
+					}
+					opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
+
+					from.CallOrFail(t, opts)
 				})
-			}
 		})
 }
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index a4bf735da5..71181013f2 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -52,7 +52,8 @@ func TestClientToServiceTls(t *testing.T) {
 			createObject(t, "istio-system", PeerAuthenticationConfig)
 
 			opts := echo.CallOptions{
-				To: server,
+				To:    server,
+				Count: 1,
 				Port: echo.Port{
 					Name: "http",
 				},
diff --git a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
index 7a3332f3b7..2fb87737da 100644
--- a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
+++ b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
@@ -131,7 +131,8 @@ func TestDestinationRuleTls(t *testing.T) {
 				portName := portName
 				t.NewSubTest(portName).Run(func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To: server,
+						To:    server,
+						Count: 1,
 						Port: echo.Port{
 							Name: portName,
 						},
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index 28342b7efb..ed2745f767 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -129,7 +129,8 @@ func TestEgressGatewayTls(t *testing.T) {
 						t.ConfigIstio().YAML(systemNamespace.Name(), bufDestinationRule.String()).ApplyOrFail(t)
 
 						opts := echo.CallOptions{
-							To: externalServer,
+							To:    externalServer,
+							Count: 1,
 							Port: echo.Port{
 								Name: "http",
 							},
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 36db23725b..735cc39207 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -114,7 +114,6 @@ func TestJWTHTTPS(t *testing.T) {
 								Port: echo.Port{
 									Name: "http",
 								},
-								Count: util.CallsPerCluster * to.WorkloadsOrFail(t).Len(),
 							}
 
 							c.customizeCall(t, from, &opts)
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index 8672d0f672..a89905908d 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -75,7 +75,6 @@ type testCase struct {
 						ConditionallyTo(echotest.ReachableDestinations).
 						ToMatch(util.DestMatcher(ns, true)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
-							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -83,7 +82,6 @@ type testCase struct {
 										Port: echo.Port{
 											Name: "http",
 										},
-										Count: callCount,
 									}
 
 									// Apply any custom options for the test.
@@ -426,7 +424,6 @@ type testCase struct {
 						}).
 						ToMatch(util.DestMatcher(ns, false)).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
-							callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
@@ -434,7 +431,6 @@ type testCase struct {
 										Port: echo.Port{
 											Name: "http",
 										},
-										Count: callCount,
 									}
 
 									// Apply any custom options for the test.
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index 3ac0bd8cf3..c69225da17 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -235,7 +235,8 @@ type expect struct {
 									checker = check.Status(http.StatusBadRequest)
 								}
 								c.CallOrFail(t, echo.CallOptions{
-									To: apps.B,
+									To:    apps.B,
+									Count: 1,
 									HTTP: echo.HTTP{
 										Path: tt.in,
 									},
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 7bb97326de..46ca9d4990 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -651,7 +651,7 @@ type expect struct {
 								}
 								name := fmt.Sprintf("%v/port %d[%t]", nameSuffix, expect.port.ServicePort, want)
 								callOpt := echo.CallOptions{
-									Count:   util.CallsPerCluster * to.WorkloadsOrFail(t).Len(),
+									Count:   echo.DefaultCallsPerWorkload() * to.WorkloadsOrFail(t).Len(),
 									Port:    expect.port,
 									Message: "HelloWorld",
 									// Do not set To to dest, otherwise fillInCallOptions() will
diff --git a/tests/integration/security/util/cert/cert.go b/tests/integration/security/util/cert/cert.go
index 1515ae1bd0..58d5cb2242 100644
--- a/tests/integration/security/util/cert/cert.go
+++ b/tests/integration/security/util/cert/cert.go
@@ -40,7 +40,8 @@
 // DumpCertFromSidecar gets the certificates served by the destination.
 func DumpCertFromSidecar(t test.Failer, from echo.Instance, to echo.Target, port string) []string {
 	result := from.CallOrFail(t, echo.CallOptions{
-		To: to,
+		To:    to,
+		Count: 1,
 		Port: echo.Port{
 			Name: port,
 		},
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index bb349494e3..f9564b4cc3 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -45,9 +45,6 @@
 	NakedSvc         = "naked"
 	HeadlessNakedSvc = "headless-naked"
 	ExternalSvc      = "external"
-
-	// CallsPerCluster is used to ensure cross-cluster load balancing has a chance to work
-	CallsPerCluster = 5
 )
 
 type EchoDeployments struct {
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 089b9dbc65..571cf80356 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -144,12 +144,6 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 								continue
 							}
 
-							callCount := 1
-							if len(toClusters) > 1 {
-								// so we can validate all clusters are hit
-								callCount = util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
-							}
-
 							copts := &callOptions
 							// If test case specified service call options, use that instead.
 							if c.CallOpts != nil {
@@ -161,7 +155,9 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 
 								// Set the target on the call options.
 								opts.To = to
-								opts.Count = callCount
+								if len(toClusters) == 1 {
+									opts.Count = 1
+								}
 
 								// TODO(https://github.com/istio/istio/issues/37629) go back to converge
 								opts.Retry.Options = []retry.Option{retry.Converge(1)}
diff --git a/tests/integration/telemetry/constants.go b/tests/integration/telemetry/constants.go
deleted file mode 100644
index 36e13b2e1e..0000000000
--- a/tests/integration/telemetry/constants.go
+++ /dev/null
@@ -1,24 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package telemetry
-
-const (
-	// RequestCountMultipler for multicluster tests we multiply the number of requests with a
-	// constant multiplier to make sure we have cross cluster traffic.
-	RequestCountMultipler = 20
-)
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index 724df8c959..502bdd7b07 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -255,7 +255,8 @@ func RunExternalRequest(t *testing.T, cases []*TestCase, prometheus prometheus.I
 			for _, tc := range cases {
 				t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
 					client.CallOrFail(t, echo.CallOptions{
-						To: to,
+						To:    to,
+						Count: 1,
 						Port: echo.Port{
 							Name: tc.PortName,
 						},
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index 8f463baf39..945c751f1c 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -49,7 +49,6 @@
 	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/pkg/util/protomarshal"
 	"istio.io/istio/pkg/util/sets"
-	"istio.io/istio/tests/integration/telemetry"
 )
 
 const (
@@ -167,7 +166,6 @@ func TestSetup(ctx resource.Context) (err error) {
 
 // send both a grpc and http requests (http with forced tracing).
 func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) error {
-	callCount := telemetry.RequestCountMultipler * Srv.MustWorkloads().Len()
 	//  All server instance have same names, so setting target as srv[0].
 	// Sending the number of total request same as number of servers, so that load balancing gets a chance to send request to all the clusters.
 	if onlyTCP {
@@ -176,7 +174,6 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 			Port: echo.Port{
 				Name: "tcp",
 			},
-			Count: callCount,
 			Retry: echo.Retry{
 				NoRetry: true,
 			},
@@ -188,7 +185,6 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 		Port: echo.Port{
 			Name: "grpc",
 		},
-		Count: callCount,
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
@@ -202,7 +198,6 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 		HTTP: echo.HTTP{
 			Headers: headers,
 		},
-		Count: callCount,
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
index f2f62981a9..0491cb5c7a 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
@@ -139,7 +139,6 @@ func sendTrafficForAudit(t test.Failer, cltInstance echo.Instance) error {
 				Headers: headers,
 				Path:    path,
 			},
-			Count: telemetry.RequestCountMultipler * Srv.WorkloadsOrFail(t).Len(),
 			Retry: echo.Retry{
 				NoRetry: true,
 			},
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
index 77150f418f..88c6e9a2e4 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
@@ -53,7 +53,6 @@ func TestTCPStackdriverMonitoring(t *testing.T) {
 							Port: echo.Port{
 								Name: "tcp",
 							},
-							Count: telemetry.RequestCountMultipler * Srv.WorkloadsOrFail(t).Len(),
 							Retry: echo.Retry{
 								NoRetry: true,
 							},
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index deb9370202..80674b6ed3 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -51,10 +51,9 @@
 )
 
 const (
-	removedTag            = "source_principal"
-	requestCountMultipler = 3
-	httpProtocol          = "http"
-	grpcProtocol          = "grpc"
+	removedTag   = "source_principal"
+	httpProtocol = "http"
+	grpcProtocol = "grpc"
 
 	// Same user name and password as specified at pkg/test/fakes/imageregistry
 	registryUser   = "user"
@@ -268,7 +267,6 @@ func setupWasmExtension(ctx resource.Context) error {
 
 func sendTraffic() error {
 	for _, cltInstance := range client {
-		count := requestCountMultipler * server.MustWorkloads().Len()
 		httpOpts := echo.CallOptions{
 			To: server,
 			Port: echo.Port{
@@ -278,7 +276,6 @@ func sendTraffic() error {
 				Path:   "/path",
 				Method: "GET",
 			},
-			Count: count,
 			Retry: echo.Retry{
 				NoRetry: true,
 			},
@@ -298,7 +295,6 @@ func sendTraffic() error {
 			Port: echo.Port{
 				Name: "grpc",
 			},
-			Count: count,
 		}
 		if _, err := cltInstance.Call(grpcOpts); err != nil {
 			return err
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
index 4433cbba7a..11ea4d083d 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
@@ -43,7 +43,6 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/util/retry"
-	"istio.io/istio/tests/integration/security/util"
 	common "istio.io/istio/tests/integration/telemetry/stats/prometheus"
 )
 
@@ -74,7 +73,6 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 	t.ConfigIstio().YAML(common.GetAppNamespace().Name(), config).ApplyOrFail(t)
 	testID := rand.String(16)
 	to := common.GetTarget()
-	callCount := util.CallsPerCluster * to.WorkloadsOrFail(t).Len()
 	if expectLogs {
 		// For positive test, we use the same ID and repeatedly send requests and check the count
 		retry.UntilSuccessOrFail(t, func() error {
@@ -83,7 +81,6 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 				Port: echo.Port{
 					Name: "http",
 				},
-				Count: callCount,
 				HTTP: echo.HTTP{
 					Path: "/" + testID,
 				},
@@ -110,7 +107,6 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 				Port: echo.Port{
 					Name: "http",
 				},
-				Count: callCount,
 				HTTP: echo.HTTP{
 					Path: "/" + testID,
 				},
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index 7a2ec39dfd..b959806552 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -267,7 +267,6 @@ func SendTraffic(from echo.Instance) error {
 		Port: echo.Port{
 			Name: "http",
 		},
-		Count: util.RequestCountMultipler * GetTarget().MustWorkloads().Len(),
 		Check: check.OK(),
 		Retry: echo.Retry{
 			NoRetry: true,
@@ -281,7 +280,6 @@ func SendTraffic(from echo.Instance) error {
 		Port: echo.Port{
 			Name: "http",
 		},
-		Count: util.RequestCountMultipler * apps.Naked.MustWorkloads().Len(),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
@@ -298,7 +296,6 @@ func SendTrafficOrFail(t test.Failer, from echo.Instance) {
 		Port: echo.Port{
 			Name: "http",
 		},
-		Count: util.RequestCountMultipler * GetTarget().MustWorkloads().Len(),
 		Check: check.OK(),
 	})
 	from.CallOrFail(t, echo.CallOptions{
@@ -306,7 +303,6 @@ func SendTrafficOrFail(t test.Failer, from echo.Instance) {
 		Port: echo.Port{
 			Name: "http",
 		},
-		Count: util.RequestCountMultipler * apps.Naked.MustWorkloads().Len(),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
@@ -320,7 +316,6 @@ func SendTCPTraffic(from echo.Instance) error {
 		Port: echo.Port{
 			Name: "tcp",
 		},
-		Count: util.RequestCountMultipler * GetTarget().MustWorkloads().Len(),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
diff --git a/tests/integration/telemetry/tracing/tracing.go b/tests/integration/telemetry/tracing/tracing.go
index 8a226b56d8..a705cc41dc 100644
--- a/tests/integration/telemetry/tracing/tracing.go
+++ b/tests/integration/telemetry/tracing/tracing.go
@@ -32,7 +32,6 @@
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/components/zipkin"
 	"istio.io/istio/pkg/test/framework/resource"
-	"istio.io/istio/tests/integration/telemetry"
 )
 
 var (
@@ -194,7 +193,6 @@ func SendTraffic(t framework.TestContext, headers map[string][]string, cl cluste
 			Port: echo.Port{
 				Name: "http",
 			},
-			Count: telemetry.RequestCountMultipler * server.WorkloadsOrFail(t).Len(),
 			HTTP: echo.HTTP{
 				Headers: headers,
 			},
diff --git a/tests/util/sanitycheck/sanity_check.go b/tests/util/sanitycheck/sanity_check.go
index ee1130cf13..fce3a83235 100644
--- a/tests/util/sanitycheck/sanity_check.go
+++ b/tests/util/sanitycheck/sanity_check.go
@@ -63,7 +63,8 @@ func SetupTrafficTest(t framework.TestContext, ctx resource.Context, revision st
 
 func RunTrafficTestClientServer(t framework.TestContext, client, server echo.Instance) {
 	_ = client.CallOrFail(t, echo.CallOptions{
-		To: server,
+		To:    server,
+		Count: 1,
 		Port: echo.Port{
 			Name: "http",
 		},
-- 
2.35.3

