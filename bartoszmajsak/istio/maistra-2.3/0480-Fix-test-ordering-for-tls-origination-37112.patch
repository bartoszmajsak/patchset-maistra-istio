From aa839034d6345730b1c084326d5c5fd5a20259a3 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Wed, 2 Feb 2022 15:24:52 -0800
Subject: Fix test ordering for tls origination (#37112)

* Fix test ordering for tls origination

Currently we have this inverted so things look odd:
https://prow.istio.io/view/gs/istio-prow/logs/integ-k8s-116_istio_postsubmit/1488615718931927040, and we lose the dumping

Also using a map is nondeterministic so not a great choice

* Merge into main suite

* Update golden

* single network

* fix build
---
 pkg/test/framework/analyzer.go                |   4 +
 pkg/test/framework/components/echo/config.go  |  12 +-
 .../multiple-istio-versions-no-proxy.yaml     |   2 +-
 .../echo/kube/testdata/multiversion.yaml      |   4 +-
 .../testdata/two-workloads-one-nosidecar.yaml |   4 +-
 pkg/test/framework/test.go                    |  29 +-
 .../egress_gateway_origination_test.go        | 393 ++++++++++++++++++
 .../egress_gateway_origination_test.go        | 258 ------------
 .../security/sds_tls_origination/util/util.go | 362 ----------------
 tests/integration/security/util/framework.go  |  50 +++
 10 files changed, 485 insertions(+), 633 deletions(-)
 create mode 100644 tests/integration/security/egress_gateway_origination_test.go
 delete mode 100644 tests/integration/security/sds_tls_origination/egress_gateway_origination_test.go
 delete mode 100644 tests/integration/security/sds_tls_origination/util/util.go

diff --git a/pkg/test/framework/analyzer.go b/pkg/test/framework/analyzer.go
index 806619d1e5..6330e7ea90 100644
--- a/pkg/test/framework/analyzer.go
+++ b/pkg/test/framework/analyzer.go
@@ -222,6 +222,10 @@ func (t *testAnalyzer) RequiresLocalControlPlane() Test {
 	return t
 }
 
+func (t *testAnalyzer) RequiresSingleNetwork() Test {
+	return t
+}
+
 func (t *testAnalyzer) Run(_ func(ctx TestContext)) {
 	defer t.track()
 	if t.hasRun {
diff --git a/pkg/test/framework/components/echo/config.go b/pkg/test/framework/components/echo/config.go
index 590f3b5e9d..6b29431eb3 100644
--- a/pkg/test/framework/components/echo/config.go
+++ b/pkg/test/framework/components/echo/config.go
@@ -205,8 +205,18 @@ func (c Config) IsStatefulSet() bool {
 	return c.StatefulSet
 }
 
+// IsNaked checks if the config has no sidecar.
+// Note: mixed workloads are considered 'naked'
 func (c Config) IsNaked() bool {
-	return len(c.Subsets) > 0 && c.Subsets[0].Annotations != nil && !c.Subsets[0].Annotations.GetBool(SidecarInject)
+	for _, s := range c.Subsets {
+		if s.Annotations == nil {
+			continue
+		}
+		if !s.Annotations.GetBool(SidecarInject) {
+			return true
+		}
+	}
+	return false
 }
 
 func (c Config) IsProxylessGRPC() bool {
diff --git a/pkg/test/framework/components/echo/kube/testdata/multiple-istio-versions-no-proxy.yaml b/pkg/test/framework/components/echo/kube/testdata/multiple-istio-versions-no-proxy.yaml
index 1a98fcea51..e3fc8e3579 100644
--- a/pkg/test/framework/components/echo/kube/testdata/multiple-istio-versions-no-proxy.yaml
+++ b/pkg/test/framework/components/echo/kube/testdata/multiple-istio-versions-no-proxy.yaml
@@ -171,4 +171,4 @@ spec:
             port: tcp-health-port
           periodSeconds: 10
           failureThreshold: 10
----
\ No newline at end of file
+---
diff --git a/pkg/test/framework/components/echo/kube/testdata/multiversion.yaml b/pkg/test/framework/components/echo/kube/testdata/multiversion.yaml
index 96048a0fbe..e5854e829b 100644
--- a/pkg/test/framework/components/echo/kube/testdata/multiversion.yaml
+++ b/pkg/test/framework/components/echo/kube/testdata/multiversion.yaml
@@ -34,7 +34,7 @@ spec:
       labels:
         app: multiversion
         version: v-istio
-        test.istio.io/class: standard
+        test.istio.io/class: naked
       annotations:
         prometheus.io/scrape: "true"
         prometheus.io/port: "15014"
@@ -119,7 +119,7 @@ spec:
       labels:
         app: multiversion
         version: v-legacy
-        test.istio.io/class: standard
+        test.istio.io/class: naked
       annotations:
         prometheus.io/scrape: "true"
         prometheus.io/port: "15014"
diff --git a/pkg/test/framework/components/echo/kube/testdata/two-workloads-one-nosidecar.yaml b/pkg/test/framework/components/echo/kube/testdata/two-workloads-one-nosidecar.yaml
index 4f0b7cc61c..2ec7024456 100644
--- a/pkg/test/framework/components/echo/kube/testdata/two-workloads-one-nosidecar.yaml
+++ b/pkg/test/framework/components/echo/kube/testdata/two-workloads-one-nosidecar.yaml
@@ -31,7 +31,7 @@ spec:
       labels:
         app: foo
         version: v1
-        test.istio.io/class: standard
+        test.istio.io/class: naked
       annotations:
         prometheus.io/scrape: "true"
         prometheus.io/port: "15014"
@@ -113,7 +113,7 @@ spec:
       labels:
         app: foo
         version: nosidecar
-        test.istio.io/class: standard
+        test.istio.io/class: naked
       annotations:
         prometheus.io/scrape: "true"
         prometheus.io/port: "15014"
diff --git a/pkg/test/framework/test.go b/pkg/test/framework/test.go
index fe5bab9390..7cc9b186af 100644
--- a/pkg/test/framework/test.go
+++ b/pkg/test/framework/test.go
@@ -46,6 +46,8 @@ type Test interface {
 	RequiresSingleCluster() Test
 	// RequiresLocalControlPlane ensures that clusters are using locally-deployed control planes.
 	RequiresLocalControlPlane() Test
+	// RequiresSingleNetwork ensures that clusters are in the same network
+	RequiresSingleNetwork() Test
 	// Run the test, supplied as a lambda.
 	Run(fn func(t TestContext))
 	// RunParallel runs this test in parallel with other children of the same parent test/suite. Under the hood,
@@ -105,13 +107,14 @@ type testImpl struct {
 	goTest *testing.T
 	labels []label.Instance
 	// featureLabels maps features to the scenarios they cover.
-	featureLabels       map[features.Feature][]string
-	notImplemented      bool
-	s                   *suiteContext
-	requiredMinClusters int
-	requiredMaxClusters int
-	requireLocalIstiod  bool
-	minIstioVersion     string
+	featureLabels        map[features.Feature][]string
+	notImplemented       bool
+	s                    *suiteContext
+	requiredMinClusters  int
+	requiredMaxClusters  int
+	requireLocalIstiod   bool
+	requireSingleNetwork bool
+	minIstioVersion      string
 
 	ctx *testContext
 
@@ -186,6 +189,11 @@ func (t *testImpl) RequiresLocalControlPlane() Test {
 	return t
 }
 
+func (t *testImpl) RequiresSingleNetwork() Test {
+	t.requireSingleNetwork = true
+	return t
+}
+
 func (t *testImpl) RequireIstioVersion(version string) Test {
 	t.minIstioVersion = version
 	return t
@@ -263,6 +271,13 @@ func (t *testImpl) doRun(ctx *testContext, fn func(ctx TestContext), parallel bo
 		}
 	}
 
+	if t.requireSingleNetwork && t.s.Environment().IsMultinetwork() {
+		ctx.Done()
+		t.goTest.Skipf(fmt.Sprintf("Skipping %q: only single network allowed",
+			t.goTest.Name()))
+		return
+	}
+
 	if t.minIstioVersion != "" {
 		if !t.ctx.Settings().Revisions.AtLeast(resource.IstioVersion(t.minIstioVersion)) {
 			ctx.Done()
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
new file mode 100644
index 0000000000..1df3a60595
--- /dev/null
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -0,0 +1,393 @@
+//go:build integ
+// +build integ
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package security
+
+import (
+	"fmt"
+	"os"
+	"path"
+	"strings"
+	"testing"
+
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/echo/client"
+	"istio.io/istio/pkg/test/echo/common/response"
+	"istio.io/istio/pkg/test/echo/common/scheme"
+	"istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/test/framework"
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/istio"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/test/framework/resource"
+	"istio.io/istio/pkg/test/util/tmpl"
+	ingressutil "istio.io/istio/tests/integration/security/sds_ingress/util"
+	sdstlsutil "istio.io/istio/tests/integration/security/sds_tls_origination/util"
+	"istio.io/istio/tests/integration/security/util"
+)
+
+// TestSimpleTlsOrigination test SIMPLE TLS mode with TLS origination happening at Gateway proxy
+// It uses CredentialName set in DestinationRule API to fetch secrets from k8s API server
+func TestSimpleTlsOrigination(t *testing.T) {
+	framework.NewTest(t).
+		RequiresSingleNetwork(). // https://github.com/istio/istio/issues/37134
+		Features("security.egress.tls.sds").
+		Run(func(t framework.TestContext) {
+			var (
+				credName        = "tls-credential-cacert"
+				fakeCredName    = "fake-tls-credential-cacert"
+				credNameMissing = "tls-credential-not-created-cacert"
+			)
+
+			credentialA := ingressutil.IngressCredential{
+				CaCert: MustReadCert(t, "root-cert.pem"),
+			}
+			CredentialB := ingressutil.IngressCredential{
+				CaCert: sdstlsutil.FakeRoot,
+			}
+			// Add kubernetes secret to provision key/cert for gateway.
+			ingressutil.CreateIngressKubeSecret(t, credName, ingressutil.TLS, credentialA, false)
+
+			// Add kubernetes secret to provision key/cert for gateway.
+			ingressutil.CreateIngressKubeSecret(t, fakeCredName, ingressutil.TLS, CredentialB, false)
+
+			// Set up Host Namespace
+			host := util.ExternalSvc + "." + apps.Namespace1.Name() + ".svc.cluster.local"
+
+			testCases := []TLSTestCase{
+				// Use CA certificate stored as k8s secret with the same issuing CA as server's CA.
+				// This root certificate can validate the server cert presented by the echoboot server instance.
+				{
+					Name:            "simple",
+					Response:        response.StatusCodeOK,
+					CredentialToUse: strings.TrimSuffix(credName, "-cacert"),
+					Gateway:         true,
+				},
+				// Use CA certificate stored as k8s secret with different issuing CA as server's CA.
+				// This root certificate cannot validate the server cert presented by the echoboot server instance.
+				{
+					Name:            "fake root",
+					Response:        response.StatusCodeUnavailable,
+					CredentialToUse: strings.TrimSuffix(fakeCredName, "-cacert"),
+					Gateway:         false,
+				},
+
+				// Set up an UpstreamCluster with a CredentialName when secret doesn't even exist in istio-system ns.
+				// Secret fetching error at Gateway, results in a 503 response.
+				{
+					Name:            "missing secret",
+					Response:        response.StatusCodeUnavailable,
+					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
+					Gateway:         false,
+				},
+			}
+
+			CreateGateway(t, t, apps.Namespace1, apps.Namespace1)
+			for _, tc := range testCases {
+				t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
+					CreateDestinationRule(t, apps.Namespace1, "SIMPLE", tc.CredentialToUse)
+					echotest.New(t, apps.All).
+						WithDefaultFilters().
+						From(echotest.Not(echotest.FilterMatch(echo.IsNaked()))).
+						To(echotest.FilterMatch(echo.Service(util.ExternalSvc))).
+						Run(func(t framework.TestContext, src echo.Instance, dst echo.Instances) {
+							callOpt := CallOpts(dst[0], host, tc)
+							src.CallWithRetryOrFail(t, callOpt, echo.DefaultCallRetryOptions()...)
+						})
+				})
+			}
+		})
+}
+
+// TestMutualTlsOrigination test MUTUAL TLS mode with TLS origination happening at Gateway proxy
+// It uses CredentialName set in DestinationRule API to fetch secrets from k8s API server
+func TestMutualTlsOrigination(t *testing.T) {
+	framework.NewTest(t).
+		RequiresSingleNetwork(). // https://github.com/istio/istio/issues/37134
+		Features("security.egress.mtls.sds").
+		Run(func(t framework.TestContext) {
+			var (
+				credNameGeneric    = "mtls-credential-generic"
+				credNameNotGeneric = "mtls-credential-not-generic"
+				fakeCredNameA      = "fake-mtls-credential-a"
+				fakeCredNameB      = "fake-mtls-credential-b"
+				credNameMissing    = "mtls-credential-not-created"
+				simpleCredName     = "tls-credential-simple-cacert"
+			)
+
+			// Add kubernetes secret to provision key/cert for gateway.
+
+			ingressutil.CreateIngressKubeSecret(t, credNameGeneric, ingressutil.Mtls, ingressutil.IngressCredential{
+				Certificate: MustReadCert(t, "cert-chain.pem"),
+				PrivateKey:  MustReadCert(t, "key.pem"),
+				CaCert:      MustReadCert(t, "root-cert.pem"),
+			}, false)
+
+			ingressutil.CreateIngressKubeSecret(t, credNameNotGeneric, ingressutil.Mtls, ingressutil.IngressCredential{
+				Certificate: MustReadCert(t, "cert-chain.pem"),
+				PrivateKey:  MustReadCert(t, "key.pem"),
+				CaCert:      MustReadCert(t, "root-cert.pem"),
+			}, true)
+
+			// Configured with an invalid ClientCert
+			ingressutil.CreateIngressKubeSecret(t, fakeCredNameA, ingressutil.Mtls, ingressutil.IngressCredential{
+				Certificate: sdstlsutil.FakeCert,
+				PrivateKey:  MustReadCert(t, "key.pem"),
+				CaCert:      MustReadCert(t, "root-cert.pem"),
+			}, false)
+
+			// Configured with an invalid ClientCert and PrivateKey
+			ingressutil.CreateIngressKubeSecret(t, fakeCredNameB, ingressutil.Mtls, ingressutil.IngressCredential{
+				Certificate: sdstlsutil.FakeCert,
+				PrivateKey:  sdstlsutil.FakeKey,
+				CaCert:      MustReadCert(t, "root-cert.pem"),
+			}, false)
+
+			ingressutil.CreateIngressKubeSecret(t, simpleCredName, ingressutil.TLS, ingressutil.IngressCredential{
+				CaCert: MustReadCert(t, "root-cert.pem"),
+			}, false)
+
+			// Set up Host Namespace
+			host := util.ExternalSvc + "." + apps.Namespace1.Name() + ".svc.cluster.local"
+
+			testCases := []TLSTestCase{
+				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
+				// This root certificate can validate the server cert presented by the echoboot server instance and server CA can
+				// validate the client cert. Secret is of type generic.
+				{
+					Name:            "generic",
+					Response:        response.StatusCodeOK,
+					CredentialToUse: strings.TrimSuffix(credNameGeneric, "-cacert"),
+					Gateway:         true,
+				},
+				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
+				// This root certificate can validate the server cert presented by the echoboot server instance and server CA can
+				// validate the client cert. Secret is not of type generic.
+				{
+					Name:            "non-generic",
+					Response:        response.StatusCodeOK,
+					CredentialToUse: strings.TrimSuffix(credNameNotGeneric, "-cacert"),
+					Gateway:         true,
+				},
+				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
+				// This root certificate can validate the server cert presented by the echoboot server instance and server CA
+				// cannot validate the client cert. Returns 503 response as TLS handshake fails.
+				{
+					Name:            "invalid client cert",
+					Response:        response.StatusCodeUnavailable,
+					CredentialToUse: strings.TrimSuffix(fakeCredNameA, "-cacert"),
+					Gateway:         false,
+				},
+
+				// Set up an UpstreamCluster with a CredentialName when secret doesn't even exist in istio-system ns.
+				// Secret fetching error at Gateway, results in a 503 response.
+				{
+					Name:            "missing",
+					Response:        response.StatusCodeUnavailable,
+					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
+					Gateway:         false,
+				},
+				{
+					Name:            "no client certs",
+					Response:        response.StatusCodeUnavailable,
+					CredentialToUse: strings.TrimSuffix(simpleCredName, "-cacert"),
+					Gateway:         false,
+				},
+			}
+
+			CreateGateway(t, t, apps.Namespace1, apps.Namespace1)
+			for _, tc := range testCases {
+				t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
+					CreateDestinationRule(t, apps.Namespace1, "MUTUAL", tc.CredentialToUse)
+					echotest.New(t, apps.All).
+						WithDefaultFilters().
+						From(echotest.Not(echotest.FilterMatch(echo.IsNaked()))).
+						To(echotest.FilterMatch(echo.Service(util.ExternalSvc))).
+						Run(func(t framework.TestContext, src echo.Instance, dst echo.Instances) {
+							callOpt := CallOpts(dst[0], host, tc)
+							src.CallWithRetryOrFail(t, callOpt, echo.DefaultCallRetryOptions()...)
+						})
+				})
+			}
+		})
+}
+
+const (
+	Gateway = `
+apiVersion: networking.istio.io/v1alpha3
+kind: Gateway
+metadata:
+  name: istio-egressgateway-sds
+spec:
+  selector:
+    istio: egressgateway
+  servers:
+    - port:
+        number: 443
+        name: https-sds
+        protocol: HTTPS
+      hosts:
+      - external.{{.ServerNamespace}}.svc.cluster.local
+      tls:
+        mode: ISTIO_MUTUAL
+---
+apiVersion: networking.istio.io/v1alpha3
+kind: DestinationRule
+metadata:
+  name: egressgateway-for-server-sds
+spec:
+  host: istio-egressgateway.istio-system.svc.cluster.local
+  subsets:
+  - name: server
+    trafficPolicy:
+      portLevelSettings:
+      - port:
+          number: 443
+        tls:
+          mode: ISTIO_MUTUAL
+          sni: external.{{.ServerNamespace}}.svc.cluster.local
+`
+	VirtualService = `
+apiVersion: networking.istio.io/v1alpha3
+kind: VirtualService
+metadata:
+  name: route-via-egressgateway-sds
+spec:
+  hosts:
+    - external.{{.ServerNamespace}}.svc.cluster.local
+  gateways:
+    - istio-egressgateway-sds
+    - mesh
+  http:
+    - match:
+        - gateways:
+            - mesh # from sidecars, route to egress gateway service
+          port: 80
+      route:
+        - destination:
+            host: istio-egressgateway.istio-system.svc.cluster.local
+            subset: server
+            port:
+              number: 443
+          weight: 100
+    - match:
+        - gateways:
+            - istio-egressgateway-sds
+          port: 443
+      route:
+        - destination:
+            host: external.{{.ServerNamespace}}.svc.cluster.local
+            port:
+              number: 443
+          weight: 100
+      headers:
+        request:
+          add:
+            handled-by-egress-gateway: "true"
+`
+)
+
+// We want to test out TLS origination at Gateway, to do so traffic from client in client namespace is first
+// routed to egress-gateway service in istio-system namespace and then from egress-gateway to server in server namespace.
+// TLS origination at Gateway happens using DestinationRule with CredentialName reading k8s secret at the gateway proxy.
+func CreateGateway(t test.Failer, ctx resource.Context, clientNamespace namespace.Instance, serverNamespace namespace.Instance) {
+	gw := tmpl.EvaluateOrFail(t, Gateway, map[string]string{"ServerNamespace": serverNamespace.Name()})
+	ctx.ConfigIstio().ApplyYAMLOrFail(t, clientNamespace.Name(), gw)
+
+	vs := tmpl.EvaluateOrFail(t, VirtualService, map[string]string{"ServerNamespace": serverNamespace.Name()})
+	ctx.ConfigIstio().ApplyYAMLOrFail(t, clientNamespace.Name(), vs)
+}
+
+const (
+	// Destination Rule configs
+	DestinationRuleConfig = `
+apiVersion: networking.istio.io/v1alpha3
+kind: DestinationRule
+metadata:
+  name: originate-tls-for-server-sds-{{.CredentialName}}
+spec:
+  host: "external.{{.ServerNamespace}}.svc.cluster.local"
+  trafficPolicy:
+    portLevelSettings:
+      - port:
+          number: 443
+        tls:
+          mode: {{.Mode}}
+          credentialName: {{.CredentialName}}
+          sni: external.{{.ServerNamespace}}.svc.cluster.local
+`
+)
+
+// Create the DestinationRule for TLS origination at Gateway by reading secret in istio-system namespace.
+func CreateDestinationRule(t framework.TestContext, serverNamespace namespace.Instance,
+	destinationRuleMode string, credentialName string) {
+	dr := tmpl.EvaluateOrFail(t, DestinationRuleConfig, map[string]string{
+		"ServerNamespace": serverNamespace.Name(),
+		"Mode":            destinationRuleMode, "CredentialName": credentialName,
+	})
+
+	// Get namespace for gateway pod.
+	istioCfg := istio.DefaultConfigOrFail(t, t)
+	systemNS := namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
+
+	t.ConfigKube(t.Clusters().Default()).ApplyYAMLOrFail(t, systemNS.Name(), dr)
+}
+
+type TLSTestCase struct {
+	Name            string
+	Response        string
+	CredentialToUse string
+	Gateway         bool // true if the request is expected to be routed through gateway
+}
+
+func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions {
+	return echo.CallOptions{
+		Target:   dest,
+		Count:    util.CallsPerCluster,
+		PortName: "http",
+		Scheme:   scheme.HTTP,
+		Headers: map[string][]string{
+			"Host": {host},
+		},
+		Validator: echo.And(echo.ValidatorFunc(
+			func(responses client.ParsedResponses, err error) error {
+				if err != nil {
+					return fmt.Errorf("request failed: %v", err)
+				}
+				for _, r := range responses {
+					if r.Code != tc.Response {
+						return fmt.Errorf("got code %s, expected %s", r.Code, tc.Response)
+					}
+				}
+				for _, r := range responses {
+					if _, f := r.RawResponse["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
+						return fmt.Errorf("expected to be handled by gateway. response: %+v", r.RawResponse)
+					}
+				}
+				return nil
+			})),
+	}
+}
+
+func MustReadCert(t test.Failer, f string) string {
+	b, err := os.ReadFile(path.Join(env.IstioSrc, "tests/testdata/certs/dns", f))
+	if err != nil {
+		t.Fatalf("failed to read %v: %v", f, err)
+	}
+	return string(b)
+}
diff --git a/tests/integration/security/sds_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/sds_tls_origination/egress_gateway_origination_test.go
deleted file mode 100644
index 3b4b3e5f79..0000000000
--- a/tests/integration/security/sds_tls_origination/egress_gateway_origination_test.go
+++ /dev/null
@@ -1,258 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package sdstlsorigination
-
-import (
-	"strings"
-	"testing"
-
-	"istio.io/istio/pkg/test/echo/common/response"
-	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/echotest"
-	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/components/namespace"
-	ingressutil "istio.io/istio/tests/integration/security/sds_ingress/util"
-	sdstlsutil "istio.io/istio/tests/integration/security/sds_tls_origination/util"
-)
-
-// TestSimpleTlsOrigination test SIMPLE TLS mode with TLS origination happening at Gateway proxy
-// It uses CredentialName set in DestinationRule API to fetch secrets from k8s API server
-func TestSimpleTlsOrigination(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.egress.tls.sds").
-		Run(func(t framework.TestContext) {
-			var (
-				credName        = "tls-credential-cacert"
-				fakeCredName    = "fake-tls-credential-cacert"
-				credNameMissing = "tls-credential-not-created-cacert"
-			)
-
-			credentialA := ingressutil.IngressCredential{
-				CaCert: sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}
-			CredentialB := ingressutil.IngressCredential{
-				CaCert: sdstlsutil.FakeRoot,
-			}
-			// Add kubernetes secret to provision key/cert for gateway.
-			ingressutil.CreateIngressKubeSecret(t, credName, ingressutil.TLS, credentialA, false)
-
-			// Add kubernetes secret to provision key/cert for gateway.
-			ingressutil.CreateIngressKubeSecret(t, fakeCredName, ingressutil.TLS, CredentialB, false)
-
-			apps := &sdstlsutil.EchoDeployments{}
-			sdstlsutil.SetupEcho(t, t, apps)
-
-			// Set up Host Namespace
-			host := sdstlsutil.ServerSvc + "." + apps.ServerNamespace.Name() + ".svc.cluster.local"
-
-			testCases := map[string]sdstlsutil.TestCase{
-				// Use CA certificate stored as k8s secret with the same issuing CA as server's CA.
-				// This root certificate can validate the server cert presented by the echoboot server instance.
-				"Simple TLS with Correct Root Cert": {
-					Response:        response.StatusCodeOK,
-					CredentialToUse: strings.TrimSuffix(credName, "-cacert"),
-					Gateway:         true,
-				},
-				// Use CA certificate stored as k8s secret with different issuing CA as server's CA.
-				// This root certificate cannot validate the server cert presented by the echoboot server instance.
-				"Simple TLS with Fake Root Cert": {
-					Response:        response.StatusCodeUnavailable,
-					CredentialToUse: strings.TrimSuffix(fakeCredName, "-cacert"),
-					Gateway:         false,
-				},
-
-				// Set up an UpstreamCluster with a CredentialName when secret doesn't even exist in istio-system ns.
-				// Secret fetching error at Gateway, results in a 503 response.
-				"Simple TLS with credentialName set when the underlying secret doesn't exist": {
-					Response:        response.StatusCodeUnavailable,
-					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
-					Gateway:         false,
-				},
-			}
-
-			for name, tc := range testCases {
-				echotest.New(t, apps.All).
-					SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
-						bufDestinationRule := sdstlsutil.CreateDestinationRule(t, apps.ServerNamespace, "SIMPLE", tc.CredentialToUse)
-
-						// Get namespace for gateway pod.
-						istioCfg := istio.DefaultConfigOrFail(t, t)
-						systemNS := namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
-
-						t.ConfigKube(t.Clusters().Default()).ApplyYAMLOrFail(t, systemNS.Name(), bufDestinationRule.String())
-						return nil
-					}).
-					From(
-						echotest.Not(func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.Service(sdstlsutil.ServerSvc))
-						}),
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.InCluster(t.Clusters().Default()))
-						},
-					).
-					ConditionallyTo(echotest.ReachableDestinations).
-					To(
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.Service(sdstlsutil.ServerSvc))
-						},
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.InCluster(t.Clusters().Default()))
-						},
-					).
-					Run(func(t framework.TestContext, src echo.Instance, _ echo.Instances) {
-						callOpt := sdstlsutil.CallOpts(apps.Server, host, name, tc)
-						t.NewSubTest(name).Run(func(t framework.TestContext) {
-							src.CallWithRetryOrFail(t, callOpt, echo.DefaultCallRetryOptions()...)
-						})
-					})
-			}
-		})
-}
-
-// TestMutualTlsOrigination test MUTUAL TLS mode with TLS origination happening at Gateway proxy
-// It uses CredentialName set in DestinationRule API to fetch secrets from k8s API server
-func TestMutualTlsOrigination(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.egress.mtls.sds").
-		Run(func(t framework.TestContext) {
-			var (
-				credNameGeneric    = "mtls-credential-generic"
-				credNameNotGeneric = "mtls-credential-not-generic"
-				fakeCredNameA      = "fake-mtls-credential-a"
-				fakeCredNameB      = "fake-mtls-credential-b"
-				credNameMissing    = "mtls-credential-not-created"
-				simpleCredName     = "tls-credential-simple-cacert"
-			)
-
-			// Add kubernetes secret to provision key/cert for gateway.
-
-			ingressutil.CreateIngressKubeSecret(t, credNameGeneric, ingressutil.Mtls, ingressutil.IngressCredential{
-				Certificate: sdstlsutil.MustReadCert(t, "cert-chain.pem"),
-				PrivateKey:  sdstlsutil.MustReadCert(t, "key.pem"),
-				CaCert:      sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}, false)
-
-			ingressutil.CreateIngressKubeSecret(t, credNameNotGeneric, ingressutil.Mtls, ingressutil.IngressCredential{
-				Certificate: sdstlsutil.MustReadCert(t, "cert-chain.pem"),
-				PrivateKey:  sdstlsutil.MustReadCert(t, "key.pem"),
-				CaCert:      sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}, true)
-
-			// Configured with an invalid ClientCert
-			ingressutil.CreateIngressKubeSecret(t, fakeCredNameA, ingressutil.Mtls, ingressutil.IngressCredential{
-				Certificate: sdstlsutil.FakeCert,
-				PrivateKey:  sdstlsutil.MustReadCert(t, "key.pem"),
-				CaCert:      sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}, false)
-
-			// Configured with an invalid ClientCert and PrivateKey
-			ingressutil.CreateIngressKubeSecret(t, fakeCredNameB, ingressutil.Mtls, ingressutil.IngressCredential{
-				Certificate: sdstlsutil.FakeCert,
-				PrivateKey:  sdstlsutil.FakeKey,
-				CaCert:      sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}, false)
-
-			ingressutil.CreateIngressKubeSecret(t, simpleCredName, ingressutil.TLS, ingressutil.IngressCredential{
-				CaCert: sdstlsutil.MustReadCert(t, "root-cert.pem"),
-			}, false)
-
-			apps := &sdstlsutil.EchoDeployments{}
-			sdstlsutil.SetupEcho(t, t, apps)
-
-			// Set up Host Namespace
-			host := sdstlsutil.ServerSvc + "." + apps.ServerNamespace.Name() + ".svc.cluster.local"
-
-			testCases := map[string]sdstlsutil.TestCase{
-				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
-				// This root certificate can validate the server cert presented by the echoboot server instance and server CA can
-				// validate the client cert. Secret is of type generic.
-				"MUTUAL TLS with correct root cert and client certs and generic secret type": {
-					Response:        response.StatusCodeOK,
-					CredentialToUse: strings.TrimSuffix(credNameGeneric, "-cacert"),
-					Gateway:         true,
-				},
-				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
-				// This root certificate can validate the server cert presented by the echoboot server instance and server CA can
-				// validate the client cert. Secret is not of type generic.
-				"MUTUAL TLS with correct root cert and client certs and non generic secret type": {
-					Response:        response.StatusCodeOK,
-					CredentialToUse: strings.TrimSuffix(credNameNotGeneric, "-cacert"),
-					Gateway:         true,
-				},
-				// Use CA certificate and client certs stored as k8s secret with the same issuing CA as server's CA.
-				// This root certificate can validate the server cert presented by the echoboot server instance and server CA
-				// cannot validate the client cert. Returns 503 response as TLS handshake fails.
-				"MUTUAL TLS with correct root cert but invalid client cert": {
-					Response:        response.StatusCodeUnavailable,
-					CredentialToUse: strings.TrimSuffix(fakeCredNameA, "-cacert"),
-					Gateway:         false,
-				},
-
-				// Set up an UpstreamCluster with a CredentialName when secret doesn't even exist in istio-system ns.
-				// Secret fetching error at Gateway, results in a 503 response.
-				"MUTUAL TLS with credentialName set when the underlying secret doesn't exist": {
-					Response:        response.StatusCodeUnavailable,
-					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
-					Gateway:         false,
-				},
-				"MUTUAL TLS with correct root cert but no client certs": {
-					Response:        response.StatusCodeUnavailable,
-					CredentialToUse: strings.TrimSuffix(simpleCredName, "-cacert"),
-					Gateway:         false,
-				},
-			}
-
-			for name, tc := range testCases {
-				echotest.New(t, apps.All).
-					SetupForDestination(func(t framework.TestContext, dst echo.Instances) error {
-						bufDestinationRule := sdstlsutil.CreateDestinationRule(t, apps.ServerNamespace, "MUTUAL", tc.CredentialToUse)
-
-						// Get namespace for gateway pod.
-						istioCfg := istio.DefaultConfigOrFail(t, t)
-						systemNS := namespace.ClaimOrFail(t, t, istioCfg.SystemNamespace)
-
-						t.ConfigKube(t.Clusters().Default()).ApplyYAMLOrFail(t, systemNS.Name(), bufDestinationRule.String())
-						return nil
-					}).
-					From(
-						echotest.Not(func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.Service(sdstlsutil.ServerSvc))
-						}),
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.InCluster(t.Clusters().Default()))
-						},
-					).
-					ConditionallyTo(echotest.ReachableDestinations).
-					To(
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.Service(sdstlsutil.ServerSvc))
-						},
-						func(instances echo.Instances) echo.Instances {
-							return instances.Match(echo.InCluster(t.Clusters().Default()))
-						},
-					).
-					Run(func(t framework.TestContext, src echo.Instance, _ echo.Instances) {
-						callOpt := sdstlsutil.CallOpts(apps.Server, host, name, tc)
-						t.NewSubTest(name).Run(func(t framework.TestContext) {
-							src.CallWithRetryOrFail(t, callOpt, echo.DefaultCallRetryOptions()...)
-						})
-					})
-			}
-		})
-}
diff --git a/tests/integration/security/sds_tls_origination/util/util.go b/tests/integration/security/sds_tls_origination/util/util.go
deleted file mode 100644
index 00fa6bdbe1..0000000000
--- a/tests/integration/security/sds_tls_origination/util/util.go
+++ /dev/null
@@ -1,362 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package sdstlsutil
-
-import (
-	"bytes"
-	"fmt"
-	"html/template"
-	"os"
-	"path"
-	"time"
-
-	envoyAdmin "github.com/envoyproxy/go-control-plane/envoy/admin/v3"
-
-	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
-	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/scheme"
-	"istio.io/istio/pkg/test/env"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
-	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/resource"
-	"istio.io/istio/pkg/test/util/retry"
-	"istio.io/istio/pkg/test/util/structpath"
-)
-
-const (
-	CallsPerCluster = 5
-	ServerSvc       = "server"
-)
-
-type EchoDeployments struct {
-	All             echo.Instances
-	Server          echo.Instance
-	ClientNamespace namespace.Instance
-	ServerNamespace namespace.Instance
-}
-
-type TestCase struct {
-	Response        string
-	CredentialToUse string
-	Gateway         bool // true if the request is expected to be routed through gateway
-}
-
-func MustReadCert(t test.Failer, f string) string {
-	b, err := os.ReadFile(path.Join(env.IstioSrc, "tests/testdata/certs/dns", f))
-	if err != nil {
-		t.Fatalf("failed to read %v: %v", f, err)
-	}
-	return string(b)
-}
-
-// SetupEcho creates two namespaces client and server. It also brings up echo instances server and
-// clients in respective namespaces. HTTP and HTTPS port on the server echo are set up. Egress Gateway is set up in the
-// service namespace to handle egress for "external" calls.
-func SetupEcho(t test.Failer, ctx resource.Context, apps *EchoDeployments) {
-	apps.ClientNamespace = namespace.NewOrFail(t, ctx, namespace.Config{
-		Prefix: "client",
-		Inject: true,
-	})
-	apps.ServerNamespace = namespace.NewOrFail(t, ctx, namespace.Config{
-		Prefix: "server",
-		Inject: true,
-	})
-	cluster := ctx.Clusters().Default()
-	var internalClient, internalVM, externalServer echo.Instance
-	echos := echoboot.NewBuilder(ctx).
-		With(&internalClient, echo.Config{
-			Cluster:   cluster,
-			Service:   "a",
-			Namespace: apps.ClientNamespace,
-			Ports:     []echo.Port{},
-			Subsets: []echo.SubsetConfig{{
-				Version: "v1",
-			}},
-		}).
-		With(&internalVM, echo.Config{
-			Cluster:   cluster,
-			Service:   "vm",
-			Namespace: apps.ClientNamespace,
-			Ports:     []echo.Port{},
-			Subsets: []echo.SubsetConfig{{
-				Version: "v1",
-			}},
-			DeployAsVM: true,
-		}).
-		With(&externalServer, echo.Config{
-			Cluster:   cluster,
-			Service:   ServerSvc,
-			Namespace: apps.ServerNamespace,
-			Ports: []echo.Port{
-				{
-					// Plain HTTP port only used to route request to egress gateway
-					Name:         "http",
-					Protocol:     protocol.HTTP,
-					ServicePort:  80,
-					InstancePort: 8080,
-				},
-				{
-					// HTTPS port
-					Name:         "https",
-					Protocol:     protocol.HTTPS,
-					ServicePort:  443,
-					InstancePort: 8443,
-					TLS:          true,
-				},
-			},
-			// Set up TLS certs on the server. This will make the server listen with these credentials.
-			TLSSettings: &common.TLSSettings{
-				// Echo has these test certs baked into the docker image
-				RootCert:   MustReadCert(t, "root-cert.pem"),
-				ClientCert: MustReadCert(t, "cert-chain.pem"),
-				Key:        MustReadCert(t, "key.pem"),
-				// Override hostname to match the SAN in the cert we are using
-				Hostname: "server.default.svc",
-			},
-			Subsets: []echo.SubsetConfig{{
-				Version:     "v1",
-				Annotations: echo.NewAnnotations().SetBool(echo.SidecarInject, false),
-			}},
-		}).
-		BuildOrFail(t)
-
-	apps.All = echos
-	apps.Server = externalServer
-	// Apply Egress Gateway for service namespace to originate external traffic
-	createGateway(t, ctx, apps.ClientNamespace, apps.ServerNamespace)
-
-	if err := WaitUntilNotCallable(internalClient, externalServer); err != nil {
-		t.Fatalf("failed to apply sidecar, %v", err)
-	}
-}
-
-const (
-	Gateway = `
-apiVersion: networking.istio.io/v1alpha3
-kind: Gateway
-metadata:
-  name: istio-egressgateway-sds
-spec:
-  selector:
-    istio: egressgateway
-  servers:
-    - port:
-        number: 443
-        name: https-sds
-        protocol: HTTPS
-      hosts:
-      - server.{{.ServerNamespace}}.svc.cluster.local
-      tls:
-        mode: ISTIO_MUTUAL
----
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: egressgateway-for-server-sds
-spec:
-  host: istio-egressgateway.istio-system.svc.cluster.local
-  subsets:
-  - name: server
-    trafficPolicy:
-      portLevelSettings:
-      - port:
-          number: 443
-        tls:
-          mode: ISTIO_MUTUAL
-          sni: server.{{.ServerNamespace}}.svc.cluster.local
-`
-	VirtualService = `
-apiVersion: networking.istio.io/v1alpha3
-kind: VirtualService
-metadata:
-  name: route-via-egressgateway-sds
-spec:
-  hosts:
-    - server.{{.ServerNamespace}}.svc.cluster.local
-  gateways:
-    - istio-egressgateway-sds
-    - mesh
-  http:
-    - match:
-        - gateways:
-            - mesh # from sidecars, route to egress gateway service
-          port: 80
-      route:
-        - destination:
-            host: istio-egressgateway.istio-system.svc.cluster.local
-            subset: server
-            port:
-              number: 443
-          weight: 100
-    - match:
-        - gateways:
-            - istio-egressgateway-sds
-          port: 443
-      route:
-        - destination:
-            host: server.{{.ServerNamespace}}.svc.cluster.local
-            port:
-              number: 443
-          weight: 100
-      headers:
-        request:
-          add:
-            handled-by-egress-gateway: "true"
-`
-)
-
-// We want to test out TLS origination at Gateway, to do so traffic from client in client namespace is first
-// routed to egress-gateway service in istio-system namespace and then from egress-gateway to server in server namespace.
-// TLS origination at Gateway happens using DestinationRule with CredentialName reading k8s secret at the gateway proxy.
-func createGateway(t test.Failer, ctx resource.Context, clientNamespace namespace.Instance, serverNamespace namespace.Instance) {
-	tmplGateway, err := template.New("Gateway").Parse(Gateway)
-	if err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-
-	var bufGateway bytes.Buffer
-	if err := tmplGateway.Execute(&bufGateway, map[string]string{"ServerNamespace": serverNamespace.Name()}); err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-	if err := ctx.ConfigKube(ctx.Clusters().Default()).ApplyYAML(clientNamespace.Name(), bufGateway.String()); err != nil {
-		t.Fatalf("failed to apply gateway: %v. template: %v", err, bufGateway.String())
-	}
-
-	// Hack:Must give some time to DR to propagate to all configs
-	time.Sleep(time.Second * 5)
-
-	tmplVS, err := template.New("VirtualService").Parse(VirtualService)
-	if err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-
-	var bufVS bytes.Buffer
-	if err := tmplVS.Execute(&bufVS, map[string]string{"ServerNamespace": serverNamespace.Name()}); err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-	if err := ctx.ConfigKube(ctx.Clusters().Default()).ApplyYAML(clientNamespace.Name(), bufVS.String()); err != nil {
-		t.Fatalf("failed to apply gateway: %v. template: %v", err, bufVS.String())
-	}
-}
-
-const (
-	// Destination Rule configs
-	DestinationRuleConfig = `
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: originate-tls-for-server-sds-{{.CredentialName}}
-spec:
-  host: "server.{{.ServerNamespace}}.svc.cluster.local"
-  trafficPolicy:
-    portLevelSettings:
-      - port:
-          number: 443
-        tls:
-          mode: {{.Mode}}
-          credentialName: {{.CredentialName}}
-          sni: server.{{.ServerNamespace}}.svc.cluster.local
-`
-)
-
-// Create the DestinationRule for TLS origination at Gateway by reading secret in istio-system namespace.
-func CreateDestinationRule(t test.Failer, serverNamespace namespace.Instance,
-	destinationRuleMode string, credentialName string) bytes.Buffer {
-	destinationRuleToParse := DestinationRuleConfig
-
-	tmpl, err := template.New("DestinationRule").Parse(destinationRuleToParse)
-	if err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-
-	var buf bytes.Buffer
-	if err := tmpl.Execute(&buf, map[string]string{
-		"ServerNamespace": serverNamespace.Name(),
-		"Mode":            destinationRuleMode, "CredentialName": credentialName,
-	}); err != nil {
-		t.Fatalf("failed to create template: %v", err)
-	}
-	return buf
-}
-
-// Wait for the server to NOT be callable by the client. This allows us to simulate external traffic.
-// This essentially just waits for the Sidecar to be applied, without sleeping.
-func WaitUntilNotCallable(c echo.Instance, dest echo.Instance) error {
-	accept := func(cfg *envoyAdmin.ConfigDump) (bool, error) {
-		validator := structpath.ForProto(cfg)
-		for _, port := range dest.Config().Ports {
-			clusterName := clusterName(dest, port)
-			// Ensure that we have an outbound configuration for the target port.
-			err := validator.NotExists("{.configs[*].dynamicActiveClusters[?(@.cluster.Name == '%s')]}", clusterName).Check()
-			if err != nil {
-				return false, err
-			}
-		}
-
-		return true, nil
-	}
-
-	workloads, _ := c.Workloads()
-	// Wait for the outbound config to be received by each workload from Pilot.
-	for _, w := range workloads {
-		if w.Sidecar() != nil {
-			if err := w.Sidecar().WaitForConfig(accept, retry.Timeout(time.Second*10)); err != nil {
-				return err
-			}
-		}
-	}
-
-	return nil
-}
-
-func clusterName(target echo.Instance, port echo.Port) string {
-	cfg := target.Config()
-	return fmt.Sprintf("outbound|%d||%s.%s.svc.%s", port.ServicePort, cfg.Service, cfg.Namespace.Name(), cfg.Domain)
-}
-
-func CallOpts(dest echo.Instance, host, name string, tc TestCase) echo.CallOptions {
-	return echo.CallOptions{
-		Target:   dest,
-		Count:    CallsPerCluster,
-		PortName: "http",
-		Scheme:   scheme.HTTP,
-		Headers: map[string][]string{
-			"Host": {host},
-		},
-		Validator: echo.And(echo.ValidatorFunc(
-			func(responses client.ParsedResponses, err error) error {
-				if err != nil {
-					return fmt.Errorf("request failed: %v", err)
-				}
-				for _, r := range responses {
-					if r.Code != tc.Response {
-						return fmt.Errorf("got code %s, expected %s", r.Code, tc.Response)
-					}
-				}
-				for _, r := range responses {
-					if _, f := r.RawResponse["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
-						return fmt.Errorf("expected to be handled by gateway. response: %+v", r.RawResponse)
-					}
-				}
-				return nil
-			})),
-	}
-}
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index 8dd207734f..d0ea626ee3 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -18,7 +18,13 @@
 package util
 
 import (
+	"fmt"
+	"os"
+	"path"
+
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/common"
+	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
@@ -40,6 +46,7 @@
 	HeadlessSvc      = "headless"
 	NakedSvc         = "naked"
 	HeadlessNakedSvc = "headless-naked"
+	ExternalSvc      = "external"
 
 	// CallsPerCluster is used to ensure cross-cluster load balancing has a chance to work
 	CallsPerCluster = 5
@@ -60,6 +67,7 @@ type EchoDeployments struct {
 	VM            echo.Instances
 	HeadlessNaked echo.Instances
 	All           echo.Instances
+	External      echo.Instances
 }
 
 func EchoConfig(name string, ns namespace.Instance, headless bool, annos echo.Annotations) echo.Config {
@@ -160,6 +168,14 @@ func EchoConfig(name string, ns namespace.Instance, headless bool, annos echo.An
 	return out
 }
 
+func MustReadCert(f string) string {
+	b, err := os.ReadFile(path.Join(env.IstioSrc, "tests/testdata/certs/dns", f))
+	if err != nil {
+		panic(fmt.Sprintf("failed to read %v: %v", f, err))
+	}
+	return string(b)
+}
+
 func SetupApps(ctx resource.Context, i istio.Instance, apps *EchoDeployments, buildVM bool) error {
 	if ctx.Settings().SkipVM {
 		buildVM = false
@@ -223,6 +239,40 @@ func SetupApps(ctx resource.Context, i istio.Instance, apps *EchoDeployments, bu
 			vmCfg.DeployAsVM = buildVM
 			return vmCfg
 		}()).
+		WithConfig(echo.Config{
+			Service:   ExternalSvc,
+			Namespace: apps.Namespace1,
+			Ports: []echo.Port{
+				{
+					// Plain HTTP port only used to route request to egress gateway
+					Name:         "http",
+					Protocol:     protocol.HTTP,
+					ServicePort:  80,
+					InstancePort: 8080,
+				},
+				{
+					// HTTPS port
+					Name:         "https",
+					Protocol:     protocol.HTTPS,
+					ServicePort:  443,
+					InstancePort: 8443,
+					TLS:          true,
+				},
+			},
+			// Set up TLS certs on the server. This will make the server listen with these credentials.
+			TLSSettings: &common.TLSSettings{
+				// Echo has these test certs baked into the docker image
+				RootCert:   MustReadCert("root-cert.pem"),
+				ClientCert: MustReadCert("cert-chain.pem"),
+				Key:        MustReadCert("key.pem"),
+				// Override hostname to match the SAN in the cert we are using
+				Hostname: "server.default.svc",
+			},
+			Subsets: []echo.SubsetConfig{{
+				Version:     "v1",
+				Annotations: echo.NewAnnotations().SetBool(echo.SidecarInject, false),
+			}},
+		}).
 		WithConfig(EchoConfig(HeadlessSvc, apps.Namespace1, true, nil)).
 		WithConfig(EchoConfig(HeadlessNakedSvc, apps.Namespace1, true, echo.NewAnnotations().
 			SetBool(echo.SidecarInject, false)))
-- 
2.35.3

