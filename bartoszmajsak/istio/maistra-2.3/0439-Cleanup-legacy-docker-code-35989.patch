From 497656b726fda83f4f6f662931006c6f4604e4d9 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Tue, 25 Jan 2022 07:33:14 -0800
Subject: Cleanup legacy docker code (#35989)

---
 tools/buildx-gen.sh          | 116 ---------
 tools/docker-builder/main.go |   4 +-
 tools/istio-docker.mk        | 480 ++++++++++++-----------------------
 3 files changed, 166 insertions(+), 434 deletions(-)
 delete mode 100755 tools/buildx-gen.sh

diff --git a/tools/buildx-gen.sh b/tools/buildx-gen.sh
deleted file mode 100755
index c81b23e794..0000000000
--- a/tools/buildx-gen.sh
+++ /dev/null
@@ -1,116 +0,0 @@
-#!/bin/bash
-
-# Copyright 2019 Istio Authors
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-WD=$(dirname "$0")
-WD=$(cd "$WD"; pwd)
-
-set -eu
-
-out="${1}"
-config="${out}/docker-bake.hcl"
-shift
-
-DEFAULT_VARIANT="${DEFAULT_VARIANT:-debug}"
-INCLUDE_UNTAGGED_DEFAULT="${INCLUDE_UNTAGGED_DEFAULT:-false}"
-
-function to_platform_list() {
-  image="${1}"
-  platforms="${2}"
-  # convert CSV to "foo","bar" list
-  # shellcheck disable=SC2001
-  echo "\"$(echo "${platforms}" | sed 's/,/","/g')\""
-}
-
-variants=\"$(for i in ${DOCKER_ALL_VARIANTS}; do echo "\"${i}\""; done | xargs | sed -e 's/ /\", \"/g')\"
-cat <<EOF > "${config}"
-group "all" {
-    targets = [${variants}]
-}
-EOF
-
-# Generate the top header. This defines a group to build all images for each variant
-for variant in ${DOCKER_ALL_VARIANTS} default; do
-  # Get all images. Transform from `docker.target` to `"target"` as a comma separated list
-  images=\"$(for i in "$@"; do
-    if ! "${WD}/skip-image.sh" "$i" "$variant"; then echo "\"${i#docker.}-${variant}\""; fi
-  done | xargs | sed -e 's/ /\", \"/g')\"
-  cat <<EOF >> "${config}"
-group "${variant}" {
-    targets = [${images}]
-}
-EOF
-done
-
-# For each docker image, define a target to build it
-for file in "$@"; do
-  for variant in ${DOCKER_ALL_VARIANTS} default; do
-    image=${file#docker.}
-    tag="${TAG}-${variant}"
-
-    # Output locally (like `docker build`) by default, or push
-    # Push requires using container driver. See https://github.com/docker/buildx#working-with-builder-instances
-    output='output = ["type=docker"]'
-    if [[ -n "${DOCKERX_PUSH:-}" ]]; then
-      output='output = ["type=registry"]'
-    fi
-
-    # Wild card check to assign the vm name and version
-    # The name of the VM image would be app_sidecar_IMAGE_VERSION
-    # Split the $image using "_"
-    VM_IMAGE_NAME=""
-    VM_IMAGE_VERSION=""
-    if [[ "$image" == *"app_sidecar"* ]]; then
-      readarray -d _ -t split < <(printf '%s'"$image")
-      VM_IMAGE_NAME="${split[-2]}"
-      VM_IMAGE_VERSION="${split[-1]}"
-    fi
-
-    # Create a list of tags by iterating over HUBs
-    tags=""
-    for hub in ${HUBS};
-    do
-      if [[ "${variant}" = "${DEFAULT_VARIANT}" ]]; then
-        tags=${tags}"\"${hub}/${image}:${tag}\", "
-        if [[ "${INCLUDE_UNTAGGED_DEFAULT}" == "true" ]]; then
-          tags=${tags}"\"${hub}/${image}:${TAG}\", "
-        fi
-      elif [[ "${variant}" == "default" ]]; then
-        tags=${tags}"\"${hub}/${image}:${TAG}\", "
-      else
-        tags=${tags}"\"${hub}/${image}:${tag}\", "
-      fi
-    done
-    tags="${tags%, *}" # remove training ', '
-
-    cat <<EOF >> "${config}"
-target "$image-$variant" {
-    context = "${out}/${file}"
-    dockerfile = "Dockerfile.$image"
-    tags = [${tags}]
-    platforms = [$(to_platform_list "${image}" "${DOCKER_ARCHITECTURES}")]
-    args = {
-      BASE_VERSION = "${BASE_VERSION}"
-      BASE_DISTRIBUTION = "${variant/default/${DEFAULT_VARIANT}}"
-      proxy_version = "istio-proxy:${PROXY_REPO_SHA}"
-      istio_version = "${VERSION}"
-      VM_IMAGE_NAME = "${VM_IMAGE_NAME}"
-      VM_IMAGE_VERSION = "${VM_IMAGE_VERSION}"
-    }
-    ${output}
-}
-EOF
-  done
-done
diff --git a/tools/docker-builder/main.go b/tools/docker-builder/main.go
index 22cf150fcd..53acfde33d 100644
--- a/tools/docker-builder/main.go
+++ b/tools/docker-builder/main.go
@@ -87,7 +87,7 @@ func main() {
 		}
 		targets := []string{}
 		for _, t := range args.Targets {
-			targets = append(targets, fmt.Sprintf("docker.%s", t))
+			targets = append(targets, fmt.Sprintf("build.docker.%s", t))
 		}
 		if err := RunMake(args, targets...); err != nil {
 			return err
@@ -222,7 +222,7 @@ func ConstructBakeFile(a Args) (map[string]string, error) {
 			if strings.HasPrefix(target, "app_") && variant == DistrolessVariant {
 				continue
 			}
-			p := filepath.Join(testenv.LocalOut, "dockerx_build", fmt.Sprintf("docker.%s", target))
+			p := filepath.Join(testenv.LocalOut, "dockerx_build", fmt.Sprintf("build.docker.%s", target))
 			t := Target{
 				Context:    sp(p),
 				Dockerfile: sp(fmt.Sprintf("Dockerfile.%s", target)),
diff --git a/tools/istio-docker.mk b/tools/istio-docker.mk
index fac6f475be..3b14336487 100644
--- a/tools/istio-docker.mk
+++ b/tools/istio-docker.mk
@@ -17,20 +17,70 @@
 .PHONY: docker.save
 .PHONY: docker.push
 
-DOCKER_V2_BUILDER ?= true
-
-# Docker target will build the go binaries and package the docker for local testing.
-# It does not upload to a registry.
-
-docker: docker.all
-
-# Add new docker targets to the end of the DOCKER_TARGETS list.
-
+# DOCKER_TARGETS defines all known docker images
 DOCKER_TARGETS ?= docker.pilot docker.proxyv2 docker.app docker.app_sidecar_ubuntu_xenial \
 docker.app_sidecar_ubuntu_bionic docker.app_sidecar_ubuntu_focal docker.app_sidecar_debian_9 \
 docker.app_sidecar_debian_10 docker.app_sidecar_centos_8 docker.app_sidecar_centos_7 \
 docker.istioctl docker.operator docker.install-cni
 
+### Docker commands ###
+# Below provides various commands to build/push docker images.
+# These are all wrappers around ./tools/docker, the binary that controls docker builds.
+# Builds can also be done through direct ./tools/docker invocations.
+# When using these commands the flow is:
+#  1) make target calls ./tools/docker
+#  2) ./tools/docker calls `make build.docker.x` targets to compute the dependencies required
+#  3) ./tools/docker triggers the actual docker commands required
+# As a result, there are two layers of make involved.
+
+docker: ## Build all docker images
+	DOCKER_TARGETS="$(DOCKER_TARGETS)" ./tools/docker
+
+docker.save: ## Build docker images and save to tar.gz
+	DOCKER_TARGETS="$(DOCKER_TARGETS)" ./tools/docker ./tools/docker --save
+
+docker.push: ## Build all docker images and push to
+	DOCKER_TARGETS="$(DOCKER_TARGETS)" ./tools/docker ./tools/docker --push
+
+# Legacy command aliases
+docker.all: docker
+	@:
+dockerx.save: docker.save
+	@:
+dockerx.push: docker.push
+	@:
+dockerx.pushx: docker.push
+	@:
+dockerx: docker
+	@:
+
+# Support individual images like `dockerx.pilot`
+
+# Docker commands defines some convenience targets
+define DOCKER_COMMANDS =
+# Build individual docker image and push it. Ex: push.docker.pilot
+push.$(1): DOCKER_TARGETS=$(1)
+push.$(1): docker.push
+	@:
+
+# Build individual docker image and save it. Ex: tar.docker.pilot
+tar.$(1): DOCKER_TARGETS=$(1)
+tar.$(1): docker.save
+	@:
+
+# Build individual docker image. Ex: docker.pilot
+$(1): DOCKER_TARGETS=$(1)
+$(1): docker
+	@:
+
+# Build individual docker image. Ex: dockerx.pilot
+dockerx.$(1): DOCKER_TARGETS=$(1)
+dockerx.$(1): docker
+	@:
+endef
+$(foreach tgt,$(DOCKER_TARGETS),$(eval $(call DOCKER_COMMANDS,$(tgt))))
+### End docker commands ###
+
 # Echo docker directory and the template to pass image name and version to for VM testing
 ECHO_DOCKER ?= pkg/test/echo/docker
 VM_OS_DOCKERFILE_TEMPLATE ?= Dockerfile.app_sidecar
@@ -40,32 +90,13 @@ $(ISTIO_DOCKER) $(ISTIO_DOCKER_TAR):
 
 .SECONDEXPANSION: #allow $@ to be used in dependency list
 
-# directives to copy files to docker scratch directory
-
-# tell make which files are copied from $(ISTIO_OUT_LINUX) and generate rules to copy them to the proper location:
-# generates rules like the following:
-# $(ISTIO_DOCKER)/pilot-agent: $(ISTIO_OUT_LINUX)/pilot-agent | $(ISTIO_DOCKER)
-# 	cp $(ISTIO_OUT_LINUX)/$FILE $(ISTIO_DOCKER)/($FILE)
-DOCKER_FILES_FROM_ISTIO_OUT_LINUX:=client server \
-                             pilot-discovery pilot-agent \
-                             istioctl manager
-$(foreach FILE,$(DOCKER_FILES_FROM_ISTIO_OUT_LINUX), \
-        $(eval $(ISTIO_DOCKER)/$(FILE): $(ISTIO_OUT_LINUX)/$(FILE) | $(ISTIO_DOCKER); cp $(ISTIO_OUT_LINUX)/$(FILE) $(ISTIO_DOCKER)/$(FILE)))
-
 # rule for the test certs.
 $(ISTIO_DOCKER)/certs:
 	mkdir -p $(ISTIO_DOCKER)
 	cp -a tests/testdata/certs $(ISTIO_DOCKER)/.
 	chmod -R o+r $(ISTIO_DOCKER)/certs
 
-# tell make which files are copied from the source tree and generate rules to copy them to the proper location:
-# TODO(sdake)                      $(NODE_AGENT_TEST_FILES) $(GRAFANA_FILES)
-DOCKER_FILES_FROM_SOURCE:=tests/testdata/certs/cert.crt tests/testdata/certs/cert.key
-$(foreach FILE,$(DOCKER_FILES_FROM_SOURCE), \
-        $(eval $(ISTIO_DOCKER)/$(notdir $(FILE)): $(FILE) | $(ISTIO_DOCKER); cp -p $(FILE) $$(@D)))
-
 # BUILD_PRE tells $(DOCKER_RULE) to run the command specified before executing a docker build
-# BUILD_ARGS tells  $(DOCKER_RULE) to execute a docker build with the specified commands
 
 # The file must be named 'envoy', depends on the release.
 ${ISTIO_ENVOY_LINUX_RELEASE_DIR}/${SIDECAR}: ${ISTIO_ENVOY_LINUX_RELEASE_PATH} ${ISTIO_ENVOY_LOCAL}
@@ -91,352 +122,169 @@ $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/stats-filter.compiled.wasm: init
 $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.wasm: init
 $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.compiled.wasm: init
 
-# Default proxy image.
-docker.proxyv2: BUILD_PRE=&& chmod 644 envoy_bootstrap.json gcp_envoy_bootstrap.json
-docker.proxyv2: BUILD_ARGS=--build-arg proxy_version=istio-proxy:${PROXY_REPO_SHA} --build-arg istio_version=${VERSION} --build-arg BASE_VERSION=${BASE_VERSION} --build-arg SIDECAR=${SIDECAR}
-docker.proxyv2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
-docker.proxyv2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
-docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/${SIDECAR}
-docker.proxyv2: $(ISTIO_OUT_LINUX)/pilot-agent
-docker.proxyv2: pilot/docker/Dockerfile.proxyv2
-docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/stats-filter.wasm
-docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/stats-filter.compiled.wasm
-docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.wasm
-docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.compiled.wasm
+# $@ is the name of the target
+# $^ the name of the dependencies for the target
+# DOCKER_RULE copies all dependencies for the dockerfile into a single folder.
+# This allows minimizing the inputs to the docker context
+DOCKER_RULE ?= ./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@
+# RENAME_TEMPLATE clones the common VM dockerfile template to the OS specific variant.
+# This allows us to have a per OS build without a ton of Dockerfiles.
+RENAME_TEMPLATE ?= mkdir -p $(DOCKERX_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKERX_BUILD_TOP)/$@/Dockerfile$(suffix $@)
+
+
+### Dockerfile builders ###
+# Unlike standard docker image builder, we use some special logic here to explicitly declare dependencies as make targets
+# Any files referenced from the Dockerfile must be included as dependency for the target to be included
+
+build.docker.proxyv2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
+build.docker.proxyv2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
+build.docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/${SIDECAR}
+build.docker.proxyv2: $(ISTIO_OUT_LINUX)/pilot-agent
+build.docker.proxyv2: pilot/docker/Dockerfile.proxyv2
+build.docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/stats-filter.wasm
+build.docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/stats-filter.compiled.wasm
+build.docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.wasm
+build.docker.proxyv2: $(ISTIO_ENVOY_LINUX_RELEASE_DIR)/metadata-exchange-filter.compiled.wasm
 	$(DOCKER_RULE)
 
-docker.pilot: BUILD_PRE=&& chmod 644 envoy_bootstrap.json gcp_envoy_bootstrap.json
-docker.pilot: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.pilot: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
-docker.pilot: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
-docker.pilot: $(ISTIO_OUT_LINUX)/pilot-discovery
-docker.pilot: pilot/docker/Dockerfile.pilot
+build.docker.pilot: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
+build.docker.pilot: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
+build.docker.pilot: $(ISTIO_OUT_LINUX)/pilot-discovery
+build.docker.pilot: pilot/docker/Dockerfile.pilot
 	$(DOCKER_RULE)
 
-docker.pilot2: BUILD_PRE=&& chmod 644 envoy_bootstrap.json gcp_envoy_bootstrap.json
-docker.pilot2: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.pilot2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
-docker.pilot2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
-docker.pilot2: $(ISTIO_OUT_LINUX)/pilot-discovery
-docker.pilot2: pilot/docker/Dockerfile.pilot
-	@$(DOCKER_BUILDER_RULE)
-
 # Test application
-docker.app: BUILD_PRE=
-docker.app: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.app: $(ECHO_DOCKER)/Dockerfile.app
-docker.app: $(ISTIO_OUT_LINUX)/client
-docker.app: $(ISTIO_OUT_LINUX)/server
-docker.app: $(ISTIO_DOCKER)/certs
+build.docker.app: $(ECHO_DOCKER)/Dockerfile.app
+build.docker.app: $(ISTIO_OUT_LINUX)/client
+build.docker.app: $(ISTIO_OUT_LINUX)/server
+build.docker.app: $(ISTIO_DOCKER)/certs
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar with ubuntu:xenial (for non-k8s).
-docker.app_sidecar_ubuntu_xenial: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=xenial --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_ubuntu_xenial: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
-docker.app_sidecar_ubuntu_xenial: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_ubuntu_xenial: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_ubuntu_xenial: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
+build.docker.app_sidecar_ubuntu_xenial: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_ubuntu_xenial: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_ubuntu_xenial: $(ISTIO_OUT_LINUX)/server
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar with ubuntu:bionic (for non-k8s).
-docker.app_sidecar_ubuntu_bionic: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=bionic --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_ubuntu_bionic: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
-docker.app_sidecar_ubuntu_bionic: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_ubuntu_bionic: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_ubuntu_bionic: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
+build.docker.app_sidecar_ubuntu_bionic: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_ubuntu_bionic: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_ubuntu_bionic: $(ISTIO_OUT_LINUX)/server
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar with ubuntu:focal (for non-k8s).
-docker.app_sidecar_ubuntu_focal: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=focal --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_ubuntu_focal: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
-docker.app_sidecar_ubuntu_focal: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_ubuntu_focal: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_ubuntu_focal: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
+build.docker.app_sidecar_ubuntu_focal: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_ubuntu_focal: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_ubuntu_focal: $(ISTIO_OUT_LINUX)/server
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar with debian 9 (for non-k8s).
-docker.app_sidecar_debian_9: BUILD_ARGS=--build-arg VM_IMAGE_NAME=debian --build-arg VM_IMAGE_VERSION=9 --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_debian_9: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
-docker.app_sidecar_debian_9: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_debian_9: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_debian_9: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
+build.docker.app_sidecar_debian_9: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_debian_9: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_debian_9: $(ISTIO_OUT_LINUX)/server
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar with debian 10 (for non-k8s).
-docker.app_sidecar_debian_10: BUILD_ARGS=--build-arg VM_IMAGE_NAME=debian --build-arg VM_IMAGE_VERSION=10 --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_debian_10: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
-docker.app_sidecar_debian_10: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_debian_10: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_debian_10: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/release/istio-sidecar.deb
+build.docker.app_sidecar_debian_10: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_debian_10: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_debian_10: $(ISTIO_OUT_LINUX)/server
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar (for non-k8s).
-docker.app_sidecar_centos_8: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION} --build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_centos_8: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/release/istio-sidecar.rpm
-docker.app_sidecar_centos_8: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_centos_8: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/server
-docker.app_sidecar_centos_8: pkg/test/echo/docker/Dockerfile.app_sidecar_centos_8
+build.docker.app_sidecar_centos_8: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/release/istio-sidecar.rpm
+build.docker.app_sidecar_centos_8: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_centos_8: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_centos_8: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_centos_8: pkg/test/echo/docker/Dockerfile.app_sidecar_centos_8
 	$(DOCKER_RULE)
 
 # Test application bundled with the sidecar (for non-k8s).
-docker.app_sidecar_centos_7: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.app_sidecar_centos_7: tools/packaging/common/envoy_bootstrap.json
-docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/release/istio-sidecar-centos-7.rpm
-docker.app_sidecar_centos_7: $(ISTIO_DOCKER)/certs
-docker.app_sidecar_centos_7: pkg/test/echo/docker/echo-start.sh
-docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/client
-docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/server
-docker.app_sidecar_centos_7: pkg/test/echo/docker/Dockerfile.app_sidecar_centos_7
+build.docker.app_sidecar_centos_7: tools/packaging/common/envoy_bootstrap.json
+build.docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/release/istio-sidecar-centos-7.rpm
+build.docker.app_sidecar_centos_7: $(ISTIO_DOCKER)/certs
+build.docker.app_sidecar_centos_7: pkg/test/echo/docker/echo-start.sh
+build.docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/client
+build.docker.app_sidecar_centos_7: $(ISTIO_OUT_LINUX)/server
+build.docker.app_sidecar_centos_7: pkg/test/echo/docker/Dockerfile.app_sidecar_centos_7
 	$(DOCKER_RULE)
 
-docker.istioctl: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.istioctl: istioctl/docker/Dockerfile.istioctl
-docker.istioctl: $(ISTIO_OUT_LINUX)/istioctl
+build.docker.istioctl: istioctl/docker/Dockerfile.istioctl
+build.docker.istioctl: $(ISTIO_OUT_LINUX)/istioctl
 	$(DOCKER_RULE)
 
-docker.operator: manifests
-docker.operator: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.operator: operator/docker/Dockerfile.operator
-docker.operator: $(ISTIO_OUT_LINUX)/operator
+build.docker.operator: manifests
+build.docker.operator: operator/docker/Dockerfile.operator
+build.docker.operator: $(ISTIO_OUT_LINUX)/operator
 	$(DOCKER_RULE)
 
-# CNI
-docker.install-cni: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
-docker.install-cni: $(ISTIO_OUT_LINUX)/istio-cni
-docker.install-cni: $(ISTIO_OUT_LINUX)/istio-iptables
-docker.install-cni: $(ISTIO_OUT_LINUX)/install-cni
-docker.install-cni: $(ISTIO_OUT_LINUX)/istio-cni-taint
-docker.install-cni: cni/deployments/kubernetes/Dockerfile.install-cni
+build.docker.install-cni: $(ISTIO_OUT_LINUX)/istio-cni
+build.docker.install-cni: $(ISTIO_OUT_LINUX)/istio-iptables
+build.docker.install-cni: $(ISTIO_OUT_LINUX)/install-cni
+build.docker.install-cni: $(ISTIO_OUT_LINUX)/istio-cni-taint
+build.docker.install-cni: cni/deployments/kubernetes/Dockerfile.install-cni
 	$(DOCKER_RULE)
 
-.PHONY: dockerx dockerx.save
-
-# Can also be linux/arm64, or both with linux/amd64,linux/arm64
-DOCKER_ARCHITECTURES ?= linux/amd64
-
-# Docker has an experimental new build engine, https://github.com/docker/buildx
-# This brings substantial (10x) performance improvements when building Istio
-# However, its only built into docker since v19.03. Because its so new that devs are likely to not have
-# this version, and because its experimental, this is not the default build method. As this matures we should migrate over.
-# For performance, in CI this method is used.
-# This target works by reusing the existing docker methods. Each docker target declares it's dependencies.
-# We then override the docker rule and "build" all of these, where building just copies the dependencies
-# We then generate a "bake" file, which defines all of the docker files in the repo
-# Finally, we call `docker buildx bake` to generate the images.
-ifeq ($(DOCKER_V2_BUILDER), true)
-dockerx:
-	./tools/docker --push=$(or $(DOCKERX_PUSH),$(DOCKERX_PUSH),false)
-else
-dockerx: DOCKER_RULE?=mkdir -p $(DOCKERX_BUILD_TOP)/$@ && TARGET_ARCH=$(TARGET_ARCH) ./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@ && cd $(DOCKERX_BUILD_TOP)/$@ $(BUILD_PRE)
-dockerx: RENAME_TEMPLATE?=mkdir -p $(DOCKERX_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKERX_BUILD_TOP)/$@/Dockerfile$(suffix $@)
-dockerx: docker | $(ISTIO_DOCKER_TAR)
-dockerx:
-	HUBS="$(HUBS)" \
-		TAG=$(TAG) \
-		PROXY_REPO_SHA=$(PROXY_REPO_SHA) \
-		VERSION=$(VERSION) \
-		DOCKER_ALL_VARIANTS="$(DOCKER_ALL_VARIANTS)" \
-		ISTIO_DOCKER_TAR=$(ISTIO_DOCKER_TAR) \
-		INCLUDE_UNTAGGED_DEFAULT=$(INCLUDE_UNTAGGED_DEFAULT) \
-		BASE_VERSION=$(BASE_VERSION) \
-		DOCKERX_PUSH=$(DOCKERX_PUSH) \
-		DOCKER_ARCHITECTURES=$(DOCKER_ARCHITECTURES) \
-		./tools/buildx-gen.sh $(DOCKERX_BUILD_TOP) $(DOCKER_TARGETS)
-	@# Retry works around https://github.com/docker/buildx/issues/298
-	DOCKER_CLI_EXPERIMENTAL=enabled bin/retry.sh "read: connection reset by peer" docker buildx bake $(BUILDX_BAKE_EXTRA_OPTIONS) -f $(DOCKERX_BUILD_TOP)/docker-bake.hcl $(or $(DOCKER_BUILD_VARIANTS),default) || \
-		{ tools/dump-docker-logs.sh; exit 1; }
-endif
-
-# Support individual images like `dockerx.pilot`
-dockerx.%:
-	@DOCKER_TARGETS=docker.$* BUILD_ALL=false $(MAKE) --no-print-directory -f Makefile.core.mk dockerx
-
-docker.base: docker/Dockerfile.base
+### Base images ###
+build.docker.base: docker/Dockerfile.base
 	$(DOCKER_RULE)
-
-docker.app_sidecar_base_debian_9: BUILD_ARGS=--build-arg VM_IMAGE_NAME=debian --build-arg VM_IMAGE_VERSION=9
-docker.app_sidecar_base_debian_9: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
-docker.app_sidecar_base_debian_9: pkg/test/echo/docker/Dockerfile.app_sidecar_base
-	$(RENAME_TEMPLATE)
+build.docker.distroless: docker/Dockerfile.distroless
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_debian_10: BUILD_ARGS=--build-arg VM_IMAGE_NAME=debian --build-arg VM_IMAGE_VERSION=10
-docker.app_sidecar_base_debian_10: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
-docker.app_sidecar_base_debian_10: pkg/test/echo/docker/Dockerfile.app_sidecar_base
+# VM Base images
+build.docker.app_sidecar_base_debian_9: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_debian_9: pkg/test/echo/docker/Dockerfile.app_sidecar_base
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_ubuntu_xenial: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=xenial
-docker.app_sidecar_base_ubuntu_xenial: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
-docker.app_sidecar_base_ubuntu_xenial: pkg/test/echo/docker/Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_debian_10: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_debian_10: pkg/test/echo/docker/Dockerfile.app_sidecar_base
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_ubuntu_bionic: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=bionic
-docker.app_sidecar_base_ubuntu_bionic: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
-docker.app_sidecar_base_ubuntu_bionic: pkg/test/echo/docker/Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_ubuntu_xenial: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_ubuntu_xenial: pkg/test/echo/docker/Dockerfile.app_sidecar_base
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_ubuntu_focal: BUILD_ARGS=--build-arg VM_IMAGE_NAME=ubuntu --build-arg VM_IMAGE_VERSION=focal
-docker.app_sidecar_base_ubuntu_focal: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
-docker.app_sidecar_base_ubuntu_focal: pkg/test/echo/docker/Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_ubuntu_bionic: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_ubuntu_bionic: pkg/test/echo/docker/Dockerfile.app_sidecar_base
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_centos_8: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base_centos
-docker.app_sidecar_base_centos_8: pkg/test/echo/docker/Dockerfile.app_sidecar_base_centos
+build.docker.app_sidecar_base_ubuntu_focal: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base
+build.docker.app_sidecar_base_ubuntu_focal: pkg/test/echo/docker/Dockerfile.app_sidecar_base
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.app_sidecar_base_centos_7: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base_centos
-docker.app_sidecar_base_centos_7: pkg/test/echo/docker/Dockerfile.app_sidecar_base_centos
+build.docker.app_sidecar_base_centos_8: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base_centos
+build.docker.app_sidecar_base_centos_8: pkg/test/echo/docker/Dockerfile.app_sidecar_base_centos
 	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
 
-docker.distroless: docker/Dockerfile.distroless
+build.docker.app_sidecar_base_centos_7: VM_OS_DOCKERFILE_TEMPLATE=Dockerfile.app_sidecar_base_centos
+build.docker.app_sidecar_base_centos_7: pkg/test/echo/docker/Dockerfile.app_sidecar_base_centos
+	$(RENAME_TEMPLATE)
 	$(DOCKER_RULE)
-
-# $@ is the name of the target
-# $^ the name of the dependencies for the target
-# Rule Steps #
-##############
-# 1. Make a directory $(DOCKER_BUILD_TOP)/%@
-# 2. This rule uses cp to copy all dependency filenames into into $(DOCKER_BUILD_TOP/$@
-# 3. This rule then changes directories to $(DOCKER_BUID_TOP)/$@
-# 4. This rule runs $(BUILD_PRE) prior to any docker build and only if specified as a dependency variable
-# 5. This rule finally runs docker build passing $(BUILD_ARGS) to docker if they are specified as a dependency variable
-
-
-define variant-tag
-$(if $(filter-out default,$(1)),-$(1),)
-endef
-define normalize-tag
-$(subst default,debug,$(1))
-endef
-
-# DOCKER_BUILD_VARIANTS ?=debug distroless
-# Base images have two different forms:
-# * "debug", suffixed as -debug. This is a ubuntu based image with a bunch of debug tools
-# * "distroless", suffixed as -distroless. This is distroless image - no shell. proxyv2 uses a custom one with iptables added
-# * "default", no suffix. This is currently "debug"
-DOCKER_BUILD_VARIANTS ?= default
-DOCKER_ALL_VARIANTS ?= debug distroless
-# If INCLUDE_UNTAGGED_DEFAULT is set, then building the "DEFAULT_DISTRIBUTION" variant will publish both <tag>-<variant> and <tag>
-# This can be done with DOCKER_BUILD_VARIANTS="default debug" as well, but at the expense of building twice vs building once and tagging twice
-INCLUDE_UNTAGGED_DEFAULT ?= false
-DEFAULT_DISTRIBUTION=debug
-DOCKER_RULE ?= $(foreach VARIANT,$(DOCKER_BUILD_VARIANTS), time (mkdir -p $(DOCKER_BUILD_TOP)/$@ && TARGET_ARCH=$(TARGET_ARCH) ./tools/docker-copy.sh $^ $(DOCKER_BUILD_TOP)/$@ && cd $(DOCKER_BUILD_TOP)/$@ $(BUILD_PRE) && docker build $(BUILD_ARGS) --build-arg BASE_DISTRIBUTION=$(call normalize-tag,$(VARIANT)) -t $(HUB)/$(subst docker.,,$@):$(TAG)$(call variant-tag,$(VARIANT)) -f Dockerfile$(suffix $@) . ); )
-DOCKER_BUILDER_RULE ?= ./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@
-RENAME_TEMPLATE ?= mkdir -p $(DOCKER_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKER_BUILD_TOP)/$@/Dockerfile$(suffix $@)
-
-# This target will package all docker images used in test and release, without re-building
-# go binaries. It is intended for CI/CD systems where the build is done in separate job.
-ifeq ($(DOCKER_V2_BUILDER), true)
-docker.all:
-	./tools/docker
-else
-docker.all: $(DOCKER_TARGETS)
-endif
-
-# for each docker.XXX target create a tar.docker.XXX target that says how
-# to make a $(ISTIO_OUT_LINUX)/docker/XXX.tar.gz from the docker XXX image
-# note that $(subst docker.,,$(TGT)) strips off the "docker." prefix, leaving just the XXX
-
-# create a DOCKER_TAR_TARGETS that's each of DOCKER_TARGETS with a tar. prefix
-DOCKER_TAR_TARGETS:=
-$(foreach TGT,$(DOCKER_TARGETS),$(eval tar.$(TGT): $(TGT) | $(ISTIO_DOCKER_TAR) ; \
-         $(foreach VARIANT,$(DOCKER_BUILD_VARIANTS) default, time ( \
-		     docker save -o ${ISTIO_DOCKER_TAR}/$(subst docker.,,$(TGT))$(call variant-tag,$(VARIANT)).tar $(HUB)/$(subst docker.,,$(TGT)):$(subst -default,,$(TAG)-$(VARIANT)) && \
-             gzip -f ${ISTIO_DOCKER_TAR}/$(subst docker.,,$(TGT))$(call variant-tag,$(VARIANT)).tar \
-			   ); \
-		  )))
-
-# create a DOCKER_TAR_TARGETS that's each of DOCKER_TARGETS with a tar. prefix DOCKER_TAR_TARGETS:=
-$(foreach TGT,$(DOCKER_TARGETS),$(eval DOCKER_TAR_TARGETS+=tar.$(TGT)))
-
-# this target saves a tar.gz of each docker image to ${ISTIO_OUT_LINUX}/docker/
-ifeq ($(DOCKER_V2_BUILDER), true)
-dockerx.save:
-	./tools/docker --save
-else
-dockerx.save: dockerx $(ISTIO_DOCKER_TAR)
-	$(foreach TGT,$(DOCKER_TARGETS), \
-	$(foreach VARIANT,$(DOCKER_BUILD_VARIANTS) default, \
-	   if ! ./tools/skip-image.sh $(TGT) $(VARIANT); then \
-	   time ( \
-		 echo $(TGT)-$(VARIANT); \
-		 docker save $(HUB)/$(subst docker.,,$(TGT)):$(TAG)$(call variant-tag,$(VARIANT)) |\
-		 gzip --fast > ${ISTIO_DOCKER_TAR}/$(subst docker.,,$(TGT))$(call variant-tag,$(VARIANT)).tar.gz \
-	   ); \
-	   fi; \
-	 ))
-endif
-
-docker.save: dockerx.save
-
-# for each docker.XXX target create a push.docker.XXX target that pushes
-# the local docker image to another hub
-# a possible optimization is to use tag.$(TGT) as a dependency to do the tag for us
-$(foreach TGT,$(DOCKER_TARGETS),$(eval push.$(TGT): | $(TGT) ; \
-	time (set -e && for distro in $(DOCKER_BUILD_VARIANTS); do tag=$(TAG)-$$$${distro}; docker push $(HUB)/$(subst docker.,,$(TGT)):$$$${tag%-default}; done)))
-
-define run_vulnerability_scanning
-        $(eval RESULTS_DIR := vulnerability_scan_results)
-        $(eval CURL_RESPONSE := $(shell curl -s --create-dirs -o $(RESULTS_DIR)/$(1) -w "%{http_code}" http://imagescanner.cloud.ibm.com/scan?image="docker.io/$(2)")) \
-        $(if $(filter $(CURL_RESPONSE), 200), (mv $(RESULTS_DIR)/$(1) $(RESULTS_DIR)/$(1).json))
-endef
-
-# create a DOCKER_PUSH_TARGETS that's each of DOCKER_TARGETS with a push. prefix
-DOCKER_PUSH_TARGETS:=
-$(foreach TGT,$(DOCKER_TARGETS),$(eval DOCKER_PUSH_TARGETS+=push.$(TGT)))
-
-# Will build and push docker images.
-ifeq ($(DOCKER_V2_BUILDER), true)
-docker.push: DOCKERX_PUSH=true
-docker.push: dockerx
-	:
-else
-docker.push: $(DOCKER_PUSH_TARGETS)
-endif
-
-# Build and push docker images using dockerx
-ifeq ($(DOCKER_V2_BUILDER), true)
-dockerx.push: DOCKERX_PUSH=true
-dockerx.push: dockerx
-	:
-else
-dockerx.push: dockerx
-	$(foreach TGT,$(DOCKER_TARGETS), time ( \
-		set -e && for distro in $(DOCKER_BUILD_VARIANTS); do tag=$(TAG)-$${distro}; docker push $(HUB)/$(subst docker.,,$(TGT)):$${tag%-default}; done); \
-	)
-endif
-
-# Build and push docker images using dockerx. Pushing is done inline as an optimization
-# This is not done in the dockerx.push target because it requires using the docker-container driver.
-# See https://github.com/docker/buildx#working-with-builder-instances for info to set this up
-dockerx.pushx: DOCKERX_PUSH=true
-dockerx.pushx: dockerx
-	@:
-
-# Scan images for security vulnerabilities using the ImageScanner tool
-docker.scan_images: $(DOCKER_PUSH_TARGETS)
-	$(foreach TGT,$(DOCKER_TARGETS),$(call run_vulnerability_scanning,$(subst docker.,,$(TGT)),$(HUB)/$(subst docker.,,$(TGT)):$(TAG)))
+### END Base Images ###
-- 
2.35.3

