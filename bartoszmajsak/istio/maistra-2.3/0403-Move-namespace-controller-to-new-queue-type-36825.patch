From 8d1422be15b57228055721854be30892f7aebe9d Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Wed, 19 Jan 2022 10:57:05 -0800
Subject: Move namespace controller to new queue type (#36825)

* Move namespace controller to new queue type

* ignore lint
---
 .../kube/controller/namespacecontroller.go    | 112 ++++--------------
 .../controller/namespacecontroller_test.go    |  37 +++++-
 2 files changed, 57 insertions(+), 92 deletions(-)

diff --git a/pilot/pkg/serviceregistry/kube/controller/namespacecontroller.go b/pilot/pkg/serviceregistry/kube/controller/namespacecontroller.go
index efbbe0a14e..e29b06f012 100644
--- a/pilot/pkg/serviceregistry/kube/controller/namespacecontroller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/namespacecontroller.go
@@ -15,21 +15,17 @@
 package controller
 
 import (
-	"fmt"
-	"time"
-
 	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/labels"
-	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
-	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/apimachinery/pkg/types"
 	corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
 	listerv1 "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
-	"k8s.io/client-go/util/workqueue"
 
 	"istio.io/istio/pilot/pkg/keycertbundle"
 	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/inject"
 	"istio.io/istio/security/pkg/k8s"
 )
@@ -46,7 +42,7 @@ type NamespaceController struct {
 	client          corev1.CoreV1Interface
 	caBundleWatcher *keycertbundle.Watcher
 
-	queue              workqueue.RateLimitingInterface
+	queue              controllers.Queue
 	namespacesInformer cache.SharedInformer
 	configMapInformer  cache.SharedInformer
 	namespaceLister    listerv1.NamespaceLister
@@ -58,72 +54,40 @@ func NewNamespaceController(kubeClient kube.Client, caBundleWatcher *keycertbund
 	c := &NamespaceController{
 		client:          kubeClient.CoreV1(),
 		caBundleWatcher: caBundleWatcher,
-		queue:           workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),
 	}
+	c.queue = controllers.NewQueue("namespace controller", controllers.WithReconciler(c.insertDataForNamespace))
 
 	c.configMapInformer = kubeClient.KubeInformer().Core().V1().ConfigMaps().Informer()
 	c.configmapLister = kubeClient.KubeInformer().Core().V1().ConfigMaps().Lister()
 	c.namespacesInformer = kubeClient.KubeInformer().Core().V1().Namespaces().Informer()
 	c.namespaceLister = kubeClient.KubeInformer().Core().V1().Namespaces().Lister()
 
-	c.configMapInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
-		UpdateFunc: func(_, obj interface{}) {
-			c.configMapChange(obj)
-		},
-		DeleteFunc: func(obj interface{}) {
-			c.configMapChange(obj)
-		},
-	})
-
-	c.namespacesInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
-		AddFunc: func(obj interface{}) {
-			c.namespaceChange(obj.(*v1.Namespace))
-		},
-		UpdateFunc: func(_, obj interface{}) {
-			c.namespaceChange(obj.(*v1.Namespace))
-		},
-	})
+	c.configMapInformer.AddEventHandler(controllers.FilteredObjectSpecHandler(c.queue.AddObject, func(o controllers.Object) bool {
+		if o.GetName() != CACertNamespaceConfigMap {
+			// This is a change to a configmap we don't watch, ignore it
+			return false
+		}
+		if inject.IgnoredNamespaces.Contains(o.GetNamespace()) {
+			// skip special kubernetes system namespaces
+			return false
+		}
+		return true
+	}))
+	c.namespacesInformer.AddEventHandler(controllers.FilteredObjectSpecHandler(c.queue.AddObject, func(o controllers.Object) bool {
+		return !inject.IgnoredNamespaces.Contains(o.GetName())
+	}))
 
 	return c
 }
 
 // Run starts the NamespaceController until a value is sent to stopCh.
 func (nc *NamespaceController) Run(stopCh <-chan struct{}) {
-	defer nc.queue.ShutDown()
-
 	if !cache.WaitForCacheSync(stopCh, nc.namespacesInformer.HasSynced, nc.configMapInformer.HasSynced) {
 		log.Error("Failed to sync namespace controller cache")
 		return
 	}
-	log.Infof("Namespace controller started")
-	go wait.Until(nc.runWorker, time.Second, stopCh)
 	go nc.startCaBundleWatcher(stopCh)
-
-	<-stopCh
-}
-
-func (nc *NamespaceController) runWorker() {
-	for nc.processNextWorkItem() {
-	}
-}
-
-// processNextWorkItem deals with one key off the queue. It returns false when
-// it's time to quit.
-func (nc *NamespaceController) processNextWorkItem() bool {
-	key, quit := nc.queue.Get()
-	if quit {
-		return false
-	}
-	defer nc.queue.Done(key)
-
-	if err := nc.insertDataForNamespace(key.(string)); err != nil {
-		utilruntime.HandleError(fmt.Errorf("insertDataForNamespace %q failed: %v", key, err))
-		nc.queue.AddRateLimited(key)
-		return true
-	}
-
-	nc.queue.Forget(key)
-	return true
+	nc.queue.Run(stopCh)
 }
 
 // startCaBundleWatcher listens for updates to the CA bundle and update cm in each namespace
@@ -146,7 +110,12 @@ func (nc *NamespaceController) startCaBundleWatcher(stop <-chan struct{}) {
 // insertDataForNamespace will add data into the configmap for the specified namespace
 // If the configmap is not found, it will be created.
 // If you know the current contents of the configmap, using UpdateDataInConfigMap is more efficient.
-func (nc *NamespaceController) insertDataForNamespace(ns string) error {
+func (nc *NamespaceController) insertDataForNamespace(o types.NamespacedName) error {
+	ns := o.Namespace
+	if ns == "" {
+		// For Namespace object, it will not have o.Namespace field set
+		ns = o.Name
+	}
 	meta := metav1.ObjectMeta{
 		Name:      CACertNamespaceConfigMap,
 		Namespace: ns,
@@ -163,39 +132,10 @@ func (nc *NamespaceController) namespaceChange(ns *v1.Namespace) {
 	}
 }
 
-// On configMap change(update or delete), try to create or update the config map.
-func (nc *NamespaceController) configMapChange(obj interface{}) {
-	cm, err := convertToConfigMap(obj)
-	if err != nil {
-		log.Errorf("failed to convert to configmap: %v", err)
-		return
-	}
-	// This is a change to a configmap we don't watch, ignore it
-	if cm.Name != CACertNamespaceConfigMap {
-		return
-	}
-	nc.syncNamespace(cm.Namespace)
-}
-
 func (nc *NamespaceController) syncNamespace(ns string) {
 	// skip special kubernetes system namespaces
 	if inject.IgnoredNamespaces.Contains(ns) {
 		return
 	}
-	nc.queue.Add(ns)
-}
-
-func convertToConfigMap(obj interface{}) (*v1.ConfigMap, error) {
-	cm, ok := obj.(*v1.ConfigMap)
-	if !ok {
-		tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
-		if !ok {
-			return nil, fmt.Errorf("couldn't get object from tombstone %#v", obj)
-		}
-		cm, ok = tombstone.Obj.(*v1.ConfigMap)
-		if !ok {
-			return nil, fmt.Errorf("tombstone contained object that is not a ConfigMap %#v", obj)
-		}
-	}
-	return cm, nil
+	nc.queue.Add(types.NamespacedName{Name: ns})
 }
diff --git a/pilot/pkg/serviceregistry/kube/controller/namespacecontroller_test.go b/pilot/pkg/serviceregistry/kube/controller/namespacecontroller_test.go
index fcd82f6799..b6328623fa 100644
--- a/pilot/pkg/serviceregistry/kube/controller/namespacecontroller_test.go
+++ b/pilot/pkg/serviceregistry/kube/controller/namespacecontroller_test.go
@@ -46,25 +46,33 @@ func TestNamespaceController(t *testing.T) {
 	})
 	client.RunAndWait(stop)
 	go nc.Run(stop)
+	retry.UntilOrFail(t, nc.queue.HasSynced)
 
 	expectedData := map[string]string{
 		constants.CACertNamespaceConfigMapDataName: string(caBundle),
 	}
 	createNamespace(t, client, "foo", nil)
-	expectConfigMap(t, nc.configmapLister, "foo", expectedData)
+	expectConfigMap(t, nc.configmapLister, CACertNamespaceConfigMap, "foo", expectedData)
+
+	// Make sure random configmap does not get updated
+	cmData := createConfigMap(t, client, "not-root", "foo", "k")
+	expectConfigMap(t, nc.configmapLister, "not-root", "foo", cmData)
 
 	newCaBundle := []byte("caBundle-new")
 	watcher.SetAndNotify(nil, nil, newCaBundle)
 	newData := map[string]string{
 		constants.CACertNamespaceConfigMapDataName: string(newCaBundle),
 	}
-	expectConfigMap(t, nc.configmapLister, "foo", newData)
+	expectConfigMap(t, nc.configmapLister, CACertNamespaceConfigMap, "foo", newData)
 
 	deleteConfigMap(t, client, "foo")
-	expectConfigMap(t, nc.configmapLister, "foo", newData)
+	expectConfigMap(t, nc.configmapLister, CACertNamespaceConfigMap, "foo", newData)
 
 	for _, namespace := range inject.IgnoredNamespaces.UnsortedList() {
+		// Create namespace in ignored list, make sure its not created
 		createNamespace(t, client, namespace, newData)
+		// Configmap in that namespace should not do anything either
+		createConfigMap(t, client, "not-root", namespace, "k")
 		expectConfigMapNotExist(t, nc.configmapLister, namespace)
 	}
 }
@@ -80,6 +88,22 @@ func deleteConfigMap(t *testing.T, client kubernetes.Interface, ns string) {
 	}
 }
 
+func createConfigMap(t *testing.T, client kubernetes.Interface, name, ns, key string) map[string]string {
+	t.Helper()
+	data := map[string]string{key: "v"}
+	_, err := client.CoreV1().ConfigMaps(ns).Create(context.Background(), &v1.ConfigMap{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      name,
+			Namespace: ns,
+		},
+		Data: data,
+	}, metav1.CreateOptions{})
+	if err != nil {
+		t.Fatal(err)
+	}
+	return data
+}
+
 func createNamespace(t *testing.T, client kubernetes.Interface, ns string, labels map[string]string) {
 	t.Helper()
 	if _, err := client.CoreV1().Namespaces().Create(context.TODO(), &v1.Namespace{
@@ -98,10 +122,11 @@ func updateNamespace(t *testing.T, client kubernetes.Interface, ns string, label
 	}
 }
 
-func expectConfigMap(t *testing.T, client listerv1.ConfigMapLister, ns string, data map[string]string) {
+// nolint:unparam
+func expectConfigMap(t *testing.T, client listerv1.ConfigMapLister, name, ns string, data map[string]string) {
 	t.Helper()
 	retry.UntilSuccessOrFail(t, func() error {
-		cm, err := client.ConfigMaps(ns).Get(CACertNamespaceConfigMap)
+		cm, err := client.ConfigMaps(ns).Get(name)
 		if err != nil {
 			return err
 		}
@@ -117,7 +142,7 @@ func expectConfigMapNotExist(t *testing.T, client listerv1.ConfigMapLister, ns s
 	err := retry.Until(func() bool {
 		_, err := client.ConfigMaps(ns).Get(CACertNamespaceConfigMap)
 		return err == nil
-	}, retry.Timeout(time.Millisecond*100))
+	}, retry.Timeout(time.Millisecond*25))
 
 	if err == nil {
 		t.Fatalf("%s namespace should not have istio-ca-root-cert configmap.", ns)
-- 
2.35.3

