From e8bcd261bb1589f6c4c98f5ea4240e70f85a5c81 Mon Sep 17 00:00:00 2001
From: Iris <irisdingbj@gmail.com>
Date: Wed, 23 Feb 2022 00:41:53 +0800
Subject: do not compare cert bytes directly (#37319)

* do not compare cert bytes directly

* fix lint

* add a unit test to cover intermediate CA case

* fix lint

* add comments and more test case

* return error if no root cert can be found
---
 security/pkg/pki/ra/k8s_ra.go                 |  43 ++++--
 security/pkg/pki/ra/k8s_ra_test.go            | 132 +++++++++++-------
 .../security/external_ca/main_test.go         |  51 +++----
 3 files changed, 136 insertions(+), 90 deletions(-)

diff --git a/security/pkg/pki/ra/k8s_ra.go b/security/pkg/pki/ra/k8s_ra.go
index d2d8f847e2..91d39eaf4a 100644
--- a/security/pkg/pki/ra/k8s_ra.go
+++ b/security/pkg/pki/ra/k8s_ra.go
@@ -29,6 +29,7 @@
 	"istio.io/istio/security/pkg/pki/ca"
 	raerror "istio.io/istio/security/pkg/pki/error"
 	"istio.io/istio/security/pkg/pki/util"
+	"istio.io/pkg/log"
 )
 
 // KubernetesRA integrated with an external CA using Kubernetes CSR API
@@ -42,6 +43,8 @@ type KubernetesRA struct {
 	mutex sync.RWMutex
 }
 
+var pkiRaLog = log.RegisterScope("pkira", "Istiod RA log", 0)
+
 // NewKubernetesRA : Create a RA that interfaces with K8S CSR CA
 func NewKubernetesRA(raOpts *IstioRAOptions) (*KubernetesRA, error) {
 	keyCertBundle, err := util.NewKeyCertBundleWithRootCertFromFile(raOpts.CaCertFile)
@@ -95,6 +98,20 @@ func (r *KubernetesRA) Sign(csrPEM []byte, certOpts ca.CertOpts) ([]byte, error)
 }
 
 // SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
+// root cert comes from two sources, order matters:
+// 1. Specified in mesh config
+// 2. Extract from the cert-chain signed by the CSR signer.
+// If no root cert can be found from either of the two sources, error returned.
+// There are several possible situations:
+// 1. root cert is specified in mesh config and is empty in signed cert chain, in this case
+// we verify the signed cert chain against the root cert from mesh config and append the
+// root cert into the cert chain.
+// 2. root cert is specified in mesh config and also can be extracted in signed cert chain, in this
+// case we verify the signed cert chain against the root cert from mesh config and append it
+// into the cert chain if the two root certs are different. This is typical when
+// the returned cert chain only contains the intermediate CA.
+// 3. root cert is not specified in mesh config but can be extracted in signed cert chain, in this case
+// we verify the signed cert chain against the root cert and return the cert chain directly.
 func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([]string, error) {
 	cert, err := r.Sign(csrPEM, certOpts)
 	if err != nil {
@@ -105,7 +122,7 @@ func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([
 		cert = append(cert, chainPem...)
 	}
 	respCertChain := []string{string(cert)}
-	var rootCert, rootCertFromMeshConfig, rootCertFromCertChain []byte
+	var possibleRootCert, rootCertFromMeshConfig, rootCertFromCertChain []byte
 	certSigner := r.certSignerDomain + "/" + certOpts.CertSigner
 	if len(r.GetCAKeyCertBundle().GetRootCertPem()) == 0 {
 		rootCertFromCertChain, err = util.FindRootCertFromCertificateChainBytes(cert)
@@ -114,26 +131,22 @@ func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([
 		}
 		rootCertFromMeshConfig, err = r.GetRootCertFromMeshConfig(certSigner)
 		if err != nil {
-			return nil, fmt.Errorf("failed to find root cert from mesh config (%v)", err.Error())
-		}
-		if rootCertFromCertChain != nil && rootCertFromMeshConfig != nil {
-			if !bytes.Equal(rootCertFromCertChain, rootCertFromMeshConfig) {
-				return nil, fmt.Errorf("root cert from signed cert-chain" +
-					" is conflicting with the one specified in mesh config")
-			}
+			pkiRaLog.Infof("failed to find root cert from mesh config (%v)", err.Error())
 		}
 		if rootCertFromMeshConfig != nil {
-			rootCert = rootCertFromMeshConfig
+			possibleRootCert = rootCertFromMeshConfig
+		} else if rootCertFromCertChain != nil {
+			possibleRootCert = rootCertFromCertChain
 		}
-
-		if rootCertFromCertChain != nil {
-			rootCert = rootCertFromCertChain
+		if possibleRootCert == nil {
+			return nil, fmt.Errorf("failed to find root cert from either signed cert-chain or mesh config")
 		}
-
-		if verifyErr := util.VerifyCertificate(nil, cert, rootCert, nil); verifyErr != nil {
+		if verifyErr := util.VerifyCertificate(nil, cert, possibleRootCert, nil); verifyErr != nil {
 			return nil, fmt.Errorf("root cert from signed cert-chain is invalid %v ", verifyErr)
 		}
-		respCertChain = append(respCertChain, string(rootCert))
+		if !bytes.Equal(possibleRootCert, rootCertFromCertChain) {
+			respCertChain = append(respCertChain, string(possibleRootCert))
+		}
 	}
 	return respCertChain, nil
 }
diff --git a/security/pkg/pki/ra/k8s_ra_test.go b/security/pkg/pki/ra/k8s_ra_test.go
index ddbf0948d2..eefbce701b 100644
--- a/security/pkg/pki/ra/k8s_ra_test.go
+++ b/security/pkg/pki/ra/k8s_ra_test.go
@@ -58,8 +58,9 @@
 )
 
 var (
-	testCsrHostName string = spiffe.Identity{TrustDomain: "cluster.local", Namespace: "default", ServiceAccount: "bookinfo-productpage"}.String()
-	TestCACertFile  string = "../testdata/example-ca-cert.pem"
+	testCsrHostName       string = spiffe.Identity{TrustDomain: "cluster.local", Namespace: "default", ServiceAccount: "bookinfo-productpage"}.String()
+	TestCACertFile        string = "../testdata/example-ca-cert.pem"
+	mismatchCertChainFile string = "../testdata/cert-chain.pem"
 )
 
 func defaultReactionFunc(obj runtime.Object) kt.ReactionFunc {
@@ -68,6 +69,85 @@ func defaultReactionFunc(obj runtime.Object) kt.ReactionFunc {
 	}
 }
 
+func TestK8sSignWithMeshConfig(t *testing.T) {
+	cases := map[string]struct {
+		rootCertForMeshConfig        string
+		certChain                    string
+		updatedRootCertForMeshConfig string
+		expectedFail                 bool
+	}{
+		"Root cert from mesh config and cert chain does not match": {
+			rootCertForMeshConfig: path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"),
+			certChain:             mismatchCertChainFile,
+			expectedFail:          true,
+		},
+		"Root cert is specified in mesh config and Root cert from cert chain is empty(only one leaf cert)": {
+			rootCertForMeshConfig: path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"),
+			certChain:             path.Join(env.IstioSrc, "samples/certs", "cert-chain.pem"),
+		},
+		"Root cert is specified in mesh config and cert chain contains only intermediate CA(only leaf cert + intermediate CA) ": {
+			rootCertForMeshConfig: path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"),
+			certChain:             path.Join(env.IstioSrc, "samples/certs", "workload-foo-cert.pem"),
+		},
+		"Root cert is specified in mesh config and be updated to an invalid value": {
+			rootCertForMeshConfig:        path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"),
+			certChain:                    path.Join(env.IstioSrc, "samples/certs", "cert-chain.pem"),
+			updatedRootCertForMeshConfig: TestCACertFile,
+			expectedFail:                 true,
+		},
+	}
+	for id, tc := range cases {
+		csrPEM := createFakeCsr(t)
+		csrName := chiron.GenCsrName()
+		rootCertPem, err := os.ReadFile(tc.rootCertForMeshConfig)
+		if err != nil {
+			t.Errorf("Failed to read sample root-cert.pem")
+		}
+		certChainPem, err := os.ReadFile(tc.certChain)
+		if err != nil {
+			t.Errorf("Failed to read sample cert-chain.pem")
+		}
+		client := initFakeKubeClient(csrName, string(certChainPem))
+		ra, err := createFakeK8sRA(client, "")
+		if err != nil {
+			t.Errorf("Failed to create Fake K8s RA")
+		}
+		signer := "kubernates.io/kube-apiserver-client"
+		ra.certSignerDomain = "kubernates.io"
+		caCertificates := []*meshconfig.MeshConfig_CertificateData{
+			{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(rootCertPem)}, CertSigners: []string{signer}},
+		}
+		ra.SetCACertificatesFromMeshConfig(caCertificates)
+		subjectID := spiffe.Identity{TrustDomain: "cluster.local", Namespace: "default", ServiceAccount: "bookinfo-productpage"}.String()
+		certOptions := ca.CertOpts{
+			SubjectIDs: []string{subjectID},
+			TTL:        60 * time.Second, ForCA: false,
+			CertSigner: "kube-apiserver-client",
+		}
+		// expect to sign back successfully
+		_, err = ra.SignWithCertChain(csrPEM, certOptions)
+		if err != nil && !tc.expectedFail {
+			t.Errorf("%s failed", id)
+		}
+		if tc.updatedRootCertForMeshConfig != "" {
+			testCACert, err := os.ReadFile(tc.updatedRootCertForMeshConfig)
+			if err != nil && !tc.expectedFail {
+				t.Errorf("Failed to read test CA Cert file")
+			}
+			updatedCACertificates := []*meshconfig.MeshConfig_CertificateData{
+				{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(testCACert)}, CertSigners: []string{signer}},
+			}
+			ra.SetCACertificatesFromMeshConfig(updatedCACertificates)
+			// expect failure in sign since root cert in mesh config does not match
+			_, err = ra.SignWithCertChain(csrPEM, certOptions)
+			if err == nil && !tc.expectedFail {
+				t.Errorf("%s failed", id)
+			}
+		}
+
+	}
+}
+
 func createFakeCsr(t *testing.T) []byte {
 	options := pkiutil.CertOptions{
 		Host:       testCsrHostName,
@@ -113,54 +193,6 @@ func createFakeK8sRA(client *fake.Clientset, caCertFile string) (*KubernetesRA,
 	return NewKubernetesRA(raOpts)
 }
 
-func TestK8sSignWithMeshConfig(t *testing.T) {
-	csrPEM := createFakeCsr(t)
-	csrName := chiron.GenCsrName()
-	rootCertPem, err := os.ReadFile(path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"))
-	if err != nil {
-		t.Errorf("Failed to read sample root-cert.pem")
-	}
-	certChainPem, err := os.ReadFile(path.Join(env.IstioSrc, "samples/certs", "cert-chain.pem"))
-	if err != nil {
-		t.Errorf("Failed to read sample cert-chain.pem")
-	}
-	client := initFakeKubeClient(csrName, string(certChainPem))
-	ra, err := createFakeK8sRA(client, "")
-	if err != nil {
-		t.Errorf("Failed to create Fake K8s RA")
-	}
-	signer := "kubernates.io/kube-apiserver-client"
-	ra.certSignerDomain = "kubernates.io"
-	caCertificates := []*meshconfig.MeshConfig_CertificateData{
-		{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(rootCertPem)}, CertSigners: []string{signer}},
-	}
-	ra.SetCACertificatesFromMeshConfig(caCertificates)
-	subjectID := spiffe.Identity{TrustDomain: "cluster.local", Namespace: "default", ServiceAccount: "bookinfo-productpage"}.String()
-	certOptions := ca.CertOpts{
-		SubjectIDs: []string{subjectID},
-		TTL:        60 * time.Second, ForCA: false,
-		CertSigner: "kube-apiserver-client",
-	}
-	// expect to sign back successfully
-	_, err = ra.SignWithCertChain(csrPEM, certOptions)
-	if err != nil {
-		t.Errorf("K8s CA Signing CSR With Root Cert In Meshconfig failed")
-	}
-	testCACert, err := os.ReadFile(TestCACertFile)
-	if err != nil {
-		t.Errorf("Failed to read test CA Cert file")
-	}
-	updatedCACertificates := []*meshconfig.MeshConfig_CertificateData{
-		{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(testCACert)}, CertSigners: []string{signer}},
-	}
-	ra.SetCACertificatesFromMeshConfig(updatedCACertificates)
-	// expect failure in sign since root cert in mesh config does not match
-	_, err = ra.SignWithCertChain(csrPEM, certOptions)
-	if err == nil {
-		t.Errorf("K8s CA Signing CSR With Root Cert In Meshconfig failed")
-	}
-}
-
 // TestK8sSign : Verify that ra.k8sSign returns a valid certPEM while using k8s Fake Client to create a CSR
 func TestK8sSign(t *testing.T) {
 	csrPEM := createFakeCsr(t)
diff --git a/tests/integration/security/external_ca/main_test.go b/tests/integration/security/external_ca/main_test.go
index 226e553843..aecc00bd2b 100644
--- a/tests/integration/security/external_ca/main_test.go
+++ b/tests/integration/security/external_ca/main_test.go
@@ -119,31 +119,32 @@ func setupConfig(ctx resource.Context, cfg *istio.Config) {
 {{.rootcert2 | indent 8}}
       certSigners:
       - {{.signer2}}
-  components:
-    pilot:
-      k8s:
-        env:
-        - name: CERT_SIGNER_DOMAIN
-          value: clusterissuers.istio.io
-        - name: EXTERNAL_CA
-          value: ISTIOD_RA_KUBERNETES_API
-        - name: PILOT_CERT_PROVIDER
-          value: k8s.io/clusterissuers.istio.io/signer2
-        overlays:
-          # Amend ClusterRole to add permission for istiod to approve certificate signing by custom signer
-          - kind: ClusterRole
-            name: istiod-clusterrole-istio-system
-            patches:
-              - path: rules[-1]
-                value: |
-                  apiGroups:
-                  - certificates.k8s.io
-                  resourceNames:
-                  - clusterissuers.istio.io/*
-                  resources:
-                  - signers
-                  verbs:
-                  - approve
+components:
+  pilot:
+    enabled: true
+    k8s:
+      env:
+      - name: CERT_SIGNER_DOMAIN
+        value: clusterissuers.istio.io
+      - name: EXTERNAL_CA
+        value: ISTIOD_RA_KUBERNETES_API
+      - name: PILOT_CERT_PROVIDER
+        value: k8s.io/clusterissuers.istio.io/signer2
+      overlays:
+        # Amend ClusterRole to add permission for istiod to approve certificate signing by custom signer
+        - kind: ClusterRole
+          name: istiod-clusterrole-istio-system
+          patches:
+            - path: rules[-1]
+              value: |
+                apiGroups:
+                - certificates.k8s.io
+                resourceNames:
+                - clusterissuers.istio.io/*
+                resources:
+                - signers
+                verbs:
+                - approve
 `, map[string]string{"rootcert1": cert1.Rootcert, "signer1": cert1.Signer, "rootcert2": cert2.Rootcert, "signer2": cert2.Signer})
 	cfg.ControlPlaneValues = cfgYaml
 	cfg.DeployEastWestGW = false
-- 
2.35.3

