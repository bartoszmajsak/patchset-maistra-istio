From 8493539095b354e99da1ee42cc75d6d79144f157 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 19 May 2022 20:24:30 -0700
Subject: [tf] Echo cleanup tcp server (#39038)

This adds better logging for the TCP server and also avoids forceClose when the request completes normally.
---
 pkg/test/echo/server/endpoint/tcp.go  | 60 ++++++++++++++++++---------
 pkg/test/echo/server/endpoint/util.go | 19 ++-------
 2 files changed, 44 insertions(+), 35 deletions(-)

diff --git a/pkg/test/echo/server/endpoint/tcp.go b/pkg/test/echo/server/endpoint/tcp.go
index 87eb4e193f..abaab0d49c 100644
--- a/pkg/test/echo/server/endpoint/tcp.go
+++ b/pkg/test/echo/server/endpoint/tcp.go
@@ -22,6 +22,8 @@
 	"net/http"
 	"os"
 	"strconv"
+	"strings"
+	"time"
 
 	"github.com/google/uuid"
 
@@ -87,9 +89,25 @@ func (s *tcpInstance) Start(onReady OnReadyFunc) error {
 				return
 			}
 
-			go s.echo(conn)
-
-			forceCloseAfterTimeout(conn)
+			id := uuid.New()
+			epLog.WithLabels("remote", conn.RemoteAddr(), "id", id).Infof("TCP Request")
+
+			done := make(chan struct{})
+			go func() {
+				s.echo(id, conn)
+				close(done)
+			}()
+
+			go func() {
+				select {
+				case <-done:
+					return
+				case <-time.After(requestTimeout):
+					epLog.WithLabels("id", id).Warnf("TCP forcing connection closed after request timeout")
+					_ = forceClose(conn)
+					return
+				}
+			}()
 		}
 	}()
 
@@ -100,13 +118,13 @@ func (s *tcpInstance) Start(onReady OnReadyFunc) error {
 }
 
 // Handles incoming connection.
-func (s *tcpInstance) echo(conn net.Conn) {
-	defer common.Metrics.TCPRequests.With(common.PortLabel.Value(strconv.Itoa(s.Port.Port))).Increment()
+func (s *tcpInstance) echo(id uuid.UUID, conn net.Conn) {
+	common.Metrics.TCPRequests.With(common.PortLabel.Value(strconv.Itoa(s.Port.Port))).Increment()
 
 	var err error
 	defer func() {
 		if err != nil && err != io.EOF {
-			forceClose(conn)
+			_ = forceClose(conn)
 		} else {
 			_ = conn.Close()
 		}
@@ -115,13 +133,13 @@ func (s *tcpInstance) echo(conn net.Conn) {
 	// If this is server first, client expects a message from server. Send the magic string.
 	if s.Port.ServerFirst {
 		if _, err = conn.Write([]byte(common.ServerFirstMagicString)); err != nil {
+			epLog.WithLabels("id", id).Warnf("TCP server-first write failed: %v", err)
 			return
 		}
 	}
 
-	id := uuid.New()
-	epLog.WithLabels("remote", conn.RemoteAddr(), "id", id).Infof("TCP Request")
 	firstReply := true
+	responseFields := ""
 	buf := make([]byte, 4096)
 	for {
 		var n int
@@ -130,12 +148,15 @@ func (s *tcpInstance) echo(conn net.Conn) {
 		// important not to start sending any response until we've started reading the message,
 		// otherwise the response could be read when we expect the magic string
 		if firstReply {
-			s.writeResponse(conn)
+			responseFields = s.getResponseFields(conn)
+			if _, writeErr := conn.Write([]byte(responseFields)); writeErr != nil {
+				epLog.WithLabels("id", id).Warnf("TCP failed writing response fields: %v", writeErr)
+			}
 			firstReply = false
 		}
 
 		if err != nil && err != io.EOF {
-			epLog.Warnf("TCP read failed: %v", err.Error())
+			epLog.WithLabels("id", id).Warnf("TCP read failed: %v", err)
 			break
 		}
 
@@ -143,7 +164,7 @@ func (s *tcpInstance) echo(conn net.Conn) {
 		if n > 0 {
 			out := buf[:n]
 			if _, err = conn.Write(out); err != nil {
-				epLog.Warnf("TCP write failed, :%v", err)
+				epLog.WithLabels("id", id).Warnf("TCP failed writing echo response: %v", err)
 				break
 			}
 		}
@@ -154,10 +175,10 @@ func (s *tcpInstance) echo(conn net.Conn) {
 		}
 	}
 
-	epLog.WithLabels("id", id).Infof("TCP Response")
+	epLog.WithLabels("id", id).Infof("TCP Response Fields:\n%s", responseFields)
 }
 
-func (s *tcpInstance) writeResponse(conn net.Conn) {
+func (s *tcpInstance) getResponseFields(conn net.Conn) string {
 	ip, _, _ := net.SplitHostPort(conn.RemoteAddr().String())
 	// Write non-request fields specific to the instance
 	respFields := map[echo.Field]string{
@@ -173,19 +194,18 @@ func (s *tcpInstance) writeResponse(conn net.Conn) {
 	if hostname, err := os.Hostname(); err == nil {
 		respFields[echo.HostnameField] = hostname
 	}
+
+	var out strings.Builder
 	for field, val := range respFields {
 		val := fmt.Sprintf("%s=%s\n", string(field), val)
-		_, err := conn.Write([]byte(val))
-		if err != nil {
-			epLog.Warnf("TCP write failed %q: %v", val, err)
-			break
-		}
+		_, _ = out.WriteString(val)
 	}
+	return out.String()
 }
 
 func (s *tcpInstance) Close() error {
 	if s.l != nil {
-		s.l.Close()
+		_ = s.l.Close()
 	}
 	return nil
 }
@@ -198,7 +218,7 @@ func (s *tcpInstance) awaitReady(onReady OnReadyFunc, address string) {
 		if err != nil {
 			return err
 		}
-		defer conn.Close()
+		defer func() { _ = conn.Close() }()
 
 		// Server is up now, we're ready.
 		return nil
diff --git a/pkg/test/echo/server/endpoint/util.go b/pkg/test/echo/server/endpoint/util.go
index 3df0ee536b..01baac6606 100644
--- a/pkg/test/echo/server/endpoint/util.go
+++ b/pkg/test/echo/server/endpoint/util.go
@@ -79,21 +79,10 @@ func listenOnUDS(uds string) (net.Listener, error) {
 }
 
 // forceClose the given socket.
-func forceClose(conn net.Conn) {
-	// Force the connection closed (should result in sending RST)
-	err := conn.(*net.TCPConn).SetLinger(0)
-	if err != nil {
-		epLog.Infof("Failed force-closing server connection: %s", err)
-	}
-
+func forceClose(conn net.Conn) error {
 	// Close may be called more than once.
-	_ = conn.Close()
-}
+	defer func() { _ = conn.Close() }()
 
-// forceCloseAfterTimeout starts a go routine that forces the connection closed after a time.
-func forceCloseAfterTimeout(conn net.Conn) {
-	go func() {
-		<-time.After(requestTimeout)
-		forceClose(conn)
-	}()
+	// Force the connection closed (should result in sending RST)
+	return conn.(*net.TCPConn).SetLinger(0)
 }
-- 
2.35.3

