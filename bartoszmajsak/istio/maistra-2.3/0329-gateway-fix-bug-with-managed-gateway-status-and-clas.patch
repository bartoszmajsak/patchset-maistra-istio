From 4aa10dd017da53bae406e90442e209d154c5549b Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Tue, 4 Jan 2022 18:09:05 -0800
Subject: gateway: fix bug with managed gateway status and class (#36602)

Two bugs:
* `setOnce` was supposed to only set status once. The problem is the
status is always set by Kubernetes by default due to CRD defaulting.
Handle that using the special NotReconciled status reason
* GatewayClass only looks at the *name*, not the *controller*. Update
this to use the same (correct) logic the main code uses.

We definitely need more test coverage here. I am looking into how we can get
defaults for the first case, for the latter we just need more time.
---
 pilot/pkg/config/kube/gateway/conditions.go   | 10 ++--
 pilot/pkg/config/kube/gateway/conversion.go   |  2 +-
 .../kube/gateway/deploymentcontroller.go      | 47 ++++++++++++++-----
 pilot/pkg/model/kstatus/helper.go             |  7 ++-
 4 files changed, 49 insertions(+), 17 deletions(-)

diff --git a/pilot/pkg/config/kube/gateway/conditions.go b/pilot/pkg/config/kube/gateway/conditions.go
index c0273efd6f..aa55c8113e 100644
--- a/pilot/pkg/config/kube/gateway/conditions.go
+++ b/pilot/pkg/config/kube/gateway/conditions.go
@@ -134,8 +134,8 @@ type condition struct {
 	// error defines an error state; the reason and message will be replaced with that of the error and
 	// the status inverted
 	error *ConfigError
-	// setOnce, if enabled, will only set the condition if it is not yet present
-	setOnce bool
+	// setOnce, if enabled, will only set the condition if it is not yet present or set to this reason
+	setOnce string
 }
 
 // setConditions sets the existingConditions with the new conditions
@@ -149,8 +149,10 @@ func setConditions(generation int64, existingConditions []metav1.Condition, cond
 	for _, k := range condKeys {
 		cond := conditions[k]
 		setter := kstatus.UpdateConditionIfChanged
-		if cond.setOnce {
-			setter = kstatus.CreateCondition
+		if cond.setOnce != "" {
+			setter = func(conditions []metav1.Condition, condition metav1.Condition) []metav1.Condition {
+				return kstatus.CreateCondition(conditions, condition, cond.setOnce)
+			}
 		}
 		// A condition can be "negative polarity" (ex: ListenerInvalid) or "positive polarity" (ex:
 		// ListenerValid), so in order to determine the status we should set each `condition` defines its
diff --git a/pilot/pkg/config/kube/gateway/conversion.go b/pilot/pkg/config/kube/gateway/conversion.go
index 5da3288bd1..72a84d5cef 100644
--- a/pilot/pkg/config/kube/gateway/conversion.go
+++ b/pilot/pkg/config/kube/gateway/conversion.go
@@ -1033,7 +1033,7 @@ func convertGateways(r *KubernetesResources) ([]config.Config, map[parentKey]map
 					Reason:  "ResourcesPending",
 					Message: "Resources not yet deployed to the cluster",
 				},
-				setOnce: true,
+				setOnce: string(k8s.GatewayReasonNotReconciled), // Default reason
 			}
 		} else {
 			gatewayConditions[string(k8s.GatewayConditionScheduled)] = &condition{
diff --git a/pilot/pkg/config/kube/gateway/deploymentcontroller.go b/pilot/pkg/config/kube/gateway/deploymentcontroller.go
index efc03b691c..acfda74576 100644
--- a/pilot/pkg/config/kube/gateway/deploymentcontroller.go
+++ b/pilot/pkg/config/kube/gateway/deploymentcontroller.go
@@ -27,12 +27,14 @@
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	klabels "k8s.io/apimachinery/pkg/labels"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	appsinformersv1 "k8s.io/client-go/informers/apps/v1"
 	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/tools/cache"
 	gateway "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	"sigs.k8s.io/gateway-api/pkg/client/listers/gateway/apis/v1alpha2"
 	"sigs.k8s.io/yaml"
 
 	"istio.io/istio/pkg/config"
@@ -66,10 +68,12 @@
 // * SSA using standard API types doesn't work well either: https://github.com/kubernetes-sigs/controller-runtime/issues/1669
 // * This leaves YAML templates, converted to unstructured types and Applied with the dynamic client.
 type DeploymentController struct {
-	client    kube.Client
-	queue     controllers.Queue
-	templates *template.Template
-	patcher   patcher
+	client             kube.Client
+	queue              controllers.Queue
+	templates          *template.Template
+	patcher            patcher
+	gatewayLister      v1alpha2.GatewayLister
+	gatewayClassLister v1alpha2.GatewayClassLister
 }
 
 // Patcher is a function that abstracts patching logic. This is largely because client-go fakes do not handle patching
@@ -78,6 +82,8 @@ type DeploymentController struct {
 // NewDeploymentController constructs a DeploymentController and registers required informers.
 // The controller will not start until Run() is called.
 func NewDeploymentController(client kube.Client) *DeploymentController {
+	gw := client.GatewayAPIInformer().Gateway().V1alpha2().Gateways()
+	gwc := client.GatewayAPIInformer().Gateway().V1alpha2().GatewayClasses()
 	dc := &DeploymentController{
 		client:    client,
 		templates: processTemplates(),
@@ -90,6 +96,8 @@ func NewDeploymentController(client kube.Client) *DeploymentController {
 			}, subresources...)
 			return err
 		},
+		gatewayLister:      gw.Lister(),
+		gatewayClassLister: gwc.Lister(),
 	}
 	dc.queue = controllers.NewQueue("gateway deployment",
 		controllers.WithReconciler(dc.Reconcile),
@@ -116,8 +124,16 @@ func(options *metav1.ListOptions) {
 	}).AddEventHandler(handler)
 
 	// Use the full informer; we are already watching all Gateways for the core Istiod logic
-	client.GatewayAPIInformer().Gateway().V1alpha2().Gateways().Informer().
-		AddEventHandler(controllers.ObjectHandler(dc.queue.AddObject))
+	gw.Informer().AddEventHandler(controllers.ObjectHandler(dc.queue.AddObject))
+	gwc.Informer().AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
+		o.GetName()
+		gws, _ := dc.gatewayLister.List(klabels.Everything())
+		for _, g := range gws {
+			if string(g.Spec.GatewayClassName) == o.GetName() {
+				dc.queue.AddObject(g)
+			}
+		}
+	}))
 
 	return dc
 }
@@ -130,7 +146,7 @@ func (d *DeploymentController) Run(stop <-chan struct{}) {
 func (d *DeploymentController) Reconcile(req types.NamespacedName) error {
 	log := log.WithLabels("gateway", req)
 
-	gw, err := d.client.GatewayAPIInformer().Gateway().V1alpha2().Gateways().Lister().Gateways(req.Namespace).Get(req.Name)
+	gw, err := d.gatewayLister.Gateways(req.Namespace).Get(req.Name)
 	if err != nil || gw == nil {
 		log.Errorf("unable to fetch Gateway: %v", err)
 		// we'll ignore not-found errors, since they can't be fixed by an immediate
@@ -139,12 +155,21 @@ func (d *DeploymentController) Reconcile(req types.NamespacedName) error {
 		return controllers.IgnoreNotFound(err)
 	}
 
-	switch gw.Spec.GatewayClassName {
-	case DefaultClassName:
-		return d.configureIstioGateway(log, *gw)
+	gc, _ := d.gatewayClassLister.Get(string(gw.Spec.GatewayClassName))
+	if gc != nil {
+		// We found the gateway class, but we do not implement it. Skip
+		if gc.Spec.ControllerName != ControllerName {
+			return nil
+		}
+	} else {
+		// Didn't find gateway class... it must use implicit Istio one.
+		if gw.Spec.GatewayClassName != DefaultClassName {
+			return nil
+		}
 	}
 
-	return nil
+	// Matched class, reconcile it
+	return d.configureIstioGateway(log, *gw)
 }
 
 func (d *DeploymentController) configureIstioGateway(log *istiolog.Scope, gw gateway.Gateway) error {
diff --git a/pilot/pkg/model/kstatus/helper.go b/pilot/pkg/model/kstatus/helper.go
index 2327b25371..d2be8c62b7 100644
--- a/pilot/pkg/model/kstatus/helper.go
+++ b/pilot/pkg/model/kstatus/helper.go
@@ -108,12 +108,17 @@ func UpdateConditionIfChanged(conditions []metav1.Condition, condition metav1.Co
 }
 
 // CreateCondition sets a condition only if it has not already been set
-func CreateCondition(conditions []metav1.Condition, condition metav1.Condition) []metav1.Condition {
+func CreateCondition(conditions []metav1.Condition, condition metav1.Condition, unsetReason string) []metav1.Condition {
 	ret := append([]metav1.Condition(nil), conditions...)
 	idx := -1
 	for i, cond := range ret {
 		if cond.Type == condition.Type {
 			idx = i
+			if cond.Reason == unsetReason {
+				// Condition is set, but its for unsetReason. This is needed because some conditions have defaults
+				ret[idx] = condition
+				return ret
+			}
 			break
 		}
 	}
-- 
2.35.3

