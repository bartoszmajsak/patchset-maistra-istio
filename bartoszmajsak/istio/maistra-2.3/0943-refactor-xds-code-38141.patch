From 7bd2eae8a083070ef417e40531c382529b1aea34 Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Wed, 30 Mar 2022 20:26:57 +0530
Subject: refactor xds code (#38141)

* refactor xds code

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* move delta back

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* revert authenticate

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* revert delta

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 pilot/pkg/xds/ads.go            | 71 ++++++++++++++++-----------------
 pilot/pkg/xds/auth.go           |  2 +-
 pilot/pkg/xds/debug.go          | 20 +++++-----
 pilot/pkg/xds/delta.go          | 44 ++++++++++----------
 pilot/pkg/xds/discovery.go      |  4 +-
 pilot/pkg/xds/discovery_test.go |  6 +--
 pilot/pkg/xds/pushqueue_test.go |  6 +--
 pilot/pkg/xds/xdsgen.go         |  2 +-
 8 files changed, 76 insertions(+), 79 deletions(-)

diff --git a/pilot/pkg/xds/ads.go b/pilot/pkg/xds/ads.go
index 64ddef0486..f02037328f 100644
--- a/pilot/pkg/xds/ads.go
+++ b/pilot/pkg/xds/ads.go
@@ -68,15 +68,15 @@
 
 // Connection holds information about connected client.
 type Connection struct {
-	// PeerAddr is the address of the client, from network layer.
-	PeerAddr string
+	// peerAddr is the address of the client, from network layer.
+	peerAddr string
 
 	// Time of connection, for debugging
-	Connect time.Time
+	connectedAt time.Time
 
-	// ConID is the connection identifier, used as a key in the connection table.
+	// conID is the connection conID, used as a key in the connection table.
 	// Currently based on the node name and a counter.
-	ConID string
+	conID string
 
 	// proxy is the client to which this connection is established.
 	proxy *model.Proxy
@@ -124,8 +124,8 @@ func newConnection(peerAddr string, stream DiscoveryStream) *Connection {
 		stop:        make(chan struct{}),
 		reqChan:     make(chan *discovery.DiscoveryRequest, 1),
 		errorChan:   make(chan error, 1),
-		PeerAddr:    peerAddr,
-		Connect:     time.Now(),
+		peerAddr:    peerAddr,
+		connectedAt: time.Now(),
 		stream:      stream,
 	}
 }
@@ -147,11 +147,11 @@ func (s *DiscoveryServer) receive(con *Connection, identities []string) {
 		req, err := con.stream.Recv()
 		if err != nil {
 			if istiogrpc.IsExpectedGRPCError(err) {
-				log.Infof("ADS: %q %s terminated %v", con.PeerAddr, con.ConID, err)
+				log.Infof("ADS: %q %s terminated", con.peerAddr, con.conID)
 				return
 			}
 			con.errorChan <- err
-			log.Errorf("ADS: %q %s terminated with error: %v", con.PeerAddr, con.ConID, err)
+			log.Errorf("ADS: %q %s terminated with error: %v", con.peerAddr, con.conID, err)
 			totalXDSInternalErrors.Increment()
 			return
 		}
@@ -159,7 +159,7 @@ func (s *DiscoveryServer) receive(con *Connection, identities []string) {
 		if firstRequest {
 			// probe happens before envoy sends first xDS request
 			if req.TypeUrl == v3.HealthInfoType {
-				log.Warnf("ADS: %q %s send health check probe before normal xDS request", con.PeerAddr, con.ConID)
+				log.Warnf("ADS: %q %s send health check probe before normal xDS request", con.peerAddr, con.conID)
 				continue
 			}
 			firstRequest = false
@@ -172,13 +172,13 @@ func (s *DiscoveryServer) receive(con *Connection, identities []string) {
 				return
 			}
 			defer s.closeConnection(con)
-			log.Infof("ADS: new connection for node:%s", con.ConID)
+			log.Infof("ADS: new connection for node:%s", con.conID)
 		}
 
 		select {
 		case con.reqChan <- req:
 		case <-con.stream.Context().Done():
-			log.Infof("ADS: %q %s terminated with stream closed", con.PeerAddr, con.ConID)
+			log.Infof("ADS: %q %s terminated with stream closed", con.peerAddr, con.conID)
 			return
 		}
 	}
@@ -188,7 +188,8 @@ func (s *DiscoveryServer) receive(con *Connection, identities []string) {
 // handles 'push' requests and close - the code will eventually call the 'push' code, and it needs more mutex
 // protection. Original code avoided the mutexes by doing both 'push' and 'process requests' in same thread.
 func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *Connection) error {
-	if !s.shouldProcessRequest(con.proxy, req) {
+	if req.TypeUrl == v3.HealthInfoType {
+		s.handleWorkloadHealthcheck(con.proxy, req)
 		return nil
 	}
 
@@ -199,7 +200,7 @@ func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *C
 			&model.PushRequest{Full: true, Push: con.proxy.LastPushContext})
 	}
 	if s.StatusReporter != nil {
-		s.StatusReporter.RegisterEvent(con.ConID, req.TypeUrl, req.ResponseNonce)
+		s.StatusReporter.RegisterEvent(con.conID, req.TypeUrl, req.ResponseNonce)
 	}
 	shouldRespond, delta := s.shouldRespond(con, req)
 	if !shouldRespond {
@@ -335,7 +336,7 @@ func (s *DiscoveryServer) shouldRespond(con *Connection, request *discovery.Disc
 	// will be different from the version sent. But it is fragile to rely on that.
 	if request.ErrorDetail != nil {
 		errCode := codes.Code(request.ErrorDetail.Code)
-		log.Warnf("ADS:%s: ACK ERROR %s %s:%s", stype, con.ConID, errCode.String(), request.ErrorDetail.GetMessage())
+		log.Warnf("ADS:%s: ACK ERROR %s %s:%s", stype, con.conID, errCode.String(), request.ErrorDetail.GetMessage())
 		incrementXDSRejects(request.TypeUrl, con.proxy.ID, errCode.String())
 		if s.StatusGen != nil {
 			s.StatusGen.OnNack(con.proxy, request)
@@ -349,7 +350,7 @@ func (s *DiscoveryServer) shouldRespond(con *Connection, request *discovery.Disc
 	}
 
 	if shouldUnsubscribe(request) {
-		log.Debugf("ADS:%s: UNSUBSCRIBE %s %s %s", stype, con.ConID, request.VersionInfo, request.ResponseNonce)
+		log.Debugf("ADS:%s: UNSUBSCRIBE %s %s %s", stype, con.conID, request.VersionInfo, request.ResponseNonce)
 		con.proxy.Lock()
 		delete(con.proxy.WatchedResources, request.TypeUrl)
 		con.proxy.Unlock()
@@ -367,7 +368,7 @@ func (s *DiscoveryServer) shouldRespond(con *Connection, request *discovery.Disc
 	// because Istiod is restarted or Envoy disconnects and reconnects.
 	// We should always respond with the current resource names.
 	if request.ResponseNonce == "" || previousInfo == nil {
-		log.Debugf("ADS:%s: INIT/RECONNECT %s %s %s", stype, con.ConID, request.VersionInfo, request.ResponseNonce)
+		log.Debugf("ADS:%s: INIT/RECONNECT %s %s %s", stype, con.conID, request.VersionInfo, request.ResponseNonce)
 		con.proxy.Lock()
 		con.proxy.WatchedResources[request.TypeUrl] = &model.WatchedResource{TypeUrl: request.TypeUrl, ResourceNames: request.ResourceNames}
 		con.proxy.Unlock()
@@ -378,7 +379,7 @@ func (s *DiscoveryServer) shouldRespond(con *Connection, request *discovery.Disc
 	// A nonce becomes stale following a newer nonce being sent to Envoy.
 	if request.ResponseNonce != previousInfo.NonceSent {
 		log.Debugf("ADS:%s: REQ %s Expired nonce received %s, sent %s", stype,
-			con.ConID, request.ResponseNonce, previousInfo.NonceSent)
+			con.conID, request.ResponseNonce, previousInfo.NonceSent)
 		xdsExpiredNonce.With(typeTag.Value(v3.GetMetricType(request.TypeUrl))).Increment()
 		con.proxy.Lock()
 		con.proxy.WatchedResources[request.TypeUrl].NonceNacked = ""
@@ -402,11 +403,11 @@ func (s *DiscoveryServer) shouldRespond(con *Connection, request *discovery.Disc
 	// Envoy can send two DiscoveryRequests with same version and nonce
 	// when it detects a new resource. We should respond if they change.
 	if len(removed) == 0 && len(added) == 0 {
-		log.Debugf("ADS:%s: ACK %s %s %s", stype, con.ConID, request.VersionInfo, request.ResponseNonce)
+		log.Debugf("ADS:%s: ACK %s %s %s", stype, con.conID, request.VersionInfo, request.ResponseNonce)
 		return false, emptyResourceDelta
 	}
 	log.Debugf("ADS:%s: RESOURCE CHANGE added %v removed %v %s %s %s", stype,
-		added, removed, con.ConID, request.VersionInfo, request.ResponseNonce)
+		added, removed, con.conID, request.VersionInfo, request.ResponseNonce)
 
 	return true, model.ResourceDelta{
 		Subscribed:   added,
@@ -478,7 +479,7 @@ func (s *DiscoveryServer) initConnection(node *core.Node, con *Connection, ident
 	// way only new push contexts will be registered for this proxy.
 	proxy.LastPushContext = s.globalPushContext()
 	// First request so initialize connection id and start tracking it.
-	con.ConID = connectionID(proxy.ID)
+	con.conID = connectionID(proxy.ID)
 	con.node = node
 	con.proxy = proxy
 
@@ -492,7 +493,7 @@ func (s *DiscoveryServer) initConnection(node *core.Node, con *Connection, ident
 	// a better choice, it introduces a race condition; If we complete initialization of a new push
 	// context between initializeProxy and addCon, we would not get any pushes triggered for the new
 	// push context, leading the proxy to have a stale state until the next full push.
-	s.addCon(con.ConID, con)
+	s.addCon(con.conID, con)
 	// Register that initialization is complete. This triggers to calls that it is safe to access the
 	// proxy
 	defer close(con.initialized)
@@ -510,17 +511,17 @@ func (s *DiscoveryServer) initConnection(node *core.Node, con *Connection, ident
 }
 
 func (s *DiscoveryServer) closeConnection(con *Connection) {
-	if con.ConID == "" {
+	if con.conID == "" {
 		return
 	}
-	s.removeCon(con.ConID)
+	s.removeCon(con.conID)
 	if s.StatusGen != nil {
 		s.StatusGen.OnDisconnect(con)
 	}
 	if s.StatusReporter != nil {
-		s.StatusReporter.RegisterDisconnect(con.ConID, AllEventTypesList)
+		s.StatusReporter.RegisterDisconnect(con.conID, AllEventTypesList)
 	}
-	s.WorkloadEntryController.QueueUnregisterWorkload(con.proxy, con.Connect)
+	s.WorkloadEntryController.QueueUnregisterWorkload(con.proxy, con.connectedAt)
 }
 
 func connectionID(node string) string {
@@ -552,7 +553,7 @@ func (s *DiscoveryServer) initializeProxy(node *core.Node, con *Connection) erro
 	proxy := con.proxy
 	// this should be done before we look for service instances, but after we load metadata
 	// TODO fix check in kubecontroller treat echo VMs like there isn't a pod
-	if err := s.WorkloadEntryController.RegisterWorkload(proxy, con.Connect); err != nil {
+	if err := s.WorkloadEntryController.RegisterWorkload(proxy, con.connectedAt); err != nil {
 		return err
 	}
 	s.computeProxyState(proxy, nil)
@@ -652,11 +653,8 @@ func (s *DiscoveryServer) computeProxyState(proxy *model.Proxy, request *model.P
 	}
 }
 
-// shouldProcessRequest returns whether or not to continue with the request.
-func (s *DiscoveryServer) shouldProcessRequest(proxy *model.Proxy, req *discovery.DiscoveryRequest) bool {
-	if req.TypeUrl != v3.HealthInfoType {
-		return true
-	}
+// handleWorkloadHealthcheck processes HealthInformation type Url.
+func (s *DiscoveryServer) handleWorkloadHealthcheck(proxy *model.Proxy, req *discovery.DiscoveryRequest) {
 	if features.WorkloadEntryHealthChecks {
 		event := workloadentry.HealthEvent{}
 		event.Healthy = req.ErrorDetail == nil
@@ -665,7 +663,6 @@ func (s *DiscoveryServer) shouldProcessRequest(proxy *model.Proxy, req *discover
 		}
 		s.WorkloadEntryController.QueueWorkloadEntryHealth(proxy, event)
 	}
-	return false
 }
 
 // DeltaAggregatedResources is not implemented.
@@ -689,10 +686,10 @@ func (s *DiscoveryServer) pushConnection(con *Connection, pushEv *Event) error {
 	}
 
 	if !s.ProxyNeedsPush(con.proxy, pushRequest) {
-		log.Debugf("Skipping push to %v, no updates required", con.ConID)
+		log.Debugf("Skipping push to %v, no updates required", con.conID)
 		if pushRequest.Full {
 			// Only report for full versions, incremental pushes do not have a new version.
-			reportAllEvents(s.StatusReporter, con.ConID, pushRequest.Push.LedgerVersion, nil)
+			reportAllEvents(s.StatusReporter, con.conID, pushRequest.Push.LedgerVersion, nil)
 		}
 		return nil
 	}
@@ -707,7 +704,7 @@ func (s *DiscoveryServer) pushConnection(con *Connection, pushEv *Event) error {
 	}
 	if pushRequest.Full {
 		// Report all events for unwatched resources. Watched resources will be reported in pushXds or on ack.
-		reportAllEvents(s.StatusReporter, con.ConID, pushRequest.Push.LedgerVersion, ignoreEvents)
+		reportAllEvents(s.StatusReporter, con.conID, pushRequest.Push.LedgerVersion, ignoreEvents)
 	}
 
 	proxiesConvergeDelay.Record(time.Since(pushRequest.Start).Seconds())
@@ -867,7 +864,7 @@ func (conn *Connection) send(res *discovery.DiscoveryResponse) error {
 			conn.proxy.Unlock()
 		}
 	} else if status.Convert(err).Code() == codes.DeadlineExceeded {
-		log.Infof("Timeout writing %s", conn.ConID)
+		log.Infof("Timeout writing %s", conn.conID)
 		xdsResponseWriteTimeouts.Increment()
 	}
 	return err
diff --git a/pilot/pkg/xds/auth.go b/pilot/pkg/xds/auth.go
index 3fbe98e17d..09a8fdc0cb 100644
--- a/pilot/pkg/xds/auth.go
+++ b/pilot/pkg/xds/auth.go
@@ -79,7 +79,7 @@ func (s *DiscoveryServer) authorize(con *Connection, identities []string) error
 		// TODO: allow locking down, rejecting unauthenticated requests.
 		id, err := checkConnectionIdentity(con.proxy, identities)
 		if err != nil {
-			log.Warnf("Unauthorized XDS: %v with identity %v: %v", con.PeerAddr, identities, err)
+			log.Warnf("Unauthorized XDS: %v with identity %v: %v", con.peerAddr, identities, err)
 			return status.Newf(codes.PermissionDenied, "authorization failed: %v", err).Err()
 		}
 		con.proxy.VerifiedIdentity = id
diff --git a/pilot/pkg/xds/debug.go b/pilot/pkg/xds/debug.go
index 3a0e7fd414..858e0a5b3c 100644
--- a/pilot/pkg/xds/debug.go
+++ b/pilot/pkg/xds/debug.go
@@ -398,11 +398,11 @@ func (s *DiscoveryServer) distributedVersions(w http.ResponseWriter, req *http.R
 				// read nonces from our statusreporter to allow for skipped nonces, etc.
 				results = append(results, SyncedVersions{
 					ProxyID: con.proxy.ID,
-					ClusterVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.ConID, v3.ClusterType),
+					ClusterVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.conID, v3.ClusterType),
 						resourceID, knownVersions),
-					ListenerVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.ConID, v3.ListenerType),
+					ListenerVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.conID, v3.ListenerType),
 						resourceID, knownVersions),
-					RouteVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.ConID, v3.RouteType),
+					RouteVersion: s.getResourceVersion(s.StatusReporter.QueryLastNonce(con.conID, v3.RouteType),
 						resourceID, knownVersions),
 				})
 			}
@@ -523,9 +523,9 @@ func (s *DiscoveryServer) connectionsHandler(w http.ResponseWriter, req *http.Re
 
 	for _, c := range connections {
 		adsClient := AdsClient{
-			ConnectionID: c.ConID,
-			ConnectedAt:  c.Connect,
-			PeerAddress:  c.PeerAddr,
+			ConnectionID: c.conID,
+			ConnectedAt:  c.connectedAt,
+			PeerAddress:  c.peerAddr,
 		}
 		adsClients.Connected = append(adsClients.Connected, adsClient)
 	}
@@ -557,9 +557,9 @@ func (s *DiscoveryServer) adsz(w http.ResponseWriter, req *http.Request) {
 	adsClients.Total = len(connections)
 	for _, c := range connections {
 		adsClient := AdsClient{
-			ConnectionID: c.ConID,
-			ConnectedAt:  c.Connect,
-			PeerAddress:  c.PeerAddr,
+			ConnectionID: c.conID,
+			ConnectedAt:  c.connectedAt,
+			PeerAddress:  c.peerAddr,
 			Metadata:     c.proxy.Metadata,
 			Watches:      map[string][]string{},
 		}
@@ -915,7 +915,7 @@ func (s *DiscoveryServer) forceDisconnect(w http.ResponseWriter, req *http.Reque
 
 func (s *DiscoveryServer) getProxyConnection(proxyID string) *Connection {
 	for _, con := range s.Clients() {
-		if strings.Contains(con.ConID, proxyID) {
+		if strings.Contains(con.conID, proxyID) {
 			return con
 		}
 	}
diff --git a/pilot/pkg/xds/delta.go b/pilot/pkg/xds/delta.go
index 08a59af2e6..eb21e86262 100644
--- a/pilot/pkg/xds/delta.go
+++ b/pilot/pkg/xds/delta.go
@@ -139,10 +139,10 @@ func (s *DiscoveryServer) pushConnectionDelta(con *Connection, pushEv *Event) er
 	}
 
 	if !s.ProxyNeedsPush(con.proxy, pushRequest) {
-		deltaLog.Debugf("Skipping push to %v, no updates required", con.ConID)
+		deltaLog.Debugf("Skipping push to %v, no updates required", con.conID)
 		if pushRequest.Full {
 			// Only report for full versions, incremental pushes do not have a new version
-			reportAllEvents(s.StatusReporter, con.ConID, pushRequest.Push.LedgerVersion, nil)
+			reportAllEvents(s.StatusReporter, con.conID, pushRequest.Push.LedgerVersion, nil)
 		}
 		return nil
 	}
@@ -157,7 +157,7 @@ func (s *DiscoveryServer) pushConnectionDelta(con *Connection, pushEv *Event) er
 	}
 	if pushRequest.Full {
 		// Report all events for unwatched resources. Watched resources will be reported in pushXds or on ack.
-		reportAllEvents(s.StatusReporter, con.ConID, pushRequest.Push.LedgerVersion, ignoreEvents)
+		reportAllEvents(s.StatusReporter, con.conID, pushRequest.Push.LedgerVersion, ignoreEvents)
 	}
 
 	proxiesConvergeDelay.Record(time.Since(pushRequest.Start).Seconds())
@@ -180,11 +180,11 @@ func (s *DiscoveryServer) receiveDelta(con *Connection, identities []string) {
 		req, err := con.deltaStream.Recv()
 		if err != nil {
 			if istiogrpc.IsExpectedGRPCError(err) {
-				deltaLog.Infof("ADS: %q %s terminated %v", con.PeerAddr, con.ConID, err)
+				deltaLog.Infof("ADS: %q %s terminated", con.peerAddr, con.conID)
 				return
 			}
 			con.errorChan <- err
-			deltaLog.Errorf("ADS: %q %s terminated with error: %v", con.PeerAddr, con.ConID, err)
+			deltaLog.Errorf("ADS: %q %s terminated with error: %v", con.peerAddr, con.conID, err)
 			totalXDSInternalErrors.Increment()
 			return
 		}
@@ -200,13 +200,13 @@ func (s *DiscoveryServer) receiveDelta(con *Connection, identities []string) {
 				return
 			}
 			defer s.closeConnection(con)
-			deltaLog.Infof("ADS: new delta connection for node:%s", con.ConID)
+			deltaLog.Infof("ADS: new delta connection for node:%s", con.conID)
 		}
 
 		select {
 		case con.deltaReqChan <- req:
 		case <-con.deltaStream.Context().Done():
-			deltaLog.Infof("ADS: %q %s terminated with stream closed", con.PeerAddr, con.ConID)
+			deltaLog.Infof("ADS: %q %s terminated with stream closed", con.peerAddr, con.conID)
 			return
 		}
 	}
@@ -238,7 +238,7 @@ func (conn *Connection) sendDelta(res *discovery.DeltaDiscoveryResponse) error {
 			conn.proxy.Unlock()
 		}
 	} else {
-		deltaLog.Infof("Timeout writing %s", conn.ConID)
+		deltaLog.Infof("Timeout writing %s", conn.conID)
 		xdsResponseWriteTimeouts.Increment()
 	}
 	return err
@@ -248,7 +248,8 @@ func (conn *Connection) sendDelta(res *discovery.DeltaDiscoveryResponse) error {
 // handles 'push' requests and close - the code will eventually call the 'push' code, and it needs more mutex
 // protection. Original code avoided the mutexes by doing both 'push' and 'process requests' in same thread.
 func (s *DiscoveryServer) processDeltaRequest(req *discovery.DeltaDiscoveryRequest, con *Connection) error {
-	if !s.shouldProcessRequest(con.proxy, deltaToSotwRequest(req)) {
+	if req.TypeUrl == v3.HealthInfoType {
+		s.handleWorkloadHealthcheck(con.proxy, deltaToSotwRequest(req))
 		return nil
 	}
 	if strings.HasPrefix(req.TypeUrl, v3.DebugType) {
@@ -257,7 +258,7 @@ func (s *DiscoveryServer) processDeltaRequest(req *discovery.DeltaDiscoveryReque
 			&model.PushRequest{Full: true, Push: con.proxy.LastPushContext})
 	}
 	if s.StatusReporter != nil {
-		s.StatusReporter.RegisterEvent(con.ConID, req.TypeUrl, req.ResponseNonce)
+		s.StatusReporter.RegisterEvent(con.conID, req.TypeUrl, req.ResponseNonce)
 	}
 	shouldRespond := s.shouldRespondDelta(con, req)
 	if !shouldRespond {
@@ -297,7 +298,7 @@ func (s *DiscoveryServer) shouldRespondDelta(con *Connection, request *discovery
 	// will be different from the version sent. But it is fragile to rely on that.
 	if request.ErrorDetail != nil {
 		errCode := codes.Code(request.ErrorDetail.Code)
-		deltaLog.Warnf("ADS:%s: ACK ERROR %s %s:%s", stype, con.ConID, errCode.String(), request.ErrorDetail.GetMessage())
+		deltaLog.Warnf("ADS:%s: ACK ERROR %s %s:%s", stype, con.conID, errCode.String(), request.ErrorDetail.GetMessage())
 		incrementXDSRejects(request.TypeUrl, con.proxy.ID, errCode.String())
 		if s.StatusGen != nil {
 			s.StatusGen.OnNack(con.proxy, deltaToSotwRequest(request))
@@ -322,7 +323,7 @@ func (s *DiscoveryServer) shouldRespondDelta(con *Connection, request *discovery
 	// We should always respond with the current resource names.
 	if previousInfo == nil {
 		// TODO: can we distinguish init and reconnect? Do we care?
-		deltaLog.Debugf("ADS:%s: INIT/RECONNECT %s %s", stype, con.ConID, request.ResponseNonce)
+		deltaLog.Debugf("ADS:%s: INIT/RECONNECT %s %s", stype, con.conID, request.ResponseNonce)
 		con.proxy.Lock()
 		con.proxy.WatchedResources[request.TypeUrl] = &model.WatchedResource{
 			TypeUrl:       request.TypeUrl,
@@ -337,7 +338,7 @@ func (s *DiscoveryServer) shouldRespondDelta(con *Connection, request *discovery
 	// TODO: due to concurrent unsubscribe, this probably doesn't make sense. Do we need any logic here?
 	if request.ResponseNonce != "" && request.ResponseNonce != previousInfo.NonceSent {
 		deltaLog.Debugf("ADS:%s: REQ %s Expired nonce received %s, sent %s", stype,
-			con.ConID, request.ResponseNonce, previousInfo.NonceSent)
+			con.conID, request.ResponseNonce, previousInfo.NonceSent)
 		xdsExpiredNonce.With(typeTag.Value(v3.GetMetricType(request.TypeUrl))).Increment()
 		con.proxy.Lock()
 		con.proxy.WatchedResources[request.TypeUrl].NonceNacked = ""
@@ -370,18 +371,17 @@ func (s *DiscoveryServer) shouldRespondDelta(con *Connection, request *discovery
 	// Envoy can send two DiscoveryRequests with same version and nonce
 	// when it detects a new resource. We should respond if they change.
 	if oldAck {
-		deltaLog.Debugf("ADS:%s: ACK  %s %s", stype, con.ConID, request.ResponseNonce)
+		deltaLog.Debugf("ADS:%s: ACK  %s %s", stype, con.conID, request.ResponseNonce)
 		return false
 	}
 	deltaLog.Debugf("ADS:%s: RESOURCE CHANGE previous resources: %v, new resources: %v %s %s", stype,
-		previousResources, deltaResources, con.ConID, request.ResponseNonce)
+		previousResources, deltaResources, con.conID, request.ResponseNonce)
 
 	return true
 }
 
-// Push an XDS resource for the given connection. Configuration will be generated
-// based on the passed in generator. Based on the updates field, generators may
-// choose to send partial or even no response if there are no changes.
+// Push an Delta XDS resource for the given connection. Configuration will be generated
+// based on the passed in generator.
 func (s *DiscoveryServer) pushDeltaXds(con *Connection,
 	w *model.WatchedResource, req *model.PushRequest) error {
 	if w == nil {
@@ -426,7 +426,7 @@ func (s *DiscoveryServer) pushDeltaXds(con *Connection,
 	if err != nil || (res == nil && deletedRes == nil) {
 		// If we have nothing to send, report that we got an ACK for this version.
 		if s.StatusReporter != nil {
-			s.StatusReporter.RegisterEvent(con.ConID, w.TypeUrl, req.Push.LedgerVersion)
+			s.StatusReporter.RegisterEvent(con.conID, w.TypeUrl, req.Push.LedgerVersion)
 		}
 		return err
 	}
@@ -449,7 +449,7 @@ func (s *DiscoveryServer) pushDeltaXds(con *Connection,
 		resp.RemovedResources = subscribed.SortedList()
 	}
 	if len(resp.RemovedResources) > 0 {
-		deltaLog.Debugf("ADS:%v %s REMOVE %v", v3.GetShortType(w.TypeUrl), con.ConID, resp.RemovedResources)
+		deltaLog.Debugf("ADS:%v %s REMOVE %v", v3.GetShortType(w.TypeUrl), con.conID, resp.RemovedResources)
 	}
 	// normally wildcard xds `subscribe` is always nil, just in case there are some extended type not handled correctly.
 	if req.Delta.Subscribed == nil && isWildcardTypeURL(w.TypeUrl) {
@@ -506,8 +506,8 @@ func newDeltaConnection(peerAddr string, stream DeltaDiscoveryStream) *Connectio
 		pushChannel:  make(chan *Event),
 		initialized:  make(chan struct{}),
 		stop:         make(chan struct{}),
-		PeerAddr:     peerAddr,
-		Connect:      time.Now(),
+		peerAddr:     peerAddr,
+		connectedAt:  time.Now(),
 		deltaStream:  stream,
 		deltaReqChan: make(chan *discovery.DeltaDiscoveryRequest, 1),
 		errorChan:    make(chan error, 1),
diff --git a/pilot/pkg/xds/discovery.go b/pilot/pkg/xds/discovery.go
index 749d935efb..af3e7ec4c3 100644
--- a/pilot/pkg/xds/discovery.go
+++ b/pilot/pkg/xds/discovery.go
@@ -549,7 +549,7 @@ func doSendPushes(stopCh <-chan struct{}, semaphore chan struct{}, queue *PushQu
 					return
 				case <-closed: // grpc stream was closed
 					doneFunc()
-					log.Infof("Client closed connection %v", client.ConID)
+					log.Infof("Client closed connection %v", client.conID)
 				}
 			}()
 		}
@@ -666,7 +666,7 @@ func (s *DiscoveryServer) SendResponse(connections []*Connection, res *discovery
 		go func() {
 			err := con.stream.Send(res)
 			if err != nil {
-				log.Errorf("Failed to send internal event %s: %v", con.ConID, err)
+				log.Errorf("Failed to send internal event %s: %v", con.conID, err)
 			}
 		}()
 	}
diff --git a/pilot/pkg/xds/discovery_test.go b/pilot/pkg/xds/discovery_test.go
index a3cac7e1c3..c5bac2504a 100644
--- a/pilot/pkg/xds/discovery_test.go
+++ b/pilot/pkg/xds/discovery_test.go
@@ -36,7 +36,7 @@ func createProxies(n int) []*Connection {
 	proxies := make([]*Connection, 0, n)
 	for p := 0; p < n; p++ {
 		proxies = append(proxies, &Connection{
-			ConID:       fmt.Sprintf("proxy-%v", p),
+			conID:       fmt.Sprintf("proxy-%v", p),
 			pushChannel: make(chan *Event),
 			stream:      &fakeStream{},
 		})
@@ -80,7 +80,7 @@ func TestSendPushesManyPushes(t *testing.T) {
 				case p := <-proxy.pushChannel:
 					p.done()
 					pushesMu.Lock()
-					pushes[proxy.ConID]++
+					pushes[proxy.conID]++
 					pushesMu.Unlock()
 				case <-stopCh:
 					return
@@ -133,7 +133,7 @@ func TestSendPushesSinglePush(t *testing.T) {
 				case p := <-proxy.pushChannel:
 					p.done()
 					pushesMu.Lock()
-					pushes[proxy.ConID]++
+					pushes[proxy.conID]++
 					pushesMu.Unlock()
 					wg.Done()
 				case <-stopCh:
diff --git a/pilot/pkg/xds/pushqueue_test.go b/pilot/pkg/xds/pushqueue_test.go
index 094a11acd9..22a355e63d 100644
--- a/pilot/pkg/xds/pushqueue_test.go
+++ b/pilot/pkg/xds/pushqueue_test.go
@@ -78,7 +78,7 @@ func ExpectDequeue(t *testing.T, p *PushQueue, expected *Connection) {
 func TestProxyQueue(t *testing.T) {
 	proxies := make([]*Connection, 0, 100)
 	for p := 0; p < 100; p++ {
-		proxies = append(proxies, &Connection{ConID: fmt.Sprintf("proxy-%d", p)})
+		proxies = append(proxies, &Connection{conID: fmt.Sprintf("proxy-%d", p)})
 	}
 
 	t.Run("simple add and remove", func(t *testing.T) {
@@ -244,7 +244,7 @@ func TestProxyQueue(t *testing.T) {
 		p := NewPushQueue()
 		defer p.ShutDown()
 
-		key := func(p *Connection, eds string) string { return fmt.Sprintf("%s~%s", p.ConID, eds) }
+		key := func(p *Connection, eds string) string { return fmt.Sprintf("%s~%s", p.conID, eds) }
 
 		// We will trigger many pushes for eds services to each proxy. In the end we will expect
 		// all of these to be dequeue, but order is not deterministic.
@@ -300,7 +300,7 @@ func TestProxyQueue(t *testing.T) {
 		t.Parallel()
 		p := NewPushQueue()
 		defer p.ShutDown()
-		con := &Connection{ConID: "proxy-test"}
+		con := &Connection{conID: "proxy-test"}
 
 		// We will trigger many pushes for eds services to the proxy. In the end we will expect
 		// all of these to be dequeue, but order is deterministic.
diff --git a/pilot/pkg/xds/xdsgen.go b/pilot/pkg/xds/xdsgen.go
index 9ad92b0fb4..f0952d2bb5 100644
--- a/pilot/pkg/xds/xdsgen.go
+++ b/pilot/pkg/xds/xdsgen.go
@@ -117,7 +117,7 @@ func (s *DiscoveryServer) pushXds(con *Connection, w *model.WatchedResource, req
 	if err != nil || res == nil {
 		// If we have nothing to send, report that we got an ACK for this version.
 		if s.StatusReporter != nil {
-			s.StatusReporter.RegisterEvent(con.ConID, w.TypeUrl, req.Push.LedgerVersion)
+			s.StatusReporter.RegisterEvent(con.conID, w.TypeUrl, req.Push.LedgerVersion)
 		}
 		return err
 	}
-- 
2.35.3

