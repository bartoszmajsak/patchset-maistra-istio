From e5d7540bed038ae0fcdf2818b01a9f7acfaa6e1b Mon Sep 17 00:00:00 2001
From: Iris <irisdingbj@gmail.com>
Date: Sat, 4 Dec 2021 02:57:19 +0800
Subject: support root cert specified in mesh config (#35895)

* support root cert in meshconfig

* allow no root cert in returned cert-chain

* address review comments
---
 pilot/pkg/bootstrap/certcontroller.go         | 29 +++++-
 pilot/pkg/bootstrap/istio_ca.go               | 12 ++-
 pilot/pkg/bootstrap/server.go                 | 26 ++++-
 pkg/config/constants/constants.go             |  2 +
 .../csrctrl/controllers/csr_controller.go     | 13 +--
 pkg/test/csrctrl/controllers/start_csrctrl.go | 31 ++++--
 pkg/test/csrctrl/signer/signer.go             | 16 +++-
 security/pkg/pki/ca/ca.go                     |  9 +-
 security/pkg/pki/ca/ca_test.go                |  3 +-
 security/pkg/pki/ca/mock/fakeca.go            | 11 ++-
 security/pkg/pki/ra/common.go                 |  5 +
 security/pkg/pki/ra/k8s_ra.go                 | 95 +++++++++++++++++--
 security/pkg/pki/ra/k8s_ra_test.go            | 67 +++++++++++--
 security/pkg/pki/util/verify_cert.go          |  2 +-
 security/pkg/server/ca/server.go              | 34 +++----
 .../security/external_ca/main_test.go         | 78 +++++++++------
 16 files changed, 336 insertions(+), 97 deletions(-)

diff --git a/pilot/pkg/bootstrap/certcontroller.go b/pilot/pkg/bootstrap/certcontroller.go
index 44db278ddb..8fba7a262f 100644
--- a/pilot/pkg/bootstrap/certcontroller.go
+++ b/pilot/pkg/bootstrap/certcontroller.go
@@ -110,7 +110,32 @@ func (s *Server) initDNSCerts(hostname, namespace string) error {
 
 	var certChain, keyPEM, caBundle []byte
 	var err error
-	if features.PilotCertProvider == constants.CertProviderKubernetes {
+	pilotCertProviderName := features.PilotCertProvider
+	if strings.HasPrefix(pilotCertProviderName, constants.CertProviderKubernetesSignerPrefix) && s.RA != nil {
+		signerName := strings.TrimPrefix(pilotCertProviderName, constants.CertProviderKubernetesSignerPrefix)
+		log.Infof("Generating K8S-signed cert for %v using signer %v", s.dnsNames, signerName)
+		certChain, keyPEM, _, err = chiron.GenKeyCertK8sCA(s.kubeClient,
+			strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, "", signerName, true, SelfSignedCACertTTL.Get())
+		if err != nil {
+			return fmt.Errorf("failed generating key and cert by kubernetes: %v", err)
+		}
+		caBundle, err = s.RA.GetRootCertFromMeshConfig(signerName)
+		if err != nil {
+			return err
+		}
+		// MeshConfig:Add callback for mesh config update
+		s.environment.AddMeshHandler(func() {
+			newCaBundle, _ := s.RA.GetRootCertFromMeshConfig(signerName)
+			if newCaBundle != nil && string(newCaBundle) != string(s.istiodCertBundleWatcher.GetKeyCertBundle().CABundle) {
+				newCertChain, newKeyPEM, _, err := chiron.GenKeyCertK8sCA(s.kubeClient,
+					strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, "", signerName, true, SelfSignedCACertTTL.Get())
+				if err != nil {
+					log.Fatalf("failed regenerating key and cert for istiod by kubernetes: %v", err)
+				}
+				s.istiodCertBundleWatcher.SetAndNotify(newKeyPEM, newCertChain, newCaBundle)
+			}
+		})
+	} else if pilotCertProviderName == constants.CertProviderKubernetes {
 		log.Infof("Generating K8S-signed cert for %v", s.dnsNames)
 		certChain, keyPEM, _, err = chiron.GenKeyCertK8sCA(s.kubeClient,
 			strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, defaultCACertPath, "", true, SelfSignedCACertTTL.Get())
@@ -121,7 +146,7 @@ func (s *Server) initDNSCerts(hostname, namespace string) error {
 		if err != nil {
 			return fmt.Errorf("failed reading %s: %v", defaultCACertPath, err)
 		}
-	} else if features.PilotCertProvider == constants.CertProviderIstiod {
+	} else if pilotCertProviderName == constants.CertProviderIstiod {
 		certChain, keyPEM, err = s.CA.GenKeyCert(s.dnsNames, SelfSignedCACertTTL.Get(), false)
 		if err != nil {
 			return fmt.Errorf("failed generating istiod key cert %v", err)
diff --git a/pilot/pkg/bootstrap/istio_ca.go b/pilot/pkg/bootstrap/istio_ca.go
index 488fcddf93..58fb3c37e5 100644
--- a/pilot/pkg/bootstrap/istio_ca.go
+++ b/pilot/pkg/bootstrap/istio_ca.go
@@ -489,7 +489,17 @@ func (s *Server) createIstioRA(client kubelib.Client,
 		TrustDomain:      opts.TrustDomain,
 		CertSignerDomain: opts.CertSignerDomain,
 	}
-	return ra.NewIstioRA(raOpts)
+	raServer, err := ra.NewIstioRA(raOpts)
+	if err != nil {
+		return nil, err
+	}
+	raServer.SetCACertificatesFromMeshConfig(s.environment.Mesh().CaCertificates)
+	s.environment.AddMeshHandler(func() {
+		meshConfig := s.environment.Mesh()
+		caCertificates := meshConfig.CaCertificates
+		s.RA.SetCACertificatesFromMeshConfig(caCertificates)
+	})
+	return raServer, err
 }
 
 // getJwtPath returns jwt path.
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index e30259764e..2459a71c44 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -989,6 +989,12 @@ func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
 		if err == nil {
 			err = s.initIstiodCertLoader()
 		}
+	} else if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
+		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
+		err = s.initDNSCerts(host, args.Namespace)
+		if err == nil {
+			err = s.initIstiodCertLoader()
+		}
 	}
 
 	return err
@@ -1009,7 +1015,13 @@ func (s *Server) createPeerCertVerifier(tlsOptions TLSOptions) (*spiffe.PeerCert
 		}
 	} else {
 		if s.RA != nil {
-			rootCertBytes = append(rootCertBytes, s.RA.GetCAKeyCertBundle().GetRootCertPem()...)
+			if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
+				signerName := strings.TrimPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix)
+				caBundle, _ := s.RA.GetRootCertFromMeshConfig(signerName)
+				rootCertBytes = append(rootCertBytes, caBundle...)
+			} else {
+				rootCertBytes = append(rootCertBytes, s.RA.GetCAKeyCertBundle().GetRootCertPem()...)
+			}
 		}
 		if s.CA != nil {
 			rootCertBytes = append(rootCertBytes, s.CA.GetCAKeyCertBundle().GetRootCertPem()...)
@@ -1247,7 +1259,17 @@ func (s *Server) initWorkloadTrustBundle(args *PilotArgs) error {
 // It return true only if istiod certs is signed by Kubernetes and
 // workload certs are signed by external CA
 func (s *Server) isDisableCa() bool {
-	return features.PilotCertProvider == constants.CertProviderKubernetes && s.RA != nil
+	if s.RA != nil {
+		// do not create CA server if PilotCertProvider is `kubernetes` and RA server exists
+		if features.PilotCertProvider == constants.CertProviderKubernetes {
+			return true
+		}
+		// do not create CA server if PilotCertProvider is `k8s.io/*` and RA server exists
+		if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
+			return true
+		}
+	}
+	return false
 }
 
 func (s *Server) initStatusManager(_ *PilotArgs) {
diff --git a/pkg/config/constants/constants.go b/pkg/config/constants/constants.go
index 0d0da3abb2..77b0956925 100644
--- a/pkg/config/constants/constants.go
+++ b/pkg/config/constants/constants.go
@@ -132,6 +132,8 @@
 	CertProviderIstiod = "istiod"
 	// CertProviderKubernetes uses the Kubernetes CSR API to generate a DNS certificate for the control plane
 	CertProviderKubernetes = "kubernetes"
+	// CertProviderKubernetesSignerPrefix uses the Kubernetes CSR API and the specified signer to generate a DNS certificate for the control plane
+	CertProviderKubernetesSignerPrefix = "k8s.io/"
 	// CertProviderCustom uses the custom root certificate mounted in a well known location for the control plane
 	CertProviderCustom = "custom"
 	// CertProviderNone does not create any certificates for the control plane. It is assumed that some external
diff --git a/pkg/test/csrctrl/controllers/csr_controller.go b/pkg/test/csrctrl/controllers/csr_controller.go
index 0ca762040d..f4b67b2aab 100644
--- a/pkg/test/csrctrl/controllers/csr_controller.go
+++ b/pkg/test/csrctrl/controllers/csr_controller.go
@@ -34,11 +34,12 @@
 // CertificateSigningRequestSigningReconciler reconciles a CertificateSigningRequest object
 type CertificateSigningRequestSigningReconciler struct {
 	client.Client
-	SignerRoot  string
-	CtrlCertTTL time.Duration
-	Scheme      *runtime.Scheme
-	SignerNames []string
-	Signers     map[string]*signer.Signer
+	SignerRoot     string
+	CtrlCertTTL    time.Duration
+	Scheme         *runtime.Scheme
+	SignerNames    []string
+	Signers        map[string]*signer.Signer
+	appendRootCert bool
 }
 
 // +kubebuilder:rbac:groups=certificates.k8s.io,resources=certificatesigningrequests,verbs=get;list;watch
@@ -85,7 +86,7 @@ func (r *CertificateSigningRequestSigningReconciler) Reconcile(_ context.Context
 				requestedLifeTime = duration
 			}
 		}
-		cert, err := signer.Sign(x509cr, csr.Spec.Usages, requestedLifeTime)
+		cert, err := signer.Sign(x509cr, csr.Spec.Usages, requestedLifeTime, r.appendRootCert)
 		if err != nil {
 			return ctrl.Result{}, fmt.Errorf("error auto signing csr: %v", err)
 		}
diff --git a/pkg/test/csrctrl/controllers/start_csrctrl.go b/pkg/test/csrctrl/controllers/start_csrctrl.go
index c3c06b4099..62c46b2dc0 100644
--- a/pkg/test/csrctrl/controllers/start_csrctrl.go
+++ b/pkg/test/csrctrl/controllers/start_csrctrl.go
@@ -46,7 +46,13 @@
 	_              = corev1.AddToScheme(scheme)
 )
 
-func RunCSRController(signerNames string, config *rest.Config, c <-chan struct{}) {
+type SignerRootCert struct {
+	Signer   string
+	Rootcert string
+}
+
+func RunCSRController(signerNames string, appendRootCert bool, config *rest.Config, c <-chan struct{},
+	certChan chan *SignerRootCert) {
 	// Config Istio log
 	if err := log.Configure(loggingOptions); err != nil {
 		log.Infof("Unable to configure Istio log error: %v", err)
@@ -71,15 +77,26 @@ func RunCSRController(signerNames string, config *rest.Config, c <-chan struct{}
 			os.Exit(-1)
 		}
 		signersMap[signerName] = signer
+		rootCert, rErr := os.ReadFile(signer.GetRootCerts())
+		if rErr != nil {
+			log.Infof("Unable to read root cert for signer [%s], error: %v", signerName, sErr)
+			os.Exit(-1)
+		}
+		rootCertsForSigner := &SignerRootCert{
+			Signer:   signerName,
+			Rootcert: string(rootCert),
+		}
+		certChan <- rootCertsForSigner
 	}
 
 	if err := (&CertificateSigningRequestSigningReconciler{
-		Client:      mgr.GetClient(),
-		SignerRoot:  signerRoot,
-		CtrlCertTTL: certificateDuration,
-		Scheme:      mgr.GetScheme(),
-		SignerNames: arrSingers,
-		Signers:     signersMap,
+		Client:         mgr.GetClient(),
+		SignerRoot:     signerRoot,
+		CtrlCertTTL:    certificateDuration,
+		Scheme:         mgr.GetScheme(),
+		SignerNames:    arrSingers,
+		Signers:        signersMap,
+		appendRootCert: appendRootCert,
 	}).SetupWithManager(mgr); err != nil {
 		log.Infof("Unable to create Controller fro controller CSRSigningReconciler, error: %v", err)
 		os.Exit(-1)
diff --git a/pkg/test/csrctrl/signer/signer.go b/pkg/test/csrctrl/signer/signer.go
index 1d2e692ad4..2bf21cfd00 100644
--- a/pkg/test/csrctrl/signer/signer.go
+++ b/pkg/test/csrctrl/signer/signer.go
@@ -46,7 +46,7 @@ func NewSigner(signerRoot, signerName string, certificateDuration time.Duration)
 	return ret, nil
 }
 
-func (s *Signer) Sign(x509cr *x509.CertificateRequest, usages []capi.KeyUsage, requestedLifetime time.Duration) ([]byte, error) {
+func (s *Signer) Sign(x509cr *x509.CertificateRequest, usages []capi.KeyUsage, requestedLifetime time.Duration, appendRootCert bool) ([]byte, error) {
 	currCA, err := s.caProvider.currentCA()
 	if err != nil {
 		return nil, err
@@ -74,10 +74,16 @@ func (s *Signer) Sign(x509cr *x509.CertificateRequest, usages []capi.KeyUsage, r
 	if err != nil {
 		return nil, fmt.Errorf("failed to append intermediate certificates (%v)", err)
 	}
-	rootCerts, err := util.AppendRootCerts(intermediateCerts, s.caProvider.caLoader.CertFile)
-	if err != nil {
-		return nil, fmt.Errorf("failed to append root certificates (%v)", err)
+	if appendRootCert {
+		rootCerts, err := util.AppendRootCerts(intermediateCerts, s.caProvider.caLoader.CertFile)
+		if err != nil {
+			return nil, fmt.Errorf("failed to append root certificates (%v)", err)
+		}
+		return rootCerts, nil
 	}
+	return intermediateCerts, nil
+}
 
-	return rootCerts, nil
+func (s *Signer) GetRootCerts() string {
+	return s.caProvider.caLoader.CertFile
 }
diff --git a/security/pkg/pki/ca/ca.go b/security/pkg/pki/ca/ca.go
index 95cbb8646f..6bac2d48d3 100644
--- a/security/pkg/pki/ca/ca.go
+++ b/security/pkg/pki/ca/ca.go
@@ -320,8 +320,12 @@ func (ca *IstioCA) Sign(csrPEM []byte, certOpts CertOpts) (
 
 // SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
 func (ca *IstioCA) SignWithCertChain(csrPEM []byte, certOpts CertOpts) (
-	[]byte, error) {
-	return ca.signWithCertChain(csrPEM, certOpts.SubjectIDs, certOpts.TTL, true, certOpts.ForCA)
+	[]string, error) {
+	cert, err := ca.signWithCertChain(csrPEM, certOpts.SubjectIDs, certOpts.TTL, true, certOpts.ForCA)
+	if err != nil {
+		return nil, err
+	}
+	return []string{string(cert)}, nil
 }
 
 // GetCAKeyCertBundle returns the KeyCertBundle for the CA.
@@ -420,6 +424,7 @@ func (ca *IstioCA) signWithCertChain(csrPEM []byte, subjectIDs []string, request
 	if err != nil {
 		return nil, err
 	}
+
 	chainPem := ca.GetCAKeyCertBundle().GetCertChainPem()
 	if len(chainPem) > 0 {
 		cert = append(cert, chainPem...)
diff --git a/security/pkg/pki/ca/ca_test.go b/security/pkg/pki/ca/ca_test.go
index b6772dd03f..c253c0343f 100644
--- a/security/pkg/pki/ca/ca_test.go
+++ b/security/pkg/pki/ca/ca_test.go
@@ -562,7 +562,8 @@ func TestSignWithCertChain(t *testing.T) {
 		TTL:        time.Hour,
 		ForCA:      false,
 	}
-	certPEM, signErr := ca.SignWithCertChain(csrPEM, caCertOpts)
+	certPEM, signErr := ca.signWithCertChain(csrPEM, caCertOpts.SubjectIDs, caCertOpts.TTL, true, caCertOpts.ForCA)
+
 	if signErr != nil {
 		t.Error(err)
 	}
diff --git a/security/pkg/pki/ca/mock/fakeca.go b/security/pkg/pki/ca/mock/fakeca.go
index a89b6a3706..9271684139 100644
--- a/security/pkg/pki/ca/mock/fakeca.go
+++ b/security/pkg/pki/ca/mock/fakeca.go
@@ -38,15 +38,20 @@ func (ca *FakeCA) Sign(csr []byte, certOpts ca.CertOpts) ([]byte, error) {
 }
 
 // SignWithCertChain returns the SignErr if SignErr is not nil, otherwise, it returns SignedCert and the cert chain.
-func (ca *FakeCA) SignWithCertChain(csr []byte, certOpts ca.CertOpts) ([]byte, error) {
+func (ca *FakeCA) SignWithCertChain(csr []byte, certOpts ca.CertOpts) ([]string, error) {
 	if ca.SignErr != nil {
 		return nil, ca.SignErr
 	}
 	cert := ca.SignedCert
+	respCertChain := []string{string(cert)}
 	if ca.KeyCertBundle != nil {
-		cert = append(cert, ca.KeyCertBundle.GetCertChainPem()...)
+		respCertChain = append(respCertChain, string(ca.KeyCertBundle.GetCertChainPem()))
 	}
-	return cert, nil
+	_, _, _, rootCertBytes := ca.GetCAKeyCertBundle().GetAll()
+	if len(rootCertBytes) != 0 {
+		respCertChain = append(respCertChain, string(rootCertBytes))
+	}
+	return respCertChain, nil
 }
 
 // GetCAKeyCertBundle returns KeyCertBundle if KeyCertBundle is not nil, otherwise, it returns an empty
diff --git a/security/pkg/pki/ra/common.go b/security/pkg/pki/ra/common.go
index e84336eb6c..4e1c7ae527 100644
--- a/security/pkg/pki/ra/common.go
+++ b/security/pkg/pki/ra/common.go
@@ -19,6 +19,7 @@
 
 	clientset "k8s.io/client-go/kubernetes"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	raerror "istio.io/istio/security/pkg/pki/error"
 	"istio.io/istio/security/pkg/pki/util"
 	caserver "istio.io/istio/security/pkg/server/ca"
@@ -27,6 +28,10 @@
 // RegistrationAuthority : Registration Authority interface.
 type RegistrationAuthority interface {
 	caserver.CertificateAuthority
+	// SetCACertificatesFromMeshConfig sets the CACertificates using the ones from mesh config
+	SetCACertificatesFromMeshConfig([]*meshconfig.MeshConfig_CertificateData)
+	// GetRootCertFromMeshConfig returns the root cert for the specific signer in mesh config
+	GetRootCertFromMeshConfig(signerName string) ([]byte, error)
 }
 
 // CaExternalType : Type of External CA integration
diff --git a/security/pkg/pki/ra/k8s_ra.go b/security/pkg/pki/ra/k8s_ra.go
index 7f3bd4a8bb..3939d0a24b 100644
--- a/security/pkg/pki/ra/k8s_ra.go
+++ b/security/pkg/pki/ra/k8s_ra.go
@@ -16,11 +16,14 @@
 
 import (
 	"fmt"
+	"strings"
+	"sync"
 	"time"
 
 	cert "k8s.io/api/certificates/v1"
 	clientset "k8s.io/client-go/kubernetes"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/security/pkg/k8s/chiron"
 	"istio.io/istio/security/pkg/pki/ca"
 	raerror "istio.io/istio/security/pkg/pki/error"
@@ -29,9 +32,13 @@
 
 // KubernetesRA integrated with an external CA using Kubernetes CSR API
 type KubernetesRA struct {
-	csrInterface  clientset.Interface
-	keyCertBundle *util.KeyCertBundle
-	raOpts        *IstioRAOptions
+	csrInterface                 clientset.Interface
+	keyCertBundle                *util.KeyCertBundle
+	raOpts                       *IstioRAOptions
+	caCertificatesFromMeshConfig map[string]string
+	certSignerDomain             string
+	// mutex protects the R/W to caCertificatesFromMeshConfig.
+	mutex sync.RWMutex
 }
 
 // NewKubernetesRA : Create a RA that interfaces with K8S CSR CA
@@ -41,16 +48,18 @@ func NewKubernetesRA(raOpts *IstioRAOptions) (*KubernetesRA, error) {
 		return nil, raerror.NewError(raerror.CAInitFail, fmt.Errorf("error processing Certificate Bundle for Kubernetes RA"))
 	}
 	istioRA := &KubernetesRA{
-		csrInterface:  raOpts.K8sClient,
-		raOpts:        raOpts,
-		keyCertBundle: keyCertBundle,
+		csrInterface:                 raOpts.K8sClient,
+		raOpts:                       raOpts,
+		keyCertBundle:                keyCertBundle,
+		certSignerDomain:             raOpts.CertSignerDomain,
+		caCertificatesFromMeshConfig: make(map[string]string),
 	}
 	return istioRA, nil
 }
 
 func (r *KubernetesRA) kubernetesSign(csrPEM []byte, caCertFile string, certSigner string,
 	requestedLifetime time.Duration) ([]byte, error) {
-	certSignerDomain := r.raOpts.CertSignerDomain
+	certSignerDomain := r.certSignerDomain
 	if certSignerDomain == "" && certSigner != "" {
 		return nil, raerror.NewError(raerror.CertGenError, fmt.Errorf("certSignerDomain is requiered for signer %s", certSigner))
 	}
@@ -85,7 +94,7 @@ func (r *KubernetesRA) Sign(csrPEM []byte, certOpts ca.CertOpts) ([]byte, error)
 }
 
 // SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
-func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([]byte, error) {
+func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([]string, error) {
 	cert, err := r.Sign(csrPEM, certOpts)
 	if err != nil {
 		return nil, err
@@ -94,10 +103,78 @@ func (r *KubernetesRA) SignWithCertChain(csrPEM []byte, certOpts ca.CertOpts) ([
 	if len(chainPem) > 0 {
 		cert = append(cert, chainPem...)
 	}
-	return cert, nil
+	respCertChain := []string{string(cert)}
+	var rootCert, rootCertFromMeshConfig, rootCertFromCertChain []byte
+	certSigner := r.certSignerDomain + "/" + certOpts.CertSigner
+	if len(r.GetCAKeyCertBundle().GetRootCertPem()) == 0 {
+		rootCertFromCertChain, err = util.FindRootCertFromCertificateChainBytes(cert)
+		if err != nil {
+			return nil, fmt.Errorf("failed to find root cert from signed cert-chain (%v)", err.Error())
+		}
+		rootCertFromMeshConfig, err = r.GetRootCertFromMeshConfig(certSigner)
+		if err != nil {
+			return nil, fmt.Errorf("failed to find root cert from mesh config (%v)", err.Error())
+		}
+		if rootCertFromCertChain != nil && rootCertFromMeshConfig != nil {
+			if string(rootCertFromCertChain) != string(rootCertFromMeshConfig) {
+				return nil, fmt.Errorf("root cert from signed cert-chain" +
+					" is conflicting with the one specified in mesh config")
+			}
+		}
+		if rootCertFromMeshConfig != nil {
+			rootCert = rootCertFromMeshConfig
+		}
+
+		if rootCertFromCertChain != nil {
+			rootCert = rootCertFromCertChain
+		}
+
+		if verifyErr := util.VerifyCertificate(nil, cert, rootCert, nil); verifyErr != nil {
+			return nil, fmt.Errorf("root cert from signed cert-chain is invalid %v ", verifyErr)
+		}
+		respCertChain = append(respCertChain, string(rootCert))
+	}
+	return respCertChain, nil
 }
 
 // GetCAKeyCertBundle returns the KeyCertBundle for the CA.
 func (r *KubernetesRA) GetCAKeyCertBundle() *util.KeyCertBundle {
 	return r.keyCertBundle
 }
+
+func (r *KubernetesRA) SetCACertificatesFromMeshConfig(caCertificates []*meshconfig.MeshConfig_CertificateData) {
+	r.mutex.Lock()
+	for _, pemCert := range caCertificates {
+		// TODO:  take care of spiffe bundle format as well
+		cert := pemCert.GetPem()
+		certSigners := pemCert.CertSigners
+		if len(certSigners) != 0 {
+			certSigner := strings.Join(certSigners, ",")
+			if cert != "" {
+				r.caCertificatesFromMeshConfig[certSigner] = cert
+			}
+		}
+	}
+	r.mutex.Unlock()
+}
+
+func (r *KubernetesRA) GetRootCertFromMeshConfig(signerName string) ([]byte, error) {
+	r.mutex.RLock()
+	defer r.mutex.RUnlock()
+	caCertificates := r.caCertificatesFromMeshConfig
+	if len(caCertificates) == 0 {
+		return nil, fmt.Errorf("no caCertificates defined in mesh config")
+	}
+	for signers, caCertificate := range caCertificates {
+		signerList := strings.Split(signers, ",")
+		if len(signerList) == 0 {
+			continue
+		}
+		for _, signer := range signerList {
+			if signer == signerName {
+				return []byte(caCertificate), nil
+			}
+		}
+	}
+	return nil, fmt.Errorf("failed to find root cert for signer: %v in mesh config", signerName)
+}
diff --git a/security/pkg/pki/ra/k8s_ra_test.go b/security/pkg/pki/ra/k8s_ra_test.go
index bed04df805..ddbf0948d2 100644
--- a/security/pkg/pki/ra/k8s_ra_test.go
+++ b/security/pkg/pki/ra/k8s_ra_test.go
@@ -15,6 +15,8 @@
 package ra
 
 import (
+	"os"
+	"path"
 	"testing"
 	"time"
 
@@ -24,7 +26,9 @@
 	"k8s.io/client-go/kubernetes/fake"
 	kt "k8s.io/client-go/testing"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/security/pkg/k8s/chiron"
 	"istio.io/istio/security/pkg/pki/ca"
 	pkiutil "istio.io/istio/security/pkg/pki/util"
@@ -79,25 +83,24 @@ func createFakeCsr(t *testing.T) []byte {
 	return csrPEM
 }
 
-func initFakeKubeClient(csrName string) *fake.Clientset {
+func initFakeKubeClient(csrName, certificate string) *fake.Clientset {
 	client := fake.NewSimpleClientset()
 	csr := &cert.CertificateSigningRequest{
 		ObjectMeta: metav1.ObjectMeta{
 			Name: csrName,
 		},
 		Status: cert.CertificateSigningRequestStatus{
-			Certificate: []byte(TestCertificatePEM),
+			Certificate: []byte(certificate),
 		},
 	}
 	client.PrependReactor("get", "certificatesigningrequests", defaultReactionFunc(csr))
 	return client
 }
 
-func createFakeK8sRA(client *fake.Clientset) (*KubernetesRA, error) {
+func createFakeK8sRA(client *fake.Clientset, caCertFile string) (*KubernetesRA, error) {
 	defaultCertTTL := 30 * time.Minute
 	maxCertTTL := time.Hour
 	caSigner := "kubernates.io/kube-apiserver-client"
-	caCertFile := "../testdata/example-ca-cert.pem"
 	raOpts := &IstioRAOptions{
 		ExternalCAType: ExtCAK8s,
 		DefaultCertTTL: defaultCertTTL,
@@ -110,12 +113,60 @@ func createFakeK8sRA(client *fake.Clientset) (*KubernetesRA, error) {
 	return NewKubernetesRA(raOpts)
 }
 
+func TestK8sSignWithMeshConfig(t *testing.T) {
+	csrPEM := createFakeCsr(t)
+	csrName := chiron.GenCsrName()
+	rootCertPem, err := os.ReadFile(path.Join(env.IstioSrc, "samples/certs", "root-cert.pem"))
+	if err != nil {
+		t.Errorf("Failed to read sample root-cert.pem")
+	}
+	certChainPem, err := os.ReadFile(path.Join(env.IstioSrc, "samples/certs", "cert-chain.pem"))
+	if err != nil {
+		t.Errorf("Failed to read sample cert-chain.pem")
+	}
+	client := initFakeKubeClient(csrName, string(certChainPem))
+	ra, err := createFakeK8sRA(client, "")
+	if err != nil {
+		t.Errorf("Failed to create Fake K8s RA")
+	}
+	signer := "kubernates.io/kube-apiserver-client"
+	ra.certSignerDomain = "kubernates.io"
+	caCertificates := []*meshconfig.MeshConfig_CertificateData{
+		{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(rootCertPem)}, CertSigners: []string{signer}},
+	}
+	ra.SetCACertificatesFromMeshConfig(caCertificates)
+	subjectID := spiffe.Identity{TrustDomain: "cluster.local", Namespace: "default", ServiceAccount: "bookinfo-productpage"}.String()
+	certOptions := ca.CertOpts{
+		SubjectIDs: []string{subjectID},
+		TTL:        60 * time.Second, ForCA: false,
+		CertSigner: "kube-apiserver-client",
+	}
+	// expect to sign back successfully
+	_, err = ra.SignWithCertChain(csrPEM, certOptions)
+	if err != nil {
+		t.Errorf("K8s CA Signing CSR With Root Cert In Meshconfig failed")
+	}
+	testCACert, err := os.ReadFile(TestCACertFile)
+	if err != nil {
+		t.Errorf("Failed to read test CA Cert file")
+	}
+	updatedCACertificates := []*meshconfig.MeshConfig_CertificateData{
+		{CertificateData: &meshconfig.MeshConfig_CertificateData_Pem{Pem: string(testCACert)}, CertSigners: []string{signer}},
+	}
+	ra.SetCACertificatesFromMeshConfig(updatedCACertificates)
+	// expect failure in sign since root cert in mesh config does not match
+	_, err = ra.SignWithCertChain(csrPEM, certOptions)
+	if err == nil {
+		t.Errorf("K8s CA Signing CSR With Root Cert In Meshconfig failed")
+	}
+}
+
 // TestK8sSign : Verify that ra.k8sSign returns a valid certPEM while using k8s Fake Client to create a CSR
 func TestK8sSign(t *testing.T) {
 	csrPEM := createFakeCsr(t)
 	csrName := chiron.GenCsrName()
-	client := initFakeKubeClient(csrName)
-	r, err := createFakeK8sRA(client)
+	client := initFakeKubeClient(csrName, TestCertificatePEM)
+	r, err := createFakeK8sRA(client, TestCACertFile)
 	if err != nil {
 		t.Errorf("Validation CSR failed")
 	}
@@ -132,8 +183,8 @@ func TestK8sSign(t *testing.T) {
 func TestValidateCSR(t *testing.T) {
 	csrPEM := createFakeCsr(t)
 	csrName := chiron.GenCsrName()
-	client := initFakeKubeClient(csrName)
-	_, err := createFakeK8sRA(client)
+	client := initFakeKubeClient(csrName, TestCertificatePEM)
+	_, err := createFakeK8sRA(client, TestCACertFile)
 	if err != nil {
 		t.Errorf("Validation CSR failed")
 	}
diff --git a/security/pkg/pki/util/verify_cert.go b/security/pkg/pki/util/verify_cert.go
index 902eb6522f..bf8246fbb0 100644
--- a/security/pkg/pki/util/verify_cert.go
+++ b/security/pkg/pki/util/verify_cert.go
@@ -185,7 +185,7 @@ func FindRootCertFromCertificateChainBytes(certBytes []byte) ([]byte, error) {
 	}
 	rootBlock, _ := pem.Decode(cert)
 	if rootBlock == nil {
-		return nil, fmt.Errorf("error decoding root certificate")
+		return nil, nil
 	}
 	rootCert, err := x509.ParseCertificate(rootBlock.Bytes)
 	if err != nil {
diff --git a/security/pkg/server/ca/server.go b/security/pkg/server/ca/server.go
index a2dbfda4fa..5a5ce66cbe 100644
--- a/security/pkg/server/ca/server.go
+++ b/security/pkg/server/ca/server.go
@@ -39,8 +39,8 @@ type CertificateAuthority interface {
 	// Sign generates a certificate for a workload or CA, from the given CSR and cert opts.
 	Sign(csrPEM []byte, opts ca.CertOpts) ([]byte, error)
 	// SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
-	SignWithCertChain(csrPEM []byte, opts ca.CertOpts) ([]byte, error)
-	// GetCAKeyCertBundle returns the KeyCertBundle used by CA.
+	SignWithCertChain(csrPEM []byte, opts ca.CertOpts) ([]string, error)
+	// SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
 	GetCAKeyCertBundle() *util.KeyCertBundle
 }
 
@@ -76,7 +76,6 @@ func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertifi
 		s.monitoring.AuthnError.Increment()
 		return nil, status.Error(codes.Unauthenticated, "request authenticate failure")
 	}
-
 	// TODO: Call authorizer.
 	crMetadata := request.Metadata.GetFields()
 	certSigner := crMetadata[security.CertSigner].GetStringValue()
@@ -88,29 +87,24 @@ func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertifi
 		ForCA:      false,
 		CertSigner: certSigner,
 	}
-	cert, signErr := s.ca.Sign([]byte(request.Csr), certOpts)
+	var signErr error
+	var cert []byte
+	var respCertChain []string
+	if certSigner == "" {
+		cert, signErr = s.ca.Sign([]byte(request.Csr), certOpts)
+	} else {
+		respCertChain, signErr = s.ca.SignWithCertChain([]byte(request.Csr), certOpts)
+	}
 	if signErr != nil {
 		serverCaLog.Errorf("CSR signing error (%v)", signErr.Error())
 		s.monitoring.GetCertSignError(signErr.(*caerror.Error).ErrorType()).Increment()
 		return nil, status.Errorf(signErr.(*caerror.Error).HTTPErrorCode(), "CSR signing error (%v)", signErr.(*caerror.Error))
 	}
-	respCertChain := []string{string(cert)}
-	if len(certChainBytes) != 0 {
-		respCertChain = append(respCertChain, string(certChainBytes))
-	}
-	if len(rootCertBytes) == 0 {
-		rootCert, err := util.FindRootCertFromCertificateChainBytes(cert)
-		if err != nil {
-			serverCaLog.Errorf("failed to find root cert from signed cert-chain (%v)", err.Error())
-			s.monitoring.GetCertSignError(err.(*caerror.Error).ErrorType()).Increment()
-			return nil, status.Errorf(err.(*caerror.Error).HTTPErrorCode(), "failed to find root cert from signed cert-chain (%v)", err.(*caerror.Error))
-		}
-		if verifyErr := util.VerifyCertificate(nil, cert, rootCert, nil); verifyErr != nil {
-			serverCaLog.Errorf("root cert from signed cert-chain is invalid (%v)", err.Error())
-			s.monitoring.GetCertSignError(err.(*caerror.Error).ErrorType()).Increment()
-			return nil, status.Errorf(err.(*caerror.Error).HTTPErrorCode(), "root cert from signed cert-chain is invalid (%v)", err.(*caerror.Error))
+	if certSigner == "" {
+		respCertChain = []string{string(cert)}
+		if len(certChainBytes) != 0 {
+			respCertChain = append(respCertChain, string(certChainBytes))
 		}
-		rootCertBytes = rootCert
 	}
 	respCertChain = append(respCertChain, string(rootCertBytes))
 	response := &pb.IstioCertificateResponse{
diff --git a/tests/integration/security/external_ca/main_test.go b/tests/integration/security/external_ca/main_test.go
index 17262c03e6..40281b03dd 100644
--- a/tests/integration/security/external_ca/main_test.go
+++ b/tests/integration/security/external_ca/main_test.go
@@ -28,6 +28,7 @@
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
+	"istio.io/istio/pkg/test/util/tmpl"
 	"istio.io/istio/tests/integration/security/util"
 )
 
@@ -91,41 +92,58 @@ func TestMain(m *testing.M) {
 }
 
 func setupConfig(ctx resource.Context, cfg *istio.Config) {
-	go csrctrl.RunCSRController("clusterissuers.istio.io/signer1", ctx.Clusters()[0].RESTConfig(), stopChan)
+	certsChan := make(chan *csrctrl.SignerRootCert, 2)
+	go csrctrl.RunCSRController("clusterissuers.istio.io/signer1,clusterissuers.istio.io/signer2", false,
+		ctx.Clusters()[0].RESTConfig(), stopChan, certsChan)
+	cert1 := <-certsChan
+	cert2 := <-certsChan
+
 	if cfg == nil {
 		return
 	}
-	cfg.ControlPlaneValues = `
-meshConfig:
-  defaultConfig:
-    proxyMetadata:
-      ISTIO_META_CERT_SIGNER: signer1
-components:
-  pilot:
-    k8s:
-      env:
-      - name: CERT_SIGNER_DOMAIN
-        value: clusterissuers.istio.io
-      - name: EXTERNAL_CA
-        value: ISTIOD_RA_KUBERNETES_API
-      overlays:
-        # Amend ClusterRole to add permission for istiod to approve certificate signing by custom signer
-        - kind: ClusterRole
-          name: istiod-clusterrole-istio-system
-          patches:
-            - path: rules[-1]
-              value: |
-                apiGroups:
-                - certificates.k8s.io
-                resourceNames:
-                - clusterissuers.istio.io/*
-                resources:
-                - signers
-                verbs:
-                - approve
+	cfgYaml := tmpl.MustEvaluate(`
 values:
   meshConfig:
+    defaultConfig:
+      proxyMetadata:
+        PROXY_CONFIG_XDS_AGENT: "true"
+        ISTIO_META_CERT_SIGNER: signer1
     trustDomainAliases: [some-other, trust-domain-foo]
-`
+    caCertificates:
+    - pem: |
+{{.rootcert1 | indent 8}}
+      certSigners:
+      - {{.signer1}}
+    - pem: |
+{{.rootcert2 | indent 8}}
+      certSigners:
+      - {{.signer2}}
+  components:
+    pilot:
+      k8s:
+        env:
+        - name: CERT_SIGNER_DOMAIN
+          value: clusterissuers.istio.io
+        - name: EXTERNAL_CA
+          value: ISTIOD_RA_KUBERNETES_API
+        - name: PILOT_CERT_PROVIDER
+          value: k8s.io/clusterissuers.istio.io/signer2
+        overlays:
+          # Amend ClusterRole to add permission for istiod to approve certificate signing by custom signer
+          - kind: ClusterRole
+            name: istiod-clusterrole-istio-system
+            patches:
+              - path: rules[-1]
+                value: |
+                  apiGroups:
+                  - certificates.k8s.io
+                  resourceNames:
+                  - clusterissuers.istio.io/*
+                  resources:
+                  - signers
+                  verbs:
+                  - approve
+`, map[string]string{"rootcert1": cert1.Rootcert, "signer1": cert1.Signer, "rootcert2": cert2.Rootcert, "signer2": cert2.Signer})
+	cfg.ControlPlaneValues = cfgYaml
 	cfg.DeployEastWestGW = false
 }
-- 
2.35.3

