From 2b3b84671b8f91f4512493212bea9640685fdd82 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Sat, 28 May 2022 19:04:51 +0800
Subject: Cleanup bootstrap ca/certs init (#39164)

* istio ca init clean up

* initIstiodCerts cleanup

* rm unused params

* Fix ci
---
 pilot/pkg/bootstrap/certcontroller.go |  13 +--
 pilot/pkg/bootstrap/istio_ca.go       |  37 ++++-----
 pilot/pkg/bootstrap/istio_ca_test.go  |  10 +--
 pilot/pkg/bootstrap/server.go         | 114 ++++++++++++--------------
 security/pkg/k8s/chiron/controller.go |   4 +-
 security/pkg/k8s/chiron/utils.go      |   6 +-
 security/pkg/k8s/chiron/utils_test.go |   3 +-
 7 files changed, 84 insertions(+), 103 deletions(-)

diff --git a/pilot/pkg/bootstrap/certcontroller.go b/pilot/pkg/bootstrap/certcontroller.go
index e5070fdffd..17870f02c8 100644
--- a/pilot/pkg/bootstrap/certcontroller.go
+++ b/pilot/pkg/bootstrap/certcontroller.go
@@ -102,12 +102,7 @@ func (s *Server) initCertController(args *PilotArgs) error {
 //
 // TODO: If the discovery address in mesh.yaml is set to port 15012 (XDS-with-DNS-certs) and the name
 // matches the k8s namespace, failure to start DNS server is a fatal error.
-func (s *Server) initDNSCerts(hostname, namespace string) error {
-	// Name in the Istiod cert - support the old service names as well.
-	// validate hostname contains namespace
-	parts := strings.Split(hostname, ".")
-	hostnamePrefix := parts[0]
-
+func (s *Server) initDNSCerts() error {
 	var certChain, keyPEM, caBundle []byte
 	var err error
 	pilotCertProviderName := features.PilotCertProvider
@@ -115,7 +110,7 @@ func (s *Server) initDNSCerts(hostname, namespace string) error {
 		signerName := strings.TrimPrefix(pilotCertProviderName, constants.CertProviderKubernetesSignerPrefix)
 		log.Infof("Generating K8S-signed cert for %v using signer %v", s.dnsNames, signerName)
 		certChain, keyPEM, _, err = chiron.GenKeyCertK8sCA(s.kubeClient.Kube(),
-			strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, "", signerName, true, SelfSignedCACertTTL.Get())
+			strings.Join(s.dnsNames, ","), "", signerName, true, SelfSignedCACertTTL.Get())
 		if err != nil {
 			return fmt.Errorf("failed generating key and cert by kubernetes: %v", err)
 		}
@@ -128,7 +123,7 @@ func (s *Server) initDNSCerts(hostname, namespace string) error {
 			newCaBundle, _ := s.RA.GetRootCertFromMeshConfig(signerName)
 			if newCaBundle != nil && !bytes.Equal(newCaBundle, s.istiodCertBundleWatcher.GetKeyCertBundle().CABundle) {
 				newCertChain, newKeyPEM, _, err := chiron.GenKeyCertK8sCA(s.kubeClient.Kube(),
-					strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, "", signerName, true, SelfSignedCACertTTL.Get())
+					strings.Join(s.dnsNames, ","), "", signerName, true, SelfSignedCACertTTL.Get())
 				if err != nil {
 					log.Fatalf("failed regenerating key and cert for istiod by kubernetes: %v", err)
 				}
@@ -138,7 +133,7 @@ func (s *Server) initDNSCerts(hostname, namespace string) error {
 	} else if pilotCertProviderName == constants.CertProviderKubernetes {
 		log.Infof("Generating K8S-signed cert for %v", s.dnsNames)
 		certChain, keyPEM, _, err = chiron.GenKeyCertK8sCA(s.kubeClient.Kube(),
-			strings.Join(s.dnsNames, ","), hostnamePrefix+".csr.secret", namespace, defaultCACertPath, "", true, SelfSignedCACertTTL.Get())
+			strings.Join(s.dnsNames, ","), defaultCACertPath, "", true, SelfSignedCACertTTL.Get())
 		if err != nil {
 			return fmt.Errorf("failed generating key and cert by kubernetes: %v", err)
 		}
diff --git a/pilot/pkg/bootstrap/istio_ca.go b/pilot/pkg/bootstrap/istio_ca.go
index 65cdc532ff..61385879d9 100644
--- a/pilot/pkg/bootstrap/istio_ca.go
+++ b/pilot/pkg/bootstrap/istio_ca.go
@@ -29,14 +29,12 @@
 	"google.golang.org/grpc"
 	"k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
 
 	"istio.io/api/security/v1beta1"
 	"istio.io/istio/pilot/pkg/features"
 	securityModel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/jwt"
-	kubelib "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/security"
 	"istio.io/istio/security/pkg/cmd"
 	"istio.io/istio/security/pkg/pki/ca"
@@ -86,7 +84,7 @@ type caOptions struct {
 		"Location of a local or mounted CA root")
 
 	useRemoteCerts = env.RegisterBoolVar("USE_REMOTE_CERTS", false,
-		"Whether to try to load CA certs from a remote Kubernetes cluster. Used for external Istiod.")
+		"Whether to try to load CA certs from config Kubernetes cluster. Used for external Istiod.")
 
 	workloadCertTTL = env.RegisterDurationVar("DEFAULT_WORKLOAD_CERT_TTL",
 		cmd.DefaultWorkloadCertTTL,
@@ -141,13 +139,6 @@ type caOptions struct {
 		"Kubernates CA Signer type. Valid from Kubernates 1.18").Get()
 )
 
-// EnableCA returns whether CA functionality is enabled in istiod.
-// This is a central consistent endpoint to get whether CA functionality is
-// enabled in istiod. EnableCA() is called in multiple places.
-func (s *Server) EnableCA() bool {
-	return features.EnableCAServer
-}
-
 // RunCA will start the cert signing GRPC service on an existing server.
 // Protected by installer options: the CA will be started only if the JWT token in /var/run/secrets
 // is mounted. If it is missing - for example old versions of K8S that don't support such tokens -
@@ -229,17 +220,19 @@ func detectAuthEnv(jwt string) (*authenticate.JwtPayload, error) {
 	return structuredPayload, nil
 }
 
-// loadRemoteCACerts mounts an existing cacerts Secret if the files aren't mounted locally.
+// loadCACerts loads an existing `cacerts` Secret if the files aren't mounted locally.
 // By default, a cacerts Secret would be mounted during pod startup due to the
 // Istiod Deployment configuration. But with external Istiod, we want to be
 // able to load cacerts from a remote cluster instead.
-func (s *Server) loadRemoteCACerts(caOpts *caOptions, dir string) error {
+func (s *Server) loadCACerts(caOpts *caOptions, dir string) error {
 	if s.kubeClient == nil {
 		return nil
 	}
 
 	signingKeyFile := path.Join(dir, ca.CAPrivateKeyFile)
-	if _, err := os.Stat(signingKeyFile); !os.IsNotExist(err) {
+	if _, err := os.Stat(signingKeyFile); err == nil {
+		return nil
+	} else if !os.IsNotExist(err) {
 		return fmt.Errorf("signing key file %s already exists", signingKeyFile)
 	}
 
@@ -252,7 +245,7 @@ func (s *Server) loadRemoteCACerts(caOpts *caOptions, dir string) error {
 		return err
 	}
 
-	log.Infof("cacerts Secret found in remote cluster, saving contents to %s", dir)
+	log.Infof("cacerts Secret found in config cluster, saving contents to %s", dir)
 	if err := os.MkdirAll(dir, 0o700); err != nil {
 		return err
 	}
@@ -376,7 +369,7 @@ func (s *Server) initCACertsWatcher() {
 //
 //	Inside, the key/cert are 'ca-key.pem' and 'ca-cert.pem'. The root cert signing the intermediate is root-cert.pem,
 //	which may contain multiple roots. A 'cert-chain.pem' file has the full cert chain.
-func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (*ca.IstioCA, error) {
+func (s *Server) createIstioCA(opts *caOptions) (*ca.IstioCA, error) {
 	var caOpts *ca.IstioCAOptions
 	var err error
 
@@ -392,7 +385,7 @@ func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (
 	}
 	if _, err := os.Stat(signingKeyFile); err != nil {
 		// The user-provided certs are missing - create a self-signed cert.
-		if client != nil {
+		if s.kubeClient != nil {
 			log.Info("Use self-signed certificate as the CA certificate")
 
 			// Abort after 20 minutes.
@@ -405,7 +398,7 @@ func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (
 				selfSignedRootCertGracePeriodPercentile.Get(), SelfSignedCACertTTL.Get(),
 				selfSignedRootCertCheckInterval.Get(), workloadCertTTL.Get(),
 				maxWorkloadCertTTL.Get(), opts.TrustDomain, true,
-				opts.Namespace, -1, client, rootCertFile,
+				opts.Namespace, -1, s.kubeClient.Kube().CoreV1(), rootCertFile,
 				enableJitterForRootCertRotator.Get(), caRSAKeySize.Get())
 		} else {
 			log.Warnf(
@@ -458,9 +451,7 @@ func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (
 //	kubernetes built-in `kubernetes.io/legacy-unknown" signer
 //
 // 3. Extract from the cert-chain signed by other CSR signer.
-func (s *Server) createIstioRA(client kubelib.Client,
-	opts *caOptions,
-) (ra.RegistrationAuthority, error) {
+func (s *Server) createIstioRA(opts *caOptions) (ra.RegistrationAuthority, error) {
 	caCertFile := path.Join(ra.DefaultExtCACertDir, constants.CACertNamespaceConfigMapDataName)
 	certSignerDomain := opts.CertSignerDomain
 	_, err := os.Stat(caCertFile)
@@ -478,6 +469,10 @@ func (s *Server) createIstioRA(client kubelib.Client,
 			caCertFile = ""
 		}
 	}
+
+	if s.kubeClient == nil {
+		return nil, fmt.Errorf("kubeClient is nil")
+	}
 	raOpts := &ra.IstioRAOptions{
 		ExternalCAType:   opts.ExternalCAType,
 		DefaultCertTTL:   workloadCertTTL.Get(),
@@ -485,7 +480,7 @@ func (s *Server) createIstioRA(client kubelib.Client,
 		CaSigner:         opts.ExternalCASigner,
 		CaCertFile:       caCertFile,
 		VerifyAppendCA:   true,
-		K8sClient:        client.Kube(),
+		K8sClient:        s.kubeClient.Kube(),
 		TrustDomain:      opts.TrustDomain,
 		CertSignerDomain: opts.CertSignerDomain,
 	}
diff --git a/pilot/pkg/bootstrap/istio_ca_test.go b/pilot/pkg/bootstrap/istio_ca_test.go
index 19cf95fb27..429cc31d31 100644
--- a/pilot/pkg/bootstrap/istio_ca_test.go
+++ b/pilot/pkg/bootstrap/istio_ca_test.go
@@ -44,7 +44,7 @@ func TestRemoteCerts(t *testing.T) {
 	}
 
 	// Should do nothing because cacerts doesn't exist.
-	err := s.loadRemoteCACerts(caOpts, dir)
+	err := s.loadCACerts(caOpts, dir)
 	g.Expect(err).Should(BeNil())
 
 	_, err = os.Stat(path.Join(dir, "root-cert.pem"))
@@ -54,7 +54,7 @@ func TestRemoteCerts(t *testing.T) {
 	err = createCASecret(s.kubeClient)
 	g.Expect(err).Should(BeNil())
 
-	err = s.loadRemoteCACerts(caOpts, dir)
+	err = s.loadCACerts(caOpts, dir)
 	g.Expect(err).Should(BeNil())
 
 	expectedRoot, err := readSampleCertFromFile("root-cert.pem")
@@ -62,9 +62,9 @@ func TestRemoteCerts(t *testing.T) {
 
 	g.Expect(os.ReadFile(path.Join(dir, "root-cert.pem"))).Should(Equal(expectedRoot))
 
-	// Should fail because certs already exist locally.
-	err = s.loadRemoteCACerts(caOpts, dir)
-	g.Expect(err).NotTo(BeNil())
+	// Should do nothing because certs already exist locally.
+	err = s.loadCACerts(caOpts, dir)
+	g.Expect(err).Should(BeNil())
 }
 
 func createCASecret(client kube.Client) error {
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 150d8a78ba..9580249f0f 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -36,7 +36,6 @@
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials"
 	"google.golang.org/grpc/reflection"
-	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
 	"k8s.io/client-go/rest"
 
 	"istio.io/api/security/v1beta1"
@@ -941,14 +940,44 @@ func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
 	// Skip all certificates
 	var err error
 
+	s.dnsNames = getDNSNames(args, host)
+	if hasCustomTLSCerts(args.ServerOptions.TLSOptions) {
+		// Use the DNS certificate provided via args.
+		err = s.initCertificateWatches(args.ServerOptions.TLSOptions)
+		if err != nil {
+			// Not crashing istiod - This typically happens if certs are missing and in tests.
+			log.Errorf("error initializing certificate watches: %v", err)
+			return nil
+		}
+	} else if features.EnableCAServer && features.PilotCertProvider == constants.CertProviderIstiod {
+		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
+		err = s.initDNSCerts()
+	} else if features.PilotCertProvider == constants.CertProviderKubernetes {
+		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
+		err = s.initDNSCerts()
+	} else if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
+		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
+		err = s.initDNSCerts()
+	} else {
+		return nil
+	}
+
+	if err == nil {
+		err = s.initIstiodCertLoader()
+	}
+
+	return err
+}
+
+func getDNSNames(args *PilotArgs, host string) []string {
+	dnsNames := []string{host}
 	// Append custom hostname if there is any
 	customHost := features.IstiodServiceCustomHost
-	s.dnsNames = []string{host}
 	cHosts := strings.Split(customHost, ",")
 	for _, cHost := range cHosts {
 		if cHost != "" && cHost != host {
 			log.Infof("Adding custom hostname %s", cHost)
-			s.dnsNames = append(s.dnsNames, cHost)
+			dnsNames = append(dnsNames, cHost)
 		}
 	}
 
@@ -970,47 +999,16 @@ func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
 			}
 		}
 		if !exist {
-			s.dnsNames = append(s.dnsNames, name)
-		}
-	}
-
-	if hasCustomTLSCerts(args.ServerOptions.TLSOptions) {
-		// Use the DNS certificate provided via args.
-		err = s.initCertificateWatches(args.ServerOptions.TLSOptions)
-		if err != nil {
-			// Not crashing istiod - This typically happens if certs are missing and in tests.
-			log.Errorf("error initializing certificate watches: %v", err)
-			return nil
-		}
-		err = s.initIstiodCertLoader()
-	} else if features.PilotCertProvider == constants.CertProviderNone {
-		return nil
-	} else if s.EnableCA() && features.PilotCertProvider == constants.CertProviderIstiod {
-		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
-		err = s.initDNSCerts(host, args.Namespace)
-		if err == nil {
-			err = s.initIstiodCertLoader()
-		}
-	} else if features.PilotCertProvider == constants.CertProviderKubernetes {
-		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
-		err = s.initDNSCerts(host, args.Namespace)
-		if err == nil {
-			err = s.initIstiodCertLoader()
-		}
-	} else if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
-		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost)
-		err = s.initDNSCerts(host, args.Namespace)
-		if err == nil {
-			err = s.initIstiodCertLoader()
+			dnsNames = append(dnsNames, name)
 		}
 	}
 
-	return err
+	return dnsNames
 }
 
 // createPeerCertVerifier creates a SPIFFE certificate verifier with the current istiod configuration.
 func (s *Server) createPeerCertVerifier(tlsOptions TLSOptions) (*spiffe.PeerCertVerifier, error) {
-	if tlsOptions.CaCertFile == "" && s.CA == nil && features.SpiffeBundleEndpoints == "" && !s.isDisableCa() {
+	if tlsOptions.CaCertFile == "" && s.CA == nil && features.SpiffeBundleEndpoints == "" && !s.isCADisabled() {
 		// Running locally without configured certs - no TLS mode
 		return nil, nil
 	}
@@ -1102,36 +1100,31 @@ func (s *Server) initMulticluster(args *PilotArgs) {
 // maybeCreateCA creates and initializes CA Key if needed.
 func (s *Server) maybeCreateCA(caOpts *caOptions) error {
 	// CA signing certificate must be created only if CA is enabled.
-	if s.EnableCA() {
+	if features.EnableCAServer {
 		log.Info("creating CA and initializing public key")
 		var err error
-		var corev1 v1.CoreV1Interface
-		if s.kubeClient != nil {
-			corev1 = s.kubeClient.Kube().CoreV1()
-		}
 		if useRemoteCerts.Get() {
-			if err = s.loadRemoteCACerts(caOpts, LocalCertDir.Get()); err != nil {
+			if err = s.loadCACerts(caOpts, LocalCertDir.Get()); err != nil {
 				return fmt.Errorf("failed to load remote CA certs: %v", err)
 			}
 		}
 		// May return nil, if the CA is missing required configs - This is not an error.
 		if caOpts.ExternalCAType != "" {
-			if s.RA, err = s.createIstioRA(s.kubeClient, caOpts); err != nil {
+			if s.RA, err = s.createIstioRA(caOpts); err != nil {
 				return fmt.Errorf("failed to create RA: %v", err)
 			}
 		}
-		if !s.isDisableCa() {
-			if s.CA, err = s.createIstioCA(corev1, caOpts); err != nil {
+		if !s.isCADisabled() {
+			if s.CA, err = s.createIstioCA(caOpts); err != nil {
 				return fmt.Errorf("failed to create CA: %v", err)
 			}
 		}
-
 	}
 	return nil
 }
 
 func (s *Server) shouldStartNsController() bool {
-	if s.isDisableCa() {
+	if s.isCADisabled() {
 		return true
 	}
 	if s.CA == nil {
@@ -1257,19 +1250,20 @@ func (s *Server) initWorkloadTrustBundle(args *PilotArgs) error {
 	return nil
 }
 
-// isDisableCa returns whether CA functionality is disabled in istiod.
-// It return true only if istiod certs is signed by Kubernetes and
+// isCADisabled returns whether CA functionality is disabled in istiod.
+// It returns true only if istiod certs is signed by Kubernetes or
 // workload certs are signed by external CA
-func (s *Server) isDisableCa() bool {
-	if s.RA != nil {
-		// do not create CA server if PilotCertProvider is `kubernetes` and RA server exists
-		if features.PilotCertProvider == constants.CertProviderKubernetes {
-			return true
-		}
-		// do not create CA server if PilotCertProvider is `k8s.io/*` and RA server exists
-		if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
-			return true
-		}
+func (s *Server) isCADisabled() bool {
+	if s.RA == nil {
+		return false
+	}
+	// do not create CA server if PilotCertProvider is `kubernetes` and RA server exists
+	if features.PilotCertProvider == constants.CertProviderKubernetes {
+		return true
+	}
+	// do not create CA server if PilotCertProvider is `k8s.io/*` and RA server exists
+	if strings.HasPrefix(features.PilotCertProvider, constants.CertProviderKubernetesSignerPrefix) {
+		return true
 	}
 	return false
 }
diff --git a/security/pkg/k8s/chiron/controller.go b/security/pkg/k8s/chiron/controller.go
index 8fbe630655..2553dc0c41 100644
--- a/security/pkg/k8s/chiron/controller.go
+++ b/security/pkg/k8s/chiron/controller.go
@@ -191,7 +191,7 @@ func (wc *WebhookController) upsertSecret(secretName, dnsName, secretNamespace s
 
 	requestedLifetime := time.Duration(0)
 	// Now we know the secret does not exist yet. So we create a new one.
-	chain, key, caCert, err := GenKeyCertK8sCA(wc.clientset, dnsName, secretName, secretNamespace, wc.k8sCaCertFile, wc.certIssuer, true, requestedLifetime)
+	chain, key, caCert, err := GenKeyCertK8sCA(wc.clientset, dnsName, wc.k8sCaCertFile, wc.certIssuer, true, requestedLifetime)
 	if err != nil {
 		log.Errorf("failed to generate key and certificate for secret %v in namespace %v (error %v)",
 			secretName, secretNamespace, err)
@@ -312,7 +312,7 @@ func (wc *WebhookController) refreshSecret(scrt *v1.Secret) error {
 	}
 
 	requestedLifetime := time.Duration(0)
-	chain, key, caCert, err := GenKeyCertK8sCA(wc.clientset, dnsName, scrtName, namespace, wc.k8sCaCertFile, wc.certIssuer, true, requestedLifetime)
+	chain, key, caCert, err := GenKeyCertK8sCA(wc.clientset, dnsName, wc.k8sCaCertFile, wc.certIssuer, true, requestedLifetime)
 	if err != nil {
 		return err
 	}
diff --git a/security/pkg/k8s/chiron/utils.go b/security/pkg/k8s/chiron/utils.go
index c3a2074350..dbe7cac3d5 100644
--- a/security/pkg/k8s/chiron/utils.go
+++ b/security/pkg/k8s/chiron/utils.go
@@ -57,13 +57,11 @@ func GenCsrName() string {
 // GenKeyCertK8sCA : Generates a key pair and gets public certificate signed by K8s_CA
 // Options are meant to sign DNS certs
 // 1. Generate a CSR
-// 2. Call SignCSRK8sCA to finish rest of the flow
+// 2. Call SignCSRK8s to finish rest of the flow
 func GenKeyCertK8sCA(client clientset.Interface, dnsName,
-	secretName, secretNamespace, caFilePath string,
-	signerName string, approveCsr bool, requestedLifetime time.Duration,
+	caFilePath string, signerName string, approveCsr bool, requestedLifetime time.Duration,
 ) ([]byte, []byte, []byte, error) {
 	// 1. Generate a CSR
-
 	options := util.CertOptions{
 		Host:       dnsName,
 		RSAKeySize: keySize,
diff --git a/security/pkg/k8s/chiron/utils_test.go b/security/pkg/k8s/chiron/utils_test.go
index 36688f1be7..3806970282 100644
--- a/security/pkg/k8s/chiron/utils_test.go
+++ b/security/pkg/k8s/chiron/utils_test.go
@@ -137,8 +137,7 @@ func TestGenKeyCertK8sCA(t *testing.T) {
 			continue
 		}
 
-		_, _, _, err = GenKeyCertK8sCA(wc.clientset, tc.dnsNames[0], tc.secretNames[0],
-			tc.secretNamespace, wc.k8sCaCertFile, "testSigner", true, DefaulCertTTL)
+		_, _, _, err = GenKeyCertK8sCA(wc.clientset, tc.dnsNames[0], wc.k8sCaCertFile, "testSigner", true, DefaulCertTTL)
 		if tc.expectFail {
 			if err == nil {
 				t.Errorf("should have failed")
-- 
2.35.3

