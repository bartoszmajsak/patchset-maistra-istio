From c8b782dd228f2d78676bf476d5d1b5d143fc649c Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Wed, 13 Apr 2022 11:10:05 -0700
Subject: tf: cleanup usages of Workload (#37647)

This introduces a new TargetWorkload entry to call *pods* rather than
*services*. And cleans up a bunch of usages where we use to do things
the hard way
---
 .../framework/components/echo/calloptions.go  | 92 ++++++++++++++-----
 .../components/echo/check/checkers.go         | 18 ++++
 .../components/echo/echotest/filters_test.go  |  4 +
 .../framework/components/echo/instance.go     |  3 +
 .../components/echo/kube/instance.go          | 42 +++++++--
 .../components/echo/match/matchers_test.go    |  5 +
 pkg/test/framework/components/echo/port.go    | 10 ++
 .../components/echo/staticvm/instance.go      | 36 ++++++--
 tests/integration/pilot/common/routing.go     | 27 ++----
 .../security/authorization_test.go            | 62 ++++++-------
 .../trust_domain_validation_test.go           | 46 +++-------
 .../pass_through_filter_chain_test.go         | 39 ++------
 .../telemetry/stats/prometheus/stats.go       |  6 +-
 13 files changed, 231 insertions(+), 159 deletions(-)

diff --git a/pkg/test/framework/components/echo/calloptions.go b/pkg/test/framework/components/echo/calloptions.go
index 836d5aba54..de6d46fff4 100644
--- a/pkg/test/framework/components/echo/calloptions.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -97,9 +97,15 @@ type Target interface {
 
 // CallOptions defines options for calling a Endpoint.
 type CallOptions struct {
-	// To is the Target to be called. Required.
+	// To is the Target to be called.
 	To Target
 
+	// ToWorkload will call a specific workload in this instance, rather than the Service.
+	// If there are multiple workloads in the Instance, the first is used.
+	// Can be used with `ToWorkload: to.WithWorkloads(someWl)` to send to a specific workload.
+	// When using the Port field, the ServicePort should be used.
+	ToWorkload Instance
+
 	// Port to be used for the call. Ignored if Scheme == DNS. If the Port.ServicePort is set,
 	// either Port.Protocol or Scheme must also be set. If Port.ServicePort is not set,
 	// the port is looked up in To by either Port.Name or Port.Protocol.
@@ -215,12 +221,21 @@ func (o *CallOptions) FillDefaults() error {
 
 func (o *CallOptions) fillAddress() error {
 	if o.Address == "" {
-		if o.To == nil {
-			return errors.New("if address is not set, then To must be set")
+		if o.To != nil {
+			// No host specified, use the fully qualified domain name for the service.
+			o.Address = o.To.Config().ClusterLocalFQDN()
+			return nil
+		}
+		if o.ToWorkload != nil {
+			wl, err := o.ToWorkload.Workloads()
+			if err != nil {
+				return err
+			}
+			o.Address = wl[0].Address()
+			return nil
 		}
 
-		// No host specified, use the fully qualified domain name for the service.
-		o.Address = o.To.Config().ClusterLocalFQDN()
+		return errors.New("if address is not set, then To must be set")
 	}
 	return nil
 }
@@ -241,27 +256,16 @@ func (o *CallOptions) fillPort() error {
 	}
 
 	if o.To != nil {
-		servicePorts := o.To.Config().Ports.GetServicePorts()
-
-		if o.Port.Name != "" {
-			// Look up the port by name.
-			p, found := servicePorts.ForName(o.Port.Name)
-			if !found {
-				return fmt.Errorf("callOptions: no port named %s available in To Instance", o.Port.Name)
-			}
-			o.Port = p
-			return nil
-		}
-
-		if o.Port.Protocol != "" {
-			// Look up the port by protocol.
-			p, found := servicePorts.ForProtocol(o.Port.Protocol)
-			if !found {
-				return fmt.Errorf("callOptions: no port for protocol %s available in To Instance", o.Port.Protocol)
-			}
-			o.Port = p
-			return nil
+		return o.fillPort2(o.To)
+	} else if o.ToWorkload != nil {
+		err := o.fillPort2(o.ToWorkload)
+		if err != nil {
+			return err
 		}
+		// Set the ServicePort to workload port since we are not reaching it through the Service
+		p := o.Port
+		p.ServicePort = p.WorkloadPort
+		o.Port = p
 	}
 
 	if o.Port.ServicePort <= 0 || (o.Port.Protocol == "" && o.Scheme == "") || o.Address == "" {
@@ -271,6 +275,41 @@ func (o *CallOptions) fillPort() error {
 	return nil
 }
 
+func (o *CallOptions) fillPort2(target Target) error {
+	servicePorts := target.Config().Ports.GetServicePorts()
+
+	if o.Port.Name != "" {
+		// Look up the port by name.
+		p, found := servicePorts.ForName(o.Port.Name)
+		if !found {
+			return fmt.Errorf("callOptions: no port named %s available in To Instance", o.Port.Name)
+		}
+		o.Port = p
+		return nil
+	}
+
+	if o.Port.Protocol != "" {
+		// Look up the port by protocol.
+		p, found := servicePorts.ForProtocol(o.Port.Protocol)
+		if !found {
+			return fmt.Errorf("callOptions: no port for protocol %s available in To Instance", o.Port.Protocol)
+		}
+		o.Port = p
+		return nil
+	}
+
+	if o.Port.ServicePort != 0 {
+		// We just have a single port number, populate the rest of the fields
+		p, found := servicePorts.ForServicePort(o.Port.ServicePort)
+		if !found {
+			return fmt.Errorf("callOptions: no port %d available in To Instance", o.Port.ServicePort)
+		}
+		o.Port = p
+		return nil
+	}
+	return nil
+}
+
 func (o *CallOptions) fillScheme() error {
 	if o.Scheme == "" {
 		// No protocol, fill it in.
@@ -283,6 +322,9 @@ func (o *CallOptions) fillScheme() error {
 }
 
 func (o *CallOptions) fillHeaders() {
+	if o.ToWorkload != nil {
+		return
+	}
 	// Initialize the headers and add a default Host header if none provided.
 	if o.HTTP.Headers == nil {
 		o.HTTP.Headers = make(http.Header)
diff --git a/pkg/test/framework/components/echo/check/checkers.go b/pkg/test/framework/components/echo/check/checkers.go
index 1465692788..c58579806b 100644
--- a/pkg/test/framework/components/echo/check/checkers.go
+++ b/pkg/test/framework/components/echo/check/checkers.go
@@ -117,6 +117,24 @@ func ErrorContains(expected string) echo.Checker {
 	}
 }
 
+func ErrorOrStatus(expected int) echo.Checker {
+	expectedStr := ""
+	if expected > 0 {
+		expectedStr = strconv.Itoa(expected)
+	}
+	return func(resp echo.CallResult, err error) error {
+		if err != nil {
+			return nil
+		}
+		for _, r := range resp.Responses {
+			if r.Code != expectedStr {
+				return fmt.Errorf("expected response code `%s`, got %q", expectedStr, r.Code)
+			}
+		}
+		return nil
+	}
+}
+
 // OK is a shorthand for NoErrorAndStatus(200).
 func OK() echo.Checker {
 	return NoErrorAndStatus(http.StatusOK)
diff --git a/pkg/test/framework/components/echo/echotest/filters_test.go b/pkg/test/framework/components/echo/echotest/filters_test.go
index 2237369892..9d220b257d 100644
--- a/pkg/test/framework/components/echo/echotest/filters_test.go
+++ b/pkg/test/framework/components/echo/echotest/filters_test.go
@@ -328,6 +328,10 @@ func instanceKey(i echo.Instance) string {
 // fakeInstance wraps echo.Config for test-framework internals tests where we don't actually make calls
 type fakeInstance echo.Config
 
+func (f fakeInstance) WithWorkloads(wl ...echo.Workload) echo.Instance {
+	panic("implement me")
+}
+
 func (f fakeInstance) Instances() echo.Instances {
 	return echo.Instances{f}
 }
diff --git a/pkg/test/framework/components/echo/instance.go b/pkg/test/framework/components/echo/instance.go
index 979479884b..54a9446e8c 100644
--- a/pkg/test/framework/components/echo/instance.go
+++ b/pkg/test/framework/components/echo/instance.go
@@ -32,4 +32,7 @@ type Instance interface {
 
 	// Restart restarts the workloads associated with this echo instance
 	Restart() error
+
+	// WithWorkloads returns a target with only the specified subset of workloads
+	WithWorkloads(wl ...Workload) Instance
 }
diff --git a/pkg/test/framework/components/echo/kube/instance.go b/pkg/test/framework/components/echo/kube/instance.go
index 22e9c20fd5..3e2f978f85 100644
--- a/pkg/test/framework/components/echo/kube/instance.go
+++ b/pkg/test/framework/components/echo/kube/instance.go
@@ -49,14 +49,15 @@
 )
 
 type instance struct {
-	id          resource.ID
-	cfg         echo.Config
-	clusterIP   string
-	clusterIPs  []string
-	ctx         resource.Context
-	cluster     cluster.Cluster
-	workloadMgr *workloadManager
-	deployment  *deployment
+	id             resource.ID
+	cfg            echo.Config
+	clusterIP      string
+	clusterIPs     []string
+	ctx            resource.Context
+	cluster        cluster.Cluster
+	workloadMgr    *workloadManager
+	deployment     *deployment
+	workloadFilter []echo.Workload
 }
 
 func newInstance(ctx resource.Context, originalCfg echo.Config) (out *instance, err error) {
@@ -124,7 +125,24 @@ func (c *instance) Addresses() []string {
 }
 
 func (c *instance) Workloads() (echo.Workloads, error) {
-	return c.workloadMgr.ReadyWorkloads()
+	wls, err := c.workloadMgr.ReadyWorkloads()
+	if err != nil {
+		return nil, err
+	}
+	final := []echo.Workload{}
+	for _, wl := range wls {
+		filtered := false
+		for _, filter := range c.workloadFilter {
+			if wl.Address() != filter.Address() {
+				filtered = true
+				break
+			}
+		}
+		if !filtered {
+			final = append(final, wl)
+		}
+	}
+	return final, nil
 }
 
 func (c *instance) WorkloadsOrFail(t test.Failer) echo.Workloads {
@@ -176,6 +194,12 @@ func (c *instance) Config() echo.Config {
 	return c.cfg
 }
 
+func (c *instance) WithWorkloads(wls ...echo.Workload) echo.Instance {
+	n := *c
+	c.workloadFilter = wls
+	return &n
+}
+
 func (c *instance) Cluster() cluster.Cluster {
 	return c.cfg.Cluster
 }
diff --git a/pkg/test/framework/components/echo/match/matchers_test.go b/pkg/test/framework/components/echo/match/matchers_test.go
index 52d1fc1bb4..6a8a24647a 100644
--- a/pkg/test/framework/components/echo/match/matchers_test.go
+++ b/pkg/test/framework/components/echo/match/matchers_test.go
@@ -95,6 +95,11 @@ func TestNaked(t *testing.T) {
 // fakeInstance wraps echo.Config for test-framework internals tests where we don't actually make calls
 type fakeInstance echo.Config
 
+func (f fakeInstance) WithWorkloads(wl ...echo.Workload) echo.Instance {
+	// TODO implement me
+	panic("implement me")
+}
+
 func (f fakeInstance) Instances() echo.Instances {
 	return echo.Instances{f}
 }
diff --git a/pkg/test/framework/components/echo/port.go b/pkg/test/framework/components/echo/port.go
index 1dd5c1cd53..892a505562 100644
--- a/pkg/test/framework/components/echo/port.go
+++ b/pkg/test/framework/components/echo/port.go
@@ -118,6 +118,16 @@ func (ps Ports) ForProtocol(protocol protocol.Instance) (Port, bool) {
 	return Port{}, false
 }
 
+// ForServicePort returns the first port found with the given service port.
+func (ps Ports) ForServicePort(port int) (Port, bool) {
+	for _, p := range ps {
+		if p.ServicePort == port {
+			return p, true
+		}
+	}
+	return Port{}, false
+}
+
 // MustForProtocol calls ForProtocol and panics if not found.
 func (ps Ports) MustForProtocol(protocol protocol.Instance) Port {
 	p, found := ps.ForProtocol(protocol)
diff --git a/pkg/test/framework/components/echo/staticvm/instance.go b/pkg/test/framework/components/echo/staticvm/instance.go
index 3be9bfea98..932169262b 100644
--- a/pkg/test/framework/components/echo/staticvm/instance.go
+++ b/pkg/test/framework/components/echo/staticvm/instance.go
@@ -39,10 +39,11 @@ func init() {
 }
 
 type instance struct {
-	id        resource.ID
-	config    echo.Config
-	address   string
-	workloads echo.Workloads
+	id             resource.ID
+	config         echo.Config
+	address        string
+	workloads      echo.Workloads
+	workloadFilter []echo.Workload
 }
 
 func newInstances(ctx resource.Context, config []echo.Config) (echo.Instances, error) {
@@ -128,8 +129,27 @@ func (i *instance) Addresses() []string {
 	return []string{i.address}
 }
 
+func (i *instance) WithWorkloads(wls ...echo.Workload) echo.Instance {
+	n := *i
+	i.workloadFilter = wls
+	return &n
+}
+
 func (i *instance) Workloads() (echo.Workloads, error) {
-	return i.workloads, nil
+	final := []echo.Workload{}
+	for _, wl := range i.workloads {
+		filtered := false
+		for _, filter := range i.workloadFilter {
+			if wl.Address() != filter.Address() {
+				filtered = true
+				break
+			}
+		}
+		if !filtered {
+			final = append(final, wl)
+		}
+	}
+	return final, nil
 }
 
 func (i *instance) WorkloadsOrFail(t test.Failer) echo.Workloads {
@@ -161,7 +181,11 @@ func (i *instance) Instances() echo.Instances {
 }
 
 func (i *instance) defaultClient() (*echoClient.Client, error) {
-	return i.workloads[0].(*workload).Client, nil
+	wl, err := i.Workloads()
+	if err != nil {
+		return nil, err
+	}
+	return wl[0].(*workload).Client, nil
 }
 
 func (i *instance) Call(opts echo.CallOptions) (echo.CallResult, error) {
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index e99e91749d..9aea85f6b2 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -18,7 +18,6 @@
 package common
 
 import (
-	"context"
 	"fmt"
 	"net/http"
 	"net/url"
@@ -34,10 +33,8 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/security"
 	"istio.io/istio/pkg/http/headers"
-	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
-	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/check"
@@ -902,27 +899,17 @@ func trafficLoopCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
 	for _, c := range apps.A {
 		for _, d := range apps.B {
-			for _, port := range []string{"15001", "15006"} {
+			for _, port := range []int{15001, 15006} {
 				c, d, port := c, d, port
 				cases = append(cases, TrafficTestCase{
-					name: port,
-					call: func(t test.Failer, options echo.CallOptions) echo.CallResult {
-						dwl := d.WorkloadsOrFail(t)[0]
-						cwl := c.WorkloadsOrFail(t)[0]
-						resp, err := cwl.ForwardEcho(context.Background(), &epb.ForwardEchoRequest{
-							Url:   fmt.Sprintf("http://%s:%s", dwl.Address(), port),
-							Count: 1,
-						})
+					name: fmt.Sprint(port),
+					call: c.CallOrFail,
+					opts: echo.CallOptions{
+						ToWorkload: d,
+						Port:       echo.Port{ServicePort: port, Protocol: protocol.HTTP},
 						// Ideally we would actually check to make sure we do not blow up the pod,
 						// but I couldn't find a way to reliably detect this.
-						if err == nil {
-							t.Fatalf("expected request to fail, but it didn't: %v", resp)
-						}
-						return echo.CallResult{
-							From:      nil,
-							Opts:      options,
-							Responses: nil,
-						}
+						Check: check.Error(),
 					},
 				})
 			}
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index ce3c931426..85808f3d19 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -18,18 +18,16 @@
 package security
 
 import (
-	"context"
 	"fmt"
 	"net/http"
 	"strings"
 	"testing"
+	"time"
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/http/headers"
 	echoClient "istio.io/istio/pkg/test/echo"
-	echoCommon "istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
-	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/check"
@@ -40,7 +38,6 @@
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/kube"
-	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/tests/common/jwt"
 	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/security/util/scheck"
@@ -746,7 +743,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 			// policies at gateways are useful for managing accessibility to external
 			// services running on a VM.
 			for _, a := range []echo.Instances{a, vm} {
-				t.NewSubTestf("to %s/", a[0].Config().Service).Run(func(t framework.TestContext) {
+				t.NewSubTestf("to %s", a[0].Config().Service).Run(func(t framework.TestContext) {
 					t.ConfigIstio().EvalFile("", map[string]string{
 						"Namespace":     ns.Name(),
 						"RootNamespace": rootns.Name(),
@@ -759,7 +756,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						code  int
 						body  string
 						host  string
-						from  echo.Workload
+						from  echo.Instances
 						token string
 					}{
 						{
@@ -768,7 +765,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code: http.StatusOK,
 							body: "handled-by-egress-gateway",
 							host: "www.company.com",
-							from: a.WorkloadsOrFail(t)[0],
+							from: a,
 						},
 						{
 							name: "deny path to company.com",
@@ -776,7 +773,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code: http.StatusForbidden,
 							body: "RBAC: access denied",
 							host: "www.company.com",
-							from: a.WorkloadsOrFail(t)[0],
+							from: a,
 						},
 						{
 							name: "allow service account a to a-only.com over mTLS",
@@ -784,7 +781,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code: http.StatusOK,
 							body: "handled-by-egress-gateway",
 							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
-							from: a.WorkloadsOrFail(t)[0],
+							from: a,
 						},
 						{
 							name: "deny service account b to a-only.com over mTLS",
@@ -792,7 +789,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code: http.StatusForbidden,
 							body: "RBAC: access denied",
 							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
-							from: c.WorkloadsOrFail(t)[0],
+							from: c,
 						},
 						{
 							name:  "allow a with JWT to jwt-only.com over mTLS",
@@ -800,7 +797,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusOK,
 							body:  "handled-by-egress-gateway",
 							host:  "jwt-only.com",
-							from:  a.WorkloadsOrFail(t)[0],
+							from:  a,
 							token: jwt.TokenIssuer1,
 						},
 						{
@@ -809,7 +806,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusOK,
 							body:  "handled-by-egress-gateway",
 							host:  "jwt-only.com",
-							from:  c.WorkloadsOrFail(t)[0],
+							from:  c,
 							token: jwt.TokenIssuer1,
 						},
 						{
@@ -818,7 +815,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusForbidden,
 							body:  "RBAC: access denied",
 							host:  "jwt-only.com",
-							from:  c.WorkloadsOrFail(t)[0],
+							from:  c,
 							token: jwt.TokenIssuer2,
 						},
 						{
@@ -827,7 +824,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusOK,
 							body:  "handled-by-egress-gateway",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  a.WorkloadsOrFail(t)[0],
+							from:  a,
 							token: jwt.TokenIssuer1,
 						},
 						{
@@ -836,7 +833,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusForbidden,
 							body:  "RBAC: access denied",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  c.WorkloadsOrFail(t)[0],
+							from:  c,
 							token: jwt.TokenIssuer1,
 						},
 						{
@@ -845,25 +842,26 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 							code:  http.StatusForbidden,
 							body:  "RBAC: access denied",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  a.WorkloadsOrFail(t)[0],
+							from:  a,
 							token: jwt.TokenIssuer2,
 						},
 					}
 
 					for _, tc := range cases {
-						request := &epb.ForwardEchoRequest{
-							// Use a fake IP to make sure the request is handled by our test.
-							Url:     fmt.Sprintf("http://10.4.4.4%s", tc.path),
-							Count:   1,
-							Headers: echoCommon.HTTPToProtoHeaders(headers.New().WithHost(tc.host).WithAuthz(tc.token).Build()),
-						}
 						t.NewSubTest(tc.name).Run(func(t framework.TestContext) {
-							retry.UntilSuccessOrFail(t, func() error {
-								rs, err := tc.from.ForwardEcho(context.TODO(), request)
-								if err != nil {
-									return err
-								}
-								return check.And(
+							tc.from[0].CallOrFail(t, echo.CallOptions{
+								Port: echo.Port{
+									Protocol:    protocol.HTTP,
+									ServicePort: 80,
+								},
+								Timeout: time.Second,
+								// Use a fake IP to make sure the request is handled by our test.
+								Address: "10.4.4.4",
+								HTTP: echo.HTTP{
+									Headers: headers.New().WithHost(tc.host).WithAuthz(tc.token).Build(),
+									Path:    tc.path,
+								},
+								Check: check.And(
 									check.NoError(),
 									check.Status(tc.code),
 									check.Each(func(r echoClient.Response) error {
@@ -871,12 +869,8 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 											return fmt.Errorf("want %q in body but not found: %s", tc.body, r.RawContent)
 										}
 										return nil
-									})).Check(echo.CallResult{
-									From:      nil, // TODO(nmittler): consider making workload implement Caller interface.
-									Opts:      echo.CallOptions{},
-									Responses: rs,
-								}, err)
-							}, echo.DefaultCallRetryOptions()...)
+									})),
+							})
 						})
 					}
 				})
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index 05765146aa..649086cdc6 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -18,22 +18,17 @@
 package cacustomroot
 
 import (
-	"context"
 	"fmt"
-	"net"
 	"os"
 	"path"
 	"testing"
-	"time"
 
 	"istio.io/istio/pkg/test/echo/common/scheme"
-	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/check"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
-	"istio.io/istio/pkg/test/util/retry"
 )
 
 const (
@@ -145,34 +140,23 @@ func(ctx framework.TestContext) {
 									Cert: trustDomains[td].cert,
 									Key:  trustDomains[td].key,
 								},
-								Retry: echo.Retry{
-									NoRetry: true,
-								},
 							}
-							retry.UntilSuccessOrFail(t, func() error {
-								result := echo.CallResult{
-									From: from,
-									Opts: opt,
-								}
-								var err error
-								if port == passThrough {
-									// Manually make the request for pass through port.
-									fromWorkload := from.WorkloadsOrFail(t)[0]
-									toWorkload := server.WorkloadsOrFail(t)[0]
-									result.Responses, err = fromWorkload.ForwardEcho(context.TODO(), &epb.ForwardEchoRequest{
-										Url:   fmt.Sprintf("tcp://%s", net.JoinHostPort(toWorkload.Address(), "9000")),
-										Count: 1,
-										Cert:  trustDomains[td].cert,
-										Key:   trustDomains[td].key,
-									})
-								} else {
-									result, err = from.Call(opt)
-								}
-								if allow {
-									return check.OK().Check(result, err)
+							if port == passThrough {
+								// Manually make the request for pass through port.
+								opt = echo.CallOptions{
+									ToWorkload: server,
+									Port:       echo.Port{Name: tcpWL},
+									TLS: echo.TLS{
+										Cert: trustDomains[td].cert,
+										Key:  trustDomains[td].key,
+									},
+									Check: check.OK(),
 								}
-								return check.ErrorContains("tls: unknown certificate").Check(result, err)
-							}, retry.Delay(250*time.Millisecond), retry.Timeout(30*time.Second), retry.Converge(5))
+							}
+							if !allow {
+								opt.Check = check.ErrorContains("tls: unknown certificate")
+							}
+							from.CallOrFail(t, opt)
 						})
 					}
 
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 8ffddc6fd4..a6511bec9c 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -23,7 +23,6 @@
 	"testing"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/check"
@@ -646,41 +645,19 @@ type expect struct {
 								if from.Config().IsNaked() {
 									want = expect.plaintextSucceeds
 								}
+								c := check.OK()
+								if !want {
+									c = check.ErrorOrStatus(http.StatusForbidden)
+								}
 								name := fmt.Sprintf("%v/port %d[%t]", nameSuffix, expect.port.ServicePort, want)
-								host := fmt.Sprintf("%s:%d", to.WorkloadsOrFail(t)[0].Address(), expect.port.ServicePort)
 								callOpt := echo.CallOptions{
-									Count: util.CallsPerCluster * to.WorkloadsOrFail(t).Len(),
-									Port:  expect.port,
-									HTTP: echo.HTTP{
-										Headers: headers.New().WithHost(host).Build(),
-									},
+									Count:   util.CallsPerCluster * to.WorkloadsOrFail(t).Len(),
+									Port:    expect.port,
 									Message: "HelloWorld",
 									// Do not set To to dest, otherwise fillInCallOptions() will
 									// complain with port does not match.
-									Address: to.WorkloadsOrFail(t)[0].Address(),
-									Check: func(result echo.CallResult, err error) error {
-										if want {
-											if err != nil {
-												return fmt.Errorf("want allow but got error: %v", err)
-											}
-											if result.Responses.Len() < 1 {
-												return fmt.Errorf("received no responses from request to %s", host)
-											}
-											if okErr := check.OK().Check(result, err); okErr != nil && expect.port.Protocol == protocol.HTTP {
-												return fmt.Errorf("want status %d but got %s", http.StatusOK, okErr.Error())
-											}
-										} else {
-											// Check HTTP forbidden response
-											if result.Responses.Len() >= 1 && check.Status(http.StatusForbidden).Check(result, err) == nil {
-												return nil
-											}
-
-											if err == nil {
-												return fmt.Errorf("want error but got none: %v", result.Responses.String())
-											}
-										}
-										return nil
-									},
+									ToWorkload: to.Instances()[0],
+									Check:      c,
 								}
 								t.NewSubTest(name).Run(func(t framework.TestContext) {
 									from.CallOrFail(t, callOpt)
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index 10455dc3e8..7ac1ad2baa 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -151,9 +151,9 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {
 			for _, prom := range mockProm {
 				st := match.Cluster(prom.Config().Cluster).FirstOrFail(t, server)
 				prom.CallOrFail(t, echo.CallOptions{
-					Address: st.WorkloadsOrFail(t)[0].Address(),
-					Scheme:  scheme.HTTPS,
-					Port:    echo.Port{ServicePort: 15014},
+					ToWorkload: st,
+					Scheme:     scheme.HTTPS,
+					Port:       echo.Port{ServicePort: 15014},
 					HTTP: echo.HTTP{
 						Path: "/metrics",
 					},
-- 
2.35.3

