From db5351d5e3d3a8a4a2ffce7c5ce4a80a914098f7 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Tue, 26 Apr 2022 11:36:05 -0700
Subject: pilot: remove concept of `plugins` (#38595)

The plugin concept is not something that is adding value to Istio
currently, and causes a number of problems. This PR is meant to be a
refactoring (no behavioral changes or XDS output changes) to remove the
plugin concept. I have a number of PRs that build upon this to further
improve the code around here, so this is meant to just be part 1.

Issues with plugin:
* Plugins are not actually pluggable - there is no mechanism to inject
  plugins at runtime. Almost all extensibility in Istio these days is
done through EnvoyFilters (eg `aeraki`). The one case I know using
plugins is Cilium; this is done by having a fork of Istio. This could be
handled just as easily by inserting 1 line in
`buildHTTPConnectionManager` rather than using a plugin. The plugin
interface was never stable, either, so there was no expectation that a
plugin could be zero-maintenance on upgrades/rebases/etc.
* Plugins are not actually generic - for example, we have a plugin for
  Authn. This implements the InboundMTLSConfiguration. There can only be
a single plugin that implements the InboundMTLSConfiguration interface,
and logically only the Authn plugin we have can meet it's requirements.
* Plugins work on the wrong abstractions. Currently we only have
  listener mutation. However, we do not even build 'Listeners' in most
cases - we build filter chains. Soon, even outbound will have one
listener most likely. This issue actually causes major code issues; we
build fake listeners for inbound then later convert them to filter
chains (I have a PR fixing this, building upon this PR).
* Plugin inputs are too large - this has been improved over the years,
  but still an issue. `InputParams` takes a lot of inputs, and many call
sites do not have all of them so they make up dummy inputs. This is
super fragile -- a plugin has access to a bunch of fields but many of
them are unsafe to use.
* Plugins are not flexible - we only expose a minimal amount of
  integration points.
* Plugins are fragile - all plugins work by just appending a filter to
  the end of the filter list. But filter order is extremely critical!

For these reasons, I suggest we finally remove the plugin concept
entirely. Instead, we directly insert the authn and authz filters where
needed.

Note: there is some duplication here, and leaky abstractions a bit in
the TCP filter application (HTTP is fine, IMO). I have some improvements
in another PR but do not want to make this PR too large.
---
 pilot/cmd/pilot-discovery/app/cmd.go          |   5 +-
 pilot/pkg/bootstrap/options.go                |   1 -
 pilot/pkg/bootstrap/server.go                 |  11 +-
 pilot/pkg/bootstrap/server_test.go            |   5 -
 pilot/pkg/networking/core/configgen.go        |   5 +-
 pilot/pkg/networking/core/v1alpha3/cluster.go |   4 +-
 .../networking/core/v1alpha3/cluster_test.go  |   4 +-
 .../pkg/networking/core/v1alpha3/configgen.go |  10 +-
 .../core/v1alpha3/extension/wasmplugin.go     |  80 +---------
 .../v1alpha3/extension/wasmplugin_test.go     | 141 ------------------
 pilot/pkg/networking/core/v1alpha3/fake.go    |  11 +-
 pilot/pkg/networking/core/v1alpha3/gateway.go |  24 ++-
 .../networking/core/v1alpha3/gateway_test.go  |   8 +-
 .../pkg/networking/core/v1alpha3/httproute.go |   2 +-
 .../pkg/networking/core/v1alpha3/listener.go  | 113 ++++++++------
 .../core/v1alpha3/listener_builder.go         |  92 +++++-------
 .../core/v1alpha3/listener_builder_test.go    | 133 +++++------------
 .../networking/core/v1alpha3/listener_test.go | 120 +++------------
 pilot/pkg/networking/networking.go            |   1 +
 .../networking/plugin/authn/authentication.go | 122 +++++++--------
 .../networking/plugin/authz/authorization.go  | 114 ++++----------
 pilot/pkg/networking/plugin/plugin.go         |  21 ---
 .../networking/plugin/registry/registry.go    |  42 ------
 .../plugin/registry/registry_test.go          |  29 ----
 pilot/pkg/security/authz/builder/builder.go   |   6 +-
 .../security/authz/builder/builder_test.go    |   6 +-
 pilot/pkg/security/authz/builder/extauthz.go  |  20 +--
 pilot/pkg/xds/discovery.go                    |   5 +-
 pilot/pkg/xds/fake.go                         |   4 +-
 pilot/pkg/xds/simple.go                       |   2 +-
 tests/fuzz/v1alpha3_fuzzer.go                 |   5 -
 31 files changed, 303 insertions(+), 843 deletions(-)
 delete mode 100644 pilot/pkg/networking/plugin/registry/registry.go
 delete mode 100644 pilot/pkg/networking/plugin/registry/registry_test.go

diff --git a/pilot/cmd/pilot-discovery/app/cmd.go b/pilot/cmd/pilot-discovery/app/cmd.go
index 57e573f6ff..d1c8fde6ad 100644
--- a/pilot/cmd/pilot-discovery/app/cmd.go
+++ b/pilot/cmd/pilot-discovery/app/cmd.go
@@ -108,6 +108,8 @@ func newDiscoveryCommand() *cobra.Command {
 	}
 }
 
+var ignored []string
+
 func addFlags(c *cobra.Command) {
 	serverArgs = bootstrap.NewPilotArgs(func(p *bootstrap.PilotArgs) {
 		// Set Defaults
@@ -133,8 +135,9 @@ func addFlags(c *cobra.Command) {
 		"File name for Istio mesh networks configuration. If not specified, a default mesh networks will be used.")
 	c.PersistentFlags().StringVarP(&serverArgs.Namespace, "namespace", "n", bootstrap.PodNamespace,
 		"Select a namespace where the controller resides. If not set, uses ${POD_NAMESPACE} environment variable")
-	c.PersistentFlags().StringSliceVar(&serverArgs.Plugins, "plugins", bootstrap.DefaultPlugins,
+	c.PersistentFlags().StringSliceVar(&ignored, "plugins", nil,
 		"comma separated list of networking plugins to enable")
+	_ = c.PersistentFlags().MarkDeprecated("plugins", "no effect")
 	c.PersistentFlags().DurationVar(&serverArgs.ShutdownDuration, "shutdownDuration", 10*time.Second,
 		"Duration the discovery server needs to terminate gracefully")
 
diff --git a/pilot/pkg/bootstrap/options.go b/pilot/pkg/bootstrap/options.go
index 652dc60122..bee4ccd7c3 100644
--- a/pilot/pkg/bootstrap/options.go
+++ b/pilot/pkg/bootstrap/options.go
@@ -60,7 +60,6 @@ type PilotArgs struct {
 	NetworksConfigFile string
 	RegistryOptions    RegistryOptions
 	CtrlZOptions       *ctrlz.Options
-	Plugins            []string
 	KeepaliveOptions   *keepalive.Options
 	ShutdownDuration   time.Duration
 	JwtRule            string
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 8667685276..6fa87ca6f5 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -45,7 +45,6 @@
 	istiogrpc "istio.io/istio/pilot/pkg/grpc"
 	"istio.io/istio/pilot/pkg/keycertbundle"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/server"
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	kubecontroller "istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
@@ -79,14 +78,6 @@
 	"istio.io/pkg/version"
 )
 
-// DefaultPlugins is the default list of plugins to enable, when no plugin(s)
-// is specified through the command line
-var DefaultPlugins = []string{
-	plugin.AuthzCustom,
-	plugin.Authn,
-	plugin.Authz,
-}
-
 const (
 	// debounce file watcher events to minimize noise in logs
 	watchDebounceDelay = 100 * time.Millisecond
@@ -216,7 +207,7 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 	}
 	// Initialize workload Trust Bundle before XDS Server
 	e.TrustBundle = s.workloadTrustBundle
-	s.XDSServer = xds.NewDiscoveryServer(e, args.Plugins, args.PodName, args.Namespace, args.RegistryOptions.KubeOptions.ClusterAliases)
+	s.XDSServer = xds.NewDiscoveryServer(e, args.PodName, args.RegistryOptions.KubeOptions.ClusterAliases)
 
 	prometheus.EnableHandlingTimeHistogram()
 
diff --git a/pilot/pkg/bootstrap/server_test.go b/pilot/pkg/bootstrap/server_test.go
index 93941bc236..591131146a 100644
--- a/pilot/pkg/bootstrap/server_test.go
+++ b/pilot/pkg/bootstrap/server_test.go
@@ -133,8 +133,6 @@ func TestNewServerCertInit(t *testing.T) {
 					FileDir: configDir,
 				}
 
-				// Include all of the default plugins
-				p.Plugins = DefaultPlugins
 				p.ShutdownDuration = 1 * time.Millisecond
 			})
 			g := NewWithT(t)
@@ -300,8 +298,6 @@ func TestNewServer(t *testing.T) {
 					FileDir: configDir,
 				}
 
-				// Include all of the default plugins
-				p.Plugins = DefaultPlugins
 				p.ShutdownDuration = 1 * time.Millisecond
 
 				p.JwtRule = c.jwtRule
@@ -384,7 +380,6 @@ func TestIstiodCipherSuites(t *testing.T) {
 				}
 
 				// Include all of the default plugins
-				p.Plugins = DefaultPlugins
 				p.ShutdownDuration = 1 * time.Millisecond
 			})
 
diff --git a/pilot/pkg/networking/core/configgen.go b/pilot/pkg/networking/core/configgen.go
index 38f78a0dfa..d04235d920 100644
--- a/pilot/pkg/networking/core/configgen.go
+++ b/pilot/pkg/networking/core/configgen.go
@@ -22,7 +22,6 @@
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
-	"istio.io/istio/pilot/pkg/networking/plugin/registry"
 	dnsProto "istio.io/istio/pkg/dns/proto"
 )
 
@@ -56,6 +55,6 @@ type ConfigGenerator interface {
 }
 
 // NewConfigGenerator creates a new instance of the dataplane configuration generator
-func NewConfigGenerator(plugins []string, cache model.XdsCache) ConfigGenerator {
-	return v1alpha3.NewConfigGenerator(registry.NewPlugins(plugins), cache)
+func NewConfigGenerator(cache model.XdsCache) ConfigGenerator {
+	return v1alpha3.NewConfigGenerator(cache)
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster.go b/pilot/pkg/networking/core/v1alpha3/cluster.go
index dbe496735f..64d0de2a80 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster.go
@@ -487,7 +487,7 @@ func (configgen *ConfigGeneratorImpl) buildInboundClusters(cb *ClusterBuilder, p
 		// Find the service instance that corresponds to this ingress listener by looking
 		// for a service instance that matches this ingress port as this will allow us
 		// to generate the right cluster name that LDS expects inbound|portNumber|portName|Hostname
-		instance := configgen.findOrCreateServiceInstance(instances, ingressListener, sidecarScope.Name, sidecarScope.Namespace)
+		instance := findOrCreateServiceInstance(instances, ingressListener, sidecarScope.Name, sidecarScope.Namespace)
 		instance.Endpoint.Address = endpointAddress
 		instance.ServicePort = listenPort
 		instance.Endpoint.ServicePortName = listenPort.Name
@@ -500,7 +500,7 @@ func (configgen *ConfigGeneratorImpl) buildInboundClusters(cb *ClusterBuilder, p
 	return clusters
 }
 
-func (configgen *ConfigGeneratorImpl) findOrCreateServiceInstance(instances []*model.ServiceInstance,
+func findOrCreateServiceInstance(instances []*model.ServiceInstance,
 	ingressListener *networking.IstioIngressListener, sidecar string, sidecarns string) *model.ServiceInstance {
 	for _, realInstance := range instances {
 		if realInstance.Endpoint.EndpointPort == ingressListener.Port.Number {
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster_test.go b/pilot/pkg/networking/core/v1alpha3/cluster_test.go
index 9ee541d5aa..e0c25aeefa 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster_test.go
@@ -40,7 +40,6 @@
 	selectorpb "istio.io/api/type/v1beta1"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
 	"istio.io/istio/pilot/test/xdstest"
@@ -1261,8 +1260,7 @@ func TestFindServiceInstanceForIngressListener(t *testing.T) {
 			Protocol: "GRPC",
 		},
 	}
-	configgen := NewConfigGenerator([]plugin.Plugin{}, &model.DisabledCache{})
-	instance := configgen.findOrCreateServiceInstance(instances, ingress, "sidecar", "sidecarns")
+	instance := findOrCreateServiceInstance(instances, ingress, "sidecar", "sidecarns")
 	if instance == nil || instance.Service.Hostname.Matches("sidecar.sidecarns") {
 		t.Fatal("Expected to return a valid instance, but got nil/default instance")
 	}
diff --git a/pilot/pkg/networking/core/v1alpha3/configgen.go b/pilot/pkg/networking/core/v1alpha3/configgen.go
index e3f85280a9..1ce2dd0674 100644
--- a/pilot/pkg/networking/core/v1alpha3/configgen.go
+++ b/pilot/pkg/networking/core/v1alpha3/configgen.go
@@ -17,19 +17,15 @@
 import (
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 )
 
 type ConfigGeneratorImpl struct {
-	// List of plugins that modify code generated by this config generator
-	Plugins []plugin.Plugin
-	Cache   model.XdsCache
+	Cache model.XdsCache
 }
 
-func NewConfigGenerator(plugins []plugin.Plugin, cache model.XdsCache) *ConfigGeneratorImpl {
+func NewConfigGenerator(cache model.XdsCache) *ConfigGeneratorImpl {
 	return &ConfigGeneratorImpl{
-		Plugins: plugins,
-		Cache:   cache,
+		Cache: cache,
 	}
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
index 7faa9251a3..400847898f 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin.go
@@ -18,15 +18,12 @@
 	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	extensionsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3"
 	hcm_filter "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/anypb"
 	"google.golang.org/protobuf/types/known/durationpb"
 
 	extensions "istio.io/api/extensions/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking"
-	securitymodel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pkg/config/xds"
 	"istio.io/istio/pkg/util/sets"
 
@@ -45,84 +42,15 @@
 	InitialFetchTimeout: &durationpb.Duration{Seconds: 0},
 }
 
-// AddWasmPluginsToMutableObjects adds WasmPlugins to HTTP filterChains
-// Note that the slices in the map must already be ordered by plugin
-// priority! This will be the case for maps returned by PushContext.WasmPlugin()
-func AddWasmPluginsToMutableObjects(
-	mutable *networking.MutableObjects,
-	extensionsMap map[extensions.PluginPhase][]*model.WasmPluginWrapper,
-) {
-	if mutable == nil {
-		return
-	}
-
-	for fcIndex, fc := range mutable.FilterChains {
-		// we currently only support HTTP
-		if fc.ListenerProtocol != networking.ListenerProtocolHTTP {
-			continue
-		}
-		mutable.FilterChains[fcIndex].HTTP = injectExtensions(fc.HTTP, extensionsMap)
-	}
-}
-
-func injectExtensions(filterChain []*hcm_filter.HttpFilter, exts map[extensions.PluginPhase][]*model.WasmPluginWrapper) []*hcm_filter.HttpFilter {
-	// copy map as we'll manipulate it in the loop
-	extMap := make(map[extensions.PluginPhase][]*model.WasmPluginWrapper)
-	for phase, list := range exts {
-		extMap[phase] = []*model.WasmPluginWrapper{}
-		extMap[phase] = append(extMap[phase], list...)
-	}
-	newHTTPFilters := make([]*hcm_filter.HttpFilter, 0)
-	// The following algorithm tries to make as few assumptions as possible about the filter
-	// chain - it might contain any number of filters that will have to retain their ordering.
-	// The one assumption we make is about the ordering of the builtin filters. This is used to
-	// position WasmPlugins relatively to the builtin filters according to their phase: when
-	// we see the Stats filter, we know that all WasmPlugins with phases AUTHN, AUTHZ and STATS
-	// must be injected before it. This method allows us to inject WasmPlugins in the right spots
-	// while retaining any filters that were unknown at the time of writing this algorithm,
-	// in linear time. The assumed ordering of builtin filters is:
-	//
-	// 1. Istio JWT, 2. Istio AuthN, 3. RBAC, 4. Stats, 5. Metadata Exchange
-	//
-	// TODO: how to deal with ext-authz? RBAC will be in the chain twice in that case
-	for _, httpFilter := range filterChain {
-		switch httpFilter.Name {
-		case securitymodel.EnvoyJwtFilterName:
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHN)
-			newHTTPFilters = append(newHTTPFilters, httpFilter)
-		case securitymodel.AuthnFilterName:
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHN)
-			newHTTPFilters = append(newHTTPFilters, httpFilter)
-		case wellknown.HTTPRoleBasedAccessControl:
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHN)
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHZ)
-			newHTTPFilters = append(newHTTPFilters, httpFilter)
-		case xds.StatsFilterName:
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHN)
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHZ)
-			newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_STATS)
-			newHTTPFilters = append(newHTTPFilters, httpFilter)
-		default:
-			newHTTPFilters = append(newHTTPFilters, httpFilter)
-		}
-	}
-	// append all remaining extensions at the end. This is required because not all builtin filters
-	// are always present (e.g. RBAC is only present when an AuthorizationPolicy was created), so
-	// we might not have emptied all slices in the map.
-	newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHN)
-	newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_AUTHZ)
-	newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_STATS)
-	newHTTPFilters = popAppend(newHTTPFilters, extMap, extensions.PluginPhase_UNSPECIFIED_PHASE)
-	return newHTTPFilters
-}
-
-func popAppend(list []*hcm_filter.HttpFilter,
+// PopAppend takes a list of filters and a set of WASM plugins, keyed by phase. It will remove all
+// plugins of a provided phase from the WASM plugin set and append them to the list of filters
+func PopAppend(list []*hcm_filter.HttpFilter,
 	filterMap map[extensions.PluginPhase][]*model.WasmPluginWrapper,
 	phase extensions.PluginPhase) []*hcm_filter.HttpFilter {
 	for _, ext := range filterMap[phase] {
 		list = append(list, toEnvoyHTTPFilter(ext))
 	}
-	filterMap[phase] = []*model.WasmPluginWrapper{}
+	delete(filterMap, phase)
 	return list
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
index 72b7737558..3815328eaf 100644
--- a/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/extension/wasmplugin_test.go
@@ -19,8 +19,6 @@
 
 	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	extensionsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3"
-	http_conn "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"github.com/golang/protobuf/ptypes/wrappers"
 	"github.com/google/go-cmp/cmp"
 	"google.golang.org/protobuf/testing/protocmp"
@@ -28,26 +26,9 @@
 
 	extensions "istio.io/api/extensions/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking"
-	securitymodel "istio.io/istio/pilot/pkg/security/model"
 )
 
 var (
-	istioJWT = &http_conn.HttpFilter{
-		Name: securitymodel.EnvoyJwtFilterName,
-	}
-	istioAuthN = &http_conn.HttpFilter{
-		Name: securitymodel.AuthnFilterName,
-	}
-	istioAuthZ = &http_conn.HttpFilter{
-		Name: wellknown.HTTPRoleBasedAccessControl,
-	}
-	istioStats = &http_conn.HttpFilter{
-		Name: "istio.stats",
-	}
-	unknown = &http_conn.HttpFilter{
-		Name: "unknown.filter",
-	}
 	someAuthNFilter = &model.WasmPluginWrapper{
 		Name:         "someAuthNFilter",
 		Namespace:    "istio-system",
@@ -56,14 +37,6 @@
 			Priority: &wrappers.Int64Value{Value: 1},
 		},
 	}
-	someImportantAuthNFilter = &model.WasmPluginWrapper{
-		Name:         "someImportantAuthNFilter",
-		Namespace:    "istio-system",
-		ResourceName: "istio-system.someImportantAuthNFilter",
-		WasmPlugin: &extensions.WasmPlugin{
-			Priority: &wrappers.Int64Value{Value: 1000},
-		},
-	}
 	someAuthZFilter = &model.WasmPluginWrapper{
 		Name:         "someAuthZFilter",
 		Namespace:    "istio-system",
@@ -74,120 +47,6 @@
 	}
 )
 
-func TestAddWasmPluginsToMutableObjects(t *testing.T) {
-	testCases := []struct {
-		name           string
-		filterChains   []networking.FilterChain
-		extensions     map[extensions.PluginPhase][]*model.WasmPluginWrapper
-		expectedResult []networking.FilterChain
-	}{
-		{
-			name:           "empty",
-			filterChains:   []networking.FilterChain{},
-			extensions:     map[extensions.PluginPhase][]*model.WasmPluginWrapper{},
-			expectedResult: []networking.FilterChain{},
-		},
-		{
-			name: "ignore tcp",
-			filterChains: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolTCP,
-				},
-			},
-			extensions: map[extensions.PluginPhase][]*model.WasmPluginWrapper{
-				extensions.PluginPhase_AUTHN: {
-					someImportantAuthNFilter,
-					someAuthNFilter,
-				},
-			},
-			expectedResult: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolTCP,
-				},
-			},
-		},
-		{
-			name: "authN",
-			filterChains: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolHTTP,
-					HTTP: []*http_conn.HttpFilter{
-						istioJWT,
-						istioAuthN,
-						istioStats,
-					},
-				},
-			},
-			extensions: map[extensions.PluginPhase][]*model.WasmPluginWrapper{
-				extensions.PluginPhase_AUTHN: {
-					someImportantAuthNFilter,
-					someAuthNFilter,
-				},
-			},
-			expectedResult: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolHTTP,
-					HTTP: []*http_conn.HttpFilter{
-						toEnvoyHTTPFilter(someImportantAuthNFilter),
-						toEnvoyHTTPFilter(someAuthNFilter),
-						istioJWT,
-						istioAuthN,
-						istioStats,
-					},
-				},
-			},
-		},
-		{
-			name: "authZ",
-			filterChains: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolHTTP,
-					HTTP: []*http_conn.HttpFilter{
-						istioAuthN,
-						unknown,
-						istioAuthZ,
-						istioStats,
-					},
-				},
-			},
-			extensions: map[extensions.PluginPhase][]*model.WasmPluginWrapper{
-				extensions.PluginPhase_AUTHN: {
-					someImportantAuthNFilter,
-					someAuthNFilter,
-				},
-				extensions.PluginPhase_AUTHZ: {
-					someAuthZFilter,
-				},
-			},
-			expectedResult: []networking.FilterChain{
-				{
-					ListenerProtocol: networking.ListenerProtocolHTTP,
-					HTTP: []*http_conn.HttpFilter{
-						toEnvoyHTTPFilter(someImportantAuthNFilter),
-						toEnvoyHTTPFilter(someAuthNFilter),
-						istioAuthN,
-						unknown,
-						toEnvoyHTTPFilter(someAuthZFilter),
-						istioAuthZ,
-						istioStats,
-					},
-				},
-			},
-		},
-	}
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			mut := &networking.MutableObjects{
-				FilterChains: tc.filterChains,
-			}
-			AddWasmPluginsToMutableObjects(mut, tc.extensions)
-			if diff := cmp.Diff(tc.expectedResult, mut.FilterChains, protocmp.Transform()); diff != "" {
-				t.Fatal(diff)
-			}
-		})
-	}
-}
-
 func TestInsertedExtensionConfigurations(t *testing.T) {
 	wasm, _ := anypb.New(&extensionsv3.Wasm{})
 	testCases := []struct {
diff --git a/pilot/pkg/networking/core/v1alpha3/fake.go b/pilot/pkg/networking/core/v1alpha3/fake.go
index 6d4c078b39..f2a853a01e 100644
--- a/pilot/pkg/networking/core/v1alpha3/fake.go
+++ b/pilot/pkg/networking/core/v1alpha3/fake.go
@@ -33,8 +33,6 @@
 	"istio.io/istio/pilot/pkg/config/kube/crd"
 	"istio.io/istio/pilot/pkg/config/memory"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/plugin"
-	"istio.io/istio/pilot/pkg/networking/plugin/registry"
 	"istio.io/istio/pilot/pkg/serviceregistry"
 	"istio.io/istio/pilot/pkg/serviceregistry/aggregate"
 	memregistry "istio.io/istio/pilot/pkg/serviceregistry/memory"
@@ -77,9 +75,6 @@ type TestOptions struct {
 	// CreateConfigStore defines a function that, given a ConfigStoreController, returns another ConfigStoreController to use
 	CreateConfigStore func(c model.ConfigStoreController) model.ConfigStoreController
 
-	// ConfigGen plugins to use. If not set, all default plugins will be used
-	Plugins []plugin.Plugin
-
 	// Mutex used for push context access. Should generally only be used by NewFakeDiscoveryServer
 	PushContextLock *sync.RWMutex
 
@@ -158,17 +153,13 @@ func NewConfigGenTest(t test.Failer, opts TestOptions) *ConfigGenTest {
 	env.NetworksWatcher = opts.NetworksWatcher
 	env.Init()
 
-	if opts.Plugins == nil {
-		opts.Plugins = registry.NewPlugins([]string{plugin.AuthzCustom, plugin.Authn, plugin.Authz})
-	}
-
 	fake := &ConfigGenTest{
 		t:                    t,
 		store:                configController,
 		env:                  env,
 		initialConfigs:       configs,
 		stop:                 stop,
-		ConfigGen:            NewConfigGenerator(opts.Plugins, &model.DisabledCache{}),
+		ConfigGen:            NewConfigGenerator(&model.DisabledCache{}),
 		MemRegistry:          msd,
 		Registry:             serviceDiscovery,
 		ServiceEntryRegistry: se,
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway.go b/pilot/pkg/networking/core/v1alpha3/gateway.go
index 73683421ed..183e93531a 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway.go
@@ -35,9 +35,7 @@
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/gateway"
@@ -144,16 +142,12 @@ func (configgen *ConfigGeneratorImpl) buildGatewayListeners(builder *ListenerBui
 				mutable = mopts.mutable
 			}
 
-			pluginParams := &plugin.InputParams{
-				Node: builder.node,
-				Push: builder.push,
-			}
-			for _, p := range configgen.Plugins {
-				if err := p.OnOutboundListener(pluginParams, &mutable.MutableObjects); err != nil {
-					log.Warn("generateListenerAndFilterChains: failed to build listener for gateway: ", err.Error())
+			for cnum := range mutable.FilterChains {
+				if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
+					mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, builder.authzCustomBuilder.BuildTCP()...)
+					mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, builder.authzBuilder.BuildTCP()...)
 				}
 			}
-			extension.AddWasmPluginsToMutableObjects(&mutable.MutableObjects, builder.push.WasmPlugins(builder.node))
 		}
 	}
 	listeners := make([]*listener.Listener, 0)
@@ -163,7 +157,7 @@ func (configgen *ConfigGeneratorImpl) buildGatewayListeners(builder *ListenerBui
 			ml.mutable.Listener.GetName(), len(ml.mutable.Listener.GetFilterChains()))
 
 		// Filters are serialized one time into an opaque struct once we have the complete list.
-		if err := ml.mutable.build(*ml.opts); err != nil {
+		if err := ml.mutable.build(builder, *ml.opts); err != nil {
 			errs = multierror.Append(errs, fmt.Errorf("gateway omitting listener %q due to: %v", ml.mutable.Listener.Name, err.Error()))
 			continue
 		}
@@ -587,7 +581,7 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 		// and that no two non-HTTPS servers can be on same port or share port names.
 		// Validation is done per gateway and also during merging
 		sniHosts:   node.MergedGateway.TLSServerInfo[server].SNIHosts,
-		tlsContext: buildGatewayListenerTLSContext(server, node, transportProtocol, configgen),
+		tlsContext: buildGatewayListenerTLSContext(server, node, transportProtocol),
 		httpOpts: &httpListenerOpts{
 			rds:               routeName,
 			useRemoteAddress:  true,
@@ -654,14 +648,14 @@ func buildGatewayConnectionManager(proxyConfig *meshconfig.ProxyConfig, node *mo
 //
 // Note that ISTIO_MUTUAL TLS mode and ingressSds should not be used simultaneously on the same ingress gateway.
 func buildGatewayListenerTLSContext(
-	server *networking.Server, proxy *model.Proxy, transportProtocol istionetworking.TransportProtocol, configgen *ConfigGeneratorImpl) *tls.DownstreamTlsContext {
+	server *networking.Server, proxy *model.Proxy, transportProtocol istionetworking.TransportProtocol) *tls.DownstreamTlsContext {
 	// Server.TLS cannot be nil or passthrough. But as a safety guard, return nil
 	if server.Tls == nil || gateway.IsPassThroughServer(server) {
 		return nil // We don't need to setup TLS context for passthrough mode
 	}
 
 	server.Tls.CipherSuites = filteredGatewayCipherSuites(server)
-	return configgen.BuildListenerTLSContext(server.Tls, proxy, transportProtocol)
+	return BuildListenerTLSContext(server.Tls, proxy, transportProtocol)
 }
 
 func convertTLSProtocol(in networking.ServerTLSSettings_TLSProtocol) tls.TlsParameters_TlsProtocol {
@@ -700,7 +694,7 @@ func (configgen *ConfigGeneratorImpl) createGatewayTCPFilterChainOpts(
 			return []*filterChainOpts{
 				{
 					sniHosts:       node.MergedGateway.TLSServerInfo[server].SNIHosts,
-					tlsContext:     buildGatewayListenerTLSContext(server, node, istionetworking.TransportProtocolTCP, configgen),
+					tlsContext:     buildGatewayListenerTLSContext(server, node, istionetworking.TransportProtocolTCP),
 					networkFilters: filters,
 				},
 			}
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway_test.go b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
index 21223e7bac..225ac4be09 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
@@ -34,7 +34,6 @@
 	"istio.io/istio/pilot/pkg/features"
 	pilot_model "istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pilot/test/xdstest"
@@ -636,10 +635,9 @@ func TestBuildGatewayListenerTlsContext(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			cgi := NewConfigGenerator([]plugin.Plugin{}, &pilot_model.DisabledCache{})
 			ret := buildGatewayListenerTLSContext(tc.server, &pilot_model.Proxy{
 				Metadata: &pilot_model.NodeMetadata{},
-			}, tc.transportProtocol, cgi)
+			}, tc.transportProtocol)
 			if diff := cmp.Diff(tc.result, ret, protocmp.Transform()); diff != "" {
 				t.Errorf("got diff: %v", diff)
 			}
@@ -1274,7 +1272,7 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			cgi := NewConfigGenerator([]plugin.Plugin{}, &pilot_model.DisabledCache{})
+			cgi := NewConfigGenerator(&pilot_model.DisabledCache{})
 			tc.node.MergedGateway = &pilot_model.MergedGateway{TLSServerInfo: map[*networking.Server]*pilot_model.TLSServerInfo{
 				tc.server: {SNIHosts: pilot_model.GetSNIHostsForServer(tc.server)},
 			}}
@@ -2141,7 +2139,7 @@ func TestBuildGatewayListeners(t *testing.T) {
 				proxy.Metadata = &proxyGatewayMetadata
 			}
 
-			builder := cg.ConfigGen.buildGatewayListeners(&ListenerBuilder{node: proxy, push: cg.PushContext()})
+			builder := cg.ConfigGen.buildGatewayListeners(NewListenerBuilder(proxy, cg.PushContext()))
 			listeners := xdstest.ExtractListenerNames(builder.gatewayListeners)
 			sort.Strings(listeners)
 			sort.Strings(tt.expectedListeners)
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index bb0b7b9ec9..a6cdb3ff7e 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -100,7 +100,7 @@ func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 
 // buildSidecarInboundHTTPRouteConfig builds the route config with a single wildcard virtual host on the inbound path
 // TODO: trace decorators, inbound timeouts
-func (configgen *ConfigGeneratorImpl) buildSidecarInboundHTTPRouteConfig(
+func buildSidecarInboundHTTPRouteConfig(
 	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string,
 ) *route.RouteConfiguration {
 	traceOperation := util.TraceOperation(string(instance.Service.Hostname), instance.ServicePort.Port)
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index b1b93705dd..84f4545fea 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -33,11 +33,13 @@
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
+	extensions "istio.io/api/extensions/v1alpha1"
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
+	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
 	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	authn_model "istio.io/istio/pilot/pkg/security/model"
@@ -127,7 +129,7 @@ func (configgen *ConfigGeneratorImpl) BuildListeners(node *model.Proxy,
 	return builder.getListeners()
 }
 
-func (configgen *ConfigGeneratorImpl) BuildListenerTLSContext(serverTLSSettings *networking.ServerTLSSettings,
+func BuildListenerTLSContext(serverTLSSettings *networking.ServerTLSSettings,
 	proxy *model.Proxy, transportProtocol istionetworking.TransportProtocol) *auth.DownstreamTlsContext {
 	alpnByTransport := util.ALPNHttp
 	if transportProtocol == istionetworking.TransportProtocolQUIC {
@@ -227,18 +229,18 @@ func filteredSidecarCipherSuites(suites []string) []string {
 func (configgen *ConfigGeneratorImpl) buildSidecarListeners(builder *ListenerBuilder) *ListenerBuilder {
 	if builder.push.Mesh.ProxyListenPort > 0 {
 		// Any build order change need a careful code review
-		builder.buildSidecarInboundListeners(configgen).
-			buildSidecarOutboundListeners(configgen).
-			buildHTTPProxyListener(configgen).
-			buildVirtualOutboundListener(configgen).
-			buildVirtualInboundListener(configgen)
+		builder.appendSidecarInboundListeners().
+			appendSidecarOutboundListeners().
+			buildHTTPProxyListener().
+			buildVirtualOutboundListener().
+			buildVirtualInboundListener()
 	}
 	return builder
 }
 
 // buildSidecarInboundListeners creates listeners for the server-side (inbound)
 // configuration for co-located service proxyInstances.
-func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
+func (lb *ListenerBuilder) buildSidecarInboundListeners(
 	node *model.Proxy,
 	push *model.PushContext) []*listener.Listener {
 	var listeners []*listener.Listener
@@ -307,7 +309,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
 				Push:            push,
 			}
 
-			if l := configgen.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
+			if l := lb.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
 				listeners = append(listeners, l)
 			}
 		}
@@ -349,7 +351,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
 			bind = getSidecarInboundBindIP(node)
 		}
 
-		instance := configgen.findOrCreateServiceInstance(node.ServiceInstances, ingressListener,
+		instance := findOrCreateServiceInstance(node.ServiceInstances, ingressListener,
 			sidecarScope.Name, sidecarScope.Namespace)
 
 		listenerOpts := buildListenerOpts{
@@ -385,7 +387,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
 			}
 		}
 
-		if l := configgen.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
+		if l := lb.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
 			listeners = append(listeners, l)
 		}
 	}
@@ -393,10 +395,10 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
 	return listeners
 }
 
-func (configgen *ConfigGeneratorImpl) buildSidecarInboundHTTPListenerOptsForPortOrUDS(node *model.Proxy,
+func buildSidecarInboundHTTPListenerOptsForPortOrUDS(node *model.Proxy,
 	pluginParams *plugin.InputParams, clusterName string) *httpListenerOpts {
 	httpOpts := &httpListenerOpts{
-		routeConfig: configgen.buildSidecarInboundHTTPRouteConfig(pluginParams.Node,
+		routeConfig: buildSidecarInboundHTTPRouteConfig(pluginParams.Node,
 			pluginParams.Push, pluginParams.ServiceInstance, clusterName),
 		rds:              "", // no RDS for inbound traffic
 		useRemoteAddress: false,
@@ -435,7 +437,7 @@ func enableHTTP10(enableFlag string) bool {
 
 // buildSidecarInboundListenerForPortOrUDS creates a single listener on the server-side (inbound)
 // for a given port or unix domain socket
-func (configgen *ConfigGeneratorImpl) buildSidecarInboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
+func (lb *ListenerBuilder) buildSidecarInboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
 	pluginParams *plugin.InputParams, listenerMap map[int]*inboundListenerEntry) *listener.Listener {
 	// Local service instances can be accessed through one of four addresses:
 	// unix domain socket, localhost, endpoint IP, and service VIP
@@ -468,7 +470,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListenerForPortOrUDS(li
 	}
 	// Setup filter chain options and call plugins
 	clusterName := model.BuildInboundSubsetKey(int(pluginParams.ServiceInstance.Endpoint.EndpointPort))
-	fcOpts := configgen.buildInboundFilterchains(pluginParams, listenerOpts, "", clusterName, false)
+	fcOpts := lb.buildInboundFilterchains(pluginParams, listenerOpts, "", clusterName, false)
 	listenerOpts.filterChainOpts = fcOpts
 
 	// Buildup the complete listener
@@ -485,8 +487,14 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListenerForPortOrUDS(li
 		},
 	}
 
+	for cnum := range mutable.FilterChains {
+		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
+		}
+	}
 	// Filters are serialized one time into an opaque struct once we have the complete list.
-	if err := mutable.build(listenerOpts); err != nil {
+	if err := mutable.build(lb, listenerOpts); err != nil {
 		log.Warn("buildSidecarInboundListeners ", err.Error())
 		return nil
 	}
@@ -554,7 +562,7 @@ func (c outboundListenerConflict) addMetric(metrics model.Metrics) {
 
 // buildSidecarOutboundListeners generates http and tcp listeners for
 // outbound connections from the proxy based on the sidecar scope associated with the proxy.
-func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.Proxy,
+func (lb *ListenerBuilder) buildSidecarOutboundListeners(node *model.Proxy,
 	push *model.PushContext) []*listener.Listener {
 	noneMode := node.GetInterceptionMode() == model.InterceptionNone
 
@@ -661,7 +669,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 			for _, service := range services {
 				listenerOpts.service = service
 				// Set service specific attributes here.
-				configgen.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
+				lb.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
 			}
 		} else {
 			// This is a catch all egress listener with no port. This
@@ -737,7 +745,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 							// selected or scaled down, so we skip these as well. This leaves us with
 							// only a plain ServiceEntry with resolution NONE. In this case, we will
 							// fallback to a wildcard listener.
-							configgen.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
+							lb.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
 							continue
 						}
 						for _, instance := range instances {
@@ -754,11 +762,11 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 								continue
 							}
 							listenerOpts.bind = instance.Endpoint.Address
-							configgen.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
+							lb.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
 						}
 					} else {
 						// Standard logic for headless and non headless services
-						configgen.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
+						lb.buildSidecarOutboundListenerForPortOrUDS(listenerOpts, listenerMap, virtualServices, actualWildcard)
 					}
 				}
 			}
@@ -778,13 +786,13 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 	tcpListeners = append(tcpListeners, httpListeners...)
 	// Build pass through filter chains now that all the non-passthrough filter chains are ready.
 	for _, listener := range tcpListeners {
-		configgen.appendListenerFallthroughRouteForCompleteListener(listener, node, push)
+		appendListenerFallthroughRouteForCompleteListener(listener, node, push)
 	}
 	removeListenerFilterTimeout(tcpListeners)
 	return tcpListeners
 }
 
-func (configgen *ConfigGeneratorImpl) buildHTTPProxy(node *model.Proxy,
+func (lb *ListenerBuilder) buildHTTPProxy(node *model.Proxy,
 	push *model.PushContext) *listener.Listener {
 	httpProxyPort := push.Mesh.ProxyHttpPort // global
 	if node.Metadata.HTTPProxyPort != "" {
@@ -833,14 +841,20 @@ func (configgen *ConfigGeneratorImpl) buildHTTPProxy(node *model.Proxy,
 			FilterChains: []istionetworking.FilterChain{{}},
 		},
 	}
-	if err := mutable.build(opts); err != nil {
+	for cnum := range mutable.FilterChains {
+		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
+		}
+	}
+	if err := mutable.build(lb, opts); err != nil {
 		log.Warn("buildHTTPProxy filter chain error  ", err.Error())
 		return nil
 	}
 	return l
 }
 
-func (configgen *ConfigGeneratorImpl) buildSidecarOutboundHTTPListenerOptsForPortOrUDS(listenerMapKey *string,
+func buildSidecarOutboundHTTPListenerOptsForPortOrUDS(listenerMapKey *string,
 	currentListenerEntry **outboundListenerEntry, listenerOpts *buildListenerOpts,
 	listenerMap map[string]*outboundListenerEntry, actualWildcard string) (bool, []*filterChainOpts) {
 	// first identify the bind if its not set. Then construct the key
@@ -936,7 +950,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundHTTPListenerOptsForPor
 	}}
 }
 
-func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPortOrUDS(listenerMapKey *string,
+func buildSidecarOutboundTCPListenerOptsForPortOrUDS(listenerMapKey *string,
 	currentListenerEntry **outboundListenerEntry, listenerOpts *buildListenerOpts, listenerMap map[string]*outboundListenerEntry,
 	virtualServices []config.Config, actualWildcard string) (bool, []*filterChainOpts) {
 	// first identify the bind if its not set. Then construct the key
@@ -1046,7 +1060,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundTCPListenerOptsForPort
 // if one doesn't already exist. HTTP listeners on same port are ignored
 // (as vhosts are shipped through RDS).  TCP listeners on same port are
 // allowed only if they have different CIDR matches.
-func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
+func (lb *ListenerBuilder) buildSidecarOutboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
 	listenerMap map[string]*outboundListenerEntry, virtualServices []config.Config, actualWildcard string) {
 	var listenerMapKey string
 	var currentListenerEntry *outboundListenerEntry
@@ -1063,7 +1077,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 
 	// For HTTP_PROXY protocol defined by sidecars, just create the HTTP listener right away.
 	if listenerPortProtocol == protocol.HTTP_PROXY {
-		if ret, opts = configgen.buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
+		if ret, opts = buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 			&listenerOpts, listenerMap, actualWildcard); !ret {
 			return
 		}
@@ -1071,7 +1085,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 	} else {
 		switch listenerProtocol {
 		case istionetworking.ListenerProtocolHTTP:
-			if ret, opts = configgen.buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey,
+			if ret, opts = buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey,
 				&currentListenerEntry, &listenerOpts, listenerMap, actualWildcard); !ret {
 				return
 			}
@@ -1121,7 +1135,7 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 			listenerOpts.filterChainOpts = opts
 
 		case istionetworking.ListenerProtocolTCP:
-			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
+			if ret, opts = buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 				&listenerOpts, listenerMap, virtualServices, actualWildcard); !ret {
 				return
 			}
@@ -1143,14 +1157,14 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 
 		case istionetworking.ListenerProtocolAuto:
 			// Add tcp filter chain, build TCP filter chain first.
-			if ret, opts = configgen.buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
+			if ret, opts = buildSidecarOutboundTCPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 				&listenerOpts, listenerMap, virtualServices, actualWildcard); !ret {
 				return
 			}
 			listenerOpts.filterChainOpts = append(listenerOpts.filterChainOpts, opts...)
 
 			// Add http filter chain and tcp filter chain to the listener opts
-			if ret, opts = configgen.buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
+			if ret, opts = buildSidecarOutboundHTTPListenerOptsForPortOrUDS(&listenerMapKey, &currentListenerEntry,
 				&listenerOpts, listenerMap, actualWildcard); !ret {
 				return
 			}
@@ -1199,19 +1213,15 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListenerForPortOrUDS(l
 		},
 	}
 
-	pluginParams := &plugin.InputParams{
-		Node: listenerOpts.proxy,
-		Push: listenerOpts.push,
-	}
-
-	for _, p := range configgen.Plugins {
-		if err := p.OnOutboundListener(pluginParams, &mutable.MutableObjects); err != nil {
-			log.Warn(err.Error())
+	for cnum := range mutable.FilterChains {
+		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
+			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
 		}
 	}
 
 	// Filters are serialized one time into an opaque struct once we have the complete list.
-	if err := mutable.build(listenerOpts); err != nil {
+	if err := mutable.build(lb, listenerOpts); err != nil {
 		log.Warn("buildSidecarOutboundListeners: ", err.Error())
 		return
 	}
@@ -1369,8 +1379,7 @@ type buildListenerOpts struct {
 	tlsSettings       *networking.ServerTLSSettings
 }
 
-func buildHTTPConnectionManager(listenerOpts buildListenerOpts, httpOpts *httpListenerOpts,
-	httpFilters []*hcm.HttpFilter) *hcm.HttpConnectionManager {
+func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListenerOpts, httpOpts *httpListenerOpts) *hcm.HttpConnectionManager {
 	if httpOpts.connectionManager == nil {
 		httpOpts.connectionManager = &hcm.HttpConnectionManager{}
 	}
@@ -1443,8 +1452,18 @@ func buildHTTPConnectionManager(listenerOpts buildListenerOpts, httpOpts *httpLi
 
 	routerFilterCtx, reqIDExtensionCtx := configureTracing(listenerOpts, connectionManager)
 
-	filters := make([]*hcm.HttpFilter, len(httpFilters))
-	copy(filters, httpFilters)
+	filters := []*hcm.HttpFilter{}
+	wasm := lb.push.WasmPlugins(lb.node)
+	// TODO: how to deal with ext-authz? It will be in the ordering twice
+	filters = append(filters, lb.authzCustomBuilder.BuildHTTP(listenerOpts.class)...)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHN)
+	filters = append(filters, lb.authnBuilder.BuildHTTP(listenerOpts.class)...)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHZ)
+	filters = append(filters, lb.authzBuilder.BuildHTTP(listenerOpts.class)...)
+
+	// TODO: these feel like the wrong place to insert, but this retains backwards compatibility with the original implementation
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_STATS)
+	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_UNSPECIFIED_PHASE)
 
 	if features.MetadataExchange {
 		filters = append(filters, xdsfilters.HTTPMx)
@@ -1653,7 +1672,7 @@ func getMatchAllFilterChain(l *listener.Listener) (int, *listener.FilterChain) {
 // Create pass through filter chain for the listener assuming all the other filter chains are ready.
 // The match member of pass through filter chain depends on the existing non-passthrough filter chain.
 // TODO(lambdai): Calculate the filter chain match to replace the wildcard and replace appendListenerFallthroughRoute.
-func (configgen *ConfigGeneratorImpl) appendListenerFallthroughRouteForCompleteListener(l *listener.Listener, node *model.Proxy, push *model.PushContext) {
+func appendListenerFallthroughRouteForCompleteListener(l *listener.Listener, node *model.Proxy, push *model.PushContext) {
 	matchIndex, matchAll := getMatchAllFilterChain(l)
 
 	fallthroughNetworkFilters := buildOutboundCatchAllNetworkFiltersOnly(push, node)
@@ -1684,7 +1703,7 @@ func (configgen *ConfigGeneratorImpl) appendListenerFallthroughRouteForCompleteL
 // TODO: given how tightly tied listener.FilterChains, opts.filterChainOpts, and mutable.FilterChains
 // are to each other we should encapsulate them some way to ensure they remain consistent (mainly that
 // in each an index refers to the same chain).
-func (ml *MutableListener) build(opts buildListenerOpts) error {
+func (ml *MutableListener) build(builder *ListenerBuilder, opts buildListenerOpts) error {
 	if len(opts.filterChainOpts) == 0 {
 		return fmt.Errorf("must have more than 0 chains in listener %q", ml.Listener.Name)
 	}
@@ -1727,7 +1746,7 @@ func (ml *MutableListener) build(opts buildListenerOpts) error {
 			if len(opt.httpOpts.statPrefix) == 0 {
 				opt.httpOpts.statPrefix = strings.ToLower(ml.Listener.TrafficDirection.String()) + "_" + ml.Listener.Name
 			}
-			httpConnectionManagers[i] = buildHTTPConnectionManager(opts, opt.httpOpts, chain.HTTP)
+			httpConnectionManagers[i] = builder.buildHTTPConnectionManager(opts, opt.httpOpts)
 			filter := &listener.Filter{
 				Name:       wellknown.HTTPConnectionManager,
 				ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(httpConnectionManagers[i])},
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index a1ebf8fe41..5f18f10844 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -32,9 +32,10 @@
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/envoyfilter"
-	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
 	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pilot/pkg/networking/plugin/authn"
+	"istio.io/istio/pilot/pkg/networking/plugin/authz"
 	"istio.io/istio/pilot/pkg/networking/util"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pkg/config/protocol"
@@ -66,6 +67,13 @@ type ListenerBuilder struct {
 	virtualInboundListener  *listener.Listener
 
 	envoyFilterWrapper *model.EnvoyFilterWrapper
+
+	// authnBuilder provides access to authn (mTLS) configuration for the given proxy.
+	authnBuilder *authn.Builder
+	// authzBuilder provides access to authz configuration for the given proxy.
+	authzBuilder *authz.Builder
+	// authzCustomBuilder provides access to CUSTOM authz configuration for the given proxy.
+	authzCustomBuilder *authz.Builder
 }
 
 // Setup the filter chain match so that the match should work under both
@@ -326,21 +334,24 @@ func NewListenerBuilder(node *model.Proxy, push *model.PushContext) *ListenerBui
 		node: node,
 		push: push,
 	}
+	builder.authnBuilder = authn.NewBuilder(push, node)
+	builder.authzBuilder = authz.NewBuilder(authz.Local, push, node)
+	builder.authzCustomBuilder = authz.NewBuilder(authz.Custom, push, node)
 	return builder
 }
 
-func (lb *ListenerBuilder) buildSidecarInboundListeners(configgen *ConfigGeneratorImpl) *ListenerBuilder {
-	lb.inboundListeners = configgen.buildSidecarInboundListeners(lb.node, lb.push)
+func (lb *ListenerBuilder) appendSidecarInboundListeners() *ListenerBuilder {
+	lb.inboundListeners = lb.buildSidecarInboundListeners(lb.node, lb.push)
 	return lb
 }
 
-func (lb *ListenerBuilder) buildSidecarOutboundListeners(configgen *ConfigGeneratorImpl) *ListenerBuilder {
-	lb.outboundListeners = configgen.buildSidecarOutboundListeners(lb.node, lb.push)
+func (lb *ListenerBuilder) appendSidecarOutboundListeners() *ListenerBuilder {
+	lb.outboundListeners = lb.buildSidecarOutboundListeners(lb.node, lb.push)
 	return lb
 }
 
-func (lb *ListenerBuilder) buildHTTPProxyListener(configgen *ConfigGeneratorImpl) *ListenerBuilder {
-	httpProxy := configgen.buildHTTPProxy(lb.node, lb.push)
+func (lb *ListenerBuilder) buildHTTPProxyListener() *ListenerBuilder {
+	httpProxy := lb.buildHTTPProxy(lb.node, lb.push)
 	if httpProxy == nil {
 		return lb
 	}
@@ -350,7 +361,7 @@ func (lb *ListenerBuilder) buildHTTPProxyListener(configgen *ConfigGeneratorImpl
 	return lb
 }
 
-func (lb *ListenerBuilder) buildVirtualOutboundListener(configgen *ConfigGeneratorImpl) *ListenerBuilder {
+func (lb *ListenerBuilder) buildVirtualOutboundListener() *ListenerBuilder {
 	if lb.node.GetInterceptionMode() == model.InterceptionNone {
 		// virtual listener is not necessary since workload is not using IPtables for traffic interception
 		return lb
@@ -361,7 +372,7 @@ func (lb *ListenerBuilder) buildVirtualOutboundListener(configgen *ConfigGenerat
 		isTransparentProxy = proto.BoolTrue
 	}
 
-	filterChains := buildOutboundCatchAllNetworkFilterChains(configgen, lb.node, lb.push)
+	filterChains := buildOutboundCatchAllNetworkFilterChains(lb.node, lb.push)
 
 	actualWildcard, _ := getActualWildcardAndLocalHost(lb.node)
 
@@ -381,7 +392,7 @@ func (lb *ListenerBuilder) buildVirtualOutboundListener(configgen *ConfigGenerat
 
 // TProxy uses only the virtual outbound listener on 15001 for both directions
 // but we still ship the no-op virtual inbound listener, so that the code flow is same across REDIRECT and TPROXY.
-func (lb *ListenerBuilder) buildVirtualInboundListener(configgen *ConfigGeneratorImpl) *ListenerBuilder {
+func (lb *ListenerBuilder) buildVirtualInboundListener() *ListenerBuilder {
 	if lb.node.GetInterceptionMode() == model.InterceptionNone {
 		// virtual listener is not necessary since workload is not using IPtables for traffic interception
 		return lb
@@ -394,7 +405,7 @@ func (lb *ListenerBuilder) buildVirtualInboundListener(configgen *ConfigGenerato
 
 	actualWildcard, _ := getActualWildcardAndLocalHost(lb.node)
 	// add an extra listener that binds to the port that is the recipient of the iptables redirect
-	filterChains, passthroughInspector, usesQUIC := buildInboundCatchAllFilterChains(configgen, lb.node, lb.push)
+	filterChains, passthroughInspector, usesQUIC := buildInboundCatchAllFilterChains(lb, lb.node, lb.push)
 
 	// exact balance used in Envoy is only supported over TCP connections
 	var connectionBalance *listener.Listener_ConnectionBalanceConfig
@@ -494,24 +505,7 @@ func (lb *ListenerBuilder) getListeners() []*listener.Listener {
 	return lb.gatewayListeners
 }
 
-func getMtlsSettings(configgen *ConfigGeneratorImpl, in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
-	for _, p := range configgen.Plugins {
-		cfg := p.InboundMTLSConfiguration(in, passthrough)
-		if cfg != nil {
-			return cfg
-		}
-	}
-	// If no plugin configures mtls, set it to disabled
-	if passthrough {
-		return []plugin.MTLSSettings{{Mode: model.MTLSDisable}}
-	}
-	return []plugin.MTLSSettings{{
-		Port: in.ServiceInstance.Endpoint.EndpointPort,
-		Mode: model.MTLSDisable,
-	}}
-}
-
-func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
+func buildInboundCatchAllFilterChains(lb *ListenerBuilder,
 	node *model.Proxy, push *model.PushContext) ([]*listener.FilterChain, map[int]enabledInspector, bool) {
 	usesQUIC := false
 
@@ -572,7 +566,7 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 			protocol: istionetworking.ListenerProtocolAuto,
 		}
 		// Call plugins to get mtls policies.
-		fcOpts := configgen.buildInboundFilterchains(in, listenerOpts, matchingIP, clusterName, true)
+		fcOpts := lb.buildInboundFilterchains(in, listenerOpts, matchingIP, clusterName, true)
 		for _, opt := range fcOpts {
 			filterChain := &listener.FilterChain{
 				FilterChainMatch: opt.match,
@@ -583,14 +577,18 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 				if opt.httpOpts.http3Only {
 					usesQUIC = true
 				}
-				connectionManager := buildHTTPConnectionManager(listenerOpts, opt.httpOpts, opt.filterChain.HTTP)
+				connectionManager := lb.buildHTTPConnectionManager(listenerOpts, opt.httpOpts)
 				filter := &listener.Filter{
 					Name:       wellknown.HTTPConnectionManager,
 					ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(connectionManager)},
 				}
 				filterChain.Filters = append(opt.filterChain.TCP, filter)
 			} else {
-				filterChain.Filters = append(opt.filterChain.TCP, opt.networkFilters...)
+				filterChain.Filters = append(filterChain.Filters, lb.authzCustomBuilder.BuildTCP()...)
+				filterChain.Filters = append(filterChain.Filters, lb.authzBuilder.BuildTCP()...)
+
+				filterChain.Filters = append(filterChain.Filters, opt.filterChain.TCP...)
+				filterChain.Filters = append(filterChain.Filters, opt.networkFilters...)
 			}
 			port := int(opt.match.DestinationPort.GetValue())
 			inspector := inspectors[port]
@@ -610,7 +608,7 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 	return filterChains, inspectors, usesQUIC
 }
 
-func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputParams, listenerOpts buildListenerOpts,
+func (lb *ListenerBuilder) buildInboundFilterchains(in *plugin.InputParams, listenerOpts buildListenerOpts,
 	matchingIP string, clusterName string, passthrough bool) []*filterChainOpts {
 	newOpts := []*fcOpts{}
 
@@ -618,7 +616,12 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 	// TLS settings won't take effect
 	hasMTLs := false
 
-	mtlsConfigs := getMtlsSettings(configgen, in, passthrough)
+	var mtlsConfigs []plugin.MTLSSettings
+	if passthrough {
+		mtlsConfigs = lb.authnBuilder.ForPassthrough()
+	} else {
+		mtlsConfigs = []plugin.MTLSSettings{lb.authnBuilder.ForPort(in.ServiceInstance.Endpoint.EndpointPort)}
+	}
 	for _, mtlsConfig := range mtlsConfigs {
 		hasMTLs = hasMTLs || mtlsConfig.Mode != model.MTLSDisable
 		for _, match := range getFilterChainMatchOptions(mtlsConfig, listenerOpts.protocol) {
@@ -636,7 +639,7 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 		}
 		opt.fc.ListenerProtocol = listenerOpts.protocol
 		listenerOpts.tlsSettings.CipherSuites = filteredSidecarCipherSuites(listenerOpts.tlsSettings.CipherSuites)
-		opt.fc.TLSContext = configgen.BuildListenerTLSContext(listenerOpts.tlsSettings, in.Node, istionetworking.TransportProtocolTCP)
+		opt.fc.TLSContext = BuildListenerTLSContext(listenerOpts.tlsSettings, in.Node, istionetworking.TransportProtocolTCP)
 		newOpts = append(newOpts, &opt)
 	}
 
@@ -648,18 +651,6 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 	mutable := &istionetworking.MutableObjects{
 		FilterChains: fcs,
 	}
-	for _, p := range configgen.Plugins {
-		if passthrough {
-			if err := p.OnInboundPassthrough(in, mutable); err != nil {
-				log.Errorf("Build inbound passthrough filter chains error: %v", err)
-			}
-		} else {
-			if err := p.OnInboundListener(in, mutable); err != nil {
-				log.Errorf("Build inbound filter chains error: %v", err)
-			}
-		}
-	}
-	extension.AddWasmPluginsToMutableObjects(mutable, in.Push.WasmPlugins(in.Node))
 	// Merge the results back into our struct
 	for i, fc := range mutable.FilterChains {
 		newOpts[i].fc = fc
@@ -680,14 +671,14 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 		fcOpt.filterChain = opt.fc
 		switch opt.fc.ListenerProtocol {
 		case istionetworking.ListenerProtocolHTTP:
-			fcOpt.httpOpts = configgen.buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
+			fcOpt.httpOpts = buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
 			fcOpt.filterChain.TCP = append(
 				buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound),
 				fcOpt.filterChain.TCP...)
 		case istionetworking.ListenerProtocolTCP:
 			fcOpt.networkFilters = buildInboundNetworkFilters(in.Push, in.Node, in.ServiceInstance, clusterName)
 		case istionetworking.ListenerProtocolAuto:
-			fcOpt.httpOpts = configgen.buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
+			fcOpt.httpOpts = buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
 			fcOpt.networkFilters = buildInboundNetworkFilters(in.Push, in.Node, in.ServiceInstance, clusterName)
 		}
 		fcOpt.filterChainName = model.VirtualInboundListenerName
@@ -740,8 +731,7 @@ func buildOutboundCatchAllNetworkFiltersOnly(push *model.PushContext, node *mode
 // with TLS blocks and build the appropriate filter chain matches and routes here. And then finally
 // evaluate the left over unmatched TLS traffic using allow_any or registry_only.
 // See https://github.com/istio/istio/issues/21170
-func buildOutboundCatchAllNetworkFilterChains(_ *ConfigGeneratorImpl,
-	node *model.Proxy, push *model.PushContext) []*listener.FilterChain {
+func buildOutboundCatchAllNetworkFilterChains(node *model.Proxy, push *model.PushContext) []*listener.FilterChain {
 	filterStack := buildOutboundCatchAllNetworkFiltersOnly(push, node)
 	chains := make([]*listener.FilterChain, 0, 2)
 	chains = append(chains, blackholeFilterChain(push, node), &listener.FilterChain{
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
index a6e47c73fb..e5c4b0ce46 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
@@ -30,8 +30,6 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
-	istionetworking "istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/test/xdstest"
 	"istio.io/istio/pkg/config"
@@ -59,9 +57,6 @@ func TestVirtualListenerBuilder(t *testing.T) {
 )
 
 func buildListeners(t *testing.T, o TestOptions, p *model.Proxy) []*listener.Listener {
-	if o.Plugins == nil {
-		o.Plugins = []plugin.Plugin{&fakePlugin{}}
-	}
 	cg := NewConfigGenTest(t, o)
 	// Hack up some instances for each Service
 	for _, s := range o.Services {
@@ -141,7 +136,6 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 	if l == nil {
 		t.Fatalf("failed to find virtual inbound listener")
 	}
-	sawFakePluginFilter := false
 	sawIpv4PassthroughCluster := 0
 	sawIpv6PassthroughCluster := false
 	sawIpv4PassthroughFilterChainMatchTLSFromFakePlugin := false
@@ -151,9 +145,6 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 		}
 
 		if f := getTCPFilter(fc); f != nil && fc.Name == model.VirtualInboundListenerName {
-			if fc.Filters[0].Name == fakePluginTCPFilter {
-				sawFakePluginFilter = true
-			}
 			if ipLen := len(fc.FilterChainMatch.PrefixRanges); ipLen != 1 {
 				t.Fatalf("expect passthrough filter chain has 1 ip address, found %d", ipLen)
 			}
@@ -184,10 +175,6 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 			if fc.TransportSocket == nil && !reflect.DeepEqual(fc.FilterChainMatch.ApplicationProtocols, plaintextHTTPALPNs) {
 				t.Fatalf("expect %v application protocols, found %v", plaintextHTTPALPNs, fc.FilterChainMatch.ApplicationProtocols)
 			}
-
-			if !strings.Contains(fc.Filters[1].GetTypedConfig().String(), fakePluginHTTPFilter) {
-				t.Errorf("failed to find the fake plugin HTTP filter: %v", fc.Filters[1].GetTypedConfig().String())
-			}
 		}
 	}
 
@@ -195,10 +182,6 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 		t.Fatalf("fail to find the ipv4 passthrough filter chain in listener, got %v: %v", sawIpv4PassthroughCluster, xdstest.Dump(t, l))
 	}
 
-	if !sawFakePluginFilter {
-		t.Fatalf("fail to find the fake plugin TCP filter in listener %v", l)
-	}
-
 	if !sawIpv4PassthroughFilterChainMatchTLSFromFakePlugin {
 		t.Fatalf("fail to find the fake plugin filter chain match with TLS in listener %v", l)
 	}
@@ -647,13 +630,22 @@ func evaluateListenerFilterPredicates(t testing.TB, predicate *listener.Listener
 	}
 }
 
-type TestAuthnPlugin struct {
-	mtlsSettings []plugin.MTLSSettings
-}
-
 func TestSidecarInboundListenerFilters(t *testing.T) {
-	services := []*model.Service{
-		buildServiceWithPort("test.com", 80, protocol.HTTPS, tnow),
+	services := []*model.Service{buildServiceWithPort("test.com", 80, protocol.HTTPS, tnow)}
+
+	expectIstioMTLS := func(t test.Failer, filterChain *listener.FilterChain) {
+		tlsContext := &tls.DownstreamTlsContext{}
+		if err := filterChain.GetTransportSocket().GetTypedConfig().UnmarshalTo(tlsContext); err != nil {
+			t.Fatal(err)
+		}
+		commonTLSContext := tlsContext.CommonTlsContext
+		if len(commonTLSContext.TlsCertificateSdsSecretConfigs) == 0 {
+			t.Fatal("expected tls certificates")
+		}
+		if commonTLSContext.TlsCertificateSdsSecretConfigs[0].Name != "default" {
+			t.Fatalf("expected certificate default, actual %s",
+				commonTLSContext.TlsCertificates[0].CertificateChain.String())
+		}
 	}
 	instances := make([]*model.ServiceInstance, 0, len(services))
 	for _, s := range services {
@@ -669,8 +661,8 @@ func TestSidecarInboundListenerFilters(t *testing.T) {
 	cases := []struct {
 		name           string
 		sidecarScope   *model.SidecarScope
-		mtlsSettings   []plugin.MTLSSettings
-		expectedResult func(filterChain *listener.FilterChain)
+		mtlsMode       model.MutualTLSMode
+		expectedResult func(t test.Failer, filterChain *listener.FilterChain)
 	}{
 		{
 			name: "simulate peer auth disabled on port 80",
@@ -688,10 +680,8 @@ func TestSidecarInboundListenerFilters(t *testing.T) {
 					},
 				},
 			},
-			mtlsSettings: []plugin.MTLSSettings{{
-				Mode: model.MTLSDisable,
-			}},
-			expectedResult: func(filterChain *listener.FilterChain) {
+			mtlsMode: model.MTLSDisable,
+			expectedResult: func(t test.Failer, filterChain *listener.FilterChain) {
 				tlsContext := &tls.DownstreamTlsContext{}
 				if err := filterChain.GetTransportSocket().GetTypedConfig().UnmarshalTo(tlsContext); err != nil {
 					t.Fatal(err)
@@ -725,14 +715,8 @@ func TestSidecarInboundListenerFilters(t *testing.T) {
 					},
 				},
 			},
-			mtlsSettings: []plugin.MTLSSettings{{
-				Mode: model.MTLSStrict,
-			}},
-			expectedResult: func(filterChain *listener.FilterChain) {
-				if filterChain.GetTransportSocket() != nil {
-					t.Fatal("expected transport socket to be nil")
-				}
-			},
+			mtlsMode:       model.MTLSStrict,
+			expectedResult: expectIstioMTLS,
 		},
 		{
 			name: "simulate peer auth permissive",
@@ -750,55 +734,16 @@ func TestSidecarInboundListenerFilters(t *testing.T) {
 					},
 				},
 			},
-			mtlsSettings: []plugin.MTLSSettings{{
-				Mode: model.MTLSPermissive,
-			}},
-			expectedResult: func(filterChain *listener.FilterChain) {
-				if filterChain.GetTransportSocket() != nil {
-					t.Fatal("expected transport socket to be nil")
-				}
-			},
-		},
-		{
-			name: "simulate multiple mode returned in mtlssettings",
-			sidecarScope: &model.SidecarScope{
-				Sidecar: &networking.Sidecar{
-					Ingress: []*networking.IstioIngressListener{
-						{
-							Port: &networking.Port{Name: "https-port", Protocol: "https", Number: 80},
-							Tls: &networking.ServerTLSSettings{
-								Mode:              networking.ServerTLSSettings_SIMPLE,
-								ServerCertificate: "cert.pem",
-								PrivateKey:        "privatekey.pem",
-							},
-						},
-					},
-				},
-			},
-			mtlsSettings: []plugin.MTLSSettings{
-				{
-					Mode: model.MTLSStrict,
-				},
-				{
-					Mode: model.MTLSDisable,
-				},
-			},
-			expectedResult: func(filterChain *listener.FilterChain) {
-				if filterChain.GetTransportSocket() != nil {
-					t.Fatal("expected transport socket to be nil")
-				}
-			},
+			mtlsMode:       model.MTLSPermissive,
+			expectedResult: expectIstioMTLS,
 		},
 	}
 	for _, tt := range cases {
 		t.Run(tt.name, func(t *testing.T) {
-			testPlugin := &TestAuthnPlugin{
-				mtlsSettings: tt.mtlsSettings,
-			}
 			cg := NewConfigGenTest(t, TestOptions{
-				Services:  services,
-				Instances: instances,
-				Plugins:   []plugin.Plugin{testPlugin},
+				Services:     services,
+				Instances:    instances,
+				ConfigString: mtlsMode(tt.mtlsMode.String()),
 			})
 			proxy := cg.SetupProxy(nil)
 			proxy.Metadata = &model.NodeMetadata{Labels: map[string]string{"app": "foo"}}
@@ -807,23 +752,19 @@ func TestSidecarInboundListenerFilters(t *testing.T) {
 			listeners := cg.Listeners(proxy)
 			virtualInbound := xdstest.ExtractListener("virtualInbound", listeners)
 			filterChain := xdstest.ExtractFilterChain("1.1.1.1_80", virtualInbound)
-			tt.expectedResult(filterChain)
+			tt.expectedResult(t, filterChain)
 		})
 	}
 }
 
-func (t TestAuthnPlugin) OnOutboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	return nil
-}
-
-func (t TestAuthnPlugin) OnInboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	return nil
-}
-
-func (t TestAuthnPlugin) OnInboundPassthrough(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	return nil
-}
-
-func (t TestAuthnPlugin) InboundMTLSConfiguration(in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
-	return t.mtlsSettings
+func mtlsMode(m string) string {
+	return fmt.Sprintf(`apiVersion: security.istio.io/v1beta1
+kind: PeerAuthentication
+metadata:
+  name: default
+  namespace: istio-system
+spec:
+  mtls:
+    mode: %s
+`, m)
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 7d2f70b3ee..09dc74ac47 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -26,7 +26,6 @@
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	tcp "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/tcp_proxy/v3"
-	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	tracing "github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3"
 	xdstype "github.com/envoyproxy/go-control-plane/envoy/type/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/conversion"
@@ -41,10 +40,7 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
-	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/listenertest"
-	"istio.io/istio/pilot/pkg/networking/plugin"
-	"istio.io/istio/pilot/pkg/networking/plugin/registry"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
@@ -60,9 +56,7 @@
 )
 
 const (
-	wildcardIP           = "0.0.0.0"
-	fakePluginHTTPFilter = "fake-plugin-http-filter"
-	fakePluginTCPFilter  = "fake-plugin-tcp-filter"
+	wildcardIP = "0.0.0.0"
 )
 
 func getProxy() *model.Proxy {
@@ -311,8 +305,7 @@ func TestOutboundListenerConflict_TCPWithCurrentTCP(t *testing.T) {
 		buildService("test2.com", "1.2.3.4", protocol.TCP, tnow),
 		buildService("test3.com", "1.2.3.4", protocol.TCP, tnow.Add(2*time.Second)),
 	}
-	p := &fakePlugin{}
-	listeners := buildOutboundListeners(t, p, getProxy(), nil, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), nil, nil, services...)
 	if len(listeners) != 1 {
 		t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
 	}
@@ -356,7 +349,6 @@ func TestOutboundListenerTCPWithVS(t *testing.T) {
 				buildService("test.com", tt.CIDR, protocol.TCP, tnow),
 			}
 
-			p := &fakePlugin{}
 			virtualService := config.Config{
 				Meta: config.Meta{
 					GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
@@ -365,7 +357,7 @@ func TestOutboundListenerTCPWithVS(t *testing.T) {
 				},
 				Spec: virtualServiceSpec,
 			}
-			listeners := buildOutboundListeners(t, p, getProxy(), nil, &virtualService, services...)
+			listeners := buildOutboundListeners(t, getProxy(), nil, &virtualService, services...)
 
 			if len(listeners) != 1 {
 				t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
@@ -411,7 +403,6 @@ func TestOutboundListenerTCPWithVSExactBalance(t *testing.T) {
 				buildService("test.com", tt.CIDR, protocol.TCP, tnow),
 			}
 
-			p := &fakePlugin{}
 			virtualService := config.Config{
 				Meta: config.Meta{
 					GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
@@ -423,7 +414,7 @@ func TestOutboundListenerTCPWithVSExactBalance(t *testing.T) {
 			proxy := getProxy()
 			proxy.Metadata.InboundListenerExactBalance = true
 			proxy.Metadata.OutboundListenerExactBalance = true
-			listeners := buildOutboundListeners(t, p, proxy, nil, &virtualService, services...)
+			listeners := buildOutboundListeners(t, proxy, nil, &virtualService, services...)
 
 			if len(listeners) != 1 {
 				t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
@@ -545,7 +536,7 @@ func TestOutboundListenerForHeadlessServices(t *testing.T) {
 			proxy.Metadata.InboundListenerExactBalance = true
 			proxy.Metadata.OutboundListenerExactBalance = true
 
-			listeners := cg.ConfigGen.buildSidecarOutboundListeners(proxy, cg.env.PushContext)
+			listeners := NewListenerBuilder(proxy, cg.env.PushContext).buildSidecarOutboundListeners(proxy, cg.env.PushContext)
 			listenersToCheck := make([]string, 0)
 			for _, l := range listeners {
 				if l.Address.GetSocketAddress().GetPortValue() == 9999 {
@@ -802,12 +793,10 @@ func TestOutboundTls(t *testing.T) {
 			},
 		},
 	}
-	p := &fakePlugin{}
-	buildOutboundListeners(t, p, getProxy(), &virtualService2, &virtualService, services...)
+	buildOutboundListeners(t, getProxy(), &virtualService2, &virtualService, services...)
 }
 
 func TestOutboundListenerConfigWithSidecarHTTPProxy(t *testing.T) {
-	p := &fakePlugin{}
 	sidecarConfig := &config.Config{
 		Meta: config.Meta{
 			Name:             "sidecar-with-http-proxy",
@@ -831,7 +820,7 @@ func TestOutboundListenerConfigWithSidecarHTTPProxy(t *testing.T) {
 	}
 	services := []*model.Service{buildService("httpbin.com", wildcardIP, protocol.HTTP, tnow.Add(1*time.Second))}
 
-	listeners := buildOutboundListeners(t, p, getProxy(), sidecarConfig, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), sidecarConfig, nil, services...)
 
 	if expected := 1; len(listeners) != expected {
 		t.Fatalf("expected %d listeners, found %d", expected, len(listeners))
@@ -1096,8 +1085,7 @@ func testOutboundListenerConflictWithSniffingDisabled(t *testing.T, services ...
 
 	oldestService := getOldestService(services...)
 
-	p := &fakePlugin{}
-	listeners := buildOutboundListeners(t, p, getProxy(), nil, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), nil, nil, services...)
 	if len(listeners) != 1 {
 		t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
 	}
@@ -1108,16 +1096,11 @@ func testOutboundListenerConflictWithSniffingDisabled(t *testing.T, services ...
 	} else if oldestProtocol == protocol.HTTP && !isHTTPListener(listeners[0]) {
 		t.Fatal("expected HTTP listener, found TCP")
 	}
-
-	if len(p.outboundListenerParams) != 1 {
-		t.Fatalf("expected %d listener params, found %d", 1, len(p.outboundListenerParams))
-	}
 }
 
 func testOutboundListenerRoute(t *testing.T, services ...*model.Service) {
 	t.Helper()
-	p := &fakePlugin{}
-	listeners := buildOutboundListeners(t, p, getProxy(), nil, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), nil, nil, services...)
 	if len(listeners) != 3 {
 		t.Fatalf("expected %d listeners, found %d", 3, len(listeners))
 	}
@@ -1158,8 +1141,7 @@ func testOutboundListenerRoute(t *testing.T, services ...*model.Service) {
 }
 
 func testOutboundListenerFilterTimeout(t *testing.T, services ...*model.Service) {
-	p := &fakePlugin{}
-	listeners := buildOutboundListeners(t, p, getProxy(), nil, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), nil, nil, services...)
 	if len(listeners) != 2 {
 		t.Fatalf("expected %d listeners, found %d", 2, len(listeners))
 	}
@@ -1178,10 +1160,9 @@ func testOutboundListenerFilterTimeout(t *testing.T, services ...*model.Service)
 
 func testOutboundListenerConflict(t *testing.T, services ...*model.Service) {
 	oldestService := getOldestService(services...)
-	p := &fakePlugin{}
 	proxy := getProxy()
 	proxy.DiscoverIPMode()
-	listeners := buildOutboundListeners(t, p, getProxy(), nil, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), nil, nil, services...)
 	if len(listeners) != 1 {
 		t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
 	}
@@ -1297,8 +1278,7 @@ func getHTTPFilterChain(t *testing.T, l *listener.Listener) *listener.FilterChai
 
 func testInboundListenerConfig(t *testing.T, proxy *model.Proxy, services ...*model.Service) {
 	t.Helper()
-	p := registry.NewPlugins([]string{plugin.Authn})
-	listeners := buildListeners(t, TestOptions{Plugins: p, Services: services}, proxy)
+	listeners := buildListeners(t, TestOptions{Services: services}, proxy)
 	verifyFilterChainMatch(t, xdstest.ExtractListener(model.VirtualInboundListenerName, listeners))
 }
 
@@ -1341,7 +1321,6 @@ func testInboundListenerConfigWithSidecar(t *testing.T, proxy *model.Proxy, serv
 	listeners := buildListeners(t, TestOptions{
 		Services: services,
 		Configs:  []config.Config{sidecarConfig},
-		Plugins:  registry.NewPlugins([]string{plugin.Authn}),
 	}, proxy)
 	l := xdstest.ExtractListener(model.VirtualInboundListenerName, listeners)
 	verifyFilterChainMatch(t, l)
@@ -1372,7 +1351,6 @@ func testInboundListenerConfigWithSidecarWithoutServices(t *testing.T, proxy *mo
 	}
 	listeners := buildListeners(t, TestOptions{
 		Configs: []config.Config{sidecarConfig},
-		Plugins: registry.NewPlugins([]string{plugin.Authn}),
 	}, proxy)
 	l := xdstest.ExtractListener(model.VirtualInboundListenerName, listeners)
 	verifyFilterChainMatch(t, l)
@@ -1380,9 +1358,7 @@ func testInboundListenerConfigWithSidecarWithoutServices(t *testing.T, proxy *mo
 
 func testInboundListenerConfigWithoutService(t *testing.T, proxy *model.Proxy) {
 	t.Helper()
-	listeners := buildListeners(t, TestOptions{
-		Plugins: registry.NewPlugins([]string{plugin.Authn}),
-	}, proxy)
+	listeners := buildListeners(t, TestOptions{}, proxy)
 	l := xdstest.ExtractListener(model.VirtualInboundListenerName, listeners)
 	verifyFilterChainMatch(t, l)
 }
@@ -1440,7 +1416,6 @@ func isTCPFilterChain(fc *listener.FilterChain) bool {
 
 func testOutboundListenerConfigWithSidecar(t *testing.T, services ...*model.Service) {
 	t.Helper()
-	p := &fakePlugin{}
 	sidecarConfig := &config.Config{
 		Meta: config.Meta{
 			Name:             "foo",
@@ -1485,7 +1460,7 @@ func testOutboundListenerConfigWithSidecar(t *testing.T, services ...*model.Serv
 	// enable mysql filter that is used here
 	test.SetBoolForTest(t, &features.EnableMysqlFilter, true)
 
-	listeners := buildOutboundListeners(t, p, getProxy(), sidecarConfig, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), sidecarConfig, nil, services...)
 	if len(listeners) != 4 {
 		t.Fatalf("expected %d listeners, found %d", 4, len(listeners))
 	}
@@ -1531,7 +1506,6 @@ func testOutboundListenerConfigWithSidecar(t *testing.T, services ...*model.Serv
 
 func testOutboundListenerConfigWithSidecarWithSniffingDisabled(t *testing.T, services ...*model.Service) {
 	t.Helper()
-	p := &fakePlugin{}
 	sidecarConfig := &config.Config{
 		Meta: config.Meta{
 			Name:             "foo",
@@ -1568,7 +1542,7 @@ func testOutboundListenerConfigWithSidecarWithSniffingDisabled(t *testing.T, ser
 	// enable mysql filter that is used here
 	test.SetBoolForTest(t, &features.EnableMysqlFilter, true)
 
-	listeners := buildOutboundListeners(t, p, getProxy(), sidecarConfig, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), sidecarConfig, nil, services...)
 	if len(listeners) != 1 {
 		t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
 	}
@@ -1580,7 +1554,6 @@ func testOutboundListenerConfigWithSidecarWithSniffingDisabled(t *testing.T, ser
 
 func testOutboundListenerConfigWithSidecarWithUseRemoteAddress(t *testing.T, services ...*model.Service) {
 	t.Helper()
-	p := &fakePlugin{}
 	sidecarConfig := &config.Config{
 		Meta: config.Meta{
 			Name:             "foo",
@@ -1605,7 +1578,7 @@ func testOutboundListenerConfigWithSidecarWithUseRemoteAddress(t *testing.T, ser
 	// enable use remote address to true
 	test.SetBoolForTest(t, &features.UseRemoteAddress, true)
 
-	listeners := buildOutboundListeners(t, p, getProxy(), sidecarConfig, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), sidecarConfig, nil, services...)
 
 	if l := findListenerByPort(listeners, 9090); !isHTTPListener(l) {
 		t.Fatalf("expected HTTP listener on port 9090, found TCP\n%v", l)
@@ -1622,7 +1595,6 @@ func testOutboundListenerConfigWithSidecarWithUseRemoteAddress(t *testing.T, ser
 
 func testOutboundListenerConfigWithSidecarWithCaptureModeNone(t *testing.T, services ...*model.Service) {
 	t.Helper()
-	p := &fakePlugin{}
 	sidecarConfig := &config.Config{
 		Meta: config.Meta{
 			Name:             "foo",
@@ -1666,7 +1638,7 @@ func testOutboundListenerConfigWithSidecarWithCaptureModeNone(t *testing.T, serv
 			},
 		},
 	}
-	listeners := buildOutboundListeners(t, p, getProxy(), sidecarConfig, nil, services...)
+	listeners := buildOutboundListeners(t, getProxy(), sidecarConfig, nil, services...)
 	if len(listeners) != 4 {
 		t.Fatalf("expected %d listeners, found %d", 4, len(listeners))
 	}
@@ -2429,69 +2401,18 @@ func getFilterConfig(filter *listener.Filter, out proto.Message) error {
 	return nil
 }
 
-func buildOutboundListeners(t *testing.T, p plugin.Plugin, proxy *model.Proxy, sidecarConfig *config.Config,
+func buildOutboundListeners(t *testing.T, proxy *model.Proxy, sidecarConfig *config.Config,
 	virtualService *config.Config, services ...*model.Service) []*listener.Listener {
 	t.Helper()
 	cg := NewConfigGenTest(t, TestOptions{
 		Services:       services,
 		ConfigPointers: []*config.Config{sidecarConfig, virtualService},
-		Plugins:        []plugin.Plugin{p},
 	})
-	listeners := cg.ConfigGen.buildSidecarOutboundListeners(cg.SetupProxy(proxy), cg.env.PushContext)
+	listeners := NewListenerBuilder(proxy, cg.env.PushContext).buildSidecarOutboundListeners(cg.SetupProxy(proxy), cg.env.PushContext)
 	xdstest.ValidateListeners(t, listeners)
 	return listeners
 }
 
-type fakePlugin struct {
-	outboundListenerParams []*plugin.InputParams
-}
-
-var _ plugin.Plugin = (*fakePlugin)(nil)
-
-func (p *fakePlugin) OnOutboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	p.outboundListenerParams = append(p.outboundListenerParams, in)
-	return nil
-}
-
-func (p *fakePlugin) OnInboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	return nil
-}
-
-func (p *fakePlugin) OnInboundPassthrough(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
-	for cnum, fc := range mutable.FilterChains {
-		switch fc.ListenerProtocol {
-		case istionetworking.ListenerProtocolTCP:
-			filter := &listener.Filter{
-				Name: fakePluginTCPFilter,
-			}
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, filter)
-		case istionetworking.ListenerProtocolHTTP:
-			filter := &hcm.HttpFilter{
-				Name: fakePluginHTTPFilter,
-			}
-			mutable.FilterChains[cnum].HTTP = append(mutable.FilterChains[cnum].HTTP, filter)
-		}
-	}
-	return nil
-}
-
-func (p *fakePlugin) InboundMTLSConfiguration(in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
-	var port uint32
-	if !passthrough {
-		port = in.ServiceInstance.Endpoint.EndpointPort
-	}
-	return []plugin.MTLSSettings{{
-		Port: port,
-		Mode: model.MTLSPermissive,
-		TCP: &tls.DownstreamTlsContext{
-			CommonTlsContext: &tls.CommonTlsContext{AlpnProtocols: []string{"foo"}},
-		},
-		HTTP: &tls.DownstreamTlsContext{
-			CommonTlsContext: &tls.CommonTlsContext{AlpnProtocols: []string{"foo"}},
-		},
-	}}
-}
-
 func isHTTPListener(listener *listener.Listener) bool {
 	for _, fc := range listener.GetFilterChains() {
 		if isHTTPFilterChain(fc) {
@@ -2661,8 +2582,7 @@ func TestAppendListenerFallthroughRouteForCompleteListener(t *testing.T) {
 		t.Run(tt.name, func(t *testing.T) {
 			cg := NewConfigGenTest(t, TestOptions{})
 			l := &listener.Listener{}
-			cg.ConfigGen.appendListenerFallthroughRouteForCompleteListener(l,
-				tt.node, cg.PushContext())
+			appendListenerFallthroughRouteForCompleteListener(l, tt.node, cg.PushContext())
 			if len(l.FilterChains) != 0 {
 				t.Errorf("Expected exactly 0 filter chain")
 			}
diff --git a/pilot/pkg/networking/networking.go b/pilot/pkg/networking/networking.go
index 9b39b6596b..c7eef41a07 100644
--- a/pilot/pkg/networking/networking.go
+++ b/pilot/pkg/networking/networking.go
@@ -125,6 +125,7 @@ type FilterChain struct {
 // Any lists should not be overridden, but rather only appended to.
 // Non-list fields may be mutated; however it's not recommended to do this since it can affect other plugins in the
 // chain in unpredictable ways.
+// TODO: do we need this now?
 type MutableObjects struct {
 	// Listener is the listener being built. Must be initialized before Plugin methods are called.
 	Listener *listener.Listener
diff --git a/pilot/pkg/networking/plugin/authn/authentication.go b/pilot/pkg/networking/plugin/authn/authentication.go
index fcea85503f..e35c2a01b6 100644
--- a/pilot/pkg/networking/plugin/authn/authentication.go
+++ b/pilot/pkg/networking/plugin/authn/authentication.go
@@ -15,108 +15,92 @@
 package authn
 
 import (
+	httppb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
+
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pilot/pkg/security/authn"
 	"istio.io/istio/pilot/pkg/security/authn/factory"
 	"istio.io/pkg/log"
 )
 
 var authnLog = log.RegisterScope("authn", "authn debugging", 0)
 
-// Plugin implements Istio mTLS auth
-type Plugin struct{}
-
-// NewPlugin returns an instance of the authn plugin
-func NewPlugin() plugin.Plugin {
-	return Plugin{}
+type Builder struct {
+	applier      authn.PolicyApplier
+	trustDomains []string
+	proxy        *model.Proxy
 }
 
-var _ plugin.Plugin = Plugin{}
-
-// OnOutboundListener is called whenever a new outbound listener is added to the LDS output for a given service
-// Can be used to add additional filters on the outbound path
-func (Plugin) OnOutboundListener(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.Router {
-		// Only care about router.
-		return nil
+func NewBuilder(push *model.PushContext, proxy *model.Proxy) *Builder {
+	applier := factory.NewPolicyApplier(push, proxy.Metadata.Namespace, proxy.Metadata.Labels)
+	trustDomains := TrustDomainsForValidation(push.Mesh)
+	return &Builder{
+		applier:      applier,
+		proxy:        proxy,
+		trustDomains: trustDomains,
 	}
-
-	return buildFilter(in, mutable)
 }
 
-// OnInboundListener is called whenever a new listener is added to the LDS output for a given service
-// Can be used to add additional filters or add more stuff to the HTTP connection manager
-// on the inbound path
-func (Plugin) OnInboundListener(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.SidecarProxy {
-		// Only care about sidecar.
-		return nil
-	}
-	return buildFilter(in, mutable)
-}
-
-func buildFilter(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	ns := in.Node.Metadata.Namespace
-	applier := factory.NewPolicyApplier(in.Push, ns, in.Node.Metadata.Labels)
-	forSidecar := in.Node.Type == model.SidecarProxy
-	for i := range mutable.FilterChains {
-		if mutable.FilterChains[i].ListenerProtocol == networking.ListenerProtocolHTTP {
-			// Adding Jwt filter and authn filter, if needed.
-			if filter := applier.JwtFilter(); filter != nil {
-				mutable.FilterChains[i].HTTP = append(mutable.FilterChains[i].HTTP, filter)
-			}
-			if filter := applier.AuthNFilter(forSidecar); filter != nil {
-				mutable.FilterChains[i].HTTP = append(mutable.FilterChains[i].HTTP, filter)
-			}
+func (b *Builder) ForPort(port uint32) plugin.MTLSSettings {
+	if b == nil {
+		return plugin.MTLSSettings{
+			Port: port,
+			Mode: model.MTLSDisable,
 		}
 	}
-
-	return nil
-}
-
-// OnInboundPassthrough is called whenever a new passthrough filter chain is added to the LDS output.
-func (Plugin) OnInboundPassthrough(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.SidecarProxy {
-		// Only care about sidecar.
-		return nil
-	}
-
-	return buildFilter(in, mutable)
+	return b.applier.InboundMTLSSettings(port, b.proxy, b.trustDomains)
 }
 
-func (p Plugin) InboundMTLSConfiguration(in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
-	applier := factory.NewPolicyApplier(in.Push, in.Node.Metadata.Namespace, in.Node.Metadata.Labels)
-	trustDomains := TrustDomainsForValidation(in.Push.Mesh)
-
-	port := in.ServiceInstance.Endpoint.EndpointPort
-
-	// For non passthrough, set up the specific port
-	if !passthrough {
-		return []plugin.MTLSSettings{
-			applier.InboundMTLSSettings(port, in.Node, trustDomains),
-		}
+func (b *Builder) ForPassthrough() []plugin.MTLSSettings {
+	if b == nil {
+		return []plugin.MTLSSettings{{
+			Port: 0,
+			Mode: model.MTLSDisable,
+		}}
 	}
-	// Otherwise, this is for passthrough configuration. We need to create configuration for the passthrough,
+	//	We need to create configuration for the passthrough,
 	// but also any ports that are not explicitly declared in the Service but are in the mTLS port level settings.
+
 	resp := []plugin.MTLSSettings{
 		// Full passthrough - no port match
-		applier.InboundMTLSSettings(0, in.Node, trustDomains),
+		b.applier.InboundMTLSSettings(0, b.proxy, b.trustDomains),
 	}
 
 	// Then generate the per-port passthrough filter chains.
-	for port := range applier.PortLevelSetting() {
+	for port := range b.applier.PortLevelSetting() {
 		// Skip the per-port passthrough filterchain if the port is already handled by InboundMTLSConfiguration().
-		if !needPerPortPassthroughFilterChain(port, in.Node) {
+		if !needPerPortPassthroughFilterChain(port, b.proxy) {
 			continue
 		}
 
-		authnLog.Debugf("InboundMTLSConfiguration: build extra pass through filter chain for %v:%d", in.Node.ID, port)
-		resp = append(resp, applier.InboundMTLSSettings(port, in.Node, trustDomains))
+		authnLog.Debugf("InboundMTLSConfiguration: build extra pass through filter chain for %v:%d", b.proxy.ID, port)
+		resp = append(resp, b.applier.InboundMTLSSettings(port, b.proxy, b.trustDomains))
 	}
 	return resp
 }
 
+func (b *Builder) BuildHTTP(class networking.ListenerClass) []*httppb.HttpFilter {
+	if b == nil {
+		return nil
+	}
+	if class == networking.ListenerClassSidecarOutbound {
+		// Only applies to inbound and gateways
+		return nil
+	}
+	res := []*httppb.HttpFilter{}
+	if filter := b.applier.JwtFilter(); filter != nil {
+		res = append(res, filter)
+	}
+	forSidecar := b.proxy.Type == model.SidecarProxy
+	if filter := b.applier.AuthNFilter(forSidecar); filter != nil {
+		res = append(res, filter)
+	}
+
+	return res
+}
+
 func needPerPortPassthroughFilterChain(port uint32, node *model.Proxy) bool {
 	// If there is any Sidecar defined, check if the port is explicitly defined there.
 	// This means the Sidecar resource takes precedence over the service. A port defined in service but not in Sidecar
diff --git a/pilot/pkg/networking/plugin/authz/authorization.go b/pilot/pkg/networking/plugin/authz/authorization.go
index be21fd40df..7102e8582f 100644
--- a/pilot/pkg/networking/plugin/authz/authorization.go
+++ b/pilot/pkg/networking/plugin/authz/authorization.go
@@ -20,14 +20,10 @@
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/security/authz/builder"
 	"istio.io/istio/pilot/pkg/security/trustdomain"
-	"istio.io/pkg/log"
 )
 
-var authzLog = log.RegisterScope("authorization", "Istio Authorization Policy", 0)
-
 type ActionType int
 
 const (
@@ -37,96 +33,52 @@
 	Custom
 )
 
-// Plugin implements Istio Authorization
-type Plugin struct {
-	actionType ActionType
-}
+type Builder struct {
+	// Lazy load
+	httpBuilt, tcpBuilt bool
 
-// NewPlugin returns an instance of the authorization plugin
-func NewPlugin(actionType ActionType) plugin.Plugin {
-	return Plugin{actionType: actionType}
+	httpFilters []*httppb.HttpFilter
+	tcpFilters  []*tcppb.Filter
+	builder     *builder.Builder
 }
 
-// OnOutboundListener is called whenever a new outbound listener is added to the LDS output for a given service
-// Can be used to add additional filters on the outbound path
-func (p Plugin) OnOutboundListener(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.Router {
-		// Only care about router.
-		return nil
+func NewBuilder(actionType ActionType, push *model.PushContext, proxy *model.Proxy) *Builder {
+	tdBundle := trustdomain.NewBundle(push.Mesh.TrustDomain, push.Mesh.TrustDomainAliases)
+	option := builder.Option{
+		IsCustomBuilder: actionType == Custom,
+		Logger:          &builder.AuthzLogger{},
 	}
-
-	p.buildFilter(in, mutable)
-	return nil
+	policies := push.AuthzPolicies.ListAuthorizationPolicies(proxy.ConfigNamespace, proxy.Metadata.Labels)
+	b := builder.New(tdBundle, push, policies, option)
+	return &Builder{builder: b}
 }
 
-// OnInboundListener is called whenever a new listener is added to the LDS output for a given service
-// Can be used to add additional filters or add more stuff to the HTTP connection manager
-// on the inbound path
-func (p Plugin) OnInboundListener(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.SidecarProxy {
-		// Only care about sidecar.
+func (b *Builder) BuildTCP() []*tcppb.Filter {
+	if b.builder == nil {
 		return nil
 	}
-
-	p.buildFilter(in, mutable)
-	return nil
-}
-
-func (p Plugin) buildFilter(in *plugin.InputParams, mutable *networking.MutableObjects) {
-	if in.Push == nil || in.Push.AuthzPolicies == nil {
-		authzLog.Debugf("No authorization policy for %s", in.Node.ID)
-		return
+	if b.tcpBuilt {
+		return b.tcpFilters
 	}
+	b.tcpBuilt = true
+	b.tcpFilters = b.builder.BuildTCP()
 
-	meshConfig := in.Push.Mesh
-	tdBundle := trustdomain.NewBundle(meshConfig.TrustDomain, meshConfig.TrustDomainAliases)
-	option := builder.Option{
-		IsCustomBuilder: p.actionType == Custom,
-		Logger:          &builder.AuthzLogger{},
-	}
-	defer option.Logger.Report(in)
-	b := builder.New(tdBundle, in, option)
-	if b == nil {
-		return
-	}
-
-	// We will lazily build filters for tcp/http as needed
-	httpBuilt := false
-	tcpBuilt := false
-	var httpFilters []*httppb.HttpFilter
-	var tcpFilters []*tcppb.Filter
-
-	for cnum := range mutable.FilterChains {
-		switch mutable.FilterChains[cnum].ListenerProtocol {
-		case networking.ListenerProtocolTCP:
-			if !tcpBuilt {
-				tcpFilters = b.BuildTCP()
-				tcpBuilt = true
-			}
-			option.Logger.AppendDebugf("added %d TCP filters to filter chain %d", len(tcpFilters), cnum)
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, tcpFilters...)
-		case networking.ListenerProtocolHTTP:
-			if !httpBuilt {
-				httpFilters = b.BuildHTTP()
-				httpBuilt = true
-			}
-			option.Logger.AppendDebugf("added %d HTTP filters to filter chain %d", len(httpFilters), cnum)
-			mutable.FilterChains[cnum].HTTP = append(mutable.FilterChains[cnum].HTTP, httpFilters...)
-		}
-	}
+	return b.tcpFilters
 }
 
-// OnInboundPassthrough is called whenever a new passthrough filter chain is added to the LDS output.
-func (p Plugin) OnInboundPassthrough(in *plugin.InputParams, mutable *networking.MutableObjects) error {
-	if in.Node.Type != model.SidecarProxy {
-		// Only care about sidecar.
+func (b *Builder) BuildHTTP(class networking.ListenerClass) []*httppb.HttpFilter {
+	if b.builder == nil {
 		return nil
 	}
+	if class == networking.ListenerClassSidecarOutbound {
+		// Only applies to inbound and gateways
+		return nil
+	}
+	if b.httpBuilt {
+		return b.httpFilters
+	}
+	b.httpBuilt = true
+	b.httpFilters = b.builder.BuildHTTP()
 
-	p.buildFilter(in, mutable)
-	return nil
-}
-
-func (p Plugin) InboundMTLSConfiguration(in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
-	return nil
+	return b.httpFilters
 }
diff --git a/pilot/pkg/networking/plugin/plugin.go b/pilot/pkg/networking/plugin/plugin.go
index 9bd738d64e..8e149c3fbc 100644
--- a/pilot/pkg/networking/plugin/plugin.go
+++ b/pilot/pkg/networking/plugin/plugin.go
@@ -18,7 +18,6 @@
 	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 
 	"istio.io/istio/pilot/pkg/model"
-	istionetworking "istio.io/istio/pilot/pkg/networking"
 )
 
 const (
@@ -44,26 +43,6 @@ type InputParams struct {
 	Push *model.PushContext
 }
 
-// Plugin is called during the construction of a listener.Listener which may alter the Listener in any
-// way. Examples include AuthenticationPlugin that sets up mTLS authentication on the inbound Listener
-// and outbound Cluster, etc.
-type Plugin interface {
-	// OnOutboundListener is called whenever a new outbound listener is added to the LDS output for a given service.
-	// Can be used to add additional filters on the outbound path.
-	OnOutboundListener(in *InputParams, mutable *istionetworking.MutableObjects) error
-
-	// OnInboundListener is called whenever a new listener is added to the LDS output for a given service
-	// Can be used to add additional filters.
-	OnInboundListener(in *InputParams, mutable *istionetworking.MutableObjects) error
-
-	// OnInboundPassthrough is called whenever a new passthrough filter chain is added to the LDS output.
-	// Can be used to add additional filters.
-	OnInboundPassthrough(in *InputParams, mutable *istionetworking.MutableObjects) error
-
-	// InboundMTLSConfiguration configures the mTLS configuration for inbound listeners.
-	InboundMTLSConfiguration(in *InputParams, passthrough bool) []MTLSSettings
-}
-
 // MTLSSettings describes the mTLS options for a filter chain
 type MTLSSettings struct {
 	// Port is the port this option applies for
diff --git a/pilot/pkg/networking/plugin/registry/registry.go b/pilot/pkg/networking/plugin/registry/registry.go
deleted file mode 100644
index e5a975cf15..0000000000
--- a/pilot/pkg/networking/plugin/registry/registry.go
+++ /dev/null
@@ -1,42 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Package registry represents a registry of plugins that can be used by a config generator.
-//
-// This lives in a subpackage and not in package `plugin` itself to avoid cyclic dependencies.
-package registry
-
-import (
-	"istio.io/istio/pilot/pkg/networking/plugin"
-	"istio.io/istio/pilot/pkg/networking/plugin/authn"
-	"istio.io/istio/pilot/pkg/networking/plugin/authz"
-)
-
-var availablePlugins = map[string]plugin.Plugin{
-	// TODO(yangminzhu): Probably better to refactor to use a single plugin for all security filters?
-	plugin.AuthzCustom: authz.NewPlugin(authz.Custom),
-	plugin.Authn:       authn.NewPlugin(),
-	plugin.Authz:       authz.NewPlugin(authz.Local),
-}
-
-// NewPlugins returns a slice of default Plugins.
-func NewPlugins(in []string) []plugin.Plugin {
-	var plugins []plugin.Plugin
-	for _, pl := range in {
-		if p, exist := availablePlugins[pl]; exist {
-			plugins = append(plugins, p)
-		}
-	}
-	return plugins
-}
diff --git a/pilot/pkg/networking/plugin/registry/registry_test.go b/pilot/pkg/networking/plugin/registry/registry_test.go
deleted file mode 100644
index 638ea821fb..0000000000
--- a/pilot/pkg/networking/plugin/registry/registry_test.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package registry_test
-
-import (
-	"testing"
-
-	"istio.io/istio/pilot/pkg/networking/plugin/registry"
-)
-
-func TestPluginsNonValid(t *testing.T) {
-	expectedPlugins := []string{"abc"}
-	plugins := registry.NewPlugins(expectedPlugins)
-	if len(plugins) != 0 {
-		t.Errorf("expected length of plugins to be %d, but got %d", 0, len(plugins))
-	}
-}
diff --git a/pilot/pkg/security/authz/builder/builder.go b/pilot/pkg/security/authz/builder/builder.go
index ed77df3de0..e88dbb88fd 100644
--- a/pilot/pkg/security/authz/builder/builder.go
+++ b/pilot/pkg/security/authz/builder/builder.go
@@ -28,7 +28,6 @@
 
 	"istio.io/api/annotation"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	authzmodel "istio.io/istio/pilot/pkg/security/authz/model"
 	"istio.io/istio/pilot/pkg/security/trustdomain"
@@ -66,8 +65,7 @@ type Builder struct {
 
 // New returns a new builder for the given workload with the authorization policy.
 // Returns nil if none of the authorization policies are enabled for the workload.
-func New(trustDomainBundle trustdomain.Bundle, in *plugin.InputParams, option Option) *Builder {
-	policies := in.Push.AuthzPolicies.ListAuthorizationPolicies(in.Node.ConfigNamespace, in.Node.Metadata.Labels)
+func New(trustDomainBundle trustdomain.Bundle, push *model.PushContext, policies model.AuthorizationPoliciesResult, option Option) *Builder {
 	if option.IsCustomBuilder {
 		option.Logger.AppendDebugf("found %d CUSTOM actions", len(policies.Custom))
 		if len(policies.Custom) == 0 {
@@ -75,7 +73,7 @@ func New(trustDomainBundle trustdomain.Bundle, in *plugin.InputParams, option Op
 		}
 		return &Builder{
 			customPolicies:    policies.Custom,
-			extensions:        processExtensionProvider(in),
+			extensions:        processExtensionProvider(push),
 			trustDomainBundle: trustDomainBundle,
 			option:            option,
 		}
diff --git a/pilot/pkg/security/authz/builder/builder_test.go b/pilot/pkg/security/authz/builder/builder_test.go
index 8cbf0e53a9..b11dee8b2c 100644
--- a/pilot/pkg/security/authz/builder/builder_test.go
+++ b/pilot/pkg/security/authz/builder/builder_test.go
@@ -258,7 +258,8 @@ func TestGenerator_GenerateHTTP(t *testing.T) {
 			}
 			in := inputParams(t, baseDir+tc.input, tc.meshConfig, tc.version)
 			defer option.Logger.Report(in)
-			g := New(tc.tdBundle, in, option)
+			policies := in.Push.AuthzPolicies.ListAuthorizationPolicies(in.Node.ConfigNamespace, in.Node.Metadata.Labels)
+			g := New(tc.tdBundle, in.Push, policies, option)
 			if g == nil {
 				t.Fatalf("failed to create generator")
 			}
@@ -324,7 +325,8 @@ func TestGenerator_GenerateTCP(t *testing.T) {
 			}
 			in := inputParams(t, baseDir+tc.input, tc.meshConfig, nil)
 			defer option.Logger.Report(in)
-			g := New(tc.tdBundle, in, option)
+			policies := in.Push.AuthzPolicies.ListAuthorizationPolicies(in.Node.ConfigNamespace, in.Node.Metadata.Labels)
+			g := New(tc.tdBundle, in.Push, policies, option)
 			if g == nil {
 				t.Fatalf("failed to create generator")
 			}
diff --git a/pilot/pkg/security/authz/builder/extauthz.go b/pilot/pkg/security/authz/builder/extauthz.go
index 20d2994375..151a4b113b 100644
--- a/pilot/pkg/security/authz/builder/extauthz.go
+++ b/pilot/pkg/security/authz/builder/extauthz.go
@@ -34,7 +34,7 @@
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/extensionproviders"
-	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pilot/pkg/model"
 	authzmodel "istio.io/istio/pilot/pkg/security/authz/model"
 	"istio.io/istio/pkg/config/validation"
 )
@@ -70,9 +70,9 @@ type builtExtAuthz struct {
 	err  error
 }
 
-func processExtensionProvider(in *plugin.InputParams) map[string]*builtExtAuthz {
+func processExtensionProvider(push *model.PushContext) map[string]*builtExtAuthz {
 	resolved := map[string]*builtExtAuthz{}
-	for i, config := range in.Push.Mesh.ExtensionProviders {
+	for i, config := range push.Mesh.ExtensionProviders {
 		var errs error
 		if config.Name == "" {
 			errs = multierror.Append(errs, fmt.Errorf("extension provider name must not be empty, found empty at index: %d", i))
@@ -85,11 +85,11 @@ func processExtensionProvider(in *plugin.InputParams) map[string]*builtExtAuthz
 		switch p := config.Provider.(type) {
 		case *meshconfig.MeshConfig_ExtensionProvider_EnvoyExtAuthzHttp:
 			if err = validation.ValidateExtensionProviderEnvoyExtAuthzHTTP(p.EnvoyExtAuthzHttp); err == nil {
-				parsed, err = buildExtAuthzHTTP(in, p.EnvoyExtAuthzHttp)
+				parsed, err = buildExtAuthzHTTP(push, p.EnvoyExtAuthzHttp)
 			}
 		case *meshconfig.MeshConfig_ExtensionProvider_EnvoyExtAuthzGrpc:
 			if err = validation.ValidateExtensionProviderEnvoyExtAuthzGRPC(p.EnvoyExtAuthzGrpc); err == nil {
-				parsed, err = buildExtAuthzGRPC(in, p.EnvoyExtAuthzGrpc)
+				parsed, err = buildExtAuthzGRPC(push, p.EnvoyExtAuthzGrpc)
 			}
 		default:
 			continue
@@ -145,13 +145,14 @@ func getExtAuthz(resolved map[string]*builtExtAuthz, providers []string) (*built
 	return ret, nil
 }
 
-func buildExtAuthzHTTP(in *plugin.InputParams, config *meshconfig.MeshConfig_ExtensionProvider_EnvoyExternalAuthorizationHttpProvider) (*builtExtAuthz, error) {
+func buildExtAuthzHTTP(push *model.PushContext,
+	config *meshconfig.MeshConfig_ExtensionProvider_EnvoyExternalAuthorizationHttpProvider) (*builtExtAuthz, error) {
 	var errs error
 	port, err := parsePort(config.Port)
 	if err != nil {
 		errs = multierror.Append(errs, err)
 	}
-	hostname, cluster, err := extensionproviders.LookupCluster(in.Push, config.Service, port)
+	hostname, cluster, err := extensionproviders.LookupCluster(push, config.Service, port)
 	if err != nil {
 		errs = multierror.Append(errs, err)
 	}
@@ -186,13 +187,14 @@ func buildExtAuthzHTTP(in *plugin.InputParams, config *meshconfig.MeshConfig_Ext
 	return generateHTTPConfig(hostname, cluster, status, config), nil
 }
 
-func buildExtAuthzGRPC(in *plugin.InputParams, config *meshconfig.MeshConfig_ExtensionProvider_EnvoyExternalAuthorizationGrpcProvider) (*builtExtAuthz, error) {
+func buildExtAuthzGRPC(push *model.PushContext,
+	config *meshconfig.MeshConfig_ExtensionProvider_EnvoyExternalAuthorizationGrpcProvider) (*builtExtAuthz, error) {
 	var errs error
 	port, err := parsePort(config.Port)
 	if err != nil {
 		errs = multierror.Append(errs, err)
 	}
-	_, cluster, err := extensionproviders.LookupCluster(in.Push, config.Service, port)
+	_, cluster, err := extensionproviders.LookupCluster(push, config.Service, port)
 	if err != nil {
 		errs = multierror.Append(errs, err)
 	}
diff --git a/pilot/pkg/xds/discovery.go b/pilot/pkg/xds/discovery.go
index b13f95328e..7912f0baf4 100644
--- a/pilot/pkg/xds/discovery.go
+++ b/pilot/pkg/xds/discovery.go
@@ -160,8 +160,7 @@ type DiscoveryServer struct {
 }
 
 // NewDiscoveryServer creates DiscoveryServer that sources data from Pilot's internal mesh data structures
-func NewDiscoveryServer(env *model.Environment, plugins []string, instanceID string, systemNameSpace string,
-	clusterAliases map[string]string) *DiscoveryServer {
+func NewDiscoveryServer(env *model.Environment, instanceID string, clusterAliases map[string]string) *DiscoveryServer {
 	out := &DiscoveryServer{
 		Env:                 env,
 		Generators:          map[string]model.XdsResourceGenerator{},
@@ -197,7 +196,7 @@ func NewDiscoveryServer(env *model.Environment, plugins []string, instanceID str
 		out.EndpointIndex.SetCache(out.Cache)
 	}
 
-	out.ConfigGenerator = core.NewConfigGenerator(plugins, out.Cache)
+	out.ConfigGenerator = core.NewConfigGenerator(out.Cache)
 
 	return out
 }
diff --git a/pilot/pkg/xds/fake.go b/pilot/pkg/xds/fake.go
index 107ac874cf..6ce64ddda5 100644
--- a/pilot/pkg/xds/fake.go
+++ b/pilot/pkg/xds/fake.go
@@ -41,7 +41,6 @@
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/serviceregistry"
 	kube "istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
 	v3 "istio.io/istio/pilot/pkg/xds/v3"
@@ -127,8 +126,7 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 	}
 
 	// Init with a dummy environment, since we have a circular dependency with the env creation.
-	s := NewDiscoveryServer(&model.Environment{PushContext: model.NewPushContext()}, []string{plugin.AuthzCustom, plugin.Authn, plugin.Authz},
-		"pilot-123", "istio-system", map[string]string{})
+	s := NewDiscoveryServer(&model.Environment{PushContext: model.NewPushContext()}, "pilot-123", map[string]string{})
 	s.InitGenerators(s.Env, "istio-system")
 	t.Cleanup(func() {
 		s.JwtKeyResolver.Close()
diff --git a/pilot/pkg/xds/simple.go b/pilot/pkg/xds/simple.go
index 90dbfcb864..d59e29113b 100644
--- a/pilot/pkg/xds/simple.go
+++ b/pilot/pkg/xds/simple.go
@@ -78,7 +78,7 @@ func NewXDS(stop chan struct{}) *SimpleServer {
 	env.PushContext.Mesh = env.Watcher.Mesh()
 	env.Init()
 
-	ds := NewDiscoveryServer(env, nil, "istiod", "istio-system", map[string]string{})
+	ds := NewDiscoveryServer(env, "istiod", map[string]string{})
 	ds.InitGenerators(env, "istio-system")
 	ds.CachesSynced()
 
diff --git a/tests/fuzz/v1alpha3_fuzzer.go b/tests/fuzz/v1alpha3_fuzzer.go
index 130210ae1b..dd1a461935 100644
--- a/tests/fuzz/v1alpha3_fuzzer.go
+++ b/tests/fuzz/v1alpha3_fuzzer.go
@@ -30,11 +30,6 @@ func init() {
 }
 
 func ValidateTestOptions(to v1alpha3.TestOptions) error {
-	for _, plugin := range to.Plugins {
-		if plugin == nil {
-			return errors.New("a Plugin was nil")
-		}
-	}
 	for _, csc := range to.ConfigStoreCaches {
 		if csc == nil {
 			return errors.New("a ConfigStoreController was nil")
-- 
2.35.3

