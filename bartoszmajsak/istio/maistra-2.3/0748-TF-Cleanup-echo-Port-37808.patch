From 9fee95470769ad7f8ea7d725ba88f19dd8650b7c Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Tue, 8 Mar 2022 09:02:42 -0800
Subject: [TF] Cleanup echo Port (#37808)

We currently have Port and PortName and the former is a pointer. This leads to a lot of complexity to the logic. This PR removes PortName and makes Port a struct rather than a pointer.
---
 pkg/config/protocol/instance.go               |   4 +
 .../framework/components/echo/calloptions.go  | 148 ++++---
 .../framework/components/echo/common/call.go  |  17 +-
 .../components/echo/kube/instance.go          |   2 +-
 .../framework/components/istio/ingress.go     |  62 +--
 tests/integration/pilot/common/routing.go     | 361 +++++++++++-------
 tests/integration/pilot/common/traffic.go     |   2 +-
 tests/integration/pilot/ingress_test.go       |  42 +-
 tests/integration/pilot/locality_test.go      |   6 +-
 .../discoverability/discoverability_test.go   |  12 +-
 tests/integration/pilot/mirror_test.go        |   8 +-
 .../pilot/multi_version_revision_test.go      |   6 +-
 tests/integration/pilot/multicluster_test.go  |  19 +-
 .../pilot/original_src_addr_test.go           |  12 +-
 .../pilot/revisioned_upgrade_test.go          |   6 +-
 .../pilot/revisions/revisions_test.go         |   8 +-
 tests/integration/pilot/vm_test.go            |   2 +-
 .../security/authorization_test.go            |  85 +++--
 .../security/ca_custom_root/main_test.go      |   6 +-
 .../ca_custom_root/multi_root_test.go         |  10 +-
 .../ca_custom_root/secure_naming_test.go      |  19 +-
 .../trust_domain_alias_secure_naming_test.go  |  11 +-
 .../trust_domain_validation_test.go           |  10 +-
 .../mtls_strict_test.go                       |  12 +-
 .../egress_gateway_origination_test.go        |  10 +-
 .../security/external_ca/reachability_test.go |  10 +-
 .../file_mounted_certs/p2p_mtls_test.go       |   8 +-
 .../destination_rule_tls_test.go              |  15 +-
 .../egress_gateway_origination_test.go        |   6 +-
 .../security/https_jwt/https_jwt_test.go      |  10 +-
 tests/integration/security/jwt_test.go        |  21 +-
 .../mtls_first_party_jwt/strict_test.go       |   2 +-
 .../security/mtlsk8sca/strict_test.go         |   2 +-
 .../security/normalization_test.go            |   6 +-
 .../pass_through_filter_chain_test.go         | 116 +++---
 .../integration/security/reachability_test.go |  37 +-
 .../security/sds_ingress/util/util.go         |   2 +-
 tests/integration/security/util/cert/cert.go  |   8 +-
 .../security/util/reachability/context.go     |  32 +-
 .../security/util/scheck/checkers.go          |   4 +-
 .../telemetry/outboundtrafficpolicy/helper.go |   6 +-
 .../telemetry/policy/envoy_ratelimit_test.go  |   8 +-
 .../telemetry/stackdriver/common.go           |  22 +-
 .../stackdriver_filter_audit_test.go          |   6 +-
 .../stackdriver_tcp_filter_test.go            |   8 +-
 .../telemetry/stackdriver/vm/vm_test.go       |   8 +-
 .../customize_metrics_test.go                 |  14 +-
 .../prometheus/nullvm/accesslogs_test.go      |  16 +-
 .../stats/prometheus/nullvm/dashboard_test.go |   4 +-
 .../telemetry/stats/prometheus/stats.go       |  28 +-
 .../integration/telemetry/tracing/tracing.go  |   8 +-
 tests/util/sanitycheck/sanity_check.go        |   8 +-
 52 files changed, 764 insertions(+), 531 deletions(-)

diff --git a/pkg/config/protocol/instance.go b/pkg/config/protocol/instance.go
index 100d99f50e..94ae9dde8e 100644
--- a/pkg/config/protocol/instance.go
+++ b/pkg/config/protocol/instance.go
@@ -19,6 +19,10 @@
 // Instance defines network protocols for ports
 type Instance string
 
+func (i Instance) String() string {
+	return string(i)
+}
+
 const (
 	// GRPC declares that the port carries gRPC traffic.
 	GRPC Instance = "GRPC"
diff --git a/pkg/test/framework/components/echo/calloptions.go b/pkg/test/framework/components/echo/calloptions.go
index b1638be1d1..5666245455 100644
--- a/pkg/test/framework/components/echo/calloptions.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -92,18 +92,17 @@ type CallOptions struct {
 	// To is the Target to be called. Required.
 	To Instance
 
-	// Port on the target Instance. Either Port or PortName must be specified.
-	Port *Port
+	// Port to be used for the call. Ignored if Scheme == DNS. If the Port.ServicePort is set,
+	// either Port.Protocol or Scheme must also be set. If Port.ServicePort is not set,
+	// the port is looked up in To by either Port.Name or Port.Protocol.
+	Port Port
 
-	// PortName of the port on the target Instance. Either Port or PortName must be specified.
-	PortName string
-
-	// Scheme to be used when making the call. If not provided, an appropriate default for the
-	// port will be used (if feasible).
+	// Scheme to be used when making the call. If not provided, the Scheme will be selected
+	// based on the Port.Protocol.
 	Scheme scheme.Instance
 
 	// Address specifies the host name or IP address to be used on the request. If not provided,
-	// an appropriate default is chosen for the target Instance.
+	// an appropriate default is chosen for To.
 	Address string
 
 	// Count indicates the number of exchanges that should be made with the service endpoint.
@@ -161,10 +160,6 @@ func (o CallOptions) GetHost() string {
 
 func (o CallOptions) DeepCopy() CallOptions {
 	clone := o
-	if o.Port != nil {
-		dc := *o.Port
-		clone.Port = &dc
-	}
 	if o.TLS.Alpn != nil {
 		clone.TLS.Alpn = make([]string, len(o.TLS.Alpn))
 		copy(clone.TLS.Alpn, o.TLS.Alpn)
@@ -174,37 +169,101 @@ func (o CallOptions) DeepCopy() CallOptions {
 
 // FillDefaults fills out any defaults that haven't been explicitly specified.
 func (o *CallOptions) FillDefaults() error {
+	// Fill in the address if not set.
+	if err := o.fillAddress(); err != nil {
+		return err
+	}
+
+	// Fill in the port if not set or the service port is missing.
+	if err := o.fillPort(); err != nil {
+		return err
+	}
+
+	// Fill in the scheme if not set, using the port information.
+	if err := o.fillScheme(); err != nil {
+		return err
+	}
+
+	// Fill in HTTP headers
+	o.fillHeaders()
+
+	if o.Timeout <= 0 {
+		o.Timeout = common.DefaultRequestTimeout
+	}
+
+	if o.Count <= 0 {
+		o.Count = common.DefaultCount
+	}
+
+	// Add any user-specified options after the default options (last option wins for each type of option).
+	o.Retry.Options = append(append([]retry.Option{}, DefaultCallRetryOptions()...), o.Retry.Options...)
+
+	// If no Check was specified, assume no error.
+	if o.Check == nil {
+		o.Check = check.None()
+	}
+	return nil
+}
+
+func (o *CallOptions) fillAddress() error {
+	if o.Address == "" {
+		if o.To == nil {
+			return errors.New("if address is not set, then To must be set")
+		}
+
+		// No host specified, use the fully qualified domain name for the service.
+		o.Address = o.To.Config().ClusterLocalFQDN()
+	}
+	return nil
+}
+
+func (o *CallOptions) fillPort() error {
+	if o.Scheme == scheme.DNS {
+		// Port is not used for DNS.
+		return nil
+	}
+
+	if o.Port.ServicePort > 0 {
+		if o.Port.Protocol == "" && o.Scheme == "" {
+			return errors.New("callOptions: servicePort specified, but no protocol or scheme was set")
+		}
+
+		// The service port was set explicitly. Nothing else to do.
+		return nil
+	}
+
 	if o.To != nil {
 		servicePorts := o.To.Config().Ports.GetServicePorts()
-		if o.PortName == "" {
-			// Validate the Port value.
 
-			if o.Port == nil {
-				return errors.New("callOptions: PortName or Port must be provided")
+		if o.Port.Name != "" {
+			// Look up the port by name.
+			p, found := servicePorts.ForName(o.Port.Name)
+			if !found {
+				return fmt.Errorf("callOptions: no port named %s available in To Instance", o.Port.Name)
 			}
+			o.Port = p
+			return nil
+		}
 
-			// Check the specified port for a match against the To Instance
-			if !servicePorts.Contains(*o.Port) {
-				return fmt.Errorf("callOptions: Port does not match any To port")
-			}
-		} else {
-			// Look up the port.
-			p, found := servicePorts.ForName(o.PortName)
+		if o.Port.Protocol != "" {
+			// Look up the port by protocol.
+			p, found := servicePorts.ForProtocol(o.Port.Protocol)
 			if !found {
-				return fmt.Errorf("callOptions: no port named %s available in To Instance", o.PortName)
+				return fmt.Errorf("callOptions: no port for protocol %s available in To Instance", o.Port.Protocol)
 			}
-			o.Port = &p
-		}
-	} else if o.Scheme == scheme.DNS {
-		// Just need address
-		if o.Address == "" {
-			return fmt.Errorf("for DNS, address must be set")
+			o.Port = p
+			return nil
 		}
-		o.Port = &Port{}
-	} else if o.Port == nil || o.Port.ServicePort <= 0 || (o.Port.Protocol == "" && o.Scheme == "") || o.Address == "" {
+	}
+
+	if o.Port.ServicePort <= 0 || (o.Port.Protocol == "" && o.Scheme == "") || o.Address == "" {
 		return fmt.Errorf("if target is not set, then port.servicePort, port.protocol or schema, and address must be set")
 	}
 
+	return nil
+}
+
+func (o *CallOptions) fillScheme() error {
 	if o.Scheme == "" {
 		// No protocol, fill it in.
 		var err error
@@ -212,12 +271,10 @@ func (o *CallOptions) FillDefaults() error {
 			return err
 		}
 	}
+	return nil
+}
 
-	if o.Address == "" {
-		// No host specified, use the fully qualified domain name for the service.
-		o.Address = o.To.Config().ClusterLocalFQDN()
-	}
-
+func (o *CallOptions) fillHeaders() {
 	// Initialize the headers and add a default Host header if none provided.
 	if o.HTTP.Headers == nil {
 		o.HTTP.Headers = make(http.Header)
@@ -229,21 +286,4 @@ func (o *CallOptions) FillDefaults() error {
 	if h := o.GetHost(); len(h) > 0 {
 		o.HTTP.Headers.Set(headers.Host, h)
 	}
-
-	if o.Timeout <= 0 {
-		o.Timeout = common.DefaultRequestTimeout
-	}
-
-	if o.Count <= 0 {
-		o.Count = common.DefaultCount
-	}
-
-	// Add any user-specified options after the default options (last option wins for each type of option).
-	o.Retry.Options = append(append([]retry.Option{}, DefaultCallRetryOptions()...), o.Retry.Options...)
-
-	// If no Check was specified, assume no error.
-	if o.Check == nil {
-		o.Check = check.None()
-	}
-	return nil
 }
diff --git a/pkg/test/framework/components/echo/common/call.go b/pkg/test/framework/components/echo/common/call.go
index 385ac2954f..9d47eeb160 100644
--- a/pkg/test/framework/components/echo/common/call.go
+++ b/pkg/test/framework/components/echo/common/call.go
@@ -156,16 +156,13 @@ func ForwardEcho(srcName string, clientProvider EchoClientProvider, opts *echo.C
 		return c.ForwardEcho(context.Background(), req)
 	})
 	if err != nil {
-		if opts.Port != nil {
-			err = fmt.Errorf("failed calling %s->'%s://%s:%d/%s': %v",
-				srcName,
-				strings.ToLower(string(opts.Port.Protocol)),
-				opts.Address,
-				opts.Port.ServicePort,
-				opts.HTTP.Path,
-				err)
-		}
-		return nil, err
+		return nil, fmt.Errorf("failed calling %s->'%s://%s:%d/%s': %v",
+			srcName,
+			strings.ToLower(string(opts.Port.Protocol)),
+			opts.Address,
+			opts.Port.ServicePort,
+			opts.HTTP.Path,
+			err)
 	}
 	return res, nil
 }
diff --git a/pkg/test/framework/components/echo/kube/instance.go b/pkg/test/framework/components/echo/kube/instance.go
index 1b690ab959..86bb16610e 100644
--- a/pkg/test/framework/components/echo/kube/instance.go
+++ b/pkg/test/framework/components/echo/kube/instance.go
@@ -193,7 +193,7 @@ func (c *instance) Restart() error {
 // aggregateResponses forwards an echo request from all workloads belonging to this echo instance and aggregates the results.
 func (c *instance) aggregateResponses(opts echo.CallOptions) (echoClient.Responses, error) {
 	// TODO put this somewhere else, or require users explicitly set the protocol - quite hacky
-	if c.Config().IsProxylessGRPC() && (opts.Scheme == scheme.GRPC || opts.PortName == "grpc" || opts.Port != nil && opts.Port.Protocol == protocol.GRPC) {
+	if c.Config().IsProxylessGRPC() && (opts.Scheme == scheme.GRPC || opts.Port.Name == "grpc" || opts.Port.Protocol == protocol.GRPC) {
 		// for gRPC calls, use XDS resolver
 		opts.Scheme = scheme.XDS
 	}
diff --git a/pkg/test/framework/components/istio/ingress.go b/pkg/test/framework/components/istio/ingress.go
index d2cb2c54fd..d6c6156f4b 100644
--- a/pkg/test/framework/components/istio/ingress.go
+++ b/pkg/test/framework/components/istio/ingress.go
@@ -22,10 +22,10 @@
 	"strconv"
 	"time"
 
-	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
@@ -182,51 +182,67 @@ func (c *ingressImpl) CallOrFail(t test.Failer, options echo.CallOptions) echoCl
 	return resp
 }
 
-func (c *ingressImpl) callEcho(options echo.CallOptions) (echoClient.Responses, error) {
-	if options.Port == nil || options.Port.Protocol == "" {
-		return nil, fmt.Errorf("must provide protocol")
-	}
+func (c *ingressImpl) callEcho(opts echo.CallOptions) (echoClient.Responses, error) {
 	var (
 		addr string
 		port int
 	)
-	options = options.DeepCopy()
-	if options.Port.ServicePort == 0 {
+	opts = opts.DeepCopy()
+
+	if opts.Port.ServicePort == 0 {
+		s, err := c.schemeFor(opts)
+		if err != nil {
+			return nil, err
+		}
+		opts.Scheme = s
+
 		// Default port based on protocol
-		switch options.Port.Protocol {
-		case protocol.HTTP:
+		switch s {
+		case scheme.HTTP:
 			addr, port = c.HTTPAddress()
-		case protocol.HTTPS:
+		case scheme.HTTPS:
 			addr, port = c.HTTPSAddress()
-		case protocol.TCP:
+		case scheme.TCP:
 			addr, port = c.TCPAddress()
 		default:
-			return nil, fmt.Errorf("protocol %v not supported, provide explicit port", options.Port.Protocol)
+			return nil, fmt.Errorf("ingress: scheme %v not supported. Options: %v+", s, opts)
 		}
 	} else {
-		addr, port = c.AddressForPort(options.Port.ServicePort)
+		addr, port = c.AddressForPort(opts.Port.ServicePort)
 	}
 
 	if addr == "" || port == 0 {
-		scopes.Framework.Warnf("failed to get host and port for %s/%d", options.Port.Protocol, options.Port.ServicePort)
+		scopes.Framework.Warnf("failed to get host and port for %s/%d", opts.Port.Protocol, opts.Port.ServicePort)
 	}
 
 	// Even if they set ServicePort, when load balancer is disabled, we may need to switch to NodePort, so replace it.
-	options.Port.ServicePort = port
-	if len(options.Address) == 0 {
+	opts.Port.ServicePort = port
+	if len(opts.Address) == 0 {
 		// Default address based on port
-		options.Address = addr
+		opts.Address = addr
 	}
-	if options.HTTP.Headers == nil {
-		options.HTTP.Headers = map[string][]string{}
+	if opts.HTTP.Headers == nil {
+		opts.HTTP.Headers = map[string][]string{}
 	}
-	if host := options.GetHost(); len(host) > 0 {
-		options.HTTP.Headers.Set(headers.Host, host)
+	if host := opts.GetHost(); len(host) > 0 {
+		opts.HTTP.Headers.Set(headers.Host, host)
 	}
 	if len(c.cluster.HTTPProxy()) > 0 {
-		options.HTTP.HTTPProxy = c.cluster.HTTPProxy()
+		opts.HTTP.HTTPProxy = c.cluster.HTTPProxy()
 	}
-	return common.CallEcho(&options)
+	return common.CallEcho(&opts)
+}
+
+func (c *ingressImpl) schemeFor(opts echo.CallOptions) (scheme.Instance, error) {
+	if opts.Scheme == "" && opts.Port.Protocol == "" {
+		return "", fmt.Errorf("must provide either protocol or scheme")
+	}
+
+	if opts.Scheme != "" {
+		return opts.Scheme, nil
+	}
+
+	return opts.Port.Scheme()
 }
 
 func (c *ingressImpl) ProxyStats() (map[string]int, error) {
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 577a5bc4e9..60a4e54d38 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -153,8 +153,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
         add:
           istio-custom-header: user-defined-value`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.RequestHeader("Istio-Custom-Header", "user-defined-value")),
@@ -180,8 +182,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
         set:
           x-custom: some-value`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.RequestHeader("X-Custom", "some-value")),
@@ -207,8 +211,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
         set:
           :authority: my-custom-authority`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("my-custom-authority")),
@@ -235,8 +241,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
           set:
             Host: my-custom-authority`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("my-custom-authority")),
@@ -267,8 +275,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
         set:
           :authority: route-authority`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("route-authority")),
@@ -303,8 +313,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
         set:
           :authority: route-authority`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("route-authority")),
@@ -339,8 +351,10 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
             Host: dest-authority
       weight: 50`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("dest-authority")),
@@ -371,7 +385,9 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
     - destination:
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
-				PortName: "http",
+				Port: echo.Port{
+					Name: "http",
+				},
 				HTTP: echo.HTTP{
 					Path:            "/foo?key=value",
 					FollowRedirects: true,
@@ -402,7 +418,9 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
       scheme: https
 `,
 			opts: echo.CallOptions{
-				PortName: "http",
+				Port: echo.Port{
+					Name: "http",
+				},
 				HTTP: echo.HTTP{
 					Path:            "/foo",
 					FollowRedirects: false,
@@ -443,7 +461,9 @@ func(r echoClient.Response) error {
     - destination:
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
-				PortName: "http",
+				Port: echo.Port{
+					Name: "http",
+				},
 				HTTP: echo.HTTP{
 					Path: "/foo?key=value#hash",
 				},
@@ -474,7 +494,9 @@ func(r echoClient.Response) error {
     - destination:
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
-				PortName: "http",
+				Port: echo.Port{
+					Name: "http",
+				},
 				HTTP: echo.HTTP{
 					Path: "/foo",
 				},
@@ -518,7 +540,9 @@ func(r echoClient.Response) error {
 					name: "preflight",
 					opts: func() echo.CallOptions {
 						return echo.CallOptions{
-							PortName: "http",
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Method: "OPTIONS",
 								Headers: headers.New().
@@ -542,7 +566,9 @@ func(r echoClient.Response) error {
 					name: "get",
 					opts: func() echo.CallOptions {
 						return echo.CallOptions{
-							PortName: "http",
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Headers: headers.New().With(headers.Origin, "cors.com").Build(),
 							},
@@ -557,8 +583,10 @@ func(r echoClient.Response) error {
 					// GET without matching origin
 					name: "get no origin match",
 					opts: echo.CallOptions{
-						PortName: "http",
-						Count:    1,
+						Port: echo.Port{
+							Name: "http",
+						},
+						Count: 1,
 						Check: check.And(
 							check.OK(),
 							check.ResponseHeader("Access-Control-Allow-Origin", "")),
@@ -589,9 +617,11 @@ func(r echoClient.Response) error {
       retryOn: gateway-error,connect-failure,refused-stream
       retryRemoteLocalities: true`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
-				Check:    check.OK(),
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
+				Check: check.OK(),
 			},
 			workloadAgnostic: true,
 		},
@@ -615,9 +645,11 @@ func(r echoClient.Response) error {
           value: 100
         httpStatus: 418`,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
-				Check:    check.Status(http.StatusTeapot),
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
+				Check: check.Status(http.StatusTeapot),
 			},
 			workloadAgnostic: true,
 		},
@@ -713,12 +745,14 @@ func(responses echoClient.Responses, err error) error {
 			setupOpts: func(src echo.Caller, dest echo.Instances, opts *echo.CallOptions) {
 				// TODO force this globally in echotest?
 				if src, ok := src.(echo.Instance); ok && src.Config().IsProxylessGRPC() {
-					opts.PortName = "grpc"
+					opts.Port.Name = "grpc"
 				}
 			},
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    100,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 100,
 			},
 			workloadAgnostic: true,
 		})
@@ -763,7 +797,7 @@ func tlsOriginationCases(apps *EchoDeployments) []TrafficTestCase {
 			tc.children = append(tc.children, TrafficCall{
 				name: fmt.Sprintf("%s: %s", c.Config().Cluster.StableName(), e.alpn),
 				opts: echo.CallOptions{
-					Port:    &echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
+					Port:    echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
 					Count:   1,
 					Address: apps.External[0].Address(),
 					HTTP: echo.HTTP{
@@ -792,9 +826,11 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 			config: useClientProtocolDestinationRule(destination.Config().Service),
 			call:   client[0].CallOrFail,
 			opts: echo.CallOptions{
-				To:       destination,
-				PortName: "http",
-				Count:    1,
+				To: destination,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				HTTP: echo.HTTP{
 					HTTP2: true,
 				},
@@ -810,9 +846,11 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 			config: useClientProtocolDestinationRule(destination.Config().Service),
 			call:   client[0].CallOrFail,
 			opts: echo.CallOptions{
-				PortName: "http",
-				Count:    1,
-				To:       destination,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
+				To:    destination,
 				HTTP: echo.HTTP{
 					HTTP2: false,
 				},
@@ -838,9 +876,11 @@ func destinationRuleCases(apps *EchoDeployments) []TrafficTestCase {
 			config: idletimeoutDestinationRule("idletimeout-dr", destination.Config().Service),
 			call:   client[0].CallOrFail,
 			opts: echo.CallOptions{
-				To:       destination,
-				PortName: "http",
-				Count:    1,
+				To: destination,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
 				HTTP: echo.HTTP{
 					HTTP2: true,
 				},
@@ -916,7 +956,7 @@ func autoPassthroughCases(apps *EchoDeployments) []TrafficTestCase {
 					name: fmt.Sprintf("mode:%v,sni:%v,alpn:%v", mode, sni, alpn),
 					call: apps.Ingress.CallOrFail,
 					opts: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							ServicePort: 443,
 							Protocol:    protocol.HTTPS,
 						},
@@ -1004,7 +1044,7 @@ func gatewayCases() []TrafficTestCase {
 			config:           httpGateway("*"),
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				HTTP: echo.HTTP{
@@ -1039,7 +1079,7 @@ func gatewayCases() []TrafficTestCase {
 `,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				Check: check.Status(http.StatusMovedPermanently),
@@ -1097,7 +1137,7 @@ func gatewayCases() []TrafficTestCase {
 ` + httpVirtualServiceTmpl,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				HTTP: echo.HTTP{
@@ -1128,7 +1168,7 @@ func gatewayCases() []TrafficTestCase {
 			setupOpts: fqdnHostHeader,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTPS,
 				},
 			},
@@ -1161,7 +1201,7 @@ func gatewayCases() []TrafficTestCase {
 ` + httpVirtualServiceTmpl,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				Check: check.Status(http.StatusMovedPermanently),
@@ -1228,7 +1268,7 @@ func gatewayCases() []TrafficTestCase {
 ` + httpVirtualServiceTmpl,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				HTTP: echo.HTTP{
@@ -1271,7 +1311,7 @@ func gatewayCases() []TrafficTestCase {
 ` + httpVirtualServiceTmpl,
 			opts: echo.CallOptions{
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				Check: check.And(
@@ -1315,7 +1355,7 @@ func gatewayCases() []TrafficTestCase {
 					HTTP2: true,
 				},
 				Count: 1,
-				Port: &echo.Port{
+				Port: echo.Port{
 					Protocol: protocol.HTTP,
 				},
 				Check: check.And(
@@ -1374,7 +1414,7 @@ func gatewayCases() []TrafficTestCase {
 							HTTP2: h2,
 						},
 						Count: 1,
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						Check: check.And(
@@ -1413,7 +1453,7 @@ func gatewayCases() []TrafficTestCase {
 				setupOpts: fqdnHostHeader,
 				opts: echo.CallOptions{
 					Count: 1,
-					Port: &echo.Port{
+					Port: echo.Port{
 						Protocol: proto,
 					},
 				},
@@ -1431,7 +1471,7 @@ func gatewayCases() []TrafficTestCase {
 				setupOpts: fqdnHostHeader,
 				opts: echo.CallOptions{
 					Count: 1,
-					Port: &echo.Port{
+					Port: echo.Port{
 						Protocol: proto,
 					},
 					Check: check.And(
@@ -1469,7 +1509,7 @@ func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
 			call:   apps.Naked[0].CallOrFail,
 			opts: echo.CallOptions{
 				Count:   1,
-				Port:    &echo.Port{ServicePort: 80},
+				Port:    echo.Port{ServicePort: 80},
 				Scheme:  scheme.HTTP,
 				Address: gateway,
 				HTTP: echo.HTTP{
@@ -1608,8 +1648,10 @@ function envoy_on_request(request_handle)
 			config: cfg,
 			call:   c.CallOrFail,
 			opts: echo.CallOptions{
-				PortName: "http",
-				To:       apps.PodB[0],
+				To: apps.PodB[0],
+				Port: echo.Port{
+					Name: "http",
+				},
 				Check: check.And(
 					check.OK(),
 					check.Protocol("HTTP/2.0"),
@@ -1661,8 +1703,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallOrFail,
 				opts: echo.CallOptions{
-					PortName: "auto-http",
-					To:       apps.Headless[0],
+					To: apps.Headless[0],
+					Port: echo.Port{
+						Name: "auto-http",
+					},
 					HTTP: echo.HTTP{
 						Headers: HostHeader(h),
 					},
@@ -1692,8 +1736,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallOrFail,
 				opts: echo.CallOptions{
-					PortName: "http",
-					To:       apps.Headless[0],
+					To: apps.Headless[0],
+					Port: echo.Port{
+						Name: "http",
+					},
 					HTTP: echo.HTTP{
 						Headers: HostHeader(h),
 					},
@@ -1743,7 +1789,7 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:   1,
 				Address: "b-alt-1",
-				Port:    &echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
+				Port:    echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
 				Timeout: time.Millisecond * 100,
 				Check:   check.OK(),
 			},
@@ -1772,7 +1818,7 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:   1,
 				Address: "b-alt-2",
-				Port:    &echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.TCP},
+				Port:    echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.TCP},
 				Scheme:  scheme.TCP,
 				Timeout: time.Millisecond * 100,
 				Check:   check.OK(),
@@ -1801,7 +1847,7 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:   1,
 				Address: "b-alt-3",
-				Port:    &echo.Port{ServicePort: 12345, Protocol: protocol.HTTP},
+				Port:    echo.Port{ServicePort: 12345, Protocol: protocol.HTTP},
 				Timeout: time.Millisecond * 100,
 				Check:   check.OK(),
 			},
@@ -1829,7 +1875,7 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:   1,
 				Address: "b-alt-4",
-				Port:    &echo.Port{ServicePort: 12346, Protocol: protocol.HTTP},
+				Port:    echo.Port{ServicePort: 12346, Protocol: protocol.HTTP},
 				Timeout: time.Millisecond * 100,
 				Check:   check.OK(),
 			},
@@ -1902,7 +1948,7 @@ func consistentHashCases(apps *EchoDeployments) []TrafficTestCase {
 				opts: echo.CallOptions{
 					Count:   10,
 					Address: svcName,
-					Port:    &echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
+					Port:    echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
 					Check: check.And(
 						check.OK(),
 						func(responses echoClient.Responses, rerr error) error {
@@ -1922,7 +1968,7 @@ func(responses echoClient.Responses, rerr error) error {
 					Path:    "/?some-query-param=bar",
 					Headers: headers.New().With("x-some-header", "baz").Build(),
 				},
-				Port: &echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
+				Port: echo.Port{ServicePort: common.Ports.MustForName("http").ServicePort, Protocol: protocol.HTTP},
 				Check: check.And(
 					check.OK(),
 					ConsistentHostChecker,
@@ -1931,14 +1977,14 @@ func(responses echoClient.Responses, rerr error) error {
 			tcpCallopts := echo.CallOptions{
 				Count:   10,
 				Address: svcName,
-				Port:    &echo.Port{ServicePort: common.Ports.MustForName("tcp").ServicePort, Protocol: protocol.TCP},
+				Port:    echo.Port{ServicePort: common.Ports.MustForName("tcp").ServicePort, Protocol: protocol.TCP},
 				Check: check.And(
 					check.OK(),
 					ConsistentHostChecker,
 				),
 			}
 			if c.Config().WorkloadClass() == echo.Proxyless {
-				callOpts.Port = &echo.Port{ServicePort: common.Ports.MustForName("grpc").ServicePort, Protocol: protocol.GRPC}
+				callOpts.Port = echo.Port{ServicePort: common.Ports.MustForName("grpc").ServicePort, Protocol: protocol.GRPC}
 			}
 			// Setup tests for various forms of the API
 			// TODO: it may be necessary to vary the inputs of the hash and ensure we get a different backend
@@ -2000,8 +2046,10 @@ func selfCallsCases() []TrafficTestCase {
 			name:             "to service",
 			workloadAgnostic: true,
 			opts: echo.CallOptions{
-				Count:    1,
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name: "http",
+				},
 				Check: check.And(
 					check.OK(),
 					check.RequestHeader("X-Envoy-Attempt-Count", "1")),
@@ -2018,7 +2066,7 @@ func selfCallsCases() []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:   1,
 				Address: "localhost",
-				Port:    &echo.Port{ServicePort: 8080},
+				Port:    echo.Port{ServicePort: 8080},
 				Scheme:  scheme.HTTP,
 				Check: check.And(
 					check.OK(),
@@ -2039,7 +2087,7 @@ func selfCallsCases() []TrafficTestCase {
 			opts: echo.CallOptions{
 				Count:  1,
 				Scheme: scheme.HTTP,
-				Port:   &echo.Port{ServicePort: 8080},
+				Port:   echo.Port{ServicePort: 8080},
 				Check: check.And(
 					check.OK(),
 					check.RequestHeader("X-Envoy-Attempt-Count", "")),
@@ -2090,10 +2138,12 @@ type protocolCase struct {
 			skip: call.scheme == scheme.TCP,
 			name: call.port,
 			opts: echo.CallOptions{
-				Count:    1,
-				PortName: call.port,
-				Scheme:   call.scheme,
-				Timeout:  time.Second * 5,
+				Count: 1,
+				Port: echo.Port{
+					Name: call.port,
+				},
+				Scheme:  call.scheme,
+				Timeout: time.Second * 5,
 			},
 			check: func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) check.Checker {
 				if call.scheme == scheme.TCP || src.(echo.Instance).Config().IsProxylessGRPC() {
@@ -2128,10 +2178,12 @@ type protocolCase struct {
 		name: "http10 to http",
 		call: apps.PodA[0].CallOrFail,
 		opts: echo.CallOptions{
-			To:       apps.PodB[0],
-			Count:    1,
-			PortName: "http",
-			Scheme:   scheme.TCP,
+			To:    apps.PodB[0],
+			Count: 1,
+			Port: echo.Port{
+				Name: "http",
+			},
+			Scheme: scheme.TCP,
 			Message: `GET / HTTP/1.0
 `,
 			Timeout: time.Second * 5,
@@ -2145,10 +2197,12 @@ type protocolCase struct {
 			name: "http10 to auto",
 			call: apps.PodA[0].CallOrFail,
 			opts: echo.CallOptions{
-				To:       apps.PodB[0],
-				Count:    1,
-				PortName: "auto-http",
-				Scheme:   scheme.TCP,
+				To:    apps.PodB[0],
+				Count: 1,
+				Port: echo.Port{
+					Name: "auto-http",
+				},
+				Scheme: scheme.TCP,
 				Message: `GET / HTTP/1.0
 `,
 				Timeout: time.Second * 5,
@@ -2166,10 +2220,9 @@ type protocolCase struct {
 				HTTP: echo.HTTP{
 					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
 				},
-				Port:     &httpPort,
-				Count:    1,
-				PortName: "http",
-				Scheme:   scheme.TCP,
+				Port:   httpPort,
+				Count:  1,
+				Scheme: scheme.TCP,
 				Message: `GET / HTTP/1.0
 `,
 				Timeout: time.Second * 5,
@@ -2187,7 +2240,7 @@ type protocolCase struct {
 				HTTP: echo.HTTP{
 					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
 				},
-				Port:   &autoPort,
+				Port:   autoPort,
 				Count:  1,
 				Scheme: scheme.TCP,
 				Message: `GET / HTTP/1.0
@@ -2349,12 +2402,14 @@ func instanceIPTests(apps *EchoDeployments) []TrafficTestCase {
 					call:   client.CallOrFail,
 					config: config,
 					opts: echo.CallOptions{
-						Count:    1,
-						To:       destination,
-						PortName: ipCase.port,
-						Scheme:   scheme.HTTP,
-						Timeout:  time.Second * 5,
-						Check:    check.Status(ipCase.code),
+						Count: 1,
+						To:    destination,
+						Port: echo.Port{
+							Name: ipCase.port,
+						},
+						Scheme:  scheme.HTTP,
+						Timeout: time.Second * 5,
+						Check:   check.Status(ipCase.code),
 					},
 					minIstioVersion: ipCase.minIstioVersion,
 				})
@@ -2632,11 +2687,13 @@ func VMTestCases(vms echo.Instances, apps *EchoDeployments) []TrafficTestCase {
 			call: c.from.CallOrFail,
 			opts: echo.CallOptions{
 				// assume that all echos in `to` only differ in which cluster they're deployed in
-				To:       c.to[0],
-				PortName: "http",
-				Address:  c.host,
-				Count:    callsPerCluster * len(c.to),
-				Check:    checker,
+				To: c.to[0],
+				Port: echo.Port{
+					Name: "http",
+				},
+				Address: c.host,
+				Count:   callsPerCluster * len(c.to),
+				Check:   checker,
 			},
 		})
 	}
@@ -2767,9 +2824,11 @@ func serverFirstTestCases(apps *EchoDeployments) []TrafficTestCase {
 				config: destinationRule(destination.Config().Service, c.dest) + peerAuthentication(destination.Config().Service, c.auth),
 				call:   client.CallOrFail,
 				opts: echo.CallOptions{
-					To:       destination,
-					PortName: c.port,
-					Scheme:   scheme.TCP,
+					To: destination,
+					Port: echo.Port{
+						Name: c.port,
+					},
+					Scheme: scheme.TCP,
 					// Inbound timeout is 1s. We want to test this does not hit the listener filter timeout
 					Timeout: time.Millisecond * 100,
 					Count:   1,
@@ -2876,9 +2935,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -2897,9 +2958,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -2921,9 +2984,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -2942,9 +3007,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -2963,9 +3030,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -2985,9 +3054,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -3009,9 +3080,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -3030,9 +3103,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
@@ -3051,9 +3126,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headersWithInvalidToken,
 				},
@@ -3072,9 +3149,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headersWithNoToken,
 				},
@@ -3093,9 +3172,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
 					Headers: headersWithNoTokenButSameHeader,
@@ -3115,9 +3196,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:    1,
-				Port:     &echo.Port{Protocol: protocol.HTTP},
-				PortName: "http",
+				Count: 1,
+				Port: echo.Port{
+					Name:     "http",
+					Protocol: protocol.HTTP,
+				},
 				HTTP: echo.HTTP{
 					Headers: headers,
 				},
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index e6e2511147..3372d14ee5 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -105,7 +105,7 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 		t.Fatal("TrafficTestCase.RunForApps: call must not be specified")
 	}
 	// just check if any of the required fields are set
-	optsSpecified := c.opts.Port != nil || c.opts.PortName != "" || c.opts.Scheme != ""
+	optsSpecified := c.opts.Port.Name != "" || c.opts.Scheme != ""
 	if optsSpecified && len(c.children) > 0 {
 		t.Fatal("TrafficTestCase: must not specify both opts and children")
 	}
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index 58c16c2305..1a0202ef42 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -193,7 +193,7 @@ func TestGateway(t *testing.T) {
 						paths := []string{"/get", "/get/", "/get/prefix"}
 						for _, path := range paths {
 							_ = apps.Ingress.CallOrFail(t, echo.CallOptions{
-								Port: &echo.Port{
+								Port: echo.Port{
 									Protocol: protocol.HTTP,
 								},
 								HTTP: echo.HTTP{
@@ -205,7 +205,7 @@ func TestGateway(t *testing.T) {
 					})
 					t.NewSubTest("tcp").Run(func(t framework.TestContext) {
 						_ = apps.Ingress.CallOrFail(t, echo.CallOptions{
-							Port: &echo.Port{
+							Port: echo.Port{
 								Protocol:    protocol.HTTP,
 								ServicePort: 31400,
 							},
@@ -217,8 +217,10 @@ func TestGateway(t *testing.T) {
 					})
 					t.NewSubTest("mesh").Run(func(t framework.TestContext) {
 						_ = apps.PodA[0].CallOrFail(t, echo.CallOptions{
-							To:       apps.PodB[0],
-							PortName: "http",
+							To: apps.PodB[0],
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/path",
 							},
@@ -266,7 +268,7 @@ func TestGateway(t *testing.T) {
       port: 80
 `).ApplyOrFail(t, apps.Namespace.Name())
 					apps.PodB[0].CallOrFail(t, echo.CallOptions{
-						Port:   &echo.Port{ServicePort: 80},
+						Port:   echo.Port{ServicePort: 80},
 						Scheme: scheme.HTTP,
 						HTTP: echo.HTTP{
 							Headers: headers.New().WithHost("bar.example.com").Build(),
@@ -397,7 +399,7 @@ func TestIngress(t *testing.T) {
 					// Basic HTTP call
 					name: "http",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -414,7 +416,7 @@ func TestIngress(t *testing.T) {
 					// Prefix /prefix/should MATCHES prefix/should/match
 					name: "http-prefix-matches-subpath",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -431,7 +433,7 @@ func TestIngress(t *testing.T) {
 					// Prefix /prefix/test/ should match path /prefix/test
 					name: "http-prefix-matches-without-trailing-backslash",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -448,7 +450,7 @@ func TestIngress(t *testing.T) {
 					// Prefix /prefix/test should match /prefix/test/
 					name: "http-prefix-matches-trailing-blackslash",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -465,7 +467,7 @@ func TestIngress(t *testing.T) {
 					// Prefix /prefix/test should NOT match /prefix/testrandom
 					name: "http-prefix-should-not-match-path-continuation",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -482,7 +484,7 @@ func TestIngress(t *testing.T) {
 					// Prefix / should match any path
 					name: "http-root-prefix-should-match-random-path",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -499,7 +501,7 @@ func TestIngress(t *testing.T) {
 					// Basic HTTPS call for foo. CaCert matches the secret
 					name: "https-foo",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTPS,
 						},
 						HTTP: echo.HTTP{
@@ -519,7 +521,7 @@ func TestIngress(t *testing.T) {
 					// Basic HTTPS call for bar. CaCert matches the secret
 					name: "https-bar",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTPS,
 						},
 						HTTP: echo.HTTP{
@@ -539,7 +541,7 @@ func TestIngress(t *testing.T) {
 					// HTTPS call for bar with namedport route. CaCert matches the secret
 					name: "https-namedport",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTPS,
 						},
 						HTTP: echo.HTTP{
@@ -646,7 +648,7 @@ func TestIngress(t *testing.T) {
 					ingressClass: "not-istio",
 					path:         "/update-test",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -667,7 +669,7 @@ func TestIngress(t *testing.T) {
 					ingressClass: "istio-test",
 					path:         "/update-test",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -682,7 +684,7 @@ func TestIngress(t *testing.T) {
 					ingressClass: "istio-test",
 					path:         "/updated",
 					call: echo.CallOptions{
-						Port: &echo.Port{
+						Port: echo.Port{
 							Protocol: protocol.HTTP,
 						},
 						HTTP: echo.HTTP{
@@ -802,7 +804,7 @@ func TestCustomGateway(t *testing.T) {
 					return err
 				}, retry.Timeout(time.Minute*2))
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
-					Port:    &echo.Port{ServicePort: 80},
+					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("custom-gateway.%s.svc.cluster.local", gatewayNs.Name()),
 					Check:   check.OK(),
@@ -875,7 +877,7 @@ func TestCustomGateway(t *testing.T) {
           number: 80
 `, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(gatewayNs.Name(), resource.NoCleanup)
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
-					Port:    &echo.Port{ServicePort: 80},
+					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("custom-gateway-helm.%s.svc.cluster.local", gatewayNs.Name()),
 					Check:   check.OK(),
@@ -942,7 +944,7 @@ func TestCustomGateway(t *testing.T) {
           number: 80
 `, apps.PodA[0].Config().ClusterLocalFQDN())).Apply(gatewayNs.Name(), resource.NoCleanup)
 				apps.PodB[0].CallOrFail(t, echo.CallOptions{
-					Port:    &echo.Port{ServicePort: 80},
+					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("helm-simple.%s.svc.cluster.local", gatewayNs.Name()),
 					Check:   check.OK(),
diff --git a/tests/integration/pilot/locality_test.go b/tests/integration/pilot/locality_test.go
index bb8b6a2df0..6823ea7bbd 100644
--- a/tests/integration/pilot/locality_test.go
+++ b/tests/integration/pilot/locality_test.go
@@ -253,8 +253,10 @@ func sendTrafficOrFail(t framework.TestContext, from echo.Instance, host string,
 	// This is a hack to remain infrastructure agnostic when running these tests
 	// We actually call the host set above not the endpoint we pass
 	_ = from.CallOrFail(t, echo.CallOptions{
-		To:       from,
-		PortName: "http",
+		To: from,
+		Port: echo.Port{
+			Name: "http",
+		},
 		HTTP: echo.HTTP{
 			Headers: headers,
 		},
diff --git a/tests/integration/pilot/mcs/discoverability/discoverability_test.go b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
index cd870fc029..de33756a1c 100644
--- a/tests/integration/pilot/mcs/discoverability/discoverability_test.go
+++ b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
@@ -254,11 +254,13 @@ func callAndValidate(t framework.TestContext, ht hostType, src echo.Instance, ds
 	}
 
 	_, err := src.Call(echo.CallOptions{
-		Address:  address,
-		To:       dest,
-		Count:    requestCountMultiplier * len(dst),
-		PortName: "http",
-		Check:    checker,
+		Address: address,
+		To:      dest,
+		Count:   requestCountMultiplier * len(dst),
+		Port: echo.Port{
+			Name: "http",
+		},
+		Check: checker,
 		Retry: echo.Retry{
 			Options: []retry.Option{retryDelay, retryTimeout},
 		},
diff --git a/tests/integration/pilot/mirror_test.go b/tests/integration/pilot/mirror_test.go
index c8d58ac0bd..c8ea2f781f 100644
--- a/tests/integration/pilot/mirror_test.go
+++ b/tests/integration/pilot/mirror_test.go
@@ -168,9 +168,11 @@ func runMirrorTest(t *testing.T, options mirrorTestOptions) {
 
 func sendTrafficMirror(from, to echo.Instance, proto protocol.Instance, testID string) error {
 	options := echo.CallOptions{
-		To:       to,
-		Count:    100,
-		PortName: strings.ToLower(string(proto)),
+		To:    to,
+		Count: 100,
+		Port: echo.Port{
+			Name: strings.ToLower(proto.String()),
+		},
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
diff --git a/tests/integration/pilot/multi_version_revision_test.go b/tests/integration/pilot/multi_version_revision_test.go
index eb9e3cb952..c42b7c1fe2 100644
--- a/tests/integration/pilot/multi_version_revision_test.go
+++ b/tests/integration/pilot/multi_version_revision_test.go
@@ -142,8 +142,10 @@ func testAllEchoCalls(t framework.TestContext, echoInstances []echo.Instance) {
 					Run(func(t framework.TestContext) {
 						retry.UntilSuccessOrFail(t, func() error {
 							resp, err := source.Call(echo.CallOptions{
-								To:       dest,
-								PortName: trafficType,
+								To: dest,
+								Port: echo.Port{
+									Name: trafficType,
+								},
 								Retry: echo.Retry{
 									NoRetry: true,
 								},
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index 1905028790..6b79e181ca 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -27,7 +27,6 @@
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -124,10 +123,11 @@ func(t framework.TestContext) {
 						source := source
 						t.NewSubTest(source.Config().Cluster.StableName()).RunParallel(func(t framework.TestContext) {
 							source.CallOrFail(t, echo.CallOptions{
-								To:       destination[0],
-								Count:    multiclusterRequestCountMultiplier * len(destination),
-								PortName: "http",
-								Scheme:   scheme.HTTP,
+								To:    destination[0],
+								Count: multiclusterRequestCountMultiplier * len(destination),
+								Port: echo.Port{
+									Name: "http",
+								},
 								Check: check.And(
 									check.OK(),
 									check.ReachedClusters(cluster.Clusters{source.Config().Cluster}),
@@ -147,10 +147,11 @@ func(t framework.TestContext) {
 					source := source
 					t.NewSubTest(source.Config().Cluster.StableName()).Run(func(t framework.TestContext) {
 						source.CallOrFail(t, echo.CallOptions{
-							To:       destination[0],
-							Count:    multiclusterRequestCountMultiplier * len(destination),
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							To:    destination[0],
+							Count: multiclusterRequestCountMultiplier * len(destination),
+							Port: echo.Port{
+								Name: "http",
+							},
 							Check: check.And(
 								check.OK(),
 								check.ReachedClusters(destination.Clusters()),
diff --git a/tests/integration/pilot/original_src_addr_test.go b/tests/integration/pilot/original_src_addr_test.go
index aa73892fbf..da9fd6a16a 100644
--- a/tests/integration/pilot/original_src_addr_test.go
+++ b/tests/integration/pilot/original_src_addr_test.go
@@ -22,7 +22,6 @@
 	"testing"
 
 	echoClient "istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 )
@@ -70,10 +69,11 @@ func checkOriginalSrcIP(t framework.TestContext, src echo.Caller, dest echo.Inst
 		return nil
 	}
 	_ = src.CallOrFail(t, echo.CallOptions{
-		To:       dest,
-		PortName: "http",
-		Scheme:   scheme.HTTP,
-		Count:    1,
-		Check:    checker,
+		To: dest,
+		Port: echo.Port{
+			Name: "http",
+		},
+		Count: 1,
+		Check: checker,
 	})
 }
diff --git a/tests/integration/pilot/revisioned_upgrade_test.go b/tests/integration/pilot/revisioned_upgrade_test.go
index c7e9555af5..c7c9be59b8 100644
--- a/tests/integration/pilot/revisioned_upgrade_test.go
+++ b/tests/integration/pilot/revisioned_upgrade_test.go
@@ -103,8 +103,10 @@ func testUpgradeFromVersion(t framework.TestContext, fromVersion string) {
 	g := traffic.NewGenerator(t, traffic.Config{
 		Source: apps.PodA[0],
 		Options: echo.CallOptions{
-			To:       apps.PodB[0],
-			PortName: "http",
+			To: apps.PodB[0],
+			Port: echo.Port{
+				Name: "http",
+			},
 		},
 		Interval: callInterval,
 	}).Start()
diff --git a/tests/integration/pilot/revisions/revisions_test.go b/tests/integration/pilot/revisions/revisions_test.go
index 5bfb490c25..6649207176 100644
--- a/tests/integration/pilot/revisions/revisions_test.go
+++ b/tests/integration/pilot/revisions/revisions_test.go
@@ -109,9 +109,11 @@ func TestMultiRevision(t *testing.T) {
 				Run(func(t framework.TestContext, src echo.Instance, dst echo.Instances) {
 					retry.UntilSuccessOrFail(t, func() error {
 						resp, err := src.Call(echo.CallOptions{
-							To:       dst[0],
-							PortName: "http",
-							Count:    len(t.Clusters()) * 3,
+							To: dst[0],
+							Port: echo.Port{
+								Name: "http",
+							},
+							Count: len(t.Clusters()) * 3,
 							Retry: echo.Retry{
 								NoRetry: true,
 							},
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 72947fcbf8..3b5c10d75d 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -113,7 +113,7 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 				retry.UntilSuccessOrFail(t, func() error {
 					res, err := client.Call(echo.CallOptions{
 						To:   autoVM,
-						Port: &autoVM.Config().Ports[0],
+						Port: autoVM.Config().Ports[0],
 						Retry: echo.Retry{
 							NoRetry: true,
 						},
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index af7be350ff..a371fbd0b4 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -78,9 +78,10 @@ func TestAuthorization_mTLS(t *testing.T) {
 						newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
-									To:       to[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
+									To: to[0],
+									Port: echo.Port{
+										Name: "http",
+									},
 									HTTP: echo.HTTP{
 										Path: path,
 									},
@@ -147,9 +148,10 @@ func TestAuthorization_JWT(t *testing.T) {
 						newTestCase := func(from echo.Instance, to echo.Instances, namePrefix, jwt, path string, expectAllowed bool) func(t framework.TestContext) {
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
-									To:       to[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
+									To: to[0],
+									Port: echo.Port{
+										Name: "http",
+									},
 									HTTP: echo.HTTP{
 										Path:    path,
 										Headers: headers.New().WithAuthz(jwt).Build(),
@@ -241,9 +243,10 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 				expectAllowed bool) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To:       to[0],
-						PortName: "http",
-						Scheme:   scheme.HTTP,
+						To: to[0],
+						Port: echo.Port{
+							Name: "http",
+						},
 						HTTP: echo.HTTP{
 							Path: path,
 						},
@@ -389,9 +392,10 @@ func TestAuthorization_Deny(t *testing.T) {
 					newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
-								To:       to[0],
-								PortName: "http",
-								Scheme:   scheme.HTTP,
+								To: to[0],
+								Port: echo.Port{
+									Name: "http",
+								},
 								HTTP: echo.HTTP{
 									Path: path,
 								},
@@ -482,9 +486,10 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 					newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
 						return func(t framework.TestContext) {
 							opts := echo.CallOptions{
-								To:       to[0],
-								PortName: "http",
-								Scheme:   scheme.HTTP,
+								To: to[0],
+								Port: echo.Port{
+									Name: "http",
+								},
 								HTTP: echo.HTTP{
 									Path: path,
 								},
@@ -728,7 +733,7 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 					for _, tc := range cases {
 						t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
 							opts := echo.CallOptions{
-								Port: &echo.Port{
+								Port: echo.Port{
 									Protocol: protocol.HTTP,
 								},
 								HTTP: echo.HTTP{
@@ -902,9 +907,11 @@ func TestAuthorization_TCP(t *testing.T) {
 			newTestCase := func(from echo.Instance, to echo.Instances, s scheme.Instance, portName string, expectAllowed bool) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To:       to[0],
-						PortName: portName,
-						Scheme:   s,
+						To: to[0],
+						Port: echo.Port{
+							Name: portName,
+						},
+						Scheme: s,
 						HTTP: echo.HTTP{
 							Path: "/data",
 						},
@@ -1079,9 +1086,10 @@ func TestAuthorization_Conditions(t *testing.T) {
 							newTestCase := func(from echo.Instance, to echo.Instances, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
-										To:       to[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
+										To: to[0],
+										Port: echo.Port{
+											Name: "http",
+										},
 										HTTP: echo.HTTP{
 											Path:    path,
 											Headers: headers,
@@ -1195,9 +1203,10 @@ func TestAuthorization_GRPC(t *testing.T) {
 							newTestCase := func(from echo.Instance, to echo.Instances, expectAllowed bool) func(t framework.TestContext) {
 								return func(t framework.TestContext) {
 									opts := echo.CallOptions{
-										To:       to[0],
-										PortName: "grpc",
-										Scheme:   scheme.GRPC,
+										To: to[0],
+										Port: echo.Port{
+											Name: "grpc",
+										},
 									}
 									if expectAllowed {
 										opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -1259,9 +1268,10 @@ func TestAuthorization_Path(t *testing.T) {
 						newTestCase := func(from echo.Instance, to echo.Instances, path string, expectAllowed bool) func(t framework.TestContext) {
 							return func(t framework.TestContext) {
 								opts := echo.CallOptions{
-									To:       to[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
+									To: to[0],
+									Port: echo.Port{
+										Name: "http",
+									},
 									HTTP: echo.HTTP{
 										Path: path,
 									},
@@ -1339,9 +1349,10 @@ func TestAuthorization_Audit(t *testing.T) {
 				path string, expectAllowed bool) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To:       to[0],
-						PortName: "http",
-						Scheme:   scheme.HTTP,
+						To: to[0],
+						Port: echo.Port{
+							Name: "http",
+						},
 						HTTP: echo.HTTP{
 							Path: path,
 						},
@@ -1485,9 +1496,11 @@ func TestAuthorization_Custom(t *testing.T) {
 				checker check.Checker, expectAllowed bool) func(t framework.TestContext) {
 				return func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To:       to,
-						PortName: port,
-						Scheme:   s,
+						To: to,
+						Port: echo.Port{
+							Name: port,
+						},
+						Scheme: s,
 						HTTP: echo.HTTP{
 							Path:    path,
 							Headers: headers,
@@ -1577,7 +1590,7 @@ func TestAuthorization_Custom(t *testing.T) {
 					checker check.Checker, expectAllowed bool) func(t framework.TestContext) {
 					return func(t framework.TestContext) {
 						opts := echo.CallOptions{
-							Port: &echo.Port{
+							Port: echo.Port{
 								Protocol: protocol.HTTP,
 							},
 							Scheme: scheme.HTTP,
@@ -1648,7 +1661,7 @@ func newRbacTestName(prefix string, expectAllowed bool, from echo.Instance, opts
 		prefix,
 		from.Config().Service,
 		opts.To.Config().Service,
-		opts.PortName,
+		opts.Port.Name,
 		opts.HTTP.Path,
 		want))
 }
diff --git a/tests/integration/security/ca_custom_root/main_test.go b/tests/integration/security/ca_custom_root/main_test.go
index 4bdf455bb6..50291c5b50 100644
--- a/tests/integration/security/ca_custom_root/main_test.go
+++ b/tests/integration/security/ca_custom_root/main_test.go
@@ -133,7 +133,7 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 			ServiceAccount: true,
 			Ports: []echo.Port{
 				{
-					Name:         HTTPS,
+					Name:         "https",
 					Protocol:     protocol.HTTPS,
 					ServicePort:  443,
 					WorkloadPort: 8443,
@@ -158,7 +158,7 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 			ServiceAccount: true,
 			Ports: []echo.Port{
 				{
-					Name:         HTTPS,
+					Name:         "https",
 					Protocol:     protocol.HTTPS,
 					ServicePort:  443,
 					WorkloadPort: 8443,
@@ -184,7 +184,7 @@ func SetupApps(ctx resource.Context, apps *EchoDeployments) error {
 			ServiceAccount: true,
 			Ports: []echo.Port{
 				{
-					Name:         HTTPS,
+					Name:         "https",
 					Protocol:     protocol.HTTPS,
 					ServicePort:  443,
 					WorkloadPort: 8443,
diff --git a/tests/integration/security/ca_custom_root/multi_root_test.go b/tests/integration/security/ca_custom_root/multi_root_test.go
index d855a73bfc..5152f18f5b 100644
--- a/tests/integration/security/ca_custom_root/multi_root_test.go
+++ b/tests/integration/security/ca_custom_root/multi_root_test.go
@@ -47,10 +47,12 @@ func TestMultiRootSetup(t *testing.T) {
 						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opts := echo.CallOptions{
-								To:       to[0],
-								PortName: HTTPS,
-								Address:  to[0].Config().Service,
-								Scheme:   s,
+								To: to[0],
+								Port: echo.Port{
+									Name: "https",
+								},
+								Address: to[0].Config().Service,
+								Scheme:  s,
 							}
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
 
diff --git a/tests/integration/security/ca_custom_root/secure_naming_test.go b/tests/integration/security/ca_custom_root/secure_naming_test.go
index 3b59337532..debd5541d5 100644
--- a/tests/integration/security/ca_custom_root/secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/secure_naming_test.go
@@ -28,7 +28,6 @@
 
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
@@ -136,10 +135,11 @@ func TestSecureNaming(t *testing.T) {
 
 							// Verify mTLS works between a and b
 							opts := echo.CallOptions{
-								To:       bSet[0],
-								PortName: "http",
-								Scheme:   scheme.HTTP,
-								Count:    callCount,
+								To: bSet[0],
+								Port: echo.Port{
+									Name: "http",
+								},
+								Count: callCount,
 							}
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
 							a.CallOrFail(t, opts)
@@ -178,10 +178,11 @@ func TestSecureNaming(t *testing.T) {
 								t.ConfigIstio().YAML(dr).ApplyOrFail(t, testNamespace.Name())
 								// Verify mTLS works between a and b
 								opts := echo.CallOptions{
-									To:       bSet[0],
-									PortName: "http",
-									Scheme:   scheme.HTTP,
-									Count:    callCount,
+									To: bSet[0],
+									Port: echo.Port{
+										Name: "http",
+									},
+									Count: callCount,
 								}
 								if tc.expectSuccess {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
diff --git a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
index 24109e0321..5545a7bbe1 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_alias_secure_naming_test.go
@@ -29,7 +29,6 @@
 )
 
 const (
-	HTTPS  = "https"
 	POLICY = `
 apiVersion: security.istio.io/v1beta1
 kind: PeerAuthentication
@@ -88,10 +87,12 @@ func TestTrustDomainAliasSecureNaming(t *testing.T) {
 						t.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opts := echo.CallOptions{
-								To:       to[0],
-								PortName: HTTPS,
-								Address:  to[0].Config().Service,
-								Scheme:   s,
+								To: to[0],
+								Port: echo.Port{
+									Name: "https",
+								},
+								Address: to[0].Config().Service,
+								Scheme:  s,
 							}
 							if success {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index 8c7a26c273..c239630eaa 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -135,10 +135,12 @@ func(ctx framework.TestContext) {
 						ctx.NewSubTest(name).Run(func(t framework.TestContext) {
 							t.Helper()
 							opt := echo.CallOptions{
-								To:       server,
-								PortName: port,
-								Address:  "server",
-								Scheme:   s,
+								To: server,
+								Port: echo.Port{
+									Name: port,
+								},
+								Address: "server",
+								Scheme:  s,
 								TLS: echo.TLS{
 									Cert: trustDomains[td].cert,
 									Key:  trustDomains[td].key,
diff --git a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
index 97ace4077d..2e145df86f 100644
--- a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
+++ b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
@@ -24,7 +24,6 @@
 	"testing"
 
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -68,11 +67,12 @@ func TestStrictMTLS(t *testing.T) {
 			t.ConfigIstio().Eval(args, DestinationRuleConfigIstioMutual).ApplyOrFail(t, ns, resource.Wait)
 
 			apps.Client.CallOrFail(t, echo.CallOptions{
-				To:       apps.Server,
-				PortName: "http",
-				Scheme:   scheme.HTTP,
-				Count:    1,
-				Check:    check.OK(),
+				To: apps.Server,
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: 1,
+				Check: check.OK(),
 			})
 
 			certPEMs := cert.DumpCertFromSidecar(t, apps.Client, apps.Server, "http")
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 690907b46e..af38e36aed 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -29,7 +29,6 @@
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -356,10 +355,11 @@ type TLSTestCase struct {
 
 func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions {
 	return echo.CallOptions{
-		To:       dest,
-		Count:    util.CallsPerCluster,
-		PortName: "http",
-		Scheme:   scheme.HTTP,
+		To:    dest,
+		Count: util.CallsPerCluster,
+		Port: echo.Port{
+			Name: "http",
+		},
 		HTTP: echo.HTTP{
 			Headers: headers.New().WithHost(host).Build(),
 		},
diff --git a/tests/integration/security/external_ca/reachability_test.go b/tests/integration/security/external_ca/reachability_test.go
index 125fdede40..316febbc9a 100644
--- a/tests/integration/security/external_ca/reachability_test.go
+++ b/tests/integration/security/external_ca/reachability_test.go
@@ -22,7 +22,6 @@
 	"testing"
 
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
@@ -60,10 +59,11 @@ func TestReachability(t *testing.T) {
 						Run(func(t framework.TestContext) {
 							// Verify mTLS works between a and b
 							opts := echo.CallOptions{
-								To:       bSet[0],
-								PortName: "http",
-								Scheme:   scheme.HTTP,
-								Count:    callCount,
+								To: bSet[0],
+								Port: echo.Port{
+									Name: "http",
+								},
+								Count: callCount,
 							}
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(bSet, &opts))
 
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index 2a20981f71..5139b5f8a3 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -24,7 +24,6 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
@@ -54,9 +53,10 @@ func TestClientToServiceTls(t *testing.T) {
 			createObject(t, "istio-system", PeerAuthenticationConfig)
 
 			opts := echo.CallOptions{
-				To:       server,
-				PortName: "http",
-				Scheme:   scheme.HTTP,
+				To: server,
+				Port: echo.Port{
+					Name: "http",
+				},
 				Check: check.And(
 					check.OK(),
 					check.RequestHeader("X-Forwarded-Client-Cert", ExpectedXfccHeader)),
diff --git a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
index ae4b3b393b..f860d2b538 100644
--- a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
+++ b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
@@ -127,14 +127,17 @@ func TestDestinationRuleTls(t *testing.T) {
 				}).
 				BuildOrFail(t)
 
-			for _, tt := range []string{"grpc", "http", "tcp"} {
-				t.NewSubTest(tt).Run(func(t framework.TestContext) {
+			for _, portName := range []string{"grpc", "http", "tcp"} {
+				portName := portName
+				t.NewSubTest(portName).Run(func(t framework.TestContext) {
 					opts := echo.CallOptions{
-						To:       server,
-						PortName: tt,
-						Check:    check.OK(),
+						To: server,
+						Port: echo.Port{
+							Name: portName,
+						},
+						Check: check.OK(),
 					}
-					if tt == "tcp" {
+					if portName == "tcp" {
 						opts.Scheme = scheme.TCP
 					}
 					client.CallOrFail(t, opts)
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index f69bd4c5f0..ed33516269 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -129,8 +129,10 @@ func TestEgressGatewayTls(t *testing.T) {
 						t.ConfigIstio().YAML(bufDestinationRule.String()).ApplyOrFail(t, systemNamespace.Name())
 
 						opts := echo.CallOptions{
-							To:       externalServer,
-							PortName: "http",
+							To: externalServer,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Headers: headers.New().WithHost(host).Build(),
 							},
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 111c8a0494..aca5e4c85b 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -24,7 +24,6 @@
 
 	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -115,10 +114,11 @@ func TestJWTHTTPS(t *testing.T) {
 						To(util.DestFilter(t, apps, ns.Name(), true)...).
 						Run(func(t framework.TestContext, from echo.Instance, to echo.Instances) {
 							opts := echo.CallOptions{
-								To:       to[0],
-								PortName: "http",
-								Scheme:   scheme.HTTP,
-								Count:    callCount,
+								To: to[0],
+								Port: echo.Port{
+									Name: "http",
+								},
+								Count: callCount,
 							}
 
 							c.customizeCall(to, &opts)
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index c5cb38d48e..d1a6e489d9 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -25,7 +25,6 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test/echo/check"
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
@@ -83,10 +82,11 @@ type testCase struct {
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
-										To:       to[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
-										Count:    callCount,
+										To: to[0],
+										Port: echo.Port{
+											Name: "http",
+										},
+										Count: callCount,
 									}
 
 									// Apply any custom options for the test.
@@ -438,10 +438,11 @@ type testCase struct {
 							for _, c := range cases {
 								t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 									opts := echo.CallOptions{
-										To:       to[0],
-										PortName: "http",
-										Scheme:   scheme.HTTP,
-										Count:    callCount,
+										To: to[0],
+										Port: echo.Port{
+											Name: "http",
+										},
+										Count: callCount,
 									}
 
 									// Apply any custom options for the test.
@@ -586,7 +587,7 @@ type testCase struct {
 					for _, c := range ingTestCases {
 						t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 							opts := echo.CallOptions{
-								Port: &echo.Port{
+								Port: echo.Port{
 									Protocol: protocol.HTTP,
 								},
 							}
diff --git a/tests/integration/security/mtls_first_party_jwt/strict_test.go b/tests/integration/security/mtls_first_party_jwt/strict_test.go
index 3123927354..eee294ab8b 100644
--- a/tests/integration/security/mtls_first_party_jwt/strict_test.go
+++ b/tests/integration/security/mtls_first_party_jwt/strict_test.go
@@ -76,7 +76,7 @@ func TestMtlsStrictK8sCA(t *testing.T) {
 					Namespace:  systemNM,
 					Include: func(src echo.Instance, opts echo.CallOptions) bool {
 						// Exclude calls to the headless TCP port.
-						if apps.Headless.Contains(opts.To) && opts.PortName == "tcp" {
+						if apps.Headless.Contains(opts.To) && opts.Port.Name == "tcp" {
 							return false
 						}
 
diff --git a/tests/integration/security/mtlsk8sca/strict_test.go b/tests/integration/security/mtlsk8sca/strict_test.go
index 4598fcdc25..8c426a2610 100644
--- a/tests/integration/security/mtlsk8sca/strict_test.go
+++ b/tests/integration/security/mtlsk8sca/strict_test.go
@@ -77,7 +77,7 @@ func TestMtlsStrictK8sCA(t *testing.T) {
 					Namespace:  systemNM,
 					Include: func(src echo.Instance, opts echo.CallOptions) bool {
 						// Exclude calls to the headless TCP port.
-						if apps.Headless.Contains(opts.To) && opts.PortName == "tcp" {
+						if apps.Headless.Contains(opts.To) && opts.Port.Name == "tcp" {
 							return false
 						}
 
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index 95adb55291..64f69d3884 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -239,8 +239,10 @@ type expect struct {
 									HTTP: echo.HTTP{
 										Path: tt.in,
 									},
-									PortName: "http",
-									Check:    checker,
+									Port: echo.Port{
+										Name: "http",
+									},
+									Check: checker,
 								})
 							})
 						}
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 861e56ed85..5c853bc80f 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -44,7 +44,7 @@ func TestPassThroughFilterChain(t *testing.T) {
 			ns := apps.Namespace1
 
 			type expect struct {
-				port              *echo.Port
+				port              echo.Port
 				plaintextSucceeds bool
 				mtlsSucceeds      bool
 			}
@@ -67,27 +67,27 @@ type expect struct {
     mode: DISABLE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
@@ -116,32 +116,32 @@ type expect struct {
         ports: ["8085", "8087", "8089"]`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      false,
 						},
@@ -160,27 +160,27 @@ type expect struct {
     mode: STRICT`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
@@ -199,27 +199,27 @@ type expect struct {
     mode: PERMISSIVE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
@@ -248,32 +248,32 @@ type expect struct {
       mode: STRICT`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
@@ -302,32 +302,32 @@ type expect struct {
       mode: DISABLE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
@@ -354,32 +354,32 @@ type expect struct {
       mode: STRICT`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
@@ -406,32 +406,32 @@ type expect struct {
       mode: PERMISSIVE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: false,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
@@ -458,32 +458,32 @@ type expect struct {
       mode: DISABLE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
@@ -510,32 +510,32 @@ type expect struct {
       mode: PERMISSIVE`,
 					expected: []expect{
 						{
-							port:              &echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8085, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
+							port:              echo.Port{ServicePort: 8086, Protocol: protocol.HTTP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8087, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
+							port:              echo.Port{ServicePort: 8088, Protocol: protocol.TCP},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8089, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      false,
 						},
 						{
-							port:              &echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
+							port:              echo.Port{ServicePort: 8084, Protocol: protocol.HTTPS},
 							plaintextSucceeds: true,
 							mtlsSucceeds:      true,
 						},
diff --git a/tests/integration/security/reachability_test.go b/tests/integration/security/reachability_test.go
index 69809534ff..caad157f53 100644
--- a/tests/integration/security/reachability_test.go
+++ b/tests/integration/security/reachability_test.go
@@ -20,7 +20,6 @@
 import (
 	"testing"
 
-	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
@@ -106,11 +105,11 @@ func TestReachability(t *testing.T) {
 						// For naked app as client, only requests targeted to mTLS disabled endpoints succeed:
 						// A are disabled by workload selector for entire service.
 						// B port 8090 http port are disabled.
-						return apps.A.Contains(opts.To) || (apps.B.Contains(opts.To) && opts.PortName == "http")
+						return apps.A.Contains(opts.To) || (apps.B.Contains(opts.To) && opts.Port.Name == "http")
 					},
 					// Only when the source is B and the destination does not disable mTLS.
 					ExpectMTLS: func(src echo.Instance, opts echo.CallOptions) bool {
-						return apps.B.Contains(src) && opts.PortName != "http" && !apps.A.Contains(opts.To)
+						return apps.B.Contains(src) && opts.Port.Name != "http" && !apps.A.Contains(opts.To)
 					},
 					SkippedForMulticluster: true,
 				},
@@ -130,7 +129,7 @@ func TestReachability(t *testing.T) {
 						return apps.B.Contains(opts.To)
 					},
 					ExpectSuccess: func(src echo.Instance, opts echo.CallOptions) bool {
-						return opts.PortName != "http"
+						return opts.Port.Name != "http"
 					},
 					ExpectMTLS:             Never,
 					SkippedForMulticluster: true,
@@ -199,15 +198,17 @@ func TestReachability(t *testing.T) {
 					Namespace:  apps.Namespace1,
 					CallOpts: []echo.CallOptions{
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vistio",
 							},
 						},
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vlegacy",
 							},
@@ -227,15 +228,17 @@ func TestReachability(t *testing.T) {
 					Namespace:  apps.Namespace1,
 					CallOpts: []echo.CallOptions{
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vistio",
 							},
 						},
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vlegacy",
 							},
@@ -256,15 +259,17 @@ func TestReachability(t *testing.T) {
 					Namespace:  apps.Namespace1,
 					CallOpts: []echo.CallOptions{
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vistio",
 							},
 						},
 						{
-							PortName: "http",
-							Scheme:   scheme.HTTP,
+							Port: echo.Port{
+								Name: "http",
+							},
 							HTTP: echo.HTTP{
 								Path: "/vlegacy",
 							},
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index 847a018770..7e73759299 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -292,7 +292,7 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 		Retry: echo.Retry{
 			Options: []retry.Option{retry.Timeout(time.Minute * 2)},
 		},
-		Port: &echo.Port{
+		Port: echo.Port{
 			Protocol: protocol.HTTPS,
 		},
 		HTTP: echo.HTTP{
diff --git a/tests/integration/security/util/cert/cert.go b/tests/integration/security/util/cert/cert.go
index 4937983bc6..5f8da10825 100644
--- a/tests/integration/security/util/cert/cert.go
+++ b/tests/integration/security/util/cert/cert.go
@@ -40,9 +40,11 @@
 // DumpCertFromSidecar gets the certificates served by the destination.
 func DumpCertFromSidecar(t test.Failer, from, to echo.Instance, port string) []string {
 	resp := from.CallOrFail(t, echo.CallOptions{
-		To:       to,
-		PortName: port,
-		Scheme:   scheme.TLS,
+		To: to,
+		Port: echo.Port{
+			Name: port,
+		},
+		Scheme: scheme.TLS,
 		TLS: echo.TLS{
 			Alpn: []string{"istio"},
 		},
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 0ed5b85024..04572fb534 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -68,24 +68,34 @@ type TestCase struct {
 func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeployments) {
 	callOptions := []echo.CallOptions{
 		{
-			PortName: "http",
-			Scheme:   scheme.HTTP,
+			Port: echo.Port{
+				Name: "http",
+			},
+			Scheme: scheme.HTTP,
 		},
 		{
-			PortName: "http",
-			Scheme:   scheme.WebSocket,
+			Port: echo.Port{
+				Name: "http",
+			},
+			Scheme: scheme.WebSocket,
 		},
 		{
-			PortName: "tcp",
-			Scheme:   scheme.TCP,
+			Port: echo.Port{
+				Name: "tcp",
+			},
+			Scheme: scheme.TCP,
 		},
 		{
-			PortName: "grpc",
-			Scheme:   scheme.GRPC,
+			Port: echo.Port{
+				Name: "grpc",
+			},
+			Scheme: scheme.GRPC,
 		},
 		{
-			PortName: "https",
-			Scheme:   scheme.HTTPS,
+			Port: echo.Port{
+				Name: "https",
+			},
+			Scheme: scheme.HTTPS,
 		},
 	}
 
@@ -186,7 +196,7 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 									subTestName := fmt.Sprintf("%s to %s:%s%s %s",
 										opts.Scheme,
 										dest.Config().Service,
-										opts.PortName,
+										opts.Port.Name,
 										opts.HTTP.Path,
 										tpe)
 
diff --git a/tests/integration/security/util/scheck/checkers.go b/tests/integration/security/util/scheck/checkers.go
index 6925c109ec..b92c225171 100644
--- a/tests/integration/security/util/scheck/checkers.go
+++ b/tests/integration/security/util/scheck/checkers.go
@@ -50,11 +50,11 @@ func ReachedClusters(to echo.Instances, opts *echo.CallOptions) check.Checker {
 }
 
 func RBACFailure(opts *echo.CallOptions) check.Checker {
-	if opts.PortName == "grpc" {
+	if opts.Port.Name == "grpc" {
 		return check.ErrorContains("rpc error: code = PermissionDenied desc = RBAC: access denied")
 	}
 
-	if strings.HasPrefix(opts.PortName, "tcp") {
+	if strings.HasPrefix(opts.Port.Name, "tcp") {
 		return check.ErrorContains("EOF")
 	}
 
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index e33d8f522e..762dc4692d 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -254,8 +254,10 @@ func RunExternalRequest(t *testing.T, cases []*TestCase, prometheus prometheus.I
 			for _, tc := range cases {
 				t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
 					client.CallOrFail(t, echo.CallOptions{
-						To:       dest,
-						PortName: tc.PortName,
+						To: dest,
+						Port: echo.Port{
+							Name: tc.PortName,
+						},
 						HTTP: echo.HTTP{
 							HTTP2:   tc.HTTP2,
 							Headers: headers.New().WithHost(tc.Host).Build(),
diff --git a/tests/integration/telemetry/policy/envoy_ratelimit_test.go b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
index accc117421..d7948fff15 100644
--- a/tests/integration/telemetry/policy/envoy_ratelimit_test.go
+++ b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
@@ -195,9 +195,11 @@ func sendTrafficAndCheckIfRatelimited(t framework.TestContext) {
 	retry.UntilSuccessOrFail(t, func() error {
 		t.Logf("Sending 5 requests...")
 		httpOpts := echo.CallOptions{
-			To:       srv,
-			PortName: "http",
-			Count:    5,
+			To: srv,
+			Port: echo.Port{
+				Name: "http",
+			},
+			Count: 5,
 			Retry: echo.Retry{
 				NoRetry: true,
 			},
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index a2d60039d8..406664f476 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -162,9 +162,11 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 	// Sending the number of total request same as number of servers, so that load balancing gets a chance to send request to all the clusters.
 	if onlyTCP {
 		_, err := cltInstance.Call(echo.CallOptions{
-			To:       Srv[0],
-			PortName: "tcp",
-			Count:    telemetry.RequestCountMultipler * len(Srv),
+			To: Srv[0],
+			Port: echo.Port{
+				Name: "tcp",
+			},
+			Count: telemetry.RequestCountMultipler * len(Srv),
 			Retry: echo.Retry{
 				NoRetry: true,
 			},
@@ -172,17 +174,21 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 		return err
 	}
 	grpcOpts := echo.CallOptions{
-		To:       Srv[0],
-		PortName: "grpc",
-		Count:    telemetry.RequestCountMultipler * len(Srv),
+		To: Srv[0],
+		Port: echo.Port{
+			Name: "grpc",
+		},
+		Count: telemetry.RequestCountMultipler * len(Srv),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
 	}
 	// an HTTP request with forced tracing
 	httpOpts := echo.CallOptions{
-		To:       Srv[0],
-		PortName: "http",
+		To: Srv[0],
+		Port: echo.Port{
+			Name: "http",
+		},
 		HTTP: echo.HTTP{
 			Headers: headers,
 		},
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
index 918cbc795e..3c99c33f0a 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
@@ -131,8 +131,10 @@ func sendTrafficForAudit(t test.Failer, cltInstance echo.Instance) error {
 
 	newOptions := func(headers http.Header, path string) echo.CallOptions {
 		return echo.CallOptions{
-			To:       Srv[0],
-			PortName: "http",
+			To: Srv[0],
+			Port: echo.Port{
+				Name: "http",
+			},
 			HTTP: echo.HTTP{
 				Headers: headers,
 				Path:    path,
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
index 1ec34217a0..590f7b6612 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
@@ -49,9 +49,11 @@ func TestTCPStackdriverMonitoring(t *testing.T) {
 				g.Go(func() error {
 					err := retry.UntilSuccess(func() error {
 						_, err := cltInstance.Call(echo.CallOptions{
-							To:       Srv[0],
-							PortName: "tcp",
-							Count:    telemetry.RequestCountMultipler * len(Srv),
+							To: Srv[0],
+							Port: echo.Port{
+								Name: "tcp",
+							},
+							Count: telemetry.RequestCountMultipler * len(Srv),
 							Retry: echo.Retry{
 								NoRetry: true,
 							},
diff --git a/tests/integration/telemetry/stackdriver/vm/vm_test.go b/tests/integration/telemetry/stackdriver/vm/vm_test.go
index a8d0cdf655..38d33907e8 100644
--- a/tests/integration/telemetry/stackdriver/vm/vm_test.go
+++ b/tests/integration/telemetry/stackdriver/vm/vm_test.go
@@ -52,9 +52,11 @@ func TestVMTelemetry(t *testing.T) {
 			retry.UntilSuccessOrFail(t, func() error {
 				// send single request from client -> server
 				if _, err := client.Call(echo.CallOptions{
-					To:       server,
-					PortName: "http",
-					Count:    1,
+					To: server,
+					Port: echo.Port{
+						Name: "http",
+					},
+					Count: 1,
 					Retry: echo.Retry{
 						NoRetry: true,
 					},
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index 0d0dcab4a2..ca5d6f3b2b 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -247,8 +247,10 @@ func sendTraffic() error {
 	for _, cltInstance := range client {
 		count := requestCountMultipler * len(server)
 		httpOpts := echo.CallOptions{
-			To:       server[0],
-			PortName: "http",
+			To: server[0],
+			Port: echo.Port{
+				Name: "http",
+			},
 			HTTP: echo.HTTP{
 				Path:   "/path",
 				Method: "GET",
@@ -269,9 +271,11 @@ func sendTraffic() error {
 		}
 
 		grpcOpts := echo.CallOptions{
-			To:       server[0],
-			PortName: "grpc",
-			Count:    count,
+			To: server[0],
+			Port: echo.Port{
+				Name: "grpc",
+			},
+			Count: count,
 		}
 		if _, err := cltInstance.Call(grpcOpts); err != nil {
 			return err
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
index a4441fe81f..98b5b102ee 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
@@ -74,9 +74,11 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 		// For positive test, we use the same ID and repeatedly send requests and check the count
 		retry.UntilSuccessOrFail(t, func() error {
 			common.GetClientInstances()[0].CallOrFail(t, echo.CallOptions{
-				To:       common.GetServerInstances()[0],
-				PortName: "http",
-				Count:    util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
+				To: common.GetServerInstances()[0],
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
 				HTTP: echo.HTTP{
 					Path: "/" + testID,
 				},
@@ -99,9 +101,11 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 		retry.UntilSuccessOrFail(t, func() error {
 			testID := testutils.RandomString(16)
 			common.GetClientInstances()[0].CallOrFail(t, echo.CallOptions{
-				To:       common.GetServerInstances()[0],
-				PortName: "http",
-				Count:    util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
+				To: common.GetServerInstances()[0],
+				Port: echo.Port{
+					Name: "http",
+				},
+				Count: util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
 				HTTP: echo.HTTP{
 					Path: "/" + testID,
 				},
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
index bd54e9e9f1..3fe258e80b 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
@@ -307,7 +307,7 @@ func setupDashboardTest(done <-chan struct{}) {
 			for _, ing := range common.GetIngressInstance() {
 				host, port := ing.TCPAddress()
 				_, err := ing.Call(echo.CallOptions{
-					Port: &echo.Port{
+					Port: echo.Port{
 						Protocol: protocol.HTTP,
 					},
 					Count: 10,
@@ -325,7 +325,7 @@ func setupDashboardTest(done <-chan struct{}) {
 					log.Warnf("requests failed: %v", err)
 				}
 				_, err = ing.Call(echo.CallOptions{
-					Port: &echo.Port{
+					Port: echo.Port{
 						Protocol:    protocol.TCP,
 						ServicePort: port,
 					},
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index 5ffe706aad..bb8b9b7ac8 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -152,7 +152,7 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {
 				prom.CallOrFail(t, echo.CallOptions{
 					Address: st.WorkloadsOrFail(t)[0].Address(),
 					Scheme:  scheme.HTTPS,
-					Port:    &echo.Port{ServicePort: 15014},
+					Port:    echo.Port{ServicePort: 15014},
 					HTTP: echo.HTTP{
 						Path: "/metrics",
 					},
@@ -322,10 +322,12 @@ func TestSetup(ctx resource.Context) (err error) {
 // SendTraffic makes a client call to the "server" service on the http port.
 func SendTraffic(cltInstance echo.Instance) error {
 	_, err := cltInstance.Call(echo.CallOptions{
-		To:       server[0],
-		PortName: "http",
-		Count:    util.RequestCountMultipler * len(server),
-		Check:    check.OK(),
+		To: server[0],
+		Port: echo.Port{
+			Name: "http",
+		},
+		Count: util.RequestCountMultipler * len(server),
+		Check: check.OK(),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
@@ -334,9 +336,11 @@ func SendTraffic(cltInstance echo.Instance) error {
 		return err
 	}
 	_, err = cltInstance.Call(echo.CallOptions{
-		To:       nonInjectedServer[0],
-		PortName: "http",
-		Count:    util.RequestCountMultipler * len(nonInjectedServer),
+		To: nonInjectedServer[0],
+		Port: echo.Port{
+			Name: "http",
+		},
+		Count: util.RequestCountMultipler * len(nonInjectedServer),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
@@ -350,9 +354,11 @@ func SendTraffic(cltInstance echo.Instance) error {
 // SendTCPTraffic makes a client call to the "server" service on the tcp port.
 func SendTCPTraffic(cltInstance echo.Instance) error {
 	_, err := cltInstance.Call(echo.CallOptions{
-		To:       server[0],
-		PortName: "tcp",
-		Count:    util.RequestCountMultipler * len(server),
+		To: server[0],
+		Port: echo.Port{
+			Name: "tcp",
+		},
+		Count: util.RequestCountMultipler * len(server),
 		Retry: echo.Retry{
 			NoRetry: true,
 		},
diff --git a/tests/integration/telemetry/tracing/tracing.go b/tests/integration/telemetry/tracing/tracing.go
index ccf370a1b0..1db7a8b4e9 100644
--- a/tests/integration/telemetry/tracing/tracing.go
+++ b/tests/integration/telemetry/tracing/tracing.go
@@ -182,9 +182,11 @@ func SendTraffic(t framework.TestContext, headers map[string][]string, cl cluste
 		}
 
 		_, err := cltInstance.Call(echo.CallOptions{
-			To:       server[0],
-			PortName: "http",
-			Count:    telemetry.RequestCountMultipler * len(server),
+			To: server[0],
+			Port: echo.Port{
+				Name: "http",
+			},
+			Count: telemetry.RequestCountMultipler * len(server),
 			HTTP: echo.HTTP{
 				Headers: headers,
 			},
diff --git a/tests/util/sanitycheck/sanity_check.go b/tests/util/sanitycheck/sanity_check.go
index fdb5e9e45a..9365efa625 100644
--- a/tests/util/sanitycheck/sanity_check.go
+++ b/tests/util/sanitycheck/sanity_check.go
@@ -63,8 +63,10 @@ func SetupTrafficTest(t framework.TestContext, ctx resource.Context, revision st
 
 func RunTrafficTestClientServer(t framework.TestContext, client, server echo.Instance) {
 	_ = client.CallOrFail(t, echo.CallOptions{
-		To:       server,
-		PortName: "http",
-		Check:    check.OK(),
+		To: server,
+		Port: echo.Port{
+			Name: "http",
+		},
+		Check: check.OK(),
 	})
 }
-- 
2.35.3

