From c97c9fe6f0909be0aad868dee529c1135661bc72 Mon Sep 17 00:00:00 2001
From: Steven Landow <landow@google.com>
Date: Tue, 17 May 2022 20:01:41 -0700
Subject: prow: update default image to 1.24.0 and fix remote-secret creation
 (#38885)

* prow: update default image to 1.24.0

Change-Id: I5b8732367af80a948f857a71d14102ca0549436b

* wait for token data to be available

Change-Id: I1e91d11ade8f053ee05a962372357a5b40627fd5

* fix test

Change-Id: Ide970ec6dac60b1020adeeed5955bb5dcf0f69cd

* fix lint and release note

Change-Id: I8527d0325527899ab20dcf3b01c642c3dac94907

* remove go install

Change-Id: I248c3464b478c179f7e9b9a999de42121f88d5e1

* handle err

Change-Id: If0496c54b12105110ec93841961c40dd8d11fb49

* unit test coverage

Change-Id: I7756310338deb98f9284976cdd11f254424a45a3
---
 istioctl/pkg/multicluster/remote_secret.go    |  64 ++++++++---
 .../pkg/multicluster/remote_secret_test.go    | 101 ++++++++++++------
 prow/integ-suite-kind.sh                      |   2 +-
 releasenotes/notes/38885.yaml                 |   8 ++
 4 files changed, 129 insertions(+), 46 deletions(-)
 create mode 100644 releasenotes/notes/38885.yaml

diff --git a/istioctl/pkg/multicluster/remote_secret.go b/istioctl/pkg/multicluster/remote_secret.go
index c6e18120bd..d2f9b96bf7 100644
--- a/istioctl/pkg/multicluster/remote_secret.go
+++ b/istioctl/pkg/multicluster/remote_secret.go
@@ -21,7 +21,9 @@
 	"io"
 	"os"
 	"strings"
+	"time"
 
+	"github.com/cenkalti/backoff/v4"
 	"github.com/spf13/cobra"
 	"github.com/spf13/pflag"
 	v1 "k8s.io/api/core/v1"
@@ -43,11 +45,14 @@
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/multicluster"
+	"istio.io/pkg/log"
 )
 
 var (
 	codec  runtime.Codec
 	scheme *runtime.Scheme
+
+	tokenWaitBackoff = time.Second
 )
 
 func init() {
@@ -211,14 +216,10 @@ func createRemoteSecretFromPlugin(
 	errMissingTokenKey  = fmt.Errorf("no %q data found", v1.ServiceAccountTokenKey)
 )
 
-func createRemoteSecretFromTokenAndServer(tokenSecret *v1.Secret, clusterName, server, secName string) (*v1.Secret, error) {
-	caData, ok := tokenSecret.Data[v1.ServiceAccountRootCAKey]
-	if !ok {
-		return nil, errMissingRootCAKey
-	}
-	token, ok := tokenSecret.Data[v1.ServiceAccountTokenKey]
-	if !ok {
-		return nil, errMissingTokenKey
+func createRemoteSecretFromTokenAndServer(client kube.ExtendedClient, tokenSecret *v1.Secret, clusterName, server, secName string) (*v1.Secret, error) {
+	caData, token, err := waitForTokenData(client, tokenSecret)
+	if err != nil {
+		return nil, err
 	}
 
 	// Create a Kubeconfig to access the remote cluster using the remote service account credentials.
@@ -231,6 +232,41 @@ func createRemoteSecretFromTokenAndServer(tokenSecret *v1.Secret, clusterName, s
 	return createRemoteServiceAccountSecret(kubeconfig, clusterName, secName)
 }
 
+func waitForTokenData(client kube.ExtendedClient, secret *v1.Secret) (ca, token []byte, err error) {
+	ca, token, err = tokenDataFromSecret(secret)
+	if err == nil {
+		return
+	}
+
+	log.Infof("Waiting for data to be populated in %s", secret.Name)
+	err = backoff.Retry(
+		func() error {
+			secret, err = client.Kube().CoreV1().Secrets(secret.Namespace).Get(context.TODO(), secret.Name, metav1.GetOptions{})
+			if err != nil {
+				return err
+			}
+			ca, token, err = tokenDataFromSecret(secret)
+			return err
+		},
+		backoff.WithMaxRetries(backoff.NewConstantBackOff(tokenWaitBackoff), 5))
+	return
+}
+
+func tokenDataFromSecret(tokenSecret *v1.Secret) (ca, token []byte, err error) {
+	var ok bool
+	ca, ok = tokenSecret.Data[v1.ServiceAccountRootCAKey]
+	if !ok {
+		err = errMissingRootCAKey
+		return
+	}
+	token, ok = tokenSecret.Data[v1.ServiceAccountTokenKey]
+	if !ok {
+		err = errMissingTokenKey
+		return
+	}
+	return
+}
+
 func getServiceAccountSecret(client kube.ExtendedClient, opt RemoteSecretOptions) (*v1.Secret, error) {
 	// Create the service account if it doesn't exist.
 	serviceAccount, err := getOrCreateServiceAccount(client, opt)
@@ -260,7 +296,7 @@ func getOrCreateServiceAccountSecret(
 			return nil, fmt.Errorf("could not get specified secret %s/%s: %v",
 				opt.Namespace, opt.SecretName, err)
 		}
-		if err := validateServiceAccountSecret(serviceAccount, secret); err != nil {
+		if err := secretReferencesServiceAccount(serviceAccount, secret); err != nil {
 			return nil, err
 		}
 		return secret, nil
@@ -274,7 +310,7 @@ func getOrCreateServiceAccountSecret(
 	}
 	for _, item := range allSecrets.Items {
 		secret := item
-		if validateServiceAccountSecret(serviceAccount, &secret) == nil {
+		if secretReferencesServiceAccount(serviceAccount, &secret) == nil {
 			return &secret, nil
 		}
 	}
@@ -282,9 +318,11 @@ func getOrCreateServiceAccountSecret(
 	// finally, create the sa token secret manually
 	// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token
 	// TODO ephemeral time-based tokens are preferred; we should re-think this
+	log.Infof("Creating token secret for service account %q", serviceAccount.Name)
+	secretName := tokenSecretName(serviceAccount.Name)
 	return client.Kube().CoreV1().Secrets(opt.Namespace).Create(ctx, &v1.Secret{
 		ObjectMeta: metav1.ObjectMeta{
-			Name:        tokenSecretName(serviceAccount.Name),
+			Name:        secretName,
 			Annotations: map[string]string{v1.ServiceAccountNameKey: serviceAccount.Name},
 		},
 		Type: v1.SecretTypeServiceAccountToken,
@@ -295,7 +333,7 @@ func tokenSecretName(saName string) string {
 	return saName + "-istio-remote-secret-token"
 }
 
-func validateServiceAccountSecret(serviceAccount *v1.ServiceAccount, secret *v1.Secret) error {
+func secretReferencesServiceAccount(serviceAccount *v1.ServiceAccount, secret *v1.Secret) error {
 	if secret.Type != v1.SecretTypeServiceAccountToken ||
 		secret.Annotations[v1.ServiceAccountNameKey] != serviceAccount.Name {
 		return fmt.Errorf("secret %s/%s does not reference ServiceAccount %s",
@@ -696,7 +734,7 @@ func createRemoteSecret(opt RemoteSecretOptions, client kube.ExtendedClient, env
 	var remoteSecret *v1.Secret
 	switch opt.AuthType {
 	case RemoteSecretAuthTypeBearerToken:
-		remoteSecret, err = createRemoteSecretFromTokenAndServer(tokenSecret, opt.ClusterName, server, secretName)
+		remoteSecret, err = createRemoteSecretFromTokenAndServer(client, tokenSecret, opt.ClusterName, server, secretName)
 	case RemoteSecretAuthTypePlugin:
 		authProviderConfig := &api.AuthProviderConfig{
 			Name:   opt.AuthPluginName,
diff --git a/istioctl/pkg/multicluster/remote_secret_test.go b/istioctl/pkg/multicluster/remote_secret_test.go
index 83ebe8c4a4..9365bcbd9a 100644
--- a/istioctl/pkg/multicluster/remote_secret_test.go
+++ b/istioctl/pkg/multicluster/remote_secret_test.go
@@ -21,6 +21,7 @@
 	"path/filepath"
 	"strings"
 	"testing"
+	"time"
 
 	"github.com/google/go-cmp/cmp"
 	. "github.com/onsi/gomega"
@@ -654,43 +655,66 @@ func TestCreateRemoteKubeconfig(t *testing.T) {
 `, "{cluster}", fakeClusterName)
 
 	cases := []struct {
-		name        string
-		clusterName string
-		context     string
-		server      string
-		in          *v1.Secret
-		want        *v1.Secret
-		wantErrStr  string
+		name               string
+		clusterName        string
+		context            string
+		server             string
+		haveTokenSecret    *v1.Secret
+		updatedTokenSecret *v1.Secret
+		wantRemoteSecret   *v1.Secret
+		wantErrStr         string
 	}{
 		{
-			name:        "missing caData",
-			in:          makeSecret("", "", "token"),
-			context:     "c0",
-			clusterName: fakeClusterName,
-			wantErrStr:  errMissingRootCAKey.Error(),
+			name:            "missing caData",
+			haveTokenSecret: makeSecret("", "", "token"),
+			context:         "c0",
+			clusterName:     fakeClusterName,
+			wantErrStr:      errMissingRootCAKey.Error(),
 		},
 		{
-			name:        "missing token",
-			in:          makeSecret("", "caData", ""),
-			context:     "c0",
-			clusterName: fakeClusterName,
-			wantErrStr:  errMissingTokenKey.Error(),
+			name:            "missing token",
+			haveTokenSecret: makeSecret("", "caData", ""),
+			context:         "c0",
+			clusterName:     fakeClusterName,
+			wantErrStr:      errMissingTokenKey.Error(),
 		},
 		{
-			name:        "bad server name",
-			in:          makeSecret("", "caData", "token"),
-			context:     "c0",
-			clusterName: fakeClusterName,
-			server:      "",
-			wantErrStr:  "invalid kubeconfig:",
+			name:            "bad server name",
+			haveTokenSecret: makeSecret("", "caData", "token"),
+			context:         "c0",
+			clusterName:     fakeClusterName,
+			server:          "",
+			wantErrStr:      "invalid kubeconfig:",
 		},
 		{
-			name:        "success",
-			in:          makeSecret("", "caData", "token"),
-			context:     "c0",
-			clusterName: fakeClusterName,
-			server:      "https://1.2.3.4",
-			want: &v1.Secret{
+			name:               "success after wait",
+			haveTokenSecret:    makeSecret("", "caData", ""),
+			updatedTokenSecret: makeSecret("", "caData", "token"), // token is populated later
+			context:            "c0",
+			clusterName:        fakeClusterName,
+			server:             "https://1.2.3.4",
+			wantRemoteSecret: &v1.Secret{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: remoteSecretNameFromClusterName(fakeClusterName),
+					Annotations: map[string]string{
+						clusterNameAnnotationKey: fakeClusterName,
+					},
+					Labels: map[string]string{
+						multicluster.MultiClusterSecretLabel: "true",
+					},
+				},
+				Data: map[string][]byte{
+					fakeClusterName: []byte(kubeconfig),
+				},
+			},
+		},
+		{
+			name:            "success",
+			haveTokenSecret: makeSecret("", "caData", "token"),
+			context:         "c0",
+			clusterName:     fakeClusterName,
+			server:          "https://1.2.3.4",
+			wantRemoteSecret: &v1.Secret{
 				ObjectMeta: metav1.ObjectMeta{
 					Name: remoteSecretNameFromClusterName(fakeClusterName),
 					Annotations: map[string]string{
@@ -706,11 +730,24 @@ func TestCreateRemoteKubeconfig(t *testing.T) {
 			},
 		},
 	}
+	oldBackoff := tokenWaitBackoff
+	tokenWaitBackoff = time.Millisecond
+	t.Cleanup(func() {
+		tokenWaitBackoff = oldBackoff
+	})
 	for i := range cases {
 		c := &cases[i]
 		secName := remoteSecretNameFromClusterName(c.clusterName)
 		t.Run(fmt.Sprintf("[%v] %v", i, c.name), func(tt *testing.T) {
-			got, err := createRemoteSecretFromTokenAndServer(c.in, c.clusterName, c.server, secName)
+			// no updateTokenSecret means re-fetching yields the same result
+			obj := []runtime.Object{c.haveTokenSecret}
+			if c.updatedTokenSecret != nil {
+				// fetching should give a different result than the token secret we pass in
+				obj = []runtime.Object{c.updatedTokenSecret}
+			}
+			client := kube.NewFakeClient(obj...)
+
+			got, err := createRemoteSecretFromTokenAndServer(client, c.haveTokenSecret, c.clusterName, c.server, secName)
 			if c.wantErrStr != "" {
 				if err == nil {
 					tt.Fatalf("wanted error including %q but none", c.wantErrStr)
@@ -719,8 +756,8 @@ func TestCreateRemoteKubeconfig(t *testing.T) {
 				}
 			} else if c.wantErrStr == "" && err != nil {
 				tt.Fatalf("wanted non-error but got %q", err)
-			} else if diff := cmp.Diff(got, c.want); diff != "" {
-				tt.Fatalf(" got %v\nwant %v\ndiff %v", got, c.want, diff)
+			} else if diff := cmp.Diff(got, c.wantRemoteSecret); diff != "" {
+				tt.Fatalf(" got %v\nwant %v\ndiff %v", got, c.wantRemoteSecret, diff)
 			}
 		})
 	}
diff --git a/prow/integ-suite-kind.sh b/prow/integ-suite-kind.sh
index 051b3025d5..acb68c3758 100755
--- a/prow/integ-suite-kind.sh
+++ b/prow/integ-suite-kind.sh
@@ -37,7 +37,7 @@ setup_and_export_git_sha
 source "${ROOT}/common/scripts/kind_provisioner.sh"
 
 TOPOLOGY=SINGLE_CLUSTER
-NODE_IMAGE="gcr.io/istio-testing/kind-node:v1.23.0"
+NODE_IMAGE="gcr.io/istio-testing/kind-node:v1.24.0-0.13.0"
 KIND_CONFIG=""
 CLUSTER_TOPOLOGY_CONFIG_FILE="${ROOT}/prow/config/topology/multicluster.json"
 
diff --git a/releasenotes/notes/38885.yaml b/releasenotes/notes/38885.yaml
new file mode 100644
index 0000000000..8520ac408e
--- /dev/null
+++ b/releasenotes/notes/38885.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: istioctl
+releaseNotes:
+- |
+  **Fixed** behavior for `istioctl create-remote-secret` on Kubernetes 1.24+. In these versions,
+  a Secret containing a ServiceAccount API token is no longer automatically created, so istioctl
+  will [create one](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token). 
-- 
2.35.3

