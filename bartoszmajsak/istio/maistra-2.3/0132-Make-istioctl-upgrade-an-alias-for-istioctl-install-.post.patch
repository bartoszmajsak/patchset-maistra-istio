From 7f8335c708918506c597820c8a839384f343d8ec Mon Sep 17 00:00:00 2001
From: Sam Naser <samnaser@google.com>
Date: Fri, 19 Nov 2021 15:20:03 -0800
Subject: Make istioctl upgrade an alias for istioctl install (#36168)

* Make istioctl upgrade an alias for istioctl install

* make gen
---
 go.mod                                        |   4 +-
 go.sum                                        |   5 -
 .../distribution/distribution/v3/LICENSE      | 202 ------
 operator/cmd/mesh/upgrade.go                  | 616 +-----------------
 operator/cmd/mesh/upgrade_test.go             |  91 ---
 5 files changed, 18 insertions(+), 900 deletions(-)
 delete mode 100644 licenses/github.com/distribution/distribution/v3/LICENSE
 delete mode 100644 operator/cmd/mesh/upgrade_test.go

diff --git a/go.mod b/go.mod
index b81b21bac1..36c755d97b 100644
--- a/go.mod
+++ b/go.mod
@@ -20,6 +20,8 @@ require (
 	cloud.google.com/go/security v1.1.0
 	contrib.go.opencensus.io/exporter/prometheus v0.4.0
 	github.com/AdaLogics/go-fuzz-headers v0.0.0-20210929163055-e81b3f25be97
+	github.com/Azure/go-autorest/autorest v0.11.20 // indirect
+	github.com/Azure/go-autorest/autorest/adal v0.9.15 // indirect
 	github.com/Masterminds/sprig/v3 v3.2.2
 	github.com/aws/aws-sdk-go v1.41.7
 	github.com/cenkalti/backoff/v4 v4.1.1
@@ -31,7 +33,6 @@ require (
 	github.com/coreos/go-oidc/v3 v3.1.0
 	github.com/cpuguy83/go-md2man/v2 v2.0.1 // indirect
 	github.com/davecgh/go-spew v1.1.1
-	github.com/distribution/distribution/v3 v3.0.0-20210926092439-1563384b69df
 	github.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021
 	github.com/evanphx/json-patch/v5 v5.6.0
 	github.com/fatih/color v1.13.0
@@ -79,6 +80,7 @@ require (
 	go.starlark.net v0.0.0-20211013185944-b0039bd2cfe3 // indirect
 	go.uber.org/atomic v1.9.0
 	go.uber.org/multierr v1.7.0
+	golang.org/x/crypto v0.0.0-20210817164053-32db794688a5 // indirect
 	golang.org/x/net v0.0.0-20211020060615-d418f374d309
 	golang.org/x/oauth2 v0.0.0-20211005180243-6b3c2da341f1
 	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c
diff --git a/go.sum b/go.sum
index 7a79f61306..da773560e0 100644
--- a/go.sum
+++ b/go.sum
@@ -61,7 +61,6 @@ git.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGy
 github.com/AdaLogics/go-fuzz-headers v0.0.0-20210929163055-e81b3f25be97 h1:MugkH51Bva2SjOXeb9+eIuGdphNSfQDBEDAmpY0C1V4=
 github.com/AdaLogics/go-fuzz-headers v0.0.0-20210929163055-e81b3f25be97/go.mod h1:WpB7kf89yJUETZxQnP1kgYPNwlT2jjdDYUCoxVggM3g=
 github.com/Azure/azure-sdk-for-go v16.2.1+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=
-github.com/Azure/azure-sdk-for-go v56.3.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=
 github.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=
 github.com/Azure/go-ansiterm v0.0.0-20210608223527-2377c96fe795/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=
 github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=
@@ -89,7 +88,6 @@ github.com/Azure/go-autorest/autorest/mocks v0.2.0/go.mod h1:OTyCOPRA2IgIlWxVYxB
 github.com/Azure/go-autorest/autorest/mocks v0.4.0/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=
 github.com/Azure/go-autorest/autorest/mocks v0.4.1 h1:K0laFcLE6VLTOwNgSxaGbUcLPuGXlNkbVvq4cW4nIHk=
 github.com/Azure/go-autorest/autorest/mocks v0.4.1/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=
-github.com/Azure/go-autorest/autorest/to v0.4.0/go.mod h1:fE8iZBn7LQR7zH/9XU2NcPR4o9jEImooCeWJcYV/zLE=
 github.com/Azure/go-autorest/logger v0.1.0/go.mod h1:oExouG+K6PryycPJfVSxi/koC6LSNgds39diKLz7Vrc=
 github.com/Azure/go-autorest/logger v0.2.0/go.mod h1:T9E3cAhj2VqvPOtCYAvby9aBXkZmbF5NWuPV8+WeEW8=
 github.com/Azure/go-autorest/logger v0.2.1 h1:IG7i4p/mDa2Ce4TRyAO8IHnVhAVF3RFU+ZtXWSmf4Tg=
@@ -385,8 +383,6 @@ github.com/denverdino/aliyungo v0.0.0-20190125010748-a747050bb1ba/go.mod h1:dV8l
 github.com/dgrijalva/jwt-go v0.0.0-20170104182250-a601269ab70c/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
 github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
 github.com/distribution/distribution/v3 v3.0.0-20210804104954-38ab4c606ee3/go.mod h1:gt38b7cvVKazi5XkHvINNytZXgTEntyhtyM3HQz46Nk=
-github.com/distribution/distribution/v3 v3.0.0-20210926092439-1563384b69df h1:zafDqOsnugdrReF9Pe0wybnfFtEIaegSyHNIvnwKPVk=
-github.com/distribution/distribution/v3 v3.0.0-20210926092439-1563384b69df/go.mod h1:ZDZib/BOniVWcXcsy0voU8gR00znhe5VJm47d3H2Y5g=
 github.com/dnaeon/go-vcr v1.0.1/go.mod h1:aBB1+wY4s93YsC3HHjMBMrwTj2R9FHDzUr9KyGc8n1E=
 github.com/docker/cli v20.10.7+incompatible h1:pv/3NqibQKphWZiAskMzdz8w0PRbtTaEB+f6NwdU7Is=
 github.com/docker/cli v20.10.7+incompatible/go.mod h1:JLrzqnKDaYBop7H2jaqPtU4hHvMKP+vjCwu2uszcLI8=
@@ -556,7 +552,6 @@ github.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5x
 github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
 github.com/godror/godror v0.24.2/go.mod h1:wZv/9vPiUib6tkoDl+AZ/QLf5YZgMravZ7jxH2eQWAE=
 github.com/gofrs/flock v0.8.0/go.mod h1:F1TvTiK9OcQqauNUHlbJvyl9Qa1QvF/gOUDKA14jxHU=
-github.com/gofrs/uuid v4.0.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=
 github.com/gogo/googleapis v1.2.0/go.mod h1:Njal3psf3qN6dwBtQfUmBZh2ybovJ0tlu3o/AC7HYjU=
 github.com/gogo/googleapis v1.4.0/go.mod h1:5YRNX2z1oM5gXdAkurHa942MDgEJyk02w4OecKY87+c=
 github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
diff --git a/licenses/github.com/distribution/distribution/v3/LICENSE b/licenses/github.com/distribution/distribution/v3/LICENSE
deleted file mode 100644
index e06d208186..0000000000
--- a/licenses/github.com/distribution/distribution/v3/LICENSE
+++ /dev/null
@@ -1,202 +0,0 @@
-Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
diff --git a/operator/cmd/mesh/upgrade.go b/operator/cmd/mesh/upgrade.go
index 986271aa56..7cf843ae5a 100644
--- a/operator/cmd/mesh/upgrade.go
+++ b/operator/cmd/mesh/upgrade.go
@@ -15,633 +15,47 @@
 package mesh
 
 import (
-	"context"
-	"encoding/json"
-	"fmt"
-	"os"
-	"runtime"
-	"strings"
 	"time"
 
-	"github.com/distribution/distribution/v3/reference"
-	goversion "github.com/hashicorp/go-version"
 	"github.com/spf13/cobra"
-	v1 "k8s.io/api/core/v1"
-	client_v1 "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset/typed/apiextensions/v1"
-	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/client-go/rest"
 
-	"istio.io/istio/istioctl/pkg/clioptions"
-	"istio.io/istio/istioctl/pkg/install/k8sversion"
-	"istio.io/istio/istioctl/pkg/verifier"
-	"istio.io/istio/operator/pkg/compare"
-	"istio.io/istio/operator/pkg/manifest"
-	"istio.io/istio/operator/pkg/name"
-	"istio.io/istio/operator/pkg/tpath"
-	"istio.io/istio/operator/pkg/util"
-	"istio.io/istio/operator/pkg/util/clog"
-	pkgversion "istio.io/istio/operator/pkg/version"
-	"istio.io/istio/pkg/kube"
 	"istio.io/pkg/log"
 )
 
-const (
-	// The duration that the command will wait between each check of the upgraded version.
-	upgradeWaitSecCheckVerPerLoop = 10 * time.Second
-	// The maximum number of attempts that the command will check for the upgrade completion,
-	// which means only the target version exist and the old version pods have been terminated.
-	upgradeWaitCheckVerMaxAttempts = 60
-
-	// This message provide the guide of how to upgrade Istio data plane
-	upgradeSidecarMessage = "To upgrade the Istio data plane, you will need to re-inject it.\n" +
-		"If you’re using automatic sidecar injection, you can upgrade the sidecar by doing a rolling" +
-		" update for all the pods:\n" +
-		"    kubectl rollout restart deployment --namespace <namespace with auto injection>\n" +
-		"If you’re using manual injection, you can upgrade the sidecar by executing:\n" +
-		"    kubectl apply -f < (istioctl kube-inject -f <original application deployment yaml>)"
-
-	// releaseURLPathTemplate is used to construct a download URL for a tar at a given version.
-	releaseURLPathTemplate = "https://github.com/istio/istio/releases/download/%s/istio-%s-%s"
-)
-
 type upgradeArgs struct {
-	// inFilenames is an array of paths to the input IstioOperator CR files.
-	inFilenames []string
-	// kubeConfigPath is the path to kube config file.
-	kubeConfigPath string
-	// context is the cluster context in the kube config.
-	context string
-	// readinessTimeout is maximum time to wait for all Istio resources to be ready.
-	readinessTimeout time.Duration
-	// set is a string with element format "path=value" where path is an IstioOperator path and the value is a
-	// value to set the node at that path to.
-	set []string
-	// skipConfirmation means skipping the prompting confirmation for value changes in this upgrade.
-	skipConfirmation bool
-	// force means directly applying the upgrade without eligibility checks.
-	force bool
-	// manifestsPath is a path to a charts and profiles directory in the local filesystem, or URL with a release tgz.
-	manifestsPath string
-	// verify verifies control plane health
-	verify bool
+	*installArgs
 }
 
-// addUpgradeFlags adds upgrade related flags into cobra command
 func addUpgradeFlags(cmd *cobra.Command, args *upgradeArgs) {
-	cmd.PersistentFlags().StringSliceVarP(&args.inFilenames, "filename",
-		"f", nil, filenameFlagHelpStr)
-	cmd.PersistentFlags().StringVarP(&args.kubeConfigPath, "kubeconfig",
-		"c", "", KubeConfigFlagHelpStr)
-	cmd.PersistentFlags().StringVar(&args.context, "context", "",
-		ContextFlagHelpStr)
-	cmd.PersistentFlags().BoolVarP(&args.skipConfirmation, "skip-confirmation", "y", false,
-		"If skip-confirmation is set, skips the prompting confirmation for value changes in this upgrade")
+	cmd.PersistentFlags().StringSliceVarP(&args.inFilenames, "filename", "f", nil, filenameFlagHelpStr)
+	cmd.PersistentFlags().StringVarP(&args.kubeConfigPath, "kubeconfig", "c", "", KubeConfigFlagHelpStr)
+	cmd.PersistentFlags().StringVar(&args.context, "context", "", ContextFlagHelpStr)
 	cmd.PersistentFlags().DurationVar(&args.readinessTimeout, "readiness-timeout", 300*time.Second,
 		"Maximum time to wait for Istio resources in each component to be ready.")
-	cmd.PersistentFlags().BoolVar(&args.force, "force", false,
-		"Apply the upgrade without eligibility checks")
+	cmd.PersistentFlags().BoolVarP(&args.skipConfirmation, "skip-confirmation", "y", false, skipConfirmationFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.force, "force", false, ForceFlagHelpStr)
+	cmd.PersistentFlags().BoolVar(&args.verify, "verify", false, VerifyCRInstallHelpStr)
 	cmd.PersistentFlags().StringArrayVarP(&args.set, "set", "s", nil, setFlagHelpStr)
 	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "charts", "", "", ChartsDeprecatedStr)
 	cmd.PersistentFlags().StringVarP(&args.manifestsPath, "manifests", "d", "", ManifestsFlagHelpStr)
-	cmd.PersistentFlags().BoolVar(&args.verify, "verify", false, VerifyCRInstallHelpStr)
 }
 
-// UpgradeCmd upgrades Istio control plane in-place with eligibility checks
+// UpgradeCmd upgrades Istio control plane in-place with eligibility checks.
 func UpgradeCmd(logOpts *log.Options) *cobra.Command {
-	macArgs := &upgradeArgs{}
 	rootArgs := &rootArgs{}
+	upgradeArgs := &upgradeArgs{
+		installArgs: &installArgs{},
+	}
 	cmd := &cobra.Command{
 		Use:   "upgrade",
 		Short: "Upgrade Istio control plane in-place",
-		Long: "The upgrade command checks for upgrade version eligibility and," +
-			" if eligible, upgrades the Istio control plane components in-place. Warning: " +
-			"traffic may be disrupted during upgrade. Please ensure PodDisruptionBudgets " +
-			"are defined to maintain service continuity.",
+		Long: "The upgrade command is an alias for the install command" +
+			" that performs additional upgrade-related checks.",
 		RunE: func(cmd *cobra.Command, args []string) (e error) {
-			l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.OutOrStderr(), installerScope)
-			initLogsOrExit(rootArgs)
-			err := upgrade(rootArgs, macArgs, logOpts, l)
-			if err != nil {
-				log.Infof("Error: %v\n", err)
-			}
-			return err
+			return runApplyCmd(cmd, rootArgs, upgradeArgs.installArgs, logOpts)
 		},
 	}
 	addFlags(cmd, rootArgs)
-	addUpgradeFlags(cmd, macArgs)
+	addUpgradeFlags(cmd, upgradeArgs)
 	return cmd
 }
-
-// upgrade is the main function for Upgrade command
-func upgrade(rootArgs *rootArgs, args *upgradeArgs, logOpts *log.Options, l clog.Logger) (err error) {
-	if err := configLogs(logOpts); err != nil {
-		return fmt.Errorf("could not configure logs: %s", err)
-	}
-
-	// Create a kube client from args.kubeConfigPath and  args.context
-	kubeClient, err := NewClient(args.kubeConfigPath, args.context)
-	if err != nil {
-		return fmt.Errorf("failed to connect Kubernetes API server, error: %v", err)
-	}
-	restConfig, clientset, client, err := K8sConfig(args.kubeConfigPath, args.context)
-	if err != nil {
-		return err
-	}
-	if err := k8sversion.IsK8VersionSupported(clientset, l); err != nil {
-		return err
-	}
-	setFlags := applyFlagAliases(args.set, args.manifestsPath, "")
-	// Generate IOPS parseObjectSetFromManifest
-	targetIOPYaml, targetIOP, err := manifest.GenerateConfig(args.inFilenames, setFlags, args.force, restConfig, l)
-	if err != nil {
-		return fmt.Errorf("failed to generate Istio configs from file %s, error: %s", args.inFilenames, err)
-	}
-
-	// Get the target version from the tag in the IOPS
-	targetTag := targetIOP.Spec.Tag
-	targetVersion, err := pkgversion.TagToVersionString(fmt.Sprint(targetTag))
-	if err != nil {
-		if !args.force {
-			return fmt.Errorf("failed to convert the target tag '%s' into a valid version, "+
-				"you can use --force flag to skip the version check if you know the tag is correct", targetTag)
-		}
-	}
-
-	// Get Istio control plane namespace
-	// TODO(elfinhe): support components distributed in multiple namespaces
-	istioNamespace := targetIOP.Namespace
-
-	// Read the current Istio version from the the cluster
-	currentVersion, err := retrieveControlPlaneVersion(kubeClient, istioNamespace, l)
-	if err != nil && !args.force {
-		return fmt.Errorf("failed to read the current Istio version, error: %v", err)
-	}
-
-	// Check if the upgrade currentVersion -> targetVersion is supported
-	err = checkSupportedVersions(kubeClient, currentVersion, targetVersion, l)
-	if err != nil && !args.force {
-		return fmt.Errorf("upgrade version check failed: %v -> %v. Error: %v",
-			currentVersion, targetVersion, err)
-	}
-	l.LogAndPrintf("Upgrade version check passed: %v -> %v.\n", currentVersion, targetVersion)
-
-	// Read the overridden IOP from args.inFilenames
-	overrideIOPYaml := ""
-	if args.inFilenames != nil {
-		overrideIOPYaml, err = manifest.ReadLayeredYAMLs(args.inFilenames)
-		if err != nil {
-			return fmt.Errorf("failed to read override IOPS from file: %v, error: %v", args.inFilenames, err)
-		}
-		if overrideIOPYaml != "" {
-			// Grab the IstioOperatorSpec subtree.
-			overrideIOPYaml, err = tpath.GetSpecSubtree(overrideIOPYaml)
-			if err != nil {
-				return fmt.Errorf("failed to get spec subtree from IOPS yaml, error: %v", err)
-			}
-		}
-	}
-
-	// Read the current installation's profile IOP yaml to check the changed profile settings between versions.
-	currentSets := args.set
-	if currentVersion != "" {
-		currentSets = append(currentSets, "installPackagePath="+releaseURLFromVersion(currentVersion))
-	}
-	profile := targetIOP.Spec.Profile
-	if profile == "" {
-		profile = name.DefaultProfileName
-	} else {
-		currentSets = append(currentSets, "profile="+targetIOP.Spec.Profile)
-	}
-	currentProfileIOPSYaml, _, err := manifest.GenIOPFromProfile(profile, "", currentSets, true, true, nil, l)
-	if err != nil {
-		return fmt.Errorf("failed to generate Istio configs from file %s for the current version: %s, error: %v",
-			args.inFilenames, currentVersion, err)
-	}
-	checkUpgradeIOPS(currentProfileIOPSYaml, targetIOPYaml, overrideIOPYaml, l)
-
-	waitForConfirmation(args.skipConfirmation || rootArgs.dryRun, l)
-
-	// Apply the Istio Control Plane specs reading from inFilenames to the cluster
-	iop, err := InstallManifests(targetIOP, args.force, rootArgs.dryRun, restConfig, client, args.readinessTimeout, l)
-	if err != nil {
-		return fmt.Errorf("failed to apply the Istio Control Plane specs. Error: %v", err)
-	}
-
-	if !rootArgs.dryRun {
-		// Waits for the upgrade to complete by periodically comparing the each
-		// component version to the target version.
-		err = waitUpgradeComplete(kubeClient, istioNamespace, targetVersion, l)
-		if err != nil {
-			return fmt.Errorf("failed to wait for the upgrade to complete. Error: %v", err)
-		}
-
-		// Read the upgraded Istio version from the the cluster
-		upgradeVer, err := retrieveControlPlaneVersion(kubeClient, istioNamespace, l)
-		if err != nil {
-			return fmt.Errorf("failed to read the upgraded Istio version. Error: %v", err)
-		}
-
-		l.LogAndPrintf("Success. Now the Istio control plane is running at version %v.\n", upgradeVer)
-	} else {
-		l.LogAndPrintf("Upgrade rollout completed. " +
-			"All Istio control plane pods are running on the target version.\n\n")
-		l.LogAndPrintf("Success. Now the Istio control plane is running at version %v.\n", targetVersion)
-	}
-
-	if args.verify {
-		if rootArgs.dryRun {
-			l.LogAndPrint("Control plane health check is not applicable for upgrade in dry-run mode")
-		} else {
-			l.LogAndPrint("\n\nVerifying installation after upgrade:")
-			installationVerifier := verifier.NewStatusVerifier(iop.Namespace, args.manifestsPath, args.kubeConfigPath,
-				args.context, args.inFilenames, clioptions.ControlPlaneOptions{Revision: iop.Spec.Revision}, l, iop)
-			if err := installationVerifier.Verify(); err != nil {
-				return fmt.Errorf("verification failed with the following error: %v", err)
-			}
-		}
-	}
-
-	l.LogAndPrintf(upgradeSidecarMessage)
-	return nil
-}
-
-// releaseURLFromVersion generates default installation url from version number.
-func releaseURLFromVersion(version string) string {
-	osArch := platformBasedTar()
-	return fmt.Sprintf(releaseURLPathTemplate, version, version, osArch)
-}
-
-func platformBasedTar() (tarExtension string) {
-	defaultExtension := "osx.tar.gz"
-	switch runtime.GOOS {
-	case "linux":
-		tarExtension = runtime.GOOS + "-" + runtime.GOARCH + ".tar.gz"
-	case "windows":
-		tarExtension = "win.zip"
-	case "darwin":
-		tarExtension = defaultExtension
-	default:
-		tarExtension = defaultExtension
-	}
-	return tarExtension
-}
-
-// checkUpgradeIOPS checks the upgrade eligibility by comparing the current IOPS with the target IOPS
-func checkUpgradeIOPS(curIOPS, tarIOPS, ignoreIOPS string, l clog.Logger) {
-	diff := compare.YAMLCmpWithIgnore(curIOPS, tarIOPS, nil, ignoreIOPS)
-	if util.IsYAMLEqual(curIOPS, tarIOPS) {
-		l.LogAndPrintf("Upgrade check: IOPS unchanged. The target IOPS are identical to the current IOPS.\n")
-	} else {
-		l.LogAndPrintf("Upgrade check: Warning!!! The following IOPS will be changed as part of upgrade. "+
-			"Please double check they are correct:\n%s", diff)
-	}
-}
-
-// waitForConfirmation waits for user's confirmation if skipConfirmation is not set
-func waitForConfirmation(skipConfirmation bool, l clog.Logger) {
-	if skipConfirmation {
-		return
-	}
-	if !confirm("Confirm to proceed [y/N]?", os.Stdout) {
-		l.LogAndFatalf("Abort.")
-	}
-}
-
-var upgradeSupportStart, _ = goversion.NewVersion("1.6.0")
-
-func checkSupportedVersions(kubeClient *Client, currentVersion, targetVersion string, l clog.Logger) error {
-	if err := verifySupportedVersion(currentVersion, targetVersion, l); err != nil {
-		return err
-	}
-	return kubeClient.CheckUnsupportedAlphaSecurityCRD()
-}
-
-func verifySupportedVersion(currentVersion, targetVersion string, l clog.Logger) error {
-	curGoVersion, err := goversion.NewVersion(currentVersion)
-	if err != nil {
-		return fmt.Errorf("failed to parse the current version %q: %v", currentVersion, err)
-	}
-	targetGoVersion, err := goversion.NewVersion(targetVersion)
-	if err != nil {
-		return fmt.Errorf("failed to parse the target version %q: %v", targetVersion, err)
-	}
-	if upgradeSupportStart.Segments()[1] > curGoVersion.Segments()[1] {
-		return fmt.Errorf("upgrade is not supported before version: %v", upgradeSupportStart)
-	}
-	// Warn if user is trying skip one minor verion eg: 1.6.x to 1.8.x
-	if (targetGoVersion.Segments()[1] - curGoVersion.Segments()[1]) > 1 {
-		l.LogAndPrint("!!! WARNING !!!")
-		l.LogAndPrintf("Upgrading across more than one minor version (e.g., %v to %v)"+
-			" in one step is not officially tested or recommended.\n", curGoVersion, targetGoVersion)
-	}
-	return nil
-}
-
-// retrieveControlPlaneVersion retrieves the version number from the Istio control plane
-func retrieveControlPlaneVersion(kubeClient ExecClient, istioNamespace string, l clog.Logger) (string, error) {
-	cv, e := kubeClient.GetIstioVersions(istioNamespace)
-	if e != nil {
-		return "", fmt.Errorf("failed to retrieve Istio control plane version, error: %v", e)
-	}
-
-	if len(cv) == 0 {
-		return "", fmt.Errorf("istio control plane not found in namespace: %v", istioNamespace)
-	}
-
-	for _, remote := range cv {
-		l.LogAndPrintf("Control Plane - %v", remote)
-	}
-	l.LogAndPrint("")
-
-	v, e := coalesceVersions(cv)
-	if e != nil {
-		return "", e
-	}
-	return v, nil
-}
-
-// waitUpgradeComplete waits for the upgrade to complete by periodically comparing the current component version
-// to the target version.
-func waitUpgradeComplete(kubeClient ExecClient, istioNamespace string, targetVer string, l clog.Logger) error {
-	for i := 1; i <= upgradeWaitCheckVerMaxAttempts; i++ {
-		sleepSeconds(upgradeWaitSecCheckVerPerLoop)
-		cv, e := kubeClient.GetIstioVersions(istioNamespace)
-		if e != nil {
-			l.LogAndPrintf("Failed to retrieve Istio control plane version, error: %v", e)
-			continue
-		}
-		if cv == nil {
-			l.LogAndPrintf("Failed to find Istio namespace: %v", istioNamespace)
-			continue
-		}
-		if identicalVersions(cv) && targetVer == cv[0].Version {
-			l.LogAndPrintf("Upgrade rollout completed. " +
-				"All Istio control plane pods are running on the target version.\n\n")
-			return nil
-		}
-		for _, remote := range cv {
-			if targetVer != remote.Version {
-				l.LogAndPrintf("Control Plane - %v does not match the target version %s",
-					remote, targetVer)
-			}
-		}
-	}
-	return fmt.Errorf("upgrade rollout unfinished. Maximum number of attempts exceeded")
-}
-
-// sleepSeconds sleeps for n seconds, printing a dot '.' per second
-func sleepSeconds(duration time.Duration) {
-	for t := time.Duration(0); t < duration; t += time.Second {
-		time.Sleep(time.Second)
-		fmt.Print(".")
-	}
-	fmt.Println()
-}
-
-// coalesceVersions coalesces all Istio control plane components versions
-func coalesceVersions(cv []ComponentVersion) (string, error) {
-	if len(cv) == 0 {
-		return "", fmt.Errorf("empty list of ComponentVersion")
-	}
-	if !identicalVersions(cv) {
-		return "", fmt.Errorf("different versions of Istio components found: %v", cv)
-	}
-	return cv[0].Version, nil
-}
-
-// identicalVersions checks if Istio control plane components are on the same version
-func identicalVersions(cv []ComponentVersion) bool {
-	exemplar := cv[0]
-	for i := 1; i < len(cv); i++ {
-		if exemplar.Version != cv[i].Version {
-			return false
-		}
-	}
-	return true
-}
-
-// Client is a helper wrapper around the Kube RESTClient for istioctl -> Pilot/Envoy/Mesh related things
-type Client struct {
-	Config *rest.Config
-	*rest.RESTClient
-}
-
-// ComponentVersion is a pair of component name and version
-type ComponentVersion struct {
-	Component string
-	Version   string
-	Pod       v1.Pod
-}
-
-func (cv ComponentVersion) String() string {
-	return fmt.Sprintf("%s pod - %s - version: %s",
-		cv.Component, cv.Pod.GetName(), cv.Version)
-}
-
-// ExecClient is an interface for remote execution
-type ExecClient interface {
-	GetIstioVersions(namespace string) ([]ComponentVersion, error)
-	GetPods(namespace string, params map[string]string) (*v1.PodList, error)
-	PodsForSelector(namespace, labelSelector string) (*v1.PodList, error)
-	ConfigMapForSelector(namespace, labelSelector string) (*v1.ConfigMapList, error)
-}
-
-// NewClient is the constructor for the client wrapper
-func NewClient(kubeconfig, configContext string) (*Client, error) {
-	config, err := kube.DefaultRestConfig(kubeconfig, configContext)
-	if err != nil {
-		return nil, err
-	}
-	restClient, err := rest.RESTClientFor(config)
-	if err != nil {
-		return nil, err
-	}
-	return &Client{config, restClient}, nil
-}
-
-// GetIstioVersions gets the version for each Istio component
-func (client *Client) GetIstioVersions(namespace string) ([]ComponentVersion, error) {
-	pods, err := client.GetPods(namespace, map[string]string{
-		"labelSelector": "istio",
-		"fieldSelector": "status.phase=Running",
-	})
-	if err != nil {
-		return nil, fmt.Errorf("failed to retrieve Istio pods, error: %v", err)
-	}
-	if len(pods.Items) == 0 {
-		return nil, fmt.Errorf("istio pod not found in namespace %v", namespace)
-	}
-
-	var errs util.Errors
-	var res []ComponentVersion
-	for _, pod := range pods.Items {
-		// label for components app: istiod, istio-ingressgateway, istio-egressgateway
-		component := pod.Labels["app"]
-
-		switch component {
-		case "statsd-prom-bridge":
-			continue
-		case "mixer":
-			continue
-		}
-
-		server := ComponentVersion{
-			Component: component,
-			Pod:       pod,
-		}
-
-		pv := ""
-		for _, c := range pod.Spec.Containers {
-			cv, err := parseTag(c.Image)
-			if err != nil {
-				errs = util.AppendErr(errs, err)
-			}
-
-			if pv == "" {
-				pv = cv
-			} else if pv != cv {
-				err := fmt.Errorf("different versions of containers in the same pod: %v", pod.Name)
-				errs = util.AppendErr(errs, err)
-			}
-		}
-		server.Version, err = pkgversion.TagToVersionString(pv)
-		if err != nil {
-			tagErr := fmt.Errorf("unable to convert tag %s into version in pod: %v", pv, pod.Name)
-			errs = util.AppendErr(errs, tagErr)
-		}
-		res = append(res, server)
-	}
-	return res, errs.ToError()
-}
-
-func parseTag(image string) (string, error) {
-	ref, err := reference.Parse(image)
-	if err != nil {
-		return "", fmt.Errorf("could not parse image: %s, error: %v", image, err)
-	}
-
-	switch t := ref.(type) {
-	case reference.Tagged:
-		return t.Tag(), nil
-	default:
-		return "", fmt.Errorf("tag not found in image: %v", image)
-	}
-}
-
-func (client *Client) PodsForSelector(namespace, labelSelector string) (*v1.PodList, error) {
-	pods, err := client.GetPods(namespace, map[string]string{
-		"labelSelector": labelSelector,
-	})
-	if err != nil {
-		return nil, fmt.Errorf("failed to retrieve pods, error: %v", err)
-	}
-	return pods, nil
-}
-
-// GetPods retrieves the pod objects for Istio deployments
-func (client *Client) GetPods(namespace string, params map[string]string) (*v1.PodList, error) {
-	req := client.Get().
-		Resource("pods").
-		Namespace(namespace)
-	for k, v := range params {
-		req.Param(k, v)
-	}
-
-	res := req.Do(context.TODO())
-	if res.Error() != nil {
-		return nil, fmt.Errorf("unable to retrieve Pods: %v", res.Error())
-	}
-	list := &v1.PodList{}
-	if err := res.Into(list); err != nil {
-		return nil, fmt.Errorf("unable to parse PodList: %v", res.Error())
-	}
-	return list, nil
-}
-
-func (client *Client) ConfigMapForSelector(namespace, labelSelector string) (*v1.ConfigMapList, error) {
-	cmGet := client.Get().Resource("configmaps").Namespace(namespace).Param("labelSelector", labelSelector)
-	obj, err := cmGet.Do(context.TODO()).Get()
-	if err != nil {
-		return nil, fmt.Errorf("failed retrieving configmap: %v", err)
-	}
-	return obj.(*v1.ConfigMapList), nil
-}
-
-func (client *Client) CheckUnsupportedAlphaSecurityCRD() error {
-	c, err := client_v1.NewForConfig(client.Config)
-	if err != nil {
-		return err
-	}
-	crds, err := c.CustomResourceDefinitions().List(context.TODO(), meta_v1.ListOptions{})
-	if err != nil {
-		return fmt.Errorf("failed to get CRDs: %v", err)
-	}
-
-	unsupportedCRD := func(name string) bool {
-		crds := []string{
-			"clusterrbacconfigs.rbac.istio.io",
-			"rbacconfigs.rbac.istio.io",
-			"servicerolebindings.rbac.istio.io",
-			"serviceroles.rbac.istio.io",
-			"policies.authentication.istio.io",
-			"meshpolicies.authentication.istio.io",
-		}
-		for _, crd := range crds {
-			if name == crd {
-				return true
-			}
-		}
-		return false
-	}
-	getResource := func(crd string) []string {
-		type ResourceItem struct {
-			Metadata meta_v1.ObjectMeta `json:"metadata,omitempty"`
-		}
-		type Resource struct {
-			Items []ResourceItem `json:"items"`
-		}
-
-		parts := strings.Split(crd, ".")
-		cmd := client.Get().AbsPath("apis", strings.Join(parts[1:], "."), "v1alpha1", parts[0])
-		obj, err := cmd.DoRaw(context.TODO())
-		if err != nil {
-			log.Errorf("failed to get resources for crd %s: %v", crd, err)
-			return nil
-		}
-		resource := &Resource{}
-		if err := json.Unmarshal(obj, resource); err != nil {
-			log.Errorf("failed decoding response for crd %s: %v", crd, err)
-			return nil
-		}
-		var foundResources []string
-		for _, res := range resource.Items {
-			n := strings.Join([]string{crd, res.Metadata.Namespace, res.Metadata.Name}, "/")
-			foundResources = append(foundResources, n)
-		}
-		return foundResources
-	}
-
-	var foundCRDs []string
-	var foundResources []string
-	for _, crd := range crds.Items {
-		if unsupportedCRD(crd.Name) {
-			foundCRDs = append(foundCRDs, crd.Name)
-			foundResources = append(foundResources, getResource(crd.Name)...)
-		}
-	}
-	if len(foundCRDs) != 0 {
-		log.Warnf("found %d CRD of unsupported v1alpha1 security policy: %v. "+
-			"The v1alpha1 security policy is no longer supported starting 1.6. It's strongly recommended to delete "+
-			"the CRD of the v1alpha1 security policy to avoid applying any of the v1alpha1 security policy in the unsupported version",
-			len(foundCRDs), foundCRDs)
-	}
-	if len(foundResources) != 0 {
-		return fmt.Errorf("found %d unsupported v1alpha1 security policy: %v. "+
-			"The v1alpha1 security policy is no longer supported starting 1.6. To continue the upgrade, "+
-			"Please migrate to the v1beta1 security policy and delete all the v1alpha1 security policy, "+
-			"See https://istio.io/news/releases/1.5.x/announcing-1.5/upgrade-notes/#authentication-policy and "+
-			"https://istio.io/blog/2019/v1beta1-authorization-policy/#migration-from-the-v1alpha1-policy",
-			len(foundResources), foundResources)
-	}
-	return nil
-}
diff --git a/operator/cmd/mesh/upgrade_test.go b/operator/cmd/mesh/upgrade_test.go
deleted file mode 100644
index 28bb87b6bf..0000000000
--- a/operator/cmd/mesh/upgrade_test.go
+++ /dev/null
@@ -1,91 +0,0 @@
-// Copyright Istio Authors.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package mesh
-
-import (
-	"fmt"
-	"os"
-	"testing"
-
-	"istio.io/istio/operator/pkg/util/clog"
-)
-
-func TestVerifySupportedVersions(t *testing.T) {
-	cases := []struct {
-		currentVer string
-		targetVer  string
-		err        error
-		isValid    bool
-	}{
-		{
-			currentVer: "",
-			targetVer:  "1.9.0",
-			err:        fmt.Errorf("failed to parse the current version %v: Malformed version: ", ""),
-			isValid:    false,
-		},
-		{
-			currentVer: "master",
-			targetVer:  "1.9.0",
-			err:        fmt.Errorf("failed to parse the current version %v: Malformed version: ", "master"),
-			isValid:    false,
-		},
-		{
-			currentVer: "1.7.4",
-			targetVer:  "1.8.0",
-			err:        nil,
-			isValid:    true,
-		},
-		{
-			currentVer: "1.8.0",
-			targetVer:  "1.9.0",
-			err:        nil,
-			isValid:    true,
-		},
-		{
-			currentVer: "1.8.0",
-			targetVer:  "1.7.4",
-			err:        nil,
-			isValid:    true,
-		},
-		{
-			currentVer: "1.9.0",
-			targetVer:  "",
-			err:        fmt.Errorf("failed to parse the target version %v: Malformed version: %v", "", ""),
-			isValid:    false,
-		},
-		{
-			currentVer: "1.5.8",
-			targetVer:  "1.8.0",
-			err:        fmt.Errorf("upgrade is not supported before version: %v", upgradeSupportStart),
-			isValid:    false,
-		},
-		{
-			currentVer: "1.8.0",
-			targetVer:  "1.8.0",
-			err:        nil,
-			isValid:    true,
-		},
-	}
-
-	for i, c := range cases {
-		t.Run(fmt.Sprintf("case %d %s", i, c.currentVer), func(t *testing.T) {
-			l := clog.NewConsoleLogger(os.Stdout, os.Stderr, nil)
-			err := verifySupportedVersion(c.currentVer, c.targetVer, l)
-			if c.isValid && err != nil {
-				t.Errorf("(curr: %v)(target: %v)(%v)", c.currentVer, c.targetVer, err)
-			}
-		})
-	}
-}
-- 
2.35.3

