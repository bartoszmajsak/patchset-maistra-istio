From 32dae1c548b3f2d866e5678439598733d45ccb07 Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Sat, 5 Mar 2022 11:21:58 +0530
Subject: check key and cert are valid before sending to Envoy (#37722)

* check key and cert are valid before sending to Envoy

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* fix tests

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* fix tests

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 security/pkg/nodeagent/cache/secretcache.go    | 18 +++++++++++++++---
 .../pkg/nodeagent/cache/secretcache_test.go    |  7 +++++--
 2 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/security/pkg/nodeagent/cache/secretcache.go b/security/pkg/nodeagent/cache/secretcache.go
index afe6f52574..6a4bd81446 100644
--- a/security/pkg/nodeagent/cache/secretcache.go
+++ b/security/pkg/nodeagent/cache/secretcache.go
@@ -17,6 +17,8 @@
 
 import (
 	"bytes"
+	"crypto/tls"
+	"errors"
 	"fmt"
 	"os"
 	"path/filepath"
@@ -411,9 +413,19 @@ func (sc *SecretManagerClient) generateRootCertFromExistingFile(rootCertPath, re
 // Generate a key and certificate item from the existing key certificate files from the passed in file paths.
 func (sc *SecretManagerClient) generateKeyCertFromExistingFiles(certChainPath, keyPath, resourceName string) (*security.SecretItem, error) {
 	// There is a remote possibility that key is written and cert is not written yet.
-	// To handle that case, we wait for some time here.
-	timer := time.After(sc.configOptions.FileDebounceDuration)
-	<-timer
+	// To handle that case, check if cert and key are valid if they are valid then only send to proxy.
+	b := backoff.NewExponentialBackOff()
+	b.InitialInterval = sc.configOptions.FileDebounceDuration
+	secretValid := func() error {
+		_, err := tls.LoadX509KeyPair(certChainPath, keyPath)
+		if errors.Is(err, os.ErrNotExist) {
+			return backoff.Permanent(err)
+		}
+		return err
+	}
+	if err := backoff.Retry(secretValid, b); err != nil {
+		return nil, err
+	}
 	return sc.keyCertSecretItem(certChainPath, keyPath, resourceName)
 }
 
diff --git a/security/pkg/nodeagent/cache/secretcache_test.go b/security/pkg/nodeagent/cache/secretcache_test.go
index 1e225ea0fd..de2f4fb42c 100644
--- a/security/pkg/nodeagent/cache/secretcache_test.go
+++ b/security/pkg/nodeagent/cache/secretcache_test.go
@@ -377,13 +377,17 @@ func runFileAgentTest(t *testing.T, sds bool) {
 	if err := file.AtomicWrite(sc.existingCertificateFile.CertificatePath, testcerts.RotatedCert, os.FileMode(0o644)); err != nil {
 		t.Fatal(err)
 	}
+	if err := file.AtomicWrite(sc.existingCertificateFile.PrivateKeyPath, testcerts.RotatedKey, os.FileMode(0o644)); err != nil {
+		t.Fatal(err)
+	}
+
 	// Expect update callback
 	u.Expect(map[string]int{workloadResource: 1})
 	// On the next generate call, we should get the new cert
 	checkSecret(t, sc, workloadResource, security.SecretItem{
 		ResourceName:     workloadResource,
 		CertificateChain: testcerts.RotatedCert,
-		PrivateKey:       privateKey,
+		PrivateKey:       testcerts.RotatedKey,
 	})
 
 	if err := file.AtomicWrite(sc.existingCertificateFile.PrivateKeyPath, testcerts.RotatedKey, os.FileMode(0o644)); err != nil {
@@ -391,7 +395,6 @@ func runFileAgentTest(t *testing.T, sds bool) {
 	}
 	// We do NOT expect update callback. We only watch the cert file, since the key and cert must be updated
 	// in tandem.
-	// TODO: what if they update out of sync? We probably shouldn't send an update of just one change
 	u.Expect(map[string]int{workloadResource: 1})
 	checkSecret(t, sc, workloadResource, security.SecretItem{
 		ResourceName:     workloadResource,
-- 
2.35.3

