From d6a211197f70101219f9e7b0b0bd866b82522e56 Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Thu, 26 May 2022 17:51:33 +0530
Subject: separate webhook patching from namespace controller (#39137)

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 pilot/pkg/leaderelection/leaderelection.go    |  1 +
 .../kube/controller/multicluster.go           | 46 +++++++++++--------
 2 files changed, 28 insertions(+), 19 deletions(-)

diff --git a/pilot/pkg/leaderelection/leaderelection.go b/pilot/pkg/leaderelection/leaderelection.go
index 2ed5199ba3..d0335a5a09 100644
--- a/pilot/pkg/leaderelection/leaderelection.go
+++ b/pilot/pkg/leaderelection/leaderelection.go
@@ -37,6 +37,7 @@
 // Various locks used throughout the code
 const (
 	NamespaceController     = "istio-namespace-controller-election"
+	WebhookPatcher          = "istio-webhook-patcher-election"
 	ServiceExportController = "istio-serviceexport-controller-election"
 	// This holds the legacy name to not conflict with older control plane deployments which are just
 	// doing the ingress syncing.
diff --git a/pilot/pkg/serviceregistry/kube/controller/multicluster.go b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
index 5e74f0db5a..ec0882c92f 100644
--- a/pilot/pkg/serviceregistry/kube/controller/multicluster.go
+++ b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
@@ -218,29 +218,37 @@ func (m *Multicluster) ClusterAdded(cluster *multicluster.Cluster, clusterStopCh
 					client.RunAndWait(clusterStopCh)
 					nc.Run(leaderStop)
 				})
-			// Set up injection webhook patching for remote clusters we are controlling.
-			// The local cluster has this patching set up elsewhere. We may eventually want to move it here.
-			if features.ExternalIstiod && !localCluster && m.caBundleWatcher != nil {
-				// Patch injection webhook cert
-				// This requires RBAC permissions - a low-priv Istiod should not attempt to patch but rely on
-				// operator or CI/CD
-				if features.InjectionWebhookConfigName != "" {
-					election = election.
-						AddRunFunction(func(leaderStop <-chan struct{}) {
-							log.Infof("initializing webhook cert patch for cluster %s", cluster.ID)
-							patcher, err := webhooks.NewWebhookCertPatcher(client, m.revision, webhookName, m.caBundleWatcher)
-							if err != nil {
-								log.Errorf("could not initialize webhook cert patcher: %v", err)
-							} else {
-								patcher.Run(leaderStop)
-							}
-						})
-				}
-			}
 			election.Run(clusterStopCh)
 			return nil
 		})
 	}
+	// Set up injection webhook patching for remote clusters we are controlling.
+	// The local cluster has this patching set up elsewhere. We may eventually want to move it here.
+	if features.ExternalIstiod && !localCluster && m.caBundleWatcher != nil {
+		// Patch injection webhook cert
+		// This requires RBAC permissions - a low-priv Istiod should not attempt to patch but rely on
+		// operator or CI/CD
+		if features.InjectionWebhookConfigName != "" {
+			// Block server exit on graceful termination of the leader controller.
+			m.s.RunComponentAsyncAndWait(func(_ <-chan struct{}) error {
+				log.Infof("joining leader-election for %s in %s on cluster %s",
+					leaderelection.WebhookPatcher, options.SystemNamespace, options.ClusterID)
+				election := leaderelection.
+					NewLeaderElectionMulticluster(options.SystemNamespace, m.serverID, leaderelection.WebhookPatcher, m.revision, !localCluster, client).
+					AddRunFunction(func(leaderStop <-chan struct{}) {
+						log.Infof("initializing webhook cert patch for cluster %s", cluster.ID)
+						patcher, err := webhooks.NewWebhookCertPatcher(client, m.revision, webhookName, m.caBundleWatcher)
+						if err != nil {
+							log.Errorf("could not initialize webhook cert patcher: %v", err)
+						} else {
+							patcher.Run(leaderStop)
+						}
+					})
+				election.Run(clusterStopCh)
+				return nil
+			})
+		}
+	}
 
 	// setting up the serviceexport controller if and only if it is turned on in the meshconfig.
 	if features.EnableMCSAutoExport {
-- 
2.35.3

