From e048ab8b983a156dd42d51aa56b6c086acd44454 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Wed, 9 Feb 2022 12:55:01 -0800
Subject: Switch default LB algorithm to LEAST_REQUEST (#37220)

Also adding an environment variable to revert the default globally.
---
 pilot/pkg/features/pilot.go                     |  7 +++++++
 pilot/pkg/networking/core/v1alpha3/cluster.go   | 11 +++++++++--
 .../core/v1alpha3/cluster_builder_test.go       |  4 +++-
 .../networking/core/v1alpha3/cluster_test.go    |  6 +++---
 pkg/test/framework/features/features.gen.go     |  2 +-
 .../framework/tools/featuresgen/cmd/root.go     |  3 ++-
 .../notes/new_lb_algorithm_default.yaml         | 17 +++++++++++++++++
 .../mcs/discoverability/discoverability_test.go | 17 +++++++++++------
 tests/integration/pilot/multicluster_test.go    | 15 +++++++++++----
 tests/integration/telemetry/constants.go        |  2 +-
 10 files changed, 65 insertions(+), 19 deletions(-)
 create mode 100644 releasenotes/notes/new_lb_algorithm_default.yaml

diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 5f57fc662d..96e297dd1c 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -284,6 +284,13 @@
 			"ENABLE_MCS_HOST also be enabled.").Get() &&
 		EnableMCSHost
 
+	EnableLegacyLBAlgorithmDefault = env.RegisterBoolVar(
+		"ENABLE_LEGACY_LB_ALGORITHM_DEFAULT",
+		false,
+		"If enabled, destinations for which no LB algorithm is specified will use the legacy "+
+			"default, ROUND_ROBIN. Care should be taken when using ROUND_ROBIN in general as it can "+
+			"overburden endpoints, especially when weights are used.").Get()
+
 	EnableAnalysis = env.RegisterBoolVar(
 		"PILOT_ENABLE_ANALYSIS",
 		false,
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster.go b/pilot/pkg/networking/core/v1alpha3/cluster.go
index ff39335a27..9e291dbe6a 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster.go
@@ -692,6 +692,13 @@ func applyOutlierDetection(c *cluster.Cluster, outlier *networking.OutlierDetect
 	}
 }
 
+func defaultLBAlgorithm() cluster.Cluster_LbPolicy {
+	if features.EnableLegacyLBAlgorithmDefault {
+		return cluster.Cluster_ROUND_ROBIN
+	}
+	return cluster.Cluster_LEAST_REQUEST
+}
+
 func applyLoadBalancer(c *cluster.Cluster, lb *networking.LoadBalancerSettings, port *model.Port,
 	locality *core.Locality, proxyLabels map[string]string, meshConfig *meshconfig.MeshConfig) {
 	localityLbSetting := loadbalancer.GetLocalityLbSetting(meshConfig.GetLocalityLbSetting(), lb.GetLocalityLbSetting())
@@ -708,7 +715,7 @@ func applyLoadBalancer(c *cluster.Cluster, lb *networking.LoadBalancerSettings,
 	applyLocalityLBSetting(locality, proxyLabels, c, localityLbSetting)
 
 	// apply default round robin lb policy
-	c.LbPolicy = cluster.Cluster_ROUND_ROBIN
+	c.LbPolicy = defaultLBAlgorithm()
 	if c.GetType() == cluster.Cluster_ORIGINAL_DST {
 		c.LbPolicy = cluster.Cluster_CLUSTER_PROVIDED
 		return
@@ -736,7 +743,7 @@ func applyLoadBalancer(c *cluster.Cluster, lb *networking.LoadBalancerSettings,
 		c.LbPolicy = cluster.Cluster_CLUSTER_PROVIDED
 		c.ClusterDiscoveryType = &cluster.Cluster_Type{Type: cluster.Cluster_ORIGINAL_DST}
 	default:
-		c.LbPolicy = cluster.Cluster_ROUND_ROBIN
+		c.LbPolicy = defaultLBAlgorithm()
 	}
 
 	ApplyRingHashLoadBalancer(c, lb)
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster_builder_test.go b/pilot/pkg/networking/core/v1alpha3/cluster_builder_test.go
index dee4559822..3c33c79d53 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster_builder_test.go
@@ -891,7 +891,8 @@ func TestBuildDefaultCluster(t *testing.T) {
 				CircuitBreakers: &cluster.CircuitBreakers{
 					Thresholds: []*cluster.CircuitBreakers_Thresholds{getDefaultCircuitBreakerThresholds()},
 				},
-				Filters: []*cluster.Filter{xdsfilters.TCPClusterMx},
+				Filters:  []*cluster.Filter{xdsfilters.TCPClusterMx},
+				LbPolicy: defaultLBAlgorithm(),
 				Metadata: &core.Metadata{
 					FilterMetadata: map[string]*structpb.Struct{
 						util.IstioMetadataKey: {
@@ -979,6 +980,7 @@ func TestBuildDefaultCluster(t *testing.T) {
 				ClusterDiscoveryType: &cluster.Cluster_Type{Type: cluster.Cluster_STATIC},
 				ConnectTimeout:       &durationpb.Duration{Seconds: 10, Nanos: 1},
 				Filters:              []*cluster.Filter{xdsfilters.TCPClusterMx},
+				LbPolicy:             defaultLBAlgorithm(),
 				LoadAssignment: &endpoint.ClusterLoadAssignment{
 					ClusterName: "foo",
 					Endpoints: []*endpoint.LocalityLbEndpoints{
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster_test.go b/pilot/pkg/networking/core/v1alpha3/cluster_test.go
index 89b2b1eb18..8bfb062706 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster_test.go
@@ -1503,14 +1503,14 @@ func TestRedisProtocolWithPassThroughResolutionAtGateway(t *testing.T) {
 			name:          "redis disabled",
 			redisEnabled:  false,
 			resolution:    model.ClientSideLB,
-			lbType:        cluster.Cluster_ROUND_ROBIN,
+			lbType:        defaultLBAlgorithm(),
 			discoveryType: cluster.Cluster_EDS,
 		},
 		{
 			name:          "redis disabled passthrough",
 			redisEnabled:  false,
 			resolution:    model.Passthrough,
-			lbType:        cluster.Cluster_ROUND_ROBIN,
+			lbType:        defaultLBAlgorithm(),
 			discoveryType: cluster.Cluster_EDS,
 		},
 		{
@@ -1701,7 +1701,7 @@ func TestApplyLoadBalancer(t *testing.T) {
 			},
 			discoveryType:                  cluster.Cluster_EDS,
 			port:                           &model.Port{Protocol: protocol.HTTP},
-			expectedLbPolicy:               cluster.Cluster_ROUND_ROBIN,
+			expectedLbPolicy:               defaultLBAlgorithm(),
 			expectedLocalityWeightedConfig: true,
 		},
 		// TODO: add more to cover all cases
diff --git a/pkg/test/framework/features/features.gen.go b/pkg/test/framework/features/features.gen.go
index 30529d5615..5f8416636f 100644
--- a/pkg/test/framework/features/features.gen.go
+++ b/pkg/test/framework/features/features.gen.go
@@ -11,7 +11,7 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-	
+
 //WARNING: THIS IS AN AUTO-GENERATED FILE, DO NOT EDIT.
 
 package features
diff --git a/pkg/test/framework/tools/featuresgen/cmd/root.go b/pkg/test/framework/tools/featuresgen/cmd/root.go
index b943755434..657edd98a3 100644
--- a/pkg/test/framework/tools/featuresgen/cmd/root.go
+++ b/pkg/test/framework/tools/featuresgen/cmd/root.go
@@ -40,7 +40,8 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-	`
+
+`
 
 	GeneratedWarning = `
 //WARNING: THIS IS AN AUTO-GENERATED FILE, DO NOT EDIT.
diff --git a/releasenotes/notes/new_lb_algorithm_default.yaml b/releasenotes/notes/new_lb_algorithm_default.yaml
new file mode 100644
index 0000000000..b6489db0a5
--- /dev/null
+++ b/releasenotes/notes/new_lb_algorithm_default.yaml
@@ -0,0 +1,17 @@
+apiVersion: release-notes/v2
+kind: feature
+area: traffic-management
+
+releaseNotes:
+  - |
+    **Updated** Istio's default load balancing algorithm from `ROUND_ROBIN` to `LEAST_REQUEST`.
+    The `ROUND_ROBIN` algorithm can lead to overburdened endpoints, especially when weights
+    are used. The `LEAST_REQUEST` algorithm, distributes more evenly across and is far less
+    likely to overburden endpoints. A number of experiments (by both the Istio and
+    Envoy teams) have shown that `LEAST_REQUEST` outperforms `ROUND_ROBIN` in virtually all
+    cases, with little/no downsides. It's generally considered a drop-in replacement for
+    ROUND_ROBIN.
+    
+    `ROUND_ROBIN` will continue to be supported if explicitly specified. To restore
+    `ROUND_ROBIN` as the default, set the istiod environment variable
+    `ENABLE_LEGACY_LB_ALGORITHM_DEFAULT=true`.
diff --git a/tests/integration/pilot/mcs/discoverability/discoverability_test.go b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
index 89df418381..0ec7ced8b4 100644
--- a/tests/integration/pilot/mcs/discoverability/discoverability_test.go
+++ b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
@@ -62,6 +62,8 @@ func (ht hostType) String() string {
 const (
 	hostTypeClusterLocal    hostType = "cluster.local"
 	hostTypeClusterSetLocal hostType = "clusterset.local"
+
+	requestCountMultiplier = 20
 )
 
 var (
@@ -69,6 +71,7 @@ func (ht hostType) String() string {
 	echos common.EchoDeployment
 
 	retryTimeout = retry.Timeout(1 * time.Minute)
+	retryDelay   = retry.Delay(500 * time.Millisecond)
 
 	hostTypes = []hostType{hostTypeClusterSetLocal, hostTypeClusterLocal}
 )
@@ -105,7 +108,7 @@ func TestClusterLocal(t *testing.T) {
 							// is only available for a service when it is exported in at least one cluster.
 							validator = validateDNSLookupFailed()
 						}
-						callAndValidate(t, ht, src, dst[0], validator)
+						callAndValidate(t, ht, src, dst, validator)
 					})
 				})
 			}
@@ -130,7 +133,7 @@ func TestMeshWide(t *testing.T) {
 							// Ensure that requests to clusterset.local reach all destination clusters.
 							expectedClusters = dst.Clusters()
 						}
-						callAndValidate(t, ht, src, dst[0], validateClustersReached(expectedClusters))
+						callAndValidate(t, ht, src, dst, validateClustersReached(expectedClusters))
 					})
 				})
 			}
@@ -171,7 +174,7 @@ func TestServiceExportedInOneCluster(t *testing.T) {
 											expectedClusters = append(expectedClusters, src.Config().Cluster)
 										}
 									}
-									callAndValidate(t, ht, src, dst[0], validateClustersReached(expectedClusters))
+									callAndValidate(t, ht, src, dst, validateClustersReached(expectedClusters))
 								})
 							})
 						}
@@ -232,9 +235,11 @@ func validateDNSLookupFailed() echo.Validator {
 	}))
 }
 
-func callAndValidate(t framework.TestContext, ht hostType, src, dest echo.Instance, validator echo.Validator) {
+func callAndValidate(t framework.TestContext, ht hostType, src echo.Instance, dst echo.Instances, validator echo.Validator) {
 	t.Helper()
 
+	dest := dst[0]
+
 	var address string
 	if ht == hostTypeClusterSetLocal {
 		// Call the service using the MCS ClusterSet host.
@@ -246,10 +251,10 @@ func callAndValidate(t framework.TestContext, ht hostType, src, dest echo.Instan
 	_, err := src.CallWithRetry(echo.CallOptions{
 		Address:   address,
 		Target:    dest,
-		Count:     20,
+		Count:     requestCountMultiplier * len(dst),
 		PortName:  "http",
 		Validator: validator,
-	}, retry.Delay(time.Millisecond*500), retryTimeout)
+	}, retryDelay, retryTimeout)
 	if err != nil {
 		t.Fatalf("failed calling host %s: %v\nCluster Details:\n%s", address, err,
 			getClusterDetailsYAML(t, address, src, dest))
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index 96e9379a90..99b450dc4e 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -35,6 +35,13 @@
 	"istio.io/istio/pkg/test/util/tmpl"
 )
 
+const multiclusterRequestCountMultiplier = 20
+
+var (
+	multiclusterRetryTimeout = retry.Timeout(1 * time.Minute)
+	multiclusterRetryDelay   = retry.Delay(500 * time.Millisecond)
+)
+
 func TestClusterLocal(t *testing.T) {
 	framework.NewTest(t).
 		Features(
@@ -116,14 +123,14 @@ func(t framework.TestContext) {
 						t.NewSubTest(source.Config().Cluster.StableName()).RunParallel(func(t framework.TestContext) {
 							source.CallWithRetryOrFail(t, echo.CallOptions{
 								Target:   destination[0],
-								Count:    3 * len(destination),
+								Count:    multiclusterRequestCountMultiplier * len(destination),
 								PortName: "http",
 								Scheme:   scheme.HTTP,
 								Validator: echo.And(
 									echo.ExpectOK(),
 									echo.ExpectReachedClusters(cluster.Clusters{source.Config().Cluster}),
 								),
-							})
+							}, multiclusterRetryDelay, multiclusterRetryTimeout)
 						})
 					}
 				})
@@ -136,14 +143,14 @@ func(t framework.TestContext) {
 					t.NewSubTest(source.Config().Cluster.StableName()).Run(func(t framework.TestContext) {
 						source.CallWithRetryOrFail(t, echo.CallOptions{
 							Target:   destination[0],
-							Count:    3 * len(destination),
+							Count:    multiclusterRequestCountMultiplier * len(destination),
 							PortName: "http",
 							Scheme:   scheme.HTTP,
 							Validator: echo.And(
 								echo.ExpectOK(),
 								echo.ExpectReachedClusters(destination.Clusters()),
 							),
-						})
+						}, multiclusterRetryDelay, multiclusterRetryTimeout)
 					})
 				}
 			})
diff --git a/tests/integration/telemetry/constants.go b/tests/integration/telemetry/constants.go
index 9d46ad570e..656834dd4a 100644
--- a/tests/integration/telemetry/constants.go
+++ b/tests/integration/telemetry/constants.go
@@ -20,5 +20,5 @@
 const (
 	// For multicluster tests we multiply the number of requests with a
 	// constant multiplier to make sure we have cross cluster traffic.
-	RequestCountMultipler = 3
+	RequestCountMultipler = 20
 )
-- 
2.35.3

