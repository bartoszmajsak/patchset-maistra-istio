From 8d13c070def1510971b0779007d8901cd4acadec Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Wed, 30 Mar 2022 15:00:57 +0530
Subject: use same ipv6 detection logic every where (#38100)

* use same ipv6 detection logic every where

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* fix test

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* fix ut

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* bc

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 pilot/cmd/pilot-agent/main.go                 |  9 +++-
 pilot/cmd/pilot-agent/options/agent.go        |  4 +-
 pilot/cmd/pilot-agent/options/statusserver.go |  3 +-
 pilot/pkg/model/context.go                    | 20 ++-------
 pilot/pkg/util/network/ip.go                  | 43 ++++++++++++++++---
 pilot/pkg/util/network/ip_test.go             | 34 ++++++++++++++-
 pkg/bootstrap/config.go                       |  2 +-
 pkg/envoy/proxy.go                            |  2 +-
 8 files changed, 85 insertions(+), 32 deletions(-)

diff --git a/pilot/cmd/pilot-agent/main.go b/pilot/cmd/pilot-agent/main.go
index fedd2c30c4..e28fd8b8c6 100644
--- a/pilot/cmd/pilot-agent/main.go
+++ b/pilot/cmd/pilot-agent/main.go
@@ -220,8 +220,11 @@ func initStatusServer(ctx context.Context, proxy *model.Proxy, proxyConfig *mesh
 }
 
 func initStsServer(proxy *model.Proxy, tokenManager security.TokenManager) (*stsserver.Server, error) {
-	localHostAddr := localHostIPv4
-	if network.IsIPv6Proxy(proxy.IPAddresses) {
+	localHostAddr := ""
+	// Prefer IPv4 address for backward compatibility.
+	if proxy.SupportsIPv4() {
+		localHostAddr = localHostIPv4
+	} else if proxy.SupportsIPv6() {
 		localHostAddr = localHostIPv6
 	}
 	stsServer, err := stsserver.NewServer(stsserver.Config{
@@ -284,6 +287,8 @@ func initProxy(args []string) (*model.Proxy, error) {
 		proxy.IPAddresses = append(proxy.IPAddresses, localHostIPv4, localHostIPv6)
 	}
 
+	proxy.DiscoverIPVersions()
+
 	// Extract pod variables.
 	podName := options.PodNameVar.Get()
 	podNamespace := options.PodNamespaceVar.Get()
diff --git a/pilot/cmd/pilot-agent/options/agent.go b/pilot/cmd/pilot-agent/options/agent.go
index c8a472f552..942992051d 100644
--- a/pilot/cmd/pilot-agent/options/agent.go
+++ b/pilot/cmd/pilot-agent/options/agent.go
@@ -21,7 +21,6 @@
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/network"
 	"istio.io/istio/pkg/bootstrap/platform"
 	istioagent "istio.io/istio/pkg/istio-agent"
 )
@@ -30,13 +29,12 @@
 const xdsHeaderPrefix = "XDS_HEADER_"
 
 func NewAgentOptions(proxy *model.Proxy, cfg *meshconfig.ProxyConfig) *istioagent.AgentOptions {
-	proxy.DiscoverIPVersions()
 	o := &istioagent.AgentOptions{
 		XDSRootCerts:                xdsRootCA,
 		CARootCerts:                 caRootCA,
 		XDSHeaders:                  map[string]string{},
 		XdsUdsPath:                  filepath.Join(cfg.ConfigPath, "XDS"),
-		IsIPv6:                      network.IsIPv6Proxy(proxy.IPAddresses),
+		IsIPv6:                      proxy.SupportsIPv6(),
 		ProxyType:                   proxy.Type,
 		EnableDynamicProxyConfig:    enableProxyConfigXdsEnv,
 		EnableDynamicBootstrap:      enableBootstrapXdsEnv,
diff --git a/pilot/cmd/pilot-agent/options/statusserver.go b/pilot/cmd/pilot-agent/options/statusserver.go
index 613ba782ef..d0f6e4df53 100644
--- a/pilot/cmd/pilot-agent/options/statusserver.go
+++ b/pilot/cmd/pilot-agent/options/statusserver.go
@@ -19,13 +19,12 @@
 	"istio.io/istio/pilot/cmd/pilot-agent/status"
 	"istio.io/istio/pilot/cmd/pilot-agent/status/ready"
 	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/util/network"
 	istioagent "istio.io/istio/pkg/istio-agent"
 )
 
 func NewStatusServerOptions(proxy *model.Proxy, proxyConfig *meshconfig.ProxyConfig, agent *istioagent.Agent) *status.Options {
 	return &status.Options{
-		IPv6:           network.IsIPv6Proxy(proxy.IPAddresses),
+		IPv6:           proxy.SupportsIPv6(),
 		PodIP:          InstanceIPVar.Get(),
 		AdminPort:      uint16(proxyConfig.ProxyAdminPort),
 		StatusPort:     uint16(proxyConfig.StatusPort),
diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 5b44505adb..eb8fc1f130 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -35,6 +35,7 @@
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/trustbundle"
+	networkutil "istio.io/istio/pilot/pkg/util/network"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
@@ -854,22 +855,9 @@ func (node *Proxy) SetWorkloadLabels(env *Environment) {
 
 // DiscoverIPVersions discovers the IP Versions supported by Proxy based on its IP addresses.
 func (node *Proxy) DiscoverIPVersions() {
-	for i := 0; i < len(node.IPAddresses); i++ {
-		addr := net.ParseIP(node.IPAddresses[i])
-		if addr == nil {
-			// Should not happen, invalid IP in proxy's IPAddresses slice should have been caught earlier,
-			// skip it to prevent a panic.
-			continue
-		}
-		if node.GlobalUnicastIP == "" && addr.IsGlobalUnicast() {
-			node.GlobalUnicastIP = addr.String()
-		}
-		if addr.To4() != nil {
-			node.ipv4Support = true
-		} else {
-			node.ipv6Support = true
-		}
-	}
+	node.GlobalUnicastIP = networkutil.GlobalUnicastIP(node.IPAddresses)
+	node.ipv6Support = networkutil.IsIPv6(node.IPAddresses)
+	node.ipv4Support = networkutil.IsIPv4(node.IPAddresses)
 }
 
 // SupportsIPv4 returns true if proxy supports IPv4 addresses.
diff --git a/pilot/pkg/util/network/ip.go b/pilot/pkg/util/network/ip.go
index b3a74a1ecd..f9a3bdc1b2 100644
--- a/pilot/pkg/util/network/ip.go
+++ b/pilot/pkg/util/network/ip.go
@@ -141,9 +141,26 @@ func ResolveAddr(addr string, lookupIPAddr ...lookupIPAddrType) (string, error)
 	return resolvedAddr, nil
 }
 
-// IsIPv6Proxy check the addresses slice and returns true for all addresses are valid IPv6 address
-// for all other cases it returns false
-func IsIPv6Proxy(ipAddrs []string) bool {
+// IsIPv6 checks the addresses slice and returns true if atleast one of the addresses
+// is a valid IPv6 address, for all other cases it returns false.
+func IsIPv6(ipAddrs []string) bool {
+	for i := 0; i < len(ipAddrs); i++ {
+		addr := net.ParseIP(ipAddrs[i])
+		if addr == nil {
+			// Should not happen, invalid IP in proxy's IPAddresses slice should have been caught earlier,
+			// skip it to prevent a panic.
+			continue
+		}
+		if addr.To4() == nil && addr.To16() != nil {
+			return true
+		}
+	}
+	return false
+}
+
+// IsIPv4 checks the addresses slice and returns true if atleast one of the addresses
+// is a valid IPv64 address, for all other cases it returns false.
+func IsIPv4(ipAddrs []string) bool {
 	for i := 0; i < len(ipAddrs); i++ {
 		addr := net.ParseIP(ipAddrs[i])
 		if addr == nil {
@@ -152,8 +169,24 @@ func IsIPv6Proxy(ipAddrs []string) bool {
 			continue
 		}
 		if addr.To4() != nil {
-			return false
+			return true
+		}
+	}
+	return false
+}
+
+// GlobalUnicastIP returns the first global unicast address in the passed in addresses.
+func GlobalUnicastIP(ipAddrs []string) string {
+	for i := 0; i < len(ipAddrs); i++ {
+		addr := net.ParseIP(ipAddrs[i])
+		if addr == nil {
+			// Should not happen, invalid IP in proxy's IPAddresses slice should have been caught earlier,
+			// skip it to prevent a panic.
+			continue
+		}
+		if addr.IsGlobalUnicast() {
+			return addr.String()
 		}
 	}
-	return true
+	return ""
 }
diff --git a/pilot/pkg/util/network/ip_test.go b/pilot/pkg/util/network/ip_test.go
index aca5e85716..d361baaa2e 100644
--- a/pilot/pkg/util/network/ip_test.go
+++ b/pilot/pkg/util/network/ip_test.go
@@ -183,7 +183,7 @@ func TestResolveAddr(t *testing.T) {
 	}
 }
 
-func TestIsIPv6Proxy(t *testing.T) {
+func TestIsIPv6(t *testing.T) {
 	tests := []struct {
 		name     string
 		addrs    []string
@@ -202,11 +202,41 @@ func TestIsIPv6Proxy(t *testing.T) {
 		{
 			name:     "mixed ipv4 and ipv6",
 			addrs:    []string{"1111:2222::1", "::1", "127.0.0.1", "2.2.2.2", "2222:3333::1"},
+			expected: true,
+		},
+	}
+	for _, tt := range tests {
+		result := IsIPv6(tt.addrs)
+		if result != tt.expected {
+			t.Errorf("Test %s failed, expected: %t got: %t", tt.name, tt.expected, result)
+		}
+	}
+}
+
+func TestIsIPv4(t *testing.T) {
+	tests := []struct {
+		name     string
+		addrs    []string
+		expected bool
+	}{
+		{
+			name:     "ipv4 only",
+			addrs:    []string{"1.1.1.1", "127.0.0.1", "2.2.2.2"},
+			expected: true,
+		},
+		{
+			name:     "ipv6 only",
+			addrs:    []string{"1111:2222::1", "::1", "2222:3333::1"},
 			expected: false,
 		},
+		{
+			name:     "mixed ipv4 and ipv6",
+			addrs:    []string{"1111:2222::1", "::1", "127.0.0.1", "2.2.2.2", "2222:3333::1"},
+			expected: true,
+		},
 	}
 	for _, tt := range tests {
-		result := IsIPv6Proxy(tt.addrs)
+		result := IsIPv4(tt.addrs)
 		if result != tt.expected {
 			t.Errorf("Test %s failed, expected: %t got: %t", tt.name, tt.expected, result)
 		}
diff --git a/pkg/bootstrap/config.go b/pkg/bootstrap/config.go
index c41b5457a0..ee580505b1 100644
--- a/pkg/bootstrap/config.go
+++ b/pkg/bootstrap/config.go
@@ -115,7 +115,7 @@ func (cfg Config) toTemplateParams() (map[string]interface{}, error) {
 	opts = append(opts, getNodeMetadataOptions(cfg.Node)...)
 
 	// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly
-	if network.IsIPv6Proxy(cfg.Metadata.InstanceIPs) {
+	if network.IsIPv6(cfg.Metadata.InstanceIPs) {
 		opts = append(opts,
 			option.Localhost(option.LocalhostIPv6),
 			option.Wildcard(option.WildcardIPv6),
diff --git a/pkg/envoy/proxy.go b/pkg/envoy/proxy.go
index b7120c37ae..54fb005144 100644
--- a/pkg/envoy/proxy.go
+++ b/pkg/envoy/proxy.go
@@ -113,7 +113,7 @@ func (e *envoy) UpdateConfig(config []byte) error {
 
 func (e *envoy) args(fname string, epoch int, bootstrapConfig string) []string {
 	proxyLocalAddressType := "v4"
-	if network.IsIPv6Proxy(e.NodeIPs) {
+	if network.IsIPv6(e.NodeIPs) {
 		proxyLocalAddressType = "v6"
 	}
 	startupArgs := []string{
-- 
2.35.3

