From 767cf87039af74a83c7aadf62002e3b4b125f442 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 27 Jan 2022 12:55:37 -0800
Subject: Simulation for LB algorithm evaluation (#36917)

---
 .../loadbalancersim/histogram/histogram.go    | 103 +++++
 pkg/test/loadbalancersim/lb_test.go           | 381 ++++++++++++++++++
 pkg/test/loadbalancersim/loadbalancer/edf.go  | 105 +++++
 .../loadbalancer/leastrequest.go              | 129 ++++++
 .../loadbalancersim/loadbalancer/priority.go  |  32 ++
 .../loadbalancer/roundrobin.go                |  52 +++
 .../loadbalancersim/loadbalancer/weight.go    | 107 +++++
 pkg/test/loadbalancersim/locality/locality.go |  40 ++
 pkg/test/loadbalancersim/locality/match.go    |  46 +++
 pkg/test/loadbalancersim/mesh/client.go       |  68 ++++
 pkg/test/loadbalancersim/mesh/mesh.go         | 101 +++++
 pkg/test/loadbalancersim/mesh/node.go         | 116 ++++++
 .../loadbalancersim/network/connection.go     |  59 +++
 pkg/test/loadbalancersim/network/helper.go    |  84 ++++
 pkg/test/loadbalancersim/timer/queue.go       | 188 +++++++++
 15 files changed, 1611 insertions(+)
 create mode 100644 pkg/test/loadbalancersim/histogram/histogram.go
 create mode 100644 pkg/test/loadbalancersim/lb_test.go
 create mode 100644 pkg/test/loadbalancersim/loadbalancer/edf.go
 create mode 100644 pkg/test/loadbalancersim/loadbalancer/leastrequest.go
 create mode 100644 pkg/test/loadbalancersim/loadbalancer/priority.go
 create mode 100644 pkg/test/loadbalancersim/loadbalancer/roundrobin.go
 create mode 100644 pkg/test/loadbalancersim/loadbalancer/weight.go
 create mode 100644 pkg/test/loadbalancersim/locality/locality.go
 create mode 100644 pkg/test/loadbalancersim/locality/match.go
 create mode 100644 pkg/test/loadbalancersim/mesh/client.go
 create mode 100644 pkg/test/loadbalancersim/mesh/mesh.go
 create mode 100644 pkg/test/loadbalancersim/mesh/node.go
 create mode 100644 pkg/test/loadbalancersim/network/connection.go
 create mode 100644 pkg/test/loadbalancersim/network/helper.go
 create mode 100644 pkg/test/loadbalancersim/timer/queue.go

diff --git a/pkg/test/loadbalancersim/histogram/histogram.go b/pkg/test/loadbalancersim/histogram/histogram.go
new file mode 100644
index 0000000000..948b8b1bfc
--- /dev/null
+++ b/pkg/test/loadbalancersim/histogram/histogram.go
@@ -0,0 +1,103 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package histogram
+
+import (
+	"math"
+	"sort"
+)
+
+var (
+	negativeInfinity = math.Inf(-1)
+	infinity         = math.Inf(1)
+	nan              = math.NaN()
+)
+
+type Instance []float64
+
+func (h Instance) Min() float64 {
+	return h.sorted().min()
+}
+
+func (h Instance) Max() float64 {
+	return h.sorted().max()
+}
+
+func (h Instance) Mean() float64 {
+	total := float64(0)
+	for _, v := range h {
+		total += v
+	}
+	return total / float64(len(h))
+}
+
+func (h Instance) Quantile(phi float64) float64 {
+	return h.sorted().quantile(phi)
+}
+
+func (h Instance) Quantiles(phis ...float64) []float64 {
+	return h.sorted().quantiles(phis...)
+}
+
+func (h Instance) sorted() sorted {
+	out := make(sorted, 0, len(h))
+	out = append(out, h...)
+
+	sort.Float64s(out)
+	return out
+}
+
+type sorted []float64
+
+func (s sorted) min() float64 {
+	if len(s) == 0 {
+		return negativeInfinity
+	}
+
+	return s[0]
+}
+
+func (s sorted) max() float64 {
+	if len(s) == 0 {
+		return infinity
+	}
+
+	return s[len(s)-1]
+}
+
+func (s sorted) quantile(phi float64) float64 {
+	if len(s) == 0 || math.IsNaN(phi) {
+		return nan
+	}
+	if phi <= 0 {
+		return s.min()
+	}
+	if phi >= 1 {
+		return s.max()
+	}
+	idx := uint(phi*float64(len(s)-1) + 0.5)
+	if idx >= uint(len(s)) {
+		idx = uint(len(s) - 1)
+	}
+	return s[idx]
+}
+
+func (s sorted) quantiles(phis ...float64) []float64 {
+	out := make([]float64, 0, len(phis))
+	for _, phi := range phis {
+		out = append(out, s.quantile(phi))
+	}
+	return out
+}
diff --git a/pkg/test/loadbalancersim/lb_test.go b/pkg/test/loadbalancersim/lb_test.go
new file mode 100644
index 0000000000..05654243dd
--- /dev/null
+++ b/pkg/test/loadbalancersim/lb_test.go
@@ -0,0 +1,381 @@
+//go:build lbsim
+// +build lbsim
+
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancersim
+
+import (
+	"fmt"
+	"os"
+	"sort"
+	"strings"
+	"sync"
+	"testing"
+	"time"
+
+	"istio.io/istio/pkg/test/loadbalancersim/histogram"
+	"istio.io/istio/pkg/test/loadbalancersim/loadbalancer"
+	"istio.io/istio/pkg/test/loadbalancersim/locality"
+	"istio.io/istio/pkg/test/loadbalancersim/mesh"
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+)
+
+func TestLoadBalancing(t *testing.T) {
+	serviceTime := 20 * time.Millisecond
+	numClients := 1
+	clientInterval := 10 * time.Millisecond
+	clientBurst := 10
+	clientDuration := 2 * time.Second
+	activeRequestBias := 1.0
+	sameZone := locality.Parse("us-east/ny")
+	sameRegion := locality.Parse("us-east/boston")
+	otherRegion := locality.Parse("asia-east/hongkong")
+	priorityWeights := map[uint32]uint32{
+		0: 30,
+		1: 20,
+		2: 1,
+	}
+	networkLatencies := map[mesh.RouteKey]time.Duration{
+		mesh.RouteKey{
+			Src:  sameZone,
+			Dest: sameZone,
+		}: 1 * time.Millisecond,
+		mesh.RouteKey{
+			Src:  sameZone,
+			Dest: sameRegion,
+		}: 10 * time.Millisecond,
+		mesh.RouteKey{
+			Src:  sameZone,
+			Dest: otherRegion,
+		}: 50 * time.Millisecond,
+	}
+
+	networkLatencyCases := []struct {
+		enable    bool
+		latencies map[mesh.RouteKey]time.Duration
+	}{
+		{
+			enable:    false,
+			latencies: make(map[mesh.RouteKey]time.Duration),
+		},
+		{
+			enable:    true,
+			latencies: networkLatencies,
+		},
+	}
+
+	weightCases := []struct {
+		enableWeighting       bool
+		newWeightedConnection loadbalancer.WeightedConnectionFactory
+	}{
+		{
+			enableWeighting:       false,
+			newWeightedConnection: loadbalancer.EquallyWeightedConnectionFactory(),
+		},
+		{
+			enableWeighting:       true,
+			newWeightedConnection: loadbalancer.PriorityWeightedConnectionFactory(loadbalancer.LocalityPrioritySelector, priorityWeights),
+		},
+	}
+
+	algorithmCases := []struct {
+		name  string
+		newLB func(conns []*loadbalancer.WeightedConnection) network.Connection
+	}{
+		{
+			name:  "round robin",
+			newLB: loadbalancer.NewRoundRobin,
+		},
+		{
+			name: "least request",
+			newLB: func(conns []*loadbalancer.WeightedConnection) network.Connection {
+				return loadbalancer.NewLeastRequest(loadbalancer.LeastRequestSettings{
+					Connections:       conns,
+					ActiveRequestBias: activeRequestBias,
+				})
+			},
+		},
+	}
+
+	topologyCases := []struct {
+		name             string
+		countSameZone    int
+		countSameRegion  int
+		countOtherRegion int
+	}{
+		{
+			name:             "all local",
+			countSameZone:    6,
+			countSameRegion:  0,
+			countOtherRegion: 0,
+		},
+		{
+			name:             "even",
+			countSameZone:    2,
+			countSameRegion:  2,
+			countOtherRegion: 2,
+		},
+		{
+			name:             "one remote",
+			countSameZone:    4,
+			countSameRegion:  1,
+			countOtherRegion: 1,
+		},
+		{
+			name:             "one local",
+			countSameZone:    1,
+			countSameRegion:  3,
+			countOtherRegion: 3,
+		},
+	}
+
+	var sm suiteMetrics
+	for _, enableQueueLatency := range []bool{false, true} {
+		t.Run("queue latency "+toggleStr(enableQueueLatency), func(t *testing.T) {
+			for _, networkLatencyCase := range networkLatencyCases {
+				t.Run("network latency "+toggleStr(networkLatencyCase.enable), func(t *testing.T) {
+					for _, weightCase := range weightCases {
+						weightCase := weightCase
+						t.Run("weighting "+toggleStr(weightCase.enableWeighting), func(t *testing.T) {
+							for _, algorithmCase := range algorithmCases {
+								algorithmCase := algorithmCase
+								t.Run(algorithmCase.name, func(t *testing.T) {
+									for _, topologyCase := range topologyCases {
+										topologyCase := topologyCase
+										t.Run(topologyCase.name, func(t *testing.T) {
+											m := mesh.New(mesh.Settings{
+												NetworkLatencies: networkLatencyCase.latencies,
+											})
+											defer m.ShutDown()
+
+											// Create the new test output.
+											tm := &testMetrics{
+												hasNetworkLatency: networkLatencyCase.enable,
+												hasQueueLatency:   enableQueueLatency,
+												weighted:          weightCase.enableWeighting,
+												algorithm:         algorithmCase.name,
+												topology:          topologyCase.name,
+											}
+											sm = append(sm, tm)
+
+											// Create the clients.
+											for i := 0; i < numClients; i++ {
+												_ = m.NewClient(mesh.ClientSettings{
+													Interval: clientInterval,
+													Burst:    clientBurst,
+													Locality: sameZone,
+												})
+											}
+
+											// Allocate the nodes in the configured topology.
+											m.NewNodes(topologyCase.countSameZone, serviceTime, enableQueueLatency, sameZone)
+											m.NewNodes(topologyCase.countSameRegion, serviceTime, enableQueueLatency, sameRegion)
+											m.NewNodes(topologyCase.countOtherRegion, serviceTime, enableQueueLatency, otherRegion)
+
+											runTest(t, testSettings{
+												mesh:                  m,
+												clientDuration:        clientDuration,
+												activeRequestBias:     activeRequestBias,
+												newWeightedConnection: weightCase.newWeightedConnection,
+												newLB:                 algorithmCase.newLB,
+											}, tm)
+										})
+									}
+								})
+							}
+						})
+					}
+				})
+			}
+		})
+	}
+
+	outputFile := os.Getenv("LB_SIM_OUTPUT_FILE")
+	if len(outputFile) == 0 {
+		homeDir, err := os.UserHomeDir()
+		if err != nil {
+			t.Fatal(err)
+		}
+		outputFile = fmt.Sprintf("%s/lb_output.csv", homeDir)
+	}
+
+	err := os.WriteFile(outputFile, []byte(sm.toCSV()), 0644)
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func toggleStrUpper(on bool) string {
+	return strings.ToUpper(toggleStr(on))
+}
+
+func toggleStr(on bool) string {
+	if on {
+		return "on"
+	}
+	return "off"
+}
+
+type testSettings struct {
+	mesh                  *mesh.Instance
+	clientDuration        time.Duration
+	newLB                 func(conns []*loadbalancer.WeightedConnection) network.Connection
+	newWeightedConnection loadbalancer.WeightedConnectionFactory
+	activeRequestBias     float64
+}
+
+type testMetrics struct {
+	hasQueueLatency     bool
+	hasNetworkLatency   bool
+	weighted            bool
+	algorithm           string
+	topology            string
+	latencyAvg          float64
+	latencyMin          float64
+	latencyMax          float64
+	nodesSameZone       int
+	nodesSameRegion     int
+	nodesOtherRegion    int
+	requestsSameZone    uint64
+	requestsSameRegion  uint64
+	requestsOtherRegion uint64
+}
+
+func (tm testMetrics) totalRequests() uint64 {
+	return tm.requestsSameZone + tm.requestsSameRegion + tm.requestsOtherRegion
+}
+
+func (tm testMetrics) sameZonePercent() float64 {
+	return (float64(tm.requestsSameZone) / float64(tm.totalRequests())) * 100
+}
+
+func (tm testMetrics) sameRegionPercent() float64 {
+	return (float64(tm.requestsSameRegion) / float64(tm.totalRequests())) * 100
+}
+
+func (tm testMetrics) otherRegionPercent() float64 {
+	return (float64(tm.requestsOtherRegion) / float64(tm.totalRequests())) * 100
+}
+
+func (tm testMetrics) String() string {
+	out := ""
+	out += fmt.Sprintf("     Requests: %d\n", tm.totalRequests())
+	out += fmt.Sprintf("     Topology: Same Zone=%d, Same Region=%d, Other Region=%d\n", tm.nodesSameZone, tm.nodesSameRegion, tm.nodesOtherRegion)
+	out += fmt.Sprintf("Latency (avg): %6.2fs\n", tm.latencyAvg)
+	out += fmt.Sprintf("Latency (min): %6.2fs\n", tm.latencyMin)
+	out += fmt.Sprintf("Latency (max): %6.2fs\n", tm.latencyMax)
+	out += fmt.Sprintf("    Same Zone: %6.2f%%\n", tm.sameZonePercent())
+	out += fmt.Sprintf("  Same Region: %6.2f%%\n", tm.sameRegionPercent())
+	out += fmt.Sprintf(" Other Region: %6.2f%%\n", tm.otherRegionPercent())
+	return out
+}
+
+func (tm testMetrics) toCSV() string {
+	return fmt.Sprintf("%s,%s,%s,%s,%s,%f,%f,%f,%f,%f,%f", tm.topology,
+		toggleStrUpper(tm.weighted), toggleStrUpper(tm.hasNetworkLatency), toggleStrUpper(tm.hasQueueLatency),
+		tm.algorithm, tm.latencyMin, tm.latencyAvg, tm.latencyMax, tm.sameZonePercent(), tm.sameRegionPercent(), tm.otherRegionPercent())
+}
+
+type suiteMetrics []*testMetrics
+
+func cmpBool(b1, b2 bool) int {
+	if b1 == b2 {
+		return 0
+	}
+	if !b1 {
+		return -1
+	}
+	return 1
+}
+
+func (sm suiteMetrics) toCSV() string {
+	sort.SliceStable(sm, func(i, j int) bool {
+		a := sm[i]
+		b := sm[j]
+
+		if cmp := cmpBool(a.hasQueueLatency, b.hasQueueLatency); cmp != 0 {
+			return cmp < 0
+		}
+
+		if cmp := cmpBool(a.hasNetworkLatency, b.hasNetworkLatency); cmp != 0 {
+			return cmp < 0
+		}
+
+		if cmp := strings.Compare(a.topology, b.topology); cmp != 0 {
+			return cmp < 0
+		}
+
+		// Sort algorithm in descending order so "round robin" is first
+		return strings.Compare(a.algorithm, b.algorithm) > 0
+	})
+	out := "TOPOLOGY,WEIGHTING,NW LATENCY,Q LATENCY,ALG,LATENCY (MIN),LATENCY (AVG),LATENCY (MAX),IN-ZONE,IN-REGION,OUT-REGION\n"
+	for _, tm := range sm {
+		out += tm.toCSV() + "\n"
+	}
+	return out
+}
+
+func runTest(t *testing.T, s testSettings, tm *testMetrics) {
+	t.Helper()
+
+	wg := sync.WaitGroup{}
+
+	clientLatencies := make([]histogram.Instance, len(s.mesh.Clients()))
+	for i, client := range s.mesh.Clients() {
+		i := i
+		client := client
+		wg.Add(1)
+		go func() {
+			// Assign weights to the endpoints.
+			var conns []*loadbalancer.WeightedConnection
+			for _, n := range s.mesh.Nodes() {
+				conns = append(conns, s.newWeightedConnection(client, n))
+			}
+
+			// Create a load balancer
+			lb := s.newLB(conns)
+
+			// Send the requests.
+			client.SendRequests(lb, s.clientDuration, func() {
+				clientLatencies[i] = lb.Latency()
+				wg.Done()
+			})
+		}()
+	}
+
+	wg.Wait()
+
+	c := s.mesh.Clients()[0]
+	clientLocality := c.Locality()
+	clientLatency := clientLatencies[0]
+
+	nodesSameZone := s.mesh.Nodes().Select(locality.MatchZone(clientLocality))
+	nodesSameRegion := s.mesh.Nodes().Select(locality.MatchOtherZoneInSameRegion(clientLocality))
+	nodesOtherRegion := s.mesh.Nodes().Select(locality.Not(locality.MatchRegion(clientLocality)))
+
+	// Store in the output.
+	tm.latencyAvg = clientLatency.Mean()
+	tm.latencyMin = clientLatency.Min()
+	tm.latencyMax = clientLatency.Max()
+	tm.nodesSameZone = len(nodesSameZone)
+	tm.nodesSameRegion = len(nodesSameRegion)
+	tm.nodesOtherRegion = len(nodesOtherRegion)
+	tm.requestsSameZone = nodesSameZone.TotalRequests()
+	tm.requestsSameRegion = nodesSameRegion.TotalRequests()
+	tm.requestsOtherRegion = nodesOtherRegion.TotalRequests()
+
+	t.Log("Test Results:\n" + tm.String())
+}
diff --git a/pkg/test/loadbalancersim/loadbalancer/edf.go b/pkg/test/loadbalancersim/loadbalancer/edf.go
new file mode 100644
index 0000000000..6a75173671
--- /dev/null
+++ b/pkg/test/loadbalancersim/loadbalancer/edf.go
@@ -0,0 +1,105 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancer
+
+import (
+	"container/heap"
+)
+
+// Entry is an item for load balance
+type Entry struct {
+	deadline float64
+	index    int64
+	value    interface{}
+	weight   float64
+}
+
+// priorityQueue is a queue that always pop the highest priority item
+type priorityQueue []*Entry
+
+// Len implements heap.Interface/sort.Interface
+func (pq priorityQueue) Len() int { return len(pq) }
+
+// Less implements heap.Interface/sort.Interface
+func (pq priorityQueue) Less(i, j int) bool {
+	// Flip logic to make this a min queue.
+	if pq[i].deadline == pq[j].deadline {
+		return pq[i].index < pq[j].index
+	}
+	return pq[i].deadline < pq[j].deadline
+}
+
+// Swap implements heap.Interface/sort.Interface
+func (pq priorityQueue) Swap(i, j int) {
+	pq[i], pq[j] = pq[j], pq[i]
+}
+
+// Push implements heap.Interface for pushing an item into the heap
+func (pq *priorityQueue) Push(x interface{}) {
+	entry := x.(*Entry)
+	*pq = append(*pq, entry)
+}
+
+// Pop implements heap.Interface for poping an item from the heap
+func (pq *priorityQueue) Pop() interface{} {
+	old := *pq
+	n := len(old)
+	entry := old[n-1]
+	*pq = old[0 : n-1]
+	return entry
+}
+
+// EDF implements the Earliest Deadline First scheduling algorithm
+type EDF struct {
+	pq              *priorityQueue
+	currentIndex    int64
+	currentDeadline float64
+}
+
+// Add a new entry for load balance
+func (e *EDF) Add(weight float64, value interface{}) {
+	e.currentIndex++
+	heap.Push(e.pq, &Entry{
+		value:    value,
+		weight:   weight,
+		deadline: e.currentDeadline + 1/weight,
+		index:    e.currentIndex,
+	})
+}
+
+// PickAndAdd picks an available entry and re-adds it with the given weight calculation
+func (e *EDF) PickAndAdd(calcWeight func(prevWeight float64, value interface{}) float64) interface{} {
+	// if no available entry, return nil
+	if len(*e.pq) == 0 {
+		return nil
+	}
+	entry := heap.Pop(e.pq).(*Entry)
+	// currentDeadline should be entry's deadline so that new added entry would have a fair
+	// competition environment with the old ones
+	e.currentDeadline = entry.deadline
+
+	// Re-add it with the updated weight.
+	e.Add(calcWeight(entry.weight, entry.value), entry.value)
+	return entry.value
+}
+
+// NewEDF create a new edf scheduler
+func NewEDF() *EDF {
+	pq := make(priorityQueue, 0)
+	return &EDF{
+		pq:           &pq,
+		currentIndex: 0,
+	}
+}
diff --git a/pkg/test/loadbalancersim/loadbalancer/leastrequest.go b/pkg/test/loadbalancersim/loadbalancer/leastrequest.go
new file mode 100644
index 0000000000..a131ea7e37
--- /dev/null
+++ b/pkg/test/loadbalancersim/loadbalancer/leastrequest.go
@@ -0,0 +1,129 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancer
+
+import (
+	"math"
+	"math/rand"
+	"sync"
+	"time"
+
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+)
+
+type LeastRequestSettings struct {
+	Connections       []*WeightedConnection
+	ActiveRequestBias float64
+}
+
+func NewLeastRequest(s LeastRequestSettings) network.Connection {
+	if len(s.Connections) == 0 {
+		panic("attempting to create load balancer with zero connections")
+	}
+
+	conn := newLBConnection("LeastRequestLB", s.Connections)
+
+	if conn.AllWeightsEqual() {
+		return newUnweightedLeastRequest(conn)
+	}
+
+	return newWeightedLeastRequest(conn, s.ActiveRequestBias)
+}
+
+type unweightedLeastRequest struct {
+	*weightedConnections
+	r *rand.Rand
+}
+
+func newUnweightedLeastRequest(conn *weightedConnections) network.Connection {
+	return &unweightedLeastRequest{
+		weightedConnections: conn,
+		r:                   rand.New(rand.NewSource(time.Now().UnixNano())),
+	}
+}
+
+func (lb *unweightedLeastRequest) pick2() (*WeightedConnection, *WeightedConnection) {
+	numConnections := len(lb.conns)
+	index1 := lb.r.Intn(numConnections)
+	index2 := lb.r.Intn(numConnections)
+	if index2 == index1 {
+		index2 = (index2 + 1) % numConnections
+	}
+
+	return lb.get(index1), lb.get(index2)
+}
+
+func (lb *unweightedLeastRequest) Request(onDone func()) {
+	if len(lb.conns) == 1 {
+		lb.doRequest(lb.get(0), onDone)
+		return
+	}
+
+	// Pick 2 endpoints at random.
+	c1, c2 := lb.pick2()
+
+	// Choose the endpoint with fewer active requests.
+	selected := c1
+	if c2.ActiveRequests() < c1.ActiveRequests() {
+		selected = c2
+	}
+
+	// Apply the selected endpoint to the metrics decorator and send the request.
+	lb.doRequest(selected, onDone)
+}
+
+type weightedLeastRequest struct {
+	*weightedConnections
+	activeRequestBias float64
+	edf               *EDF
+	edfMutex          sync.Mutex
+}
+
+func newWeightedLeastRequest(conn *weightedConnections, activeRequestBias float64) network.Connection {
+	lb := &weightedLeastRequest{
+		weightedConnections: conn,
+		activeRequestBias:   activeRequestBias,
+		edf:                 NewEDF(),
+	}
+
+	// Add all endpoints to the EDF scheduler.
+	for _, c := range conn.conns {
+		lb.edf.Add(lb.calcEDFWeight(0, c), c)
+	}
+
+	return lb
+}
+
+func (lb *weightedLeastRequest) Request(onDone func()) {
+	// Pick the next endpoint and re-add it with the updated weight.
+	lb.edfMutex.Lock()
+	selected := lb.edf.PickAndAdd(lb.calcEDFWeight).(*WeightedConnection)
+	lb.edfMutex.Unlock()
+
+	// Make the request.
+	lb.doRequest(selected, onDone)
+}
+
+func (lb *weightedLeastRequest) calcEDFWeight(_ float64, value interface{}) float64 {
+	conn := value.(*WeightedConnection)
+
+	weight := float64(conn.Weight)
+	if lb.activeRequestBias >= 1.0 {
+		weight /= float64(conn.ActiveRequests() + 1)
+	} else if lb.activeRequestBias > 0.0 {
+		weight /= math.Pow(float64(conn.ActiveRequests()+1), lb.activeRequestBias)
+	}
+	return weight
+}
diff --git a/pkg/test/loadbalancersim/loadbalancer/priority.go b/pkg/test/loadbalancersim/loadbalancer/priority.go
new file mode 100644
index 0000000000..c00aa412df
--- /dev/null
+++ b/pkg/test/loadbalancersim/loadbalancer/priority.go
@@ -0,0 +1,32 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancer
+
+import (
+	mesh2 "istio.io/istio/pkg/test/loadbalancersim/mesh"
+)
+
+type PrioritySelector func(src *mesh2.Client, dest *mesh2.Node) uint32
+
+func LocalityPrioritySelector(src *mesh2.Client, dest *mesh2.Node) uint32 {
+	priority := uint32(2)
+	if src.Locality().Region == dest.Locality().Region {
+		priority = 1
+		if src.Locality().Zone == dest.Locality().Zone {
+			priority = 0
+		}
+	}
+	return priority
+}
diff --git a/pkg/test/loadbalancersim/loadbalancer/roundrobin.go b/pkg/test/loadbalancersim/loadbalancer/roundrobin.go
new file mode 100644
index 0000000000..7ee3af629a
--- /dev/null
+++ b/pkg/test/loadbalancersim/loadbalancer/roundrobin.go
@@ -0,0 +1,52 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancer
+
+import (
+	"sync"
+
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+)
+
+func NewRoundRobin(conns []*WeightedConnection) network.Connection {
+	// Add instances for each connection based on the weight.
+	var lbConns []*WeightedConnection
+	for _, conn := range conns {
+		for i := uint32(0); i < conn.Weight; i++ {
+			lbConns = append(lbConns, conn)
+		}
+	}
+
+	return &roundRobin{
+		weightedConnections: newLBConnection("RoundRobinLB", lbConns),
+	}
+}
+
+type roundRobin struct {
+	*weightedConnections
+
+	next      int
+	nextMutex sync.Mutex
+}
+
+func (lb *roundRobin) Request(onDone func()) {
+	// Select the connection to use for this request.
+	lb.nextMutex.Lock()
+	selected := lb.get(lb.next)
+	lb.next = (lb.next + 1) % len(lb.conns)
+	lb.nextMutex.Unlock()
+
+	lb.doRequest(selected, onDone)
+}
diff --git a/pkg/test/loadbalancersim/loadbalancer/weight.go b/pkg/test/loadbalancersim/loadbalancer/weight.go
new file mode 100644
index 0000000000..da055af1a1
--- /dev/null
+++ b/pkg/test/loadbalancersim/loadbalancer/weight.go
@@ -0,0 +1,107 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package loadbalancer
+
+import (
+	"istio.io/istio/pkg/test/loadbalancersim/histogram"
+	mesh2 "istio.io/istio/pkg/test/loadbalancersim/mesh"
+	network2 "istio.io/istio/pkg/test/loadbalancersim/network"
+)
+
+type WeightedConnection struct {
+	network2.Connection
+	Weight uint32
+}
+
+type weightedConnections struct {
+	conns  []*WeightedConnection
+	helper *network2.ConnectionHelper
+}
+
+func newLBConnection(name string, conns []*WeightedConnection) *weightedConnections {
+	return &weightedConnections{
+		conns:  conns,
+		helper: network2.NewConnectionHelper(name),
+	}
+}
+
+func (lb *weightedConnections) AllWeightsEqual() bool {
+	if len(lb.conns) == 0 {
+		return true
+	}
+
+	weight := lb.conns[0].Weight
+	for _, conn := range lb.conns {
+		if conn.Weight != weight {
+			return false
+		}
+	}
+	return true
+}
+
+func (lb *weightedConnections) get(index int) *WeightedConnection {
+	return lb.conns[index]
+}
+
+func (lb *weightedConnections) doRequest(c *WeightedConnection, onDone func()) {
+	lb.helper.Request(c.Request, onDone)
+}
+
+func (lb *weightedConnections) Name() string {
+	return lb.helper.Name()
+}
+
+func (lb *weightedConnections) TotalRequests() uint64 {
+	return lb.helper.TotalRequests()
+}
+
+func (lb *weightedConnections) ActiveRequests() uint64 {
+	return lb.helper.ActiveRequests()
+}
+
+func (lb *weightedConnections) Latency() histogram.Instance {
+	return lb.helper.Latency()
+}
+
+type WeightedConnectionFactory func(src *mesh2.Client, n *mesh2.Node) *WeightedConnection
+
+func EquallyWeightedConnectionFactory() WeightedConnectionFactory {
+	return func(src *mesh2.Client, dest *mesh2.Node) *WeightedConnection {
+		return &WeightedConnection{
+			Connection: src.Mesh().NewConnection(src, dest),
+			Weight:     1,
+		}
+	}
+}
+
+func PriorityWeightedConnectionFactory(selectPriority PrioritySelector, priorityWeightMap map[uint32]uint32) WeightedConnectionFactory {
+	return func(src *mesh2.Client, dest *mesh2.Node) *WeightedConnection {
+		// Select the priority for this node.
+		priority := selectPriority(src, dest)
+
+		// Get the weight for the priority.
+		weight := uint32(1)
+		if priorityWeightMap != nil {
+			if w := priorityWeightMap[priority]; w > 0 {
+				weight = w
+			}
+		}
+
+		return &WeightedConnection{
+			Connection: src.Mesh().NewConnection(src, dest),
+			Weight:     weight,
+		}
+	}
+}
diff --git a/pkg/test/loadbalancersim/locality/locality.go b/pkg/test/loadbalancersim/locality/locality.go
new file mode 100644
index 0000000000..5eca0767b0
--- /dev/null
+++ b/pkg/test/loadbalancersim/locality/locality.go
@@ -0,0 +1,40 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package locality
+
+import (
+	"fmt"
+	"strings"
+)
+
+type Instance struct {
+	Zone   string
+	Region string
+}
+
+func (l Instance) String() string {
+	return fmt.Sprintf("%s/%s", l.Region, l.Zone)
+}
+
+func Parse(s string) Instance {
+	parts := strings.Split(s, "/")
+	if len(parts) != 2 {
+		panic("invalid locality string: " + s)
+	}
+	return Instance{
+		Region: parts[0],
+		Zone:   parts[1],
+	}
+}
diff --git a/pkg/test/loadbalancersim/locality/match.go b/pkg/test/loadbalancersim/locality/match.go
new file mode 100644
index 0000000000..d9ca199905
--- /dev/null
+++ b/pkg/test/loadbalancersim/locality/match.go
@@ -0,0 +1,46 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package locality
+
+type Match func(Instance) bool
+
+func MatchZone(l Instance) Match {
+	return func(o Instance) bool {
+		return l.Zone == o.Zone &&
+			l.Region == o.Region
+	}
+}
+
+func MatchRegion(l Instance) Match {
+	return func(o Instance) bool {
+		return l.Region == o.Region
+	}
+}
+
+func MatchOtherZoneInSameRegion(l Instance) Match {
+	return And(MatchRegion(l), Not(MatchZone(l)))
+}
+
+func And(m1 Match, m2 Match) Match {
+	return func(o Instance) bool {
+		return m1(o) && m2(o)
+	}
+}
+
+func Not(match Match) Match {
+	return func(o Instance) bool {
+		return !match(o)
+	}
+}
diff --git a/pkg/test/loadbalancersim/mesh/client.go b/pkg/test/loadbalancersim/mesh/client.go
new file mode 100644
index 0000000000..24185984b0
--- /dev/null
+++ b/pkg/test/loadbalancersim/mesh/client.go
@@ -0,0 +1,68 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package mesh
+
+import (
+	"sync"
+	"time"
+
+	"istio.io/istio/pkg/test/loadbalancersim/locality"
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+)
+
+type ClientSettings struct {
+	Burst    int
+	Interval time.Duration
+	Locality locality.Instance
+}
+
+type Client struct {
+	mesh *Instance
+	s    ClientSettings
+}
+
+func (c *Client) Mesh() *Instance {
+	return c.mesh
+}
+
+func (c *Client) Locality() locality.Instance {
+	return c.s.Locality
+}
+
+func (c *Client) SendRequests(conn network.Connection, duration time.Duration, done func()) {
+	go func() {
+		wg := sync.WaitGroup{}
+
+		timer := time.NewTimer(duration)
+		ticker := time.NewTicker(c.s.Interval)
+		for {
+			select {
+			case <-timer.C:
+				timer.Stop()
+				ticker.Stop()
+
+				// Wait for all pending requests to complete.
+				wg.Wait()
+				done()
+				return
+			case <-ticker.C:
+				wg.Add(c.s.Burst)
+				for i := 0; i < c.s.Burst; i++ {
+					conn.Request(wg.Done)
+				}
+			}
+		}
+	}()
+}
diff --git a/pkg/test/loadbalancersim/mesh/mesh.go b/pkg/test/loadbalancersim/mesh/mesh.go
new file mode 100644
index 0000000000..5fcc99535d
--- /dev/null
+++ b/pkg/test/loadbalancersim/mesh/mesh.go
@@ -0,0 +1,101 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package mesh
+
+import (
+	"fmt"
+	"time"
+
+	"istio.io/istio/pkg/test/loadbalancersim/locality"
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+	"istio.io/istio/pkg/test/loadbalancersim/timer"
+)
+
+type RouteKey struct {
+	Src  locality.Instance
+	Dest locality.Instance
+}
+
+type Settings struct {
+	NetworkLatencies map[RouteKey]time.Duration
+}
+
+type Instance struct {
+	nodes    Nodes
+	clients  []*Client
+	s        Settings
+	networkQ *timer.Queue
+}
+
+func New(s Settings) *Instance {
+	return &Instance{
+		s:        s,
+		networkQ: timer.NewQueue(),
+	}
+}
+
+func (m *Instance) Nodes() Nodes {
+	return m.nodes
+}
+
+func (m *Instance) Clients() []*Client {
+	return m.clients
+}
+
+func (m *Instance) NewConnection(src *Client, dest *Node) network.Connection {
+	// Lookup the route between the source and destination
+	networkLatency := m.s.NetworkLatencies[RouteKey{
+		Src:  src.Locality(),
+		Dest: dest.Locality(),
+	}]
+
+	request := dest.Request
+	if networkLatency > time.Duration(0) {
+		request = func(onDone func()) {
+			m.networkQ.Schedule(func() {
+				dest.Request(onDone)
+			}, time.Now().Add(networkLatency))
+		}
+	}
+
+	return network.NewConnection(dest.Name(), request)
+}
+
+func (m *Instance) ShutDown() {
+	m.networkQ.ShutDown()
+	m.nodes.ShutDown()
+}
+
+func (m *Instance) NewNodes(count int, serviceTime time.Duration, enableQueueLatency bool, locality locality.Instance) Nodes {
+	out := make(Nodes, 0, count)
+	for i := 0; i < count; i++ {
+		name := fmt.Sprintf("%s_%d", locality, i)
+		out = append(out, newNode(name, serviceTime, enableQueueLatency, locality))
+	}
+
+	m.nodes = append(m.nodes, out...)
+
+	return out
+}
+
+func (m *Instance) NewClient(s ClientSettings) *Client {
+	c := &Client{
+		mesh: m,
+		s:    s,
+	}
+
+	m.clients = append(m.clients, c)
+	return c
+}
diff --git a/pkg/test/loadbalancersim/mesh/node.go b/pkg/test/loadbalancersim/mesh/node.go
new file mode 100644
index 0000000000..bad03fb82e
--- /dev/null
+++ b/pkg/test/loadbalancersim/mesh/node.go
@@ -0,0 +1,116 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package mesh
+
+import (
+	"math"
+	"time"
+
+	"istio.io/istio/pkg/test/loadbalancersim/histogram"
+	"istio.io/istio/pkg/test/loadbalancersim/locality"
+	"istio.io/istio/pkg/test/loadbalancersim/network"
+	"istio.io/istio/pkg/test/loadbalancersim/timer"
+)
+
+var _ network.Connection = &Node{}
+
+type Node struct {
+	locality            locality.Instance
+	helper              *network.ConnectionHelper
+	q                   *timer.Queue
+	calcRequestDuration func() time.Duration
+}
+
+func newNode(name string, serviceTime time.Duration, enableQueueLatency bool, l locality.Instance) *Node {
+	q := timer.NewQueue()
+	var calcRequestDuration func() time.Duration
+	if enableQueueLatency {
+		calcRequestDuration = func() time.Duration {
+			return serviceTime + time.Duration(math.Pow(float64(q.Len())/2.0, 2.0))*time.Millisecond
+		}
+	} else {
+		calcRequestDuration = func() time.Duration {
+			return serviceTime
+		}
+	}
+
+	n := &Node{
+		locality:            l,
+		calcRequestDuration: calcRequestDuration,
+		helper:              network.NewConnectionHelper(name),
+		q:                   q,
+	}
+
+	return n
+}
+
+func (n *Node) Name() string {
+	return n.helper.Name()
+}
+
+func (n *Node) TotalRequests() uint64 {
+	return n.helper.TotalRequests()
+}
+
+func (n *Node) ActiveRequests() uint64 {
+	return n.helper.ActiveRequests()
+}
+
+func (n *Node) Latency() histogram.Instance {
+	return n.helper.Latency()
+}
+
+func (n *Node) Request(onDone func()) {
+	n.helper.Request(func(wrappedOnDone func()) {
+		deadline := time.Now().Add(n.calcRequestDuration())
+
+		// Schedule the done function to be called after the deadline.
+		n.q.Schedule(wrappedOnDone, deadline)
+	}, onDone)
+}
+
+func (n *Node) Locality() locality.Instance {
+	return n.locality
+}
+
+func (n *Node) ShutDown() {
+	n.q.ShutDown()
+}
+
+type Nodes []*Node
+
+func (nodes Nodes) Select(match locality.Match) Nodes {
+	var out Nodes
+	for _, n := range nodes {
+		if match(n.locality) {
+			out = append(out, n)
+		}
+	}
+	return out
+}
+
+func (nodes Nodes) TotalRequests() uint64 {
+	var out uint64
+	for _, n := range nodes {
+		out += n.TotalRequests()
+	}
+	return out
+}
+
+func (nodes Nodes) ShutDown() {
+	for _, n := range nodes {
+		n.ShutDown()
+	}
+}
diff --git a/pkg/test/loadbalancersim/network/connection.go b/pkg/test/loadbalancersim/network/connection.go
new file mode 100644
index 0000000000..03c549c9e2
--- /dev/null
+++ b/pkg/test/loadbalancersim/network/connection.go
@@ -0,0 +1,59 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package network
+
+import (
+	"istio.io/istio/pkg/test/loadbalancersim/histogram"
+)
+
+type Connection interface {
+	Name() string
+	Request(onDone func())
+	TotalRequests() uint64
+	ActiveRequests() uint64
+	Latency() histogram.Instance
+}
+
+func NewConnection(name string, request func(onDone func())) Connection {
+	return &connection{
+		request: request,
+		helper:  NewConnectionHelper(name),
+	}
+}
+
+type connection struct {
+	request func(onDone func())
+	helper  *ConnectionHelper
+}
+
+func (c *connection) Name() string {
+	return c.helper.Name()
+}
+
+func (c *connection) TotalRequests() uint64 {
+	return c.helper.TotalRequests()
+}
+
+func (c *connection) ActiveRequests() uint64 {
+	return c.helper.ActiveRequests()
+}
+
+func (c *connection) Latency() histogram.Instance {
+	return c.helper.Latency()
+}
+
+func (c *connection) Request(onDone func()) {
+	c.helper.Request(c.request, onDone)
+}
diff --git a/pkg/test/loadbalancersim/network/helper.go b/pkg/test/loadbalancersim/network/helper.go
new file mode 100644
index 0000000000..449c40a845
--- /dev/null
+++ b/pkg/test/loadbalancersim/network/helper.go
@@ -0,0 +1,84 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package network
+
+import (
+	"sync"
+	"time"
+
+	"go.uber.org/atomic"
+
+	"istio.io/istio/pkg/test/loadbalancersim/histogram"
+)
+
+type ConnectionHelper struct {
+	name      string
+	hist      histogram.Instance
+	histMutex sync.Mutex
+	active    *atomic.Uint64
+	total     *atomic.Uint64
+}
+
+func NewConnectionHelper(name string) *ConnectionHelper {
+	return &ConnectionHelper{
+		active: atomic.NewUint64(0),
+		total:  atomic.NewUint64(0),
+		name:   name,
+	}
+}
+
+func (c *ConnectionHelper) Name() string {
+	return c.name
+}
+
+func (c *ConnectionHelper) TotalRequests() uint64 {
+	return c.total.Load()
+}
+
+func (c *ConnectionHelper) ActiveRequests() uint64 {
+	return c.active.Load()
+}
+
+func (c *ConnectionHelper) Latency() histogram.Instance {
+	c.histMutex.Lock()
+	out := make(histogram.Instance, 0, len(c.hist))
+	out = append(out, c.hist...)
+	c.histMutex.Unlock()
+
+	return out
+}
+
+func (c *ConnectionHelper) Request(request func(onDone func()), onDone func()) {
+	start := time.Now()
+	c.total.Inc()
+	c.active.Inc()
+
+	wrappedDone := func() {
+		// Calculate the latency for this request.
+		latency := time.Since(start)
+
+		// Update the histogram.
+		c.histMutex.Lock()
+		c.hist = append(c.hist, latency.Seconds())
+		c.histMutex.Unlock()
+
+		c.active.Dec()
+
+		// Invoke the caller's handler.
+		onDone()
+	}
+
+	request(wrappedDone)
+}
diff --git a/pkg/test/loadbalancersim/timer/queue.go b/pkg/test/loadbalancersim/timer/queue.go
new file mode 100644
index 0000000000..99412bdbdf
--- /dev/null
+++ b/pkg/test/loadbalancersim/timer/queue.go
@@ -0,0 +1,188 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package timer
+
+import (
+	"container/heap"
+	"sync"
+	"time"
+)
+
+type Queue struct {
+	heap            timerHeap
+	mutex           sync.Mutex
+	stopCh          chan struct{}
+	resetTimerCh    chan struct{}
+	stopping        bool
+	timer           *time.Timer
+	currentDeadline time.Time
+}
+
+func NewQueue() *Queue {
+	q := &Queue{
+		heap:         make(timerHeap, 0),
+		timer:        time.NewTimer(1 * time.Minute),
+		stopCh:       make(chan struct{}),
+		resetTimerCh: make(chan struct{}),
+	}
+
+	// Start the worker thread.
+	go func() {
+		for {
+			select {
+			case <-q.stopCh:
+				q.stopTimer()
+				return
+			case <-q.resetTimerCh:
+				q.resetTimer()
+			case <-q.timer.C:
+				q.onTimerExpired()
+			}
+		}
+	}()
+
+	return q
+}
+
+func (q *Queue) Len() int {
+	q.mutex.Lock()
+	defer q.mutex.Unlock()
+	return q.heap.Len()
+}
+
+func (q *Queue) Schedule(handler func(), deadline time.Time) {
+	// Add the timer to the heap.
+	q.mutex.Lock()
+	heap.Push(&q.heap, &entry{
+		handler:  handler,
+		deadline: deadline,
+		index:    0,
+	})
+	q.mutex.Unlock()
+
+	// Request that the timer be reset.
+	q.resetTimerCh <- struct{}{}
+}
+
+func (q *Queue) ShutDown() {
+	close(q.stopCh)
+}
+
+func (q *Queue) stopTimer() {
+	q.mutex.Lock()
+	q.stopping = true
+	q.mutex.Unlock()
+
+	q.timer.Stop()
+}
+
+func (q *Queue) resetTimer() {
+	// Below is a separate function to limit the scope of the lock.
+	// We don't want to lock when we modify the timer in case it causes
+	// an immediate callback, which would reaquire the lock.
+	needReset, resetDuration := func() (bool, time.Duration) {
+		q.mutex.Lock()
+		defer q.mutex.Unlock()
+
+		if q.stopping {
+			// Ignore the event, since we're already shutting down.
+			return false, 0
+		}
+
+		e := q.heap.peek()
+		if e == nil || e.deadline.Equal(q.currentDeadline) {
+			// nothing to do.
+			return false, 0
+		}
+
+		q.currentDeadline = e.deadline
+		return true, time.Until(e.deadline)
+	}()
+
+	// Reset the timer.
+	if needReset {
+		q.timer.Reset(resetDuration)
+	}
+}
+
+func (q *Queue) onTimerExpired() {
+	// Collect all expired timers.
+	q.mutex.Lock()
+	handlers := q.heap.advanceTo(time.Now())
+	q.mutex.Unlock()
+
+	// Call the expired timer handlers.
+	for _, h := range handlers {
+		h()
+	}
+
+	// Reset the timer based on the earliest deadline.
+	q.resetTimer()
+}
+
+type entry struct {
+	deadline time.Time
+	handler  func()
+	index    int
+}
+
+type timerHeap []*entry
+
+func (h timerHeap) peek() *entry {
+	if h.Len() > 0 {
+		return h[0]
+	}
+	return nil
+}
+
+func (h *timerHeap) advanceTo(tnow time.Time) (out []func()) {
+	for {
+		if top := h.peek(); top != nil && !top.deadline.After(tnow) {
+			heap.Remove(h, top.index)
+			out = append(out, top.handler)
+		} else {
+			// There are no further expired timers.
+			return
+		}
+	}
+}
+
+func (h timerHeap) Len() int {
+	return len(h)
+}
+
+func (h timerHeap) Less(i, j int) bool {
+	return h[i].deadline.Before(h[j].deadline)
+}
+
+func (h timerHeap) Swap(i, j int) {
+	h[i], h[j] = h[j], h[i]
+	h[i].index = i
+	h[j].index = j
+}
+
+func (h *timerHeap) Push(x interface{}) {
+	e := x.(*entry)
+	*h = append(*h, e)
+	e.index = len(*h) - 1
+}
+
+func (h *timerHeap) Pop() interface{} {
+	n := h.Len()
+	e := (*h)[n-1]
+	*h = (*h)[:n-1]
+	e.index = -1
+	return e
+}
-- 
2.35.3

