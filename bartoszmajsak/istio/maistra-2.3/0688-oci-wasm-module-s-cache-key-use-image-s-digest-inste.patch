From 82cbd49db92acce69184ab4e9b95e033ea8ab390 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=BE=84=E6=BD=AD?= <ztywto@qq.com>
Date: Wed, 2 Mar 2022 12:32:52 +0800
Subject: oci wasm module's cache key use image's digest instead of binary's
 checksum (#37566)

---
 pkg/wasm/cache.go             |  4 +-
 pkg/wasm/cache_test.go        |  6 +--
 pkg/wasm/imagefetcher.go      | 29 ++++++++------
 pkg/wasm/imagefetcher_test.go | 72 ++++++++++++++++++++++-------------
 4 files changed, 68 insertions(+), 43 deletions(-)

diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index c0e322316c..95abc5aeb7 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -157,7 +157,7 @@ func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration
 		}
 		wasmLog.Debugf("wasm oci fetch %s with options: %v", downloadURL, imgFetcherOps)
 		fetcher := NewImageFetcher(ctx, imgFetcherOps)
-		b, err = fetcher.Fetch(u.Host+u.Path, checksum)
+		b, dChecksum, err = fetcher.Fetch(u.Host+u.Path, checksum)
 		if err != nil {
 			if errors.Is(err, errWasmOCIImageDigestMismatch) {
 				wasmRemoteFetchCount.With(resultTag.Value(checksumMismatch)).Increment()
@@ -166,8 +166,6 @@ func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration
 			}
 			return "", fmt.Errorf("could not fetch Wasm OCI image: %v", err)
 		}
-		sha := sha256.Sum256(b)
-		dChecksum = hex.EncodeToString(sha[:])
 	default:
 		return "", fmt.Errorf("unsupported Wasm module downloading URL scheme: %v", u.Scheme)
 	}
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index 2631439e4c..4818ea7486 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -65,7 +65,7 @@ func TestWasmCache(t *testing.T) {
 	if err != nil {
 		t.Fatal(err)
 	}
-	wantOCIDockerBinaryChecksum, dockerImageDigest, invalidOCIImageDigest := setupOCIRegistry(t, ou.Host)
+	_, dockerImageDigest, invalidOCIImageDigest := setupOCIRegistry(t, ou.Host)
 
 	// Calculate cachehit sum.
 	cacheHitSha := sha256.Sum256([]byte("cachehit"))
@@ -182,7 +182,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:        DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:     DefaultWasmModuleExpiry,
 			requestTimeout:       time.Second * 10,
-			wantFileName:         fmt.Sprintf("%s.wasm", wantOCIDockerBinaryChecksum),
+			wantFileName:         fmt.Sprintf("%s.wasm", dockerImageDigest),
 		},
 		{
 			name:                 "fetch oci with digest",
@@ -192,7 +192,7 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:     DefaultWasmModuleExpiry,
 			requestTimeout:       time.Second * 10,
 			checksum:             dockerImageDigest,
-			wantFileName:         fmt.Sprintf("%s.wasm", wantOCIDockerBinaryChecksum),
+			wantFileName:         fmt.Sprintf("%s.wasm", dockerImageDigest),
 		},
 		{
 			name:                 "fetch oci timed out",
diff --git a/pkg/wasm/imagefetcher.go b/pkg/wasm/imagefetcher.go
index 3c24f68388..2f59bca2bf 100644
--- a/pkg/wasm/imagefetcher.go
+++ b/pkg/wasm/imagefetcher.go
@@ -80,59 +80,66 @@ func NewImageFetcher(ctx context.Context, opt ImageFetcherOption) *ImageFetcher
 }
 
 // Fetch is the entrypoint for fetching Wasm binary from Wasm Image Specification compatible images.
-func (o *ImageFetcher) Fetch(url, expManifestDigest string) ([]byte, error) {
+func (o *ImageFetcher) Fetch(url, expManifestDigest string) (ret []byte, actualDigest string, err error) {
 	ref, err := o.parseReference(url)
 	if err != nil {
-		return nil, fmt.Errorf("could not parse url in image reference: %v", err)
+		err = fmt.Errorf("could not parse url in image reference: %v", err)
+		return
 	}
 
 	// Fetch image.
 	img, err := remote.Image(ref, o.fetchOpts...)
 	if err != nil {
-		return nil, fmt.Errorf("could not fetch image: %v", err)
+		err = fmt.Errorf("could not fetch image: %v", err)
+		return
 	}
 
 	// Check Manifest's digest if expManifestDigest is not empty.
 	d, _ := img.Digest()
 	if expManifestDigest != "" && d.Hex != expManifestDigest {
-		return nil, fmt.Errorf("%w: got %s, but want %s", errWasmOCIImageDigestMismatch, d.Hex, expManifestDigest)
+		err = fmt.Errorf("%w: got %s, but want %s", errWasmOCIImageDigestMismatch, d.Hex, expManifestDigest)
+		return
 	}
+	actualDigest = d.Hex
 
 	manifest, err := img.Manifest()
 	if err != nil {
-		return nil, fmt.Errorf("could not retrieve manifest: %v", err)
+		err = fmt.Errorf("could not retrieve manifest: %v", err)
+		return
 	}
 
 	if manifest.MediaType == types.DockerManifestSchema2 {
 		// This case, assume we have docker images with "application/vnd.docker.distribution.manifest.v2+json"
 		// as the manifest media type. Note that the media type of manifest is Docker specific and
 		// all OCI images would have an empty string in .MediaType field.
-		ret, err := extractDockerImage(img)
+		ret, err = extractDockerImage(img)
 		if err != nil {
-			return nil, fmt.Errorf("could not extract Wasm file from the image as Docker container %v", err)
+			err = fmt.Errorf("could not extract Wasm file from the image as Docker container %v", err)
+			return
 		}
-		return ret, nil
+		return
 	}
 
 	// We try to parse it as the "compat" variant image with a single "application/vnd.oci.image.layer.v1.tar+gzip" layer.
 	ret, errCompat := extractOCIStandardImage(img)
 	if errCompat == nil {
-		return ret, nil
+		return
 	}
 
 	// Otherwise, we try to parse it as the *oci* variant image with custom artifact media types.
 	ret, errOCI := extractOCIArtifactImage(img)
 	if errOCI == nil {
-		return ret, nil
+		return
 	}
 
 	// We failed to parse the image in any format, so wrap the errors and return.
-	return nil, fmt.Errorf("the given image is in invalid format as an OCI image: %v",
+	err = fmt.Errorf("the given image is in invalid format as an OCI image: %v",
 		multierror.Append(err,
 			fmt.Errorf("could not parse as compat variant: %v", errCompat),
 			fmt.Errorf("could not parse as oci variant: %v", errOCI),
 		),
 	)
+	return
 }
 
 func (o *ImageFetcher) parseReference(url string) (name.Reference, error) {
diff --git a/pkg/wasm/imagefetcher_test.go b/pkg/wasm/imagefetcher_test.go
index 8a74564f2c..c1f9875ce8 100644
--- a/pkg/wasm/imagefetcher_test.go
+++ b/pkg/wasm/imagefetcher_test.go
@@ -100,30 +100,37 @@ func TestImageFetcher_Fetch(t *testing.T) {
 			t.Fatal(err)
 		}
 
+		// Fetch docker image with digest
+		d, err := img.Digest()
+		if err != nil {
+			t.Fatal(err)
+		}
+
 		// Fetch docker image without digest
-		actual, err := fetcher.Fetch(ref, "")
+		actual, actualDiget, err := fetcher.Fetch(ref, "")
 		if err != nil {
 			t.Fatal(err)
 		}
 		if string(actual) != exp {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), exp)
 		}
-
-		// Fetch docker image with digest
-		d, err := img.Digest()
-		if err != nil {
-			t.Fatal(err)
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
 		}
-		actual, err = fetcher.Fetch(ref, d.Hex)
+
+		actual, actualDiget, err = fetcher.Fetch(ref, d.Hex)
 		if err != nil {
 			t.Fatal(err)
 		}
 		if string(actual) != exp {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), exp)
 		}
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
+		}
 
 		// Giving wrong digest should be error
-		_, err = fetcher.Fetch(ref, "foobar")
+		_, _, err = fetcher.Fetch(ref, "foobar")
 		if err == nil {
 			t.Error("fetcher.Fetch should raise error for wrong digest")
 		}
@@ -151,30 +158,37 @@ func TestImageFetcher_Fetch(t *testing.T) {
 			t.Fatal(err)
 		}
 
+		// Fetch OCI image with digest
+		d, err := img.Digest()
+		if err != nil {
+			t.Fatal(err)
+		}
+
 		// Fetch OCI image.
-		actual, err := fetcher.Fetch(ref, "")
+		actual, actualDiget, err := fetcher.Fetch(ref, "")
 		if err != nil {
 			t.Fatal(err)
 		}
 		if string(actual) != exp {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), exp)
 		}
-
-		// Fetch OCI image with digest
-		d, err := img.Digest()
-		if err != nil {
-			t.Fatal(err)
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
 		}
-		actual, err = fetcher.Fetch(ref, d.Hex)
+
+		actual, actualDiget, err = fetcher.Fetch(ref, d.Hex)
 		if err != nil {
 			t.Fatal(err)
 		}
 		if string(actual) != exp {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), exp)
 		}
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
+		}
 
 		// Giving wrong digest should be error
-		_, err = fetcher.Fetch(ref, "foobar")
+		_, _, err = fetcher.Fetch(ref, "foobar")
 		if err == nil {
 			t.Error("fetcher.Fetch should raise error for wrong digest")
 		}
@@ -216,31 +230,37 @@ func TestImageFetcher_Fetch(t *testing.T) {
 			t.Fatal(err)
 		}
 
-		// Fetch OCI image.
-		actual, err := fetcher.Fetch(ref, "")
+		// Fetch OCI image with digest
+		d, err := img.Digest()
 		if err != nil {
 			t.Fatal(err)
 		}
 
+		// Fetch OCI image.
+		actual, actualDiget, err := fetcher.Fetch(ref, "")
+		if err != nil {
+			t.Fatal(err)
+		}
 		if !bytes.Equal(actual, want) {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), string(want))
 		}
-
-		// Fetch OCI image with digest
-		d, err := img.Digest()
-		if err != nil {
-			t.Fatal(err)
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
 		}
-		actual, err = fetcher.Fetch(ref, d.Hex)
+
+		actual, actualDiget, err = fetcher.Fetch(ref, d.Hex)
 		if err != nil {
 			t.Fatal(err)
 		}
 		if !bytes.Equal(actual, want) {
 			t.Errorf("ImageFetcher.Fetch got %s, but want '%s'", string(actual), want)
 		}
+		if actualDiget != d.Hex {
+			t.Errorf("ImageFetcher.Getch got digest %s, but want '%s'", actualDiget, d.Hex)
+		}
 
 		// Giving wrong digest should be error
-		_, err = fetcher.Fetch(ref, "foobar")
+		_, _, err = fetcher.Fetch(ref, "foobar")
 		if err == nil {
 			t.Error("fetcher.Fetch should raise error for wrong digest")
 		}
@@ -266,7 +286,7 @@ func TestImageFetcher_Fetch(t *testing.T) {
 		}
 
 		// Try to fetch.
-		actual, err := fetcher.Fetch(ref, "")
+		actual, _, err := fetcher.Fetch(ref, "")
 		if actual != nil {
 			t.Errorf("ImageFetcher.Fetch got %s, but want nil", string(actual))
 		}
-- 
2.35.3

