From 56edd90bb930ff715474769e8c9587f8c74700eb Mon Sep 17 00:00:00 2001
From: jacob-delgado <jacob.delgado@volunteers.acasi.info>
Date: Fri, 28 Jan 2022 12:22:55 -0700
Subject: Set connection_balance_config to exact_balance... (#36834)

* Set connection_balance_config to exact_balance

for inbound and outbound connections. This does not apply to
virtualOutbound and for listeners that use QUIC.

Fixes https://github.com/istio/istio/issues/18152

Based on lessons from  https://aspenmesh.io/sailing-faster-with-istio/
we should set connectionBalanceConfig to exactBalance.

* Add release note

* Run make gen

* Review comment

* Add a feature flag for inbound and outbound listeners

* Use proxy metadata instead of environment variables in pilot

* Run make gen

* Rename variables

* Remove unnecessasry json

* Fix name

* Remove unneeded file

* Update comments
---
 pilot/pkg/model/context.go                    |   8 ++
 .../networking/core/v1alpha3/gateway_test.go  |   7 +
 .../pkg/networking/core/v1alpha3/listener.go  |  25 +++-
 .../core/v1alpha3/listener_builder.go         |  34 +++--
 .../core/v1alpha3/listener_builder_test.go    | 125 ++++++++++++------
 .../networking/core/v1alpha3/listener_test.go |  74 +++++++++++
 releasenotes/notes/18152.yaml                 |   9 ++
 7 files changed, 225 insertions(+), 57 deletions(-)
 create mode 100644 releasenotes/notes/18152.yaml

diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 6f920eefa1..ea122d55dd 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -608,6 +608,14 @@ type NodeMetadata struct {
 	// ExitOnZeroActiveConnections terminates Envoy if there are no active connections if set.
 	ExitOnZeroActiveConnections StringBool `json:"EXIT_ON_ZERO_ACTIVE_CONNECTIONS,omitempty"`
 
+	// InboundListenerExactBalance sets connection balance config to use exact_balance for virtualInbound,
+	// as long as QUIC, since it uses UDP, isn't also used.
+	InboundListenerExactBalance StringBool `json:"INBOUND_LISTENER_EXACT_BALANCE,omitempty"`
+
+	// OutboundListenerExactBalance sets connection balance config to use exact_balance for outbound
+	// redirected tcp listeners. This does not change the virtualOutbound listener.
+	OutboundListenerExactBalance StringBool `json:"OUTBOUND_LISTENER_EXACT_BALANCE,omitempty"`
+
 	// Contains a copy of the raw metadata. This is needed to lookup arbitrary values.
 	// If a value is known ahead of time it should be added to the struct rather than reading from here,
 	Raw map[string]interface{} `json:"-"`
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway_test.go b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
index 98d1680c82..a4f6c2dda5 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
@@ -2128,6 +2128,13 @@ func TestBuildGatewayListeners(t *testing.T) {
 				t.Fatalf("Expected listeners: %v, got: %v\n%v", tt.expectedListeners, listeners, proxyGateway.MergedGateway.MergedServers)
 			}
 			xdstest.ValidateListeners(t, builder.gatewayListeners)
+
+			// gateways bind to port, but exact_balance can still be used
+			for _, l := range builder.gatewayListeners {
+				if l.ConnectionBalanceConfig != nil {
+					t.Fatalf("expected connection balance config to be empty, found %v", l.ConnectionBalanceConfig)
+				}
+			}
 		})
 	}
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index 3a02e6f973..b008edea86 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -1558,17 +1558,30 @@ func buildListener(opts buildListenerOpts, trafficDirection core.TrafficDirectio
 	switch opts.transport {
 	case istionetworking.TransportProtocolTCP:
 		var bindToPort *wrappers.BoolValue
+		var connectionBalance *listener.Listener_ConnectionBalanceConfig
 		if !opts.bindToPort {
 			bindToPort = proto.BoolFalse
 		}
+
+		// only use to exact_balance for tcp outbound listeners; virtualOutbound listener should
+		// not have this set per Envoy docs for redirected listeners
+		if opts.proxy.Metadata.OutboundListenerExactBalance && trafficDirection == core.TrafficDirection_OUTBOUND {
+			connectionBalance = &listener.Listener_ConnectionBalanceConfig{
+				BalanceType: &listener.Listener_ConnectionBalanceConfig_ExactBalance_{
+					ExactBalance: &listener.Listener_ConnectionBalanceConfig_ExactBalance{},
+				},
+			}
+		}
+
 		res = &listener.Listener{
 			// TODO: need to sanitize the opts.bind if its a UDS socket, as it could have colons, that envoy doesn't like
-			Name:             getListenerName(opts.bind, opts.port.Port, istionetworking.TransportProtocolTCP),
-			Address:          util.BuildAddress(opts.bind, uint32(opts.port.Port)),
-			TrafficDirection: trafficDirection,
-			ListenerFilters:  listenerFilters,
-			FilterChains:     filterChains,
-			BindToPort:       bindToPort,
+			Name:                    getListenerName(opts.bind, opts.port.Port, istionetworking.TransportProtocolTCP),
+			Address:                 util.BuildAddress(opts.bind, uint32(opts.port.Port)),
+			TrafficDirection:        trafficDirection,
+			ListenerFilters:         listenerFilters,
+			FilterChains:            filterChains,
+			BindToPort:              bindToPort,
+			ConnectionBalanceConfig: connectionBalance,
 		}
 
 		if opts.proxy.Type != model.Router {
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 1a511c2190..c21052b71f 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -383,14 +383,25 @@ func (lb *ListenerBuilder) buildVirtualInboundListener(configgen *ConfigGenerato
 
 	actualWildcard, _ := getActualWildcardAndLocalHost(lb.node)
 	// add an extra listener that binds to the port that is the recipient of the iptables redirect
-	filterChains, passthroughInspector := buildInboundCatchAllFilterChains(configgen, lb.node, lb.push)
+	filterChains, passthroughInspector, usesQUIC := buildInboundCatchAllFilterChains(configgen, lb.node, lb.push)
+
+	// exact balance used in Envoy is only supported over TCP connections
+	var connectionBalance *listener.Listener_ConnectionBalanceConfig
+	if !usesQUIC && bool(lb.node.Metadata.InboundListenerExactBalance) {
+		connectionBalance = &listener.Listener_ConnectionBalanceConfig{
+			BalanceType: &listener.Listener_ConnectionBalanceConfig_ExactBalance_{
+				ExactBalance: &listener.Listener_ConnectionBalanceConfig_ExactBalance{},
+			},
+		}
+	}
 	lb.virtualInboundListener = &listener.Listener{
-		Name:             model.VirtualInboundListenerName,
-		Address:          util.BuildAddress(actualWildcard, ProxyInboundListenPort),
-		Transparent:      isTransparentProxy,
-		UseOriginalDst:   proto.BoolTrue,
-		TrafficDirection: core.TrafficDirection_INBOUND,
-		FilterChains:     filterChains,
+		Name:                    model.VirtualInboundListenerName,
+		Address:                 util.BuildAddress(actualWildcard, ProxyInboundListenPort),
+		Transparent:             isTransparentProxy,
+		UseOriginalDst:          proto.BoolTrue,
+		TrafficDirection:        core.TrafficDirection_INBOUND,
+		FilterChains:            filterChains,
+		ConnectionBalanceConfig: connectionBalance,
 	}
 	accessLogBuilder.setListenerAccessLog(lb.push, lb.node, lb.virtualInboundListener)
 	lb.aggregateVirtualInboundListener(passthroughInspector)
@@ -490,7 +501,9 @@ func getMtlsSettings(configgen *ConfigGeneratorImpl, in *plugin.InputParams, pas
 }
 
 func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
-	node *model.Proxy, push *model.PushContext) ([]*listener.FilterChain, map[int]enabledInspector) {
+	node *model.Proxy, push *model.PushContext) ([]*listener.FilterChain, map[int]enabledInspector, bool) {
+	usesQUIC := false
+
 	// ipv4 and ipv6 feature detect
 	ipVersions := make([]string, 0, 2)
 	if node.SupportsIPv4() {
@@ -555,6 +568,9 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 			}
 			if opt.httpOpts != nil {
 				opt.httpOpts.statPrefix = clusterName
+				if opt.httpOpts.http3Only {
+					usesQUIC = true
+				}
 				connectionManager := buildHTTPConnectionManager(listenerOpts, opt.httpOpts, opt.filterChain.HTTP)
 				filter := &listener.Filter{
 					Name:       wellknown.HTTPConnectionManager,
@@ -579,7 +595,7 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 		}
 	}
 
-	return filterChains, inspectors
+	return filterChains, inspectors, usesQUIC
 }
 
 func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputParams, listenerOpts buildListenerOpts,
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
index e8e863c9f2..94bb715c18 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
@@ -118,9 +118,15 @@ func setInboundCaptureAllOnThisNode(proxy *model.Proxy, mode model.TrafficInterc
 	proxy.Metadata.InterceptionMode = mode
 }
 
-var testServices = []*model.Service{buildService("test.com", wildcardIP, protocol.HTTP, tnow)}
+var (
+	testServices         = []*model.Service{buildService("test.com", wildcardIP, protocol.HTTP, tnow)}
+	testServicesWithQUIC = []*model.Service{
+		buildService("test.com", wildcardIP, protocol.HTTP, tnow),
+		buildService("quick.com", wildcardIP, protocol.UDP, tnow),
+	}
+)
 
-func prepareListeners(t *testing.T, services []*model.Service, mode model.TrafficInterceptionMode) []*listener.Listener {
+func prepareListeners(t *testing.T, services []*model.Service, mode model.TrafficInterceptionMode, exactBalance bool) []*listener.Listener {
 	// prepare
 	ldsEnv := getDefaultLdsEnv()
 
@@ -141,6 +147,8 @@ func prepareListeners(t *testing.T, services []*model.Service, mode model.Traffi
 
 	proxy := getDefaultProxy()
 	proxy.ServiceInstances = instances
+	proxy.Metadata.InboundListenerExactBalance = model.StringBool(exactBalance)
+	proxy.Metadata.OutboundListenerExactBalance = model.StringBool(exactBalance)
 	setInboundCaptureAllOnThisNode(proxy, mode)
 	setNilSidecarOnProxy(proxy, env.PushContext)
 
@@ -153,58 +161,74 @@ func prepareListeners(t *testing.T, services []*model.Service, mode model.Traffi
 }
 
 func TestVirtualInboundListenerBuilder(t *testing.T) {
-	defaultValue := features.EnableProtocolSniffingForInbound
-	features.EnableProtocolSniffingForInbound = true
-	defer func() { features.EnableProtocolSniffingForInbound = defaultValue }()
-
-	// prepare
-	t.Helper()
-	listeners := prepareListeners(t, testServices, model.InterceptionRedirect)
-	// virtual inbound and outbound listener
-	if len(listeners) != 2 {
-		t.Fatalf("expected %d listeners, found %d", 2, len(listeners))
+	tests := []struct {
+		useExactBalance bool
+	}{
+		{
+			useExactBalance: false,
+		},
+		{
+			useExactBalance: true,
+		},
 	}
 
-	if !strings.HasPrefix(listeners[0].Name, model.VirtualOutboundListenerName) {
-		t.Fatalf("expect virtual listener, found %s", listeners[0].Name)
-	} else {
-		t.Logf("found virtual listener: %s", listeners[0].Name)
-	}
+	for _, tt := range tests {
+		// prepare
+		t.Helper()
+		listeners := prepareListeners(t, testServices, model.InterceptionRedirect, tt.useExactBalance)
+		// virtual inbound and outbound listener
+		if len(listeners) != 2 {
+			t.Fatalf("expected %d listeners, found %d", 2, len(listeners))
+		}
 
-	if !strings.HasPrefix(listeners[1].Name, model.VirtualInboundListenerName) {
-		t.Fatalf("expect virtual listener, found %s", listeners[1].Name)
-	} else {
-		t.Logf("found virtual inbound listener: %s", listeners[1].Name)
-	}
+		if !strings.HasPrefix(listeners[0].Name, model.VirtualOutboundListenerName) {
+			t.Fatalf("expect virtual listener, found %s", listeners[0].Name)
+		} else {
+			t.Logf("found virtual listener: %s", listeners[0].Name)
+		}
 
-	l := listeners[1]
+		if !strings.HasPrefix(listeners[1].Name, model.VirtualInboundListenerName) {
+			t.Fatalf("expect virtual listener, found %s", listeners[1].Name)
+		} else {
+			t.Logf("found virtual inbound listener: %s", listeners[1].Name)
+		}
 
-	byListenerName := map[string]int{}
+		l := listeners[1]
 
-	for _, fc := range l.FilterChains {
-		byListenerName[fc.Name]++
-	}
+		byListenerName := map[string]int{}
 
-	for k, v := range byListenerName {
-		if k == model.VirtualInboundListenerName && v != 3 {
-			t.Fatalf("expect virtual listener has 3 passthrough filter chains, found %d", v)
+		for _, fc := range l.FilterChains {
+			byListenerName[fc.Name]++
 		}
-		if k == model.VirtualInboundCatchAllHTTPFilterChainName && v != 2 {
-			t.Fatalf("expect virtual listener has 2 passthrough filter chains, found %d", v)
+
+		for k, v := range byListenerName {
+			if k == model.VirtualInboundListenerName && v != 3 {
+				t.Fatalf("expect virtual listener has 3 passthrough filter chains, found %d", v)
+			}
+			if k == model.VirtualInboundCatchAllHTTPFilterChainName && v != 2 {
+				t.Fatalf("expect virtual listener has 2 passthrough filter chains, found %d", v)
+			}
+			if k == listeners[0].Name && v != len(listeners[0].FilterChains) {
+				t.Fatalf("expect virtual listener has %d filter chains from listener %s, found %d", len(listeners[0].FilterChains), l.Name, v)
+			}
 		}
-		if k == listeners[0].Name && v != len(listeners[0].FilterChains) {
-			t.Fatalf("expect virtual listener has %d filter chains from listener %s, found %d", len(listeners[0].FilterChains), l.Name, v)
+
+		if tt.useExactBalance {
+			if l.ConnectionBalanceConfig == nil || l.ConnectionBalanceConfig.GetExactBalance() == nil {
+				t.Fatal("expected virtual listener to have connection balance config set to exact_balance")
+			}
+		} else {
+			if l.ConnectionBalanceConfig != nil {
+				t.Fatal("expected virtual listener to not have connection balance config set")
+			}
 		}
 	}
 }
 
 func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
-	defaultValue := features.EnableProtocolSniffingForInbound
-	features.EnableProtocolSniffingForInbound = true
-	defer func() { features.EnableProtocolSniffingForInbound = defaultValue }()
 	// prepare
 	t.Helper()
-	listeners := prepareListeners(t, testServices, model.InterceptionRedirect)
+	listeners := prepareListeners(t, testServices, model.InterceptionRedirect, true)
 	// virtual inbound and outbound listener
 	if len(listeners) != 2 {
 		t.Fatalf("expect %d listeners, found %d", 2, len(listeners))
@@ -214,7 +238,7 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 	sawFakePluginFilter := false
 	sawIpv4PassthroughCluster := 0
 	sawIpv6PassthroughCluster := false
-	sawIpv4PsssthroughFilterChainMatchTLSFromFakePlugin := false
+	sawIpv4PassthroughFilterChainMatchTLSFromFakePlugin := false
 	for _, fc := range l.FilterChains {
 		if fc.TransportSocket != nil && fc.FilterChainMatch.TransportProtocol != "tls" {
 			t.Fatalf("expect passthrough filter chain sets transport protocol to tls if transport socket is set")
@@ -229,7 +253,7 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 			}
 
 			if fc.TransportSocket != nil {
-				sawIpv4PsssthroughFilterChainMatchTLSFromFakePlugin = true
+				sawIpv4PassthroughFilterChainMatchTLSFromFakePlugin = true
 			}
 			if fc.FilterChainMatch.PrefixRanges[0].AddressPrefix == util.ConvertAddressToCidr("0.0.0.0/0").AddressPrefix &&
 				fc.FilterChainMatch.PrefixRanges[0].PrefixLen.Value == 0 {
@@ -269,7 +293,7 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 		t.Fatalf("fail to find the fake plugin TCP filter in listener %v", l)
 	}
 
-	if !sawIpv4PsssthroughFilterChainMatchTLSFromFakePlugin {
+	if !sawIpv4PassthroughFilterChainMatchTLSFromFakePlugin {
 		t.Fatalf("fail to find the fake plugin filter chain match with TLS in listener %v", l)
 	}
 
@@ -289,7 +313,7 @@ func TestVirtualInboundHasPassthroughClusters(t *testing.T) {
 func TestSidecarInboundListenerWithOriginalSrc(t *testing.T) {
 	// prepare
 	t.Helper()
-	listeners := prepareListeners(t, testServices, model.InterceptionTproxy)
+	listeners := prepareListeners(t, testServices, model.InterceptionTproxy, false)
 
 	if len(listeners) != 2 {
 		t.Fatalf("expected %d listeners, found %d", 2, len(listeners))
@@ -307,6 +331,23 @@ func TestSidecarInboundListenerWithOriginalSrc(t *testing.T) {
 	}
 }
 
+// TestSidecarInboundListenerWithQUICConnectionBalance should not set
+// exact_balance for the virtualInbound listener as QUIC uses UDP
+// and this works only over TCP
+func TestSidecarInboundListenerWithQUICAndExactBalance(t *testing.T) {
+	// prepare
+	t.Helper()
+	listeners := prepareListeners(t, testServicesWithQUIC, model.InterceptionTproxy, true)
+
+	if len(listeners) != 2 {
+		t.Fatalf("expected %d listeners, found %d", 2, len(listeners))
+	}
+	l := listeners[1]
+	if l.ConnectionBalanceConfig == nil || l.ConnectionBalanceConfig.GetExactBalance() == nil {
+		t.Fatal("expected listener to have exact_balance set, but was empty")
+	}
+}
+
 func TestListenerBuilderPatchListeners(t *testing.T) {
 	configPatches := []*networking.EnvoyFilter_EnvoyConfigObjectPatch{
 		{
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 2d9fa0f854..7556de22a2 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -381,6 +381,68 @@ func TestOutboundListenerTCPWithVS(t *testing.T) {
 			if !reflect.DeepEqual(chains, tt.expectedChains) {
 				t.Fatalf("expected filter chains %v, found %v", tt.expectedChains, chains)
 			}
+
+			if listeners[0].ConnectionBalanceConfig != nil {
+				t.Fatalf("expected connection balance config to be set to empty, found %v", listeners[0].ConnectionBalanceConfig)
+			}
+		})
+	}
+}
+
+func TestOutboundListenerTCPWithVSExactBalance(t *testing.T) {
+	tests := []struct {
+		name           string
+		CIDR           string
+		expectedChains []string
+	}{
+		{
+			name:           "same CIDR",
+			CIDR:           "10.10.0.0/24",
+			expectedChains: []string{"10.10.0.0"},
+		},
+		{
+			name:           "different CIDR",
+			CIDR:           "10.10.10.0/24",
+			expectedChains: []string{"10.10.0.0", "10.10.10.0"},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			services := []*model.Service{
+				buildService("test.com", tt.CIDR, protocol.TCP, tnow),
+			}
+
+			p := &fakePlugin{}
+			virtualService := config.Config{
+				Meta: config.Meta{
+					GroupVersionKind: collections.IstioNetworkingV1Alpha3Virtualservices.Resource().GroupVersionKind(),
+					Name:             "test_vs",
+					Namespace:        "default",
+				},
+				Spec: virtualServiceSpec,
+			}
+			proxy := getProxy()
+			proxy.Metadata.InboundListenerExactBalance = true
+			proxy.Metadata.OutboundListenerExactBalance = true
+			listeners := buildOutboundListeners(t, p, proxy, nil, &virtualService, services...)
+
+			if len(listeners) != 1 {
+				t.Fatalf("expected %d listeners, found %d", 1, len(listeners))
+			}
+			var chains []string
+			for _, fc := range listeners[0].FilterChains {
+				for _, cidr := range fc.FilterChainMatch.PrefixRanges {
+					chains = append(chains, cidr.AddressPrefix)
+				}
+			}
+			// There should not be multiple filter chains with same CIDR match
+			if !reflect.DeepEqual(chains, tt.expectedChains) {
+				t.Fatalf("expected filter chains %v, found %v", tt.expectedChains, chains)
+			}
+
+			if listeners[0].ConnectionBalanceConfig == nil || listeners[0].ConnectionBalanceConfig.GetExactBalance() == nil {
+				t.Fatalf("expected connection balance config to be set to exact_balance, found %v", listeners[0].ConnectionBalanceConfig)
+			}
 		})
 	}
 }
@@ -481,6 +543,8 @@ func TestOutboundListenerForHeadlessServices(t *testing.T) {
 			})
 
 			proxy := cg.SetupProxy(nil)
+			proxy.Metadata.InboundListenerExactBalance = true
+			proxy.Metadata.OutboundListenerExactBalance = true
 
 			listeners := cg.ConfigGen.buildSidecarOutboundListeners(proxy, cg.env.PushContext)
 			listenersToCheck := make([]string, 0)
@@ -488,6 +552,10 @@ func TestOutboundListenerForHeadlessServices(t *testing.T) {
 				if l.Address.GetSocketAddress().GetPortValue() == 9999 {
 					listenersToCheck = append(listenersToCheck, l.Name)
 				}
+
+				if l.ConnectionBalanceConfig == nil || l.ConnectionBalanceConfig.GetExactBalance() == nil {
+					t.Fatalf("expected connection balance config to be set to exact_balance, found %v", listeners[0].ConnectionBalanceConfig)
+				}
 			}
 
 			if len(listenersToCheck) != tt.numListenersOnServicePort {
@@ -1528,6 +1596,9 @@ func testOutboundListenerConfigWithSidecarWithCaptureModeNone(t *testing.T, serv
 		if expectedListenerType == "HTTP" && !isHTTPListener(l) {
 			t.Fatalf("expected HTTP listener %s, but found TCP", listenerName)
 		}
+		if l.ConnectionBalanceConfig != nil {
+			t.Fatalf("expected connection balance config to be nil, found %v", l.ConnectionBalanceConfig)
+		}
 	}
 
 	if l := findListenerByPort(listeners, 9090); !isHTTPListener(l) {
@@ -1559,6 +1630,9 @@ func TestOutboundListenerAccessLogs(t *testing.T) {
 			if fc.AccessLog == nil {
 				t.Fatal("expected access log configuration")
 			}
+			if l.ConnectionBalanceConfig != nil {
+				t.Fatalf("expected connection balance config to be empty, found %v", l.ConnectionBalanceConfig)
+			}
 			found = true
 			break
 		}
diff --git a/releasenotes/notes/18152.yaml b/releasenotes/notes/18152.yaml
new file mode 100644
index 0000000000..12728dade5
--- /dev/null
+++ b/releasenotes/notes/18152.yaml
@@ -0,0 +1,9 @@
+apiVersion: release-notes/v2
+kind: feature
+area: traffic-management
+issue:
+  - 18152
+
+releaseNotes:
+- |
+  **Fixed** listeners to balance between Envoy worker threads. Fixes (#18152)[https://github.com/istio/istio/issues/18152).
\ No newline at end of file
-- 
2.35.3

