From 0202bdbc3c8e84b95cd43172c30c066bbe577f41 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 24 Mar 2022 09:36:58 -0700
Subject: [TF] Simplify echo deployment for single namespace (#38110)

---
 .../echo/common/deployment/echos.go           | 215 +++++++++
 .../echo/common/deployment/external.go        |  62 +++
 .../deployment/{apps.go => namespace.go}      | 436 +++++-------------
 .../framework/components/echo/instances.go    |  12 +
 .../framework/components/echo/services.go     |   1 +
 pkg/test/framework/components/istio/istio.go  |  44 +-
 .../pilot/cni/cniversionskew_test.go          |   6 +-
 tests/integration/pilot/common/routing.go     | 146 +++---
 tests/integration/pilot/common/traffic.go     |  10 +-
 .../integration/pilot/cross_revision_test.go  |   4 +-
 .../pilot/endpointslice/endpointslice_test.go |   4 +-
 tests/integration/pilot/gw_topology_test.go   |   2 +-
 tests/integration/pilot/ingress_test.go       |  54 +--
 tests/integration/pilot/istioctl_test.go      |  52 +--
 tests/integration/pilot/locality_test.go      |  12 +-
 tests/integration/pilot/main_test.go          |   4 +-
 tests/integration/pilot/mirror_test.go        |  18 +-
 .../pilot/multi_version_revision_test.go      |   2 +-
 tests/integration/pilot/multicluster_test.go  |   6 +-
 .../pilot/original_src_addr_test.go           |   4 +-
 tests/integration/pilot/piggyback_test.go     |   4 +-
 .../pilot/revisioned_upgrade_test.go          |   4 +-
 tests/integration/pilot/vm_test.go            |   8 +-
 23 files changed, 610 insertions(+), 500 deletions(-)
 create mode 100644 pkg/test/framework/components/echo/common/deployment/echos.go
 create mode 100644 pkg/test/framework/components/echo/common/deployment/external.go
 rename pkg/test/framework/components/echo/common/deployment/{apps.go => namespace.go} (50%)

diff --git a/pkg/test/framework/components/echo/common/deployment/echos.go b/pkg/test/framework/components/echo/common/deployment/echos.go
new file mode 100644
index 0000000000..c8598e275c
--- /dev/null
+++ b/pkg/test/framework/components/echo/common/deployment/echos.go
@@ -0,0 +1,215 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package deployment
+
+import (
+	"context"
+	"fmt"
+	"sort"
+	"strings"
+
+	"github.com/hashicorp/go-multierror"
+	"golang.org/x/sync/errgroup"
+
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
+	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/test/framework/resource"
+)
+
+// SingleNamespaceView is a simplified view of Echos for tests that only require a single namespace.
+type SingleNamespaceView struct {
+	// Include the echos at the top-level, so there is no need for accessing sub-structures.
+	EchoNamespace
+
+	// External (out-of-mesh) deployments
+	External External
+
+	// All echo instances
+	All echo.Services
+}
+
+// Echos is a common set of echo deployments to support integration testing.
+type Echos struct {
+	// NS is the list of echo namespaces.
+	NS []EchoNamespace
+
+	// External (out-of-mesh) deployments
+	External External
+
+	// All echo instances.
+	All echo.Services
+}
+
+// SingleNamespaceView converts this Echos into a SingleNamespaceView for NS1.
+func (d Echos) SingleNamespaceView() SingleNamespaceView {
+	return SingleNamespaceView{
+		EchoNamespace: d.NS1(),
+		External:      d.External,
+		All:           d.NS1().All.Append(d.External.All.Services()),
+	}
+}
+
+// NS1 is shorthand for NS[0]
+func (d Echos) NS1() EchoNamespace {
+	return d.NS[0]
+}
+
+// NS2 is shorthand for NS[1]. Will panic if there are not at least 2 apps namespaces.
+func (d Echos) NS2() EchoNamespace {
+	return d.NS[1]
+}
+
+// NS1AndNS2 returns the combined set of services in NS1 and NS2.
+func (d Echos) NS1AndNS2() echo.Services {
+	return d.NS1().All.Append(d.NS2().All)
+}
+
+func (d *Echos) loadValues(t resource.Context, echos echo.Instances) error {
+	d.All = echos.Services()
+
+	g := multierror.Group{}
+	for i := 0; i < len(d.NS); i++ {
+		i := i
+		g.Go(func() error {
+			return d.NS[i].loadValues(t, echos, d)
+		})
+	}
+
+	g.Go(func() error {
+		return d.External.loadValues(echos)
+	})
+
+	return g.Wait().ErrorOrNil()
+}
+
+func (d Echos) namespaces(excludes ...namespace.Instance) []string {
+	var out []string
+	for _, n := range d.NS {
+		include := true
+		for _, e := range excludes {
+			if n.Namespace.Name() == e.Name() {
+				include = false
+				break
+			}
+		}
+		if include {
+			out = append(out, n.Namespace.Name())
+		}
+	}
+
+	sort.Strings(out)
+	return out
+}
+
+func serviceEntryPorts() []echo.Port {
+	var res []echo.Port
+	for _, p := range ports.All().GetServicePorts() {
+		if strings.HasPrefix(p.Name, "auto") {
+			// The protocol needs to be set in common.EchoPorts to configure the echo deployment
+			// But for service entry, we want to ensure we set it to "" which will use sniffing
+			p.Protocol = ""
+		}
+		res = append(res, p)
+	}
+	return res
+}
+
+type Config struct {
+	NamespaceCount int
+}
+
+func (c *Config) fillDefaults() {
+	if c.NamespaceCount <= 1 {
+		c.NamespaceCount = 1
+	}
+}
+
+func SetupSingleNamespace(t resource.Context, view *SingleNamespaceView) error {
+	// Perform a setup with exactly 1 namespace.
+	var apps Echos
+	if err := Setup(t, &apps, Config{NamespaceCount: 1}); err != nil {
+		return err
+	}
+
+	// Store the single namespace view.
+	*view = apps.SingleNamespaceView()
+	return nil
+}
+
+func Setup(t resource.Context, apps *Echos, cfg Config) error {
+	cfg.fillDefaults()
+
+	// Create the namespaces concurrently.
+	g, _ := errgroup.WithContext(context.TODO())
+
+	// Create the echo namespaces.
+	apps.NS = make([]EchoNamespace, cfg.NamespaceCount)
+	if cfg.NamespaceCount == 1 {
+		// If only using a single namespace, preserve the "echo" prefix.
+		g.Go(func() (err error) {
+			apps.NS[0].Namespace, err = namespace.New(t, namespace.Config{
+				Prefix: "echo",
+				Inject: true,
+			})
+			return
+		})
+	} else {
+		for i := 0; i < cfg.NamespaceCount; i++ {
+			i := i
+			g.Go(func() (err error) {
+				apps.NS[i].Namespace, err = namespace.New(t, namespace.Config{
+					Prefix: fmt.Sprintf("echo%d", i),
+					Inject: true,
+				})
+				return
+			})
+		}
+	}
+
+	// Create the external namespace.
+	g.Go(func() (err error) {
+		apps.External.Namespace, err = namespace.New(t, namespace.Config{
+			Prefix: "external",
+			Inject: false,
+		})
+		return
+	})
+
+	// Wait for the namespaces to be created.
+	if err := g.Wait(); err != nil {
+		return err
+	}
+
+	builder := deployment.New(t).WithClusters(t.Clusters()...)
+	for _, n := range apps.NS {
+		builder = n.build(t, builder)
+	}
+	builder = apps.External.build(builder)
+
+	echos, err := builder.Build()
+	if err != nil {
+		return err
+	}
+
+	// Load values from the deployed echo instances.
+	return apps.loadValues(t, echos)
+}
+
+// TODO(nmittler): should t.Settings().Skip(echo.Delta) do all of this?
+func skipDeltaXDS(t resource.Context) bool {
+	return t.Settings().Skip(echo.Delta) || !t.Settings().Revisions.AtLeast("1.11")
+}
diff --git a/pkg/test/framework/components/echo/common/deployment/external.go b/pkg/test/framework/components/echo/common/deployment/external.go
new file mode 100644
index 0000000000..251c7f3b2f
--- /dev/null
+++ b/pkg/test/framework/components/echo/common/deployment/external.go
@@ -0,0 +1,62 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package deployment
+
+import (
+	"strconv"
+
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
+	"istio.io/istio/pkg/test/framework/components/echo/deployment"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+)
+
+const (
+	ExternalSvc      = "external"
+	externalHostname = "fake.external.com"
+)
+
+type External struct {
+	// Namespace where external echo app will be deployed
+	Namespace namespace.Instance
+
+	// All external echo instances with no sidecar injected
+	All echo.Instances
+}
+
+func (e External) build(b deployment.Builder) deployment.Builder {
+	return b.WithConfig(echo.Config{
+		Service:           ExternalSvc,
+		Namespace:         e.Namespace,
+		DefaultHostHeader: externalHostname,
+		Ports:             ports.All(),
+		Subsets: []echo.SubsetConfig{
+			{
+				Annotations: map[echo.Annotation]*echo.AnnotationValue{
+					echo.SidecarInject: {
+						Value: strconv.FormatBool(false),
+					},
+				},
+			},
+		},
+	})
+}
+
+func (e *External) loadValues(echos echo.Instances) error {
+	e.All = match.ServiceName(model.NamespacedName{Name: ExternalSvc, Namespace: e.Namespace.Name()}).GetMatches(echos)
+	return nil
+}
diff --git a/pkg/test/framework/components/echo/common/deployment/apps.go b/pkg/test/framework/components/echo/common/deployment/namespace.go
similarity index 50%
rename from pkg/test/framework/components/echo/common/deployment/apps.go
rename to pkg/test/framework/components/echo/common/deployment/namespace.go
index 54d276fb66..ac11d7b152 100644
--- a/pkg/test/framework/components/echo/common/deployment/apps.go
+++ b/pkg/test/framework/components/echo/common/deployment/namespace.go
@@ -15,44 +15,34 @@
 package deployment
 
 import (
-	"context"
-	"fmt"
 	"sort"
 	"strconv"
-	"strings"
-	"sync"
-
-	"github.com/hashicorp/go-multierror"
-	"golang.org/x/sync/errgroup"
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
 	"istio.io/istio/pkg/test/framework/components/echo/deployment"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
-	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 )
 
 const (
-	PodASvc          = "a"
-	PodBSvc          = "b"
-	PodCSvc          = "c"
-	PodTproxySvc     = "tproxy"
+	ASvc             = "a"
+	BSvc             = "b"
+	CSvc             = "c"
+	TproxySvc        = "tproxy"
 	VMSvc            = "vm"
 	HeadlessSvc      = "headless"
 	StatefulSetSvc   = "statefulset"
 	ProxylessGRPCSvc = "proxyless-grpc"
 	NakedSvc         = "naked"
-	ExternalSvc      = "external"
 	DeltaSvc         = "delta"
-	externalHostname = "fake.external.com"
 )
 
-type Namespace struct {
-	// Namespace echo apps will be deployed
+// EchoNamespace contains the echo instances for a single namespace.
+type EchoNamespace struct {
+	// Namespace where the services are deployed.
 	Namespace namespace.Instance
 
 	// Standard echo app to be used by tests
@@ -80,295 +70,32 @@ type Namespace struct {
 	All echo.Services
 }
 
-// ServiceNames returns the names of all services in this namespace.
-func (n Namespace) ServiceNames() []string {
-	out := make([]string, 0, len(n.All))
-	for _, n := range n.All.ServiceNames() {
-		out = append(out, n.Name)
-	}
-	sort.Strings(out)
-	return out
-}
-
-func (n *Namespace) loadValues(t resource.Context, echos echo.Instances, d *Echos) error {
-	ns := n.Namespace.Name()
-
-	all := func(is echo.Instances) echo.Instances {
-		if len(is) > 0 {
-			n.All = append(n.All, is)
-			return is
-		}
-		return nil
-	}
-
-	n.A = all(match.ServiceName(model.NamespacedName{Name: PodASvc, Namespace: ns}).GetMatches(echos))
-	n.B = all(match.ServiceName(model.NamespacedName{Name: PodBSvc, Namespace: ns}).GetMatches(echos))
-	n.C = all(match.ServiceName(model.NamespacedName{Name: PodCSvc, Namespace: ns}).GetMatches(echos))
-	n.Tproxy = all(match.ServiceName(model.NamespacedName{Name: PodTproxySvc, Namespace: ns}).GetMatches(echos))
-	n.Headless = all(match.ServiceName(model.NamespacedName{Name: HeadlessSvc, Namespace: ns}).GetMatches(echos))
-	n.StatefulSet = all(match.ServiceName(model.NamespacedName{Name: StatefulSetSvc, Namespace: ns}).GetMatches(echos))
-	n.Naked = all(match.ServiceName(model.NamespacedName{Name: NakedSvc, Namespace: ns}).GetMatches(echos))
-	n.ProxylessGRPC = all(match.ServiceName(model.NamespacedName{Name: ProxylessGRPCSvc, Namespace: ns}).GetMatches(echos))
-	if !t.Settings().Skip(echo.VM) {
-		n.VM = all(match.ServiceName(model.NamespacedName{Name: VMSvc, Namespace: ns}).GetMatches(echos))
-	}
-	if !skipDeltaXDS(t) {
-		n.DeltaXDS = all(match.ServiceName(model.NamespacedName{Name: DeltaSvc, Namespace: ns}).GetMatches(echos))
-	}
-
-	// Restrict egress from this namespace to only those endpoints in the same Echos.
-	if err := t.ConfigIstio().Eval(ns, map[string]interface{}{
-		"otherNS": d.namespaces(n.Namespace),
-	}, `
-apiVersion: networking.istio.io/v1alpha3
-kind: Sidecar
-metadata:
-  name: restrict-to-namespace
-spec:
-  egress:
-  - hosts:
-    - "./*"
-    - "istio-system/*"
-{{ range $ns := .otherNS }}
-    - "{{ $ns }}/*"
-{{ end }}
-`).Apply(resource.NoCleanup); err != nil {
-		return err
-	}
-
-	// Create a ServiceEntry to allow apps in this namespace to talk to the external service.
-	if err := t.ConfigIstio().Eval(ns, map[string]interface{}{
-		"Namespace": d.External.Namespace.Name(),
-		"Hostname":  externalHostname,
-		"Ports":     serviceEntryPorts(),
-	}, `apiVersion: networking.istio.io/v1alpha3
-kind: ServiceEntry
-metadata:
-  name: external-service
-spec:
-  hosts:
-  - {{.Hostname}}
-  location: MESH_EXTERNAL
-  resolution: DNS
-  endpoints:
-  - address: external.{{.Namespace}}.svc.cluster.local
-  ports:
-  - name: http-tls-origination
-    number: 8888
-    protocol: http
-    targetPort: 443
-  - name: http2-tls-origination
-    number: 8882
-    protocol: http2
-    targetPort: 443
-{{- range $i, $p := .Ports }}
-  - name: {{$p.Name}}
-    number: {{$p.ServicePort}}
-    protocol: "{{$p.Protocol}}"
-{{- end }}
-`).Apply(resource.NoCleanup); err != nil {
-		return err
-	}
-	return nil
-}
-
-type External struct {
-	// Namespace where external echo app will be deployed
-	Namespace namespace.Instance
-
-	// Echos app to be used by tests, with no sidecar injected
-	Echos echo.Instances
-}
-
-func (e *External) loadValues(echos echo.Instances) {
-	e.Echos = match.ServiceName(model.NamespacedName{Name: ExternalSvc, Namespace: e.Namespace.Name()}).GetMatches(echos)
-}
-
-// Echos is a common set of echo deployments to support integration testing.
-type Echos struct {
-	// Ingressgateway instance
-	Ingress   ingress.Instance
-	Ingresses ingress.Instances
-
-	// NS is the list of echo namespaces.
-	NS []Namespace
-
-	// External (out-of-mesh) deployments
-	External External
-
-	// All echo instances.
-	All echo.Services
-}
-
-// NS1 is shorthand for NS[0]
-func (d Echos) NS1() Namespace {
-	return d.NS[0]
-}
-
-// NS2 is shorthand for NS[1]. Will panic if there are not at least 2 apps namespaces.
-func (d Echos) NS2() Namespace {
-	return d.NS[1]
-}
-
-// NS1AndNS2 returns the combined set of services in NS1 and NS2.
-func (d Echos) NS1AndNS2() echo.Services {
-	return d.NS1().All.Append(d.NS2().All)
-}
-
-func (d *Echos) loadValues(t resource.Context, echos echo.Instances) error {
-	d.All = echos.Services()
-
-	for i := 0; i < len(d.NS); i++ {
-		if err := d.NS[i].loadValues(t, echos, d); err != nil {
-			return err
-		}
-	}
-
-	d.External.loadValues(echos)
-	return nil
-}
-
-func (d Echos) namespaces(excludes ...namespace.Instance) []string {
-	var out []string
-	for _, n := range d.NS {
-		include := true
-		for _, e := range excludes {
-			if n.Namespace.Name() == e.Name() {
-				include = false
-				break
-			}
-		}
-		if include {
-			out = append(out, n.Namespace.Name())
-		}
-	}
-
-	sort.Strings(out)
-	return out
-}
-
-func serviceEntryPorts() []echo.Port {
-	var res []echo.Port
-	for _, p := range ports.All().GetServicePorts() {
-		if strings.HasPrefix(p.Name, "auto") {
-			// The protocol needs to be set in common.EchoPorts to configure the echo deployment
-			// But for service entry, we want to ensure we set it to "" which will use sniffing
-			p.Protocol = ""
-		}
-		res = append(res, p)
-	}
-	return res
-}
-
-type Config struct {
-	NamespaceCount int
-}
-
-func (c *Config) fillDefaults() {
-	if c.NamespaceCount <= 1 {
-		c.NamespaceCount = 1
-	}
-}
-
-func Setup(t resource.Context, apps *Echos, cfg Config) error {
-	cfg.fillDefaults()
-
-	// Get the Istio component.
-	i, err := istio.Get(t)
-	if err != nil {
-		return err
-	}
-
-	// Create the namespaces concurrently.
-	g, _ := errgroup.WithContext(context.TODO())
-
-	// Create the echo namespaces.
-	apps.NS = make([]Namespace, cfg.NamespaceCount)
-	if cfg.NamespaceCount == 1 {
-		// If only using a single namespace, preserve the "echo" prefix.
-		g.Go(func() (err error) {
-			apps.NS[0].Namespace, err = namespace.New(t, namespace.Config{
-				Prefix: "echo",
-				Inject: true,
-			})
-			return
-		})
-	} else {
-		for i := 0; i < cfg.NamespaceCount; i++ {
-			i := i
-			g.Go(func() (err error) {
-				apps.NS[i].Namespace, err = namespace.New(t, namespace.Config{
-					Prefix: fmt.Sprintf("echo%d", i),
-					Inject: true,
-				})
-				return
-			})
-		}
-	}
-
-	// Create the external namespace.
-	g.Go(func() (err error) {
-		apps.External.Namespace, err = namespace.New(t, namespace.Config{
-			Prefix: "external",
-			Inject: false,
-		})
-		return
-	})
-
-	// Wait for the namespaces to be created.
-	if err := g.Wait(); err != nil {
-		return err
-	}
-
-	apps.Ingress = i.IngressFor(t.Clusters().Default())
-	apps.Ingresses = i.Ingresses()
-
-	builder := deployment.New(t).WithClusters(t.Clusters()...)
-	for _, n := range apps.NS {
-		builder = buildNamespace(t, builder, n.Namespace)
-	}
-	builder = buildExternal(builder, apps.External.Namespace)
-
-	echos, err := builder.Build()
-	if err != nil {
-		return err
-	}
-
-	// Load values from the deployed echo instances.
-	return apps.loadValues(t, echos)
-}
-
-// TODO: should t.Settings().Skip(echo.Delta) do all of this?
-func skipDeltaXDS(t resource.Context) bool {
-	return t.Settings().Skip(echo.Delta) || !t.Settings().Revisions.AtLeast("1.11")
-}
-
-func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Instance) deployment.Builder {
+func (n EchoNamespace) build(t resource.Context, b deployment.Builder) deployment.Builder {
 	b = b.WithConfig(echo.Config{
-		Service:        PodASvc,
-		Namespace:      ns,
+		Service:        ASvc,
+		Namespace:      n.Namespace,
 		ServiceAccount: true,
 		Ports:          ports.All(),
 		Subsets:        []echo.SubsetConfig{{}},
 		Locality:       "region.zone.subzone",
 	}).
 		WithConfig(echo.Config{
-			Service:        PodBSvc,
-			Namespace:      ns,
+			Service:        BSvc,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Ports:          ports.All(),
 			Subsets:        []echo.SubsetConfig{{}},
 		}).
 		WithConfig(echo.Config{
-			Service:        PodCSvc,
-			Namespace:      ns,
+			Service:        CSvc,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Ports:          ports.All(),
 			Subsets:        []echo.SubsetConfig{{}},
 		}).
 		WithConfig(echo.Config{
 			Service:        HeadlessSvc,
-			Namespace:      ns,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Headless:       true,
 			Ports:          ports.Headless(),
@@ -376,7 +103,7 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 		}).
 		WithConfig(echo.Config{
 			Service:        StatefulSetSvc,
-			Namespace:      ns,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Headless:       true,
 			StatefulSet:    true,
@@ -385,7 +112,7 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 		}).
 		WithConfig(echo.Config{
 			Service:        NakedSvc,
-			Namespace:      ns,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Ports:          ports.All(),
 			Subsets: []echo.SubsetConfig{
@@ -399,8 +126,8 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 			},
 		}).
 		WithConfig(echo.Config{
-			Service:        PodTproxySvc,
-			Namespace:      ns,
+			Service:        TproxySvc,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Ports:          ports.All(),
 			Subsets: []echo.SubsetConfig{{
@@ -409,7 +136,7 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 		}).
 		WithConfig(echo.Config{
 			Service:        VMSvc,
-			Namespace:      ns,
+			Namespace:      n.Namespace,
 			ServiceAccount: true,
 			Ports:          ports.All(),
 			DeployAsVM:     true,
@@ -421,7 +148,7 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 		b = b.
 			WithConfig(echo.Config{
 				Service:        DeltaSvc,
-				Namespace:      ns,
+				Namespace:      n.Namespace,
 				ServiceAccount: true,
 				Ports:          ports.All(),
 				Subsets: []echo.SubsetConfig{{
@@ -436,7 +163,7 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 			// TODO when agent handles secure control-plane connection for grpc-less, deploy to "remote" clusters
 			WithConfig(echo.Config{
 				Service:        ProxylessGRPCSvc,
-				Namespace:      ns,
+				Namespace:      n.Namespace,
 				ServiceAccount: true,
 				Ports:          ports.All(),
 				Subsets: []echo.SubsetConfig{
@@ -453,45 +180,92 @@ func buildNamespace(t resource.Context, b deployment.Builder, ns namespace.Insta
 	return b
 }
 
-func buildExternal(b deployment.Builder, ns namespace.Instance) deployment.Builder {
-	return b.WithConfig(echo.Config{
-		Service:           ExternalSvc,
-		Namespace:         ns,
-		DefaultHostHeader: externalHostname,
-		Ports:             ports.All(),
-		Subsets: []echo.SubsetConfig{
-			{
-				Annotations: map[echo.Annotation]*echo.AnnotationValue{
-					echo.SidecarInject: {
-						Value: strconv.FormatBool(false),
-					},
-				},
-			},
-		},
-	})
+// ServiceNames returns the names of all services in this namespace.
+func (n EchoNamespace) ServiceNames() []string {
+	out := make([]string, 0, len(n.All))
+	for _, n := range n.All.ServiceNames() {
+		out = append(out, n.Name)
+	}
+	sort.Strings(out)
+	return out
 }
 
-// Restart restarts all echo deployments.
-func (d Echos) Restart() error {
-	wg := sync.WaitGroup{}
-	aggregateErrMux := &sync.Mutex{}
-	var aggregateErr error
-	for _, app := range d.All.Instances() {
-		app := app
-		wg.Add(1)
-		go func() {
-			defer wg.Done()
+func (n *EchoNamespace) loadValues(t resource.Context, echos echo.Instances, d *Echos) error {
+	ns := n.Namespace.Name()
 
-			if err := app.Restart(); err != nil {
-				aggregateErrMux.Lock()
-				aggregateErr = multierror.Append(aggregateErr, err)
-				aggregateErrMux.Unlock()
-			}
-		}()
+	all := func(is echo.Instances) echo.Instances {
+		if len(is) > 0 {
+			n.All = append(n.All, is)
+			return is
+		}
+		return nil
 	}
-	wg.Wait()
-	if aggregateErr != nil {
-		return aggregateErr
+
+	n.A = all(match.ServiceName(model.NamespacedName{Name: ASvc, Namespace: ns}).GetMatches(echos))
+	n.B = all(match.ServiceName(model.NamespacedName{Name: BSvc, Namespace: ns}).GetMatches(echos))
+	n.C = all(match.ServiceName(model.NamespacedName{Name: CSvc, Namespace: ns}).GetMatches(echos))
+	n.Tproxy = all(match.ServiceName(model.NamespacedName{Name: TproxySvc, Namespace: ns}).GetMatches(echos))
+	n.Headless = all(match.ServiceName(model.NamespacedName{Name: HeadlessSvc, Namespace: ns}).GetMatches(echos))
+	n.StatefulSet = all(match.ServiceName(model.NamespacedName{Name: StatefulSetSvc, Namespace: ns}).GetMatches(echos))
+	n.Naked = all(match.ServiceName(model.NamespacedName{Name: NakedSvc, Namespace: ns}).GetMatches(echos))
+	n.ProxylessGRPC = all(match.ServiceName(model.NamespacedName{Name: ProxylessGRPCSvc, Namespace: ns}).GetMatches(echos))
+	if !t.Settings().Skip(echo.VM) {
+		n.VM = all(match.ServiceName(model.NamespacedName{Name: VMSvc, Namespace: ns}).GetMatches(echos))
+	}
+	if !skipDeltaXDS(t) {
+		n.DeltaXDS = all(match.ServiceName(model.NamespacedName{Name: DeltaSvc, Namespace: ns}).GetMatches(echos))
 	}
-	return nil
+
+	// Restrict egress from this namespace to only those endpoints in the same Echos.
+	cfg := t.ConfigIstio().New()
+	cfg.Eval(ns, map[string]interface{}{
+		"otherNS": d.namespaces(n.Namespace),
+	}, `
+apiVersion: networking.istio.io/v1alpha3
+kind: Sidecar
+metadata:
+  name: restrict-to-namespace
+spec:
+  egress:
+  - hosts:
+    - "./*"
+    - "istio-system/*"
+{{ range $ns := .otherNS }}
+    - "{{ $ns }}/*"
+{{ end }}
+`)
+
+	// Create a ServiceEntry to allow apps in this namespace to talk to the external service.
+	cfg.Eval(ns, map[string]interface{}{
+		"Namespace": d.External.Namespace.Name(),
+		"Hostname":  externalHostname,
+		"Ports":     serviceEntryPorts(),
+	}, `apiVersion: networking.istio.io/v1alpha3
+kind: ServiceEntry
+metadata:
+  name: external-service
+spec:
+  hosts:
+  - {{.Hostname}}
+  location: MESH_EXTERNAL
+  resolution: DNS
+  endpoints:
+  - address: external.{{.Namespace}}.svc.cluster.local
+  ports:
+  - name: http-tls-origination
+    number: 8888
+    protocol: http
+    targetPort: 443
+  - name: http2-tls-origination
+    number: 8882
+    protocol: http2
+    targetPort: 443
+{{- range $i, $p := .Ports }}
+  - name: {{$p.Name}}
+    number: {{$p.ServicePort}}
+    protocol: "{{$p.Protocol}}"
+{{- end }}
+`)
+
+	return cfg.Apply(resource.NoCleanup)
 }
diff --git a/pkg/test/framework/components/echo/instances.go b/pkg/test/framework/components/echo/instances.go
index 4ac896f051..5db5ac4196 100644
--- a/pkg/test/framework/components/echo/instances.go
+++ b/pkg/test/framework/components/echo/instances.go
@@ -18,6 +18,8 @@
 	"errors"
 	"sort"
 
+	"github.com/hashicorp/go-multierror"
+
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -157,3 +159,13 @@ func (i Instances) Copy() Instances {
 func (i Instances) Append(instances Instances) Instances {
 	return append(i.Copy(), instances...)
 }
+
+// Restart each Instance
+func (i Instances) Restart() error {
+	g := multierror.Group{}
+	for _, app := range i {
+		app := app
+		g.Go(app.Restart)
+	}
+	return g.Wait()
+}
diff --git a/pkg/test/framework/components/echo/services.go b/pkg/test/framework/components/echo/services.go
index f228329e5b..33dc4368f4 100644
--- a/pkg/test/framework/components/echo/services.go
+++ b/pkg/test/framework/components/echo/services.go
@@ -138,5 +138,6 @@ func (d Services) Append(others ...Services) Services {
 	for _, o := range others {
 		out = append(out, o...)
 	}
+	sort.Stable(out)
 	return out
 }
diff --git a/pkg/test/framework/components/istio/istio.go b/pkg/test/framework/components/istio/istio.go
index cdccacab5f..29f0fb6efc 100644
--- a/pkg/test/framework/components/istio/istio.go
+++ b/pkg/test/framework/components/istio/istio.go
@@ -62,10 +62,50 @@ func Get(ctx resource.Context) (Instance, error) {
 }
 
 // GetOrFail returns the Istio component from the context. If there is none the test is failed.
-func GetOrFail(f test.Failer, ctx resource.Context) Instance {
+func GetOrFail(t test.Failer, ctx resource.Context) Instance {
+	t.Helper()
 	i, err := Get(ctx)
 	if err != nil {
-		f.Fatal(err)
+		t.Fatal(err)
+	}
+	return i
+}
+
+// DefaultIngress returns the ingress installed in the default cluster. The ingress's service name
+// will be "istio-ingressgateway" and the istio label will be "ingressgateway".
+func DefaultIngress(ctx resource.Context) (ingress.Instance, error) {
+	i, err := Get(ctx)
+	if err != nil {
+		return nil, err
+	}
+	return i.IngressFor(ctx.Clusters().Default()), nil
+}
+
+// DefaultIngressOrFail calls DefaultIngress and fails if an error is encountered.
+func DefaultIngressOrFail(t test.Failer, ctx resource.Context) ingress.Instance {
+	t.Helper()
+	i, err := DefaultIngress(ctx)
+	if err != nil {
+		t.Fatal(err)
+	}
+	return i
+}
+
+// Ingresses returns all ingresses for "istio-ingressgateway" in each cluster.
+func Ingresses(ctx resource.Context) (ingress.Instances, error) {
+	i, err := Get(ctx)
+	if err != nil {
+		return nil, err
+	}
+	return i.Ingresses(), nil
+}
+
+// IngressesOrFail calls Ingresses and fails if an error is encountered.
+func IngressesOrFail(t test.Failer, ctx resource.Context) ingress.Instances {
+	t.Helper()
+	i, err := Ingresses(ctx)
+	if err != nil {
+		t.Fatal(err)
 	}
 	return i
 }
diff --git a/tests/integration/pilot/cni/cniversionskew_test.go b/tests/integration/pilot/cni/cniversionskew_test.go
index 844e64fbe5..c675c22a2f 100644
--- a/tests/integration/pilot/cni/cniversionskew_test.go
+++ b/tests/integration/pilot/cni/cniversionskew_test.go
@@ -38,7 +38,7 @@
 var (
 	i istio.Instance
 
-	apps = deployment.Echos{}
+	apps = deployment.SingleNamespaceView{}
 )
 
 const (
@@ -84,7 +84,7 @@ func TestCNIVersionSkew(t *testing.T) {
 				if _, err := kube.WaitUntilPodsAreReady(podFetchFn); err != nil {
 					t.Fatal(err)
 				}
-				if err := apps.Restart(); err != nil {
+				if err := apps.All.Instances().Restart(); err != nil {
 					t.Fatalf("Failed to restart apps %v", err)
 				}
 				common.RunAllTrafficTests(t, i, &apps)
@@ -101,7 +101,7 @@ func TestMain(m *testing.M) {
 		RequireMultiPrimary().
 		Setup(istio.Setup(&i, nil)).
 		Setup(func(t resource.Context) error {
-			return deployment.Setup(t, &apps, deployment.Config{})
+			return deployment.SetupSingleNamespace(t, &apps)
 		}).
 		Run()
 }
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 2996208369..a92a00c534 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -40,11 +40,13 @@
 	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	epb "istio.io/istio/pkg/test/echo/proto"
+	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common/deployment"
 	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
+	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/tmpl"
@@ -763,7 +765,7 @@ func HostHeader(header string) http.Header {
 }
 
 // tlsOriginationCases contains tests TLS origination from DestinationRule
-func tlsOriginationCases(apps *deployment.Echos) []TrafficTestCase {
+func tlsOriginationCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	tc := TrafficTestCase{
 		name: "",
 		config: fmt.Sprintf(`
@@ -776,7 +778,7 @@ func tlsOriginationCases(apps *deployment.Echos) []TrafficTestCase {
   trafficPolicy:
     tls:
       mode: SIMPLE
-`, apps.External.Echos.Config().DefaultHostHeader),
+`, apps.External.All.Config().DefaultHostHeader),
 		children: []TrafficCall{},
 	}
 	expects := []struct {
@@ -786,7 +788,7 @@ func tlsOriginationCases(apps *deployment.Echos) []TrafficTestCase {
 		{8888, "http/1.1"},
 		{8882, "h2"},
 	}
-	for _, c := range apps.NS1().A {
+	for _, c := range apps.A {
 		for _, e := range expects {
 			c := c
 			e := e
@@ -796,9 +798,9 @@ func tlsOriginationCases(apps *deployment.Echos) []TrafficTestCase {
 				opts: echo.CallOptions{
 					Port:    echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
 					Count:   1,
-					Address: apps.External.Echos[0].Address(),
+					Address: apps.External.All[0].Address(),
 					HTTP: echo.HTTP{
-						Headers: HostHeader(apps.External.Echos[0].Config().DefaultHostHeader),
+						Headers: HostHeader(apps.External.All[0].Config().DefaultHostHeader),
 					},
 					Scheme: scheme.HTTP,
 					Check: check.And(
@@ -813,10 +815,10 @@ func tlsOriginationCases(apps *deployment.Echos) []TrafficTestCase {
 }
 
 // useClientProtocolCases contains tests use_client_protocol from DestinationRule
-func useClientProtocolCases(apps *deployment.Echos) []TrafficTestCase {
+func useClientProtocolCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
-	client := apps.NS1().A
-	to := apps.NS1().C
+	client := apps.A
+	to := apps.C
 	cases = append(cases,
 		TrafficTestCase{
 			name:   "use client protocol with h2",
@@ -862,10 +864,10 @@ func useClientProtocolCases(apps *deployment.Echos) []TrafficTestCase {
 }
 
 // destinationRuleCases contains tests some specific DestinationRule tests.
-func destinationRuleCases(apps *deployment.Echos) []TrafficTestCase {
+func destinationRuleCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
-	from := apps.NS1().A
-	to := apps.NS1().C
+	from := apps.A
+	to := apps.C
 	cases = append(cases,
 		// Validates the config is generated correctly when only idletimeout is specified in DR.
 		TrafficTestCase{
@@ -890,10 +892,10 @@ func destinationRuleCases(apps *deployment.Echos) []TrafficTestCase {
 }
 
 // trafficLoopCases contains tests to ensure traffic does not loop through the sidecar
-func trafficLoopCases(apps *deployment.Echos) []TrafficTestCase {
+func trafficLoopCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
-	for _, c := range apps.NS1().A {
-		for _, d := range apps.NS1().B {
+	for _, c := range apps.A {
+		for _, d := range apps.B {
 			for _, port := range []string{"15001", "15006"} {
 				c, d, port := c, d, port
 				cases = append(cases, TrafficTestCase{
@@ -920,14 +922,15 @@ func trafficLoopCases(apps *deployment.Echos) []TrafficTestCase {
 }
 
 // autoPassthroughCases tests that we cannot hit unexpected destinations when using AUTO_PASSTHROUGH
-func autoPassthroughCases(apps *deployment.Echos) []TrafficTestCase {
+func autoPassthroughCases(t framework.TestContext, apps *deployment.SingleNamespaceView) []TrafficTestCase {
+	t.Helper()
 	var cases []TrafficTestCase
 	// We test the cross product of all Istio ALPNs (or no ALPN), all mTLS modes, and various backends
 	alpns := []string{"istio", "istio-peer-exchange", "istio-http/1.0", "istio-http/1.1", "istio-h2", ""}
 	modes := []string{"STRICT", "PERMISSIVE", "DISABLE"}
 
-	mtlsHost := host.Name(apps.NS1().A.Config().ClusterLocalFQDN())
-	nakedHost := host.Name(apps.NS1().Naked.Config().ClusterLocalFQDN())
+	mtlsHost := host.Name(apps.A.Config().ClusterLocalFQDN())
+	nakedHost := host.Name(apps.Naked.Config().ClusterLocalFQDN())
 	httpsPort := ports.All().MustForName("https").ServicePort
 	httpsAutoPort := ports.All().MustForName("auto-https").ServicePort
 	snis := []string{
@@ -940,6 +943,7 @@ func autoPassthroughCases(apps *deployment.Echos) []TrafficTestCase {
 		model.BuildSubsetKey(model.TrafficDirectionOutbound, "", nakedHost, httpsAutoPort),
 		model.BuildDNSSrvSubsetKey(model.TrafficDirectionOutbound, "", nakedHost, httpsAutoPort),
 	}
+	defaultIngress := istio.DefaultIngressOrFail(t, t)
 	for _, mode := range modes {
 		var childs []TrafficCall
 		for _, sni := range snis {
@@ -951,7 +955,7 @@ func autoPassthroughCases(apps *deployment.Echos) []TrafficTestCase {
 				}
 				childs = append(childs, TrafficCall{
 					name: fmt.Sprintf("mode:%v,sni:%v,alpn:%v", mode, sni, alpn),
-					call: apps.Ingress.CallOrFail,
+					call: defaultIngress.CallOrFail,
 					opts: echo.CallOptions{
 						Port: echo.Port{
 							ServicePort: 443,
@@ -1486,11 +1490,11 @@ func gatewayCases() []TrafficTestCase {
 	return cases
 }
 
-func XFFGatewayCase(apps *deployment.Echos, gateway string) []TrafficTestCase {
+func XFFGatewayCase(apps *deployment.SingleNamespaceView, gateway string) []TrafficTestCase {
 	var cases []TrafficTestCase
 
 	destinationSets := []echo.Instances{
-		apps.NS1().A,
+		apps.A,
 	}
 
 	for _, d := range destinationSets {
@@ -1502,7 +1506,7 @@ func XFFGatewayCase(apps *deployment.Echos, gateway string) []TrafficTestCase {
 		cases = append(cases, TrafficTestCase{
 			name:   d[0].Config().Service,
 			config: httpGateway("*") + httpVirtualService("gateway", fqdn, d[0].PortForName("http").ServicePort),
-			call:   apps.NS1().Naked[0].CallOrFail,
+			call:   apps.Naked[0].CallOrFail,
 			opts: echo.CallOptions{
 				Count:   1,
 				Port:    echo.Port{ServicePort: 80},
@@ -1541,7 +1545,7 @@ func(r echoClient.Response) error {
 	return cases
 }
 
-func envoyFilterCases(apps *deployment.Echos) []TrafficTestCase {
+func envoyFilterCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
 	// Test adding envoyfilter to inbound and outbound route/cluster/listeners
 	cfg := `
@@ -1639,12 +1643,12 @@ function envoy_on_request(request_handle)
       value:
         http2_protocol_options: {}
 `
-	for _, c := range apps.NS1().A {
+	for _, c := range apps.A {
 		cases = append(cases, TrafficTestCase{
 			config: cfg,
 			call:   c.CallOrFail,
 			opts: echo.CallOptions{
-				To: apps.NS1().B,
+				To: apps.B,
 				Port: echo.Port{
 					Name: "http",
 				},
@@ -1665,12 +1669,12 @@ function envoy_on_request(request_handle)
 }
 
 // hostCases tests different forms of host header to use
-func hostCases(apps *deployment.Echos) ([]TrafficTestCase, error) {
+func hostCases(apps *deployment.SingleNamespaceView) ([]TrafficTestCase, error) {
 	var cases []TrafficTestCase
-	for _, c := range apps.NS1().A {
-		cfg := apps.NS1().Headless.Config()
+	for _, c := range apps.A {
+		cfg := apps.Headless.Config()
 		port := ports.All().MustForName("auto-http").WorkloadPort
-		wl, err := apps.NS1().Headless[0].Workloads()
+		wl, err := apps.Headless[0].Workloads()
 		if err != nil {
 			return nil, err
 		}
@@ -1699,7 +1703,7 @@ func hostCases(apps *deployment.Echos) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallOrFail,
 				opts: echo.CallOptions{
-					To: apps.NS1().Headless,
+					To: apps.Headless,
 					Port: echo.Port{
 						Name: "auto-http",
 					},
@@ -1732,7 +1736,7 @@ func hostCases(apps *deployment.Echos) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallOrFail,
 				opts: echo.CallOptions{
-					To: apps.NS1().Headless,
+					To: apps.Headless,
 					Port: echo.Port{
 						Name: "http",
 					},
@@ -1758,9 +1762,9 @@ func hostCases(apps *deployment.Echos) ([]TrafficTestCase, error) {
 // 3) Another service, B', with P' -> T. In this case, the listener is shared. This is fine, with the exception of different protocols
 //    The cluster is distinct.
 // 4) Another service, B', with P' -> T'. There is no conflicts here at all.
-func serviceCases(apps *deployment.Echos) []TrafficTestCase {
+func serviceCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
-	for _, c := range apps.NS1().A {
+	for _, c := range apps.A {
 		c := c
 
 		// Case 1
@@ -1882,9 +1886,9 @@ func serviceCases(apps *deployment.Echos) []TrafficTestCase {
 }
 
 // consistentHashCases tests destination rule's consistent hashing mechanism
-func consistentHashCases(apps *deployment.Echos) []TrafficTestCase {
+func consistentHashCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
-	for _, app := range []echo.Instances{apps.NS1().A, apps.NS1().B} {
+	for _, app := range []echo.Instances{apps.A, apps.B} {
 		app := app
 		for _, c := range app {
 			c := c
@@ -2111,7 +2115,7 @@ func selfCallsCases() []TrafficTestCase {
 }
 
 // TODO: merge with security TestReachability code
-func protocolSniffingCases(apps *deployment.Echos) []TrafficTestCase {
+func protocolSniffingCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
 
 	type protocolCase struct {
@@ -2177,9 +2181,9 @@ type protocolCase struct {
 	// To simulate these, we use TCP and hand-craft the requests.
 	cases = append(cases, TrafficTestCase{
 		name: "http10 to http",
-		call: apps.NS1().A[0].CallOrFail,
+		call: apps.A[0].CallOrFail,
 		opts: echo.CallOptions{
-			To:    apps.NS1().B,
+			To:    apps.B,
 			Count: 1,
 			Port: echo.Port{
 				Name: "http",
@@ -2196,9 +2200,9 @@ type protocolCase struct {
 	},
 		TrafficTestCase{
 			name: "http10 to auto",
-			call: apps.NS1().A[0].CallOrFail,
+			call: apps.A[0].CallOrFail,
 			opts: echo.CallOptions{
-				To:    apps.NS1().B,
+				To:    apps.B,
 				Count: 1,
 				Port: echo.Port{
 					Name: "auto-http",
@@ -2215,11 +2219,11 @@ type protocolCase struct {
 		},
 		TrafficTestCase{
 			name: "http10 to external",
-			call: apps.NS1().A[0].CallOrFail,
+			call: apps.A[0].CallOrFail,
 			opts: echo.CallOptions{
-				Address: apps.External.Echos[0].Address(),
+				Address: apps.External.All[0].Address(),
 				HTTP: echo.HTTP{
-					Headers: HostHeader(apps.External.Echos.Config().DefaultHostHeader),
+					Headers: HostHeader(apps.External.All.Config().DefaultHostHeader),
 				},
 				Port:   httpPort,
 				Count:  1,
@@ -2235,11 +2239,11 @@ type protocolCase struct {
 		},
 		TrafficTestCase{
 			name: "http10 to external auto",
-			call: apps.NS1().A[0].CallOrFail,
+			call: apps.A[0].CallOrFail,
 			opts: echo.CallOptions{
-				Address: apps.External.Echos[0].Address(),
+				Address: apps.External.All[0].Address(),
 				HTTP: echo.HTTP{
-					Headers: HostHeader(apps.External.Echos.Config().DefaultHostHeader),
+					Headers: HostHeader(apps.External.All.Config().DefaultHostHeader),
 				},
 				Port:   autoPort,
 				Count:  1,
@@ -2279,7 +2283,7 @@ type protocolCase struct {
 }
 
 // Todo merge with security TestReachability code
-func instanceIPTests(apps *deployment.Echos) []TrafficTestCase {
+func instanceIPTests(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var cases []TrafficTestCase
 	ipCases := []struct {
 		name            string
@@ -2372,10 +2376,10 @@ func instanceIPTests(apps *deployment.Echos) []TrafficTestCase {
 		},
 	}
 	for _, ipCase := range ipCases {
-		for _, client := range apps.NS1().A {
+		for _, client := range apps.A {
 			ipCase := ipCase
 			client := client
-			to := apps.NS1().B
+			to := apps.B
 			var config string
 			if !ipCase.disableSidecar {
 				config = fmt.Sprintf(`
@@ -2433,7 +2437,7 @@ type vmCase struct {
 	host string
 }
 
-func DNSTestCases(apps *deployment.Echos, cniEnabled bool) []TrafficTestCase {
+func DNSTestCases(apps *deployment.SingleNamespaceView, cniEnabled bool) []TrafficTestCase {
 	makeSE := func(ips ...string) string {
 		return tmpl.MustEvaluate(`
 apiVersion: networking.istio.io/v1alpha3
@@ -2513,7 +2517,7 @@ func DNSTestCases(apps *deployment.Echos, cniEnabled bool) []TrafficTestCase {
 			server:   dummyLocalhostServer,
 		},
 	}
-	for _, client := range flatten(apps.NS1().VM, apps.NS1().A, apps.NS1().Tproxy) {
+	for _, client := range flatten(apps.VM, apps.A, apps.Tproxy) {
 		for _, tt := range cases {
 			if tt.skipCNI && cniEnabled {
 				continue
@@ -2564,13 +2568,13 @@ func DNSTestCases(apps *deployment.Echos, cniEnabled bool) []TrafficTestCase {
 			protocol: "udp",
 		},
 	}
-	for _, client := range flatten(apps.NS1().VM, apps.NS1().A, apps.NS1().Tproxy) {
+	for _, client := range flatten(apps.VM, apps.A, apps.Tproxy) {
 		for _, tt := range svcCases {
 			tt, client := tt, client
-			aInCluster := match.Cluster(client.Config().Cluster).GetMatches(apps.NS1().A)
+			aInCluster := match.Cluster(client.Config().Cluster).GetMatches(apps.A)
 			if len(aInCluster) == 0 {
 				// The cluster doesn't contain A, but connects to a cluster containing A
-				aInCluster = match.Cluster(client.Config().Cluster.Config()).GetMatches(apps.NS1().A)
+				aInCluster = match.Cluster(client.Config().Cluster.Config()).GetMatches(apps.A)
 			}
 			address := aInCluster[0].Config().ClusterLocalFQDN() + "?"
 			if tt.protocol != "" {
@@ -2605,7 +2609,7 @@ func DNSTestCases(apps *deployment.Echos, cniEnabled bool) []TrafficTestCase {
 	return tcases
 }
 
-func VMTestCases(vms echo.Instances, apps *deployment.Echos) []TrafficTestCase {
+func VMTestCases(vms echo.Instances, apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	var testCases []vmCase
 
 	for _, vm := range vms {
@@ -2613,32 +2617,32 @@ func VMTestCases(vms echo.Instances, apps *deployment.Echos) []TrafficTestCase {
 			vmCase{
 				name: "dns: VM to k8s cluster IP service name.namespace host",
 				from: vm,
-				to:   apps.NS1().A,
-				host: deployment.PodASvc + "." + apps.NS1().Namespace.Name(),
+				to:   apps.A,
+				host: deployment.ASvc + "." + apps.Namespace.Name(),
 			},
 			vmCase{
 				name: "dns: VM to k8s cluster IP service fqdn host",
 				from: vm,
-				to:   apps.NS1().A,
-				host: apps.NS1().A[0].Config().ClusterLocalFQDN(),
+				to:   apps.A,
+				host: apps.A[0].Config().ClusterLocalFQDN(),
 			},
 			vmCase{
 				name: "dns: VM to k8s cluster IP service short name host",
 				from: vm,
-				to:   apps.NS1().A,
-				host: deployment.PodASvc,
+				to:   apps.A,
+				host: deployment.ASvc,
 			},
 			vmCase{
 				name: "dns: VM to k8s headless service",
 				from: vm,
-				to:   match.Cluster(vm.Config().Cluster.Config()).GetMatches(apps.NS1().Headless),
-				host: apps.NS1().Headless.Config().ClusterLocalFQDN(),
+				to:   match.Cluster(vm.Config().Cluster.Config()).GetMatches(apps.Headless),
+				host: apps.Headless.Config().ClusterLocalFQDN(),
 			},
 			vmCase{
 				name: "dns: VM to k8s statefulset service",
 				from: vm,
-				to:   match.Cluster(vm.Config().Cluster.Config()).GetMatches(apps.NS1().StatefulSet),
-				host: apps.NS1().StatefulSet.Config().ClusterLocalFQDN(),
+				to:   match.Cluster(vm.Config().Cluster.Config()).GetMatches(apps.StatefulSet),
+				host: apps.StatefulSet.Config().ClusterLocalFQDN(),
 			},
 			// TODO(https://github.com/istio/istio/issues/32552) re-enable
 			//vmCase{
@@ -2667,7 +2671,7 @@ func VMTestCases(vms echo.Instances, apps *deployment.Echos) []TrafficTestCase {
 			//},
 		)
 	}
-	for _, podA := range apps.NS1().A {
+	for _, podA := range apps.A {
 		testCases = append(testCases, vmCase{
 			name: "k8s to vm",
 			from: podA,
@@ -2777,10 +2781,10 @@ func globalPeerAuthentication(mode string) string {
 `, mode)
 }
 
-func serverFirstTestCases(apps *deployment.Echos) []TrafficTestCase {
+func serverFirstTestCases(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	cases := make([]TrafficTestCase, 0)
-	from := apps.NS1().A
-	to := apps.NS1().C
+	from := apps.A
+	to := apps.C
 	configs := []struct {
 		port    string
 		dest    string
@@ -2821,7 +2825,7 @@ func serverFirstTestCases(apps *deployment.Echos) []TrafficTestCase {
 			cases = append(cases, TrafficTestCase{
 				name: fmt.Sprintf("%v:%v/%v", c.port, c.dest, c.auth),
 				skip: skip{
-					skip:   apps.NS1().All.Instances().Clusters().IsMulticluster(),
+					skip:   apps.All.Instances().Clusters().IsMulticluster(),
 					reason: "https://github.com/istio/istio/issues/37305: stabilize tcp connection breaks",
 				},
 				config: destinationRule(to.Config().Service, c.dest) + peerAuthentication(to.Config().Service, c.auth),
@@ -2844,7 +2848,7 @@ func serverFirstTestCases(apps *deployment.Echos) []TrafficTestCase {
 	return cases
 }
 
-func jwtClaimRoute(apps *deployment.Echos) []TrafficTestCase {
+func jwtClaimRoute(apps *deployment.SingleNamespaceView) []TrafficTestCase {
 	configRoute := `
 apiVersion: networking.istio.io/v1alpha3
 kind: Gateway
@@ -2905,7 +2909,7 @@ func jwtClaimRoute(apps *deployment.Echos) []TrafficTestCase {
     jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
 ---
 `
-	podB := []match.Matcher{match.ServiceName(apps.NS1().B.NamespacedName())}
+	podB := []match.Matcher{match.ServiceName(apps.B.NamespacedName())}
 	headersWithToken := map[string][]string{
 		"Host":          {"foo.bar"},
 		"Authorization": {"Bearer " + jwt.TokenIssuer1WithNestedClaims1},
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index f9aaa8a377..40478cdc29 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -235,7 +235,7 @@ func (c TrafficTestCase) Run(t framework.TestContext, namespace string) {
 	}
 }
 
-func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *deployment.Echos) {
+func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *deployment.SingleNamespaceView) {
 	cases := map[string][]TrafficTestCase{}
 	if !t.Settings().Selector.Excludes(label.NewSet(label.IPv4)) { // https://github.com/istio/istio/issues/35835
 		cases["jwt-claim-route"] = jwtClaimRoute(apps)
@@ -245,7 +245,7 @@ func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *deploym
 	cases["selfcall"] = selfCallsCases()
 	cases["serverfirst"] = serverFirstTestCases(apps)
 	cases["gateway"] = gatewayCases()
-	cases["autopassthrough"] = autoPassthroughCases(apps)
+	cases["autopassthrough"] = autoPassthroughCases(t, apps)
 	cases["loop"] = trafficLoopCases(apps)
 	cases["tls-origination"] = tlsOriginationCases(apps)
 	cases["instanceip"] = instanceIPTests(apps)
@@ -264,16 +264,16 @@ func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *deploym
 	cases["use-client-protocol"] = useClientProtocolCases(apps)
 	cases["destinationrule"] = destinationRuleCases(apps)
 	if !t.Settings().Skip(echo.VM) {
-		cases["vm"] = VMTestCases(apps.NS1().VM, apps)
+		cases["vm"] = VMTestCases(apps.VM, apps)
 	}
 	cases["dns"] = DNSTestCases(apps, i.Settings().EnableCNI)
 	for name, tts := range cases {
 		t.NewSubTest(name).Run(func(t framework.TestContext) {
 			for _, tt := range tts {
 				if tt.workloadAgnostic {
-					tt.RunForApps(t, apps.All.Instances(), apps.NS1().Namespace.Name())
+					tt.RunForApps(t, apps.All.Instances(), apps.Namespace.Name())
 				} else {
-					tt.Run(t, apps.NS1().Namespace.Name())
+					tt.Run(t, apps.Namespace.Name())
 				}
 			}
 		})
diff --git a/tests/integration/pilot/cross_revision_test.go b/tests/integration/pilot/cross_revision_test.go
index f594849b1a..8f8b3061bc 100644
--- a/tests/integration/pilot/cross_revision_test.go
+++ b/tests/integration/pilot/cross_revision_test.go
@@ -58,7 +58,7 @@ func TestRevisionTraffic(t *testing.T) {
 				})
 			}
 			// Allow all namespaces so we do not hit passthrough cluster
-			t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), `apiVersion: networking.istio.io/v1alpha3
+			t.ConfigIstio().YAML(apps.Namespace.Name(), `apiVersion: networking.istio.io/v1alpha3
 kind: Sidecar
 metadata:
   name: allow-cross-namespaces
@@ -82,7 +82,7 @@ func TestRevisionTraffic(t *testing.T) {
 			}
 			instances := builder.BuildOrFail(t)
 			// Add our existing revision to the instances list
-			instances = append(instances, apps.NS1().A...)
+			instances = append(instances, apps.A...)
 			testAllEchoCalls(t, instances)
 		})
 }
diff --git a/tests/integration/pilot/endpointslice/endpointslice_test.go b/tests/integration/pilot/endpointslice/endpointslice_test.go
index fcba557eb2..1e414959e8 100644
--- a/tests/integration/pilot/endpointslice/endpointslice_test.go
+++ b/tests/integration/pilot/endpointslice/endpointslice_test.go
@@ -35,7 +35,7 @@
 	// Below are various preconfigured echo deployments. Whenever possible, tests should utilize these
 	// to avoid excessive creation/tear down of deployments. In general, a test should only deploy echo if
 	// its doing something unique to that specific test.
-	apps = deployment.Echos{}
+	apps = deployment.SingleNamespaceView{}
 )
 
 func TestMain(m *testing.M) {
@@ -54,7 +54,7 @@ func TestMain(m *testing.M) {
 				kubelib.IsLessThanVersion(t.Clusters().Kube().Default(), 21))
 		})).
 		Setup(func(t resource.Context) error {
-			return deployment.Setup(t, &apps, deployment.Config{})
+			return deployment.SetupSingleNamespace(t, &apps)
 		}).
 		Run()
 }
diff --git a/tests/integration/pilot/gw_topology_test.go b/tests/integration/pilot/gw_topology_test.go
index 0878d6da5c..84bd72ab81 100644
--- a/tests/integration/pilot/gw_topology_test.go
+++ b/tests/integration/pilot/gw_topology_test.go
@@ -97,7 +97,7 @@ func TestXFFGateway(t *testing.T) {
 				return err
 			}, retry.Timeout(time.Minute*2), retry.Delay(time.Second))
 			for _, tt := range common.XFFGatewayCase(&apps, fmt.Sprintf("custom-gateway.%s.svc.cluster.local", gatewayNs.Name())) {
-				tt.Run(t, apps.NS1().Namespace.Name())
+				tt.Run(t, apps.Namespace.Name())
 			}
 		})
 }
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index 574939f7e2..6f929d3e58 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -41,6 +41,7 @@
 	kubecluster "istio.io/istio/pkg/test/framework/components/cluster/kube"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/environment/kube"
+	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/helm"
@@ -123,11 +124,11 @@ func TestGateway(t *testing.T) {
       certificateRefs:
       - kind: Secret
         name: test-gateway-cert-same
----`, apps.NS1().Namespace.Name())).Apply()
+---`, apps.Namespace.Name())).Apply()
 				return err
 			}, retry.Delay(time.Second*10), retry.Timeout(time.Second*90))
 			retry.UntilSuccessOrFail(t, func() error {
-				err := t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), `
+				err := t.ConfigIstio().YAML(apps.Namespace.Name(), `
 apiVersion: gateway.networking.k8s.io/v1alpha2
 kind: HTTPRoute
 metadata:
@@ -187,12 +188,12 @@ func TestGateway(t *testing.T) {
 `).Apply()
 				return err
 			}, retry.Delay(time.Second*10), retry.Timeout(time.Second*90))
-			for _, ingr := range apps.Ingresses {
+			for _, ingr := range istio.IngressesOrFail(t, t) {
 				t.NewSubTest(ingr.Cluster().StableName()).Run(func(t framework.TestContext) {
 					t.NewSubTest("http").Run(func(t framework.TestContext) {
 						paths := []string{"/get", "/get/", "/get/prefix"}
 						for _, path := range paths {
-							_ = apps.Ingress.CallOrFail(t, echo.CallOptions{
+							_ = ingr.CallOrFail(t, echo.CallOptions{
 								Port: echo.Port{
 									Protocol: protocol.HTTP,
 								},
@@ -204,7 +205,7 @@ func TestGateway(t *testing.T) {
 						}
 					})
 					t.NewSubTest("tcp").Run(func(t framework.TestContext) {
-						_ = apps.Ingress.CallOrFail(t, echo.CallOptions{
+						_ = ingr.CallOrFail(t, echo.CallOptions{
 							Port: echo.Port{
 								Protocol:    protocol.HTTP,
 								ServicePort: 31400,
@@ -216,8 +217,8 @@ func TestGateway(t *testing.T) {
 						})
 					})
 					t.NewSubTest("mesh").Run(func(t framework.TestContext) {
-						_ = apps.NS1().A[0].CallOrFail(t, echo.CallOptions{
-							To: apps.NS1().B,
+						_ = apps.A[0].CallOrFail(t, echo.CallOptions{
+							To: apps.B,
 							Port: echo.Port{
 								Name: "http",
 							},
@@ -244,7 +245,7 @@ func TestGateway(t *testing.T) {
 				})
 			}
 			t.NewSubTest("managed").Run(func(t framework.TestContext) {
-				t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), `apiVersion: gateway.networking.k8s.io/v1alpha2
+				t.ConfigIstio().YAML(apps.Namespace.Name(), `apiVersion: gateway.networking.k8s.io/v1alpha2
 kind: Gateway
 metadata:
   name: gateway
@@ -268,13 +269,13 @@ func TestGateway(t *testing.T) {
     - name: b
       port: 80
 `).ApplyOrFail(t)
-				apps.NS1().B[0].CallOrFail(t, echo.CallOptions{
+				apps.B[0].CallOrFail(t, echo.CallOptions{
 					Port:   echo.Port{ServicePort: 80},
 					Scheme: scheme.HTTP,
 					HTTP: echo.HTTP{
 						Headers: headers.New().WithHost("bar.example.com").Build(),
 					},
-					Address: fmt.Sprintf("gateway.%s.svc.cluster.local", apps.NS1().Namespace.Name()),
+					Address: fmt.Sprintf("gateway.%s.svc.cluster.local", apps.Namespace.Name()),
 					Check:   check.OK(),
 					Retry: echo.Retry{
 						Options: []retry.Option{retry.Timeout(time.Minute)},
@@ -382,7 +383,7 @@ func TestIngress(t *testing.T) {
 `
 			}
 
-			successChecker := check.And(check.OK(), check.ReachedClusters(apps.NS1().B.Clusters()))
+			successChecker := check.And(check.OK(), check.ReachedClusters(apps.B.Clusters()))
 			failureChecker := check.Status(http.StatusNotFound)
 			count := 2 * t.Clusters().Len()
 
@@ -557,13 +558,13 @@ func TestIngress(t *testing.T) {
 				},
 			}
 
-			for _, ingr := range apps.Ingresses {
+			for _, ingr := range istio.IngressesOrFail(t, t) {
 				ingr := ingr
 				t.NewSubTestf("from %s", ingr.Cluster().StableName()).Run(func(t framework.TestContext) {
 					for _, c := range cases {
 						c := c
 						t.NewSubTest(c.name).Run(func(t framework.TestContext) {
-							if err := t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), ingressClassConfig,
+							if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 								fmt.Sprintf(ingressConfigTemplate, "ingress", "istio-test", c.path, c.path, c.prefixPath)).
 								Apply(); err != nil {
 								t.Fatal(err)
@@ -578,21 +579,22 @@ func TestIngress(t *testing.T) {
 				})
 			}
 
+			defaultIngress := istio.DefaultIngressOrFail(t, t)
 			t.NewSubTest("status").Run(func(t framework.TestContext) {
 				if !t.Environment().(*kube.Environment).Settings().LoadBalancerSupported {
 					t.Skip("ingress status not supported without load balancer")
 				}
-				if err := t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), ingressClassConfig,
+				if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 					fmt.Sprintf(ingressConfigTemplate, "ingress", "istio-test", "/test", "/test", "/test")).
 					Apply(); err != nil {
 					t.Fatal(err)
 				}
 
-				host, _ := apps.Ingress.HTTPAddress()
+				host, _ := defaultIngress.HTTPAddress()
 				hostIsIP := net.ParseIP(host).String() != "<nil>"
 				retry.UntilSuccessOrFail(t, func() error {
 					if apiVersion == "v1beta1" {
-						ing, err := t.Clusters().Default().NetworkingV1beta1().Ingresses(apps.NS1().Namespace.Name()).Get(context.Background(), "ingress", metav1.GetOptions{})
+						ing, err := t.Clusters().Default().NetworkingV1beta1().Ingresses(apps.Namespace.Name()).Get(context.Background(), "ingress", metav1.GetOptions{})
 						if err != nil {
 							return err
 						}
@@ -608,7 +610,7 @@ func TestIngress(t *testing.T) {
 						}
 						return nil
 					}
-					ing, err := t.Clusters().Default().NetworkingV1().Ingresses(apps.NS1().Namespace.Name()).Get(context.Background(), "ingress", metav1.GetOptions{})
+					ing, err := t.Clusters().Default().NetworkingV1().Ingresses(apps.Namespace.Name()).Get(context.Background(), "ingress", metav1.GetOptions{})
 					if err != nil {
 						return err
 					}
@@ -628,7 +630,7 @@ func TestIngress(t *testing.T) {
 
 			// setup another ingress pointing to a different route; the ingress will have an ingress class that should be targeted at first
 			const updateIngressName = "update-test-ingress"
-			if err := t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), ingressClassConfig,
+			if err := t.ConfigIstio().YAML(apps.Namespace.Name(), ingressClassConfig,
 				fmt.Sprintf(ingressConfigTemplate, updateIngressName, "istio-test", "/update-test", "/update-test", "/update-test")).
 				Apply(); err != nil {
 				t.Fatal(err)
@@ -697,10 +699,10 @@ func TestIngress(t *testing.T) {
 			for _, c := range ingressUpdateCases {
 				c := c
 				updatedIngress := fmt.Sprintf(ingressConfigTemplate, updateIngressName, c.ingressClass, c.path, c.path, c.path)
-				t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), updatedIngress).ApplyOrFail(t)
+				t.ConfigIstio().YAML(apps.Namespace.Name(), updatedIngress).ApplyOrFail(t)
 				t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 					c.call.Retry.Options = []retry.Option{retry.Timeout(time.Minute)}
-					apps.Ingress.CallOrFail(t, c.call)
+					defaultIngress.CallOrFail(t, c.call)
 				})
 			}
 		})
@@ -720,7 +722,7 @@ func TestCustomGateway(t *testing.T) {
 			templateParams := map[string]string{
 				"imagePullSecret": t.Settings().Image.PullSecretNameOrFail(t),
 				"injectLabel":     injectLabel,
-				"host":            apps.NS1().A.Config().ClusterLocalFQDN(),
+				"host":            apps.A.Config().ClusterLocalFQDN(),
 				"imagePullPolicy": t.Settings().Image.PullPolicy,
 			}
 
@@ -801,7 +803,7 @@ func TestCustomGateway(t *testing.T) {
 					_, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(cs, gatewayNs.Name(), "istio=custom"))
 					return err
 				}, retry.Timeout(time.Minute*2))
-				apps.NS1().B[0].CallOrFail(t, echo.CallOptions{
+				apps.B[0].CallOrFail(t, echo.CallOptions{
 					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("custom-gateway.%s.svc.cluster.local", gatewayNs.Name()),
@@ -873,8 +875,8 @@ func TestCustomGateway(t *testing.T) {
         host: %s
         port:
           number: 80
-`, apps.NS1().A.Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
-				apps.NS1().B[0].CallOrFail(t, echo.CallOptions{
+`, apps.A.Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
+				apps.B[0].CallOrFail(t, echo.CallOptions{
 					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("custom-gateway-helm.%s.svc.cluster.local", gatewayNs.Name()),
@@ -940,8 +942,8 @@ func TestCustomGateway(t *testing.T) {
         host: %s
         port:
           number: 80
-`, apps.NS1().A.Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
-				apps.NS1().B[0].CallOrFail(t, echo.CallOptions{
+`, apps.A.Config().ClusterLocalFQDN())).Apply(resource.NoCleanup)
+				apps.B[0].CallOrFail(t, echo.CallOptions{
 					Port:    echo.Port{ServicePort: 80},
 					Scheme:  scheme.HTTP,
 					Address: fmt.Sprintf("helm-simple.%s.svc.cluster.local", gatewayNs.Name()),
diff --git a/tests/integration/pilot/istioctl_test.go b/tests/integration/pilot/istioctl_test.go
index ae02293c5a..065f82f57e 100644
--- a/tests/integration/pilot/istioctl_test.go
+++ b/tests/integration/pilot/istioctl_test.go
@@ -146,7 +146,7 @@ func TestDescribe(t *testing.T) {
 	framework.NewTest(t).Features("usability.observability.describe").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			t.ConfigIstio().File(apps.NS1().Namespace.Name(), "testdata/a.yaml").ApplyOrFail(t)
+			t.ConfigIstio().File(apps.Namespace.Name(), "testdata/a.yaml").ApplyOrFail(t)
 
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 
@@ -156,7 +156,7 @@ func TestDescribe(t *testing.T) {
 			retry.UntilSuccessOrFail(t, func() error {
 				args := []string{
 					"--namespace=dummy",
-					"x", "describe", "svc", fmt.Sprintf("%s.%s", commonDeployment.PodASvc, apps.NS1().Namespace.Name()),
+					"x", "describe", "svc", fmt.Sprintf("%s.%s", commonDeployment.ASvc, apps.Namespace.Name()),
 				}
 				output, _, err := istioCtl.Invoke(args)
 				if err != nil {
@@ -169,13 +169,13 @@ func TestDescribe(t *testing.T) {
 			}, retry.Timeout(time.Second*20))
 
 			retry.UntilSuccessOrFail(t, func() error {
-				podID, err := getPodID(apps.NS1().A[0])
+				podID, err := getPodID(apps.A[0])
 				if err != nil {
 					return fmt.Errorf("could not get Pod ID: %v", err)
 				}
 				args := []string{
 					"--namespace=dummy",
-					"x", "describe", "pod", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()),
+					"x", "describe", "pod", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()),
 				}
 				output, _, err := istioCtl.Invoke(args)
 				if err != nil {
@@ -263,7 +263,7 @@ func TestProxyConfig(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 
-			podID, err := getPodID(apps.NS1().A[0])
+			podID, err := getPodID(apps.A[0])
 			if err != nil {
 				t.Fatalf("Could not get Pod ID: %v", err)
 			}
@@ -274,7 +274,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "bootstrap", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()),
+				"pc", "bootstrap", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()),
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput := jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -282,7 +282,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "cluster", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "-o", "json",
+				"pc", "cluster", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "-o", "json",
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput = jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -290,7 +290,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "endpoint", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "-o", "json",
+				"pc", "endpoint", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "-o", "json",
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput = jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -298,7 +298,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "listener", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "-o", "json",
+				"pc", "listener", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "-o", "json",
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput = jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -306,7 +306,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "route", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "-o", "json",
+				"pc", "route", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "-o", "json",
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput = jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -314,7 +314,7 @@ func TestProxyConfig(t *testing.T) {
 
 			args = []string{
 				"--namespace=dummy",
-				"pc", "secret", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "-o", "json",
+				"pc", "secret", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "-o", "json",
 			}
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			jsonOutput = jsonUnmarshallOrFail(t, strings.Join(args, " "), output)
@@ -353,7 +353,7 @@ func TestProxyStatus(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 
-			podID, err := getPodID(apps.NS1().A[0])
+			podID, err := getPodID(apps.A[0])
 			if err != nil {
 				t.Fatalf("Could not get Pod ID: %v", err)
 			}
@@ -366,7 +366,7 @@ func TestProxyStatus(t *testing.T) {
 			output, _ = istioCtl.InvokeOrFail(t, args)
 			// Just verify pod A is known to Pilot; implicitly this verifies that
 			// the printing code printed it.
-			g.Expect(output).To(gomega.ContainSubstring(fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name())))
+			g.Expect(output).To(gomega.ContainSubstring(fmt.Sprintf("%s.%s", podID, apps.Namespace.Name())))
 
 			expectSubstrings := func(have string, wants ...string) error {
 				for _, want := range wants {
@@ -379,7 +379,7 @@ func TestProxyStatus(t *testing.T) {
 
 			retry.UntilSuccessOrFail(t, func() error {
 				args = []string{
-					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()),
+					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()),
 				}
 				output, _, err := istioCtl.Invoke(args)
 				if err != nil {
@@ -393,12 +393,12 @@ func TestProxyStatus(t *testing.T) {
 				d := t.TempDir()
 				filename := filepath.Join(d, "ps-configdump.json")
 				cs := t.Clusters().Default()
-				dump, err := cs.EnvoyDo(context.TODO(), podID, apps.NS1().Namespace.Name(), "GET", "config_dump")
+				dump, err := cs.EnvoyDo(context.TODO(), podID, apps.Namespace.Name(), "GET", "config_dump")
 				g.Expect(err).ShouldNot(gomega.HaveOccurred())
 				err = os.WriteFile(filename, dump, os.ModePerm)
 				g.Expect(err).ShouldNot(gomega.HaveOccurred())
 				args = []string{
-					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "--file", filename,
+					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "--file", filename,
 				}
 				output, _, err = istioCtl.Invoke(args)
 				if err != nil {
@@ -416,7 +416,7 @@ func TestXdsProxyStatus(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 
-			podID, err := getPodID(apps.NS1().A[0])
+			podID, err := getPodID(apps.A[0])
 			if err != nil {
 				t.Fatalf("Could not get Pod ID: %v", err)
 			}
@@ -427,7 +427,7 @@ func TestXdsProxyStatus(t *testing.T) {
 			output, _ := istioCtl.InvokeOrFail(t, args)
 			// Just verify pod A is known to Pilot; implicitly this verifies that
 			// the printing code printed it.
-			g.Expect(output).To(gomega.ContainSubstring(fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name())))
+			g.Expect(output).To(gomega.ContainSubstring(fmt.Sprintf("%s.%s", podID, apps.Namespace.Name())))
 
 			expectSubstrings := func(have string, wants ...string) error {
 				for _, want := range wants {
@@ -440,7 +440,7 @@ func TestXdsProxyStatus(t *testing.T) {
 
 			retry.UntilSuccessOrFail(t, func() error {
 				args = []string{
-					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()),
+					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()),
 				}
 				output, _, err = istioCtl.Invoke(args)
 				if err != nil {
@@ -454,12 +454,12 @@ func TestXdsProxyStatus(t *testing.T) {
 				d := t.TempDir()
 				filename := filepath.Join(d, "ps-configdump.json")
 				cs := t.Clusters().Default()
-				dump, err := cs.EnvoyDo(context.TODO(), podID, apps.NS1().Namespace.Name(), "GET", "config_dump")
+				dump, err := cs.EnvoyDo(context.TODO(), podID, apps.Namespace.Name(), "GET", "config_dump")
 				g.Expect(err).ShouldNot(gomega.HaveOccurred())
 				err = os.WriteFile(filename, dump, os.ModePerm)
 				g.Expect(err).ShouldNot(gomega.HaveOccurred())
 				args = []string{
-					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.NS1().Namespace.Name()), "--file", filename,
+					"proxy-status", fmt.Sprintf("%s.%s", podID, apps.Namespace.Name()), "--file", filename,
 				}
 				output, _, err = istioCtl.Invoke(args)
 				if err != nil {
@@ -474,14 +474,14 @@ func TestAuthZCheck(t *testing.T) {
 	framework.NewTest(t).Features("usability.observability.authz-check").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			t.ConfigIstio().File(apps.NS1().Namespace.Name(), "testdata/authz-a.yaml").ApplyOrFail(t)
+			t.ConfigIstio().File(apps.Namespace.Name(), "testdata/authz-a.yaml").ApplyOrFail(t)
 			t.ConfigIstio().File(i.Settings().SystemNamespace, "testdata/authz-b.yaml").ApplyOrFail(t)
 
 			gwPod, err := i.IngressFor(t.Clusters().Default()).PodID(0)
 			if err != nil {
 				t.Fatalf("Could not get Pod ID: %v", err)
 			}
-			appPod, err := getPodID(apps.NS1().A[0])
+			appPod, err := getPodID(apps.A[0])
 			if err != nil {
 				t.Fatalf("Could not get Pod ID: %v", err)
 			}
@@ -501,11 +501,11 @@ func TestAuthZCheck(t *testing.T) {
 				},
 				{
 					name: "workload",
-					pod:  fmt.Sprintf("%s.%s", appPod, apps.NS1().Namespace.Name()),
+					pod:  fmt.Sprintf("%s.%s", appPod, apps.Namespace.Name()),
 					wants: []*regexp.Regexp{
-						regexp.MustCompile(fmt.Sprintf(`DENY\s+deny-policy\.%s\s+2`, apps.NS1().Namespace.Name())),
+						regexp.MustCompile(fmt.Sprintf(`DENY\s+deny-policy\.%s\s+2`, apps.Namespace.Name())),
 						regexp.MustCompile(`ALLOW\s+_anonymous_match_nothing_\s+1`),
-						regexp.MustCompile(fmt.Sprintf(`ALLOW\s+allow-policy\.%s\s+1`, apps.NS1().Namespace.Name())),
+						regexp.MustCompile(fmt.Sprintf(`ALLOW\s+allow-policy\.%s\s+1`, apps.Namespace.Name())),
 					},
 				},
 			}
diff --git a/tests/integration/pilot/locality_test.go b/tests/integration/pilot/locality_test.go
index 4947724b7b..ab45f2df98 100644
--- a/tests/integration/pilot/locality_test.go
+++ b/tests/integration/pilot/locality_test.go
@@ -111,12 +111,12 @@ func TestLocality(t *testing.T) {
 		Features("traffic.locality").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			destA := apps.NS1().B[0]
-			destB := apps.NS1().C[0]
-			destC := apps.NS1().Naked[0]
+			destA := apps.B[0]
+			destB := apps.C[0]
+			destC := apps.Naked[0]
 			if !t.Settings().Skip(echo.VM) {
 				// TODO do we even need this to be a VM
-				destC = apps.NS1().VM[0]
+				destC = apps.VM[0]
 			}
 
 			cases := []struct {
@@ -210,8 +210,8 @@ func TestLocality(t *testing.T) {
 				t.NewSubTest(tt.name).Run(func(t framework.TestContext) {
 					hostname := fmt.Sprintf("%s-fake-locality.example.com", strings.ToLower(strings.ReplaceAll(tt.name, "/", "-")))
 					tt.input.Host = hostname
-					t.ConfigIstio().YAML(apps.NS1().Namespace.Name(), runTemplate(t, localityTemplate, tt.input)).ApplyOrFail(t)
-					sendTrafficOrFail(t, apps.NS1().A[0], hostname, tt.expected)
+					t.ConfigIstio().YAML(apps.Namespace.Name(), runTemplate(t, localityTemplate, tt.input)).ApplyOrFail(t)
+					sendTrafficOrFail(t, apps.A[0], hostname, tt.expected)
 				})
 			}
 		})
diff --git a/tests/integration/pilot/main_test.go b/tests/integration/pilot/main_test.go
index de7cba26da..700526c115 100644
--- a/tests/integration/pilot/main_test.go
+++ b/tests/integration/pilot/main_test.go
@@ -35,7 +35,7 @@
 	// Below are various preconfigured echo deployments. Whenever possible, tests should utilize these
 	// to avoid excessive creation/tear down of deployments. In general, a test should only deploy echo if
 	// its doing something unique to that specific test.
-	apps = deployment.Echos{}
+	apps = deployment.SingleNamespaceView{}
 )
 
 func supportsCRDv1(t resource.Context) bool {
@@ -55,7 +55,7 @@ func TestMain(m *testing.M) {
 		NewSuite(m).
 		Setup(istio.Setup(&i, nil)).
 		Setup(func(t resource.Context) error {
-			return deployment.Setup(t, &apps, deployment.Config{})
+			return deployment.SetupSingleNamespace(t, &apps)
 		}).
 		Run()
 }
diff --git a/tests/integration/pilot/mirror_test.go b/tests/integration/pilot/mirror_test.go
index 281db99e78..d011702005 100644
--- a/tests/integration/pilot/mirror_test.go
+++ b/tests/integration/pilot/mirror_test.go
@@ -102,8 +102,8 @@ func TestMirroring(t *testing.T) {
 // mesh because of the Sidecar), then we can inspect "external" logs to verify the requests were properly mirrored.
 func TestMirroringExternalService(t *testing.T) {
 	header := ""
-	if len(apps.External.Echos) > 0 {
-		header = apps.External.Echos.Config().HostHeader()
+	if len(apps.External.All) > 0 {
+		header = apps.External.All.Config().HostHeader()
 	}
 	runMirrorTest(t, mirrorTestOptions{
 		mirrorHost: header,
@@ -113,7 +113,7 @@ func TestMirroringExternalService(t *testing.T) {
 				absent:              true,
 				percentage:          100.0,
 				threshold:           0.0,
-				expectedDestination: apps.External.Echos,
+				expectedDestination: apps.External.All,
 			},
 		},
 	})
@@ -128,7 +128,7 @@ func runMirrorTest(t *testing.T, options mirrorTestOptions) {
 				t.NewSubTest(c.name).Run(func(t framework.TestContext) {
 					mirrorHost := options.mirrorHost
 					if len(mirrorHost) == 0 {
-						mirrorHost = deployment.PodCSvc
+						mirrorHost = deployment.CSvc
 					}
 					vsc := VirtualServiceMirrorConfig{
 						c.name,
@@ -138,24 +138,24 @@ func runMirrorTest(t *testing.T, options mirrorTestOptions) {
 					}
 
 					// we only apply to config clusters
-					t.ConfigIstio().EvalFile(apps.NS1().Namespace.Name(), vsc, "testdata/traffic-mirroring-template.yaml").ApplyOrFail(t)
+					t.ConfigIstio().EvalFile(apps.Namespace.Name(), vsc, "testdata/traffic-mirroring-template.yaml").ApplyOrFail(t)
 
-					for _, podA := range apps.NS1().A {
+					for _, podA := range apps.A {
 						podA := podA
 						t.NewSubTest(fmt.Sprintf("from %s", podA.Config().Cluster.StableName())).Run(func(t framework.TestContext) {
 							for _, proto := range mirrorProtocols {
 								t.NewSubTest(string(proto)).Run(func(t framework.TestContext) {
 									retry.UntilSuccessOrFail(t, func() error {
 										testID := rand.String(16)
-										if err := sendTrafficMirror(podA, apps.NS1().B, proto, testID); err != nil {
+										if err := sendTrafficMirror(podA, apps.B, proto, testID); err != nil {
 											return err
 										}
 										expected := c.expectedDestination
 										if expected == nil {
-											expected = apps.NS1().C
+											expected = apps.C
 										}
 
-										return verifyTrafficMirror(apps.NS1().B, expected, c, testID)
+										return verifyTrafficMirror(apps.B, expected, c, testID)
 									}, echo.DefaultCallRetryOptions()...)
 								})
 							}
diff --git a/tests/integration/pilot/multi_version_revision_test.go b/tests/integration/pilot/multi_version_revision_test.go
index 6407b36eb6..52d7d347a8 100644
--- a/tests/integration/pilot/multi_version_revision_test.go
+++ b/tests/integration/pilot/multi_version_revision_test.go
@@ -122,7 +122,7 @@ func TestMultiVersionRevision(t *testing.T) {
 			}
 			instances := builder.BuildOrFail(t)
 			// add an existing pod from apps to the rotation to avoid an extra deployment
-			instances = append(instances, apps.NS1().A[0])
+			instances = append(instances, apps.A[0])
 
 			testAllEchoCalls(t, instances)
 		})
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index 65c389d165..5b7cfbeadc 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -54,8 +54,8 @@ func TestClusterLocal(t *testing.T) {
 		RequireIstioVersion("1.11").
 		Run(func(t framework.TestContext) {
 			// TODO use echotest to dynamically pick 2 simple pods from apps.All
-			sources := apps.NS1().A
-			to := apps.NS1().B
+			sources := apps.A
+			to := apps.B
 
 			tests := []struct {
 				name  string
@@ -70,7 +70,7 @@ func(t framework.TestContext) {
     clusterLocal: true
   hosts:
   - "%s"
-`, apps.NS1().B.Config().ClusterLocalFQDN()))
+`, apps.B.Config().ClusterLocalFQDN()))
 					},
 				},
 				{
diff --git a/tests/integration/pilot/original_src_addr_test.go b/tests/integration/pilot/original_src_addr_test.go
index c4c37c9079..338a4bd2d8 100644
--- a/tests/integration/pilot/original_src_addr_test.go
+++ b/tests/integration/pilot/original_src_addr_test.go
@@ -35,7 +35,7 @@ func TestTproxy(t *testing.T) {
 			if t.Settings().Skip(echo.TProxy) {
 				t.Skip()
 			}
-			workloads, err := apps.NS1().A[0].Workloads()
+			workloads, err := apps.A[0].Workloads()
 			if err != nil {
 				t.Errorf("failed to get Subsets: %v", err)
 				return
@@ -45,7 +45,7 @@ func TestTproxy(t *testing.T) {
 			for _, w := range workloads {
 				srcIps = append(srcIps, w.Address())
 			}
-			checkOriginalSrcIP(t, apps.NS1().A[0], apps.NS1().Tproxy[0], srcIps)
+			checkOriginalSrcIP(t, apps.A[0], apps.Tproxy[0], srcIps)
 		})
 }
 
diff --git a/tests/integration/pilot/piggyback_test.go b/tests/integration/pilot/piggyback_test.go
index 2818a7f968..a7c757ca56 100644
--- a/tests/integration/pilot/piggyback_test.go
+++ b/tests/integration/pilot/piggyback_test.go
@@ -34,8 +34,8 @@ func TestPiggyback(t *testing.T) {
 		RequireIstioVersion("1.10.0").
 		Run(func(t framework.TestContext) {
 			out, _, err := t.Clusters()[0].PodExec(
-				apps.NS1().A[0].WorkloadsOrFail(t)[0].PodName(),
-				apps.NS1().A.Config().Namespace.Name(),
+				apps.A[0].WorkloadsOrFail(t)[0].PodName(),
+				apps.A.Config().Namespace.Name(),
 				"istio-proxy",
 				"pilot-agent request --debug-port 15004 GET /debug/syncz")
 			if err != nil {
diff --git a/tests/integration/pilot/revisioned_upgrade_test.go b/tests/integration/pilot/revisioned_upgrade_test.go
index 261bed4ac7..7814ed8437 100644
--- a/tests/integration/pilot/revisioned_upgrade_test.go
+++ b/tests/integration/pilot/revisioned_upgrade_test.go
@@ -101,9 +101,9 @@ func testUpgradeFromVersion(t framework.TestContext, fromVersion string) {
 
 	// Create a traffic generator between A and B.
 	g := traffic.NewGenerator(t, traffic.Config{
-		Source: apps.NS1().A[0],
+		Source: apps.A[0],
 		Options: echo.CallOptions{
-			To: apps.NS1().B,
+			To: apps.B,
 			Port: echo.Port{
 				Name: "http",
 			},
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 3d75253a97..bf4a033eb6 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -68,7 +68,7 @@ func TestVmOSPost(t *testing.T) {
 			for _, image := range images {
 				b = b.WithConfig(echo.Config{
 					Service:    "vm-" + strings.ReplaceAll(image, "_", "-"),
-					Namespace:  apps.NS1().Namespace,
+					Namespace:  apps.Namespace,
 					Ports:      ports.All(),
 					DeployAsVM: true,
 					VMDistro:   image,
@@ -81,7 +81,7 @@ func TestVmOSPost(t *testing.T) {
 				i, image := i, image
 				t.NewSubTest(image).RunParallel(func(t framework.TestContext) {
 					for _, tt := range common.VMTestCases(echo.Instances{instances[i]}, &apps) {
-						tt.Run(t, apps.NS1().Namespace.Name())
+						tt.Run(t, apps.Namespace.Name())
 					}
 				})
 			}
@@ -99,12 +99,12 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 				t.Skip()
 			}
 			scaleDeploymentOrFail(t, "istiod", i.Settings().SystemNamespace, 2)
-			client := match.Cluster(t.Clusters().Default()).FirstOrFail(t, apps.NS1().A)
+			client := match.Cluster(t.Clusters().Default()).FirstOrFail(t, apps.A)
 			// TODO test multi-network (must be shared control plane but on different networks)
 			var autoVM echo.Instance
 			_ = deployment.New(t).
 				With(&autoVM, echo.Config{
-					Namespace:      apps.NS1().Namespace,
+					Namespace:      apps.Namespace,
 					Service:        "auto-vm",
 					Ports:          ports.All(),
 					DeployAsVM:     true,
-- 
2.35.3

