From e5380bdf647ae7d5bc6c3e31d4b4e09b00c7ad96 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 26 May 2022 15:35:49 -0700
Subject: [TF] Refactoring authz tests (#37914)

This is a complete rewrite of the authz tests to use a common echo deployment and the echotest framework.

The new tests deploy smaller configs and test more combinations of deployments and ports/protocols.
---
 .../security/authorization_test.go            | 1645 ---------------
 .../integration/security/authz/authz_test.go  | 1800 +++++++++++++++++
 tests/integration/security/authz/main_test.go |   56 +
 .../v1beta1/allow-namespace.yaml.tmpl         |   32 +
 .../v1beta1/allow-principal.yaml.tmpl         |   32 +
 .../testdata/v1beta1/conditions.yaml.tmpl     |  178 ++
 .../v1beta1/custom-provider.yaml.tmpl         |   25 +
 .../testdata/v1beta1/deny-global.yaml.tmpl    |   21 +
 .../testdata/v1beta1/deny-namespace.yaml.tmpl |   33 +
 .../testdata/v1beta1/deny-principal.yaml.tmpl |   33 +
 .../testdata/v1beta1/egress-gateway.yaml.tmpl |  178 ++
 .../v1beta1/ingress-gateway.yaml.tmpl         |   86 +
 .../testdata/v1beta1/jwt.yaml.tmpl}           |    7 +-
 .../authz/testdata/v1beta1/mtls.yaml.tmpl     |   20 +
 .../authz/testdata/v1beta1/not-host.yaml.tmpl |   45 +
 .../testdata/v1beta1/not-method.yaml.tmpl     |   13 +
 .../testdata/v1beta1/not-namespace.yaml.tmpl  |   13 +
 .../authz/testdata/v1beta1/not-port.yaml.tmpl |   13 +
 .../v1beta1/path-normalization.yaml.tmpl}     |   10 +-
 .../v1beta1/path-precedence.yaml.tmpl         |   32 +
 .../testdata/v1beta1/plaintext.yaml.tmpl      |   57 +
 .../testdata/v1beta1/workload-bad.yaml.tmpl   |   15 +
 .../testdata/v1beta1/workload-ns.yaml.tmpl    |   11 +
 .../v1beta1/workload-system-ns.yaml.tmpl      |   15 +
 .../authz/testdata/v1beta1/workload.yaml.tmpl |   14 +
 tests/integration/security/jwt_test.go        |    3 +-
 .../authz/v1beta1-audit-allow.yaml.tmpl       |   31 -
 .../authz/v1beta1-audit-deny.yaml.tmpl        |   31 -
 .../testdata/authz/v1beta1-audit.yaml.tmpl    |   78 -
 .../authz/v1beta1-conditions.yaml.tmpl        |  329 ---
 .../testdata/authz/v1beta1-custom.yaml.tmpl   |  158 --
 .../authz/v1beta1-deny-ns-root.yaml.tmpl      |   14 -
 .../testdata/authz/v1beta1-deny.yaml.tmpl     |   90 -
 .../authz/v1beta1-egress-gateway.yaml.tmpl    |  164 --
 .../testdata/authz/v1beta1-grpc.yaml.tmpl     |   60 -
 .../authz/v1beta1-ingress-gateway.yaml.tmpl   |   94 -
 .../testdata/authz/v1beta1-mtls.yaml.tmpl     |   57 -
 .../authz/v1beta1-negative-match.yaml.tmpl    |  194 --
 .../testdata/authz/v1beta1-path.yaml.tmpl     |   19 -
 .../testdata/authz/v1beta1-tcp.yaml.tmpl      |   89 -
 .../authz/v1beta1-workload-ns-root.yaml.tmpl  |   16 -
 .../authz/v1beta1-workload-ns1.yaml.tmpl      |   65 -
 .../authz/v1beta1-workload-ns2.yaml.tmpl      |   30 -
 43 files changed, 2730 insertions(+), 3176 deletions(-)
 delete mode 100644 tests/integration/security/authorization_test.go
 create mode 100644 tests/integration/security/authz/authz_test.go
 create mode 100644 tests/integration/security/authz/main_test.go
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/allow-namespace.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/allow-principal.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/conditions.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/custom-provider.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/deny-global.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/deny-namespace.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/deny-principal.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/egress-gateway.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/ingress-gateway.yaml.tmpl
 rename tests/integration/security/{testdata/authz/v1beta1-jwt.yaml.tmpl => authz/testdata/v1beta1/jwt.yaml.tmpl} (92%)
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/mtls.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/not-host.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/not-method.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/not-namespace.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/not-port.yaml.tmpl
 rename tests/integration/security/{testdata/authz/v1beta1-audit-default.yaml.tmpl => authz/testdata/v1beta1/path-normalization.yaml.tmpl} (53%)
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/path-precedence.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/plaintext.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/workload-bad.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/workload-ns.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/workload-system-ns.yaml.tmpl
 create mode 100644 tests/integration/security/authz/testdata/v1beta1/workload.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-audit-allow.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-audit-deny.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-audit.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-custom.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-deny-ns-root.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-deny.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-egress-gateway.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-grpc.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-ingress-gateway.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-mtls.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-negative-match.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-path.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-tcp.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-workload-ns-root.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-workload-ns1.yaml.tmpl
 delete mode 100644 tests/integration/security/testdata/authz/v1beta1-workload-ns2.yaml.tmpl

diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
deleted file mode 100644
index cba447dc44..0000000000
--- a/tests/integration/security/authorization_test.go
+++ /dev/null
@@ -1,1645 +0,0 @@
-//go:build integ
-// +build integ
-
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package security
-
-import (
-	"fmt"
-	"net/http"
-	"strings"
-	"testing"
-	"time"
-
-	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/http/headers"
-	echoClient "istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/common/scheme"
-	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/authz"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/check"
-	"istio.io/istio/pkg/test/framework/components/echo/deployment"
-	"istio.io/istio/pkg/test/framework/components/echo/match"
-	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/label"
-	"istio.io/istio/pkg/test/framework/resource/config/apply"
-	"istio.io/istio/tests/common/jwt"
-	"istio.io/istio/tests/integration/security/util"
-	"istio.io/istio/tests/integration/security/util/scheck"
-)
-
-func newRootNS(ctx framework.TestContext) namespace.Instance {
-	return istio.ClaimSystemNamespaceOrFail(ctx, ctx)
-}
-
-// TestAuthorization_mTLS tests v1beta1 authorization with mTLS.
-func TestAuthorization_mTLS(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.mtls-local").
-		Run(func(t framework.TestContext) {
-			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			for _, to := range []echo.Instances{b, vm} {
-				to := to
-				t.ConfigIstio().EvalFile(apps.Namespace1.Name(), map[string]string{
-					"Namespace":  apps.Namespace1.Name(),
-					"Namespace2": apps.Namespace2.Name(),
-					"dst":        to.Config().Service,
-				}, "testdata/authz/v1beta1-mtls.yaml.tmpl").ApplyOrFail(t, apply.Wait)
-				for _, cluster := range t.Clusters() {
-					a := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
-					c := match.And(match.Cluster(cluster), match.Namespace(apps.Namespace2)).GetMatches(apps.C)
-					if len(a) == 0 || len(c) == 0 {
-						continue
-					}
-
-					t.NewSubTestf("From %s", cluster.StableName()).Run(func(t framework.TestContext) {
-						newTestCase := func(from echo.Instance, path string, expectAllowed bool) func(t framework.TestContext) {
-							return func(t framework.TestContext) {
-								opts := echo.CallOptions{
-									To: to,
-									Port: echo.Port{
-										Name: "http",
-									},
-									HTTP: echo.HTTP{
-										Path: path,
-									},
-								}
-								if expectAllowed {
-									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-								} else {
-									opts.Check = check.Forbidden(protocol.HTTP)
-								}
-
-								name := newRbacTestName("", expectAllowed, from, &opts)
-								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-									name.SkipIfNecessary(t)
-									from.CallOrFail(t, opts)
-								})
-							}
-						}
-						// a and c send requests to dst
-						cases := []func(testContext framework.TestContext){
-							newTestCase(a[0], "/principal-a", true),
-							newTestCase(a[0], "/namespace-2", false),
-							newTestCase(c[0], "/principal-a", false),
-							newTestCase(c[0], "/namespace-2", true),
-						}
-						for _, c := range cases {
-							c(t)
-						}
-					})
-				}
-			}
-		})
-}
-
-// TestAuthorization_JWT tests v1beta1 authorization with JWT token claims.
-func TestAuthorization_JWT(t *testing.T) {
-	framework.NewTest(t).
-		Label(label.IPv4). // https://github.com/istio/istio/issues/35835
-		Features("security.authorization.jwt-token").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			b := match.Namespace(ns).GetMatches(apps.B)
-			c := match.Namespace(ns).GetMatches(apps.C)
-			vm := match.Namespace(ns).GetMatches(apps.VM)
-			for _, dst := range []echo.Instances{b, vm} {
-				args := map[string]string{
-					"Namespace":  apps.Namespace1.Name(),
-					"Namespace2": apps.Namespace2.Name(),
-					"dst":        dst[0].Config().Service,
-				}
-				t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-jwt.yaml.tmpl").
-					ApplyOrFail(t, apply.Wait)
-				for _, srcCluster := range t.Clusters() {
-					a := match.And(match.Cluster(srcCluster), match.Namespace(ns)).GetMatches(apps.A)
-					if len(a) == 0 {
-						continue
-					}
-
-					t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-						newTestCase := func(from echo.Instance, to echo.Target, namePrefix, jwt, path string, expectAllowed bool) func(t framework.TestContext) {
-							return func(t framework.TestContext) {
-								opts := echo.CallOptions{
-									To: to,
-									Port: echo.Port{
-										Name: "http",
-									},
-									HTTP: echo.HTTP{
-										Path:    path,
-										Headers: headers.New().WithAuthz(jwt).Build(),
-									},
-								}
-								if expectAllowed {
-									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-								} else {
-									opts.Check = check.Forbidden(protocol.HTTP)
-								}
-
-								name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
-								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-									name.SkipIfNecessary(t)
-									from.CallOrFail(t, opts)
-								})
-							}
-						}
-						cases := []func(testContext framework.TestContext){
-							newTestCase(a[0], dst, "[NoJWT]", "", "/token1", false),
-							newTestCase(a[0], dst, "[NoJWT]", "", "/token2", false),
-							newTestCase(a[0], dst, "[Token3]", jwt.TokenIssuer1, "/token3", false),
-							newTestCase(a[0], dst, "[Token3]", jwt.TokenIssuer2, "/token3", true),
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/token1", true),
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/token2", false),
-							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/token1", false),
-							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/token2", true),
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/tokenAny", true),
-							newTestCase(a[0], dst, "[Token2]", jwt.TokenIssuer2, "/tokenAny", true),
-							newTestCase(a[0], dst, "[PermissionToken1]", jwt.TokenIssuer1, "/permission", false),
-							newTestCase(a[0], dst, "[PermissionToken2]", jwt.TokenIssuer2, "/permission", false),
-							newTestCase(a[0], dst, "[PermissionTokenWithSpaceDelimitedScope]", jwt.TokenIssuer2WithSpaceDelimitedScope, "/permission", true),
-							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key1", true),
-							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key1", false),
-							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-key2", false),
-							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-key2", true),
-							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-2-key1", true),
-							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-2-key1", false),
-							newTestCase(a[0], dst, "[NestedToken1]", jwt.TokenIssuer1WithNestedClaims1, "/nested-non-exist", false),
-							newTestCase(a[0], dst, "[NestedToken2]", jwt.TokenIssuer1WithNestedClaims2, "/nested-non-exist", false),
-							newTestCase(a[0], dst, "[NoJWT]", "", "/tokenAny", false),
-							newTestCase(a[0], c, "[NoJWT]", "", "/somePath", true),
-
-							// Test condition "request.auth.principal" on path "/valid-jwt".
-							newTestCase(a[0], dst, "[NoJWT]", "", "/valid-jwt", false),
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/valid-jwt", true),
-							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/valid-jwt", true),
-							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/valid-jwt", true),
-
-							// Test condition "request.auth.presenter" on suffix "/presenter".
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/request/presenter", false),
-							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1, "/request/presenter", false),
-							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter-x", false),
-							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/presenter", true),
-
-							// Test condition "request.auth.audiences" on suffix "/audiences".
-							newTestCase(a[0], dst, "[Token1]", jwt.TokenIssuer1, "/request/audiences", false),
-							newTestCase(a[0], dst, "[Token1WithAzp]", jwt.TokenIssuer1WithAzp, "/request/audiences", false),
-							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences-x", false),
-							newTestCase(a[0], dst, "[Token1WithAud]", jwt.TokenIssuer1WithAud, "/request/audiences", true),
-						}
-						for _, c := range cases {
-							c(t)
-						}
-					})
-				}
-			}
-		})
-}
-
-// TestAuthorization_WorkloadSelector tests the workload selector for the v1beta1 policy in two namespaces.
-func TestAuthorization_WorkloadSelector(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.workload-selector").
-		Run(func(t framework.TestContext) {
-			bInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			vmInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			cInNS1 := match.Namespace(apps.Namespace1).GetMatches(apps.C)
-			cInNS2 := match.Namespace(apps.Namespace2).GetMatches(apps.C)
-			ns1 := apps.Namespace1
-			ns2 := apps.Namespace2
-			rootns := newRootNS(t)
-
-			newTestCase := func(from echo.Instance, to echo.Target, namePrefix, path string,
-				expectAllowed bool,
-			) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					opts := echo.CallOptions{
-						To: to,
-						Port: echo.Port{
-							Name: "http",
-						},
-						HTTP: echo.HTTP{
-							Path: path,
-						},
-					}
-					if expectAllowed {
-						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-					} else {
-						opts.Check = check.Forbidden(protocol.HTTP)
-					}
-
-					name := newRbacTestName(namePrefix, expectAllowed, from, &opts)
-					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-						name.SkipIfNecessary(t)
-						from.CallOrFail(t, opts)
-					})
-				}
-			}
-
-			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
-				if len(a) == 0 {
-					continue
-				}
-
-				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-					applyPolicy := func(filename string, ns namespace.Instance) {
-						t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
-							"Namespace1":    ns1.Name(),
-							"Namespace2":    ns2.Name(),
-							"RootNamespace": rootns.Name(),
-							"b":             util.BSvc,
-							"c":             util.CSvc,
-						}, filename).ApplyOrFail(t, apply.Wait)
-					}
-					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
-					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
-					applyPolicy("testdata/authz/v1beta1-workload-ns-root.yaml.tmpl", rootns)
-
-					cases := []func(test framework.TestContext){
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-b", true),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-vm", false),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-c", false),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-x", false),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns1-all", true),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns2-c", false),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns2-all", false),
-						newTestCase(a[0], bInNS1, "[bInNS1]", "/policy-ns-root-c", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-b", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-vm", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-c", true),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-x", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns1-all", true),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns2-c", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns2-all", false),
-						newTestCase(a[0], cInNS1, "[cInNS1]", "/policy-ns-root-c", true),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-b", false),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-vm", false),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-c", false),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-x", false),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns1-all", false),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns2-c", true),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns2-all", true),
-						newTestCase(a[0], cInNS2, "[cInNS2]", "/policy-ns-root-c", true),
-					}
-					for _, c := range cases {
-						c(t)
-					}
-				})
-
-				// TODO(JimmyCYJ): Support multiple VMs in different namespaces for workload selector test and set c to service on VM.
-				t.NewSubTestf("VM From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-					applyPolicy := func(filename string, ns namespace.Instance) {
-						t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
-							"Namespace1":    ns1.Name(),
-							"Namespace2":    ns2.Name(),
-							"RootNamespace": rootns.Name(),
-							"b":             util.VMSvc, // This is the only difference from standard args.
-							"c":             util.CSvc,
-						}, filename).ApplyOrFail(t, apply.Wait)
-					}
-					applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
-					applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
-					applyPolicy("testdata/authz/v1beta1-workload-ns-root.yaml.tmpl", rootns)
-
-					cases := []func(test framework.TestContext){
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-b", false),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-vm", true),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-c", false),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-x", false),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns1-all", true),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns2-b", false),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns2-all", false),
-						newTestCase(a[0], vmInNS1, "[vmInNS1]", "/policy-ns-root-c", false),
-					}
-					for _, c := range cases {
-						c(t)
-					}
-				})
-			}
-		})
-}
-
-// TestAuthorization_Deny tests the authorization policy with action "DENY".
-func TestAuthorization_Deny(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.deny-action").
-		Run(func(t framework.TestContext) {
-			if t.Clusters().IsMulticluster() {
-				t.Skip("https://github.com/istio/istio/issues/37307")
-			}
-			ns := apps.Namespace1
-			rootns := newRootNS(t)
-			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-
-			applyPolicy := func(filename string, ns namespace.Instance) {
-				t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
-					"Namespace":     ns.Name(),
-					"RootNamespace": rootns.Name(),
-					"b":             b[0].Config().Service,
-					"c":             c[0].Config().Service,
-					"vm":            vm[0].Config().Service,
-				}, filename).ApplyOrFail(t, apply.Wait)
-			}
-			applyPolicy("testdata/authz/v1beta1-deny.yaml.tmpl", ns)
-			applyPolicy("testdata/authz/v1beta1-deny-ns-root.yaml.tmpl", rootns)
-			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
-				if len(a) == 0 {
-					continue
-				}
-
-				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-					newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-						return func(t framework.TestContext) {
-							opts := echo.CallOptions{
-								To: to,
-								Port: echo.Port{
-									Name: "http",
-								},
-								HTTP: echo.HTTP{
-									Path: path,
-								},
-							}
-							if expectAllowed {
-								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-							} else {
-								opts.Check = check.Forbidden(protocol.HTTP)
-							}
-
-							name := newRbacTestName("", expectAllowed, from, &opts)
-							t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-								name.SkipIfNecessary(t)
-								from.CallOrFail(t, opts)
-							})
-						}
-					}
-					cases := []func(t framework.TestContext){
-						newTestCase(a[0], b, "/deny", false),
-						newTestCase(a[0], b, "/deny?param=value", false),
-						newTestCase(a[0], b, "/global-deny", false),
-						newTestCase(a[0], b, "/global-deny?param=value", false),
-						newTestCase(a[0], b, "/other", true),
-						newTestCase(a[0], b, "/other?param=value", true),
-						newTestCase(a[0], b, "/allow", true),
-						newTestCase(a[0], b, "/allow?param=value", true),
-						newTestCase(a[0], c, "/allow/admin", false),
-						newTestCase(a[0], c, "/allow/admin?param=value", false),
-						newTestCase(a[0], c, "/global-deny", false),
-						newTestCase(a[0], c, "/global-deny?param=value", false),
-						newTestCase(a[0], c, "/other", false),
-						newTestCase(a[0], c, "/other?param=value", false),
-						newTestCase(a[0], c, "/allow", true),
-						newTestCase(a[0], c, "/allow?param=value", true),
-
-						// TODO(JimmyCYJ): support multiple VMs and test deny policies on multiple VMs.
-						newTestCase(a[0], vm, "/allow/admin", false),
-						newTestCase(a[0], vm, "/allow/admin?param=value", false),
-						newTestCase(a[0], vm, "/global-deny", false),
-						newTestCase(a[0], vm, "/global-deny?param=value", false),
-						newTestCase(a[0], vm, "/other", false),
-						newTestCase(a[0], vm, "/other?param=value", false),
-						newTestCase(a[0], vm, "/allow", true),
-						newTestCase(a[0], vm, "/allow?param=value", true),
-					}
-
-					for _, c := range cases {
-						c(t)
-					}
-				})
-			}
-		})
-}
-
-// TestAuthorization_NegativeMatch tests the authorization policy with negative match.
-func TestAuthorization_NegativeMatch(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.negative-match").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			ns2 := apps.Namespace2
-			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
-			d := match.Namespace(apps.Namespace1).GetMatches(apps.D)
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			t.ConfigIstio().EvalFile("", map[string]string{
-				"Namespace":  ns.Name(),
-				"Namespace2": ns2.Name(),
-				"b":          b[0].Config().Service,
-				"c":          c[0].Config().Service,
-				"d":          d[0].Config().Service,
-				"vm":         vm[0].Config().Service,
-			}, "testdata/authz/v1beta1-negative-match.yaml.tmpl").ApplyOrFail(t)
-
-			type request struct {
-				method string // default value is GET if not specified
-				host   string // only set if not empty
-				port   string // default value is http if not specified
-			}
-			reqParam := request{method: "GET", port: "http"}
-			reqNotMethodParam := request{method: "PUT", port: "http"}
-			reqNotPortParam := request{method: "GET", port: "http-8091"}
-			reqNotHostParam := request{method: "GET", port: "http", host: "deny.com"}
-			for _, srcCluster := range t.Clusters() {
-				a := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace1)).GetMatches(apps.A)
-				bInNS2 := match.And(match.Cluster(srcCluster), match.Namespace(apps.Namespace2)).GetMatches(apps.B)
-				if len(a) == 0 || len(bInNS2) == 0 {
-					continue
-				}
-
-				t.NewSubTestf("From %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-					newTestCaseWithRequest := func(from echo.Instance, to echo.Target, path string, expectAllowed bool, request request) func(t framework.TestContext) {
-						return func(t framework.TestContext) {
-							opts := echo.CallOptions{
-								To: to,
-								Port: echo.Port{
-									Name: request.port,
-								},
-								HTTP: echo.HTTP{
-									Path:    path,
-									Method:  request.method,
-									Headers: headers.New().WithHost(request.host).Build(),
-								},
-							}
-							if expectAllowed {
-								opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-							} else {
-								opts.Check = check.Forbidden(protocol.HTTP)
-							}
-
-							name := newRbacTestName("", expectAllowed, from, &opts)
-							t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-								name.SkipIfNecessary(t)
-								from.CallOrFail(t, opts)
-							})
-						}
-					}
-					newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-						return newTestCaseWithRequest(from, to, path, expectAllowed, reqParam)
-					}
-					// a, b, c and d are in the same namespace and another b(bInNs2) is in a different namespace.
-					// a connects to b, c and d in ns1 with mTLS.
-					// bInNs2 connects to b and c with mTLS, to d with plain-text.
-					cases := []func(testContext framework.TestContext){
-						// Test the policy with overlapped `paths`, `not_paths` and `not_methods` on b.
-						// a and bInNs2 should have the same results:
-						// - path with prefix `/prefix` should be denied explicitly.
-						// - path `/prefix/allowlist` should be excluded from the deny.
-						// - path `/allow` should be allowed implicitly.
-						newTestCaseWithRequest(a[0], b, "/", false, reqNotMethodParam),
-						newTestCase(a[0], b, "/prefix", false),
-						newTestCase(a[0], b, "/prefix/other", false),
-						newTestCase(a[0], b, "/prefix/allowlist", true),
-						newTestCase(a[0], b, "/allow", true),
-						newTestCase(bInNS2[0], b, "/prefix", false),
-						newTestCase(bInNS2[0], b, "/prefix/other", false),
-						newTestCase(bInNS2[0], b, "/prefix/allowlist", true),
-						newTestCase(bInNS2[0], b, "/allow", true),
-
-						// Test the policy that denies other namespace on c.
-						// a should be allowed because it's from the same namespace.
-						// any request to path deny.com should be denied
-						// bInNs2 should be denied because it's from a different namespace.
-						newTestCase(a[0], c, "/", true),
-						newTestCaseWithRequest(a[0], c, "/", false, reqNotHostParam),
-						newTestCase(bInNS2[0], c, "/", false),
-
-						// Test the policy that denies plain-text traffic on d.
-						// a should be allowed because it's using mTLS.
-						// any request to port 8091 should be denied
-						// bInNs2 should be denied because it's using plain-text.
-						newTestCase(a[0], d, "/", true),
-						newTestCaseWithRequest(a[0], d, "/", false, reqNotPortParam),
-						newTestCase(bInNS2[0], d, "/", false),
-
-						// Test the policy with overlapped `paths` and `not_paths` on vm.
-						// a and bInNs2 should have the same results:
-						// - path with prefix `/prefix` should be denied explicitly.
-						// - path `/prefix/allowlist` should be excluded from the deny.
-						// - path `/allow` should be allowed implicitly.
-						// TODO(JimmyCYJ): support multiple VMs and test negative match on multiple VMs.
-						newTestCase(a[0], vm, "/prefix", false),
-						newTestCase(a[0], vm, "/prefix/other", false),
-						newTestCase(a[0], vm, "/prefix/allowlist", true),
-						newTestCase(a[0], vm, "/allow", true),
-						newTestCase(bInNS2[0], vm, "/prefix", false),
-						newTestCase(bInNS2[0], vm, "/prefix/other", false),
-						newTestCase(bInNS2[0], vm, "/prefix/allowlist", true),
-						newTestCase(bInNS2[0], vm, "/allow", true),
-					}
-
-					for _, c := range cases {
-						c(t)
-					}
-				})
-			}
-		})
-}
-
-// TestAuthorization_IngressGateway tests the authorization policy on ingress gateway.
-func TestAuthorization_IngressGateway(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.ingress-gateway").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			rootns := newRootNS(t)
-			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			// Gateways on VMs are not supported yet. This test verifies that security
-			// policies at gateways are useful for managing accessibility to services
-			// running on a VM.
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			for _, dst := range []echo.Instances{b, vm} {
-				t.NewSubTestf("to %s/", dst[0].Config().Service).Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile("", map[string]string{
-						"Namespace":     ns.Name(),
-						"RootNamespace": rootns.Name(),
-						"dst":           dst[0].Config().Service,
-					}, "testdata/authz/v1beta1-ingress-gateway.yaml.tmpl").ApplyOrFail(t)
-
-					ingr := ist.IngressFor(t.Clusters().Default())
-
-					cases := []struct {
-						Name     string
-						Host     string
-						Path     string
-						IP       string
-						WantCode int
-					}{
-						{
-							Name:     "case-insensitive-deny deny.company.com",
-							Host:     "deny.company.com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny DENY.COMPANY.COM",
-							Host:     "DENY.COMPANY.COM",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny Deny.Company.Com",
-							Host:     "Deny.Company.Com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny deny.suffix.company.com",
-							Host:     "deny.suffix.company.com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny DENY.SUFFIX.COMPANY.COM",
-							Host:     "DENY.SUFFIX.COMPANY.COM",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny Deny.Suffix.Company.Com",
-							Host:     "Deny.Suffix.Company.Com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny prefix.company.com",
-							Host:     "prefix.company.com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny PREFIX.COMPANY.COM",
-							Host:     "PREFIX.COMPANY.COM",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "case-insensitive-deny Prefix.Company.Com",
-							Host:     "Prefix.Company.Com",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "allow www.company.com",
-							Host:     "www.company.com",
-							Path:     "/",
-							IP:       "172.16.0.1",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "deny www.company.com/private",
-							Host:     "www.company.com",
-							Path:     "/private",
-							IP:       "172.16.0.1",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "allow www.company.com/public",
-							Host:     "www.company.com",
-							Path:     "/public",
-							IP:       "172.16.0.1",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "deny internal.company.com",
-							Host:     "internal.company.com",
-							Path:     "/",
-							IP:       "172.16.0.1",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "deny internal.company.com/private",
-							Host:     "internal.company.com",
-							Path:     "/private",
-							IP:       "172.16.0.1",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "deny 172.17.72.46",
-							Host:     "remoteipblocks.company.com",
-							Path:     "/",
-							IP:       "172.17.72.46",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "deny 192.168.5.233",
-							Host:     "remoteipblocks.company.com",
-							Path:     "/",
-							IP:       "192.168.5.233",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "allow 10.4.5.6",
-							Host:     "remoteipblocks.company.com",
-							Path:     "/",
-							IP:       "10.4.5.6",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "deny 10.2.3.4",
-							Host:     "notremoteipblocks.company.com",
-							Path:     "/",
-							IP:       "10.2.3.4",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "allow 172.23.242.188",
-							Host:     "notremoteipblocks.company.com",
-							Path:     "/",
-							IP:       "172.23.242.188",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "deny 10.242.5.7",
-							Host:     "remoteipattr.company.com",
-							Path:     "/",
-							IP:       "10.242.5.7",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "deny 10.124.99.10",
-							Host:     "remoteipattr.company.com",
-							Path:     "/",
-							IP:       "10.124.99.10",
-							WantCode: http.StatusForbidden,
-						},
-						{
-							Name:     "allow 10.4.5.6",
-							Host:     "remoteipattr.company.com",
-							Path:     "/",
-							IP:       "10.4.5.6",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "allow 172.19.19.19",
-							Host:     "ipblocks.company.com",
-							Path:     "/",
-							IP:       "172.19.19.19",
-							WantCode: http.StatusOK,
-						},
-						{
-							Name:     "deny 172.19.19.20",
-							Host:     "notipblocks.company.com",
-							Path:     "/",
-							IP:       "172.19.19.20",
-							WantCode: http.StatusForbidden,
-						},
-					}
-
-					for _, tc := range cases {
-						t.NewSubTest(tc.Name).Run(func(t framework.TestContext) {
-							opts := echo.CallOptions{
-								Port: echo.Port{
-									Protocol: protocol.HTTP,
-								},
-								HTTP: echo.HTTP{
-									Path:    tc.Path,
-									Headers: headers.New().WithHost(tc.Host).WithXForwardedFor(tc.IP).Build(),
-								},
-								Check: check.Status(tc.WantCode),
-							}
-							ingr.CallOrFail(t, opts)
-						})
-					}
-				})
-			}
-		})
-}
-
-// TestAuthorization_EgressGateway tests v1beta1 authorization on egress gateway.
-func TestAuthorization_EgressGateway(t *testing.T) {
-	framework.NewTest(t).
-		Label(label.IPv4). // https://github.com/istio/istio/issues/35835
-		Features("security.authorization.egress-gateway").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			rootns := newRootNS(t)
-			a := match.Namespace(apps.Namespace1).GetMatches(apps.A)
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
-			// Gateways on VMs are not supported yet. This test verifies that security
-			// policies at gateways are useful for managing accessibility to external
-			// services running on a VM.
-			for _, a := range []echo.Instances{a, vm} {
-				t.NewSubTestf("to %s", a[0].Config().Service).Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile("", map[string]string{
-						"Namespace":     ns.Name(),
-						"RootNamespace": rootns.Name(),
-						"a":             a[0].Config().Service,
-					}, "testdata/authz/v1beta1-egress-gateway.yaml.tmpl").ApplyOrFail(t)
-
-					cases := []struct {
-						name  string
-						path  string
-						code  int
-						body  string
-						host  string
-						from  echo.Instances
-						token string
-					}{
-						{
-							name: "allow path to company.com",
-							path: "/allow",
-							code: http.StatusOK,
-							body: "handled-by-egress-gateway",
-							host: "www.company.com",
-							from: a,
-						},
-						{
-							name: "deny path to company.com",
-							path: "/deny",
-							code: http.StatusForbidden,
-							body: "RBAC: access denied",
-							host: "www.company.com",
-							from: a,
-						},
-						{
-							name: "allow service account a to a-only.com over mTLS",
-							path: "/",
-							code: http.StatusOK,
-							body: "handled-by-egress-gateway",
-							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
-							from: a,
-						},
-						{
-							name: "deny service account b to a-only.com over mTLS",
-							path: "/",
-							code: http.StatusForbidden,
-							body: "RBAC: access denied",
-							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
-							from: c,
-						},
-						{
-							name:  "allow a with JWT to jwt-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusOK,
-							body:  "handled-by-egress-gateway",
-							host:  "jwt-only.com",
-							from:  a,
-							token: jwt.TokenIssuer1,
-						},
-						{
-							name:  "allow b with JWT to jwt-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusOK,
-							body:  "handled-by-egress-gateway",
-							host:  "jwt-only.com",
-							from:  c,
-							token: jwt.TokenIssuer1,
-						},
-						{
-							name:  "deny b with wrong JWT to jwt-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusForbidden,
-							body:  "RBAC: access denied",
-							host:  "jwt-only.com",
-							from:  c,
-							token: jwt.TokenIssuer2,
-						},
-						{
-							name:  "allow service account a with JWT to jwt-and-a-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusOK,
-							body:  "handled-by-egress-gateway",
-							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  a,
-							token: jwt.TokenIssuer1,
-						},
-						{
-							name:  "deny service account c with JWT to jwt-and-a-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusForbidden,
-							body:  "RBAC: access denied",
-							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  c,
-							token: jwt.TokenIssuer1,
-						},
-						{
-							name:  "deny service account a with wrong JWT to jwt-and-a-only.com over mTLS",
-							path:  "/",
-							code:  http.StatusForbidden,
-							body:  "RBAC: access denied",
-							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
-							from:  a,
-							token: jwt.TokenIssuer2,
-						},
-					}
-
-					for _, tc := range cases {
-						t.NewSubTest(tc.name).Run(func(t framework.TestContext) {
-							tc.from[0].CallOrFail(t, echo.CallOptions{
-								Port: echo.Port{
-									Protocol:    protocol.HTTP,
-									ServicePort: 80,
-								},
-								Timeout: time.Second,
-								// Use a fake IP to make sure the request is handled by our test.
-								Address: "10.4.4.4",
-								HTTP: echo.HTTP{
-									Headers: headers.New().WithHost(tc.host).WithAuthz(tc.token).Build(),
-									Path:    tc.path,
-								},
-								Check: check.And(
-									check.NoError(),
-									check.Status(tc.code),
-									check.BodyContains(tc.body)),
-							})
-						})
-					}
-				})
-			}
-		})
-}
-
-// TestAuthorization_TCP tests the authorization policy on workloads using the raw TCP protocol.
-func TestAuthorization_TCP(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.tcp").
-		Run(func(t framework.TestContext) {
-			newTestCase := func(from echo.Instance, to echo.Target, s scheme.Instance, portName string, expectAllowed bool) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					opts := echo.CallOptions{
-						To:    to,
-						Count: 1,
-						Port: echo.Port{
-							Name: portName,
-						},
-						Scheme: s,
-						HTTP: echo.HTTP{
-							Path: "/data",
-						},
-					}
-					opts.FillDefaultsOrFail(t)
-					if expectAllowed {
-						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-					} else {
-						opts.Check = check.Forbidden(opts.Port.Protocol)
-					}
-
-					name := newRbacTestName("", expectAllowed, from, &opts)
-					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-						name.SkipIfNecessary(t)
-						from.CallOrFail(t, opts)
-					})
-				}
-			}
-
-			ns := apps.Namespace1
-			ns2 := apps.Namespace2
-			a := match.Namespace(ns).GetMatches(apps.A)
-			b := match.Namespace(ns).GetMatches(apps.B)
-			c := match.Namespace(ns).GetMatches(apps.C)
-			eInNS2 := match.Namespace(ns2).GetMatches(apps.E)
-			d := match.Namespace(ns).GetMatches(apps.D)
-			e := match.Namespace(ns).GetMatches(apps.E)
-			t.NewSubTest("non-vms").
-				Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile("", map[string]string{
-						"Namespace":  ns.Name(),
-						"Namespace2": ns2.Name(),
-						"b":          b[0].Config().Service,
-						"c":          c[0].Config().Service,
-						"d":          d[0].Config().Service,
-						"e":          e[0].Config().Service,
-						"a":          a[0].Config().Service,
-					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t)
-
-					cases := []func(testContext framework.TestContext){
-						// The policy on workload b denies request with path "/data" to port 8091:
-						// - request to port http-8091 should be denied because both path and port are matched.
-						// - request to port http-8092 should be allowed because the port is not matched.
-						// - request to port tcp-8093 should be allowed because the port is not matched.
-						newTestCase(a[0], b, scheme.HTTP, "http-8091", false),
-						newTestCase(a[0], b, scheme.HTTP, "http-8092", true),
-						newTestCase(a[0], b, scheme.TCP, "tcp-8093", true),
-
-						// The policy on workload c denies request to port 8091:
-						// - request to port http-8091 should be denied because the port is matched.
-						// - request to http port 8092 should be allowed because the port is not matched.
-						// - request to tcp port 8093 should be allowed because the port is not matched.
-						// - request from b to tcp port 8093 should be allowed by default.
-						// - request from b to tcp port 8094 should be denied because the principal is matched.
-						// - request from eInNS2 to tcp port 8093 should be denied because the namespace is matched.
-						// - request from eInNS2 to tcp port 8094 should be allowed by default.
-						newTestCase(a[0], c, scheme.HTTP, "http-8091", false),
-						newTestCase(a[0], c, scheme.HTTP, "http-8092", true),
-						newTestCase(a[0], c, scheme.TCP, "tcp-8093", true),
-						newTestCase(b[0], c, scheme.TCP, "tcp-8093", true),
-						newTestCase(b[0], c, scheme.TCP, "tcp-8094", false),
-						newTestCase(eInNS2[0], c, scheme.TCP, "tcp-8093", false),
-						newTestCase(eInNS2[0], c, scheme.TCP, "tcp-8094", true),
-
-						// The policy on workload d denies request from service account a and workloads in namespace 2:
-						// - request from a to d should be denied because it has service account a.
-						// - request from b to d should be allowed.
-						// - request from c to d should be allowed.
-						// - request from eInNS2 to a should be allowed because there is no policy on a.
-						// - request from eInNS2 to d should be denied because it's in namespace 2.
-						newTestCase(a[0], d, scheme.TCP, "tcp-8093", false),
-						newTestCase(b[0], d, scheme.TCP, "tcp-8093", true),
-						newTestCase(c[0], d, scheme.TCP, "tcp-8093", true),
-						newTestCase(eInNS2[0], a, scheme.TCP, "tcp-8093", true),
-						newTestCase(eInNS2[0], d, scheme.TCP, "tcp-8093", false),
-
-						// The policy on workload e denies request with path "/other":
-						// - request to port http-8091 should be allowed because the path is not matched.
-						// - request to port http-8092 should be allowed because the path is not matched.
-						// - request to port tcp-8093 should be denied because policy uses HTTP fields.
-						newTestCase(a[0], e, scheme.HTTP, "http-8091", true),
-						newTestCase(a[0], e, scheme.HTTP, "http-8092", true),
-						newTestCase(a[0], e, scheme.TCP, "tcp-8093", false),
-					}
-
-					for _, c := range cases {
-						c(t)
-					}
-				})
-			// TODO(JimmyCYJ): support multiple VMs and apply different security policies to each VM.
-			vm := match.Namespace(ns).GetMatches(apps.VM)
-			t.NewSubTest("vms").
-				Run(func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile("", map[string]string{
-						"Namespace":  ns.Name(),
-						"Namespace2": ns2.Name(),
-						"b":          b[0].Config().Service,
-						"c":          vm[0].Config().Service,
-						"d":          d[0].Config().Service,
-						"e":          e[0].Config().Service,
-						"a":          a[0].Config().Service,
-					}, "testdata/authz/v1beta1-tcp.yaml.tmpl").ApplyOrFail(t)
-					cases := []func(testContext framework.TestContext){
-						// The policy on workload vm denies request to port 8091:
-						// - request to port http-8091 should be denied because the port is matched.
-						// - request to http port 8092 should be allowed because the port is not matched.
-						// - request to tcp port 8093 should be allowed because the port is not matched.
-						// - request from b to tcp port 8093 should be allowed by default.
-						// - request from b to tcp port 8094 should be denied because the principal is matched.
-						// - request from eInNS2 to tcp port 8093 should be denied because the namespace is matched.
-						// - request from eInNS2 to tcp port 8094 should be allowed by default.
-						newTestCase(a[0], vm, scheme.HTTP, "http-8091", false),
-						newTestCase(a[0], vm, scheme.HTTP, "http-8092", true),
-						newTestCase(a[0], vm, scheme.TCP, "tcp-8093", true),
-						newTestCase(b[0], vm, scheme.TCP, "tcp-8093", true),
-						newTestCase(b[0], vm, scheme.TCP, "tcp-8094", false),
-						newTestCase(eInNS2[0], vm, scheme.TCP, "tcp-8093", false),
-						newTestCase(eInNS2[0], vm, scheme.TCP, "tcp-8094", true),
-					}
-					for _, c := range cases {
-						c(t)
-					}
-				})
-		})
-}
-
-// TestAuthorization_Conditions tests v1beta1 authorization with conditions.
-func TestAuthorization_Conditions(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.conditions").
-		Run(func(t framework.TestContext) {
-			nsA := apps.Namespace1
-			nsB := apps.Namespace2
-			nsC := apps.Namespace3
-
-			c := match.Namespace(nsC).GetMatches(apps.C)
-			vm := match.Namespace(nsA).GetMatches(apps.VM)
-			for _, to := range []echo.Instances{c, vm} {
-				to := to
-				for _, a := range match.Namespace(nsA).GetMatches(apps.A) {
-					a := a
-					bs := match.And(match.Cluster(a.Config().Cluster), match.Namespace(nsB)).GetMatches(apps.B)
-					if len(bs) < 1 {
-						t.Skip()
-					}
-					b := bs[0]
-					t.NewSubTestf("from %s to %s in %s",
-						a.Config().Cluster.StableName(), to.Config().Service, to.Config().Cluster.StableName()).
-						Run(func(t framework.TestContext) {
-							args := map[string]interface{}{
-								"NamespaceA": nsA.Name(),
-								"NamespaceB": nsB.Name(),
-								"NamespaceC": to.Config().Namespace.Name(),
-								"cSet":       to.Config().Service,
-								"ipA":        a.WorkloadsOrFail(t).Addresses(),
-								"ipB":        b.WorkloadsOrFail(t).Addresses(),
-								"ipC":        to.WorkloadsOrFail(t).Addresses(),
-								"portC":      "8090",
-								"a":          util.ASvc,
-								"b":          util.BSvc,
-							}
-
-							t.ConfigIstio().EvalFile("", args, "testdata/authz/v1beta1-conditions.yaml.tmpl").
-								ApplyOrFail(t)
-							newTestCase := func(from echo.Instance, path string, headers http.Header, expectAllowed bool) func(t framework.TestContext) {
-								return func(t framework.TestContext) {
-									opts := echo.CallOptions{
-										To: to,
-										Port: echo.Port{
-											Name: "http",
-										},
-										HTTP: echo.HTTP{
-											Path:    path,
-											Headers: headers,
-										},
-									}
-									if expectAllowed {
-										opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-									} else {
-										opts.Check = check.Forbidden(protocol.HTTP)
-									}
-
-									name := newRbacTestName("", expectAllowed, from, &opts)
-									t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-										name.SkipIfNecessary(t)
-										from.CallOrFail(t, opts)
-									})
-								}
-							}
-
-							cases := []func(framework.TestContext){
-								newTestCase(a, "/request-headers", headers.New().With("x-foo", "foo").Build(), true),
-								newTestCase(b, "/request-headers", headers.New().With("x-foo", "foo").Build(), true),
-								newTestCase(a, "/request-headers", headers.New().With("x-foo", "bar").Build(), false),
-								newTestCase(b, "/request-headers", headers.New().With("x-foo", "bar").Build(), false),
-								newTestCase(a, "/request-headers", nil, false),
-								newTestCase(b, "/request-headers", nil, false),
-								newTestCase(a, "/request-headers-notValues-bar", headers.New().With("x-foo", "foo").Build(), true),
-								newTestCase(a, "/request-headers-notValues-bar", headers.New().With("x-foo", "bar").Build(), false),
-
-								newTestCase(a, fmt.Sprintf("/source-ip-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-ip-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-ip-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-ip-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-ip-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-namespace-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-namespace-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-namespace-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, fmt.Sprintf("/source-principal-%s", args["a"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-principal-%s", args["a"]), nil, false),
-								newTestCase(a, fmt.Sprintf("/source-principal-%s", args["b"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/source-principal-%s", args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, true),
-								newTestCase(b, fmt.Sprintf("/source-principal-notValues-%s", args["b"]), nil, false),
-
-								newTestCase(a, "/destination-ip-good", nil, true),
-								newTestCase(b, "/destination-ip-good", nil, true),
-								newTestCase(a, "/destination-ip-bad", nil, false),
-								newTestCase(b, "/destination-ip-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/destination-ip-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/destination-ip-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
-
-								newTestCase(a, "/destination-port-good", nil, true),
-								newTestCase(b, "/destination-port-good", nil, true),
-								newTestCase(a, "/destination-port-bad", nil, false),
-								newTestCase(b, "/destination-port-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
-								newTestCase(b, fmt.Sprintf("/destination-port-notValues-%s", args["cSet"]), nil, false),
-
-								newTestCase(a, "/connection-sni-good", nil, true),
-								newTestCase(b, "/connection-sni-good", nil, true),
-								newTestCase(a, "/connection-sni-bad", nil, false),
-								newTestCase(b, "/connection-sni-bad", nil, false),
-								newTestCase(a, fmt.Sprintf("/connection-sni-notValues-%s-or-%s", args["a"], args["b"]), nil, true),
-								newTestCase(a, fmt.Sprintf("/connection-sni-notValues-%s-or-%s-or-%s", args["a"], args["b"], args["cSet"]), nil, false),
-
-								newTestCase(a, "/other", nil, false),
-								newTestCase(b, "/other", nil, false),
-							}
-							for _, c := range cases {
-								c(t)
-							}
-						})
-				}
-			}
-		})
-}
-
-// TestAuthorization_GRPC tests v1beta1 authorization with gRPC protocol.
-func TestAuthorization_GRPC(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.grpc-protocol").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			a := match.Namespace(apps.Namespace1).GetMatches(apps.A)
-			b := match.Namespace(apps.Namespace1).GetMatches(apps.B)
-			c := match.Namespace(apps.Namespace1).GetMatches(apps.C)
-			d := match.Namespace(apps.Namespace1).GetMatches(apps.D)
-			vm := match.Namespace(apps.Namespace1).GetMatches(apps.VM)
-			for _, a := range []echo.Instances{a, vm} {
-				for _, b := range []echo.Instances{b, vm} {
-					if a[0].Config().Service == b[0].Config().Service {
-						t.Skip()
-					}
-					t.NewSubTestf("to %s in %s", a[0].Config().Service, a[0].Config().Cluster.StableName()).
-						Run(func(t framework.TestContext) {
-							args := map[string]string{
-								"Namespace": ns.Name(),
-								"a":         a[0].Config().Service,
-								"b":         b[0].Config().Service,
-								"c":         c[0].Config().Service,
-								"d":         d[0].Config().Service,
-							}
-							t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-grpc.yaml.tmpl").ApplyOrFail(t, apply.Wait)
-							newTestCase := func(from echo.Instance, to echo.Target, expectAllowed bool) func(t framework.TestContext) {
-								return func(t framework.TestContext) {
-									opts := echo.CallOptions{
-										To:    to,
-										Count: 1,
-										Port: echo.Port{
-											Name: "grpc",
-										},
-									}
-									if expectAllowed {
-										opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-									} else {
-										opts.Check = check.Forbidden(protocol.GRPC)
-									}
-
-									name := newRbacTestName("", expectAllowed, from, &opts)
-									t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-										name.SkipIfNecessary(t)
-										from.CallOrFail(t, opts)
-									})
-								}
-							}
-							cases := []func(testContext framework.TestContext){
-								newTestCase(b[0], a, true),
-								newTestCase(c[0], a, false),
-								newTestCase(d[0], a, true),
-							}
-
-							for _, c := range cases {
-								c(t)
-							}
-						})
-				}
-			}
-		})
-}
-
-// TestAuthorization_Path tests the path is normalized before using in authorization. For example, a request
-// with path "/a/../b" should be normalized to "/b" before using in authorization.
-func TestAuthorization_Path(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.path-normalization").
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			a := match.Namespace(ns).GetMatches(apps.A)
-			vm := match.Namespace(ns).GetMatches(apps.VM)
-			for _, a := range []echo.Instances{a, vm} {
-				for _, srcCluster := range t.Clusters() {
-					b := match.And(match.Cluster(srcCluster), match.Namespace(ns)).GetMatches(apps.B)
-					if len(b) == 0 {
-						continue
-					}
-
-					t.NewSubTestf("In %s", srcCluster.StableName()).Run(func(t framework.TestContext) {
-						args := map[string]string{
-							"Namespace": ns.Name(),
-							"a":         a[0].Config().Service,
-						}
-						t.ConfigIstio().EvalFile(ns.Name(), args, "testdata/authz/v1beta1-path.yaml.tmpl").ApplyOrFail(t, apply.Wait)
-
-						newTestCase := func(from echo.Instance, to echo.Target, path string, expectAllowed bool) func(t framework.TestContext) {
-							return func(t framework.TestContext) {
-								opts := echo.CallOptions{
-									To: to,
-									Port: echo.Port{
-										Name: "http",
-									},
-									HTTP: echo.HTTP{
-										Path: path,
-									},
-								}
-								if expectAllowed {
-									opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-								} else {
-									opts.Check = check.Forbidden(protocol.HTTP)
-								}
-
-								name := newRbacTestName("", expectAllowed, from, &opts)
-								t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-									name.SkipIfNecessary(t)
-									from.CallOrFail(t, opts)
-								})
-							}
-						}
-						cases := []func(test framework.TestContext){
-							newTestCase(b[0], a, "/public", true),
-							newTestCase(b[0], a, "/public/../public", true),
-							newTestCase(b[0], a, "/private", false),
-							newTestCase(b[0], a, "/public/../private", false),
-							newTestCase(b[0], a, "/public/./../private", false),
-							newTestCase(b[0], a, "/public/.././private", false),
-							newTestCase(b[0], a, "/public/%2E%2E/private", false),
-							newTestCase(b[0], a, "/public/%2e%2e/private", false),
-							newTestCase(b[0], a, "/public/%2E/%2E%2E/private", false),
-							newTestCase(b[0], a, "/public/%2e/%2e%2e/private", false),
-							newTestCase(b[0], a, "/public/%2E%2E/%2E/private", false),
-							newTestCase(b[0], a, "/public/%2e%2e/%2e/private", false),
-						}
-						for _, c := range cases {
-							c(t)
-						}
-					})
-				}
-			}
-		})
-}
-
-// TestAuthorization_Audit tests that the AUDIT action does not impact allowing or denying a request
-func TestAuthorization_Audit(t *testing.T) {
-	framework.NewTest(t).
-		Run(func(t framework.TestContext) {
-			ns := apps.Namespace1
-			a := match.Namespace(ns).GetMatches(apps.A)
-			b := match.Namespace(ns).GetMatches(apps.B)
-			c := match.Namespace(ns).GetMatches(apps.C)
-			d := match.Namespace(ns).GetMatches(apps.D)
-			vm := match.Namespace(ns).GetMatches(apps.VM)
-
-			policy := func(filename string) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
-						"b":             b[0].Config().Service,
-						"c":             c[0].Config().Service,
-						"d":             d[0].Config().Service,
-						"Namespace":     ns.Name(),
-						"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
-					}, filename).ApplyOrFail(t, apply.Wait)
-				}
-			}
-
-			vmPolicy := func(filename string) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					t.ConfigIstio().EvalFile(ns.Name(), map[string]string{
-						"Namespace": ns.Name(),
-						"dst":       vm[0].Config().Service,
-					}, filename).ApplyOrFail(t, apply.Wait)
-				}
-			}
-
-			newTestCase := func(applyPolicy func(t framework.TestContext), from echo.Instance, to echo.Target,
-				path string, expectAllowed bool,
-			) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					opts := echo.CallOptions{
-						To:    to,
-						Count: 1,
-						Port: echo.Port{
-							Name: "http",
-						},
-						HTTP: echo.HTTP{
-							Path: path,
-						},
-					}
-					if expectAllowed {
-						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-					} else {
-						opts.Check = check.Forbidden(protocol.HTTP)
-					}
-
-					name := newRbacTestName("", expectAllowed, from, &opts)
-					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-						name.SkipIfNecessary(t)
-
-						applyPolicy(t)
-
-						from.CallOrFail(t, opts)
-					})
-				}
-			}
-
-			cases := []func(t framework.TestContext){
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], b, "/allow", true),
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], b, "/audit", false),
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], c, "/audit", true),
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], c, "/deny", false),
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], d, "/audit", true),
-				newTestCase(policy("testdata/authz/v1beta1-audit.yaml.tmpl"), a[0], d, "/other", true),
-
-				// (TODO)JimmyCYJ: Support multiple VMs and apply audit policies to multiple VMs for testing.
-				// The tests below are duplicated from above for VM workloads. With support for multiple VMs,
-				// These tests will be merged to the tests above.
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-allow.yaml.tmpl"), b[0], vm, "/allow", true),
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-allow.yaml.tmpl"), b[0], vm, "/audit", false),
-
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-deny.yaml.tmpl"), b[0], vm, "/audit", true),
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-deny.yaml.tmpl"), b[0], vm, "/deny", false),
-
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-default.yaml.tmpl"), b[0], vm, "/audit", true),
-				newTestCase(vmPolicy("testdata/authz/v1beta1-audit-default.yaml.tmpl"), b[0], vm, "/other", true),
-			}
-			for _, c := range cases {
-				c(t)
-			}
-		})
-}
-
-// TestAuthorization_Custom tests that the CUSTOM action with the sample ext_authz server.
-func TestAuthorization_Custom(t *testing.T) {
-	framework.NewTest(t).
-		Features("security.authorization.custom").
-		Run(func(t framework.TestContext) {
-			ns := namespace.NewOrFail(t, t, namespace.Config{
-				Prefix: "v1beta1-custom",
-				Inject: true,
-			})
-
-			// Start the authz server.
-			authzServer := authz.NewOrFail(t, ns)
-
-			// Also configure local access to the authz servers deployed in the echo pods.
-			localAuthzServer := authz.NewLocalOrFail(t, ns)
-
-			// Create the template args.
-			args := map[string]string{
-				"Namespace":     ns.Name(),
-				"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
-			}
-			for _, p := range authzServer.Providers() {
-				switch p.API() {
-				case authz.HTTP:
-					args["HTTPProviderName"] = p.Name()
-				case authz.GRPC:
-					args["GRPCProviderName"] = p.Name()
-				}
-			}
-			for _, p := range localAuthzServer.Providers() {
-				switch p.API() {
-				case authz.HTTP:
-					args["LocalHTTPProviderName"] = p.Name()
-				case authz.GRPC:
-					args["LocalGRPCProviderName"] = p.Name()
-				}
-			}
-			t.ConfigIstio().EvalFile("", args, "testdata/authz/v1beta1-custom.yaml.tmpl").
-				ApplyOrFail(t)
-			ports := []echo.Port{
-				{
-					Name:         "tcp-8092",
-					Protocol:     protocol.TCP,
-					WorkloadPort: 8092,
-				},
-				{
-					Name:         "tcp-8093",
-					Protocol:     protocol.TCP,
-					WorkloadPort: 8093,
-				},
-				{
-					Name:         "http",
-					Protocol:     protocol.HTTP,
-					WorkloadPort: 8090,
-				},
-			}
-
-			var a, b, c, d, e, f, g, x echo.Instance
-			echoConfig := func(name string, includeExtAuthz bool) echo.Config {
-				cfg := util.EchoConfig(name, ns, false, nil)
-				cfg.IncludeExtAuthz = includeExtAuthz
-				cfg.Ports = ports
-				return cfg
-			}
-			deployment.New(t).
-				With(&a, echoConfig("a", false)).
-				With(&b, echoConfig("b", false)).
-				With(&c, echoConfig("c", false)).
-				With(&d, echoConfig("d", true)).
-				With(&e, echoConfig("e", true)).
-				With(&f, echoConfig("f", false)).
-				With(&g, echoConfig("g", false)).
-				With(&x, echoConfig("x", false)).
-				BuildOrFail(t)
-
-			newTestCase := func(from echo.Instance, to echo.Target, s scheme.Instance, port, path string, headers http.Header,
-				checker echo.Checker, expectAllowed bool,
-			) func(t framework.TestContext) {
-				return func(t framework.TestContext) {
-					opts := echo.CallOptions{
-						To:    to,
-						Count: 1,
-						Port: echo.Port{
-							Name: port,
-						},
-						Scheme: s,
-						HTTP: echo.HTTP{
-							Path:    path,
-							Headers: headers,
-						},
-					}
-					opts.FillDefaultsOrFail(t)
-					if expectAllowed {
-						opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-					} else {
-						opts.Check = check.Forbidden(opts.Port.Protocol)
-					}
-					opts.Check = check.And(opts.Check, checker)
-
-					name := newRbacTestName("", expectAllowed, from, &opts)
-					t.NewSubTest(name.String()).Run(func(t framework.TestContext) {
-						name.SkipIfNecessary(t)
-						from.CallOrFail(t, opts)
-					})
-				}
-			}
-			checkHTTPHeaders := func(hType echoClient.HeaderType) echo.Checker {
-				return check.And(
-					scheck.HeaderContains(hType, map[string][]string{
-						"X-Ext-Authz-Check-Received":             {"additional-header-new-value", "additional-header-override-value"},
-						"X-Ext-Authz-Additional-Header-Override": {"additional-header-override-value"},
-					}),
-					scheck.HeaderNotContains(hType, map[string][]string{
-						"X-Ext-Authz-Check-Received":             {"should-be-override"},
-						"X-Ext-Authz-Additional-Header-Override": {"should-be-override"},
-					}))
-			}
-			checkGRPCHeaders := func(hType echoClient.HeaderType) echo.Checker {
-				return check.And(
-					scheck.HeaderContains(hType, map[string][]string{
-						"X-Ext-Authz-Check-Received":             {"should-be-override"},
-						"X-Ext-Authz-Additional-Header-Override": {"grpc-additional-header-override-value"},
-					}),
-					scheck.HeaderNotContains(hType, map[string][]string{
-						"X-Ext-Authz-Additional-Header-Override": {"should-be-override"},
-					}))
-			}
-
-			authzHeaders := func(h string) http.Header {
-				return headers.New().With("x-ext-authz", h).With("x-ext-authz-additional-header-override", "should-be-override").Build()
-			}
-
-			// Path "/custom" is protected by ext-authz service and is accessible with the header `x-ext-authz: allow`.
-			// Path "/health" is not protected and is accessible to public.
-			cases := []func(test framework.TestContext){
-				// workload b is using an ext-authz service in its own pod of HTTP API.
-				newTestCase(x, b, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
-				newTestCase(x, b, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
-				newTestCase(x, b, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
-				newTestCase(x, b, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
-
-				// workload c is using an ext-authz service in its own pod of gRPC API.
-				newTestCase(x, c, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkGRPCHeaders(echoClient.RequestHeader), true),
-				newTestCase(x, c, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkGRPCHeaders(echoClient.ResponseHeader), false),
-				newTestCase(x, c, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
-				newTestCase(x, c, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
-
-				// workload d is using an local ext-authz service in the same pod as the application of HTTP API.
-				newTestCase(x, d, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
-				newTestCase(x, d, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
-				newTestCase(x, d, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
-				newTestCase(x, d, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
-
-				// workload e is using an local ext-authz service in the same pod as the application of gRPC API.
-				newTestCase(x, e, scheme.HTTP, "http", "/custom", authzHeaders("allow"), checkGRPCHeaders(echoClient.RequestHeader), true),
-				newTestCase(x, e, scheme.HTTP, "http", "/custom", authzHeaders("deny"), checkGRPCHeaders(echoClient.ResponseHeader), false),
-				newTestCase(x, e, scheme.HTTP, "http", "/health", authzHeaders("allow"), nil, true),
-				newTestCase(x, e, scheme.HTTP, "http", "/health", authzHeaders("deny"), nil, true),
-
-				// workload f is using an ext-authz service in its own pod of TCP API.
-				newTestCase(a, f, scheme.TCP, "tcp-8092", "", authzHeaders(""), nil, true),
-				newTestCase(x, f, scheme.TCP, "tcp-8092", "", authzHeaders(""), nil, false),
-				newTestCase(a, f, scheme.TCP, "tcp-8093", "", authzHeaders(""), nil, true),
-				newTestCase(x, f, scheme.TCP, "tcp-8093", "", authzHeaders(""), nil, true),
-			}
-
-			for _, c := range cases {
-				c(t)
-			}
-
-			t.NewSubTest("ingress").Run(func(t framework.TestContext) {
-				ingr := ist.IngressFor(t.Clusters().Default())
-				newIngressTestCase := func(from, to echo.Instance, path string, h http.Header,
-					checker echo.Checker, expectAllowed bool,
-				) func(t framework.TestContext) {
-					return func(t framework.TestContext) {
-						opts := echo.CallOptions{
-							To:    to,
-							Count: 1,
-							Port: echo.Port{
-								Protocol: protocol.HTTP,
-							},
-							Scheme: scheme.HTTP,
-							HTTP: echo.HTTP{
-								Path: path,
-								Headers: headers.New().
-									WithHost("www.company.com").
-									With("X-Ext-Authz", h.Get("x-ext-authz")).
-									Build(),
-							},
-						}
-						if expectAllowed {
-							opts.Check = check.And(check.OK(), scheck.ReachedClusters(t.AllClusters(), &opts))
-						} else {
-							opts.Check = check.Forbidden(protocol.HTTP)
-						}
-						opts.Check = check.And(opts.Check, checker)
-
-						name := fmt.Sprintf("%s->%s%s[%t]",
-							from.Config().Service,
-							to.Config().Service,
-							path,
-							expectAllowed)
-
-						t.NewSubTest(name).Run(func(t framework.TestContext) {
-							ingr.CallOrFail(t, opts)
-						})
-					}
-				}
-
-				ingressCases := []func(framework.TestContext){
-					// workload g is using an ext-authz service in its own pod of HTTP API.
-					newIngressTestCase(x, g, "/custom", authzHeaders("allow"), checkHTTPHeaders(echoClient.RequestHeader), true),
-					newIngressTestCase(x, g, "/custom", authzHeaders("deny"), checkHTTPHeaders(echoClient.ResponseHeader), false),
-					newIngressTestCase(x, g, "/health", authzHeaders("allow"), nil, true),
-					newIngressTestCase(x, g, "/health", authzHeaders("deny"), nil, true),
-				}
-				for _, c := range ingressCases {
-					c(t)
-				}
-			})
-		})
-}
-
-type rbacTestName string
-
-func (n rbacTestName) String() string {
-	return string(n)
-}
-
-func (n rbacTestName) SkipIfNecessary(t framework.TestContext) {
-	t.Helper()
-
-	if strings.Contains(n.String(), "source-ip") && t.Clusters().IsMulticluster() {
-		t.Skip("https://github.com/istio/istio/issues/37307: " +
-			"Current source ip based authz test cases are not required in multicluster setup because " +
-			"cross-network traffic will lose the origin source ip info")
-	}
-}
-
-func newRbacTestName(prefix string, expectAllowed bool, from echo.Instance, opts *echo.CallOptions) rbacTestName {
-	want := "deny"
-	if expectAllowed {
-		want = "allow"
-	}
-
-	return rbacTestName(fmt.Sprintf("%s%s->%s:%s%s[%s]",
-		prefix,
-		from.Config().Service,
-		opts.To.Config().Service,
-		opts.Port.Name,
-		opts.HTTP.Path,
-		want))
-}
diff --git a/tests/integration/security/authz/authz_test.go b/tests/integration/security/authz/authz_test.go
new file mode 100644
index 0000000000..0c9400e469
--- /dev/null
+++ b/tests/integration/security/authz/authz_test.go
@@ -0,0 +1,1800 @@
+//go:build integ
+// +build integ
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package security
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
+	"istio.io/istio/pkg/test/framework"
+	"istio.io/istio/pkg/test/framework/components/authz"
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/check"
+	"istio.io/istio/pkg/test/framework/components/echo/common/ports"
+	"istio.io/istio/pkg/test/framework/components/echo/config"
+	"istio.io/istio/pkg/test/framework/components/echo/config/param"
+	"istio.io/istio/pkg/test/framework/components/echo/echotest"
+	"istio.io/istio/pkg/test/framework/components/echo/match"
+	"istio.io/istio/pkg/test/framework/components/istio"
+	"istio.io/istio/pkg/test/framework/components/istio/ingress"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/tests/common/jwt"
+)
+
+func TestAuthz_Principal(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/allow-principal.yaml.tmpl").WithParams(
+					param.Params{
+						"Allowed": allowed,
+					})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.NamespacedName() == allowed.NamespacedName())
+
+					cases := []struct {
+						ports []string
+						path  string
+						allow allowValue
+					}{
+						{
+							ports: []string{ports.GRPC, ports.TCP},
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow?param=value",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny?param=value",
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Path(c.path).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_DenyPrincipal(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp",
+			"security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/deny-global.yaml.tmpl").WithParams(param.Params{
+					param.Namespace.String(): istio.ClaimSystemNamespaceOrFail(t, t),
+				})).
+				Source(config.File("testdata/v1beta1/deny-principal.yaml.tmpl").WithParams(
+					param.Params{
+						"Denied": denied,
+					})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.NamespacedName() != denied.NamespacedName())
+
+					cases := []struct {
+						ports []string
+						path  string
+						allow allowValue
+					}{
+						{
+							ports: []string{ports.GRPC, ports.TCP},
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny?param=value",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny/allow?param=value",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow?param=value",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny?param=value",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny/allow?param=value",
+							allow: true,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Path(c.path).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_Namespace(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp").
+		Run(func(t framework.TestContext) {
+			// Allow anything from ns1. Any service in ns1 will work as the `from` (just using ns1.A)
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1AndNs2)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/allow-namespace.yaml.tmpl").WithParams(
+					param.Params{
+						"Allowed": allowed,
+					})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.Config().Namespace.Name() == allowed.Config().Namespace.Name())
+
+					cases := []struct {
+						ports []string
+						path  string
+						allow allowValue
+					}{
+						{
+							ports: []string{ports.GRPC, ports.TCP},
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow?param=value",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny?param=value",
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Path(c.path).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_DenyNamespace(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp",
+			"security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1AndNs2)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/deny-global.yaml.tmpl").WithParams(param.Params{
+					param.Namespace.String(): istio.ClaimSystemNamespaceOrFail(t, t),
+				})).
+				Source(config.File("testdata/v1beta1/deny-namespace.yaml.tmpl").WithParams(
+					param.Params{
+						"Denied": denied,
+					})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.Config().Namespace.Name() == allowed.Config().Namespace.Name())
+
+					cases := []struct {
+						ports []string
+						path  string
+						allow allowValue
+					}{
+						{
+							ports: []string{ports.GRPC, ports.TCP},
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny?param=value",
+							allow: allow,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/deny/allow?param=value",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/allow?param=value",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny?param=value",
+							allow: false,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny/allow",
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP, ports.HTTP2},
+							path:  "/global-deny/allow?param=value",
+							allow: true,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Path(c.path).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_NotNamespace(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp",
+			"security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/not-namespace.yaml.tmpl").WithParams(
+					param.Params{
+						"Allowed": allowed,
+					})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.Config().Namespace.Name() == allowed.Config().Namespace.Name())
+
+					newAuthzTest().
+						From(from).
+						To(to).
+						Allow(allow).
+						BuildAndRunForPorts(t, ports.GRPC, ports.TCP, ports.HTTP, ports.HTTP2)
+				})
+		})
+}
+
+func TestAuthz_NotHost(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/not-host.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				RunViaIngress(func(t framework.TestContext, from ingress.Instance, to echo.Target) {
+					cases := []struct {
+						host  string
+						allow allowValue
+					}{
+						{
+							host:  fmt.Sprintf("allow.%s.com", to.Config().Service),
+							allow: true,
+						},
+						{
+							host:  fmt.Sprintf("deny.%s.com", to.Config().Service),
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						c := c
+						testName := fmt.Sprintf("%s(%s)", c.host, c.allow)
+						t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+							wantCode := http.StatusOK
+							if !c.allow {
+								wantCode = http.StatusForbidden
+							}
+
+							opts := echo.CallOptions{
+								Port: echo.Port{
+									Protocol: protocol.HTTP,
+								},
+								HTTP: echo.HTTP{
+									Headers: headers.New().WithHost(c.host).Build(),
+								},
+								Check: check.And(check.NoError(), check.Status(wantCode)),
+							}
+							from.CallOrFail(t, opts)
+						})
+					}
+				})
+		})
+}
+
+func TestAuthz_NotMethod(t *testing.T) {
+	// NOTE: negative match for mtls is tested by TestAuthz_DenyPlaintext.
+	// Negative match for paths is tested by TestAuthz_DenyPrincipal, TestAuthz_DenyNamespace.
+	framework.NewTest(t).
+		Features("security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1AndNs2)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/not-method.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					cases := []struct {
+						ports  []string
+						method string
+						allow  allowValue
+					}{
+						{
+							ports:  []string{ports.HTTP, ports.HTTP2},
+							method: "GET",
+							allow:  true,
+						},
+						{
+							ports:  []string{ports.HTTP, ports.HTTP2},
+							method: "PUT",
+							allow:  false,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Method(c.method).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_NotPort(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1AndNs2)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/not-port.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					cases := []struct {
+						ports []string
+						allow allowValue
+					}{
+						{
+							ports: []string{ports.HTTP},
+							allow: true,
+						},
+						{
+							ports: []string{ports.HTTP2},
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							BuildAndRunForPorts(t, c.ports...)
+					}
+				})
+		})
+}
+
+func TestAuthz_DenyPlaintext(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.mtls-local",
+			"security.authorization.grpc-protocol",
+			"security.authorization.tcp",
+			"security.authorization.negative-match").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			newTrafficTest(t, apps.Ns1.All.Instances().Append(denied)).
+				Config(config.File("testdata/v1beta1/plaintext.yaml.tmpl").WithParams(param.Params{
+					"Denied": denied,
+					// The namespaces for each resource are specified in the file. Use "" as the ns to apply to.
+					param.Namespace.String(): "",
+				})).
+				// Just test from A in each namespace to show the policy works.
+				FromMatch(match.AnyServiceName(allowed.Append(denied).NamespacedNames())).
+				ToMatch(match.Namespace(apps.Ns1.Namespace)).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.Config().Namespace.Name() == allowed.Config().Namespace.Name())
+					newAuthzTest().
+						From(from).
+						To(to).
+						Allow(allow).
+						BuildAndRunForPorts(t, ports.GRPC, ports.TCP, ports.HTTP, ports.HTTP2)
+				})
+		})
+}
+
+func TestAuthz_JWT(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.jwt-token").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.ServiceName(from.NamespacedName())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/jwt.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					cases := []struct {
+						prefix string
+						jwt    string
+						path   string
+						allow  allowValue
+					}{
+						{
+							prefix: "[No JWT]",
+							jwt:    "",
+							path:   "/token1",
+							allow:  false,
+						},
+						{
+							prefix: "[No JWT]",
+							jwt:    "",
+							path:   "/token2",
+							allow:  false,
+						},
+						{
+							prefix: "[Token1]",
+							jwt:    jwt.TokenIssuer1, path: "/token1", allow: true,
+						},
+						{
+							prefix: "[Token1]",
+							jwt:    jwt.TokenIssuer1,
+							path:   "/token2",
+							allow:  false,
+						},
+						{
+							prefix: "[Token2]",
+							jwt:    jwt.TokenIssuer2,
+							path:   "/token1",
+							allow:  false,
+						},
+						{
+							prefix: "[Token2]",
+							jwt:    jwt.TokenIssuer2,
+							path:   "/token2",
+							allow:  true,
+						},
+						{
+							prefix: "[Token3]",
+							jwt:    jwt.TokenIssuer1,
+							path:   "/token3",
+							allow:  false,
+						},
+						{
+							prefix: "[Token3]",
+							jwt:    jwt.TokenIssuer2,
+							path:   "/token3",
+							allow:  true,
+						},
+						{
+							prefix: "[Token1]",
+							jwt:    jwt.TokenIssuer1,
+							path:   "/tokenAny",
+							allow:  true,
+						},
+						{
+							prefix: "[Token2]",
+							jwt:    jwt.TokenIssuer2,
+							path:   "/tokenAny",
+							allow:  true,
+						},
+						{
+							prefix: "[PermissionToken1]",
+							jwt:    jwt.TokenIssuer1,
+							path:   "/permission",
+							allow:  false,
+						},
+						{
+							prefix: "[PermissionToken2]",
+							jwt:    jwt.TokenIssuer2,
+							path:   "/permission",
+							allow:  false,
+						},
+						{
+							prefix: "[PermissionTokenWithSpaceDelimitedScope]",
+							jwt:    jwt.TokenIssuer2WithSpaceDelimitedScope,
+							path:   "/permission",
+							allow:  true,
+						},
+						{
+							prefix: "[NestedToken1]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims1,
+							path:   "/nested-key1",
+							allow:  true,
+						},
+						{
+							prefix: "[NestedToken2]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims2,
+							path:   "/nested-key1",
+							allow:  false,
+						},
+						{
+							prefix: "[NestedToken1]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims1,
+							path:   "/nested-key2",
+							allow:  false,
+						},
+						{
+							prefix: "[NestedToken2]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims2,
+							path:   "/nested-key2",
+							allow:  true,
+						},
+						{
+							prefix: "[NestedToken1]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims1,
+							path:   "/nested-2-key1",
+							allow:  true,
+						},
+						{
+							prefix: "[NestedToken2]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims2,
+							path:   "/nested-2-key1",
+							allow:  false,
+						},
+						{
+							prefix: "[NestedToken1]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims1,
+							path:   "/nested-non-exist",
+							allow:  false,
+						},
+						{
+							prefix: "[NestedToken2]",
+							jwt:    jwt.TokenIssuer1WithNestedClaims2,
+							path:   "/nested-non-exist",
+							allow:  false,
+						},
+						{
+							prefix: "[NoJWT]",
+							jwt:    "",
+							path:   "/tokenAny",
+							allow:  false,
+						},
+					}
+					for _, c := range cases {
+						h := headers.New().WithAuthz(c.jwt).Build()
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Prefix(c.prefix).
+							Path(c.path).
+							Headers(h).
+							BuildAndRunForPorts(t, ports.HTTP, ports.HTTP2)
+					}
+				})
+		})
+}
+
+func TestAuthz_WorkloadSelector(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.workload-selector").
+		Run(func(t framework.TestContext) {
+			// Verify that the workload-specific path (/policy-<ns>-<svc>) works only on the selected workload.
+			t.NewSubTestf("single workload").
+				Run(func(t framework.TestContext) {
+					from := apps.Ns1.A
+					fromMatch := match.ServiceName(from.NamespacedName())
+					toMatch := match.Not(fromMatch)
+					to := toMatch.GetServiceMatches(apps.Ns1.All)
+					fromAndTo := to.Instances().Append(from)
+
+					config.New(t).
+						Source(config.File("testdata/v1beta1/workload.yaml.tmpl")).
+						// Also define a bad workload selector for path /policy-<ns>-<svc>-bad.
+						Source(config.File("testdata/v1beta1/workload-bad.yaml.tmpl")).
+						// Allow /policy-<ns>-all for all workloads.
+						Source(config.File("testdata/v1beta1/workload-ns.yaml.tmpl").WithParams(param.Params{
+							param.Namespace.String(): apps.Ns1.Namespace,
+						})).
+						Source(config.File("testdata/v1beta1/workload-ns.yaml.tmpl").WithParams(param.Params{
+							param.Namespace.String(): apps.Ns2.Namespace,
+						})).
+						// Allow /policy-istio-system-<svc> for all services in all namespaces. Just using ns1 to avoid
+						// creating duplicate resources.
+						Source(config.File("testdata/v1beta1/workload-system-ns.yaml.tmpl").WithParams(param.Params{
+							param.Namespace.String(): istio.ClaimSystemNamespaceOrFail(t, t),
+						})).
+						BuildAll(nil, to).
+						Apply()
+
+					newTrafficTest(t, fromAndTo).
+						FromMatch(fromMatch).
+						ToMatch(toMatch).
+						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+							type testCase struct {
+								path  string
+								allow allowValue
+							}
+
+							cases := []testCase{
+								{
+									// Make sure the bad policy did not select this workload.
+									path:  fmt.Sprintf("/policy-%s-%s-bad", to.Config().Namespace.Prefix(), to.Config().Service),
+									allow: false,
+								},
+							}
+
+							// Make sure the namespace-wide policy was applied to this workload.
+							for _, ns := range []namespace.Instance{apps.Ns1.Namespace, apps.Ns2.Namespace} {
+								cases = append(cases,
+									testCase{
+										path:  fmt.Sprintf("/policy-%s-all", ns.Prefix()),
+										allow: ns.Name() == to.Config().Namespace.Name(),
+									})
+							}
+
+							// Make sure the workload-specific paths succeeds.
+							cases = append(cases,
+								testCase{
+									path:  fmt.Sprintf("/policy-%s-%s", to.Config().Namespace.Prefix(), to.Config().Service),
+									allow: true,
+								},
+								testCase{
+									path:  fmt.Sprintf("/policy-system-%s", to.Config().Service),
+									allow: true,
+								})
+
+							// The workload-specific paths should fail for another service (just add a single test case).
+							for _, svc := range apps.Ns1.All {
+								if svc.Config().Service != to.Config().Service {
+									cases = append(cases,
+										testCase{
+											path:  fmt.Sprintf("/policy-%s-%s", svc.Config().Namespace.Prefix(), svc.Config().Service),
+											allow: false,
+										},
+										testCase{
+											path:  fmt.Sprintf("/policy-system-%s", svc.Config().Service),
+											allow: false,
+										})
+									break
+								}
+							}
+
+							for _, c := range cases {
+								newAuthzTest().
+									From(from).
+									To(to).
+									Allow(c.allow).
+									Path(c.path).
+									BuildAndRunForPorts(t, ports.HTTP, ports.HTTP2)
+							}
+						})
+				})
+		})
+}
+
+func TestAuthz_PathPrecedence(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.deny-action").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.ServiceName(from.NamespacedName())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/path-precedence.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					cases := []struct {
+						path  string
+						allow allowValue
+					}{
+						{
+							path:  "/allow/admin",
+							allow: false,
+						},
+						{
+							path:  "/allow/admin?param=value",
+							allow: false,
+						},
+						{
+							path:  "/allow",
+							allow: true,
+						},
+						{
+							path:  "/allow?param=value",
+							allow: true,
+						},
+					}
+
+					for _, c := range cases {
+						newAuthzTest().
+							From(from).
+							To(to).
+							Allow(c.allow).
+							Path(c.path).
+							BuildAndRunForPorts(t, ports.HTTP, ports.HTTP2)
+					}
+				})
+		})
+}
+
+func TestAuthz_IngressGateway(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.ingress-gateway").
+		Run(func(t framework.TestContext) {
+			to := apps.Ns1.All
+			config.New(t).
+				Source(config.File("testdata/v1beta1/ingress-gateway.yaml.tmpl").WithParams(param.Params{
+					// The namespaces for each resource are specified in the file. Use "" as the ns to apply to.
+					param.Namespace.String(): "",
+				})).
+				BuildAll(nil, to).
+				Apply()
+			newTrafficTest(t, to.Instances()).
+				RunViaIngress(func(t framework.TestContext, from ingress.Instance, to echo.Target) {
+					host := func(fmtStr string) string {
+						return fmt.Sprintf(fmtStr, to.Config().Service)
+					}
+					cases := []struct {
+						host  string
+						path  string
+						ip    string
+						allow allowValue
+					}{
+						{
+							host:  host("deny.%s.com"),
+							allow: false,
+						},
+						{
+							host:  host("DENY.%s.COM"),
+							allow: false,
+						},
+						{
+							host:  host("Deny.%s.Com"),
+							allow: false,
+						},
+						{
+							host:  host("deny.suffix.%s.com"),
+							allow: false,
+						},
+						{
+							host:  host("DENY.SUFFIX.%s.COM"),
+							allow: false,
+						},
+						{
+							host:  host("Deny.Suffix.%s.Com"),
+							allow: false,
+						},
+						{
+							host:  host("prefix.%s.com"),
+							allow: false,
+						},
+						{
+							host:  host("PREFIX.%s.COM"),
+							allow: false,
+						},
+						{
+							host:  host("Prefix.%s.Com"),
+							allow: false,
+						},
+						{
+							host:  host("www.%s.com"),
+							path:  "/",
+							ip:    "172.16.0.1",
+							allow: true,
+						},
+						{
+							host:  host("www.%s.com"),
+							path:  "/private",
+							ip:    "172.16.0.1",
+							allow: false,
+						},
+						{
+							host:  host("www.%s.com"),
+							path:  "/public",
+							ip:    "172.16.0.1",
+							allow: true,
+						},
+						{
+							host:  host("internal.%s.com"),
+							path:  "/",
+							ip:    "172.16.0.1",
+							allow: false,
+						},
+						{
+							host:  host("internal.%s.com"),
+							path:  "/private",
+							ip:    "172.16.0.1",
+							allow: false,
+						},
+						{
+							host:  host("remoteipblocks.%s.com"),
+							path:  "/",
+							ip:    "172.17.72.46",
+							allow: false,
+						},
+						{
+							host:  host("remoteipblocks.%s.com"),
+							path:  "/",
+							ip:    "192.168.5.233",
+							allow: false,
+						},
+						{
+							host:  host("remoteipblocks.%s.com"),
+							path:  "/",
+							ip:    "10.4.5.6",
+							allow: true,
+						},
+						{
+							host:  host("notremoteipblocks.%s.com"),
+							path:  "/",
+							ip:    "10.2.3.4",
+							allow: false,
+						},
+						{
+							host:  host("notremoteipblocks.%s.com"),
+							path:  "/",
+							ip:    "172.23.242.188",
+							allow: true,
+						},
+						{
+							host:  host("remoteipattr.%s.com"),
+							path:  "/",
+							ip:    "10.242.5.7",
+							allow: false,
+						},
+						{
+							host:  host("remoteipattr.%s.com"),
+							path:  "/",
+							ip:    "10.124.99.10",
+							allow: false,
+						},
+						{
+							host:  host("remoteipattr.%s.com"),
+							path:  "/",
+							ip:    "10.4.5.6",
+							allow: true,
+						},
+					}
+
+					for _, c := range cases {
+						c := c
+						testName := c.host + c.path + c.allow.String()
+						if len(c.ip) > 0 {
+							testName = c.ip + "->" + testName
+						}
+						t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+							wantCode := http.StatusOK
+							if !c.allow {
+								wantCode = http.StatusForbidden
+							}
+
+							opts := echo.CallOptions{
+								Port: echo.Port{
+									Protocol: protocol.HTTP,
+								},
+								HTTP: echo.HTTP{
+									Path:    c.path,
+									Headers: headers.New().WithHost(c.host).WithXForwardedFor(c.ip).Build(),
+								},
+								Check: check.And(check.NoError(), check.Status(wantCode)),
+							}
+							from.CallOrFail(t, opts)
+						})
+					}
+				})
+		})
+}
+
+func TestAuthz_EgressGateway(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.egress-gateway").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Config(config.File("testdata/v1beta1/egress-gateway.yaml.tmpl").WithParams(param.Params{
+					// The namespaces for each resource are specified in the file. Use "" as the ns to apply to.
+					param.Namespace.String(): "",
+					"Allowed":                allowed,
+				})).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.NamespacedName() == allowed.Config().NamespacedName())
+
+					cases := []struct {
+						host  string
+						path  string
+						token string
+						allow allowValue
+					}{
+						{
+							host:  "www.company.com",
+							path:  "/allow",
+							allow: true,
+						},
+						{
+							host:  "www.company.com",
+							path:  "/deny",
+							allow: false,
+						},
+						{
+							host:  fmt.Sprintf("%s-%s-only.com", allowed.Config().Service, allowed.Config().Namespace.Name()),
+							path:  "/",
+							allow: allow,
+						},
+						{
+							host:  "jwt-only.com",
+							path:  "/",
+							token: jwt.TokenIssuer1,
+							allow: true,
+						},
+						{
+							host:  "jwt-only.com",
+							path:  "/",
+							token: jwt.TokenIssuer2,
+							allow: false,
+						},
+						{
+							host:  fmt.Sprintf("jwt-and-%s-%s-only.com", allowed.Config().Service, allowed.Config().Namespace.Name()),
+							path:  "/",
+							token: jwt.TokenIssuer1,
+							allow: allow,
+						},
+						{
+							path:  "/",
+							host:  fmt.Sprintf("jwt-and-%s-%s-only.com", allowed.Config().Service, allowed.Config().Namespace.Name()),
+							token: jwt.TokenIssuer2,
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						c := c
+						testName := c.host + c.path + c.allow.String()
+						t.NewSubTest(testName).Run(func(t framework.TestContext) {
+							wantCode := http.StatusOK
+							body := "handled-by-egress-gateway"
+							if !c.allow {
+								wantCode = http.StatusForbidden
+								body = "RBAC: access denied"
+							}
+
+							opts := echo.CallOptions{
+								// Use a fake IP address to bypass DNS lookup (which will fail). The host
+								// header will be used for routing decisions.
+								Address: "10.4.4.4",
+								Port: echo.Port{
+									Name:        ports.HTTP,
+									Protocol:    protocol.HTTP,
+									ServicePort: 80,
+								},
+								HTTP: echo.HTTP{
+									Path:    c.path,
+									Headers: headers.New().WithHost(c.host).WithAuthz(c.token).Build(),
+								},
+								Check: check.And(check.NoErrorAndStatus(wantCode), check.BodyContains(body)),
+							}
+
+							from.CallOrFail(t, opts)
+						})
+					}
+				})
+		})
+}
+
+func TestAuthz_Conditions(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.conditions").
+		Run(func(t framework.TestContext) {
+			allowed := apps.Ns1.A
+			denied := apps.Ns2.A
+
+			from := allowed.Append(denied)
+			fromMatch := match.AnyServiceName(from.NamespacedNames())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/mtls.yaml.tmpl")).
+				Source(config.File("testdata/v1beta1/conditions.yaml.tmpl").WithParams(param.Params{
+					"Allowed": allowed,
+					"Denied":  denied,
+				})).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					allow := allowValue(from.NamespacedName() == allowed.Config().NamespacedName())
+
+					skipSourceIPTestsForMulticluster := func(t framework.TestContext) {
+						t.Helper()
+						if t.Clusters().IsMulticluster() {
+							// TODO(nmittler): Needs to be documented as a limitation for multi-network.
+							t.Skip("https://github.com/istio/istio/issues/37307: " +
+								"Source IP-based authz tests are not supported in multi-network configurations " +
+								"due to the fact that the origin source IP will be lost when traversing the " +
+								"east-west gateway.")
+						}
+					}
+
+					cases := []struct {
+						path    string
+						headers http.Header
+						allow   allowValue
+						skipFn  func(t framework.TestContext)
+					}{
+						// Test headers.
+						{
+							path:    "/request-headers",
+							headers: headers.New().With("x-foo", "foo").Build(),
+							allow:   true,
+						},
+						{
+							path:    "/request-headers",
+							headers: headers.New().With("x-foo", "bar").Build(),
+							allow:   false,
+						},
+						{
+							path:  "/request-headers",
+							allow: false,
+						},
+						{
+							path:    "/request-headers-notValues",
+							headers: headers.New().With("x-foo", "foo").Build(),
+							allow:   true,
+						},
+						{
+							path:    "/request-headers-notValues",
+							headers: headers.New().With("x-foo", "bar").Build(),
+							allow:   false,
+						},
+
+						// Test source IP
+						{
+							path:   "/source-ip",
+							allow:  allow,
+							skipFn: skipSourceIPTestsForMulticluster,
+						},
+						{
+							path:   "/source-ip-notValues",
+							allow:  allow,
+							skipFn: skipSourceIPTestsForMulticluster,
+						},
+
+						// Test source namespace
+						{
+							path:  "/source-namespace",
+							allow: allow,
+						},
+						{
+							path:  "/source-namespace-notValues",
+							allow: allow,
+						},
+
+						// Test source principal
+						{
+							path:  "/source-principal",
+							allow: allow,
+						},
+						{
+							path:  "/source-principal-notValues",
+							allow: allow,
+						},
+
+						// Test destination IP
+						{
+							path:  "/destination-ip-good",
+							allow: true,
+						},
+						{
+							path:  "/destination-ip-bad",
+							allow: false,
+						},
+						{
+							path:  "/destination-ip-notValues",
+							allow: false,
+						},
+
+						// Test destination port
+						{
+							path:  "/destination-port-good",
+							allow: true,
+						},
+						{
+							path:  "/destination-port-bad",
+							allow: false,
+						},
+						{
+							path:  "/destination-port-notValues",
+							allow: false,
+						},
+
+						// Test SNI
+						{
+							path:  "/connection-sni-good",
+							allow: true,
+						},
+						{
+							path:  "/connection-sni-bad",
+							allow: false,
+						},
+						{
+							path:  "/connection-sni-notValues",
+							allow: false,
+						},
+
+						{
+							path:  "/other",
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						c := c
+						xfooHeader := ""
+						if c.headers != nil {
+							xfooHeader = "?x-foo=" + c.headers.Get("x-foo")
+						}
+						testName := c.path + xfooHeader + c.allow.String()
+						t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+							if c.skipFn != nil {
+								c.skipFn(t)
+							}
+
+							newAuthzTest().
+								From(from).
+								To(to).
+								PortName(ports.HTTP).
+								Path(c.path).
+								Allow(c.allow).
+								Headers(c.headers).
+								BuildAndRun(t)
+						})
+					}
+				})
+		})
+}
+
+func TestAuthz_PathNormalization(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.path-normalization").
+		Run(func(t framework.TestContext) {
+			from := apps.Ns1.A
+			fromMatch := match.ServiceName(from.NamespacedName())
+			toMatch := match.Not(fromMatch)
+			to := toMatch.GetServiceMatches(apps.Ns1.All)
+			fromAndTo := to.Instances().Append(from)
+
+			config.New(t).
+				Source(config.File("testdata/v1beta1/path-normalization.yaml.tmpl")).
+				BuildAll(nil, to).
+				Apply()
+
+			newTrafficTest(t, fromAndTo).
+				FromMatch(fromMatch).
+				ToMatch(toMatch).
+				Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+					cases := []struct {
+						path  string
+						allow allowValue
+					}{
+						{
+							path:  "/public",
+							allow: true,
+						},
+						{
+							path:  "/public/../public",
+							allow: true,
+						},
+						{
+							path:  "/private",
+							allow: false,
+						},
+						{
+							path:  "/public/../private",
+							allow: false,
+						},
+						{
+							path:  "/public/./../private",
+							allow: false,
+						},
+						{
+							path:  "/public/.././private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2E%2E/private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2e%2e/private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2E/%2E%2E/private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2e/%2e%2e/private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2E%2E/%2E/private",
+							allow: false,
+						},
+						{
+							path:  "/public/%2e%2e/%2e/private",
+							allow: false,
+						},
+					}
+
+					for _, c := range cases {
+						c := c
+						testName := c.path + c.allow.String()
+						t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+							newAuthzTest().
+								From(from).
+								To(to).
+								PortName(ports.HTTP).
+								Path(c.path).
+								Allow(c.allow).
+								BuildAndRun(t)
+						})
+					}
+				})
+		})
+}
+
+func TestAuthz_CustomServer(t *testing.T) {
+	framework.NewTest(t).
+		Features("security.authorization.custom").
+		Run(func(t framework.TestContext) {
+			extAuthzHeaders := func(value string) http.Header {
+				return headers.New().
+					With(authz.XExtAuthz, value).
+					With(authz.XExtAuthzAdditionalHeaderOverride, "should-be-override").
+					Build()
+			}
+			allowHeaders := func() http.Header {
+				return extAuthzHeaders(authz.XExtAuthzAllow)
+			}
+			denyHeaders := func() http.Header {
+				return extAuthzHeaders("deny")
+			}
+
+			allProviders := append(authzServer.Providers(), localAuthzServer.Providers()...)
+			for _, provider := range allProviders {
+				t.NewSubTest(provider.Name()).Run(func(t framework.TestContext) {
+					// The ext-authz server is hard-coded to allow requests from any service account ending in
+					// "/sa/a". Since the namespace is ignored, we use ns2.B for our denied app (rather than ns2.A).
+					// We'll only need the service account for TCP, since we send headers in all other protocols
+					// to control the server's behavior.
+					allowed := apps.Ns1.A
+					var denied echo.Instances
+					if provider.IsProtocolSupported(protocol.TCP) {
+						denied = apps.Ns2.B
+					}
+
+					from := allowed.Append(denied)
+					fromMatch := match.AnyServiceName(from.NamespacedNames())
+					toMatch := match.And(match.Not(fromMatch), provider.MatchSupportedTargets())
+					to := toMatch.GetServiceMatches(apps.Ns1.All)
+					fromAndTo := to.Instances().Append(from)
+
+					config.New(t).
+						Source(config.File("testdata/v1beta1/custom-provider.yaml.tmpl").WithParams(param.Params{
+							"Provider": provider,
+						})).
+						BuildAll(nil, to).
+						Apply()
+
+					newTrafficTest(t, fromAndTo).
+						FromMatch(fromMatch).
+						ToMatch(toMatch).
+						Run(func(t framework.TestContext, from echo.Instance, to echo.Target) {
+							fromAllowed := from.NamespacedName() == allowed.NamespacedName()
+
+							authzPath := "/custom"
+							cases := []struct {
+								ports   []string
+								path    string
+								headers http.Header
+								allow   allowValue
+								skip    bool
+							}{
+								{
+									ports: []string{ports.TCP},
+									// For TCP, we rely on the hard-coded allowed service account.
+									allow: allowValue(fromAllowed),
+								},
+								{
+									ports:   []string{ports.HTTP, ports.HTTP2, ports.GRPC},
+									path:    authzPath,
+									headers: allowHeaders(),
+									allow:   true,
+									skip:    !fromAllowed,
+								},
+								{
+									ports:   []string{ports.HTTP, ports.HTTP2, ports.GRPC},
+									path:    authzPath,
+									headers: denyHeaders(),
+									allow:   false,
+									skip:    !fromAllowed,
+								},
+								{
+									ports:   []string{ports.HTTP, ports.HTTP2},
+									path:    "/health",
+									headers: extAuthzHeaders(authz.XExtAuthzAllow),
+									allow:   true,
+									skip:    !fromAllowed,
+								},
+								{
+									ports:   []string{ports.HTTP, ports.HTTP2},
+									path:    "/health",
+									headers: extAuthzHeaders("deny"),
+									allow:   true,
+									skip:    !fromAllowed,
+								},
+							}
+
+							for _, c := range cases {
+								c := c
+								if c.skip {
+									continue
+								}
+								tsts := newAuthzTest().
+									From(from).
+									To(to).
+									Path(c.path).
+									Headers(c.headers).
+									Allow(c.allow).
+									BuildForPorts(t, c.ports...).
+									Filter(func(tst authzTest) bool {
+										return provider.IsProtocolSupported(tst.opts.Port.Protocol)
+									})
+								for _, tst := range tsts {
+									params := ""
+									if c.headers != nil {
+										params = fmt.Sprintf("?%s=%s", authz.XExtAuthz, c.headers.Get(authz.XExtAuthz))
+									}
+									testName := fmt.Sprintf("[%s]%s%s(%s)", tst.opts.Port.Name, c.path, params, c.allow)
+									t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+										if c.path == authzPath {
+											tst.opts.Check = check.And(tst.opts.Check, provider.Check(tst.opts, c.allow.Bool()))
+										}
+
+										tst.Run(t)
+									})
+								}
+							}
+						})
+				})
+			}
+		})
+}
+
+func newTrafficTest(t framework.TestContext, echos ...echo.Instances) *echotest.T {
+	var all []echo.Instance
+	for _, e := range echos {
+		all = append(all, e...)
+	}
+
+	return echotest.New(t, all).
+		WithDefaultFilters().
+		FromMatch(match.And(
+			match.NotNaked,
+			match.NotProxylessGRPC)).
+		ToMatch(match.And(
+			match.NotNaked,
+			match.NotProxylessGRPC)).
+		ConditionallyTo(func(from echo.Instance, to echo.Instances) echo.Instances {
+			// Disallow self-calls since it will bypass the sidecar.
+			return match.Not(match.ServiceName(from.NamespacedName())).GetMatches(to)
+		})
+}
+
+type allowValue bool
+
+func (v allowValue) Bool() bool {
+	return bool(v)
+}
+
+func (v allowValue) String() string {
+	if v {
+		return "allow"
+	}
+	return "deny"
+}
+
+type authzTest struct {
+	from   echo.Instance
+	opts   echo.CallOptions
+	allow  allowValue
+	prefix string
+}
+
+func newAuthzTest() *authzTest {
+	return &authzTest{}
+}
+
+func (b *authzTest) Prefix(prefix string) *authzTest {
+	b.prefix = prefix
+	return b
+}
+
+func (b *authzTest) From(from echo.Instance) *authzTest {
+	b.from = from
+	return b
+}
+
+func (b *authzTest) To(to echo.Target) *authzTest {
+	b.opts.To = to
+	return b
+}
+
+func (b *authzTest) PortName(portName string) *authzTest {
+	b.opts.Port.Name = portName
+	return b
+}
+
+func (b *authzTest) Method(method string) *authzTest {
+	b.opts.HTTP.Method = method
+	return b
+}
+
+func (b *authzTest) Path(path string) *authzTest {
+	b.opts.HTTP.Path = path
+	return b
+}
+
+func (b *authzTest) Headers(headers http.Header) *authzTest {
+	b.opts.HTTP.Headers = headers
+	return b
+}
+
+func (b *authzTest) Allow(allow allowValue) *authzTest {
+	b.allow = allow
+	return b
+}
+
+func (b *authzTest) Build(t framework.TestContext) *authzTest {
+	t.Helper()
+
+	// Fill in the defaults.
+	b.opts.FillDefaultsOrFail(t)
+
+	if b.allow {
+		b.opts.Check = check.And(check.OK(), check.ReachedTargetClusters(t.Clusters()))
+	} else {
+		b.opts.Check = check.Forbidden(b.opts.Port.Protocol)
+	}
+	return b
+}
+
+func (b *authzTest) BuildForPorts(t framework.TestContext, ports ...string) authzTests {
+	out := make(authzTests, 0, len(ports))
+	for _, p := range ports {
+		opts := b.opts.DeepCopy()
+		opts.Port.Name = p
+
+		tst := (&authzTest{
+			prefix: b.prefix,
+			from:   b.from,
+			opts:   opts,
+			allow:  b.allow,
+		}).Build(t)
+		out = append(out, *tst)
+	}
+	return out
+}
+
+func (b *authzTest) BuildAndRunForPorts(t framework.TestContext, ports ...string) {
+	tsts := b.BuildForPorts(t, ports...)
+	tsts.RunAll(t)
+}
+
+func (b *authzTest) Run(t framework.TestContext) {
+	t.Helper()
+	b.from.CallOrFail(t, b.opts)
+}
+
+func (b *authzTest) BuildAndRun(t framework.TestContext) {
+	t.Helper()
+	b.Build(t).Run(t)
+}
+
+type authzTests []authzTest
+
+func (tsts authzTests) checkValid() {
+	path := tsts[0].opts.HTTP.Path
+	allow := tsts[0].allow
+	prefix := tsts[0].prefix
+	for _, tst := range tsts {
+		if tst.opts.HTTP.Path != path {
+			panic("authz tests have different paths")
+		}
+		if tst.allow != allow {
+			panic("authz tests have different allow")
+		}
+		if tst.prefix != prefix {
+			panic("authz tests have different prefixes")
+		}
+	}
+}
+
+func (tsts authzTests) Filter(keep func(authzTest) bool) authzTests {
+	out := make(authzTests, 0, len(tsts))
+	for _, tst := range tsts {
+		if keep(tst) {
+			out = append(out, tst)
+		}
+	}
+	return out
+}
+
+func (tsts authzTests) RunAll(t framework.TestContext) {
+	t.Helper()
+
+	firstTest := tsts[0]
+	if len(tsts) == 1 {
+		// Testing a single port. Just run a single test.
+		testName := fmt.Sprintf("%s[%s]%s(%s)", firstTest.prefix, firstTest.opts.Port.Name, firstTest.opts.HTTP.Path, firstTest.allow)
+		t.NewSubTest(testName).RunParallel(func(t framework.TestContext) {
+			firstTest.BuildAndRun(t)
+		})
+		return
+	}
+
+	tsts.checkValid()
+
+	// Testing multiple ports...
+	// Name outer test with constant info. Name inner test with port.
+	outerTestName := fmt.Sprintf("%s%s(%s)", firstTest.prefix, firstTest.opts.HTTP.Path, firstTest.allow)
+	t.NewSubTest(outerTestName).RunParallel(func(t framework.TestContext) {
+		for _, tst := range tsts {
+			tst := tst
+			t.NewSubTest(tst.opts.Port.Name).RunParallel(func(t framework.TestContext) {
+				tst.BuildAndRun(t)
+			})
+		}
+	})
+}
diff --git a/tests/integration/security/authz/main_test.go b/tests/integration/security/authz/main_test.go
new file mode 100644
index 0000000000..0a69676da7
--- /dev/null
+++ b/tests/integration/security/authz/main_test.go
@@ -0,0 +1,56 @@
+//go:build integ
+// +build integ
+
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package security
+
+import (
+	"testing"
+
+	"istio.io/istio/pkg/test/framework"
+	"istio.io/istio/pkg/test/framework/components/authz"
+	"istio.io/istio/pkg/test/framework/components/echo/common/deployment"
+	"istio.io/istio/pkg/test/framework/components/istio"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/test/framework/resource"
+)
+
+var (
+	apps             deployment.TwoNamespaceView
+	authzServer      authz.Server
+	localAuthzServer authz.Server
+)
+
+func TestMain(m *testing.M) {
+	framework.
+		NewSuite(m).
+		Setup(istio.Setup(nil, func(_ resource.Context, cfg *istio.Config) {
+			cfg.ControlPlaneValues = `
+values:
+  pilot: 
+    env: 
+      PILOT_JWT_ENABLE_REMOTE_JWKS: true
+meshConfig:
+  defaultConfig:
+    gatewayTopology:
+      numTrustedProxies: 1 # Needed for X-Forwarded-For (See https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/)
+`
+		})).
+		Setup(authz.Setup(&authzServer, nil)).
+		Setup(deployment.SetupTwoNamespaces(&apps, deployment.Config{IncludeExtAuthz: true})).
+		Setup(authz.SetupLocal(&localAuthzServer, func() namespace.Instance { return apps.Ns1.Namespace })).
+		Run()
+}
diff --git a/tests/integration/security/authz/testdata/v1beta1/allow-namespace.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/allow-namespace.yaml.tmpl
new file mode 100644
index 0000000000..3ad394c5e1
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/allow-namespace.yaml.tmpl
@@ -0,0 +1,32 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+        - operation: # HTTP
+            ports: [ "{{ (.To.PortForName `http`).WorkloadPort }}", "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
+            paths: [ "/allow" ]
+            methods: [ "GET" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Allowed.NamespaceName }}" ]
+    - to:
+        - operation: # GRPC
+            ports: [ "{{ (.To.PortForName `grpc`).WorkloadPort }}" ]
+            paths: [ "/proto.EchoTestService/Echo" ]
+            methods: [ "POST" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Allowed.NamespaceName }}" ]
+    - to:
+        - operation: # TCP
+            ports: [ "{{ (.To.PortForName `tcp`).WorkloadPort }}" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Allowed.NamespaceName }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/allow-principal.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/allow-principal.yaml.tmpl
new file mode 100644
index 0000000000..79caaa6492
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/allow-principal.yaml.tmpl
@@ -0,0 +1,32 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+        - operation: # HTTP
+            ports: [ "{{ (.To.PortForName `http`).WorkloadPort }}", "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
+            paths: [ "/allow" ]
+            methods: [ "GET" ]
+      from:
+        - source:
+            principals: [ "{{ .Allowed.ServiceAccountName }}" ]
+    - to:
+        - operation: # GRPC
+            ports: [ "{{ (.To.PortForName `grpc`).WorkloadPort }}" ]
+            paths: [ "/proto.EchoTestService/Echo" ]
+            methods: [ "POST" ]
+      from:
+        - source:
+            principals: [ "{{ .Allowed.ServiceAccountName }}" ]
+    - to:
+        - operation: # TCP
+            ports: [ "{{ (.To.PortForName `tcp`).WorkloadPort }}" ]
+      from:
+        - source:
+            principals: [ "{{ .Allowed.ServiceAccountName }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/conditions.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/conditions.yaml.tmpl
new file mode 100644
index 0000000000..65f98e17e3
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/conditions.yaml.tmpl
@@ -0,0 +1,178 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-request-headers
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/request-headers" ]
+    when:
+    - key: request.headers[x-foo]
+      values: [ "foo" ]
+  - to:
+      - operation:
+          paths: [ "/request-headers-notValues" ]
+    when:
+      - key: request.headers[x-foo]
+        notValues: [ "bar" ]
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-source-ip
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/source-ip" ]
+    when:
+    - key: source.ip
+      values: {{ .Allowed.MustWorkloads.Addresses | toJson }}
+  - to:
+      - operation:
+          paths: [ "/source-ip-notValues" ]
+    when:
+      - key: source.ip
+        notValues: {{ .Denied.MustWorkloads.Addresses | toJson }}
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-source-namespace
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/source-namespace" ]
+    when:
+    - key: source.namespace
+      values: [ "{{ .Allowed.NamespaceName }}" ]
+  - to:
+      - operation:
+          paths: [ "/source-namespace-notValues" ]
+    when:
+      - key: source.namespace
+        notValues: [ "{{ .Denied.NamespaceName }}" ]
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-source-principal
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/source-principal" ]
+    when:
+    - key: source.principal
+      values: [ "{{ .Allowed.ServiceAccountName }}" ]
+  - to:
+      - operation:
+          paths: [ "/source-principal-notValues" ]
+    when:
+      - key: source.principal
+        notValues: [ "{{ .Denied.ServiceAccountName }}" ]
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-destination-ip
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/destination-ip-good" ]
+    when:
+    - key: destination.ip
+      values: {{ .To.MustWorkloads.Addresses | toJson }}
+  - to:
+    - operation:
+        paths: [ "/destination-ip-bad" ]
+    when:
+    - key: destination.ip
+      values: [ "1.2.3.4" ]
+  - to:
+      - operation:
+          paths: [ "/destination-ip-notValues" ]
+    when:
+      - key: destination.ip
+        notValues: {{ .To.MustWorkloads.Addresses | toJson }}
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-destination-port
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/destination-port-good" ]
+    when:
+    - key: destination.port
+      values: [ "{{ ( .To.PortForName `http` ).WorkloadPort }}" ]
+  - to:
+    - operation:
+        paths: [ "/destination-port-bad" ]
+    when:
+    - key: destination.port
+      values: [ "1" ]
+  - to:
+      - operation:
+          paths: [ "/destination-port-notValues" ]
+    when:
+      - key: destination.port
+        notValues: [ "{{ ( .To.PortForName `http` ).WorkloadPort }}" ]
+---
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-connection-sni
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/connection-sni-good" ]
+    when:
+    - key: connection.sni
+      values: [ "*.{{ .To.ClusterLocalFQDN }}" ]
+  - to:
+    - operation:
+        paths: [ "/connection-sni-bad" ]
+    when:
+    - key: connection.sni
+      values: [ "never-matched" ]
+  - to:
+      - operation:
+          paths: [ "/connection-sni-notValues" ]
+    when:
+      - key: connection.sni
+        notValues: [ "*.{{ .To.ClusterLocalFQDN }}" ]
+---
diff --git a/tests/integration/security/authz/testdata/v1beta1/custom-provider.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/custom-provider.yaml.tmpl
new file mode 100644
index 0000000000..de0a7d4769
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/custom-provider.yaml.tmpl
@@ -0,0 +1,25 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: custom-{{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: CUSTOM
+  provider:
+    name: "{{ .Provider.Name }}"
+  rules:
+  - to:
+    - operation: # HTTP
+        ports: [ "{{ (.To.PortForName `http`).WorkloadPort }}", "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
+        paths: [ "/custom" ]
+        methods: [ "GET" ]
+  - to:
+    - operation: # GRPC
+        ports: [ "{{ (.To.PortForName `grpc`).WorkloadPort }}" ]
+        paths: [ "/proto.EchoTestService/Echo" ]
+        methods: [ "POST" ]
+  - to:
+    - operation: # TCP
+        ports: [ "{{ (.To.PortForName `tcp`).WorkloadPort }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/deny-global.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/deny-global.yaml.tmpl
new file mode 100644
index 0000000000..819fec76e8
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/deny-global.yaml.tmpl
@@ -0,0 +1,21 @@
+# The following policy denies access to path /global-deny for all workloads
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-deny-system
+spec:
+  action: DENY
+  rules:
+  - to:
+    - operation:
+        # Generally we don't expect users to set global policies, since they
+        # impact anything in the istio-system namespace. For these tests,
+        # the target port is needed to avoid the DENY policy also applying to
+        # traffic through the eastwest-gateway. Since all eastwest-gateway
+        # traffic is TCP, the policy will attempt to be as restrictive as
+        # possible and block all traffic through the eastwest-gateway.
+        ports: [ "18080", "18085" ]
+        paths: ["/global-deny*"]
+        notPaths: ["/global-deny/allow"]
+---
diff --git a/tests/integration/security/authz/testdata/v1beta1/deny-namespace.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/deny-namespace.yaml.tmpl
new file mode 100644
index 0000000000..87c84d99e9
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/deny-namespace.yaml.tmpl
@@ -0,0 +1,33 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: DENY
+  rules:
+    - to:
+        - operation: # HTTP
+            ports: [ "{{ (.To.PortForName `http`).WorkloadPort }}", "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
+            paths: [ "/deny*" ]
+            notPaths: ["/deny/allow"]
+            methods: [ "GET" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Denied.NamespaceName }}" ]
+    - to:
+        - operation: # GRPC
+            ports: [ "{{ (.To.PortForName `grpc`).WorkloadPort }}" ]
+            paths: [ "/proto.EchoTestService/Echo" ]
+            methods: [ "POST" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Denied.NamespaceName }}" ]
+    - to:
+        - operation: # TCP
+            ports: [ "{{ (.To.PortForName `tcp`).WorkloadPort }}" ]
+      from:
+        - source:
+            namespaces: [ "{{ .Denied.NamespaceName }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/deny-principal.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/deny-principal.yaml.tmpl
new file mode 100644
index 0000000000..fde6dba9f7
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/deny-principal.yaml.tmpl
@@ -0,0 +1,33 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: DENY
+  rules:
+    - to:
+        - operation: # HTTP
+            ports: [ "{{ (.To.PortForName `http`).WorkloadPort }}", "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
+            paths: [ "/deny*" ]
+            notPaths: ["/deny/allow"]
+            methods: [ "GET" ]
+      from:
+        - source:
+            principals: [ "{{ .Denied.ServiceAccountName }}" ]
+    - to:
+        - operation: # GRPC
+            ports: [ "{{ (.To.PortForName `grpc`).WorkloadPort }}" ]
+            paths: [ "/proto.EchoTestService/Echo" ]
+            methods: [ "POST" ]
+      from:
+        - source:
+            principals: [ "{{ .Denied.ServiceAccountName }}" ]
+    - to:
+        - operation: # TCP
+            ports: [ "{{ (.To.PortForName `tcp`).WorkloadPort }}" ]
+      from:
+        - source:
+            principals: [ "{{ .Denied.ServiceAccountName }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/egress-gateway.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/egress-gateway.yaml.tmpl
new file mode 100644
index 0000000000..6e575273a2
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/egress-gateway.yaml.tmpl
@@ -0,0 +1,178 @@
+apiVersion: security.istio.io/v1beta1
+kind: RequestAuthentication
+metadata:
+  name: default
+  namespace: {{ .SystemNamespace.Name }}
+spec:
+  jwtRules:
+    - issuer: "test-issuer-1@istio.io"
+      jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
+    - issuer: "test-issuer-2@istio.io"
+      jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
+---
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: egressgateway
+  namespace: {{ .SystemNamespace.Name }}
+spec:
+  selector:
+    matchLabels:
+      app: istio-egressgateway
+  rules:
+    - to: # only allow /allow for company.com
+        - operation:
+            paths: [ "/allow" ]
+            hosts: [ "www.company.com" ]
+    - to: # checks only a call 443 over istio mutual without JWT
+        - operation:
+            hosts: [ "{{ .Allowed.ServiceName }}-{{ .Allowed.NamespaceName }}-only.com" ]
+      from:
+        - source:
+            principals: [ "{{ .Allowed.ServiceAccountName }}" ]
+    - to: # checks workload can call 443 over istio mutual with JWT
+        - operation:
+            hosts: [ "jwt-only.com" ]
+      from:
+        - source:
+            requestPrincipals: [ "test-issuer-1@istio.io/sub-1" ]
+    - to: # checks only a can call 443 over istio mutual with JWT
+        - operation:
+            hosts: [ "jwt-and-{{ .Allowed.ServiceName }}-{{ .Allowed.NamespaceName }}-only.com" ]
+      from:
+        - source:
+            requestPrincipals: [ "test-issuer-1@istio.io/sub-1" ]
+            principals: [ "{{ .Allowed.ServiceAccountName }}" ]
+---
+# The following policy redirects the request through egress gateway.
+
+apiVersion: networking.istio.io/v1beta1
+kind: Gateway
+metadata:
+  name: test-egress
+  namespace: {{ .From.NamespaceName }}
+spec:
+  selector:
+    istio: egressgateway
+  servers:
+    - port:
+        number: 80
+        name: http
+        protocol: HTTP
+      hosts:
+        - "www.company.com"
+    - port:
+        number: 443
+        name: https
+        protocol: HTTPS
+      tls:
+        mode: ISTIO_MUTUAL
+      hosts:
+        - "*"
+---
+
+apiVersion: networking.istio.io/v1beta1
+kind: VirtualService
+metadata:
+  name: route-via-egressgateway
+  namespace: {{ .From.NamespaceName }}
+spec:
+  hosts:
+    - "www.company.com"
+  gateways:
+    - test-egress
+    - mesh
+  http:
+    - match:
+        - gateways:
+            - mesh
+          port: 80
+      route:
+        - destination:
+            host: "istio-egressgateway.{{ .SystemNamespace.Name }}.svc.cluster.local"
+            port:
+              number: 80
+          weight: 100
+    - match:
+        - gateways:
+            - test-egress
+          port: 80
+      route:
+        - destination:
+            host: "{{ .To.ClusterLocalFQDN }}"
+            port:
+              number: {{ (.To.PortForName "http").ServicePort }}
+          weight: 100
+      headers:
+        request:
+          add:
+            x-egress-test: "handled-by-egress-gateway"
+---
+apiVersion: networking.istio.io/v1beta1
+kind: VirtualService
+metadata:
+  name: route-via-egressgateway-2
+  namespace: {{ .From.NamespaceName }}
+spec:
+  hosts:
+    - "{{ .Allowed.ServiceName }}-{{ .Allowed.NamespaceName }}-only.com"
+    - "jwt-only.com"
+    - "jwt-and-{{ .Allowed.ServiceName }}-{{ .Allowed.NamespaceName }}-only.com"
+  gateways:
+    - test-egress
+    - mesh
+  http:
+    - match:
+        - gateways:
+            - mesh
+          port: 80
+      route:
+        - destination:
+            host: "istio-egressgateway.{{ .SystemNamespace.Name }}.svc.cluster.local"
+            port:
+              number: 443
+          weight: 100
+    - match:
+        - gateways:
+            - test-egress
+          port: 443
+      route:
+        - destination:
+            host: "{{ .To.ClusterLocalFQDN }}"
+            port:
+              number: {{ (.To.PortForName "http").ServicePort }}
+          weight: 100
+      headers:
+        request:
+          add:
+            x-egress-test: "handled-by-egress-gateway"
+---
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: test-egress
+  namespace: {{ .From.NamespaceName }}
+spec:
+  host: "istio-egressgateway.{{ .SystemNamespace.Name }}.svc.cluster.local"
+  trafficPolicy:
+    portLevelSettings:
+      - port:
+          number: 443
+        tls:
+          mode: ISTIO_MUTUAL
+---
+# TODO(nmittler): Shouldn't need this. Workaround for https://github.com/istio/istio/issues/38704.
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: test-egress
+  namespace: {{ .SystemNamespace.Name }}
+spec:
+  host: "istio-egressgateway.{{ .SystemNamespace.Name }}.svc.cluster.local"
+  trafficPolicy:
+    portLevelSettings:
+      - port:
+          number: 443
+        tls:
+          mode: ISTIO_MUTUAL
+---
diff --git a/tests/integration/security/authz/testdata/v1beta1/ingress-gateway.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/ingress-gateway.yaml.tmpl
new file mode 100644
index 0000000000..1ff3f46e0a
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/ingress-gateway.yaml.tmpl
@@ -0,0 +1,86 @@
+# The following policy denies access to "internal.{{ .To.ServiceName }}.company.com"
+# and path "/private", denies access from 172.17.72.46 or 192.168.4.0/23 to
+# "remoteipblocks.{{ .To.ServiceName }}.company.com", denies access from anything
+# but 172.23.240.0/22 to "notremoteipblocks.{{ .To.ServiceName }}.company.com",
+# and denies access to "remoteipattr.{{ .To.ServiceName }}.company.com" when the
+# remote ip is 10.242.5.7 or in the network 10.124.99.0/24.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .To.ServiceName }}
+  namespace: {{ .SystemNamespace.Name }}
+spec:
+  action: DENY
+  selector:
+    matchLabels:
+      app: istio-ingressgateway
+  rules:
+    - to:
+        - operation:
+            hosts: [
+              "deny.{{ .To.ServiceName }}.com",
+              "*.suffix.{{ .To.ServiceName }}.com",
+              "prefix.{{ .To.ServiceName }}.*"]
+    - to:
+        - operation:
+            hosts: ["internal.{{ .To.ServiceName }}.com"]
+        - operation:
+            paths: ["/private"]
+    - from:
+        - source:
+            remoteIpBlocks: ["172.17.72.46", "192.168.4.0/23"]
+      to:
+        - operation:
+            hosts: ["remoteipblocks.{{ .To.ServiceName }}.com"]
+    - from:
+        - source:
+            notRemoteIpBlocks: ["172.23.240.0/22"]
+      to:
+        - operation:
+            hosts: ["notremoteipblocks.{{ .To.ServiceName }}.com"]
+    - to:
+        - operation:
+            hosts: ["remoteipattr.{{ .To.ServiceName }}.com"]
+      when:
+        - key: remote.ip
+          values: ["10.242.5.7", "10.124.99.0/24"]
+---
+
+# The following gateway allows request to "*.{{ .To.ServiceName }}.com"
+
+apiVersion: networking.istio.io/v1beta1
+kind: Gateway
+metadata:
+  name: gw-{{ .To.ServiceName }}
+  namespace: {{ .To.NamespaceName }}
+spec:
+  selector:
+    istio: ingressgateway # use istio default ingress gateway
+  servers:
+    - port:
+        number: 80
+        name: http
+        protocol: HTTP
+      hosts:
+        - "*.{{ .To.ServiceName }}.com"
+---
+
+# The following virtual service routes requests to workload
+
+apiVersion: networking.istio.io/v1beta1
+kind: VirtualService
+metadata:
+  name: vs-{{ .To.ServiceName }}
+  namespace: {{ .To.NamespaceName }}
+spec:
+  hosts:
+  - "*.{{ .To.ServiceName }}.com"
+  gateways:
+  - gw-{{ .To.ServiceName }}
+  http:
+  - route:
+    - destination:
+        host: "{{ .To.ClusterLocalFQDN }}"
+        port:
+          number: {{ (.To.PortForName "http").ServicePort }}
diff --git a/tests/integration/security/testdata/authz/v1beta1-jwt.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/jwt.yaml.tmpl
similarity index 92%
rename from tests/integration/security/testdata/authz/v1beta1-jwt.yaml.tmpl
rename to tests/integration/security/authz/testdata/v1beta1/jwt.yaml.tmpl
index e571d51495..45652648cd 100644
--- a/tests/integration/security/testdata/authz/v1beta1-jwt.yaml.tmpl
+++ b/tests/integration/security/authz/testdata/v1beta1/jwt.yaml.tmpl
@@ -6,7 +6,6 @@ apiVersion: security.istio.io/v1beta1
 kind: RequestAuthentication
 metadata:
   name: default
-  namespace: {{ .Namespace }}
 spec:
   jwtRules:
   - issuer: "test-issuer-1@istio.io"
@@ -23,17 +22,15 @@ spec:
 # - Allow request with valid JWT token to access path /jwt1
 # - Allow request with valid JWT token of presenter foo to access path with suffix "/presenter"
 # - Allow request with valid JWT token of audiences bar to access path with suffix "/audiences"
-# - Deny request with JWT token from test-issuer-1@istio.io to access path with suffix "/token3" and "GET" method
 
 apiVersion: security.istio.io/v1beta1
 kind: AuthorizationPolicy
 metadata:
-  name: policy-{{ .dst }}
-  namespace: "{{ .Namespace }}"
+  name: {{ .To.ServiceName }}
 spec:
   selector:
     matchLabels:
-      "app": "{{ .dst }}"
+      "app": "{{ .To.ServiceName }}"
   rules:
   - to:
     - operation:
diff --git a/tests/integration/security/authz/testdata/v1beta1/mtls.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/mtls.yaml.tmpl
new file mode 100644
index 0000000000..7d20cbd451
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/mtls.yaml.tmpl
@@ -0,0 +1,20 @@
+apiVersion: security.istio.io/v1beta1
+kind: PeerAuthentication
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      app: "{{ .To.ServiceName }}"
+  mtls:
+    mode: STRICT
+---
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: {{ .To.ServiceName }}
+spec:
+  host: "{{ .To.ClusterLocalFQDN }}"
+  trafficPolicy:
+    tls:
+      mode: ISTIO_MUTUAL
diff --git a/tests/integration/security/authz/testdata/v1beta1/not-host.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/not-host.yaml.tmpl
new file mode 100644
index 0000000000..f44420e7be
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/not-host.yaml.tmpl
@@ -0,0 +1,45 @@
+apiVersion: networking.istio.io/v1beta1
+kind: Gateway
+metadata:
+  name: gw-{{ .To.ServiceName }}
+spec:
+  selector:
+    istio: ingressgateway # use istio default ingress gateway
+  servers:
+    - port:
+        number: 80
+        name: http
+        protocol: HTTP
+      hosts:
+        - "*.{{ .To.ServiceName }}.com"
+---
+apiVersion: networking.istio.io/v1beta1
+kind: VirtualService
+metadata:
+  name: vw-{{ .To.ServiceName }}
+spec:
+  hosts:
+    - "allow.{{ .To.ServiceName }}.com"
+    - "deny.{{ .To.ServiceName }}.com"
+  gateways:
+    - gw-{{ .To.ServiceName }}
+  http:
+    - route:
+        - destination:
+            host: "{{ .To.ClusterLocalFQDN }}"
+            port:
+              number: {{ (.To.PortForName "http").ServicePort }}
+---
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: allow-{{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+      - operation:
+          notHosts: [ "deny.{{ .To.ServiceName }}.com" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/not-method.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/not-method.yaml.tmpl
new file mode 100644
index 0000000000..aef3ab4a54
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/not-method.yaml.tmpl
@@ -0,0 +1,13 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-allow
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+      - operation:
+          notMethods: [ "PUT" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/not-namespace.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/not-namespace.yaml.tmpl
new file mode 100644
index 0000000000..13e06ba441
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/not-namespace.yaml.tmpl
@@ -0,0 +1,13 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-deny
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: DENY
+  rules:
+    - from:
+      - source:
+          notNamespaces: [ "{{ .Allowed.NamespaceName }}" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/not-port.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/not-port.yaml.tmpl
new file mode 100644
index 0000000000..510270c5a5
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/not-port.yaml.tmpl
@@ -0,0 +1,13 @@
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}-allow
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+      - operation:
+          notPorts: [ "{{ (.To.PortForName `http2`).WorkloadPort }}" ]
diff --git a/tests/integration/security/testdata/authz/v1beta1-audit-default.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/path-normalization.yaml.tmpl
similarity index 53%
rename from tests/integration/security/testdata/authz/v1beta1-audit-default.yaml.tmpl
rename to tests/integration/security/authz/testdata/v1beta1/path-normalization.yaml.tmpl
index 5c7efe48a6..5a9362a7c6 100644
--- a/tests/integration/security/testdata/authz/v1beta1-audit-default.yaml.tmpl
+++ b/tests/integration/security/authz/testdata/v1beta1/path-normalization.yaml.tmpl
@@ -1,15 +1,13 @@
 apiVersion: security.istio.io/v1beta1
 kind: AuthorizationPolicy
 metadata:
-  name: policy-audit
-  namespace: "{{ .Namespace }}"
+  name: {{ .To.ServiceName }}
 spec:
   selector:
     matchLabels:
-      "app": "{{ .dst }}"
-  action: AUDIT
+      "app": "{{ .To.ServiceName }}"
   rules:
   - to:
     - operation:
-        paths: ["/audit"]
----
+        paths: ["/public*"]
+        methods: ["GET"]
diff --git a/tests/integration/security/authz/testdata/v1beta1/path-precedence.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/path-precedence.yaml.tmpl
new file mode 100644
index 0000000000..c308b0aa2a
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/path-precedence.yaml.tmpl
@@ -0,0 +1,32 @@
+# The following policy denies access to path /allow/admin.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .To.ServiceName }}-deny
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: DENY
+  rules:
+    - to:
+        - operation:
+            paths: ["/allow/admin"]
+---
+# The following policy allows access to path with prefix /allow.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .To.ServiceName }}-allow
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: ALLOW
+  rules:
+    - to:
+        - operation:
+            paths: ["/allow*"]
+---
diff --git a/tests/integration/security/authz/testdata/v1beta1/plaintext.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/plaintext.yaml.tmpl
new file mode 100644
index 0000000000..7125ee7f05
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/plaintext.yaml.tmpl
@@ -0,0 +1,57 @@
+# This configures all services within the namespace to use mTLS with permissive mode (allowing plaintext).
+
+apiVersion: security.istio.io/v1beta1
+kind: PeerAuthentication
+metadata:
+  name: ns-default
+  namespace: {{ .To.NamespaceName }}
+spec:
+  mtls:
+    mode: PERMISSIVE
+
+---
+# This configures requests to any service in the namespace to use mTLS.
+
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: default
+  namespace: {{ .To.NamespaceName }}
+spec:
+  host: "*.{{ .To.NamespaceName }}.svc.cluster.local"
+  trafficPolicy:
+    tls:
+      mode: ISTIO_MUTUAL
+
+---
+# This authz policy denies access to the service if the request was not mTLS, since
+# mTLS is required in order to match source principals.
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: {{ .To.ServiceName }}
+  namespace: {{ .To.NamespaceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  action: DENY
+  rules:
+    - from:
+        - source:
+            notPrincipals: [ "*" ]
+
+---
+# This configures plaintext for the "To" service from any workload in the namespace.
+
+apiVersion: networking.istio.io/v1beta1
+kind: DestinationRule
+metadata:
+  name: {{ .To.ServiceName }}
+  namespace: {{ .Denied.NamespaceName }}
+spec:
+  host: "{{ .To.ClusterLocalFQDN }}"
+  trafficPolicy:
+    tls:
+      mode: DISABLE
diff --git a/tests/integration/security/authz/testdata/v1beta1/workload-bad.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/workload-bad.yaml.tmpl
new file mode 100644
index 0000000000..e2ad3a6e47
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/workload-bad.yaml.tmpl
@@ -0,0 +1,15 @@
+# The following policy selects a non-exist workload
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .To.ServiceName }}-bad
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+      "foo": "bla"
+  rules:
+    - to:
+        - operation:
+            paths: [ "/policy-{{ .To.Config.Namespace.Prefix }}-{{ .To.ServiceName }}-bad" ]
diff --git a/tests/integration/security/authz/testdata/v1beta1/workload-ns.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/workload-ns.yaml.tmpl
new file mode 100644
index 0000000000..42424c59ba
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/workload-ns.yaml.tmpl
@@ -0,0 +1,11 @@
+# The following policy selects all workloads in namespace 1
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .Namespace.Prefix }}-all
+spec:
+  rules:
+    - to:
+        - operation:
+            paths: ["/policy-{{ .Namespace.Prefix }}-all"]
diff --git a/tests/integration/security/authz/testdata/v1beta1/workload-system-ns.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/workload-system-ns.yaml.tmpl
new file mode 100644
index 0000000000..878e4dd4b5
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/workload-system-ns.yaml.tmpl
@@ -0,0 +1,15 @@
+# The following policy selects workloads for the service in all namespaces
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-system-{{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: ["/policy-system-{{ .To.ServiceName }}"]
+---
diff --git a/tests/integration/security/authz/testdata/v1beta1/workload.yaml.tmpl b/tests/integration/security/authz/testdata/v1beta1/workload.yaml.tmpl
new file mode 100644
index 0000000000..b145e0478d
--- /dev/null
+++ b/tests/integration/security/authz/testdata/v1beta1/workload.yaml.tmpl
@@ -0,0 +1,14 @@
+# The following policy selects the workload
+
+apiVersion: security.istio.io/v1beta1
+kind: AuthorizationPolicy
+metadata:
+  name: policy-{{ .To.ServiceName }}
+spec:
+  selector:
+    matchLabels:
+      "app": "{{ .To.ServiceName }}"
+  rules:
+  - to:
+    - operation:
+        paths: [ "/policy-{{ .To.Config.Namespace.Prefix }}-{{ .To.ServiceName }}" ]
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index a89905908d..dd9be31283 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -394,7 +394,8 @@ func TestIngressRequestAuthentication(t *testing.T) {
 			ns := apps.Namespace1
 
 			// Apply the policy.
-			t.ConfigIstio().EvalFile(newRootNS(t).Name(), map[string]string{
+			systemNS := istio.ClaimSystemNamespaceOrFail(t, t)
+			t.ConfigIstio().EvalFile(systemNS.Name(), map[string]string{
 				"Namespace":     ns.Name(),
 				"RootNamespace": istio.GetOrFail(t, t).Settings().SystemNamespace,
 			}, "testdata/requestauthn/global-jwt.yaml.tmpl").ApplyOrFail(t, apply.Wait)
diff --git a/tests/integration/security/testdata/authz/v1beta1-audit-allow.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-audit-allow.yaml.tmpl
deleted file mode 100644
index 68f8c64740..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-audit-allow.yaml.tmpl
+++ /dev/null
@@ -1,31 +0,0 @@
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-audit
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst }}"
-  action: AUDIT
-  rules:
-  - to:
-    - operation:
-        paths: ["/audit"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-audit-deny.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-audit-deny.yaml.tmpl
deleted file mode 100644
index f63f646b56..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-audit-deny.yaml.tmpl
+++ /dev/null
@@ -1,31 +0,0 @@
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-audit
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst }}"
-  action: AUDIT
-  rules:
-  - to:
-    - operation:
-        paths: ["/audit"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/deny"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-audit.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-audit.yaml.tmpl
deleted file mode 100644
index 4b8d53dc87..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-audit.yaml.tmpl
+++ /dev/null
@@ -1,78 +0,0 @@
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-audit
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: AUDIT
-  rules:
-  - to:
-    - operation:
-        paths: ["/audit"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-audit
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: AUDIT
-  rules:
-  - to:
-    - operation:
-        paths: ["/audit"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/deny"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .d }}-audit
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .d }}"
-  action: AUDIT
-  rules:
-  - to:
-    - operation:
-        paths: ["/audit"]
\ No newline at end of file
diff --git a/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
deleted file mode 100644
index 113d8cb12f..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-conditions.yaml.tmpl
+++ /dev/null
@@ -1,329 +0,0 @@
-# The following policy enables mTLS for server side workload.
-
-apiVersion: security.istio.io/v1beta1
-kind: PeerAuthentication
-metadata:
-  name: mtls
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  mtls:
-    mode: STRICT
----
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: mtls
-  namespace: "{{ .NamespaceC }}"
-spec:
-  host: "{{ .cSet }}.{{ .NamespaceC }}.svc.cluster.local"
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# Each of the following authorization policy uses a different condition on the given path.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-request-headers
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/request-headers"]
-    when:
-    - key: request.headers[x-foo]
-      values: ["foo"]
----
-
-# Each of the following authorization policy uses a different condition on the given path.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-request-headers-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/request-headers-notValues-bar"]
-    when:
-    - key: request.headers[x-foo]
-      notValues: ["bar"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-ip
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-ip-{{ .a }}"]
-    when:
-    - key: source.ip
-      values: {{ toJson .ipA }}
-  - to:
-    - operation:
-        paths: ["/source-ip-{{ .b }}"]
-    when:
-    - key: source.ip
-      values: {{ toJson .ipB }}
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-ip-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-ip-notValues-{{ .b }}"]
-    when:
-    - key: source.ip
-      notValues: {{ toJson .ipB }}
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-namespace
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-namespace-{{ .a }}"]
-    when:
-    - key: source.namespace
-      values: ["{{ .NamespaceA }}"]
-  - to:
-    - operation:
-        paths: ["/source-namespace-{{ .b }}"]
-    when:
-    - key: source.namespace
-      values: ["{{ .NamespaceB }}"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-namespace-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-namespace-notValues-{{ .b }}"]
-    when:
-    - key: source.namespace
-      notValues: ["{{ .NamespaceB }}"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-principal
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-principal-{{ .a }}"]
-    when:
-    - key: source.principal
-      values: ["cluster.local/ns/{{ .NamespaceA }}/sa/{{ .a }}"]
-  - to:
-    - operation:
-        paths: ["/source-principal-{{ .b }}"]
-    when:
-    - key: source.principal
-      values: ["cluster.local/ns/{{ .NamespaceB }}/sa/{{ .b }}"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-source-principal-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/source-principal-notValues-{{ .b }}"]
-    when:
-    - key: source.principal
-      notValues: ["cluster.local/ns/{{ .NamespaceB }}/sa/{{ .b }}"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-destination-ip
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/destination-ip-good"]
-    when:
-    - key: destination.ip
-      values: {{ toJson .ipC }}
-  - to:
-    - operation:
-        paths: ["/destination-ip-bad"]
-    when:
-    - key: destination.ip
-      values: ["1.2.3.4"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-destination-ip-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/destination-ip-notValues-{{ .a }}-or-{{ .b }}"]
-    when:
-    - key: destination.ip
-      notValues: {{ concat .ipA .ipB | toJson }}
-  - to:
-    - operation:
-        paths: ["/destination-ip-notValues-{{ .a }}-or-{{ .b }}-or-{{ .cSet }}"]
-    when:
-    - key: destination.ip
-      notValues: {{ concat .ipA .ipB .ipC | toJson }}
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-destination-port
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/destination-port-good"]
-    when:
-    - key: destination.port
-      values: ["{{ .portC }}"]
-  - to:
-    - operation:
-        paths: ["/destination-port-bad"]
-    when:
-    - key: destination.port
-      values: ["1"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-destination-port-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/destination-port-notValues-{{ .cSet }}"]
-    when:
-    - key: destination.port
-      notValues: ["{{ .portC }}"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-connection-sni
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/connection-sni-good"]
-    when:
-    - key: connection.sni
-      values: ["*.{{ .cSet }}.{{ .NamespaceC }}.svc.cluster.local"]
-  - to:
-    - operation:
-        paths: ["/connection-sni-bad"]
-    when:
-    - key: connection.sni
-      values: ["never-matched"]
----
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: condition-connection-sni-notvalues
-  namespace: "{{ .NamespaceC }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .cSet }}
-  rules:
-  - to:
-    - operation:
-        paths: ["/connection-sni-notValues-{{ .a }}-or-{{ .b }}"]
-    when:
-    - key: connection.sni
-      notValues: ["*.{{ .a }}.{{ .NamespaceA }}.svc.cluster.local", "*.{{ .b }}.{{ .NamespaceB }}.svc.cluster.local"]
-  - to:
-    - operation:
-        paths: ["/connection-sni-notValues-{{ .a }}-or-{{ .b }}-or-{{ .cSet }}"]
-    when:
-    - key: connection.sni
-      notValues: ["*.{{ .a }}.{{ .NamespaceA }}.svc.cluster.local", "*.{{ .b }}.{{ .NamespaceB }}.svc.cluster.local", "*.{{ .cSet }}.{{ .NamespaceC }}.svc.cluster.local"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-custom.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-custom.yaml.tmpl
deleted file mode 100644
index cd957abfcf..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-custom.yaml.tmpl
+++ /dev/null
@@ -1,158 +0,0 @@
-# The following policy applies the CUSTOM action with the HTTP provider on workload b for path /custom.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-b
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "b"
-  action: CUSTOM
-  provider:
-    name: "{{ .HTTPProviderName }}"
-  rules:
-    - to:
-        - operation:
-            paths: ["/custom"]
----
-
-# The following policy applies the CUSTOM action with the GRPC provider on workload c for path /custom.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-c
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "c"
-  action: CUSTOM
-  provider:
-    name: "{{ .GRPCProviderName }}"
-  rules:
-    - to:
-        - operation:
-            paths: ["/custom"]
----
-
-# The following policy applies the CUSTOM action with the local HTTP provider on workload d for path /custom.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-d
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "d"
-  action: CUSTOM
-  provider:
-    name: "{{ .LocalHTTPProviderName }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/custom"]
----
-
-# The following policy applies the CUSTOM action with the local GRPC provider on workload e for path /custom.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-e
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "e"
-  action: CUSTOM
-  provider:
-    name: "{{ .LocalGRPCProviderName }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/custom"]
----
-
-# The following policy applies the CUSTOM action with the GRPC provider on workload f for TCP port 8092.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-f-tcp
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "f"
-  action: CUSTOM
-  provider:
-    name: "{{ .GRPCProviderName }}"
-  rules:
-  - to:
-    - operation:
-        ports: ["8092"]
-
----
-
-# The following policy applies the CUSTOM action with the HTTP provider on ingress gateway for path /custom.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ingress-http
-  namespace: "{{ .RootNamespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "istio-ingressgateway"
-  action: CUSTOM
-  provider:
-    name: "{{ .HTTPProviderName }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/custom"]
----
-
-# The following gateway allows request to "*.company.com"
-
-apiVersion: networking.istio.io/v1alpha3
-kind: Gateway
-metadata:
-  name: test-ingress
-  namespace: {{ .Namespace }}
-spec:
-  selector:
-    istio: ingressgateway # use istio default ingress gateway
-  servers:
-    - port:
-        number: 80
-        name: http
-        protocol: HTTP
-      hosts:
-        - "*.company.com"
----
-
-# The following virtual service routes requests to workload x
-
-apiVersion: networking.istio.io/v1alpha3
-kind: VirtualService
-metadata:
-  name: test-vs
-  namespace: {{ .Namespace }}
-spec:
-  hosts:
-  - "*.company.com"
-  gateways:
-  - test-ingress
-  http:
-  - route:
-    - destination:
-        host: x
-        port:
-          number: 80
diff --git a/tests/integration/security/testdata/authz/v1beta1-deny-ns-root.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-deny-ns-root.yaml.tmpl
deleted file mode 100644
index 38a8e373a0..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-deny-ns-root.yaml.tmpl
+++ /dev/null
@@ -1,14 +0,0 @@
-# The following policy denies access to path /global-deny for all workloads
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-deny-ns-root
-  namespace: "{{ .RootNamespace }}"
-spec:
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/global-deny"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-deny.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-deny.yaml.tmpl
deleted file mode 100644
index 56ba9c4454..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-deny.yaml.tmpl
+++ /dev/null
@@ -1,90 +0,0 @@
-# The following policy denies access to path /deny to workload b.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/deny"]
----
-
-# The following policy denies access to path /allow/admin to workload c.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow/admin"]
----
-
-# The following policy allows access to path with prefix "/allow" to workload c.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow*"]
----
-
-# The following policy denies access to path /allow/admin to workload vm.
-# (TODO)JimmyCYJ: the following two policies are duplicates of existing ones above
-# and can be removed once the test framework supports multiple vm workloads.
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-vm-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .vm }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow/admin"]
----
-
-# The following policy allows access to path with prefix "/allow" to workload vm.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-vm-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .vm }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        paths: ["/allow*"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-egress-gateway.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-egress-gateway.yaml.tmpl
deleted file mode 100644
index 706d24b76e..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-egress-gateway.yaml.tmpl
+++ /dev/null
@@ -1,164 +0,0 @@
-apiVersion: security.istio.io/v1beta1
-kind: RequestAuthentication
-metadata:
-  name: "default"
-  namespace: "{{ .RootNamespace }}"
-spec:
-  jwtRules:
-  - issuer: "test-issuer-1@istio.io"
-    jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
-  - issuer: "test-issuer-2@istio.io"
-    jwksUri: "https://raw.githubusercontent.com/istio/istio/master/tests/common/jwt/jwks.json"
----
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: egressgateway
-  namespace: "{{ .RootNamespace }}"
-spec:
-  selector:
-    matchLabels:
-      app: istio-egressgateway
-  rules:
-    - to: # only allow /allow for company.com
-        - operation:
-            paths: ["/allow"]
-            hosts: ["www.company.com"]
-    - to: # checks only a call 443 over istio mutual without JWT
-      - operation:
-          hosts: ["{{ .a }}-only.com"]
-      from:
-      - source:
-          principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .a }}"]
-    - to: # checks workload can call 443 over istio mutual with JWT
-      - operation:
-          hosts: ["jwt-only.com"]
-      from:
-      - source:
-          requestPrincipals: ["test-issuer-1@istio.io/sub-1"]
-    - to: # checks only a can call 443 over istio mutual with JWT
-      - operation:
-          hosts: ["jwt-and-{{ .a }}-only.com"]
-      from:
-      - source:
-          requestPrincipals: ["test-issuer-1@istio.io/sub-1"]
-          principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .a }}"]
----
-
-# The following policy redirects the request through egress gateway.
-
-apiVersion: networking.istio.io/v1alpha3
-kind: Gateway
-metadata:
-  name: test-egress
-  namespace: {{ .Namespace }}
-spec:
-  selector:
-    istio: egressgateway
-  servers:
-    - port:
-        number: 80
-        name: http
-        protocol: HTTP
-      hosts:
-        - "www.company.com"
-    - port:
-        number: 443
-        name: https
-        protocol: HTTPS
-      tls:
-         mode: ISTIO_MUTUAL
-      hosts:
-        - "*"
----
-
-apiVersion: networking.istio.io/v1alpha3
-kind: VirtualService
-metadata:
-  name: route-via-egressgateway
-  namespace: {{ .Namespace }}
-spec:
-  hosts:
-  - "www.company.com"
-  gateways:
-  - test-egress
-  - mesh
-  http:
-    - match:
-      - gateways:
-        - mesh
-        port: 80
-      route:
-      - destination:
-          host: istio-egressgateway.{{ .RootNamespace }}.svc.cluster.local
-          port:
-            number: 80
-        weight: 100
-    - match:
-      - gateways:
-        - test-egress
-        port: 80
-      route:
-      - destination:
-          host: b.{{ .Namespace }}.svc.cluster.local
-          port:
-            number: 8095
-        weight: 100
-      headers:
-        request:
-          add:
-            x-egress-test: "handled-by-egress-gateway"
----
-apiVersion: networking.istio.io/v1alpha3
-kind: VirtualService
-metadata:
-  name: route-via-egressgateway-2
-  namespace: {{ .Namespace }}
-spec:
-  hosts:
-  - "{{ .a }}-only.com"
-  - "jwt-only.com"
-  - "jwt-and-{{ .a }}-only.com"
-  gateways:
-  - test-egress
-  - mesh
-  http:
-    - match:
-      - gateways:
-        - mesh
-        port: 80
-      route:
-      - destination:
-          host: istio-egressgateway.{{ .RootNamespace }}.svc.cluster.local
-          port:
-            number: 443
-        weight: 100
-    - match:
-      - gateways:
-        - test-egress
-        port: 443
-      route:
-      - destination:
-          host: b.{{ .Namespace }}.svc.cluster.local
-          port:
-            number: 8095
-        weight: 100
-      headers:
-        request:
-          add:
-            x-egress-test: "handled-by-egress-gateway"
----
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "test-egress"
-  namespace: {{ .Namespace }}
-spec:
-  host: "istio-egressgateway.{{ .RootNamespace }}.svc.cluster.local"
-  trafficPolicy:
-    portLevelSettings:
-    - port:
-        number: 443
-      tls:
-        mode: ISTIO_MUTUAL
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-grpc.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-grpc.yaml.tmpl
deleted file mode 100644
index 921167cbed..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-grpc.yaml.tmpl
+++ /dev/null
@@ -1,60 +0,0 @@
-# The following policy enables mTLS for server side workload.
-
-apiVersion: security.istio.io/v1beta1
-kind: PeerAuthentication
-metadata:
-  name: mtls
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .a }}
-  mtls:
-    mode: STRICT
----
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: mtls
-  namespace: {{ .Namespace }}
-spec:
-  host: "{{ .a }}.{{ .Namespace }}.svc.cluster.local"
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# For workload a:
-# * Allow src0 to call dst's Echo method.
-# * Disallow src1 to talk to dst since GET, DELETE, and PUT are not supported in gRPC.
-# * Allow src2 to call any methods of dst.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: authz-grpc
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .a }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/proto.EchoTestService/Echo"]
-        methods: ["POST"]
-    from:
-    - source:
-        principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .b }}"]
-  - to:
-    - operation:
-        paths: ["/proto.EchoTestService/Echo"]
-        # Since gRPC only allows POST, this will be denied (even though paths should be allowed).
-        methods: ["GET", "DELETE", "PUT"]
-    from:
-    - source:
-        principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .c }}"]
-  - from:
-    - source:
-        principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .d }}"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-ingress-gateway.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-ingress-gateway.yaml.tmpl
deleted file mode 100644
index c3c4d06cc0..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-ingress-gateway.yaml.tmpl
+++ /dev/null
@@ -1,94 +0,0 @@
-# The following policy denies access to "internal.company.com" and path "/private",
-# denies access from 172.17.72.46 or 192.168.4.0/23 to "remoteipblocks.company.com",
-# denies access from anything but 172.23.240.0/22 to "notremoteipblocks.company.com",
-# and denies access to "remoteipattr.company.com" when the remote ip is 10.242.5.7 or
-# in the network 10.124.99.0/24.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: deny-policy
-  namespace: "{{ .RootNamespace }}"
-spec:
-  action: DENY
-  selector:
-    matchLabels:
-      app: istio-ingressgateway
-  rules:
-    - to:
-        - operation:
-            hosts: ["deny.company.com", "*.suffix.company.com", "prefix.company.*"]
-    - to:
-        - operation:
-            hosts: ["internal.company.com"]
-        - operation:
-            paths: ["/private"]
-    - from:
-        - source:
-            remoteIpBlocks: ["172.17.72.46", "192.168.4.0/23"]
-      to:
-        - operation:
-            hosts: ["remoteipblocks.company.com"]
-    - from:
-        - source:
-            notRemoteIpBlocks: ["172.23.240.0/22"]
-      to:
-        - operation:
-            hosts: ["notremoteipblocks.company.com"]
-    - to:
-        - operation:
-            hosts: ["remoteipattr.company.com"]
-      when:
-        - key: remote.ip
-          values: ["10.242.5.7", "10.124.99.0/24"]
-    - from:
-        - source:
-            ipBlocks: ["172.19.19.19"]
-      to:
-        - operation:
-            hosts: ["ipblocks.company.com"]
-    - from:
-        - source:
-            notIpBlocks: ["172.19.19.20"]
-      to:
-        - operation:
-            hosts: ["notipblocks.company.com"]
----
-
-# The following gateway allows request to "*.company.com"
-
-apiVersion: networking.istio.io/v1alpha3
-kind: Gateway
-metadata:
-  name: test-ingress
-  namespace: {{ .Namespace }}
-spec:
-  selector:
-    istio: ingressgateway # use istio default ingress gateway
-  servers:
-    - port:
-        number: 80
-        name: http
-        protocol: HTTP
-      hosts:
-        - "*.company.com"
----
-
-# The following virtual service routes requests to workload
-
-apiVersion: networking.istio.io/v1alpha3
-kind: VirtualService
-metadata:
-  name: test-vs
-  namespace: {{ .Namespace }}
-spec:
-  hosts:
-  - "*.company.com"
-  gateways:
-  - test-ingress
-  http:
-  - route:
-    - destination:
-        host: {{ .dst }}
-        port:
-          number: 8095
diff --git a/tests/integration/security/testdata/authz/v1beta1-mtls.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-mtls.yaml.tmpl
deleted file mode 100644
index a72bcc15b7..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-mtls.yaml.tmpl
+++ /dev/null
@@ -1,57 +0,0 @@
-# Enforce access control based on mTLS identities.
-
-# The following policy enables mTLS for workload.
-
-apiVersion: security.istio.io/v1beta1
-kind: PeerAuthentication
-metadata:
-  name: mtls
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      app: {{ .dst }}
-  mtls:
-    mode: STRICT
----
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "mtls"
-  namespace: "{{ .Namespace }}"
-spec:
-  host: "{{ .dst }}.{{ .Namespace }}.svc.cluster.local"
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# The following policy enables authorization on workload:
-# - Allow workloads of service account a in the same namespace to access path /principal-a
-# - Allow workloads in namespace-2 to access path /namespace-2
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .dst }}
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/principal-a"]
-        methods: ["GET"]
-    from:
-    - source:
-        principals: ["cluster.local/ns/{{ .Namespace }}/sa/a"]
-  - to:
-    - operation:
-        paths: ["/namespace-2"]
-        methods: ["GET"]
-    from:
-    - source:
-        namespaces: ["{{ .Namespace2 }}"]
----
\ No newline at end of file
diff --git a/tests/integration/security/testdata/authz/v1beta1-negative-match.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-negative-match.yaml.tmpl
deleted file mode 100644
index c74ea8b04e..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-negative-match.yaml.tmpl
+++ /dev/null
@@ -1,194 +0,0 @@
-# The following policy denies access to path with prefix "/prefix" except "/prefix/allowlist" to workload b.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/prefix*"]
-        notPaths: ["/prefix/allowlist"]
----
-# The following policy will deny all the requests to GET method
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        notMethods : ["PUT"]
----
-# The following policy denies access from other namespaces.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-same-namespace
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: DENY
-  rules:
-  - from:
-    - source:
-        notNamespaces: ["{{ .Namespace }}"]
----
-# The following policy allows request if the host is not "deny.com"
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        notHosts: ["deny.com"]
----
-
-# The following policy denies access to a workload d if it's not mTLS, in other words, it allows only mTLS traffic to access the workload d.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .d }}-mtls-traffic
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .d }}"
-  action: DENY
-  rules:
-  - from:
-    - source:
-        notPrincipals: ["*"]
----
-# The following policy allows request if the port is not "8091"
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .d }}-allow
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .d }}"
-  action: ALLOW
-  rules:
-  - to:
-    - operation:
-        notPorts: ["8091"]
---- 
-# The following policy denies access to path with prefix "/prefix" except "/prefix/allowlist" to workload vm.
-# (TODO)JimmyCYJ: the following policy is a duplicate of policy-{{ .b }}-deny and can be removed once the test framework supports multiple vm workloads.
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .vm }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .vm }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/prefix*"]
-        notPaths: ["/prefix/allowlist"]
----
-
-# The following policy enables mTLS with PERMISSIVE mode for all workloads in the namespace
-
-apiVersion: security.istio.io/v1beta1
-kind: PeerAuthentication
-metadata:
-  name: default
-  namespace: "{{ .Namespace }}"
-spec:
-  mtls:
-    mode: PERMISSIVE
----
-
-# The following destination rule enables mTLS in the namespace
-
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "mtls"
-  namespace: "{{ .Namespace }}"
-spec:
-  host: "*.{{ .Namespace }}.svc.cluster.local"
-  exportTo: ["."]
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# The following destination rule enables mTLS from namespace 2 to workload b.
-
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "dr-{{ .b }}"
-  namespace: "{{ .Namespace2 }}"
-spec:
-  host: "{{ .b }}.{{ .Namespace }}.svc.cluster.local"
-  exportTo: ["."]
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# The following destination rule enables mTLS from namespace 2 to workload c.
-
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "dr-{{ .c }}"
-  namespace: "{{ .Namespace2 }}"
-spec:
-  host: "{{ .c }}.{{ .Namespace }}.svc.cluster.local"
-  exportTo: ["."]
-  trafficPolicy:
-    tls:
-      mode: ISTIO_MUTUAL
----
-
-# The following destination rule disables mTLS from namespace 2 to workload d.
-
-apiVersion: networking.istio.io/v1alpha3
-kind: DestinationRule
-metadata:
-  name: "dr-{{ .d }}"
-  namespace: "{{ .Namespace2 }}"
-spec:
-  host: "{{ .d }}.{{ .Namespace }}.svc.cluster.local"
-  exportTo: ["."]
-  trafficPolicy:
-    tls:
-      mode: DISABLE
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-path.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-path.yaml.tmpl
deleted file mode 100644
index de9ee252de..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-path.yaml.tmpl
+++ /dev/null
@@ -1,19 +0,0 @@
-# For server side workload:
-# * Allow GET requests at path with prefix "/public".
-# * Deny any other requests by default.
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .a }}-path
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .a }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/public*"]
-        methods: ["GET"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-tcp.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-tcp.yaml.tmpl
deleted file mode 100644
index fc804aad40..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-tcp.yaml.tmpl
+++ /dev/null
@@ -1,89 +0,0 @@
-# The following policy denies request with path "/data" to port 8091 for workload
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .b }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/data"]
-        ports: ["8091"]
----
-
-# The following policy denies:
-# request to port 8091 for workload c
-# request to port 8094 with principal suffix matching
-# request to port 8093 with namespace suffix matching
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .c }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        ports: ["8091"]
-  - to:
-    - operation:
-        ports: ["8094"]
-    from:
-    - source:
-        principals: ["*/ns/{{ .Namespace }}/sa/{{ .b }}"]
-  - to:
-    - operation:
-        ports: ["8093"]
-    from:
-    - source:
-        namespaces: ["*{{ .Namespace2 }}"]
----
-
-# The following policy denies request from service account a and namespace 2 for workload d
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .d }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .d }}"
-  action: DENY
-  rules:
-  - from:
-    - source:
-        principals: ["cluster.local/ns/{{ .Namespace }}/sa/{{ .a }}"]
-    - source:
-        namespaces: ["{{ .Namespace2 }}"]
----
-
-# The following policy denies request with path "/other" for workload e
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-{{ .e }}-deny
-  namespace: "{{ .Namespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .e }}"
-  action: DENY
-  rules:
-  - to:
-    - operation:
-        paths: ["/other"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-workload-ns-root.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-workload-ns-root.yaml.tmpl
deleted file mode 100644
index fbea9b5d05..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-workload-ns-root.yaml.tmpl
+++ /dev/null
@@ -1,16 +0,0 @@
-# The following policy selects workload c in all namespaces
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns-root-{{ .c }}
-  namespace: "{{ .RootNamespace }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns-root-{{ .c }}"]
----
diff --git a/tests/integration/security/testdata/authz/v1beta1-workload-ns1.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-workload-ns1.yaml.tmpl
deleted file mode 100644
index 4ba40ce654..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-workload-ns1.yaml.tmpl
+++ /dev/null
@@ -1,65 +0,0 @@
-# The following policy selects workload b in namespace 1
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns1-{{ .b }}
-  namespace: "{{ .Namespace1 }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .b }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns1-{{ .b }}"]
----
-
-# The following policy selects workload c in namespace 1
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns1-{{ .c }}
-  namespace: "{{ .Namespace1 }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns1-{{ .c }}"]
----
-
-# The following policy selects a non-exist workload in namespace 1
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns1-x
-  namespace: "{{ .Namespace1 }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .dst1 }}"
-      "foo": "bla"
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns1-x"]
----
-
-# The following policy selects all workloads in namespace 1
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns1-all
-  namespace: "{{ .Namespace1 }}"
-spec:
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns1-all"]
----
\ No newline at end of file
diff --git a/tests/integration/security/testdata/authz/v1beta1-workload-ns2.yaml.tmpl b/tests/integration/security/testdata/authz/v1beta1-workload-ns2.yaml.tmpl
deleted file mode 100644
index acd238b916..0000000000
--- a/tests/integration/security/testdata/authz/v1beta1-workload-ns2.yaml.tmpl
+++ /dev/null
@@ -1,30 +0,0 @@
-# The following policy selects workload c in namespace 2
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns2-{{ .c }}
-  namespace: "{{ .Namespace2 }}"
-spec:
-  selector:
-    matchLabels:
-      "app": "{{ .c }}"
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns2-{{ .c }}"]
----
-
-# The following policy selects all workloads in namespace 2
-
-apiVersion: security.istio.io/v1beta1
-kind: AuthorizationPolicy
-metadata:
-  name: policy-ns2-all
-  namespace: "{{ .Namespace2 }}"
-spec:
-  rules:
-  - to:
-    - operation:
-        paths: ["/policy-ns2-all"]
----
\ No newline at end of file
-- 
2.35.3

