From 50c0cc307ee273e34e35e324fc130371bd536bdf Mon Sep 17 00:00:00 2001
From: zirain <hejianpeng2@huawei.com>
Date: Thu, 10 Feb 2022 09:54:50 +0800
Subject: add insecure oci support (#36903)

* add insecure oci support

* Update pkg/wasm/imagefetcher.go

Co-authored-by: Pengyuan Bian <bianpengyuan@google.com>

* fix nit

Co-authored-by: Pengyuan Bian <bianpengyuan@google.com>
---
 pilot/cmd/pilot-agent/options/agent.go   |  1 +
 pilot/cmd/pilot-agent/options/options.go |  3 +++
 pkg/istio-agent/agent.go                 |  2 ++
 pkg/istio-agent/xds_proxy.go             |  4 ++-
 pkg/wasm/cache.go                        | 32 ++++++++++++++++--------
 pkg/wasm/cache_test.go                   |  4 +--
 pkg/wasm/imagefetcher.go                 | 31 ++++++++++++++++++++++-
 7 files changed, 63 insertions(+), 14 deletions(-)

diff --git a/pilot/cmd/pilot-agent/options/agent.go b/pilot/cmd/pilot-agent/options/agent.go
index 6bc1ed6ce9..d3098f6b35 100644
--- a/pilot/cmd/pilot-agent/options/agent.go
+++ b/pilot/cmd/pilot-agent/options/agent.go
@@ -40,6 +40,7 @@ func NewAgentOptions(proxy *model.Proxy, cfg *meshconfig.ProxyConfig) *istioagen
 		ProxyType:                   proxy.Type,
 		EnableDynamicProxyConfig:    enableProxyConfigXdsEnv,
 		EnableDynamicBootstrap:      enableBootstrapXdsEnv,
+		WASMInsecureRegistries:      strings.Split(wasmInsecureRegistries, ","),
 		ProxyIPAddresses:            proxy.IPAddresses,
 		ServiceNode:                 proxy.ServiceNode(),
 		EnvoyStatusPort:             envoyStatusPortEnv,
diff --git a/pilot/cmd/pilot-agent/options/options.go b/pilot/cmd/pilot-agent/options/options.go
index 995f0693ba..a9474015d2 100644
--- a/pilot/cmd/pilot-agent/options/options.go
+++ b/pilot/cmd/pilot-agent/options/options.go
@@ -99,6 +99,9 @@
 	enableProxyConfigXdsEnv = env.RegisterBoolVar("PROXY_CONFIG_XDS_AGENT", false,
 		"If set to true, agent retrieves dynamic proxy-config updates via xds channel").Get()
 
+	wasmInsecureRegistries = env.RegisterStringVar("WASM_INSECURE_REGISTRIES", "",
+		"allow agent pull wasm plugin from insecure registries, for example: 'localhost:5000,docker-registry:5000'").Get()
+
 	// Ability of istio-agent to retrieve bootstrap via XDS
 	enableBootstrapXdsEnv = env.RegisterBoolVar("BOOTSTRAP_XDS_AGENT", false,
 		"If set to true, agent retrieves the bootstrap configuration prior to starting Envoy").Get()
diff --git a/pkg/istio-agent/agent.go b/pkg/istio-agent/agent.go
index b8fc77b9a7..46fded3e6d 100644
--- a/pkg/istio-agent/agent.go
+++ b/pkg/istio-agent/agent.go
@@ -195,6 +195,8 @@ type AgentOptions struct {
 	DownstreamGrpcOptions []grpc.ServerOption
 
 	IstiodSAN string
+
+	WASMInsecureRegistries []string
 }
 
 // NewAgent hosts the functionality for local SDS and XDS. This consists of the local SDS server and
diff --git a/pkg/istio-agent/xds_proxy.go b/pkg/istio-agent/xds_proxy.go
index d088d0d0dd..31094d8486 100644
--- a/pkg/istio-agent/xds_proxy.go
+++ b/pkg/istio-agent/xds_proxy.go
@@ -142,6 +142,8 @@ func initXdsProxy(ia *Agent) (*XdsProxy, error) {
 			LocalHostAddr: localHostAddr,
 		}
 	}
+
+	cache := wasm.NewLocalFileCache(constants.IstioDataDir, wasm.DefaultWasmModulePurgeInterval, wasm.DefaultWasmModuleExpiry, ia.cfg.WASMInsecureRegistries)
 	proxy := &XdsProxy{
 		istiodAddress:         ia.proxyConfig.DiscoveryAddress,
 		istiodSAN:             ia.cfg.IstiodSAN,
@@ -151,7 +153,7 @@ func initXdsProxy(ia *Agent) (*XdsProxy, error) {
 		healthChecker:         health.NewWorkloadHealthChecker(ia.proxyConfig.ReadinessProbe, envoyProbe, ia.cfg.ProxyIPAddresses, ia.cfg.IsIPv6),
 		xdsHeaders:            ia.cfg.XDSHeaders,
 		xdsUdsPath:            ia.cfg.XdsUdsPath,
-		wasmCache:             wasm.NewLocalFileCache(constants.IstioDataDir, wasm.DefaultWasmModulePurgeInterval, wasm.DefaultWasmModuleExpiry),
+		wasmCache:             cache,
 		proxyAddresses:        ia.cfg.ProxyIPAddresses,
 		downstreamGrpcOptions: ia.cfg.DownstreamGrpcOptions,
 	}
diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 2be69a1f7e..3da52d2232 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -28,6 +28,7 @@
 	"sync"
 	"time"
 
+	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/pkg/log"
 )
 
@@ -62,8 +63,9 @@ type LocalFileCache struct {
 	mux sync.Mutex
 
 	// Duration for stale Wasm module purging.
-	purgeInterval    time.Duration
-	wasmModuleExpiry time.Duration
+	purgeInterval      time.Duration
+	wasmModuleExpiry   time.Duration
+	insecureRegistries sets.Set
 
 	// stopChan currently is only used by test
 	stopChan chan struct{}
@@ -86,14 +88,15 @@ type cacheEntry struct {
 }
 
 // NewLocalFileCache create a new Wasm module cache which downloads and stores Wasm module files locally.
-func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration) *LocalFileCache {
+func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, insecureRegistries []string) *LocalFileCache {
 	cache := &LocalFileCache{
-		httpFetcher:      NewHTTPFetcher(),
-		modules:          make(map[cacheKey]cacheEntry),
-		dir:              dir,
-		purgeInterval:    purgeInterval,
-		wasmModuleExpiry: moduleExpiry,
-		stopChan:         make(chan struct{}),
+		httpFetcher:        NewHTTPFetcher(),
+		modules:            make(map[cacheKey]cacheEntry),
+		dir:                dir,
+		purgeInterval:      purgeInterval,
+		wasmModuleExpiry:   moduleExpiry,
+		stopChan:           make(chan struct{}),
+		insecureRegistries: sets.NewSet(insecureRegistries...),
 	}
 	go func() {
 		cache.purge()
@@ -143,8 +146,17 @@ func (c *LocalFileCache) Get(downloadURL, checksum string, timeout time.Duration
 	case "oci":
 		ctx, cancel := context.WithTimeout(context.Background(), timeout)
 		defer cancel()
+
+		insecure := false
+		if c.insecureRegistries.Contains(u.Host) {
+			insecure = true
+		}
 		// TODO: support imagePullSecret and pass it to ImageFetcherOption.
-		fetcher := NewImageFetcher(ctx, ImageFetcherOption{})
+		imgFetcherOps := ImageFetcherOption{
+			Insecure: insecure,
+		}
+		wasmLog.Debugf("wasm oci fetch %s with options: %v", downloadURL, imgFetcherOps)
+		fetcher := NewImageFetcher(ctx, imgFetcherOps)
 		b, err = fetcher.Fetch(u.Host+u.Path, checksum)
 		if err != nil {
 			if errors.Is(err, errWasmOCIImageDigestMismatch) {
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index 642a0bfd2f..8babc72ca8 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -232,7 +232,7 @@ func TestWasmCache(t *testing.T) {
 	for _, c := range cases {
 		t.Run(c.name, func(t *testing.T) {
 			tmpDir := t.TempDir()
-			cache := NewLocalFileCache(tmpDir, c.purgeInterval, c.wasmModuleExpiry)
+			cache := NewLocalFileCache(tmpDir, c.purgeInterval, c.wasmModuleExpiry, nil)
 			defer close(cache.stopChan)
 			tsNumRequest = 0
 
@@ -344,7 +344,7 @@ func setupOCIRegistry(t *testing.T, host string) (wantBinaryCheckSum, dockerImag
 
 func TestWasmCacheMissChecksum(t *testing.T) {
 	tmpDir := t.TempDir()
-	cache := NewLocalFileCache(tmpDir, DefaultWasmModulePurgeInterval, DefaultWasmModuleExpiry)
+	cache := NewLocalFileCache(tmpDir, DefaultWasmModulePurgeInterval, DefaultWasmModuleExpiry, nil)
 	defer close(cache.stopChan)
 
 	gotNumRequest := 0
diff --git a/pkg/wasm/imagefetcher.go b/pkg/wasm/imagefetcher.go
index a5e453eaa8..6a45f4a2bb 100644
--- a/pkg/wasm/imagefetcher.go
+++ b/pkg/wasm/imagefetcher.go
@@ -18,10 +18,12 @@
 	"archive/tar"
 	"compress/gzip"
 	"context"
+	"crypto/tls"
 	"errors"
 	"fmt"
 	"io"
 	"path/filepath"
+	"strings"
 
 	"github.com/google/go-containerregistry/pkg/authn"
 	"github.com/google/go-containerregistry/pkg/name"
@@ -41,6 +43,8 @@ type ImageFetcherOption struct {
 	Username string
 	Password string
 	// TODO(mathetake) Add signature verification stuff.
+
+	Insecure bool
 }
 
 func (o *ImageFetcherOption) useDefaultKeyChain() bool {
@@ -61,6 +65,15 @@ func NewImageFetcher(ctx context.Context, opt ImageFetcherOption) *ImageFetcher
 	} else {
 		fetchOpts = append(fetchOpts, remote.WithAuth(&authn.Basic{Username: opt.Username}))
 	}
+
+	if opt.Insecure {
+		t := remote.DefaultTransport.Clone()
+		t.TLSClientConfig = &tls.Config{
+			InsecureSkipVerify: opt.Insecure, //nolint: gosec
+		}
+		fetchOpts = append(fetchOpts, remote.WithTransport(t))
+	}
+
 	return &ImageFetcher{
 		fetchOpts: append(fetchOpts, remote.WithContext(ctx)),
 	}
@@ -68,7 +81,7 @@ func NewImageFetcher(ctx context.Context, opt ImageFetcherOption) *ImageFetcher
 
 // Fetch is the entrypoint for fetching Wasm binary from Wasm Image Specification compatible images.
 func (o *ImageFetcher) Fetch(url, expManifestDigest string) ([]byte, error) {
-	ref, err := name.ParseReference(url)
+	ref, err := parseReference(url)
 	if err != nil {
 		return nil, fmt.Errorf("could not parse url in image reference: %v", err)
 	}
@@ -122,6 +135,22 @@ func (o *ImageFetcher) Fetch(url, expManifestDigest string) ([]byte, error) {
 	)
 }
 
+func parseReference(url string) (name.Reference, error) {
+	ref, err := name.ParseReference(url)
+	if err != nil {
+		return nil, err
+	}
+
+	// fallback to http based request, inspired by [helm](https://github.com/helm/helm/blob/12f1bc0acdeb675a8c50a78462ed3917fb7b2e37/pkg/registry/client.go#L594)
+	_, err = remote.Get(ref)
+	if err != nil && strings.Contains(err.Error(), "server gave HTTP response") {
+		wasmLog.Infof("fetch with plain text from %s", url)
+		return name.ParseReference(url, name.Insecure)
+	}
+
+	return ref, err
+}
+
 // extractDockerImage extracts the Wasm binary from the
 // *compat* variant Wasm image with the standard Docker media type: application/vnd.docker.image.rootfs.diff.tar.gzip.
 // https://github.com/solo-io/wasm/blob/master/spec/spec-compat.md#specification
-- 
2.35.3

