From f5279a9734997a4cf87ba28ad21f26362dbd90ad Mon Sep 17 00:00:00 2001
From: Pengyuan Bian <bianpengyuan@google.com>
Date: Tue, 14 Dec 2021 00:42:06 -0800
Subject: Fix ServiceEntry selecting WorkloadEntry with host & UDS address.
 (#36480)

* Make WorkloadEntry with DNS & UDS host selectable for ServiceEntry.

* update.
---
 pilot/pkg/model/service.go                    |  2 ++
 .../serviceentry/conversion.go                | 14 ++++----
 .../serviceentry/conversion_test.go           | 36 +++++++++++++++++--
 .../serviceentry/servicediscovery.go          | 18 +++++++++-
 .../serviceentry/servicediscovery_test.go     | 35 ++++++++++++++++++
 5 files changed, 96 insertions(+), 9 deletions(-)

diff --git a/pilot/pkg/model/service.go b/pilot/pkg/model/service.go
index b9fc911a68..7d50f172d3 100644
--- a/pilot/pkg/model/service.go
+++ b/pilot/pkg/model/service.go
@@ -266,6 +266,8 @@ type WorkloadInstance struct {
 	Kind     workloadKind      `json:"kind"`
 	Endpoint *IstioEndpoint    `json:"endpoint,omitempty"`
 	PortMap  map[string]uint32 `json:"portMap,omitempty"`
+	// Can only be selected by service entry of DNS type.
+	DNSServiceEntryOnly bool `json:"dnsServiceEntryOnly,omitempty"`
 }
 
 // DeepCopy creates a copy of WorkloadInstance.
diff --git a/pilot/pkg/serviceregistry/serviceentry/conversion.go b/pilot/pkg/serviceregistry/serviceentry/conversion.go
index 664f551271..f45f3b3b0b 100644
--- a/pilot/pkg/serviceregistry/serviceentry/conversion.go
+++ b/pilot/pkg/serviceregistry/serviceentry/conversion.go
@@ -386,13 +386,14 @@ func (s *ServiceEntryStore) convertWorkloadEntryToWorkloadInstance(cfg config.Co
 		labels[k] = v
 	}
 	addr := we.GetAddress()
+	dnsServiceEntryOnly := false
 	if strings.HasPrefix(addr, model.UnixAddressPrefix) {
 		// k8s can't use uds for service objects
-		return nil
+		dnsServiceEntryOnly = true
 	}
 	if net.ParseIP(addr) == nil {
 		// k8s can't use workloads with hostnames in the address field.
-		return nil
+		dnsServiceEntryOnly = true
 	}
 	tlsMode := getTLSModeFromWorkloadEntry(we)
 	sa := ""
@@ -419,9 +420,10 @@ func (s *ServiceEntryStore) convertWorkloadEntryToWorkloadInstance(cfg config.Co
 			TLSMode:        tlsMode,
 			ServiceAccount: sa,
 		},
-		PortMap:   we.Ports,
-		Namespace: cfg.Namespace,
-		Name:      cfg.Name,
-		Kind:      model.WorkloadEntryKind,
+		PortMap:             we.Ports,
+		Namespace:           cfg.Namespace,
+		Name:                cfg.Name,
+		Kind:                model.WorkloadEntryKind,
+		DNSServiceEntryOnly: dnsServiceEntryOnly,
 	}
 }
diff --git a/pilot/pkg/serviceregistry/serviceentry/conversion_test.go b/pilot/pkg/serviceregistry/serviceentry/conversion_test.go
index c375993931..33a225a2b2 100644
--- a/pilot/pkg/serviceregistry/serviceentry/conversion_test.go
+++ b/pilot/pkg/serviceregistry/serviceentry/conversion_test.go
@@ -988,7 +988,23 @@ func TestConvertWorkloadEntryToWorkloadInstance(t *testing.T) {
 					ServiceAccount: "scooby",
 				},
 			},
-			out: nil,
+			out: &model.WorkloadInstance{
+				Namespace: "ns1",
+				Kind:      model.WorkloadEntryKind,
+				Endpoint: &model.IstioEndpoint{
+					Labels: map[string]string{
+						"topology.istio.io/cluster": clusterID,
+					},
+					Address:        "unix://foo/bar",
+					ServiceAccount: "spiffe://cluster.local/ns/ns1/sa/scooby",
+					TLSMode:        "istio",
+					Namespace:      "ns1",
+					Locality: model.Locality{
+						ClusterID: cluster.ID(clusterID),
+					},
+				},
+				DNSServiceEntryOnly: true,
+			},
 		},
 		{
 			name: "DNS address",
@@ -1001,7 +1017,23 @@ func TestConvertWorkloadEntryToWorkloadInstance(t *testing.T) {
 					ServiceAccount: "scooby",
 				},
 			},
-			out: nil,
+			out: &model.WorkloadInstance{
+				Namespace: "ns1",
+				Kind:      model.WorkloadEntryKind,
+				Endpoint: &model.IstioEndpoint{
+					Labels: map[string]string{
+						"topology.istio.io/cluster": clusterID,
+					},
+					Address:        "scooby.com",
+					ServiceAccount: "spiffe://cluster.local/ns/ns1/sa/scooby",
+					TLSMode:        "istio",
+					Namespace:      "ns1",
+					Locality: model.Locality{
+						ClusterID: cluster.ID(clusterID),
+					},
+				},
+				DNSServiceEntryOnly: true,
+			},
 		},
 		{
 			name: "metadata labels only",
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
index 4f49ee1c62..e6fad0e3e9 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery.go
@@ -174,7 +174,7 @@ func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event
 	}
 
 	wi := s.convertWorkloadEntryToWorkloadInstance(curr, s.Cluster())
-	if wi != nil {
+	if wi != nil && !wi.DNSServiceEntryOnly {
 		// fire off the k8s handlers
 		for _, h := range s.workloadHandlers {
 			h(wi, event)
@@ -214,6 +214,11 @@ func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event
 	for namespacedName, cfg := range currSes {
 		services := s.services.getServices(namespacedName)
 		se := cfg.Spec.(*networking.ServiceEntry)
+		if wi.DNSServiceEntryOnly && se.Resolution != networking.ServiceEntry_DNS &&
+			se.Resolution != networking.ServiceEntry_DNS_ROUND_ROBIN {
+			log.Debugf("skip selecting workload instance %v/%v for DNS service entry %v", wi.Namespace, wi.Name, se.Hosts)
+			continue
+		}
 		instance := s.convertWorkloadEntryToServiceInstances(wle, services, se, &key, s.Cluster())
 		instancesUpdated = append(instancesUpdated, instance...)
 		addConfigs(se, services)
@@ -223,6 +228,11 @@ func (s *ServiceEntryStore) workloadEntryHandler(old, curr config.Config, event
 		services := s.services.getServices(namespacedName)
 		cfg := oldSes[namespacedName]
 		se := cfg.Spec.(*networking.ServiceEntry)
+		if wi.DNSServiceEntryOnly && se.Resolution != networking.ServiceEntry_DNS &&
+			se.Resolution != networking.ServiceEntry_DNS_ROUND_ROBIN {
+			log.Debugf("skip selecting workload instance %v/%v for DNS service entry %v", wi.Namespace, wi.Name, se.Hosts)
+			continue
+		}
 		instance := s.convertWorkloadEntryToServiceInstances(wle, services, se, &key, s.Cluster())
 		instancesDeleted = append(instancesDeleted, instance...)
 		addConfigs(se, services)
@@ -835,6 +845,12 @@ func (s *ServiceEntryStore) buildServiceInstancesForSE(
 	if currentServiceEntry.WorkloadSelector != nil {
 		workloadInstances := s.workloadInstances.listUnordered(curr.Namespace, labels.Collection{currentServiceEntry.WorkloadSelector.Labels})
 		for _, wi := range workloadInstances {
+			if wi.DNSServiceEntryOnly && currentServiceEntry.Resolution != networking.ServiceEntry_DNS &&
+				currentServiceEntry.Resolution != networking.ServiceEntry_DNS_ROUND_ROBIN {
+				log.Debugf("skip selecting workload instance %v/%v for DNS service entry %v", wi.Namespace, wi.Name,
+					currentServiceEntry.Hosts)
+				continue
+			}
 			instances := convertWorkloadInstanceToServiceInstance(wi.Endpoint, services, currentServiceEntry)
 			serviceInstances = append(serviceInstances, instances...)
 			ckey := configKey{namespace: wi.Namespace, name: wi.Name}
diff --git a/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go b/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
index 2a5da37f10..2b00fda0e0 100644
--- a/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
+++ b/pilot/pkg/serviceregistry/serviceentry/servicediscovery_test.go
@@ -563,6 +563,12 @@ func TestServiceDiscoveryWorkloadUpdate(t *testing.T) {
 			Labels:         map[string]string{"app": "wle"},
 			ServiceAccount: "default",
 		})
+	wle3 := createWorkloadEntry("wl3", selector.Name,
+		&networking.WorkloadEntry{
+			Address:        "abc.def",
+			Labels:         map[string]string{"app": "wle"},
+			ServiceAccount: "default",
+		})
 	dnsWle := createWorkloadEntry("dnswl", dnsSelector.Namespace,
 		&networking.WorkloadEntry{
 			Address:        "4.4.4.4",
@@ -666,6 +672,35 @@ func TestServiceDiscoveryWorkloadUpdate(t *testing.T) {
 		)
 	})
 
+	t.Run("ignore host workload", func(t *testing.T) {
+		// Add a WLE with host address. Should be ignored by static service entry.
+		createConfigs([]*config.Config{wle3}, store, t)
+		instances := []*model.ServiceInstance{
+			makeInstanceWithServiceAccount(selector, "2.2.2.2", 444,
+				selector.Spec.(*networking.ServiceEntry).Ports[0], map[string]string{"app": "wle"}, "default"),
+			makeInstanceWithServiceAccount(selector, "2.2.2.2", 445,
+				selector.Spec.(*networking.ServiceEntry).Ports[1], map[string]string{"app": "wle"}, "default"),
+		}
+		for _, i := range instances {
+			i.Endpoint.WorkloadName = "wl"
+			i.Endpoint.Namespace = selector.Name
+		}
+		expectProxyInstances(t, sd, instances, "2.2.2.2")
+		instances = append(instances,
+			makeInstanceWithServiceAccount(selector, "3.3.3.3", 444,
+				selector.Spec.(*networking.ServiceEntry).Ports[0], map[string]string{"app": "wle"}, "default"),
+			makeInstanceWithServiceAccount(selector, "3.3.3.3", 445,
+				selector.Spec.(*networking.ServiceEntry).Ports[1], map[string]string{"app": "wle"}, "default"))
+		for _, i := range instances[2:] {
+			i.Endpoint.WorkloadName = "wl2"
+			i.Endpoint.Namespace = selector.Name
+		}
+		expectServiceInstances(t, sd, selector, 0, instances)
+		expectEvents(t, events,
+			Event{kind: "xds", proxyIP: "abc.def"},
+		)
+	})
+
 	t.Run("deletion", func(t *testing.T) {
 		// Delete the configs, it should be gone
 		deleteConfigs([]*config.Config{wle2}, store, t)
-- 
2.35.3

