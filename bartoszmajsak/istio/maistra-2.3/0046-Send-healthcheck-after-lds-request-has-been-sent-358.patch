From 57b27bfceb507d56fa59b46917a44eb60524c3ae Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Sat, 6 Nov 2021 00:11:49 +0800
Subject: Send healthcheck after lds request has been sent (#35863)

* Send healthcheck after lds request has been sent

* Fix intercept hc xds upstream request

* Fix potential race

* add ut
---
 pilot/pkg/xds/ads.go              |  5 ++
 pkg/istio-agent/xds_proxy.go      | 85 ++++++++++++++++---------------
 pkg/istio-agent/xds_proxy_test.go | 24 ++++++++-
 3 files changed, 72 insertions(+), 42 deletions(-)

diff --git a/pilot/pkg/xds/ads.go b/pilot/pkg/xds/ads.go
index 9332107c2c..13a04003fa 100644
--- a/pilot/pkg/xds/ads.go
+++ b/pilot/pkg/xds/ads.go
@@ -167,6 +167,11 @@ func (s *DiscoveryServer) receive(con *Connection) {
 		}
 		// This should be only set for the first request. The node id may not be set - for example malicious clients.
 		if firstRequest {
+			// probe happens before envoy sends first xDS request
+			if req.TypeUrl == v3.HealthInfoType {
+				log.Warnf("ADS: %q %s send health check probe before normal xDS request", con.PeerAddr, con.ConID)
+				continue
+			}
 			firstRequest = false
 			if req.Node == nil || req.Node.Id == "" {
 				con.errorChan <- status.New(codes.InvalidArgument, "missing node information").Err()
diff --git a/pkg/istio-agent/xds_proxy.go b/pkg/istio-agent/xds_proxy.go
index 51766751e1..0ec16873a0 100644
--- a/pkg/istio-agent/xds_proxy.go
+++ b/pkg/istio-agent/xds_proxy.go
@@ -324,46 +324,6 @@ func (p *XdsProxy) handleStream(downstream adsStream) error {
 	p.RegisterStream(con)
 	defer p.UnregisterStream(con)
 
-	// Handle downstream xds
-	initialRequestsSent := false
-	go func() {
-		for {
-			// From Envoy
-			req, err := downstream.Recv()
-			if err != nil {
-				select {
-				case con.downstreamError <- err:
-				case <-con.stopChan:
-				}
-				return
-			}
-			// forward to istiod
-			con.sendRequest(req)
-			if !initialRequestsSent && req.TypeUrl == v3.ListenerType {
-				// fire off an initial NDS request
-				if _, f := p.handlers[v3.NameTableType]; f {
-					con.sendRequest(&discovery.DiscoveryRequest{
-						TypeUrl: v3.NameTableType,
-					})
-				}
-				// fire off an initial PCDS request
-				if _, f := p.handlers[v3.ProxyConfigType]; f {
-					con.sendRequest(&discovery.DiscoveryRequest{
-						TypeUrl: v3.ProxyConfigType,
-					})
-				}
-				// Fire of a configured initial request, if there is one
-				p.connectedMutex.RLock()
-				initialRequest := p.initialRequest
-				if initialRequest != nil {
-					con.sendRequest(initialRequest)
-				}
-				p.connectedMutex.RUnlock()
-				initialRequestsSent = true
-			}
-		}
-	}()
-
 	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
 	defer cancel()
 	upstreamConn, err := grpc.DialContext(ctx, p.istiodAddress, p.istiodDialOptions...)
@@ -449,10 +409,55 @@ func (p *XdsProxy) HandleUpstream(ctx context.Context, con *ProxyConnection, xds
 }
 
 func (p *XdsProxy) handleUpstreamRequest(con *ProxyConnection) {
+	initialRequestsSent := atomic.NewBool(false)
+	go func() {
+		for {
+			// recv xds requests from envoy
+			req, err := con.downstream.Recv()
+			if err != nil {
+				select {
+				case con.downstreamError <- err:
+				case <-con.stopChan:
+				}
+				return
+			}
+
+			// forward to istiod
+			con.sendRequest(req)
+			if !initialRequestsSent.Load() && req.TypeUrl == v3.ListenerType {
+				// fire off an initial NDS request
+				if _, f := p.handlers[v3.NameTableType]; f {
+					con.sendRequest(&discovery.DiscoveryRequest{
+						TypeUrl: v3.NameTableType,
+					})
+				}
+				// fire off an initial PCDS request
+				if _, f := p.handlers[v3.ProxyConfigType]; f {
+					con.sendRequest(&discovery.DiscoveryRequest{
+						TypeUrl: v3.ProxyConfigType,
+					})
+				}
+				// set flag before sending the initial request to prevent race.
+				initialRequestsSent.Store(true)
+				// Fire of a configured initial request, if there is one
+				p.connectedMutex.RLock()
+				initialRequest := p.initialRequest
+				if initialRequest != nil {
+					con.sendRequest(initialRequest)
+				}
+				p.connectedMutex.RUnlock()
+			}
+		}
+	}()
+
 	defer con.upstream.CloseSend() // nolint
 	for {
 		select {
 		case req := <-con.requestsChan:
+			if req.TypeUrl == v3.HealthInfoType && !initialRequestsSent.Load() {
+				// only send healthcheck probe after LDS request has been sent
+				continue
+			}
 			proxyLog.Debugf("request for type url %s", req.TypeUrl)
 			metrics.XdsProxyRequests.Increment()
 			if req.TypeUrl == v3.ExtensionConfigurationType {
diff --git a/pkg/istio-agent/xds_proxy_test.go b/pkg/istio-agent/xds_proxy_test.go
index a0fa14fe9c..8580e8399a 100644
--- a/pkg/istio-agent/xds_proxy_test.go
+++ b/pkg/istio-agent/xds_proxy_test.go
@@ -134,7 +134,6 @@ func TestXdsProxyHealthCheck(t *testing.T) {
 	setDialOptions(proxy, f.BufListener)
 	conn := setupDownstreamConnection(t, proxy)
 	downstream := stream(t, conn)
-	sendDownstreamWithNode(t, downstream, node)
 
 	// Setup test helpers
 	waitDisconnect := func() {
@@ -168,9 +167,30 @@ func TestXdsProxyHealthCheck(t *testing.T) {
 		}, retry.Timeout(time.Second*2))
 	}
 
-	// On initial connect, status is unset.
+	// send cds before healthcheck, to make wle registered
+	coreNode := &core.Node{
+		Id:       "sidecar~1.1.1.1~debug~cluster.local",
+		Metadata: node.ToStruct(),
+	}
+	err := downstream.Send(&discovery.DiscoveryRequest{TypeUrl: v3.ClusterType, Node: coreNode})
+	if err != nil {
+		t.Fatal(err)
+	}
+	_, err = downstream.Recv()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	// healthcheck before lds will be not sent
+	proxy.PersistRequest(healthy)
 	expectCondition("")
 
+	// simulate envoy send xds requests
+	sendDownstreamWithNode(t, downstream, node)
+
+	// after lds sent, the caching healthcheck will be resent
+	expectCondition(status.StatusTrue)
+
 	// Flip status back and forth, ensure we update
 	proxy.PersistRequest(healthy)
 	expectCondition(status.StatusTrue)
-- 
2.35.3

