From 84e873082378df818e2d8a3d8fa919768829502e Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Mon, 6 Dec 2021 16:22:10 -0800
Subject: operator: use shared kube client (#36350)

* operator: use shared kube client

Currently we create a TON of clients, and call a ton of things
redundantly. This consolodates the code so we use a single shared client
(almost?) everywhere.

Before: 180 GET calls to api server for `istioctl install`
After: 40 GET calls

* Fix test

* cleanup

* Revert burst
---
 istioctl/pkg/install/k8sversion/version.go    | 26 ++-----
 istioctl/pkg/install/verify.go                |  5 +-
 istioctl/pkg/verifier/verifier.go             | 62 +++++------------
 operator/cmd/mesh/install.go                  | 29 ++++----
 operator/cmd/mesh/manifest-generate_test.go   |  4 +-
 operator/cmd/mesh/manifest_shared_test.go     | 17 +++--
 operator/cmd/mesh/operator-init.go            | 16 ++---
 operator/cmd/mesh/operator-remove.go          |  6 +-
 operator/cmd/mesh/shared.go                   | 47 +++++--------
 operator/cmd/mesh/uninstall.go                | 10 +--
 .../istiocontrolplane_controller.go           | 42 +++++-------
 operator/pkg/helm/helm.go                     |  3 +-
 operator/pkg/helmreconciler/apply.go          |  2 +-
 operator/pkg/helmreconciler/reconciler.go     | 46 +++----------
 operator/pkg/helmreconciler/wait.go           | 19 ++----
 operator/pkg/manifest/shared.go               | 67 ++++++-------------
 operator/pkg/util/k8s.go                      | 14 ++--
 operator/pkg/util/k8s_test.go                 |  3 +-
 pkg/kube/client.go                            | 18 +++--
 tests/fuzz/helm_reconciler_fuzzer.go          |  2 +-
 tests/integration/operator/verify_test.go     |  6 +-
 21 files changed, 163 insertions(+), 281 deletions(-)

diff --git a/istioctl/pkg/install/k8sversion/version.go b/istioctl/pkg/install/k8sversion/version.go
index ad736f3a46..e25ab2c066 100644
--- a/istioctl/pkg/install/k8sversion/version.go
+++ b/istioctl/pkg/install/k8sversion/version.go
@@ -19,10 +19,9 @@
 
 	goversion "github.com/hashicorp/go-version"
 	"k8s.io/apimachinery/pkg/version"
-	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/rest"
 
 	"istio.io/istio/operator/pkg/util/clog"
+	"istio.io/istio/pkg/kube"
 	pkgVersion "istio.io/pkg/version"
 )
 
@@ -52,30 +51,13 @@ func extractKubernetesVersion(versionInfo *version.Info) (int, error) {
 	return num, nil
 }
 
-// GetKubernetesVersion fetches the Kubernetes minor version. For example, `v1.19.1` will return `19`
-func GetKubernetesVersion(restConfig *rest.Config) (int, error) {
-	client, err := kubernetes.NewForConfig(restConfig)
-	if err != nil {
-		return 0, fmt.Errorf("error creating Kubernetes client: %w", err)
-	}
-	serverVersion, err := client.Discovery().ServerVersion()
-	if err != nil {
-		return 0, fmt.Errorf("error getting Kubernetes version: %w", err)
-	}
-	return extractKubernetesVersion(serverVersion)
-}
-
 // IsK8VersionSupported checks minimum supported Kubernetes version for istio
-func IsK8VersionSupported(clientset kubernetes.Interface, l clog.Logger) error {
-	serverVersion, err := clientset.Discovery().ServerVersion()
+func IsK8VersionSupported(c kube.Client, l clog.Logger) error {
+	serverVersion, err := c.GetKubernetesVersion()
 	if err != nil {
 		return fmt.Errorf("error getting Kubernetes version: %w", err)
 	}
-	ok, err := CheckKubernetesVersion(serverVersion)
-	if err != nil {
-		return fmt.Errorf("error checking if Kubernetes version is supported: %w", err)
-	}
-	if !ok {
+	if !kube.IsAtLeastVersion(c, MinK8SVersion) {
 		l.LogAndPrintf("\nThe Kubernetes version %s is not supported by Istio %s. The minimum supported Kubernetes version is 1.%d.\n"+
 			"Proceeding with the installation, but you might experience problems. "+
 			"See https://istio.io/latest/docs/setup/platform-setup/ for a list of supported versions.\n",
diff --git a/istioctl/pkg/install/verify.go b/istioctl/pkg/install/verify.go
index 7ab112661a..0036aa01c2 100644
--- a/istioctl/pkg/install/verify.go
+++ b/istioctl/pkg/install/verify.go
@@ -75,8 +75,11 @@ func NewVerifyCommand() *cobra.Command {
 			return nil
 		},
 		RunE: func(c *cobra.Command, args []string) error {
-			installationVerifier := verifier.NewStatusVerifier(istioNamespace, manifestsPath,
+			installationVerifier, err := verifier.NewStatusVerifier(istioNamespace, manifestsPath,
 				*kubeConfigFlags.KubeConfig, *kubeConfigFlags.Context, filenames, opts, nil, nil)
+			if err != nil {
+				return err
+			}
 			if formatting.IstioctlColorDefault(c.OutOrStdout()) {
 				installationVerifier.Colorize()
 			}
diff --git a/istioctl/pkg/verifier/verifier.go b/istioctl/pkg/verifier/verifier.go
index 037334f1b9..49be05624d 100644
--- a/istioctl/pkg/verifier/verifier.go
+++ b/istioctl/pkg/verifier/verifier.go
@@ -56,14 +56,13 @@
 type StatusVerifier struct {
 	istioNamespace   string
 	manifestsPath    string
-	kubeconfig       string
-	context          string
 	filenames        []string
 	controlPlaneOpts clioptions.ControlPlaneOptions
 	logger           clog.Logger
 	iop              *v1alpha1.IstioOperator
 	successMarker    string
 	failureMarker    string
+	client           kube.ExtendedClient
 }
 
 // NewStatusVerifier creates a new instance of post-install verifier
@@ -71,22 +70,25 @@ type StatusVerifier struct {
 // TODO(su225): This is doing too many things. Refactor: break it down
 func NewStatusVerifier(istioNamespace, manifestsPath, kubeconfig, context string,
 	filenames []string, controlPlaneOpts clioptions.ControlPlaneOptions,
-	logger clog.Logger, installedIOP *v1alpha1.IstioOperator) *StatusVerifier {
+	logger clog.Logger, installedIOP *v1alpha1.IstioOperator) (*StatusVerifier, error) {
 	if logger == nil {
 		logger = clog.NewDefaultLogger()
 	}
+	client, err := kube.NewExtendedClient(kube.BuildClientCmd(kubeconfig, context), "")
+	if err != nil {
+		return nil, fmt.Errorf("failed to connect Kubernetes API server, error: %v", err)
+	}
 	return &StatusVerifier{
 		istioNamespace:   istioNamespace,
 		manifestsPath:    manifestsPath,
 		filenames:        filenames,
 		controlPlaneOpts: controlPlaneOpts,
 		logger:           logger,
-		kubeconfig:       kubeconfig,
-		context:          context,
+		client:           client,
 		iop:              installedIOP,
 		successMarker:    "✔",
 		failureMarker:    "✘",
-	}
+	}, nil
 }
 
 func (v *StatusVerifier) Colorize() {
@@ -138,8 +140,7 @@ func (v *StatusVerifier) verifyInstallIOPRevision() error {
 	if err != nil {
 		return err
 	}
-	mergedIOP, err := manifest.GetMergedIOP(string(by), profile, v.manifestsPath, v.controlPlaneOpts.Revision,
-		v.kubeconfig, v.context, v.logger)
+	mergedIOP, err := manifest.GetMergedIOP(string(by), profile, v.manifestsPath, v.controlPlaneOpts.Revision, v.client, v.logger)
 	if err != nil {
 		return err
 	}
@@ -152,11 +153,7 @@ func (v *StatusVerifier) getRevision() (string, error) {
 	var revision string
 	var revs string
 	revCount := 0
-	kubeClient, err := v.createClient()
-	if err != nil {
-		return "", err
-	}
-	pods, err := kubeClient.PodsForSelector(context.TODO(), v.istioNamespace, "app=istiod")
+	pods, err := v.client.PodsForSelector(context.TODO(), v.istioNamespace, "app=istiod")
 	if err != nil {
 		return "", fmt.Errorf("failed to fetch istiod pod, error: %v", err)
 	}
@@ -177,18 +174,6 @@ func (v *StatusVerifier) getRevision() (string, error) {
 	return revision, nil
 }
 
-func (v *StatusVerifier) createClient() (kube.ExtendedClient, error) {
-	cfg, err := kube.BuildClientConfig(v.kubeconfig, v.context)
-	if err != nil {
-		return nil, err
-	}
-	kubeClient, err := kube.NewExtendedClient(kube.NewClientConfigForRestConfig(cfg), "")
-	if err != nil {
-		return nil, fmt.Errorf("failed to connect Kubernetes API server, error: %v", err)
-	}
-	return kubeClient, nil
-}
-
 func (v *StatusVerifier) verifyFinalIOP() error {
 	crdCount, istioDeploymentCount, err := v.verifyPostInstallIstioOperator(
 		v.iop, fmt.Sprintf("IOP:%s", v.iop.GetName()))
@@ -197,7 +182,7 @@ func (v *StatusVerifier) verifyFinalIOP() error {
 
 func (v *StatusVerifier) verifyInstall() error {
 	// This is not a pre-check.  Check that the supplied resources exist in the cluster
-	r := resource.NewBuilder(v.k8sConfig()).
+	r := resource.NewBuilder(v.client.UtilFactory()).
 		Unstructured().
 		FilenameParam(false, &resource.FilenameOptions{Filenames: v.filenames}).
 		Flatten().
@@ -227,7 +212,7 @@ func (v *StatusVerifier) verifyPostInstallIstioOperator(iop *v1alpha1.IstioOpera
 		return 0, 0, errs.ToError()
 	}
 
-	builder := resource.NewBuilder(v.k8sConfig()).ContinueOnError().Unstructured()
+	builder := resource.NewBuilder(v.client.UtilFactory()).ContinueOnError().Unstructured()
 	for cat, manifest := range manifests {
 		for i, manitem := range manifest {
 			reader := strings.NewReader(manitem)
@@ -333,7 +318,7 @@ func (v *StatusVerifier) verifyPostInstall(visitor resource.Visitor, filename st
 			}
 			profile := manifest.GetProfile(unmergedIOP)
 			iop, err := manifest.GetMergedIOP(by, profile, v.manifestsPath, v.controlPlaneOpts.Revision,
-				v.kubeconfig, v.context, v.logger)
+				v.client, v.logger)
 			if err != nil {
 				v.reportFailure(kind, name, namespace, err)
 				return err
@@ -382,12 +367,7 @@ func (v *StatusVerifier) verifyPostInstall(visitor resource.Visitor, filename st
 
 // Find Istio injector matching revision.  ("" matches any revision.)
 func (v *StatusVerifier) injectorFromCluster(revision string) (*admit_v1.MutatingWebhookConfiguration, error) {
-	kubeClient, err := v.createClient()
-	if err != nil {
-		return nil, err
-	}
-	ctx := context.Background()
-	hooks, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().List(ctx, meta_v1.ListOptions{})
+	hooks, err := v.client.AdmissionregistrationV1().MutatingWebhookConfigurations().List(context.Background(), meta_v1.ListOptions{})
 	if err != nil {
 		return nil, err
 	}
@@ -416,15 +396,7 @@ func (v *StatusVerifier) injectorFromCluster(revision string) (*admit_v1.Mutatin
 // Find an IstioOperator matching revision in the cluster.  The IstioOperators
 // don't have a label for their revision, so we parse them and check .Spec.Revision
 func (v *StatusVerifier) operatorFromCluster(revision string) (*v1alpha1.IstioOperator, error) {
-	restConfig, err := v.k8sConfig().ToRESTConfig()
-	if err != nil {
-		return nil, err
-	}
-	client, err := dynamic.NewForConfig(restConfig)
-	if err != nil {
-		return nil, err
-	}
-	iops, err := AllOperatorsInCluster(client)
+	iops, err := AllOperatorsInCluster(v.client.Dynamic())
 	if err != nil {
 		return nil, err
 	}
@@ -491,10 +463,6 @@ func istioVerificationFailureError(filename string, reason error) error {
 	return fmt.Errorf("Istio installation failed, incomplete or does not match \"%s\": %v", filename, reason) // nolint
 }
 
-func (v *StatusVerifier) k8sConfig() *genericclioptions.ConfigFlags {
-	return &genericclioptions.ConfigFlags{KubeConfig: &v.kubeconfig, Context: &v.context}
-}
-
 func (v *StatusVerifier) reportFailure(kind, name, namespace string, err error) {
 	v.logger.LogAndPrintf("%s %s: %s.%s: %v", v.failureMarker, kind, name, namespace, err)
 }
diff --git a/operator/cmd/mesh/install.go b/operator/cmd/mesh/install.go
index 85055790c0..7d654c7a0d 100644
--- a/operator/cmd/mesh/install.go
+++ b/operator/cmd/mesh/install.go
@@ -24,12 +24,10 @@
 
 	"github.com/fatih/color"
 	"github.com/spf13/cobra"
-	"k8s.io/client-go/rest"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	"istio.io/api/operator/v1alpha1"
 	"istio.io/istio/istioctl/pkg/clioptions"
-	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	revtag "istio.io/istio/istioctl/pkg/tag"
 	"istio.io/istio/istioctl/pkg/verifier"
 	v1alpha12 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
@@ -135,25 +133,19 @@ func InstallCmd(logOpts *log.Options) *cobra.Command {
 
 func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, logOpts *log.Options) error {
 	l := clog.NewConsoleLogger(cmd.OutOrStdout(), cmd.ErrOrStderr(), installerScope)
-	var opts clioptions.ControlPlaneOptions
-	kubeClient, err := kube.NewExtendedClient(kube.BuildClientCmd(iArgs.kubeConfigPath, iArgs.context), opts.Revision)
-	if err != nil {
-		return fmt.Errorf("create Kubernetes client: %v", err)
-	}
-	restConfig, clientset, client, err := K8sConfig(iArgs.kubeConfigPath, iArgs.context)
+
+	kubeClient, client, err := KubernetesClients(iArgs.kubeConfigPath, iArgs.context, l)
 	if err != nil {
-		return fmt.Errorf("fetch Kubernetes config file: %v", err)
-	}
-	if err := k8sversion.IsK8VersionSupported(clientset, l); err != nil {
-		return fmt.Errorf("check minimum supported Kubernetes version: %v", err)
+		return err
 	}
+
 	tag, err := GetTagVersion(operatorVer.OperatorVersionString)
 	if err != nil {
 		return fmt.Errorf("fetch Istio version: %v", err)
 	}
 	setFlags := applyFlagAliases(iArgs.set, iArgs.manifestsPath, iArgs.revision)
 
-	_, iop, err := manifest.GenerateConfig(iArgs.inFilenames, setFlags, iArgs.force, restConfig, l)
+	_, iop, err := manifest.GenerateConfig(iArgs.inFilenames, setFlags, iArgs.force, kubeClient, l)
 	if err != nil {
 		return fmt.Errorf("generate config: %v", err)
 	}
@@ -189,7 +181,7 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 	if rev == "" && pilotEnabled {
 		_ = revtag.DeleteTagWebhooks(context.Background(), kubeClient, revtag.DefaultRevisionName)
 	}
-	iop, err = InstallManifests(iop, iArgs.force, rootArgs.dryRun, restConfig, client, iArgs.readinessTimeout, l)
+	iop, err = InstallManifests(iop, iArgs.force, rootArgs.dryRun, kubeClient, client, iArgs.readinessTimeout, l)
 	if err != nil {
 		return fmt.Errorf("failed to install manifests: %v", err)
 	}
@@ -220,8 +212,11 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 			return nil
 		}
 		l.LogAndPrint("\n\nVerifying installation:")
-		installationVerifier := verifier.NewStatusVerifier(iop.Namespace, iArgs.manifestsPath, iArgs.kubeConfigPath,
+		installationVerifier, err := verifier.NewStatusVerifier(iop.Namespace, iArgs.manifestsPath, iArgs.kubeConfigPath,
 			iArgs.context, iArgs.inFilenames, clioptions.ControlPlaneOptions{Revision: iop.Spec.Revision}, l, iop)
+		if err != nil {
+			return fmt.Errorf("failed to setup verifier: %v", err)
+		}
 		if err := installationVerifier.Verify(); err != nil {
 			return fmt.Errorf("verification failed with the following error: %v", err)
 		}
@@ -235,7 +230,7 @@ func runApplyCmd(cmd *cobra.Command, rootArgs *rootArgs, iArgs *installArgs, log
 //  force   validation warnings are written to logger but command is not aborted
 //  dryRun  all operations are done but nothing is written
 // Returns final IstioOperator after installation if successful.
-func InstallManifests(iop *v1alpha12.IstioOperator, force bool, dryRun bool, restConfig *rest.Config, client client.Client,
+func InstallManifests(iop *v1alpha12.IstioOperator, force bool, dryRun bool, kubeClient kube.Client, client client.Client,
 	waitTimeout time.Duration, l clog.Logger) (*v1alpha12.IstioOperator, error) {
 	// Needed in case we are running a test through this path that doesn't start a new process.
 	cache.FlushObjectCaches()
@@ -243,7 +238,7 @@ func InstallManifests(iop *v1alpha12.IstioOperator, force bool, dryRun bool, res
 		DryRun: dryRun, Log: l, WaitTimeout: waitTimeout, ProgressLog: progress.NewLog(),
 		Force: force,
 	}
-	reconciler, err := helmreconciler.NewHelmReconciler(client, nil, restConfig, iop, opts)
+	reconciler, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, opts)
 	if err != nil {
 		return iop, err
 	}
diff --git a/operator/cmd/mesh/manifest-generate_test.go b/operator/cmd/mesh/manifest-generate_test.go
index ec893d16f9..aeeb80856d 100644
--- a/operator/cmd/mesh/manifest-generate_test.go
+++ b/operator/cmd/mesh/manifest-generate_test.go
@@ -235,9 +235,9 @@ func TestManifestGenerateWithDuplicateMutatingWebhookConfig(t *testing.T) {
 		t.Fatal(err)
 	}
 
-	defer func() {
+	t.Cleanup(func() {
 		removeFile(filepath.Join(env.IstioSrc, helm.OperatorSubdirFilePath+"/"+testIstioDiscoveryChartPath+"/"+testResourceFile+".yaml"))
-	}()
+	})
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
diff --git a/operator/cmd/mesh/manifest_shared_test.go b/operator/cmd/mesh/manifest_shared_test.go
index 288171ee30..4da67e1d53 100644
--- a/operator/cmd/mesh/manifest_shared_test.go
+++ b/operator/cmd/mesh/manifest_shared_test.go
@@ -26,7 +26,6 @@
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/client-go/kubernetes"
-	testFakeClient "k8s.io/client-go/kubernetes/fake"
 	"k8s.io/client-go/kubernetes/scheme"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/client/fake"
@@ -41,6 +40,7 @@
 	"istio.io/istio/operator/pkg/object"
 	"istio.io/istio/operator/pkg/util"
 	"istio.io/istio/operator/pkg/util/clog"
+	"istio.io/istio/pkg/kube"
 	"istio.io/pkg/log"
 )
 
@@ -70,7 +70,6 @@
 	// Only used if kubebuilder is installed.
 	testenv               *envtest.Environment
 	testClient            client.Client
-	testClientSet         kubernetes.Interface
 	testReconcileOperator *istiocontrolplane.ReconcileIstioOperator
 
 	allNamespacedGVKs = append(helmreconciler.NamespacedResources,
@@ -121,7 +120,7 @@ func recreateTestEnv() error {
 		return err
 	}
 
-	testReconcileOperator = istiocontrolplane.NewReconcileIstioOperator(testClient, nil, testRestConfig, s)
+	testReconcileOperator = istiocontrolplane.NewReconcileIstioOperator(testClient, nil, s)
 	return nil
 }
 
@@ -133,8 +132,7 @@ func recreateSimpleTestEnv() {
 	s.AddKnownTypes(v1alpha1.SchemeGroupVersion, &v1alpha1.IstioOperator{})
 
 	testClient = fake.NewClientBuilder().WithScheme(s).Build()
-	testClientSet = testFakeClient.NewSimpleClientset()
-	testReconcileOperator = istiocontrolplane.NewReconcileIstioOperator(testClient, testClientSet, nil, s)
+	testReconcileOperator = istiocontrolplane.NewReconcileIstioOperator(testClient, kube.NewFakeClient(), s)
 }
 
 // runManifestCommands runs all testedManifestCmds commands with the given input IOP file, flags and chartSource.
@@ -194,7 +192,7 @@ func fakeApplyManifest(inFile, flags string, chartSource chartSourceType) (*Obje
 
 // fakeApplyExtraResources applies any extra resources for the given test name.
 func fakeApplyExtraResources(inFile string) error {
-	reconciler, err := helmreconciler.NewHelmReconciler(testClient, testClientSet, testRestConfig, nil, nil)
+	reconciler, err := helmreconciler.NewHelmReconciler(testClient, nil, nil, nil)
 	if err != nil {
 		return err
 	}
@@ -208,18 +206,19 @@ func fakeApplyExtraResources(inFile string) error {
 }
 
 func fakeControllerReconcile(inFile string, chartSource chartSourceType, opts *helmreconciler.Options) (*ObjectSet, error) {
+	c := kube.NewFakeClient()
 	l := clog.NewDefaultLogger()
 	_, iop, err := manifest.GenerateConfig(
 		[]string{inFileAbsolutePath(inFile)},
 		[]string{"installPackagePath=" + string(chartSource)},
-		false, testRestConfig, l)
+		false, c, l)
 	if err != nil {
 		return nil, err
 	}
 
 	iop.Spec.InstallPackagePath = string(chartSource)
 
-	reconciler, err := helmreconciler.NewHelmReconciler(testClient, testClientSet, testRestConfig, iop, opts)
+	reconciler, err := helmreconciler.NewHelmReconciler(testClient, c, iop, opts)
 	if err != nil {
 		return nil, err
 	}
@@ -342,7 +341,7 @@ func readFile(path string) (string, error) {
 
 // writeFile writes a file and returns an error if operation is unsuccessful.
 func writeFile(path string, data []byte) error {
-	return os.WriteFile(path, data, 0644)
+	return os.WriteFile(path, data, 0o644)
 }
 
 // removeFile removes given file from provided path.
diff --git a/operator/cmd/mesh/operator-init.go b/operator/cmd/mesh/operator-init.go
index ce58d6d9a6..b37a8be4a2 100644
--- a/operator/cmd/mesh/operator-init.go
+++ b/operator/cmd/mesh/operator-init.go
@@ -22,7 +22,6 @@
 	"github.com/spf13/cobra"
 
 	"istio.io/api/operator/v1alpha1"
-	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	iopv1alpha1 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/operator/pkg/name"
 	"istio.io/istio/operator/pkg/translate"
@@ -83,15 +82,12 @@ func operatorInitCmd(rootArgs *rootArgs, oiArgs *operatorInitArgs) *cobra.Comman
 func operatorInit(args *rootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
 	initLogsOrExit(args)
 
-	restConfig, clientset, client, err := K8sConfig(oiArgs.kubeConfigPath, oiArgs.context)
+	kubeClient, client, err := KubernetesClients(oiArgs.kubeConfigPath, oiArgs.context, l)
 	if err != nil {
 		l.LogAndFatal(err)
 	}
-	if err := k8sversion.IsK8VersionSupported(clientset, l); err != nil {
-		l.LogAndFatal(err)
-	}
 	// Error here likely indicates Deployment is missing. If some other K8s error, we will hit it again later.
-	already, _ := isControllerInstalled(clientset, oiArgs.common.operatorNamespace, oiArgs.common.revision)
+	already, _ := isControllerInstalled(kubeClient, oiArgs.common.operatorNamespace, oiArgs.common.revision)
 	if already {
 		l.LogAndPrintf("Operator controller is already installed in %s namespace.", oiArgs.common.operatorNamespace)
 		l.LogAndPrintf("Upgrading operator controller in namespace: %s using image: %s/operator:%s",
@@ -131,7 +127,7 @@ func operatorInit(args *rootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
 		}
 	}
 
-	if err := createNamespace(clientset, oiArgs.common.operatorNamespace, ""); err != nil {
+	if err := createNamespace(kubeClient, oiArgs.common.operatorNamespace, ""); err != nil {
 		l.LogAndFatal(err)
 	}
 
@@ -142,17 +138,17 @@ func operatorInit(args *rootArgs, oiArgs *operatorInitArgs, l clog.Logger) {
 		namespaces = append(namespaces, istioNamespace)
 	}
 	for _, ns := range namespaces {
-		if err := createNamespace(clientset, ns, ""); err != nil {
+		if err := createNamespace(kubeClient, ns, ""); err != nil {
 			l.LogAndFatal(err)
 		}
 	}
 
-	if err := applyManifest(restConfig, client, mstr, name.IstioOperatorComponentName, opts, iop, l); err != nil {
+	if err := applyManifest(kubeClient, client, mstr, name.IstioOperatorComponentName, opts, iop, l); err != nil {
 		l.LogAndFatal(err)
 	}
 
 	if customResource != "" {
-		if err := applyManifest(restConfig, client, customResource, name.IstioOperatorComponentName, opts, iop, l); err != nil {
+		if err := applyManifest(kubeClient, client, customResource, name.IstioOperatorComponentName, opts, iop, l); err != nil {
 			l.LogAndFatal(err)
 		}
 	}
diff --git a/operator/cmd/mesh/operator-remove.go b/operator/cmd/mesh/operator-remove.go
index 1b13ba7ae0..a01340e926 100644
--- a/operator/cmd/mesh/operator-remove.go
+++ b/operator/cmd/mesh/operator-remove.go
@@ -64,12 +64,12 @@ func operatorRemoveCmd(rootArgs *rootArgs, orArgs *operatorRemoveArgs) *cobra.Co
 func operatorRemove(args *rootArgs, orArgs *operatorRemoveArgs, l clog.Logger) {
 	initLogsOrExit(args)
 
-	restConfig, clientset, client, err := K8sConfig(orArgs.kubeConfigPath, orArgs.context)
+	kubeClient, client, err := KubernetesClients(orArgs.kubeConfigPath, orArgs.context, l)
 	if err != nil {
 		l.LogAndFatal(err)
 	}
 
-	installed, err := isControllerInstalled(clientset, orArgs.operatorNamespace, orArgs.revision)
+	installed, err := isControllerInstalled(kubeClient, orArgs.operatorNamespace, orArgs.revision)
 	if installed && err != nil {
 		l.LogAndFatal(err)
 	}
@@ -90,7 +90,7 @@ func operatorRemove(args *rootArgs, orArgs *operatorRemoveArgs, l clog.Logger) {
 			l.LogAndFatal(err)
 		}
 	}
-	reconciler, err := helmreconciler.NewHelmReconciler(client, nil, restConfig, iop, &helmreconciler.Options{DryRun: args.dryRun, Log: l})
+	reconciler, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, &helmreconciler.Options{DryRun: args.dryRun, Log: l})
 	if err != nil {
 		l.LogAndFatal(err)
 	}
diff --git a/operator/cmd/mesh/shared.go b/operator/cmd/mesh/shared.go
index a862afe253..85fcec9571 100644
--- a/operator/cmd/mesh/shared.go
+++ b/operator/cmd/mesh/shared.go
@@ -24,10 +24,10 @@
 	"time"
 
 	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/kubernetes/scheme"
 	"k8s.io/client-go/rest"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 
+	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	"istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/operator/pkg/cache"
 	"istio.io/istio/operator/pkg/helmreconciler"
@@ -95,41 +95,28 @@ func confirm(msg string, writer io.Writer) bool {
 	return false
 }
 
-// K8sConfig creates a rest.Config, Clientset and controller runtime Client from the given kubeconfig path and context.
-func K8sConfig(kubeConfigPath string, context string) (*rest.Config, *kubernetes.Clientset, client.Client, error) {
-	restConfig, clientset, err := InitK8SRestClient(kubeConfigPath, context)
+func KubernetesClients(kubeConfigPath, context string, l clog.Logger) (kube.ExtendedClient, client.Client, error) {
+	rc, err := kube.DefaultRestConfig(kubeConfigPath, context, func(config *rest.Config) {
+		// We are running a one-off command locally, so we don't need to worry too much about rate limitting
+		// Bumping this up greatly decreases install time
+		config.QPS = 50
+		config.Burst = 100
+	})
 	if err != nil {
-		return nil, nil, nil, err
+		return nil, nil, err
 	}
-	// We are running a one-off command locally, so we don't need to worry too much about rate limitting
-	// Bumping this up greatly decreases install time
-	restConfig.QPS = 50
-	restConfig.Burst = 100
-	client, err := client.New(restConfig, client.Options{Scheme: scheme.Scheme})
+	kubeClient, err := kube.NewExtendedClient(kube.NewClientConfigForRestConfig(rc), "")
 	if err != nil {
-		return nil, nil, nil, err
-	}
-	return restConfig, clientset, client, nil
-}
-
-// InitK8SRestClient creates a rest.Config qne Clientset from the given kubeconfig path and context.
-func InitK8SRestClient(kubeconfig, kubeContext string) (*rest.Config, *kubernetes.Clientset, error) {
-	if testRestConfig != nil || testK8Interface != nil {
-		if !(testRestConfig != nil && testK8Interface != nil) {
-			return nil, nil, fmt.Errorf("testRestConfig and testK8Interface must both be either nil or set")
-		}
-		return testRestConfig, testK8Interface, nil
+		return nil, nil, fmt.Errorf("create Kubernetes client: %v", err)
 	}
-	restConfig, err := kube.DefaultRestConfig(kubeconfig, kubeContext)
+	client, err := client.New(kubeClient.RESTConfig(), client.Options{Scheme: kube.IstioScheme})
 	if err != nil {
 		return nil, nil, err
 	}
-	clientset, err := kubernetes.NewForConfig(restConfig)
-	if err != nil {
-		return nil, nil, err
+	if err := k8sversion.IsK8VersionSupported(kubeClient, l); err != nil {
+		return nil, nil, fmt.Errorf("check minimum supported Kubernetes version: %v", err)
 	}
-
-	return restConfig, clientset, nil
+	return kubeClient, client, nil
 }
 
 // applyOptions contains the startup options for applying the manifest.
@@ -144,11 +131,11 @@ type applyOptions struct {
 	WaitTimeout time.Duration
 }
 
-func applyManifest(restConfig *rest.Config, client client.Client, manifestStr string,
+func applyManifest(kubeClient kube.Client, client client.Client, manifestStr string,
 	componentName name.ComponentName, opts *applyOptions, iop *v1alpha1.IstioOperator, l clog.Logger) error {
 	// Needed in case we are running a test through this path that doesn't start a new process.
 	cache.FlushObjectCaches()
-	reconciler, err := helmreconciler.NewHelmReconciler(client, nil, restConfig, iop, &helmreconciler.Options{DryRun: opts.DryRun, Log: l})
+	reconciler, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, &helmreconciler.Options{DryRun: opts.DryRun, Log: l})
 	if err != nil {
 		l.LogAndError(err)
 		return err
diff --git a/operator/cmd/mesh/uninstall.go b/operator/cmd/mesh/uninstall.go
index 6393962573..732a6d937e 100644
--- a/operator/cmd/mesh/uninstall.go
+++ b/operator/cmd/mesh/uninstall.go
@@ -127,9 +127,9 @@ func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, lo
 	if err := configLogs(logOpts); err != nil {
 		return fmt.Errorf("could not configure logs: %s", err)
 	}
-	restConfig, _, client, err := K8sConfig(uiArgs.kubeConfigPath, uiArgs.context)
+	kubeClient, client, err := KubernetesClients(uiArgs.kubeConfigPath, uiArgs.context, l)
 	if err != nil {
-		return err
+		l.LogAndFatal(err)
 	}
 	cache.FlushObjectCaches()
 	opts := &helmreconciler.Options{DryRun: rootArgs.dryRun, Log: l, ProgressLog: progress.NewLog()}
@@ -148,7 +148,7 @@ func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, lo
 		if err != nil {
 			return err
 		}
-		h, err := helmreconciler.NewHelmReconciler(client, nil, restConfig, iop, opts)
+		h, err := helmreconciler.NewHelmReconciler(client, kubeClient, iop, opts)
 		if err != nil {
 			return fmt.Errorf("failed to create reconciler: %v", err)
 		}
@@ -165,7 +165,7 @@ func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, lo
 		return nil
 	}
 	manifestMap, iop, err := manifest.GenManifests([]string{uiArgs.filename},
-		applyFlagAliases(uiArgs.set, uiArgs.manifestsPath, uiArgs.revision), uiArgs.force, restConfig, l)
+		applyFlagAliases(uiArgs.set, uiArgs.manifestsPath, uiArgs.revision), uiArgs.force, kubeClient, l)
 	if err != nil {
 		return err
 	}
@@ -175,7 +175,7 @@ func uninstall(cmd *cobra.Command, rootArgs *rootArgs, uiArgs *uninstallArgs, lo
 		return err
 	}
 	preCheckWarnings(cmd, uiArgs, iop.Spec.Revision, nil, cpObjects, l)
-	h, err = helmreconciler.NewHelmReconciler(client, nil, restConfig, iop, opts)
+	h, err = helmreconciler.NewHelmReconciler(client, kubeClient, iop, opts)
 	if err != nil {
 		return fmt.Errorf("failed to create reconciler: %v", err)
 	}
diff --git a/operator/pkg/controller/istiocontrolplane/istiocontrolplane_controller.go b/operator/pkg/controller/istiocontrolplane/istiocontrolplane_controller.go
index a79522d506..543df2f6eb 100644
--- a/operator/pkg/controller/istiocontrolplane/istiocontrolplane_controller.go
+++ b/operator/pkg/controller/istiocontrolplane/istiocontrolplane_controller.go
@@ -29,7 +29,6 @@
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
-	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/rest"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/controller"
@@ -55,6 +54,7 @@
 	"istio.io/istio/operator/pkg/util/clog"
 	"istio.io/istio/operator/pkg/util/progress"
 	"istio.io/istio/pkg/errdict"
+	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/url"
 	"istio.io/pkg/log"
 	"istio.io/pkg/version"
@@ -172,12 +172,11 @@ type Options struct {
 )
 
 // NewReconcileIstioOperator creates a new ReconcileIstioOperator and returns a ptr to it.
-func NewReconcileIstioOperator(client client.Client, clientSet kubernetes.Interface, config *rest.Config, scheme *runtime.Scheme) *ReconcileIstioOperator {
+func NewReconcileIstioOperator(client client.Client, kubeClient kube.Client, scheme *runtime.Scheme) *ReconcileIstioOperator {
 	return &ReconcileIstioOperator{
-		client:    client,
-		clientSet: clientSet,
-		config:    config,
-		scheme:    scheme,
+		client:     client,
+		kubeClient: kubeClient,
+		scheme:     scheme,
 	}
 }
 
@@ -185,11 +184,10 @@ func NewReconcileIstioOperator(client client.Client, clientSet kubernetes.Interf
 type ReconcileIstioOperator struct {
 	// This client, initialized using mgr.Client() above, is a split client
 	// that reads objects from the cache and writes to the apiserver
-	client    client.Client
-	clientSet kubernetes.Interface
-	config    *rest.Config
-	scheme    *runtime.Scheme
-	options   *Options
+	client     client.Client
+	kubeClient kube.Client
+	scheme     *runtime.Scheme
+	options    *Options
 }
 
 // Reconcile reads that state of the cluster for a IstioOperator object and makes changes based on the state read
@@ -262,7 +260,7 @@ func (r *ReconcileIstioOperator) Reconcile(_ context.Context, request reconcile.
 		}
 		scope.Infof("Deleting IstioOperator %s", iopName)
 
-		reconciler, err := helmreconciler.NewHelmReconciler(r.client, r.clientSet, r.config, iopMerged, nil)
+		reconciler, err := helmreconciler.NewHelmReconciler(r.client, r.kubeClient, iopMerged, nil)
 		if err != nil {
 			return reconcile.Result{}, err
 		}
@@ -320,12 +318,8 @@ func (r *ReconcileIstioOperator) Reconcile(_ context.Context, request reconcile.
 	}
 	globalValues := iopMerged.Spec.Values["global"].(map[string]interface{})
 	scope.Info("Detecting third-party JWT support")
-	kubeClient, err := kubernetes.NewForConfig(r.config)
-	if err != nil {
-		return reconcile.Result{}, nil
-	}
 	var jwtPolicy util.JWTPolicy
-	if jwtPolicy, err = util.DetectSupportedJWTPolicy(kubeClient); err != nil {
+	if jwtPolicy, err = util.DetectSupportedJWTPolicy(r.kubeClient); err != nil {
 		// TODO(howardjohn): add to dictionary. When resolved, replace this sentence with Done or WontFix - if WontFix, add reason.
 		scope.Warnf("Failed to detect third-party JWT support: %v", err)
 	} else {
@@ -336,11 +330,7 @@ func (r *ReconcileIstioOperator) Reconcile(_ context.Context, request reconcile.
 		}
 		globalValues["jwtPolicy"] = string(jwtPolicy)
 	}
-	client, err := kubernetes.NewForConfig(r.config)
-	if err != nil {
-		return reconcile.Result{}, err
-	}
-	err = util.ValidateIOPCAConfig(client, iopMerged)
+	err = util.ValidateIOPCAConfig(r.kubeClient, iopMerged)
 	if err != nil {
 		scope.Errorf(errdict.OperatorFailedToConfigure, "failed to apply IstioOperator resources. Error %s", err)
 		return reconcile.Result{}, err
@@ -352,7 +342,7 @@ func (r *ReconcileIstioOperator) Reconcile(_ context.Context, request reconcile.
 	if r.options != nil {
 		helmReconcilerOptions.Force = r.options.Force
 	}
-	reconciler, err := helmreconciler.NewHelmReconciler(r.client, r.clientSet, r.config, iopMerged, helmReconcilerOptions)
+	reconciler, err := helmreconciler.NewHelmReconciler(r.client, r.kubeClient, iopMerged, helmReconcilerOptions)
 	if err != nil {
 		return reconcile.Result{}, err
 	}
@@ -433,7 +423,11 @@ func mergeIOPSWithProfile(iop *iopv1alpha1.IstioOperator) (*v1alpha1.IstioOperat
 // and Start it when the Manager is Started. It also provides additional options to modify internal reconciler behavior.
 func Add(mgr manager.Manager, options *Options) error {
 	restConfig = mgr.GetConfig()
-	return add(mgr, &ReconcileIstioOperator{client: mgr.GetClient(), scheme: mgr.GetScheme(), config: mgr.GetConfig(), options: options})
+	kubeClient, err := kube.NewExtendedClient(kube.NewClientConfigForRestConfig(restConfig), "")
+	if err != nil {
+		return fmt.Errorf("create Kubernetes client: %v", err)
+	}
+	return add(mgr, &ReconcileIstioOperator{client: mgr.GetClient(), scheme: mgr.GetScheme(), kubeClient: kubeClient, options: options})
 }
 
 // add adds a new Controller to mgr with r as the reconcile.Reconciler
diff --git a/operator/pkg/helm/helm.go b/operator/pkg/helm/helm.go
index 94d627d79b..93ff36d645 100644
--- a/operator/pkg/helm/helm.go
+++ b/operator/pkg/helm/helm.go
@@ -99,7 +99,8 @@ func renderChart(namespace, values string, chrt *chart.Chart, filterFunc Templat
 		return "", fmt.Errorf("failed to unmarshal values: %v", err)
 	}
 
-	vals, err := chartutil.ToRenderValues(chrt, valuesMap, options, nil)
+	caps := *chartutil.DefaultCapabilities
+	vals, err := chartutil.ToRenderValues(chrt, valuesMap, options, &caps)
 	if err != nil {
 		return "", err
 	}
diff --git a/operator/pkg/helmreconciler/apply.go b/operator/pkg/helmreconciler/apply.go
index a02e355238..35c06518d0 100644
--- a/operator/pkg/helmreconciler/apply.go
+++ b/operator/pkg/helmreconciler/apply.go
@@ -132,7 +132,7 @@ func (h *HelmReconciler) ApplyManifest(manifest name.Manifest, serverSideApply b
 			return processedObjects, 0, errs.ToError()
 		}
 
-		err := WaitForResources(processedObjects, h.restConfig, h.clientSet,
+		err := WaitForResources(processedObjects, h.kubeClient,
 			h.opts.WaitTimeout, h.opts.DryRun, plog)
 		if err != nil {
 			werr := fmt.Errorf("failed to wait for resource: %v", err)
diff --git a/operator/pkg/helmreconciler/reconciler.go b/operator/pkg/helmreconciler/reconciler.go
index ec65cd9b00..a58d499595 100644
--- a/operator/pkg/helmreconciler/reconciler.go
+++ b/operator/pkg/helmreconciler/reconciler.go
@@ -30,12 +30,10 @@
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/rest"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	"istio.io/api/label"
 	"istio.io/api/operator/v1alpha1"
-	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	"istio.io/istio/istioctl/pkg/util/formatting"
 	istioV1Alpha1 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/operator/pkg/metrics"
@@ -56,8 +54,7 @@
 // HelmReconciler reconciles resources rendered by a set of helm charts.
 type HelmReconciler struct {
 	client     client.Client
-	restConfig *rest.Config
-	clientSet  kubernetes.Interface
+	kubeClient kube.Client
 	iop        *istioV1Alpha1.IstioOperator
 	opts       *Options
 	// copy of the last generated manifests.
@@ -94,8 +91,7 @@ type Options struct {
 }
 
 // NewHelmReconciler creates a HelmReconciler and returns a ptr to it
-func NewHelmReconciler(client client.Client, clientSet kubernetes.Interface, restConfig *rest.Config, iop *istioV1Alpha1.IstioOperator,
-	opts *Options) (*HelmReconciler, error) {
+func NewHelmReconciler(client client.Client, kubeClient kube.Client, iop *istioV1Alpha1.IstioOperator, opts *Options) (*HelmReconciler, error) {
 	if opts == nil {
 		opts = defaultOptions
 	}
@@ -121,20 +117,9 @@ func NewHelmReconciler(client client.Client, clientSet kubernetes.Interface, res
 		iop = &istioV1Alpha1.IstioOperator{}
 		iop.Spec = &v1alpha1.IstioOperatorSpec{}
 	}
-	var cs kubernetes.Interface
-	var err error
-	if clientSet != nil {
-		cs = clientSet
-	} else if restConfig != nil {
-		cs, err = kubernetes.NewForConfig(restConfig)
-	}
-	if err != nil {
-		return nil, err
-	}
 	return &HelmReconciler{
 		client:           client,
-		restConfig:       restConfig,
-		clientSet:        cs,
+		kubeClient:       kubeClient,
 		iop:              iop,
 		opts:             opts,
 		dependencyWaitCh: initDependencies(),
@@ -251,19 +236,14 @@ func (h *HelmReconciler) processRecursive(manifests name.ManifestMap) *v1alpha1.
 
 // CheckSSAEnabled is a helper function to check whether ServerSideApply should be used when applying manifests.
 func (h *HelmReconciler) CheckSSAEnabled() bool {
-	if h.restConfig != nil {
-		// check k8s minor version
-		k8sVer, err := k8sversion.GetKubernetesVersion(h.restConfig)
-		if err != nil {
-			scope.Errorf("failed to get k8s version: %s", err)
-		}
+	if h.kubeClient != nil {
 		// There is a mutatingwebhook in gke that would corrupt the managedFields, which is fixed in k8s 1.18.
 		// See: https://github.com/kubernetes/kubernetes/issues/96351
-		if k8sVer >= 18 {
+		if kube.IsAtLeastVersion(h.kubeClient, 18) {
 			// todo(kebe7jun) a more general test method
 			// API Server does not support detecting whether ServerSideApply is enabled
 			// through the API for the time being.
-			ns, err := h.clientSet.CoreV1().Namespaces().Get(context.TODO(), constants.KubeSystemNamespace, v12.GetOptions{})
+			ns, err := h.kubeClient.Kube().CoreV1().Namespaces().Get(context.TODO(), constants.KubeSystemNamespace, v12.GetOptions{})
 			if err != nil {
 				scope.Warnf("failed to get namespace: %v", err)
 				return false
@@ -495,8 +475,8 @@ func (h *HelmReconciler) getCRHash(componentName string) (string, error) {
 		return "", err
 	}
 	var host string
-	if h.restConfig != nil {
-		host = h.restConfig.Host
+	if h.kubeClient != nil && h.kubeClient.RESTConfig() != nil {
+		host = h.kubeClient.RESTConfig().Host
 	}
 	return strings.Join([]string{crName, crNamespace, componentName, host}, "-"), nil
 }
@@ -595,12 +575,8 @@ func (h *HelmReconciler) analyzeWebhooks(whs []string) error {
 		return err
 	}
 
-	if h.restConfig != nil {
-		k, err := kube.NewClient(kube.NewClientConfigForRestConfig(h.restConfig))
-		if err != nil {
-			return err
-		}
-		sa.AddRunningKubeSource(k)
+	if h.kubeClient != nil {
+		sa.AddRunningKubeSource(h.kubeClient)
 	}
 
 	// Analyze webhooks
@@ -624,7 +600,7 @@ func (h *HelmReconciler) createNamespace(namespace string, network string) error
 	if h.opts.DryRun {
 		return nil
 	}
-	return CreateNamespace(h.clientSet, namespace, network)
+	return CreateNamespace(h.kubeClient, namespace, network)
 }
 
 func (h *HelmReconciler) networkName() string {
diff --git a/operator/pkg/helmreconciler/wait.go b/operator/pkg/helmreconciler/wait.go
index 2b6b040496..9085c860ab 100644
--- a/operator/pkg/helmreconciler/wait.go
+++ b/operator/pkg/helmreconciler/wait.go
@@ -24,17 +24,16 @@
 	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
 	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
-	apiextensionsclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/labels"
 	"k8s.io/apimachinery/pkg/util/wait"
 	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/rest"
 	kctldeployment "k8s.io/kubectl/pkg/util/deployment"
 
 	"istio.io/istio/operator/pkg/name"
 	"istio.io/istio/operator/pkg/object"
 	"istio.io/istio/operator/pkg/util/progress"
+	"istio.io/istio/pkg/kube"
 )
 
 const (
@@ -54,13 +53,13 @@ type deployment struct {
 
 // WaitForResources polls to get the current status of all pods, PVCs, and Services
 // until all are ready or a timeout is reached
-func WaitForResources(objects object.K8sObjects, restConfig *rest.Config, cs kubernetes.Interface,
+func WaitForResources(objects object.K8sObjects, client kube.Client,
 	waitTimeout time.Duration, dryRun bool, l *progress.ManifestLog) error {
 	if dryRun || TestMode {
 		return nil
 	}
 
-	if err := waitForCRDs(objects, restConfig); err != nil {
+	if err := waitForCRDs(objects, client); err != nil {
 		return err
 	}
 
@@ -68,12 +67,12 @@ func WaitForResources(objects object.K8sObjects, restConfig *rest.Config, cs kub
 	var debugInfo map[string]string
 
 	// Check if we are ready immediately, to avoid the 2s delay below when we are already redy
-	if ready, _, _, err := waitForResources(objects, cs, l); err == nil && ready {
+	if ready, _, _, err := waitForResources(objects, client, l); err == nil && ready {
 		return nil
 	}
 
 	errPoll := wait.Poll(2*time.Second, waitTimeout, func() (bool, error) {
-		isReady, notReadyObjects, debugInfoObjects, err := waitForResources(objects, cs, l)
+		isReady, notReadyObjects, debugInfoObjects, err := waitForResources(objects, client, l)
 		notReady = notReadyObjects
 		debugInfo = debugInfoObjects
 		return isReady, err
@@ -154,7 +153,7 @@ func waitForResources(objects object.K8sObjects, cs kubernetes.Interface, l *pro
 	return isReady, notReady, resourceDebugInfo, nil
 }
 
-func waitForCRDs(objects object.K8sObjects, restConfig *rest.Config) error {
+func waitForCRDs(objects object.K8sObjects, client kube.Client) error {
 	var crdNames []string
 	for _, o := range object.KindObjects(objects, name.CRDStr) {
 		crdNames = append(crdNames, o.Name)
@@ -162,15 +161,11 @@ func waitForCRDs(objects object.K8sObjects, restConfig *rest.Config) error {
 	if len(crdNames) == 0 {
 		return nil
 	}
-	cs, err := apiextensionsclient.NewForConfig(restConfig)
-	if err != nil {
-		return fmt.Errorf("k8s client error: %s", err)
-	}
 
 	errPoll := wait.Poll(cRDPollInterval, cRDPollTimeout, func() (bool, error) {
 	descriptor:
 		for _, crdName := range crdNames {
-			crd, errGet := cs.ApiextensionsV1().CustomResourceDefinitions().Get(context.TODO(), crdName, metav1.GetOptions{})
+			crd, errGet := client.Ext().ApiextensionsV1().CustomResourceDefinitions().Get(context.TODO(), crdName, metav1.GetOptions{})
 			if errGet != nil {
 				return false, errGet
 			}
diff --git a/operator/pkg/manifest/shared.go b/operator/pkg/manifest/shared.go
index 302a086dbe..ebb6f59af0 100644
--- a/operator/pkg/manifest/shared.go
+++ b/operator/pkg/manifest/shared.go
@@ -21,12 +21,9 @@
 	"path/filepath"
 	"strings"
 
-	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/rest"
 	"sigs.k8s.io/yaml"
 
 	"istio.io/api/operator/v1alpha1"
-	"istio.io/istio/istioctl/pkg/install/k8sversion"
 	iopv1alpha1 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
 	"istio.io/istio/operator/pkg/apis/istio/v1alpha1/validation"
 	"istio.io/istio/operator/pkg/controlplane"
@@ -52,8 +49,8 @@
 // If force is set, validation errors will not cause processing to abort but will result in warnings going to the
 // supplied logger.
 func GenManifests(inFilename []string, setFlags []string, force bool,
-	kubeConfig *rest.Config, l clog.Logger) (name.ManifestMap, *iopv1alpha1.IstioOperator, error) {
-	mergedYAML, _, err := GenerateConfig(inFilename, setFlags, force, kubeConfig, l)
+	client kube.Client, l clog.Logger) (name.ManifestMap, *iopv1alpha1.IstioOperator, error) {
+	mergedYAML, _, err := GenerateConfig(inFilename, setFlags, force, client, l)
 	if err != nil {
 		return nil, nil, err
 	}
@@ -90,7 +87,7 @@ func GenManifests(inFilename []string, setFlags []string, force bool,
 // Otherwise it will be the compiled in profile YAMLs.
 // In step 3, the remaining fields in the same user overlay are applied on the resulting profile base.
 // The force flag causes validation errors not to abort but only emit log/console warnings.
-func GenerateConfig(inFilenames []string, setFlags []string, force bool, kubeConfig *rest.Config,
+func GenerateConfig(inFilenames []string, setFlags []string, force bool, client kube.Client,
 	l clog.Logger) (string, *iopv1alpha1.IstioOperator, error) {
 	if err := validateSetFlags(setFlags); err != nil {
 		return "", nil, err
@@ -101,12 +98,12 @@ func GenerateConfig(inFilenames []string, setFlags []string, force bool, kubeCon
 		return "", nil, err
 	}
 
-	return OverlayYAMLStrings(profile, fy, setFlags, force, kubeConfig, l)
+	return OverlayYAMLStrings(profile, fy, setFlags, force, client, l)
 }
 
 func OverlayYAMLStrings(profile string, fy string,
-	setFlags []string, force bool, kubeConfig *rest.Config, l clog.Logger) (string, *iopv1alpha1.IstioOperator, error) {
-	iopsString, iops, err := GenIOPFromProfile(profile, fy, setFlags, force, false, kubeConfig, l)
+	setFlags []string, force bool, client kube.Client, l clog.Logger) (string, *iopv1alpha1.IstioOperator, error) {
+	iopsString, iops, err := GenIOPFromProfile(profile, fy, setFlags, force, false, client, l)
 	if err != nil {
 		return "", nil, err
 	}
@@ -125,7 +122,7 @@ func OverlayYAMLStrings(profile string, fy string,
 // GenIOPFromProfile generates an IstioOperator from the given profile name or path, and overlay YAMLs from user
 // files and the --set flag. If successful, it returns an IstioOperator string and struct.
 func GenIOPFromProfile(profileOrPath, fileOverlayYAML string, setFlags []string, skipValidation, allowUnknownField bool,
-	kubeConfig *rest.Config, l clog.Logger) (string, *iopv1alpha1.IstioOperator, error) {
+	client kube.Client, l clog.Logger) (string, *iopv1alpha1.IstioOperator, error) {
 	installPackagePath, err := getInstallPackagePath(fileOverlayYAML)
 	if err != nil {
 		return "", nil, err
@@ -155,8 +152,8 @@ func GenIOPFromProfile(profileOrPath, fileOverlayYAML string, setFlags []string,
 	}
 
 	// Merge k8s specific values.
-	if kubeConfig != nil {
-		kubeOverrides, err := getClusterSpecificValues(kubeConfig, skipValidation, l)
+	if client != nil {
+		kubeOverrides, err := getClusterSpecificValues(client, skipValidation, l)
 		if err != nil {
 			return "", nil, err
 		}
@@ -197,11 +194,7 @@ func GenIOPFromProfile(profileOrPath, fileOverlayYAML string, setFlags []string,
 	}
 
 	// Validate Final IOP config against K8s cluster
-	if kubeConfig != nil {
-		client, err := kubernetes.NewForConfig(kubeConfig)
-		if err != nil {
-			return "", nil, err
-		}
+	if client != nil {
 		err = util.ValidateIOPCAConfig(client, finalIOP)
 		if err != nil {
 			return "", nil, err
@@ -330,12 +323,8 @@ func GetProfile(iop *iopv1alpha1.IstioOperator) string {
 	return profile
 }
 
-func GetMergedIOP(userIOPStr, profile, manifestsPath, revision, kubeConfigPath, context string,
+func GetMergedIOP(userIOPStr, profile, manifestsPath, revision string, client kube.Client,
 	logger clog.Logger) (*iopv1alpha1.IstioOperator, error) {
-	restConfig, err := kube.BuildClientConfig(kubeConfigPath, context)
-	if err != nil {
-		return nil, err
-	}
 	extraFlags := make([]string, 0)
 	if manifestsPath != "" {
 		extraFlags = append(extraFlags, fmt.Sprintf("installPackagePath=%s", manifestsPath))
@@ -343,7 +332,7 @@ func GetMergedIOP(userIOPStr, profile, manifestsPath, revision, kubeConfigPath,
 	if revision != "" {
 		extraFlags = append(extraFlags, fmt.Sprintf("revision=%s", revision))
 	}
-	_, mergedIOP, err := OverlayYAMLStrings(profile, userIOPStr, extraFlags, false, restConfig, logger)
+	_, mergedIOP, err := OverlayYAMLStrings(profile, userIOPStr, extraFlags, false, client, logger)
 	if err != nil {
 		return nil, err
 	}
@@ -419,20 +408,14 @@ func overlayHubAndTag(yml string) (string, error) {
 	return out, nil
 }
 
-func getClusterSpecificValues(config *rest.Config, force bool, l clog.Logger) (string, error) {
+func getClusterSpecificValues(client kube.Client, force bool, l clog.Logger) (string, error) {
 	overlays := []string{}
 
-	fsgroup, err := getFSGroupOverlay(config)
-	if err != nil {
-		if force {
-			l.LogAndPrint(err)
-		} else {
-			return "", err
-		}
-	} else if fsgroup != "" {
+	fsgroup := getFSGroupOverlay(client)
+	if fsgroup != "" {
 		overlays = append(overlays, fsgroup)
 	}
-	jwt, err := getJwtTypeOverlay(config, l)
+	jwt, err := getJwtTypeOverlay(client, l)
 	if err != nil {
 		if force {
 			l.LogAndPrint(err)
@@ -445,15 +428,11 @@ func getClusterSpecificValues(config *rest.Config, force bool, l clog.Logger) (s
 	return makeTreeFromSetList(overlays)
 }
 
-func getFSGroupOverlay(config *rest.Config) (string, error) {
-	version, err := k8sversion.GetKubernetesVersion(config)
-	if err != nil {
-		return "", fmt.Errorf("failed to determine JWT policy support. Use the --force flag to ignore this: %v", err)
+func getFSGroupOverlay(config kube.Client) string {
+	if kube.IsAtLeastVersion(config, 19) {
+		return "values.pilot.env.ENABLE_LEGACY_FSGROUP_INJECTION=false"
 	}
-	if version >= 19 {
-		return "values.pilot.env.ENABLE_LEGACY_FSGROUP_INJECTION=false", nil
-	}
-	return "", nil
+	return ""
 }
 
 // makeTreeFromSetList creates a YAML tree from a string slice containing key-value pairs in the format key=value.
@@ -489,11 +468,7 @@ func makeTreeFromSetList(setOverlay []string) (string, error) {
 	return tpath.AddSpecRoot(string(out))
 }
 
-func getJwtTypeOverlay(config *rest.Config, l clog.Logger) (string, error) {
-	client, err := kubernetes.NewForConfig(config)
-	if err != nil {
-		return "", err
-	}
+func getJwtTypeOverlay(client kube.Client, l clog.Logger) (string, error) {
 	jwtPolicy, err := util.DetectSupportedJWTPolicy(client)
 	if err != nil {
 		return "", fmt.Errorf("failed to determine JWT policy support. Use the --force flag to ignore this: %v", err)
diff --git a/operator/pkg/util/k8s.go b/operator/pkg/util/k8s.go
index 194f2414db..2f90ffd831 100644
--- a/operator/pkg/util/k8s.go
+++ b/operator/pkg/util/k8s.go
@@ -16,13 +16,13 @@
 
 import (
 	"fmt"
-	"strconv"
 
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/client-go/discovery"
 	"k8s.io/client-go/kubernetes"
 
 	iopv1alpha1 "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
+	"istio.io/istio/pkg/kube"
 )
 
 type JWTPolicy string
@@ -63,7 +63,7 @@ func GKString(gvk schema.GroupKind) string {
 }
 
 // ValidateIOPCAConfig validates if the IstioOperator CA configs are applicable to the K8s cluster
-func ValidateIOPCAConfig(client kubernetes.Interface, iop *iopv1alpha1.IstioOperator) error {
+func ValidateIOPCAConfig(client kube.Client, iop *iopv1alpha1.IstioOperator) error {
 	globalI := iop.Spec.Values["global"]
 	global, ok := globalI.(map[string]interface{})
 	if !ok {
@@ -76,16 +76,14 @@ func ValidateIOPCAConfig(client kubernetes.Interface, iop *iopv1alpha1.IstioOper
 		return nil
 	}
 	if ca == "kubernetes" {
-		versionInfo, err := client.Discovery().ServerVersion()
+		ver, err := client.GetKubernetesVersion()
 		if err != nil {
 			return fmt.Errorf("failed to determine support for K8s legacy signer. Use the --force flag to ignore this: %v", err)
 		}
-		minor, _ := strconv.Atoi(versionInfo.Minor)
-		major, _ := strconv.Atoi(versionInfo.Major)
 
-		if minor >= 22 || major > 1 {
-			return fmt.Errorf("configuration PILOT_CERT_PROVIDER=%s not supported in k8s minor version %v."+
-				"Please pick another value for PILOT_CERT_PROVIDER", ca, minor)
+		if kube.IsAtLeastVersion(client, 22) {
+			return fmt.Errorf("configuration PILOT_CERT_PROVIDER=%s not supported in Kubernetes %v."+
+				"Please pick another value for PILOT_CERT_PROVIDER", ca, ver.String())
 		}
 	}
 	return nil
diff --git a/operator/pkg/util/k8s_test.go b/operator/pkg/util/k8s_test.go
index 2454d3577d..2f78ef1d53 100644
--- a/operator/pkg/util/k8s_test.go
+++ b/operator/pkg/util/k8s_test.go
@@ -22,6 +22,7 @@
 	"k8s.io/client-go/kubernetes/fake"
 
 	pkgAPI "istio.io/istio/operator/pkg/apis/istio/v1alpha1"
+	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/util/gogoprotomarshal"
 )
 
@@ -52,7 +53,6 @@
 
 func TestValidateIOPCAConfig(t *testing.T) {
 	var err error
-	k8sClient := fake.NewSimpleClientset()
 
 	tests := []struct {
 		major        string
@@ -87,6 +87,7 @@ func TestValidateIOPCAConfig(t *testing.T) {
 	}
 
 	for i, tt := range tests {
+		k8sClient := kube.NewFakeClient()
 		k8sClient.Discovery().(*fakediscovery.FakeDiscovery).FakedServerVersion = &version.Info{
 			Major: tt.major,
 			Minor: tt.minor,
diff --git a/pkg/kube/client.go b/pkg/kube/client.go
index a6477e8b78..0f0a50d44d 100644
--- a/pkg/kube/client.go
+++ b/pkg/kube/client.go
@@ -80,6 +80,7 @@
 	istioclient "istio.io/client-go/pkg/clientset/versioned"
 	istiofake "istio.io/client-go/pkg/clientset/versioned/fake"
 	istioinformer "istio.io/client-go/pkg/informers/externalversions"
+	"istio.io/istio/operator/pkg/apis"
 	"istio.io/istio/pkg/kube/mcs"
 	"istio.io/istio/pkg/queue"
 	"istio.io/pkg/version"
@@ -333,7 +334,6 @@ type client struct {
 
 	versionOnce sync.Once
 	version     *kubeVersion.Info
-	versionErr  error
 }
 
 // newClientInternal creates a Kubernetes client from the given factory.
@@ -506,10 +506,19 @@ func (c *client) RunAndWait(stop <-chan struct{}) {
 func (c *client) GetKubernetesVersion() (*kubeVersion.Info, error) {
 	c.versionOnce.Do(func() {
 		v, err := c.Discovery().ServerVersion()
-		c.version = v
-		c.versionErr = err
+		if err == nil {
+			c.version = v
+		}
 	})
-	return c.version, c.versionErr
+	if c.version != nil {
+		return c.version, nil
+	}
+	// Initial attempt failed, retry on each call to this function
+	v, err := c.Discovery().ServerVersion()
+	if err != nil {
+		c.version = v
+	}
+	return c.version, err
 }
 
 type reflectInformerSync interface {
@@ -1058,5 +1067,6 @@ func isEmptyFile(f string) bool {
 	utilruntime.Must(clienttelemetry.AddToScheme(scheme))
 	utilruntime.Must(clientextensions.AddToScheme(scheme))
 	utilruntime.Must(gatewayapi.AddToScheme(scheme))
+	utilruntime.Must(apis.AddToScheme(scheme))
 	return scheme
 }()
diff --git a/tests/fuzz/helm_reconciler_fuzzer.go b/tests/fuzz/helm_reconciler_fuzzer.go
index c8c8d63ea0..94d266512f 100644
--- a/tests/fuzz/helm_reconciler_fuzzer.go
+++ b/tests/fuzz/helm_reconciler_fuzzer.go
@@ -53,7 +53,7 @@ func FuzzHelmReconciler(data []byte) int {
 		return 0
 	}
 	cl := &fakeClientWrapper{fake.NewClientBuilder().WithRuntimeObjects(obj).Build()}
-	h, err := helmreconciler.NewHelmReconciler(cl, nil, nil, nil, nil)
+	h, err := helmreconciler.NewHelmReconciler(cl, nil, nil, nil)
 	if err != nil {
 		return 0
 	}
diff --git a/tests/integration/operator/verify_test.go b/tests/integration/operator/verify_test.go
index 17cb32f2be..27ad8e9f6e 100644
--- a/tests/integration/operator/verify_test.go
+++ b/tests/integration/operator/verify_test.go
@@ -53,10 +53,12 @@ func TestPostInstallControlPlaneVerification(t *testing.T) {
 				"-y",
 			}
 			istioCtl.InvokeOrFail(t, installCmd)
-
 			tfLogger := clog.NewConsoleLogger(io.Discard, io.Discard, scopes.Framework)
-			statusVerifier := verifier.NewStatusVerifier(IstioNamespace, ManifestPath, "",
+			statusVerifier, err := verifier.NewStatusVerifier(IstioNamespace, ManifestPath, "",
 				"", []string{}, clioptions.ControlPlaneOptions{}, tfLogger, nil)
+			if err != nil {
+				t.Fatal(err)
+			}
 			if err := statusVerifier.Verify(); err != nil {
 				t.Fatal(err)
 			}
-- 
2.35.3

