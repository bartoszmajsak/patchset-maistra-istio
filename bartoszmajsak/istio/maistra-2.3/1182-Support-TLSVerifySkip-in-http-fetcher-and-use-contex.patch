From f0a2aa7ef44b78f698459d112bb98070e2927133 Mon Sep 17 00:00:00 2001
From: Ingwon Song <102102227+ingwonsong@users.noreply.github.com>
Date: Wed, 4 May 2022 19:23:59 -0700
Subject: Support TLSVerifySkip in http fetcher, and use context-based timeout
 (#38571)

* Support TLSVerifySkip in http fetcher, and use context-based timeout instead of setting timeout on HTTP Client

* Share httpfetcher globally to use connections

* Add the test cases for skipping insecure https server

* Move back httpfetcher to a field of the cache

* Add the release note.

* Fix the test description

* Add the per-request timeout back

* Change to use constants instead of directly putting the numbers regarding HTTP timeout and retries

* Update pkg/wasm/cache.go

Co-authored-by: John Howard <howardjohn@google.com>

* Exits earlier when context timeout happen.

Co-authored-by: John Howard <howardjohn@google.com>
---
 pilot/cmd/pilot-agent/options/options.go      |  2 +-
 pkg/wasm/cache.go                             | 21 +++--
 pkg/wasm/cache_test.go                        | 16 +++-
 pkg/wasm/httpfetcher.go                       | 47 +++++++---
 pkg/wasm/httpfetcher_test.go                  | 93 +++++++++++++++++--
 .../notes/wasm-https-insecure-support.yaml    |  7 ++
 6 files changed, 151 insertions(+), 35 deletions(-)
 create mode 100644 releasenotes/notes/wasm-https-insecure-support.yaml

diff --git a/pilot/cmd/pilot-agent/options/options.go b/pilot/cmd/pilot-agent/options/options.go
index ab01a13252..cc18a74934 100644
--- a/pilot/cmd/pilot-agent/options/options.go
+++ b/pilot/cmd/pilot-agent/options/options.go
@@ -102,7 +102,7 @@
 		"If set to true, agent retrieves dynamic proxy-config updates via xds channel").Get()
 
 	wasmInsecureRegistries = env.RegisterStringVar("WASM_INSECURE_REGISTRIES", "",
-		"allow agent pull wasm plugin from insecure registries, for example: 'localhost:5000,docker-registry:5000'").Get()
+		"allow agent pull wasm plugin from insecure registries or https server, for example: 'localhost:5000,docker-registry:5000'").Get()
 
 	// Ability of istio-agent to retrieve bootstrap via XDS
 	enableBootstrapXdsEnv = env.RegisterBoolVar("BOOTSTRAP_XDS_AGENT", false,
diff --git a/pkg/wasm/cache.go b/pkg/wasm/cache.go
index 8b0d411420..600c367be1 100644
--- a/pkg/wasm/cache.go
+++ b/pkg/wasm/cache.go
@@ -44,6 +44,13 @@
 	// DefaultWasmModuleExpiry is the default duration for least recently touched Wasm module to become stale.
 	DefaultWasmModuleExpiry = 24 * time.Hour
 
+	// Default timeout per a HTTP/HTTPS request for HTTP/HTTPS-based wasm pulling.
+	DefaultWasmHTTPRequestTimeout = 5 * time.Second
+
+	// Default maximum number of HTTP/HTTPS request retries for HTTP/HTTPS-based wasm pulling.
+	// Note that, if the timeout specified in WasmPlugin is reaching out, then the pulling is stopped even though the retry count is still less than this value.
+	DefaultWasmHTTPRequestMaxRetries = 5
+
 	// oci URL prefix
 	ociURLPrefix = "oci://"
 
@@ -121,7 +128,7 @@ type cacheEntry struct {
 // NewLocalFileCache create a new Wasm module cache which downloads and stores Wasm module files locally.
 func NewLocalFileCache(dir string, purgeInterval, moduleExpiry time.Duration, insecureRegistries []string) *LocalFileCache {
 	cache := &LocalFileCache{
-		httpFetcher:        NewHTTPFetcher(),
+		httpFetcher:        NewHTTPFetcher(DefaultWasmHTTPRequestTimeout),
 		modules:            make(map[moduleKey]*cacheEntry),
 		checksums:          make(map[string]*checksumEntry),
 		dir:                dir,
@@ -195,10 +202,14 @@ func (c *LocalFileCache) Get(
 	// Hex-Encoded sha256 checksum of binary.
 	var dChecksum string
 	var binaryFetcher func() ([]byte, error)
+	insecure := c.insecureRegistries.Contains(u.Host)
+
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
 	switch u.Scheme {
 	case "http", "https":
 		// Download the Wasm module with http fetcher.
-		b, err = c.httpFetcher.Fetch(downloadURL, timeout)
+		b, err = c.httpFetcher.Fetch(ctx, downloadURL, insecure)
 		if err != nil {
 			wasmRemoteFetchCount.With(resultTag.Value(downloadFailure)).Increment()
 			return "", err
@@ -208,13 +219,7 @@ func (c *LocalFileCache) Get(
 		sha := sha256.Sum256(b)
 		dChecksum = hex.EncodeToString(sha[:])
 	case "oci":
-		ctx, cancel := context.WithTimeout(context.Background(), timeout)
-		defer cancel()
 
-		insecure := false
-		if c.insecureRegistries.Contains(u.Host) {
-			insecure = true
-		}
 		// TODO: support imagePullSecret and pass it to ImageFetcherOption.
 		imgFetcherOps := ImageFetcherOption{
 			Insecure: insecure,
diff --git a/pkg/wasm/cache_test.go b/pkg/wasm/cache_test.go
index 6f0b734143..ea9860351b 100644
--- a/pkg/wasm/cache_test.go
+++ b/pkg/wasm/cache_test.go
@@ -113,6 +113,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
+			requestTimeout:         time.Second * 10,
 			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
 			wantVisitServer:        true,
 		},
@@ -126,6 +127,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               cacheHitSum,
+			requestTimeout:         time.Second * 10,
 			wantFileName:           "test.wasm",
 			wantVisitServer:        false,
 		},
@@ -137,6 +139,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
+			requestTimeout:         time.Second * 10,
 			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
 			wantErrorMsgPrefix:     "unsupported Wasm module downloading URL scheme: foo",
 			wantVisitServer:        false,
@@ -148,7 +151,8 @@ func TestWasmCache(t *testing.T) {
 			fetchURL:               "https://dummyurl",
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
-			wantErrorMsgPrefix:     "wasm module download failed, last error: Get \"https://dummyurl\"",
+			requestTimeout:         time.Second * 10,
+			wantErrorMsgPrefix:     "wasm module download failed after 5 attempts, last error: Get \"https://dummyurl\"",
 			wantVisitServer:        false,
 		},
 		{
@@ -159,6 +163,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               "wrongchecksum\n",
+			requestTimeout:         time.Second * 10,
 			wantErrorMsgPrefix:     fmt.Sprintf("module downloaded from %v has checksum %s, which does not match", ts.URL, httpDataCheckSum),
 			wantVisitServer:        true,
 		},
@@ -174,6 +179,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               httpDataCheckSum,
+			requestTimeout:         time.Second * 10,
 			wantErrorMsgPrefix:     fmt.Sprintf("module downloaded from %v/different-url has checksum", ts.URL),
 			wantVisitServer:        true,
 		},
@@ -187,6 +193,7 @@ func TestWasmCache(t *testing.T) {
 			purgeInterval:          DefaultWasmModulePurgeInterval,
 			wasmModuleExpiry:       DefaultWasmModuleExpiry,
 			checksum:               invalidHTTPDataCheckSum,
+			requestTimeout:         time.Second * 10,
 			wantErrorMsgPrefix:     fmt.Sprintf("fetched Wasm binary from %s is invalid", ts.URL+"/invalid-wasm-header"),
 			wantVisitServer:        true,
 		},
@@ -201,6 +208,7 @@ func TestWasmCache(t *testing.T) {
 			wasmModuleExpiry:       1 * time.Millisecond,
 			checkPurgeTimeout:      5 * time.Second,
 			checksum:               httpDataCheckSum,
+			requestTimeout:         time.Second * 10,
 			wantFileName:           fmt.Sprintf("%s.wasm", httpDataCheckSum),
 			wantVisitServer:        true,
 		},
@@ -645,7 +653,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 
 	// Get wasm module three times, since checksum is not specified, it will be fetched from module server every time.
 	// 1st time
-	gotFilePath, err := cache.Get(ts.URL, "", "namespace.resource", "123456", 0, []byte{}, defaultPullPolicy)
+	gotFilePath, err := cache.Get(ts.URL, "", "namespace.resource", "123456", time.Second*10, []byte{}, defaultPullPolicy)
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
@@ -654,7 +662,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 	}
 
 	// 2nd time
-	gotFilePath, err = cache.Get(ts.URL, "", "namespace.resource", "123456", 0, []byte{}, defaultPullPolicy)
+	gotFilePath, err = cache.Get(ts.URL, "", "namespace.resource", "123456", time.Second*10, []byte{}, defaultPullPolicy)
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
@@ -663,7 +671,7 @@ func TestWasmCacheMissChecksum(t *testing.T) {
 	}
 
 	// 3rd time
-	gotFilePath, err = cache.Get(ts.URL, "", "namespace.resource", "123456", 0, []byte{}, defaultPullPolicy)
+	gotFilePath, err = cache.Get(ts.URL, "", "namespace.resource", "123456", time.Second*10, []byte{}, defaultPullPolicy)
 	if err != nil {
 		t.Fatalf("failed to download Wasm module: %v", err)
 	}
diff --git a/pkg/wasm/httpfetcher.go b/pkg/wasm/httpfetcher.go
index 2c1838e146..14fabdbae5 100644
--- a/pkg/wasm/httpfetcher.go
+++ b/pkg/wasm/httpfetcher.go
@@ -15,6 +15,8 @@
 package wasm
 
 import (
+	"context"
+	"crypto/tls"
 	"fmt"
 	"io"
 	"net/http"
@@ -25,40 +27,57 @@
 
 // HTTPFetcher fetches remote wasm module with HTTP get.
 type HTTPFetcher struct {
-	defaultClient  *http.Client
+	client         *http.Client
+	insecureClient *http.Client
 	initialBackoff time.Duration
 }
 
 // NewHTTPFetcher create a new HTTP remote wasm module fetcher.
-func NewHTTPFetcher() *HTTPFetcher {
+// requestTimeout is a timeout for each HTTP/HTTPS request.
+func NewHTTPFetcher(requestTimeout time.Duration) *HTTPFetcher {
+	if requestTimeout == 0 {
+		requestTimeout = 5 * time.Second
+	}
+	transport := http.DefaultTransport.(*http.Transport).Clone()
+	transport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
 	return &HTTPFetcher{
-		defaultClient: &http.Client{
-			Timeout: 5 * time.Second,
+		client: &http.Client{
+			Timeout: requestTimeout,
+		},
+		insecureClient: &http.Client{
+			Timeout:   requestTimeout,
+			Transport: transport,
 		},
 		initialBackoff: time.Millisecond * 500,
 	}
 }
 
 // Fetch downloads a wasm module with HTTP get.
-func (f *HTTPFetcher) Fetch(url string, timeout time.Duration) ([]byte, error) {
-	c := f.defaultClient
-	if timeout != 0 {
-		c = &http.Client{
-			Timeout: timeout,
-		}
+func (f *HTTPFetcher) Fetch(ctx context.Context, url string, allowInsecure bool) ([]byte, error) {
+	c := f.client
+	if allowInsecure {
+		c = f.insecureClient
 	}
 	attempts := 0
-
 	b := backoff.NewExponentialBackOff()
 	b.InitialInterval = f.initialBackoff
 	b.Reset()
 	var lastError error
-	for attempts < 5 {
+	for attempts < DefaultWasmHTTPRequestMaxRetries {
 		attempts++
-		resp, err := c.Get(url)
+		req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
+		if err != nil {
+			wasmLog.Debugf("wasm module download request failed: %v", err)
+			return nil, err
+		}
+		resp, err := c.Do(req)
 		if err != nil {
 			lastError = err
 			wasmLog.Debugf("wasm module download request failed: %v", err)
+			if ctx.Err() != nil {
+				// If there is context timeout, exit this loop.
+				return nil, fmt.Errorf("wasm module download failed after %v attempts, last error: %v", attempts, lastError)
+			}
 			time.Sleep(b.NextBackOff())
 			continue
 		}
@@ -78,7 +97,7 @@ func (f *HTTPFetcher) Fetch(url string, timeout time.Duration) ([]byte, error) {
 		resp.Body.Close()
 		break
 	}
-	return nil, fmt.Errorf("wasm module download failed, last error: %v", lastError)
+	return nil, fmt.Errorf("wasm module download failed after %v attempts, last error: %v", attempts, lastError)
 }
 
 func retryable(code int) bool {
diff --git a/pkg/wasm/httpfetcher_test.go b/pkg/wasm/httpfetcher_test.go
index d9f16dafef..229e81e49d 100644
--- a/pkg/wasm/httpfetcher_test.go
+++ b/pkg/wasm/httpfetcher_test.go
@@ -15,9 +15,12 @@
 package wasm
 
 import (
+	"context"
 	"fmt"
 	"net/http"
 	"net/http/httptest"
+	"regexp"
+	"strings"
 	"testing"
 	"time"
 )
@@ -28,14 +31,16 @@ func TestWasmHTTPFetch(t *testing.T) {
 	cases := []struct {
 		name           string
 		handler        func(http.ResponseWriter, *http.Request, int)
+		timeout        time.Duration
 		wantNumRequest int
-		wantError      string
+		wantErrorRegex string
 	}{
 		{
 			name: "download ok",
 			handler: func(w http.ResponseWriter, r *http.Request, num int) {
 				fmt.Fprintln(w, "wasm")
 			},
+			timeout:        5 * time.Second,
 			wantNumRequest: 1,
 		},
 		{
@@ -47,6 +52,7 @@ func TestWasmHTTPFetch(t *testing.T) {
 					fmt.Fprintln(w, "wasm")
 				}
 			},
+			timeout:        5 * time.Second,
 			wantNumRequest: 4,
 		},
 		{
@@ -54,8 +60,18 @@ func TestWasmHTTPFetch(t *testing.T) {
 			handler: func(w http.ResponseWriter, r *http.Request, num int) {
 				w.WriteHeader(500)
 			},
+			timeout:        5 * time.Second,
 			wantNumRequest: 5,
-			wantError:      "wasm module download failed, last error: wasm module download request failed: status code 500",
+			wantErrorRegex: "wasm module download failed after 5 attempts, last error: wasm module download request failed: status code 500",
+		},
+		{
+			name: "download is never tried by immediate context timeout",
+			handler: func(w http.ResponseWriter, r *http.Request, num int) {
+				w.WriteHeader(500)
+			},
+			timeout:        0, // Immediately timeout in the context level.
+			wantNumRequest: 0, // Should not retried because it is already timed out.
+			wantErrorRegex: "wasm module download failed after 1 attempts, last error: Get \"[^\"]+\": context deadline exceeded",
 		},
 	}
 
@@ -68,17 +84,78 @@ func TestWasmHTTPFetch(t *testing.T) {
 				gotNumRequest++
 			}))
 			defer ts.Close()
-			fetcher := NewHTTPFetcher()
+			fetcher := NewHTTPFetcher(1 * time.Second)
+			fetcher.initialBackoff = time.Microsecond
+			ctx, cancel := context.WithTimeout(context.Background(), c.timeout)
+			defer cancel()
+			b, err := fetcher.Fetch(ctx, ts.URL, false)
+			if c.wantNumRequest != gotNumRequest {
+				t.Errorf("Wasm download request got %v, want %v", gotNumRequest, c.wantNumRequest)
+			}
+			if c.wantErrorRegex != "" {
+				if err == nil {
+					t.Errorf("Wasm download got no error, want error regex `%v`", c.wantErrorRegex)
+				} else if matched, regexErr := regexp.MatchString(c.wantErrorRegex, err.Error()); regexErr != nil || !matched {
+					t.Errorf("Wasm download got error `%v`, want error regex `%v`", err, c.wantErrorRegex)
+				}
+			} else if string(b) != wantWasmModule {
+				t.Errorf("downloaded wasm module got %v, want wasm", string(b))
+			}
+		})
+	}
+}
+
+func TestWasmHTTPInsecureServer(t *testing.T) {
+	var ts *httptest.Server
+
+	cases := []struct {
+		name            string
+		handler         func(http.ResponseWriter, *http.Request, int)
+		insecure        bool
+		wantNumRequest  int
+		wantErrorSuffix string
+	}{
+		{
+			name: "download fail",
+			handler: func(w http.ResponseWriter, r *http.Request, num int) {
+				fmt.Fprintln(w, "wasm")
+			},
+			insecure:        false,
+			wantErrorSuffix: "x509: certificate signed by unknown authority",
+			wantNumRequest:  0,
+		},
+		{
+			name: "download ok",
+			handler: func(w http.ResponseWriter, r *http.Request, num int) {
+				fmt.Fprintln(w, "wasm")
+			},
+			insecure:       true,
+			wantNumRequest: 1,
+		},
+	}
+
+	for _, c := range cases {
+		t.Run(c.name, func(t *testing.T) {
+			gotNumRequest := 0
+			wantWasmModule := "wasm\n"
+			ts = httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+				c.handler(w, r, gotNumRequest)
+				gotNumRequest++
+			}))
+			defer ts.Close()
+			fetcher := NewHTTPFetcher(1 * time.Second)
 			fetcher.initialBackoff = time.Microsecond
-			b, err := fetcher.Fetch(ts.URL, 0)
+			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
+			defer cancel()
+			b, err := fetcher.Fetch(ctx, ts.URL, c.insecure)
 			if c.wantNumRequest != gotNumRequest {
 				t.Errorf("Wasm download request got %v, want %v", gotNumRequest, c.wantNumRequest)
 			}
-			if c.wantError != "" {
+			if c.wantErrorSuffix != "" {
 				if err == nil {
-					t.Errorf("Wasm download got no error, want error `%v`", c.wantError)
-				} else if c.wantError != err.Error() {
-					t.Errorf("Wasm download got error `%v`, want error `%v`", err, c.wantError)
+					t.Errorf("Wasm download got no error, want error suffix `%v`", c.wantErrorSuffix)
+				} else if !strings.HasSuffix(err.Error(), c.wantErrorSuffix) {
+					t.Errorf("Wasm download got error `%v`, want error suffix `%v`", err, c.wantErrorSuffix)
 				}
 			} else if string(b) != wantWasmModule {
 				t.Errorf("downloaded wasm module got %v, want wasm", string(b))
diff --git a/releasenotes/notes/wasm-https-insecure-support.yaml b/releasenotes/notes/wasm-https-insecure-support.yaml
new file mode 100644
index 0000000000..efdd8cf7e4
--- /dev/null
+++ b/releasenotes/notes/wasm-https-insecure-support.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: extensibility
+issue: []
+releaseNotes:
+  - |
+    **Added** WASM_INSECURE_REGISTRIES environment variable of istio-agent is also honored when the WasmPlugin is pointing http/https server.
-- 
2.35.3

