From 8085f1a5101885b9f2194098e1a7c29f9f220787 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Mon, 8 Nov 2021 09:49:24 -0800
Subject: Fix alt-host generation when hostname has a partial overlap with
 cluster domain (#35691)

* Fix alt-host generation when hostname has a partial overlap with cluster domain

For example, a service `foo.bar.local` behaves incorrectly because we
incorrectly match the `.local` up with `.cluster.local`

* Test order as well

* Fix alt-host generation when hostname has a partial overlap with cluster domain

* fix direction

* lint

* fixes
---
 .../pkg/networking/core/v1alpha3/httproute.go | 71 ++++++++--------
 .../core/v1alpha3/httproute_test.go           | 81 ++++++++++++++++---
 releasenotes/notes/vhost-name-generation.yaml |  8 ++
 3 files changed, 117 insertions(+), 43 deletions(-)
 create mode 100644 releasenotes/notes/vhost-name-generation.yaml

diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index 48cc2a2660..51c5230c93 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -491,6 +491,10 @@ func generateVirtualHostDomains(service *model.Service, port int, node *model.Pr
 // - Given foo.local.campus.net on proxy domain "" or proxy domain example.com, this
 // function returns nil
 func GenerateAltVirtualHosts(hostname string, port int, proxyDomain string) []string {
+	if strings.Contains(proxyDomain, ".svc.") {
+		return generateAltVirtualHostsForKubernetesService(hostname, port, proxyDomain)
+	}
+
 	var vhosts []string
 	uniqueHostnameParts, sharedDNSDomainParts := getUniqueAndSharedDNSDomain(hostname, proxyDomain)
 
@@ -502,43 +506,46 @@ func GenerateAltVirtualHosts(hostname string, port int, proxyDomain string) []st
 
 	uniqueHostname := strings.Join(uniqueHostnameParts, ".")
 
-	if strings.Contains(proxyDomain, ".svc.") {
-		// Proxy is k8s.
-
-		if len(uniqueHostnameParts) == 2 {
-			// This is the case of uniqHostname having namespace already.
-			dnsHostName := uniqueHostname + "." + sharedDNSDomainParts[0]
-			vhosts = append(vhosts, uniqueHostname, util.DomainName(uniqueHostname, port), dnsHostName, util.DomainName(dnsHostName, port))
-		} else {
-			// Derive the namespace from sharedDNSDomain and add virtual host.
-			namespace := sharedDNSDomainParts[0]
-			if strings.HasPrefix(proxyDomain, namespace+".svc.") {
-				// Split the domain and add only for Kubernetes proxies.
-				vhosts = append(vhosts, uniqueHostname, util.DomainName(uniqueHostname, port))
-				if len(sharedDNSDomainParts) > 1 {
-					dnsHostName := uniqueHostname + "." + namespace + "." + sharedDNSDomainParts[1]
-					vhosts = append(vhosts, dnsHostName, util.DomainName(dnsHostName, port))
-				}
-				hostNameWithNS := uniqueHostname + "." + namespace
+	// Add the uniqueHost.
+	vhosts = append(vhosts, uniqueHostname, util.DomainName(uniqueHostname, port))
+	if len(uniqueHostnameParts) == 2 {
+		// This is the case of uniqHostname having namespace already.
+		dnsHostName := uniqueHostname + "." + sharedDNSDomainParts[0]
+		vhosts = append(vhosts, dnsHostName, util.DomainName(dnsHostName, port))
+	}
+	return vhosts
+}
 
-				// Don't add if they are same because we add it later and adding it here will result in duplicates.
-				if hostname != hostNameWithNS {
-					vhosts = append(vhosts, hostNameWithNS, util.DomainName(hostNameWithNS, port))
-				}
+func generateAltVirtualHostsForKubernetesService(hostname string, port int, proxyDomain string) []string {
+	id := strings.Index(proxyDomain, ".svc.")
+	ih := strings.Index(hostname, ".svc.")
+	if ih > 0 { // Proxy and service hostname are in kube
+		ns := strings.Index(hostname, ".")
+		if ns+1 >= len(hostname) || ns+1 > ih {
+			// Invalid domain
+			return nil
+		}
+		if hostname[ns+1:ih] == proxyDomain[:id] {
+			// Same namespace
+			return []string{
+				hostname[:ns],
+				util.DomainName(hostname[:ns], port),
+				hostname[:ih] + ".svc",
+				util.DomainName(hostname[:ih]+".svc", port),
+				hostname[:ih],
+				util.DomainName(hostname[:ih], port),
 			}
 		}
-	} else {
-		// Proxy is non-k8s
-
-		// Add the uniqueHost.
-		vhosts = append(vhosts, uniqueHostname, util.DomainName(uniqueHostname, port))
-		if len(uniqueHostnameParts) == 2 {
-			// This is the case of uniqHostname having namespace already.
-			dnsHostName := uniqueHostname + "." + sharedDNSDomainParts[0]
-			vhosts = append(vhosts, dnsHostName, util.DomainName(dnsHostName, port))
+		// Different namespace
+		return []string{
+			hostname[:ih],
+			util.DomainName(hostname[:ih], port),
+			hostname[:ih] + ".svc",
+			util.DomainName(hostname[:ih]+".svc", port),
 		}
 	}
-	return vhosts
+	// Proxy is in k8s, but service isn't. No alt hosts
+	return nil
 }
 
 // mergeAllVirtualHosts across all ports. On routes for ports other than port 80,
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute_test.go b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
index 83cdee0d66..826cafbf47 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute_test.go
@@ -17,7 +17,6 @@
 import (
 	"fmt"
 	"reflect"
-	"sort"
 	"testing"
 	"time"
 
@@ -56,8 +55,8 @@ func TestGenerateVirtualHostDomains(t *testing.T) {
 				DNSDomain: "local.campus.net",
 			},
 			want: []string{
-				"foo", "foo.local.campus.net",
-				"foo:80", "foo.local.campus.net:80",
+				"foo.local.campus.net", "foo.local.campus.net:80",
+				"foo", "foo:80",
 			},
 		},
 		{
@@ -71,8 +70,12 @@ func TestGenerateVirtualHostDomains(t *testing.T) {
 				DNSDomain: "remote.campus.net",
 			},
 			want: []string{
-				"foo.local", "foo.local.campus", "foo.local.campus.net",
-				"foo.local:80", "foo.local.campus:80", "foo.local.campus.net:80",
+				"foo.local.campus.net",
+				"foo.local.campus.net:80",
+				"foo.local",
+				"foo.local:80",
+				"foo.local.campus",
+				"foo.local.campus:80",
 			},
 		},
 		{
@@ -98,8 +101,14 @@ func TestGenerateVirtualHostDomains(t *testing.T) {
 				DNSDomain: "default.svc.cluster.local",
 			},
 			want: []string{
-				"echo", "echo.default", "echo.default.svc", "echo.default.svc.cluster.local",
-				"echo:8123", "echo.default:8123", "echo.default.svc:8123", "echo.default.svc.cluster.local:8123",
+				"echo.default.svc.cluster.local",
+				"echo.default.svc.cluster.local:8123",
+				"echo",
+				"echo:8123",
+				"echo.default.svc",
+				"echo.default.svc:8123",
+				"echo.default",
+				"echo.default:8123",
 			},
 		},
 		{
@@ -113,8 +122,12 @@ func TestGenerateVirtualHostDomains(t *testing.T) {
 				DNSDomain: "mesh.svc.cluster.local",
 			},
 			want: []string{
-				"echo.default", "echo.default.svc", "echo.default.svc.cluster.local",
-				"echo.default:8123", "echo.default.svc:8123", "echo.default.svc.cluster.local:8123",
+				"echo.default.svc.cluster.local",
+				"echo.default.svc.cluster.local:8123",
+				"echo.default",
+				"echo.default:8123",
+				"echo.default.svc",
+				"echo.default.svc:8123",
 			},
 		},
 		{
@@ -153,12 +166,58 @@ func TestGenerateVirtualHostDomains(t *testing.T) {
 			},
 			want: []string{"[2406:3003:2064:35b8:864:a648:4b96:e37d]", "[2406:3003:2064:35b8:864:a648:4b96:e37d]:8123"},
 		},
+		{
+			name: "back subset of cluster domain in address",
+			service: &model.Service{
+				Hostname:     "aaa.example.local",
+				MeshExternal: true,
+			},
+			port: 7777,
+			node: &model.Proxy{
+				DNSDomain: "tests.svc.cluster.local",
+			},
+			want: []string{"aaa.example.local", "aaa.example.local:7777"},
+		},
+		{
+			name: "front subset of cluster domain in address",
+			service: &model.Service{
+				Hostname:     "aaa.example.my",
+				MeshExternal: true,
+			},
+			port: 7777,
+			node: &model.Proxy{
+				DNSDomain: "tests.svc.my.long.domain.suffix",
+			},
+			want: []string{"aaa.example.my", "aaa.example.my:7777"},
+		},
+		{
+			name: "large subset of cluster domain in address",
+			service: &model.Service{
+				Hostname:     "aaa.example.my.long",
+				MeshExternal: true,
+			},
+			port: 7777,
+			node: &model.Proxy{
+				DNSDomain: "tests.svc.my.long.domain.suffix",
+			},
+			want: []string{"aaa.example.my.long", "aaa.example.my.long:7777"},
+		},
+		{
+			name: "no overlap of cluster domain in address",
+			service: &model.Service{
+				Hostname:     "aaa.example.com",
+				MeshExternal: true,
+			},
+			port: 7777,
+			node: &model.Proxy{
+				DNSDomain: "tests.svc.cluster.local",
+			},
+			want: []string{"aaa.example.com", "aaa.example.com:7777"},
+		},
 	}
 
 	testFn := func(service *model.Service, port int, node *model.Proxy, want []string) error {
 		out, _ := generateVirtualHostDomains(service, port, node)
-		sort.SliceStable(want, func(i, j int) bool { return want[i] < want[j] })
-		sort.SliceStable(out, func(i, j int) bool { return out[i] < out[j] })
 		if !reflect.DeepEqual(out, want) {
 			return fmt.Errorf("unexpected virtual hosts:\ngot  %v\nwant %v", out, want)
 		}
diff --git a/releasenotes/notes/vhost-name-generation.yaml b/releasenotes/notes/vhost-name-generation.yaml
new file mode 100644
index 0000000000..e75f94d850
--- /dev/null
+++ b/releasenotes/notes/vhost-name-generation.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+- 35676
+releaseNotes:
+- |
+  **Fixed** an issue causing hostnames overlapping the cluster domain (such as `example.local`) to generate invalid routes.
-- 
2.35.3

