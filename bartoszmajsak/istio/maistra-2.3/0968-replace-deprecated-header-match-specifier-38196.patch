From 11830ff791136991456aa6eb570b4e8472a2908d Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Sat, 2 Apr 2022 07:54:27 +0530
Subject: replace deprecated header match specifier (#38196)

* remove deprecated header match specifier

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* minor change

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* rever header

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* revert security

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 .../networking/core/v1alpha3/route/route.go   | 85 ++-----------------
 .../v1alpha3/route/route_internal_test.go     | 16 ++--
 .../core/v1alpha3/route/route_test.go         | 25 +++---
 pilot/pkg/networking/util/util.go             | 34 ++++++++
 4 files changed, 64 insertions(+), 96 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/route/route.go b/pilot/pkg/networking/core/v1alpha3/route/route.go
index a3bb33d7c1..6ca2b53071 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route.go
@@ -57,8 +57,6 @@
 // DefaultRouteName is the name assigned to a route generated by default in absence of a virtual service.
 const DefaultRouteName = "default"
 
-var regexEngine = &matcher.RegexMatcher_GoogleRe2{GoogleRe2: &matcher.RegexMatcher_GoogleRE2{}}
-
 // VirtualHostWrapper is a context-dependent virtual host entry with guarded routes.
 // Note: Currently we are not fully utilizing this structure. We could invoke this logic
 // once for all sidecars in the cluster to compute all RDS for inside the mesh and arrange
@@ -822,8 +820,7 @@ func translateRouteMatch(in *networking.HTTPMatchRequest) *route.RouteMatch {
 		case *networking.StringMatch_Regex:
 			out.PathSpecifier = &route.RouteMatch_SafeRegex{
 				SafeRegex: &matcher.RegexMatcher{
-					// nolint: staticcheck
-					EngineType: regexEngine,
+					EngineType: util.RegexEngine,
 					Regex:      m.Regex,
 				},
 			}
@@ -871,7 +868,7 @@ func translateQueryParamMatch(name string, in *networking.StringMatch) *route.Qu
 			StringMatch: &matcher.StringMatcher{
 				MatchPattern: &matcher.StringMatcher_SafeRegex{
 					SafeRegex: &matcher.RegexMatcher{
-						EngineType: regexEngine,
+						EngineType: util.RegexEngine,
 						Regex:      m.Regex,
 					},
 				},
@@ -912,28 +909,7 @@ func translateMetadataMatch(name string, in *networking.StringMatch) *matcher.Me
 		return nil
 	}
 	claims := strings.Split(name[len(constant.HeaderJWTClaim):], ".")
-
-	var value *matcher.StringMatcher
-	switch m := in.MatchType.(type) {
-	case *networking.StringMatch_Exact:
-		value = &matcher.StringMatcher{
-			MatchPattern: &matcher.StringMatcher_Exact{Exact: m.Exact},
-		}
-	case *networking.StringMatch_Prefix:
-		value = &matcher.StringMatcher{
-			MatchPattern: &matcher.StringMatcher_Prefix{Prefix: m.Prefix},
-		}
-	case *networking.StringMatch_Regex:
-		value = &matcher.StringMatcher{
-			MatchPattern: &matcher.StringMatcher_SafeRegex{
-				SafeRegex: &matcher.RegexMatcher{
-					EngineType: regexEngine,
-					Regex:      m.Regex,
-				},
-			},
-		}
-	}
-	return authz.MetadataMatcherForJWTClaims(claims, value)
+	return authz.MetadataMatcherForJWTClaims(claims, util.ConvertToEnvoyMatch(in))
 }
 
 // translateHeaderMatch translates to HeaderMatcher
@@ -947,60 +923,15 @@ func translateHeaderMatch(name string, in *networking.StringMatch) *route.Header
 		return out
 	}
 
-	// nolint: staticcheck
-	switch m := in.MatchType.(type) {
-	case *networking.StringMatch_Exact:
-		out.HeaderMatchSpecifier = &route.HeaderMatcher_ExactMatch{ExactMatch: m.Exact}
-	case *networking.StringMatch_Prefix:
-		// Envoy regex grammar is RE2 (https://github.com/google/re2/wiki/Syntax)
-		// Golang has a slightly different regex grammar
-		out.HeaderMatchSpecifier = &route.HeaderMatcher_PrefixMatch{PrefixMatch: m.Prefix}
-	case *networking.StringMatch_Regex:
-		out.HeaderMatchSpecifier = &route.HeaderMatcher_SafeRegexMatch{
-			SafeRegexMatch: &matcher.RegexMatcher{
-				EngineType: regexEngine,
-				Regex:      m.Regex,
-			},
+	if em := util.ConvertToEnvoyMatch(in); em != nil {
+		out.HeaderMatchSpecifier = &route.HeaderMatcher_StringMatch{
+			StringMatch: em,
 		}
 	}
 
 	return out
 }
 
-func convertToExactEnvoyMatch(in []string) []*matcher.StringMatcher {
-	res := make([]*matcher.StringMatcher, 0, len(in))
-
-	for _, istioMatcher := range in {
-		res = append(res, &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Exact{Exact: istioMatcher}})
-	}
-
-	return res
-}
-
-func convertToEnvoyMatch(in []*networking.StringMatch) []*matcher.StringMatcher {
-	res := make([]*matcher.StringMatcher, 0, len(in))
-
-	for _, istioMatcher := range in {
-		switch m := istioMatcher.MatchType.(type) {
-		case *networking.StringMatch_Exact:
-			res = append(res, &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Exact{Exact: m.Exact}})
-		case *networking.StringMatch_Prefix:
-			res = append(res, &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Prefix{Prefix: m.Prefix}})
-		case *networking.StringMatch_Regex:
-			res = append(res, &matcher.StringMatcher{
-				MatchPattern: &matcher.StringMatcher_SafeRegex{
-					SafeRegex: &matcher.RegexMatcher{
-						EngineType: regexEngine,
-						Regex:      m.Regex,
-					},
-				},
-			})
-		}
-	}
-
-	return res
-}
-
 // translateCORSPolicy translates CORS policy
 func translateCORSPolicy(in *networking.CorsPolicy) *route.CorsPolicy {
 	if in == nil {
@@ -1011,9 +942,9 @@ func translateCORSPolicy(in *networking.CorsPolicy) *route.CorsPolicy {
 	out := route.CorsPolicy{}
 	// nolint: staticcheck
 	if in.AllowOrigins != nil {
-		out.AllowOriginStringMatch = convertToEnvoyMatch(in.AllowOrigins)
+		out.AllowOriginStringMatch = util.ConvertToEnvoyMatches(in.AllowOrigins)
 	} else if in.AllowOrigin != nil {
-		out.AllowOriginStringMatch = convertToExactEnvoyMatch(in.AllowOrigin)
+		out.AllowOriginStringMatch = util.StringToExactMatch(in.AllowOrigin)
 	}
 
 	out.EnabledSpecifier = &route.CorsPolicy_FilterEnabled{
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go b/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
index f97154c12d..b6633c5e15 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
@@ -25,6 +25,7 @@
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/networking/util"
 	authzmatcher "istio.io/istio/pilot/pkg/security/authz/matcher"
 	authz "istio.io/istio/pilot/pkg/security/authz/model"
 	"istio.io/istio/pkg/config/labels"
@@ -170,11 +171,14 @@ func TestIsCatchAllRoute(t *testing.T) {
 					Headers: []*route.HeaderMatcher{
 						{
 							Name: "Authentication",
-							HeaderMatchSpecifier: &route.HeaderMatcher_SafeRegexMatch{
-								SafeRegexMatch: &matcher.RegexMatcher{
-									// nolint: staticcheck
-									EngineType: &matcher.RegexMatcher_GoogleRe2{},
-									Regex:      "*",
+							HeaderMatchSpecifier: &route.HeaderMatcher_StringMatch{
+								StringMatch: &matcher.StringMatcher{
+									MatchPattern: &matcher.StringMatcher_SafeRegex{
+										SafeRegex: &matcher.RegexMatcher{
+											EngineType: util.RegexEngine,
+											Regex:      "*",
+										},
+									},
 								},
 							},
 						},
@@ -295,7 +299,7 @@ func TestTranslateCORSPolicy(t *testing.T) {
 			{
 				MatchPattern: &matcher.StringMatcher_SafeRegex{
 					SafeRegex: &matcher.RegexMatcher{
-						EngineType: regexEngine,
+						EngineType: util.RegexEngine,
 						Regex:      "regex",
 					},
 				},
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route_test.go b/pilot/pkg/networking/core/v1alpha3/route/route_test.go
index f5128876a1..a8311e0447 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route_test.go
@@ -224,9 +224,7 @@ func TestBuildHTTPRoutes(t *testing.T) {
 		xdstest.ValidateRoutes(t, routes)
 		g.Expect(err).NotTo(gomega.HaveOccurred())
 		g.Expect(len(routes)).To(gomega.Equal(1))
-		// nolint: staticcheck
-		// Update to not use the deprecated fields later.
-		g.Expect(routes[0].GetMatch().GetHeaders()[0].GetSafeRegexMatch().GetRegex()).To(gomega.Equal("Bearer .+?\\..+?\\..+?"))
+		g.Expect(routes[0].GetMatch().GetHeaders()[0].GetStringMatch().GetSafeRegex().GetRegex()).To(gomega.Equal("Bearer .+?\\..+?\\..+?"))
 	})
 
 	t.Run("for virtual service with regex matching on without_header", func(t *testing.T) {
@@ -238,9 +236,7 @@ func TestBuildHTTPRoutes(t *testing.T) {
 		xdstest.ValidateRoutes(t, routes)
 		g.Expect(err).NotTo(gomega.HaveOccurred())
 		g.Expect(len(routes)).To(gomega.Equal(1))
-		// nolint: staticcheck
-		// Update to not use the deprecated fields later.
-		g.Expect(routes[0].GetMatch().GetHeaders()[0].GetSafeRegexMatch().GetRegex()).To(gomega.Equal("BAR .+?\\..+?\\..+?"))
+		g.Expect(routes[0].GetMatch().GetHeaders()[0].GetStringMatch().GetSafeRegex().GetRegex()).To(gomega.Equal("BAR .+?\\..+?\\..+?"))
 		g.Expect(routes[0].GetMatch().GetHeaders()[0].GetInvertMatch()).To(gomega.Equal(true))
 	})
 
@@ -1678,7 +1674,6 @@ func createVirtualServiceWithRegexMatchingForAllCasesOnHeader() []*config.Config
 }
 
 func TestCombineVHostRoutes(t *testing.T) {
-	// nolint: staticcheck
 	regexEngine := &matcher.RegexMatcher_GoogleRe2{GoogleRe2: &matcher.RegexMatcher_GoogleRE2{
 		MaxProgramSize: &wrappers.UInt32Value{
 			Value: uint32(10),
@@ -1713,9 +1708,11 @@ func TestCombineVHostRoutes(t *testing.T) {
 			},
 			Headers: []*envoyroute.HeaderMatcher{
 				{
-					Name:                 "foo",
-					HeaderMatchSpecifier: &envoyroute.HeaderMatcher_ExactMatch{ExactMatch: "bar"},
-					InvertMatch:          false,
+					Name: "foo",
+					HeaderMatchSpecifier: &envoyroute.HeaderMatcher_StringMatch{
+						StringMatch: &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Exact{Exact: "bar"}},
+					},
+					InvertMatch: false,
 				},
 			},
 		}},
@@ -1747,9 +1744,11 @@ func TestCombineVHostRoutes(t *testing.T) {
 			},
 			Headers: []*envoyroute.HeaderMatcher{
 				{
-					Name:                 "foo",
-					HeaderMatchSpecifier: &envoyroute.HeaderMatcher_ExactMatch{ExactMatch: "bar"},
-					InvertMatch:          false,
+					Name: "foo",
+					HeaderMatchSpecifier: &envoyroute.HeaderMatcher_StringMatch{
+						StringMatch: &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Exact{Exact: "bar"}},
+					},
+					InvertMatch: false,
 				},
 			},
 		}},
diff --git a/pilot/pkg/networking/util/util.go b/pilot/pkg/networking/util/util.go
index 0bf144d4ac..f8fb8f8367 100644
--- a/pilot/pkg/networking/util/util.go
+++ b/pilot/pkg/networking/util/util.go
@@ -134,6 +134,9 @@
 // ALPNDownstream advertises that Proxy is going to talk http2 or http 1.1.
 var ALPNDownstream = []string{"h2", "http/1.1"}
 
+// RegexEngine is the default google RE2 regex engine.
+var RegexEngine = &matcher.RegexMatcher_GoogleRe2{GoogleRe2: &matcher.RegexMatcher_GoogleRE2{}}
+
 func getMaxCidrPrefix(addr string) uint32 {
 	ip := net.ParseIP(addr)
 	if ip.To4() == nil {
@@ -587,6 +590,37 @@ func StringToPrefixMatch(in []string) []*matcher.StringMatcher {
 	return res
 }
 
+func ConvertToEnvoyMatches(in []*networking.StringMatch) []*matcher.StringMatcher {
+	res := make([]*matcher.StringMatcher, 0, len(in))
+
+	for _, im := range in {
+		if em := ConvertToEnvoyMatch(im); em != nil {
+			res = append(res, em)
+		}
+	}
+
+	return res
+}
+
+func ConvertToEnvoyMatch(in *networking.StringMatch) *matcher.StringMatcher {
+	switch m := in.MatchType.(type) {
+	case *networking.StringMatch_Exact:
+		return &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Exact{Exact: m.Exact}}
+	case *networking.StringMatch_Prefix:
+		return &matcher.StringMatcher{MatchPattern: &matcher.StringMatcher_Prefix{Prefix: m.Prefix}}
+	case *networking.StringMatch_Regex:
+		return &matcher.StringMatcher{
+			MatchPattern: &matcher.StringMatcher_SafeRegex{
+				SafeRegex: &matcher.RegexMatcher{
+					EngineType: RegexEngine,
+					Regex:      m.Regex,
+				},
+			},
+		}
+	}
+	return nil
+}
+
 func StringSliceEqual(a, b []string) bool {
 	if len(a) != len(b) {
 		return false
-- 
2.35.3

