From 0fb12bfcfe582458b70b5cb911fb0307ee927d3c Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Fri, 29 Apr 2022 14:47:46 -0700
Subject: xds: refactor inbound listener generation (#38652)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

* xds: refactor inbound listener generation

Currently, the listener generation code has decayed substantially as
features have been bolted on over the years. The biggest issue is that
we build `FilterChain`s, then build them into real `Listener`s, but then later convert them back to just
`FilterChain`s. This is not only super complex, but also inefficient --
benchmarks below show about 5-15% improvement just by not doing this.
Further, it limits our ability to make changes, such as taking advantage
of the new `FilterChainMatcher` in Envoy.

Some other issues are that we have a bunch of poor coding practices,
like fake instances of structs (ServiceInstance), mutable state
(`listenerMap`), etc. We have a bunch of extremely complex config to
build up a variety of filters then try to arrange them appropriately
later, rather than just building them correctly in the first place.

This PR refactors all *inbound* listeners, following
https://github.com/istio/istio/pull/38595, to a completely new code
path. We have pretty solid test coverage here, and I have done manual
XDS comparison of before/after to ensure no behavioral changes.

The new code behaves a bit differently than before. First, we build up a
'plan' for the listener. This allows us to handle conflicts, etc, in
simple code rather than interweaved with the xDS generation. Then we use
the plan to build up the listeners/filter chains.

Benchmarks:
```
name                                             old time/op        new time/op        delta
ListenerGeneration/gateways-6                          18.8ms ± 8%        18.6ms ± 4%     ~     (p=0.537 n=6+5)
ListenerGeneration/gateways-shared-6                   39.8µs ± 8%        39.0µs ± 4%     ~     (p=0.485 n=6+6)
ListenerGeneration/empty-6                             1.43ms ± 4%        1.36ms ± 6%   -4.61%  (p=0.041 n=6+6)
ListenerGeneration/tls-6                               1.40ms ±15%        1.33ms ± 4%     ~     (p=0.240 n=6+6)
ListenerGeneration/telemetry-6                         1.58ms ±10%        1.66ms ± 6%     ~     (p=0.240 n=6+6)
ListenerGeneration/telemetry-api-6                     1.57ms ± 8%        1.47ms ± 7%   -6.13%  (p=0.026 n=6+6)
ListenerGeneration/virtualservice-6                     117µs ± 3%         113µs ± 4%   -3.58%  (p=0.041 n=6+6)
ListenerGeneration/authorizationpolicy-6               1.28ms ± 4%        1.18ms ± 7%   -7.71%  (p=0.015 n=6+6)
ListenerGeneration/peerauthentication-6                89.6µs ± 6%        73.9µs ± 1%  -17.56%  (p=0.004 n=6+5)
ListenerGeneration/knative-gateway-6                   35.6µs ± 5%        34.9µs ± 2%     ~     (p=0.247 n=6+5)
ListenerGeneration/serviceentry-workloadentry-6        1.41ms ± 1%        1.36ms ± 7%     ~     (p=0.093 n=6+6)

name                                             old kb/msg         new kb/msg         delta
ListenerGeneration/gateways-6                           2.11k ± 0%         2.11k ± 0%     ~     (all equal)
ListenerGeneration/gateways-shared-6                     4.02 ± 0%          4.02 ± 0%     ~     (all equal)
ListenerGeneration/empty-6                               18.4 ± 0%          18.5 ± 0%   +0.49%  (p=0.002 n=6+6)
ListenerGeneration/tls-6                                 12.8 ± 0%          12.6 ± 0%   -1.02%  (p=0.002 n=6+6)
ListenerGeneration/telemetry-6                           31.6 ± 0%          31.7 ± 0%   +0.32%  (p=0.002 n=6+6)
ListenerGeneration/telemetry-api-6                       23.9 ± 0%          24.0 ± 0%   +0.42%  (p=0.002 n=6+6)
ListenerGeneration/virtualservice-6                      7.43 ± 0%          7.32 ± 0%   -1.60%  (p=0.002 n=6+6)
ListenerGeneration/authorizationpolicy-6                 65.2 ± 0%          38.9 ± 0%  -40.34%  (p=0.002 n=6+6)
ListenerGeneration/peerauthentication-6                  6.55 ± 0%          6.41 ± 0%   -2.11%  (p=0.002 n=6+6)
ListenerGeneration/knative-gateway-6                     3.56 ± 0%          3.56 ± 0%     ~     (all equal)
ListenerGeneration/serviceentry-workloadentry-6          18.4 ± 0%          18.5 ± 0%   +0.49%  (p=0.002 n=6+6)

name                                             old resources/msg  new resources/msg  delta
ListenerGeneration/gateways-6                            2.00 ± 0%          2.00 ± 0%     ~     (all equal)
ListenerGeneration/gateways-shared-6                     2.00 ± 0%          2.00 ± 0%     ~     (all equal)
ListenerGeneration/empty-6                               6.00 ± 0%          6.00 ± 0%     ~     (all equal)
ListenerGeneration/tls-6                                 6.00 ± 0%          6.00 ± 0%     ~     (all equal)
ListenerGeneration/telemetry-6                           6.00 ± 0%          6.00 ± 0%     ~     (all equal)
ListenerGeneration/telemetry-api-6                       6.00 ± 0%          6.00 ± 0%     ~     (all equal)
ListenerGeneration/virtualservice-6                      3.00 ± 0%          3.00 ± 0%     ~     (all equal)
ListenerGeneration/authorizationpolicy-6                 4.00 ± 0%          4.00 ± 0%     ~     (all equal)
ListenerGeneration/peerauthentication-6                  4.00 ± 0%          4.00 ± 0%     ~     (all equal)
ListenerGeneration/knative-gateway-6                     2.00 ± 0%          2.00 ± 0%     ~     (all equal)
ListenerGeneration/serviceentry-workloadentry-6          6.00 ± 0%          6.00 ± 0%     ~     (all equal)

name                                             old alloc/op       new alloc/op       delta
ListenerGeneration/gateways-6                          10.4MB ± 0%        10.4MB ± 0%   +0.15%  (p=0.002 n=6+6)
ListenerGeneration/gateways-shared-6                   23.0kB ± 0%        23.0kB ± 0%   -0.14%  (p=0.002 n=6+6)
ListenerGeneration/empty-6                              787kB ± 0%         757kB ± 0%   -3.79%  (p=0.004 n=6+5)
ListenerGeneration/tls-6                                742kB ± 0%         729kB ± 0%   -1.79%  (p=0.010 n=6+4)
ListenerGeneration/telemetry-6                          891kB ± 0%         861kB ± 0%   -3.35%  (p=0.004 n=6+5)
ListenerGeneration/telemetry-api-6                      816kB ± 0%         781kB ± 0%   -4.26%  (p=0.002 n=6+6)
ListenerGeneration/virtualservice-6                    81.3kB ± 0%        74.9kB ± 0%   -7.84%  (p=0.008 n=5+5)
ListenerGeneration/authorizationpolicy-6                609kB ± 0%         515kB ± 0%  -15.38%  (p=0.002 n=6+6)
ListenerGeneration/peerauthentication-6                47.4kB ± 0%        40.1kB ± 0%  -15.44%  (p=0.026 n=5+6)
ListenerGeneration/knative-gateway-6                   21.4kB ± 0%        21.4kB ± 0%   -0.15%  (p=0.002 n=6+6)
ListenerGeneration/serviceentry-workloadentry-6         787kB ± 0%         757kB ± 0%   -3.80%  (p=0.002 n=6+6)

name                                             old allocs/op      new allocs/op      delta
ListenerGeneration/gateways-6                            113k ± 0%          113k ± 0%     ~     (p=0.892 n=6+6)
ListenerGeneration/gateways-shared-6                      290 ± 0%           290 ± 0%     ~     (all equal)
ListenerGeneration/empty-6                              14.7k ± 0%         14.3k ± 0%   -2.36%  (p=0.002 n=6+6)
ListenerGeneration/tls-6                                14.2k ± 0%         14.0k ± 0%   -1.39%  (p=0.002 n=6+6)
ListenerGeneration/telemetry-6                          16.0k ± 0%         15.6k ± 0%   -2.16%  (p=0.002 n=6+6)
ListenerGeneration/telemetry-api-6                      16.1k ± 0%         15.7k ± 0%   -2.51%  (p=0.002 n=6+6)
ListenerGeneration/virtualservice-6                       968 ± 0%           894 ± 0%   -7.64%  (p=0.002 n=6+6)
ListenerGeneration/authorizationpolicy-6                10.5k ± 0%         10.3k ± 0%   -1.73%  (p=0.002 n=6+6)
ListenerGeneration/peerauthentication-6                   602 ± 0%           509 ± 0%  -15.45%  (p=0.002 n=6+6)
ListenerGeneration/knative-gateway-6                      274 ± 0%           274 ± 0%     ~     (all equal)
ListenerGeneration/serviceentry-workloadentry-6         14.7k ± 0%         14.3k ± 0%   -2.36%  (p=0.002 n=6+6)
```

* Cleanup based on Rama's comments
---
 .../pkg/networking/core/v1alpha3/accesslog.go |   9 +-
 .../core/v1alpha3/filterchain_options.go      |  44 +-
 pilot/pkg/networking/core/v1alpha3/gateway.go |   6 +-
 .../networking/core/v1alpha3/gateway_test.go  |  27 +-
 .../pkg/networking/core/v1alpha3/httproute.go |  16 +-
 .../pkg/networking/core/v1alpha3/listener.go  | 351 +--------
 .../core/v1alpha3/listener_builder.go         | 506 +------------
 .../core/v1alpha3/listener_builder_test.go    |   9 +-
 .../core/v1alpha3/listener_inbound.go         | 704 ++++++++++++++++++
 .../networking/core/v1alpha3/networkfilter.go |  35 +-
 .../core/v1alpha3/networkfilter_test.go       |  44 +-
 .../core/v1alpha3/sidecar_simulation_test.go  |  15 +-
 pilot/pkg/networking/core/v1alpha3/tracing.go |  33 +-
 .../networking/core/v1alpha3/tracing_test.go  |   2 +-
 pilot/pkg/networking/util/util.go             |  34 +
 pilot/pkg/simulation/traffic.go               |  41 +-
 pilot/test/xdstest/test.go                    |   2 +-
 pkg/config/protocol/instance.go               |  12 +
 18 files changed, 948 insertions(+), 942 deletions(-)
 create mode 100644 pilot/pkg/networking/core/v1alpha3/listener_inbound.go

diff --git a/pilot/pkg/networking/core/v1alpha3/accesslog.go b/pilot/pkg/networking/core/v1alpha3/accesslog.go
index d7008ad1bb..25b6100df0 100644
--- a/pilot/pkg/networking/core/v1alpha3/accesslog.go
+++ b/pilot/pkg/networking/core/v1alpha3/accesslog.go
@@ -222,9 +222,10 @@ func buildAccessLogFilterFromTelemetry(spec *model.LoggingConfig) *accesslog.Acc
 	}
 }
 
-func (b *AccessLogBuilder) setHTTPAccessLog(opts buildListenerOpts, connectionManager *hcm.HttpConnectionManager) {
-	mesh := opts.push.Mesh
-	cfg := opts.push.Telemetry.AccessLogging(opts.proxy, opts.class)
+func (b *AccessLogBuilder) setHTTPAccessLog(push *model.PushContext, proxy *model.Proxy,
+	connectionManager *hcm.HttpConnectionManager, class networking.ListenerClass) {
+	mesh := push.Mesh
+	cfg := push.Telemetry.AccessLogging(proxy, class)
 
 	if cfg == nil {
 		// No Telemetry API configured, fall back to legacy mesh config setting
@@ -238,7 +239,7 @@ func (b *AccessLogBuilder) setHTTPAccessLog(opts buildListenerOpts, connectionMa
 		return
 	}
 
-	if al := buildAccessLogFromTelemetry(opts.push, cfg, false); len(al) != 0 {
+	if al := buildAccessLogFromTelemetry(push, cfg, false); len(al) != 0 {
 		connectionManager.AccessLog = append(connectionManager.AccessLog, al...)
 	}
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/filterchain_options.go b/pilot/pkg/networking/core/v1alpha3/filterchain_options.go
index 107f167bf6..c6a8f71365 100644
--- a/pilot/pkg/networking/core/v1alpha3/filterchain_options.go
+++ b/pilot/pkg/networking/core/v1alpha3/filterchain_options.go
@@ -17,6 +17,7 @@
 import (
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	"istio.io/istio/pilot/pkg/model"
@@ -34,12 +35,8 @@ type FilterChainMatchOptions struct {
 	TransportProtocol string
 	// Filter chain protocol. HTTP for HTTP proxy and TCP for TCP proxy
 	Protocol networking.ListenerProtocol
-	// Whether this chain should terminate mTLS or not
-	MTLS bool
-	// Hostnames to match on
-	SNIHosts []string
-	// Has One-way TLS or mTLS configured by the user
-	IsCustomTLS bool
+	// Whether this chain should terminate TLS or not
+	TLS bool
 }
 
 // Set of filter chain match options used for various combinations.
@@ -53,7 +50,7 @@ type FilterChainMatchOptions struct {
 			// If client sends mTLS traffic, transport protocol will be set by the TLS inspector
 			TransportProtocol: xdsfilters.TLSTransportProtocol,
 			Protocol:          networking.ListenerProtocolHTTP,
-			MTLS:              true,
+			TLS:               true,
 		},
 		{
 			// client side traffic was detected as HTTP by the outbound listener, sent out as plain text
@@ -68,7 +65,7 @@ type FilterChainMatchOptions struct {
 			// If client sends mTLS traffic, transport protocol will be set by the TLS inspector
 			TransportProtocol: xdsfilters.TLSTransportProtocol,
 			Protocol:          networking.ListenerProtocolTCP,
-			MTLS:              true,
+			TLS:               true,
 		},
 		{
 			// client side traffic could not be identified by the outbound listener, sent over plaintext
@@ -94,7 +91,7 @@ type FilterChainMatchOptions struct {
 			ApplicationProtocols: allIstioMtlsALPNs,
 			TransportProtocol:    xdsfilters.TLSTransportProtocol,
 			Protocol:             networking.ListenerProtocolHTTP,
-			MTLS:                 true,
+			TLS:                  true,
 		},
 		{
 			// Plaintext HTTP
@@ -109,7 +106,7 @@ type FilterChainMatchOptions struct {
 			ApplicationProtocols: allIstioMtlsALPNs,
 			TransportProtocol:    xdsfilters.TLSTransportProtocol,
 			Protocol:             networking.ListenerProtocolTCP,
-			MTLS:                 true,
+			TLS:                  true,
 		},
 		{
 			// Plain TLS
@@ -130,27 +127,27 @@ type FilterChainMatchOptions struct {
 			ApplicationProtocols: mtlsHTTPALPNs,
 			Protocol:             networking.ListenerProtocolHTTP,
 			TransportProtocol:    xdsfilters.TLSTransportProtocol,
-			MTLS:                 true,
+			TLS:                  true,
 		},
 		{
 			// Could not detect traffic on the client side. Server side has no mTLS.
 			Protocol:          networking.ListenerProtocolTCP,
 			TransportProtocol: xdsfilters.TLSTransportProtocol,
-			MTLS:              true,
+			TLS:               true,
 		},
 	}
 	inboundStrictTCPFilterChainMatchOptions = []FilterChainMatchOptions{
 		{
 			Protocol:          networking.ListenerProtocolTCP,
 			TransportProtocol: xdsfilters.TLSTransportProtocol,
-			MTLS:              true,
+			TLS:               true,
 		},
 	}
 	inboundStrictHTTPFilterChainMatchOptions = []FilterChainMatchOptions{
 		{
 			Protocol:          networking.ListenerProtocolHTTP,
 			TransportProtocol: xdsfilters.TLSTransportProtocol,
-			MTLS:              true,
+			TLS:               true,
 		},
 	}
 
@@ -182,6 +179,15 @@ type FilterChainMatchOptions struct {
 	emptyFilterChainMatch = &listener.FilterChainMatch{}
 )
 
+// getTLSFilterChainMatchOptions returns the FilterChainMatchOptions that should be used based on mTLS mode and protocol
+func getTLSFilterChainMatchOptions(protocol networking.ListenerProtocol) []FilterChainMatchOptions {
+	return []FilterChainMatchOptions{{
+		Protocol:          protocol,
+		TransportProtocol: xdsfilters.TLSTransportProtocol,
+		TLS:               true,
+	}}
+}
+
 // getFilterChainMatchOptions returns the FilterChainMatchOptions that should be used based on mTLS mode and protocol
 func getFilterChainMatchOptions(settings plugin.MTLSSettings, protocol networking.ListenerProtocol) []FilterChainMatchOptions {
 	switch protocol {
@@ -238,3 +244,13 @@ func (opt fcOpts) populateFilterChain(mtls plugin.MTLSSettings, port uint32, mat
 	}
 	return opt
 }
+
+func (opt FilterChainMatchOptions) ToTransportSocket(mtls plugin.MTLSSettings) *tls.DownstreamTlsContext {
+	if !opt.TLS {
+		return nil
+	}
+	if opt.Protocol == networking.ListenerProtocolHTTP {
+		return mtls.HTTP
+	}
+	return mtls.TCP
+}
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway.go b/pilot/pkg/networking/core/v1alpha3/gateway.go
index 183e93531a..e6e42c21a4 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway.go
@@ -567,7 +567,8 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 				rds:               routeName,
 				useRemoteAddress:  true,
 				connectionManager: buildGatewayConnectionManager(proxyConfig, node, false /* http3SupportEnabled */),
-				addGRPCWebFilter:  serverProto == protocol.GRPCWeb,
+				protocol:          serverProto,
+				class:             istionetworking.ListenerClassGateway,
 			},
 		}
 	}
@@ -586,9 +587,10 @@ func (configgen *ConfigGeneratorImpl) createGatewayHTTPFilterChainOpts(node *mod
 			rds:               routeName,
 			useRemoteAddress:  true,
 			connectionManager: buildGatewayConnectionManager(proxyConfig, node, http3Enabled),
-			addGRPCWebFilter:  serverProto == protocol.GRPCWeb,
+			protocol:          serverProto,
 			statPrefix:        server.Name,
 			http3Only:         http3Enabled,
+			class:             istionetworking.ListenerClassGateway,
 		},
 	}
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/gateway_test.go b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
index 225ac4be09..4b56480022 100644
--- a/pilot/pkg/networking/core/v1alpha3/gateway_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/gateway_test.go
@@ -39,6 +39,7 @@
 	"istio.io/istio/pilot/test/xdstest"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/visibility"
 	"istio.io/istio/pkg/proto"
@@ -662,7 +663,9 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 				Metadata: &pilot_model.NodeMetadata{HTTP10: "1"},
 			},
 			server: &networking.Server{
-				Port: &networking.Port{},
+				Port: &networking.Port{
+					Protocol: protocol.HTTP.String(),
+				},
 			},
 			routeName:   "some-route",
 			proxyConfig: nil,
@@ -687,6 +690,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						},
 						StripPortMode: stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTP,
 				},
 			},
 		},
@@ -777,6 +782,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						HttpProtocolOptions: &core.Http1ProtocolOptions{},
 						StripPortMode:       stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTPS,
 				},
 			},
 		},
@@ -867,6 +874,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						HttpProtocolOptions: &core.Http1ProtocolOptions{},
 						StripPortMode:       stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTPS,
 				},
 			},
 		},
@@ -957,6 +966,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						HttpProtocolOptions: &core.Http1ProtocolOptions{},
 						StripPortMode:       stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTPS,
 				},
 			},
 		},
@@ -964,7 +975,9 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 			name: "Topology HTTP Protocol",
 			node: &pilot_model.Proxy{Metadata: &pilot_model.NodeMetadata{}},
 			server: &networking.Server{
-				Port: &networking.Port{},
+				Port: &networking.Port{
+					Protocol: protocol.HTTP.String(),
+				},
 			},
 			routeName: "some-route",
 			proxyConfig: &meshconfig.ProxyConfig{
@@ -992,6 +1005,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						HttpProtocolOptions: &core.Http1ProtocolOptions{},
 						StripPortMode:       stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTP,
 				},
 			},
 		},
@@ -1087,6 +1102,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						HttpProtocolOptions: &core.Http1ProtocolOptions{},
 						StripPortMode:       stripPortMode,
 					},
+					class:    istionetworking.ListenerClassGateway,
+					protocol: protocol.HTTPS,
 				},
 			},
 		},
@@ -1184,6 +1201,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 						StripPortMode:       stripPortMode,
 					},
 					statPrefix: "server1",
+					class:      istionetworking.ListenerClassGateway,
+					protocol:   protocol.HTTPS,
 				},
 			},
 		},
@@ -1265,6 +1284,8 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 					},
 					useRemoteAddress: true,
 					statPrefix:       "server1",
+					class:            istionetworking.ListenerClassGateway,
+					protocol:         protocol.HTTPS,
 				},
 			},
 		},
@@ -1282,7 +1303,7 @@ func TestCreateGatewayHTTPFilterChainOpts(t *testing.T) {
 				t.Errorf("got diff in tls context: %v", diff)
 			}
 			if !reflect.DeepEqual(tc.result.httpOpts, ret.httpOpts) {
-				t.Errorf("expecting httpopts:\n %+v \nbut got:\n %+v", tc.result.httpOpts.connectionManager, ret.httpOpts.connectionManager)
+				t.Errorf("expecting httpopts:\n %+v \nbut got:\n %+v", tc.result.httpOpts, ret.httpOpts)
 			}
 			if !reflect.DeepEqual(tc.result.sniHosts, ret.sniHosts) {
 				t.Errorf("expecting snihosts %+v but got %+v", tc.result.sniHosts, ret.sniHosts)
diff --git a/pilot/pkg/networking/core/v1alpha3/httproute.go b/pilot/pkg/networking/core/v1alpha3/httproute.go
index a6cdb3ff7e..8c9c682120 100644
--- a/pilot/pkg/networking/core/v1alpha3/httproute.go
+++ b/pilot/pkg/networking/core/v1alpha3/httproute.go
@@ -100,25 +100,23 @@ func (configgen *ConfigGeneratorImpl) BuildHTTPRoutes(
 
 // buildSidecarInboundHTTPRouteConfig builds the route config with a single wildcard virtual host on the inbound path
 // TODO: trace decorators, inbound timeouts
-func buildSidecarInboundHTTPRouteConfig(
-	node *model.Proxy, push *model.PushContext, instance *model.ServiceInstance, clusterName string,
-) *route.RouteConfiguration {
-	traceOperation := util.TraceOperation(string(instance.Service.Hostname), instance.ServicePort.Port)
-	defaultRoute := istio_route.BuildDefaultHTTPInboundRoute(clusterName, traceOperation)
+func buildSidecarInboundHTTPRouteConfig(lb *ListenerBuilder, cc inboundChainConfig) *route.RouteConfiguration {
+	traceOperation := util.TraceOperation(string(cc.telemetryMetadata.InstanceHostname), int(cc.port.Port))
+	defaultRoute := istio_route.BuildDefaultHTTPInboundRoute(cc.clusterName, traceOperation)
 
 	inboundVHost := &route.VirtualHost{
-		Name:    inboundVirtualHostPrefix + strconv.Itoa(instance.ServicePort.Port), // Format: "inbound|http|%d"
+		Name:    inboundVirtualHostPrefix + strconv.Itoa(int(cc.port.Port)), // Format: "inbound|http|%d"
 		Domains: []string{"*"},
 		Routes:  []*route.Route{defaultRoute},
 	}
 
 	r := &route.RouteConfiguration{
-		Name:             clusterName,
+		Name:             cc.clusterName,
 		VirtualHosts:     []*route.VirtualHost{inboundVHost},
 		ValidateClusters: proto.BoolFalse,
 	}
-	efw := push.EnvoyFilters(node)
-	r = envoyfilter.ApplyRouteConfigurationPatches(networking.EnvoyFilter_SIDECAR_INBOUND, node, efw, r)
+	efw := lb.push.EnvoyFilters(lb.node)
+	r = envoyfilter.ApplyRouteConfigurationPatches(networking.EnvoyFilter_SIDECAR_INBOUND, lb.node, efw, r)
 	return r
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index e9fabbe2a9..e2d7a5c8f3 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -40,9 +40,8 @@
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/extension"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
-	authn_model "istio.io/istio/pilot/pkg/security/model"
+	authnmodel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pilot/pkg/xds/requestidextension"
@@ -59,24 +58,18 @@
 
 const (
 	NoConflict = iota
-	// Incoming HTTP existing HTTP
-	HTTPOverHTTP
-	// Incoming HTTP existing TCP
+	// HTTPOverTCP represents incoming HTTP existing TCP
 	HTTPOverTCP
-	// Incoming HTTP existing AUTO
-	HTTPOverAuto
-	// Incoming TCP existing HTTP
+	// TCPOverHTTP represents incoming TCP existing HTTP
 	TCPOverHTTP
-	// Incoming TCP existing TCP
+	// TCPOverTCP represents incoming TCP existing TCP
 	TCPOverTCP
-	// Incoming TCP existing AUTO
+	// TCPOverAuto represents incoming TCP existing AUTO
 	TCPOverAuto
-	// Incoming AUTO existing HTTP
+	// AutoOverHTTP represents incoming AUTO existing HTTP
 	AutoOverHTTP
-	// Incoming AUTO existing TCP
+	// AutoOverTCP represents incoming AUTO existing TCP
 	AutoOverTCP
-	// Incoming AUTO existing AUTO
-	AutoOverAuto
 )
 
 const (
@@ -95,7 +88,7 @@ type MutableListener struct {
 var (
 	// These are sniffed by the HTTP Inspector in the outbound listener
 	// We need to forward these ALPNs to upstream so that the upstream can
-	// properly use a HTTP or TCP listener
+	// properly use an HTTP or TCP listener
 	plaintextHTTPALPNs = func() []string {
 		if features.HTTP10 {
 			// If HTTP 1.0 is enabled, we will match it
@@ -156,9 +149,9 @@ func BuildListenerTLSContext(serverTLSSettings *networking.ServerTLSSettings,
 		switch {
 		// If credential name is specified at gateway config, create  SDS config for gateway to fetch key/cert from Istiod.
 		case serverTLSSettings.CredentialName != "":
-			authn_model.ApplyCredentialSDSToServerCommonTLSContext(ctx.CommonTlsContext, serverTLSSettings)
+			authnmodel.ApplyCredentialSDSToServerCommonTLSContext(ctx.CommonTlsContext, serverTLSSettings)
 		case serverTLSSettings.Mode == networking.ServerTLSSettings_ISTIO_MUTUAL:
-			authn_model.ApplyToCommonTLSContext(ctx.CommonTlsContext, proxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
+			authnmodel.ApplyToCommonTLSContext(ctx.CommonTlsContext, proxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
 		default:
 			certProxy := &model.Proxy{}
 			certProxy.IstioVersion = proxy.IstioVersion
@@ -169,15 +162,15 @@ func BuildListenerTLSContext(serverTLSSettings *networking.ServerTLSSettings,
 				TLSServerRootCert:  serverTLSSettings.CaCertificates,
 			}
 
-			authn_model.ApplyToCommonTLSContext(ctx.CommonTlsContext, certProxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
+			authnmodel.ApplyToCommonTLSContext(ctx.CommonTlsContext, certProxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
 		}
 	} else {
 		switch {
 		case serverTLSSettings.Mode == networking.ServerTLSSettings_ISTIO_MUTUAL:
-			authn_model.ApplyToCommonTLSContext(ctx.CommonTlsContext, proxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
+			authnmodel.ApplyToCommonTLSContext(ctx.CommonTlsContext, proxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
 		// If credential name is specified at gateway config, create  SDS config for gateway to fetch key/cert from Istiod.
 		case serverTLSSettings.CredentialName != "":
-			authn_model.ApplyCredentialSDSToServerCommonTLSContext(ctx.CommonTlsContext, serverTLSSettings)
+			authnmodel.ApplyCredentialSDSToServerCommonTLSContext(ctx.CommonTlsContext, serverTLSSettings)
 		default:
 			certProxy := &model.Proxy{}
 			certProxy.IstioVersion = proxy.IstioVersion
@@ -188,7 +181,7 @@ func BuildListenerTLSContext(serverTLSSettings *networking.ServerTLSSettings,
 				TLSServerRootCert:  serverTLSSettings.CaCertificates,
 			}
 
-			authn_model.ApplyToCommonTLSContext(ctx.CommonTlsContext, certProxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
+			authnmodel.ApplyToCommonTLSContext(ctx.CommonTlsContext, certProxy, serverTLSSettings.SubjectAltNames, []string{}, ctx.RequireClientCertificate.Value)
 		}
 	}
 
@@ -232,285 +225,16 @@ func (configgen *ConfigGeneratorImpl) buildSidecarListeners(builder *ListenerBui
 		builder.appendSidecarInboundListeners().
 			appendSidecarOutboundListeners().
 			buildHTTPProxyListener().
-			buildVirtualOutboundListener().
-			buildVirtualInboundListener()
+			buildVirtualOutboundListener()
 	}
 	return builder
 }
 
-// buildSidecarInboundListeners creates listeners for the server-side (inbound)
-// configuration for co-located service proxyInstances.
-func (lb *ListenerBuilder) buildSidecarInboundListeners(
-	node *model.Proxy,
-	push *model.PushContext) []*listener.Listener {
-	var listeners []*listener.Listener
-	listenerMap := make(map[int]*inboundListenerEntry)
-
-	sidecarScope := node.SidecarScope
-	noneMode := node.GetInterceptionMode() == model.InterceptionNone
-	// No user supplied sidecar scope or the user supplied one has no ingress listeners.
-	if !sidecarScope.HasIngressListener() {
-		// Construct inbound listeners in the usual way by looking at the ports of the service instances
-		// attached to the proxy
-		// We should not create inbound listeners in NONE mode based on the service instances
-		// Doing so will prevent the workloads from starting as they would be listening on the same port
-		// Users are required to provide the sidecar config to define the inbound listeners
-		if noneMode {
-			return nil
-		}
-
-		// Inbound connections/requests are redirected to the endpoint address but appear to be sent
-		// to the service address.
-		//
-		// Protocol sniffing for inbound listener.
-		// If there is no ingress listener, for each service instance, the listener port protocol is determined
-		// by the service port protocol. If user doesn't specify the service port protocol, the listener will
-		// be generated using protocol sniffing.
-		// For example, the set of service instances
-		//      --> Endpoint
-		//              Address:Port 172.16.0.1:1111
-		//              ServicePort  80|HTTP
-		//      --> Endpoint
-		//              Address:Port 172.16.0.1:2222
-		//              ServicePort  8888|TCP
-		//      --> Endpoint
-		//              Address:Port 172.16.0.1:3333
-		//              ServicePort 9999|Unknown
-		//
-		//	Pilot will generate three listeners, the last one will use protocol sniffing.
-		//
-		for _, instance := range node.ServiceInstances {
-			endpoint := instance.Endpoint
-			// Inbound listeners will be aggregated into a single virtual listener (port 15006)
-			// As a result, we don't need to worry about binding to the endpoint IP; we already know
-			// all traffic for these listeners is inbound.
-			// TODO: directly build filter chains rather than translating listeners to filter chains
-			wildcard, _ := getActualWildcardAndLocalHost(node)
-			bind := wildcard
-
-			// Local service instances can be accessed through one of three addresses: localhost, endpoint IP,
-			// and service VIP. Localhost bypasses the proxy and doesn't need any TCP route config. Endpoint IP
-			// is handled below and Service IP is handled by outbound routes. Traffic sent to our service VIP is
-			// redirected by remote services' kubeproxy to our specific endpoint IP.
-			port := *instance.ServicePort
-			port.Port = int(endpoint.EndpointPort)
-			listenerOpts := buildListenerOpts{
-				push:       push,
-				proxy:      node,
-				bind:       bind,
-				port:       &port,
-				bindToPort: false,
-				protocol:   istionetworking.ModelProtocolToListenerProtocol(instance.ServicePort.Protocol, core.TrafficDirection_INBOUND),
-			}
-
-			pluginParams := &plugin.InputParams{
-				Node:            node,
-				ServiceInstance: instance,
-				Push:            push,
-			}
-
-			if l := lb.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
-				listeners = append(listeners, l)
-			}
-		}
-		return listeners
-	}
-
-	for _, ingressListener := range sidecarScope.Sidecar.Ingress {
-		// determine the bindToPort setting for listeners. Validation guarantees that these are all IP listeners.
-		bindToPort := false
-		if noneMode {
-			// do not care what the listener's capture mode setting is. The proxy does not use iptables
-			bindToPort = true
-		} else if ingressListener.CaptureMode == networking.CaptureMode_NONE {
-			// proxy uses iptables redirect or tproxy. IF mode is not set
-			// for older proxies, it defaults to iptables redirect.  If the
-			// listener's capture mode specifies NONE, then the proxy wants
-			// this listener alone to be on a physical port. If the
-			// listener's capture mode is default, then its same as
-			// iptables i.e. bindToPort is false.
-			bindToPort = true
-		}
-
-		// Skip ports we cannot bind to
-		if !node.CanBindToPort(bindToPort, ingressListener.Port.Number) {
-			log.Warnf("buildSidecarInboundListeners: skipping privileged sidecar port %d for node %s as it is an unprivileged proxy",
-				ingressListener.Port.Number, node.ID)
-			continue
-		}
-
-		listenPort := &model.Port{
-			Port:     int(ingressListener.Port.Number),
-			Protocol: protocol.Parse(ingressListener.Port.Protocol),
-			Name:     ingressListener.Port.Name,
-		}
-
-		bind := ingressListener.Bind
-		if len(bind) == 0 {
-			// User did not provide one. Pick the proxy's IP or wildcard inbound listener.
-			bind = getSidecarInboundBindIP(node)
-		}
-
-		instance := findOrCreateServiceInstance(node.ServiceInstances, ingressListener,
-			sidecarScope.Name, sidecarScope.Namespace)
-
-		listenerOpts := buildListenerOpts{
-			push:       push,
-			proxy:      node,
-			bind:       bind,
-			port:       listenPort,
-			bindToPort: bindToPort,
-			protocol: istionetworking.ModelProtocolToListenerProtocol(listenPort.Protocol,
-				core.TrafficDirection_INBOUND),
-		}
-
-		// we don't need to set other fields of the endpoint here as
-		// the consumers of this service instance (listener/filter chain constructors)
-		// are simply looking for the service port and the service associated with the instance.
-		instance.ServicePort = listenPort
-
-		// Validation ensures that the protocol specified in Sidecar.ingress
-		// is always a valid known protocol
-		pluginParams := &plugin.InputParams{
-			Node:            node,
-			ServiceInstance: instance,
-			Push:            push,
-		}
-
-		// Add TLS settings if they have been configured
-		// Set the ListenerProtocol to ListenerProtocolHTTP so that istio adds
-		// HttpConnectionManager configs
-		if ingressListener.Tls != nil && features.EnableTLSOnSidecarIngress {
-			listenerOpts.tlsSettings = ingressListener.Tls
-			if listenPort.Protocol.IsHTTPS() {
-				listenerOpts.protocol = istionetworking.ListenerProtocolHTTP
-			}
-		}
-
-		if l := lb.buildSidecarInboundListenerForPortOrUDS(listenerOpts, pluginParams, listenerMap); l != nil {
-			listeners = append(listeners, l)
-		}
-	}
-
-	return listeners
-}
-
-func buildSidecarInboundHTTPListenerOptsForPortOrUDS(node *model.Proxy,
-	pluginParams *plugin.InputParams, clusterName string) *httpListenerOpts {
-	httpOpts := &httpListenerOpts{
-		routeConfig: buildSidecarInboundHTTPRouteConfig(pluginParams.Node,
-			pluginParams.Push, pluginParams.ServiceInstance, clusterName),
-		rds:              "", // no RDS for inbound traffic
-		useRemoteAddress: false,
-		connectionManager: &hcm.HttpConnectionManager{
-			// Append and forward client cert to backend.
-			ForwardClientCertDetails: hcm.HttpConnectionManager_APPEND_FORWARD,
-			SetCurrentClientCertDetails: &hcm.HttpConnectionManager_SetCurrentClientCertDetails{
-				Subject: proto.BoolTrue,
-				Uri:     true,
-				Dns:     true,
-			},
-			ServerName: EnvoyServerName,
-		},
-	}
-	// See https://github.com/grpc/grpc-web/tree/master/net/grpc/gateway/examples/helloworld#configure-the-proxy
-	if pluginParams.ServiceInstance.ServicePort.Protocol.IsHTTP2() {
-		httpOpts.connectionManager.Http2ProtocolOptions = &core.Http2ProtocolOptions{}
-		if pluginParams.ServiceInstance.ServicePort.Protocol == protocol.GRPCWeb {
-			httpOpts.addGRPCWebFilter = true
-		}
-	}
-
-	if features.HTTP10 || enableHTTP10(node.Metadata.HTTP10) {
-		httpOpts.connectionManager.HttpProtocolOptions = &core.Http1ProtocolOptions{
-			AcceptHttp_10: true,
-		}
-	}
-
-	return httpOpts
-}
-
 // if enableFlag is "1" indicates that AcceptHttp_10 is enabled.
 func enableHTTP10(enableFlag string) bool {
 	return enableFlag == "1"
 }
 
-// buildSidecarInboundListenerForPortOrUDS creates a single listener on the server-side (inbound)
-// for a given port or unix domain socket
-func (lb *ListenerBuilder) buildSidecarInboundListenerForPortOrUDS(listenerOpts buildListenerOpts,
-	pluginParams *plugin.InputParams, listenerMap map[int]*inboundListenerEntry) *listener.Listener {
-	// Local service instances can be accessed through one of four addresses:
-	// unix domain socket, localhost, endpoint IP, and service VIP
-	// Localhost bypasses the proxy and doesn't need any TCP route config.
-	// Endpoint IP is handled below and Service IP is handled by outbound routes.
-	// Traffic sent to our service VIP is redirected by remote services' kubeproxy to our specific endpoint IP.
-
-	listenerOpts.class = istionetworking.ListenerClassSidecarInbound
-
-	if old, exists := listenerMap[listenerOpts.port.Port]; exists {
-		if old.protocol != listenerOpts.port.Protocol && old.instanceHostname != pluginParams.ServiceInstance.Service.Hostname {
-			// For sidecar specified listeners, the caller is expected to supply a dummy service instance
-			// with the right port and a hostname constructed from the sidecar config's name+namespace
-			pluginParams.Push.AddMetric(model.ProxyStatusConflictInboundListener, pluginParams.Node.ID, pluginParams.Node.ID,
-				fmt.Sprintf("Conflicting inbound listener:%d. existing: %s, incoming: %s", listenerOpts.port.Port,
-					old.instanceHostname, pluginParams.ServiceInstance.Service.Hostname))
-			return nil
-		}
-		// This can happen if two services select the same pod with same port and protocol - we should skip building listener again.
-		if old.instanceHostname != pluginParams.ServiceInstance.Service.Hostname {
-			log.Debugf("skipping inbound listener:%d as we have already build it for existing host: %s, new host: %s",
-				listenerOpts.port.Port,
-				old.instanceHostname, pluginParams.ServiceInstance.Service.Hostname)
-		}
-		// Skip building listener for the same port
-		return nil
-	}
-	if listenerOpts.protocol == istionetworking.ListenerProtocolAuto {
-		listenerOpts.needHTTPInspector = true
-	}
-	// Setup filter chain options and call plugins
-	clusterName := model.BuildInboundSubsetKey(int(pluginParams.ServiceInstance.Endpoint.EndpointPort))
-	fcOpts := lb.buildInboundFilterchains(pluginParams, listenerOpts, "", clusterName, false)
-	listenerOpts.filterChainOpts = fcOpts
-
-	// Buildup the complete listener
-	// TODO: Currently, we build filter chains, then convert them to listener.Listeners then
-	// aggregate them back to filter chains in the virtual listener. This is complex and inefficient.
-	// We should instead just directly construct the filter chains. We do still need the ability to
-	// create full listeners for bind-to-port listeners added explicitly, but they are not common.
-	l := buildListener(listenerOpts, core.TrafficDirection_INBOUND)
-
-	mutable := &MutableListener{
-		MutableObjects: istionetworking.MutableObjects{
-			Listener:     l,
-			FilterChains: getPluginFilterChain(listenerOpts),
-		},
-	}
-
-	for cnum := range mutable.FilterChains {
-		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
-		}
-	}
-	// Filters are serialized one time into an opaque struct once we have the complete list.
-	if err := mutable.build(lb, listenerOpts); err != nil {
-		log.Warn("buildSidecarInboundListeners ", err.Error())
-		return nil
-	}
-
-	listenerMap[listenerOpts.port.Port] = &inboundListenerEntry{
-		instanceHostname: pluginParams.ServiceInstance.Service.Hostname,
-		protocol:         listenerOpts.port.Protocol,
-	}
-	return mutable.Listener
-}
-
-type inboundListenerEntry struct {
-	instanceHostname host.Name // could be empty if generated via Sidecar CRD
-	protocol         protocol.Instance
-}
-
 type outboundListenerEntry struct {
 	services    []*model.Service
 	servicePort *model.Port
@@ -785,8 +509,8 @@ func (lb *ListenerBuilder) buildSidecarOutboundListeners(node *model.Proxy,
 	}
 	tcpListeners = append(tcpListeners, httpListeners...)
 	// Build pass through filter chains now that all the non-passthrough filter chains are ready.
-	for _, listener := range tcpListeners {
-		appendListenerFallthroughRouteForCompleteListener(listener, node, push)
+	for _, l := range tcpListeners {
+		appendListenerFallthroughRouteForCompleteListener(l, node, push)
 	}
 	removeListenerFilterTimeout(tcpListeners)
 	return tcpListeners
@@ -827,6 +551,8 @@ func (lb *ListenerBuilder) buildHTTPProxy(node *model.Proxy,
 				connectionManager: &hcm.HttpConnectionManager{
 					HttpProtocolOptions: httpOpts,
 				},
+				protocol: protocol.HTTP_PROXY,
+				class:    istionetworking.ListenerClassSidecarOutbound,
 			},
 		}},
 		bindToPort:      true,
@@ -935,6 +661,9 @@ func buildSidecarOutboundHTTPListenerOptsForPortOrUDS(listenerMapKey *string,
 		// such as "x-envoy-upstream-rq-timeout-ms" set by the calling application.
 		useRemoteAddress: features.UseRemoteAddress,
 		rds:              rdsName,
+
+		protocol: listenerOpts.port.Protocol,
+		class:    istionetworking.ListenerClassSidecarOutbound,
 	}
 
 	if features.HTTP10 || enableHTTP10(listenerOpts.proxy.Metadata.HTTP10) {
@@ -1336,15 +1065,15 @@ type httpListenerOpts struct {
 	connectionManager *hcm.HttpConnectionManager
 	// stat prefix for the http connection manager
 	// DO not set this field. Will be overridden by buildCompleteFilterChain
-	statPrefix string
-	// addGRPCWebFilter specifies whether the envoy.grpc_web HTTP filter
-	// should be added.
-	addGRPCWebFilter bool
+	statPrefix       string
+	protocol         protocol.Instance
 	useRemoteAddress bool
 
 	// http3Only indicates that the HTTP codec used
 	// is HTTP/3 over QUIC transport (uses UDP)
 	http3Only bool
+
+	class istionetworking.ListenerClass
 }
 
 // filterChainOpts describes a filter chain: a set of filters with the same TLS context
@@ -1374,12 +1103,10 @@ type buildListenerOpts struct {
 	needHTTPInspector bool
 	class             istionetworking.ListenerClass
 	service           *model.Service
-	protocol          istionetworking.ListenerProtocol
 	transport         istionetworking.TransportProtocol
-	tlsSettings       *networking.ServerTLSSettings
 }
 
-func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListenerOpts, httpOpts *httpListenerOpts) *hcm.HttpConnectionManager {
+func (lb *ListenerBuilder) buildHTTPConnectionManager(httpOpts *httpListenerOpts) *hcm.HttpConnectionManager {
 	if httpOpts.connectionManager == nil {
 		httpOpts.connectionManager = &hcm.HttpConnectionManager{}
 	}
@@ -1396,7 +1123,7 @@ func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListener
 
 	// Setup normalization
 	connectionManager.PathWithEscapedSlashesAction = hcm.HttpConnectionManager_KEEP_UNCHANGED
-	switch listenerOpts.push.Mesh.GetPathNormalization().GetNormalization() {
+	switch lb.push.Mesh.GetPathNormalization().GetNormalization() {
 	case meshconfig.MeshConfig_ProxyPathNormalization_NONE:
 		connectionManager.NormalizePath = proto.BoolFalse
 	case meshconfig.MeshConfig_ProxyPathNormalization_BASE, meshconfig.MeshConfig_ProxyPathNormalization_DEFAULT:
@@ -1420,7 +1147,7 @@ func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListener
 	websocketUpgrade := &hcm.HttpConnectionManager_UpgradeConfig{UpgradeType: "websocket"}
 	connectionManager.UpgradeConfigs = []*hcm.HttpConnectionManager_UpgradeConfig{websocketUpgrade}
 
-	idleTimeout, err := time.ParseDuration(listenerOpts.proxy.Metadata.IdleTimeout)
+	idleTimeout, err := time.ParseDuration(lb.node.Metadata.IdleTimeout)
 	if err == nil {
 		connectionManager.CommonHttpProtocolOptions = &core.HttpProtocolOptions{
 			IdleTimeout: durationpb.New(idleTimeout),
@@ -1448,18 +1175,18 @@ func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListener
 		connectionManager.RouteSpecifier = &hcm.HttpConnectionManager_RouteConfig{RouteConfig: httpOpts.routeConfig}
 	}
 
-	accessLogBuilder.setHTTPAccessLog(listenerOpts, connectionManager)
+	accessLogBuilder.setHTTPAccessLog(lb.push, lb.node, connectionManager, httpOpts.class)
 
-	routerFilterCtx, reqIDExtensionCtx := configureTracing(listenerOpts, connectionManager)
+	routerFilterCtx, reqIDExtensionCtx := configureTracing(lb.push, lb.node, connectionManager, httpOpts.class)
 
 	filters := []*hcm.HttpFilter{}
 	wasm := lb.push.WasmPlugins(lb.node)
 	// TODO: how to deal with ext-authz? It will be in the ordering twice
-	filters = append(filters, lb.authzCustomBuilder.BuildHTTP(listenerOpts.class)...)
+	filters = append(filters, lb.authzCustomBuilder.BuildHTTP(httpOpts.class)...)
 	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHN)
-	filters = append(filters, lb.authnBuilder.BuildHTTP(listenerOpts.class)...)
+	filters = append(filters, lb.authnBuilder.BuildHTTP(httpOpts.class)...)
 	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_AUTHZ)
-	filters = append(filters, lb.authzBuilder.BuildHTTP(listenerOpts.class)...)
+	filters = append(filters, lb.authzBuilder.BuildHTTP(httpOpts.class)...)
 
 	// TODO: these feel like the wrong place to insert, but this retains backwards compatibility with the original implementation
 	filters = extension.PopAppend(filters, wasm, extensions.PluginPhase_STATS)
@@ -1469,24 +1196,24 @@ func (lb *ListenerBuilder) buildHTTPConnectionManager(listenerOpts buildListener
 		filters = append(filters, xdsfilters.HTTPMx)
 	}
 
-	if httpOpts.addGRPCWebFilter {
+	if httpOpts.protocol == protocol.GRPCWeb {
 		filters = append(filters, xdsfilters.GrpcWeb)
 	}
 
-	if listenerOpts.port != nil && listenerOpts.port.Protocol.IsGRPC() {
+	if httpOpts.protocol.IsGRPC() {
 		filters = append(filters, xdsfilters.GrpcStats)
 	}
 
 	// append ALPN HTTP filter in HTTP connection manager for outbound listener only.
 	if features.ALPNFilter {
-		if listenerOpts.class != istionetworking.ListenerClassSidecarInbound {
+		if httpOpts.class != istionetworking.ListenerClassSidecarInbound {
 			filters = append(filters, xdsfilters.Alpn)
 		}
 	}
 
 	// TypedPerFilterConfig in route needs these filters.
 	filters = append(filters, xdsfilters.Fault, xdsfilters.Cors)
-	filters = append(filters, listenerOpts.push.Telemetry.HTTPFilters(listenerOpts.proxy, listenerOpts.class)...)
+	filters = append(filters, lb.push.Telemetry.HTTPFilters(lb.node, httpOpts.class)...)
 	filters = append(filters, xdsfilters.BuildRouterFilter(routerFilterCtx))
 
 	connectionManager.HttpFilters = filters
@@ -1746,7 +1473,7 @@ func (ml *MutableListener) build(builder *ListenerBuilder, opts buildListenerOpt
 			if len(opt.httpOpts.statPrefix) == 0 {
 				opt.httpOpts.statPrefix = strings.ToLower(ml.Listener.TrafficDirection.String()) + "_" + ml.Listener.Name
 			}
-			httpConnectionManagers[i] = builder.buildHTTPConnectionManager(opts, opt.httpOpts)
+			httpConnectionManagers[i] = builder.buildHTTPConnectionManager(opt.httpOpts)
 			filter := &listener.Filter{
 				Name:       wellknown.HTTPConnectionManager,
 				ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(httpConnectionManagers[i])},
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 8eadd77d85..82b61a88ed 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -15,42 +15,27 @@
 package v1alpha3
 
 import (
-	"sort"
 	"time"
 
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	tcp "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/tcp_proxy/v3"
-	envoytype "github.com/envoyproxy/go-control-plane/envoy/type/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
-	golangproto "google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
 	networking "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/envoyfilter"
 	istio_route "istio.io/istio/pilot/pkg/networking/core/v1alpha3/route"
-	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/plugin/authn"
 	"istio.io/istio/pilot/pkg/networking/plugin/authz"
 	"istio.io/istio/pilot/pkg/networking/util"
-	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
-	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/proto"
 	"istio.io/pkg/log"
 )
 
-var dummyServiceInstance = &model.ServiceInstance{
-	Service:     &model.Service{},
-	ServicePort: &model.Port{},
-	Endpoint: &model.IstioEndpoint{
-		EndpointPort: 15006,
-	},
-}
-
 // A stateful listener builder
 // Support the below intentions
 // 1. Use separate inbound capture listener(:15006) and outbound capture listener(:15001)
@@ -76,259 +61,12 @@ type ListenerBuilder struct {
 	authzCustomBuilder *authz.Builder
 }
 
-// Setup the filter chain match so that the match should work under both
-// - bind_to_port == false listener
-// - virtual inbound listener
-func amendFilterChainMatchFromInboundListener(chain *listener.FilterChain, l *listener.Listener) enabledInspector {
-	if chain.FilterChainMatch == nil {
-		chain.FilterChainMatch = &listener.FilterChainMatch{}
-	}
-	listenerAddress := l.Address
-	if sockAddr := listenerAddress.GetSocketAddress(); sockAddr != nil {
-		chain.FilterChainMatch.DestinationPort = &wrappers.UInt32Value{Value: sockAddr.GetPortValue()}
-		chain.Name = l.Name
-	}
-
-	res := enabledInspector{}
-	for _, filter := range l.ListenerFilters {
-		if filter.Name == wellknown.TlsInspector {
-			res.TLSInspector = true
-		}
-		if filter.Name == wellknown.HttpInspector {
-			res.HTTPInspector = true
-		}
-	}
-	return res
-}
-
-func isBindtoPort(l *listener.Listener) bool {
-	v1 := l.GetBindToPort()
-	if v1 == nil {
-		// Default is true
-		return true
-	}
-	return v1.GetValue()
-}
-
 // enabledInspector captures if for a given listener, listener filter inspectors are added
 type enabledInspector struct {
 	HTTPInspector bool
 	TLSInspector  bool
 }
 
-// Accumulate the filter chains from per proxy service listeners
-func reduceInboundListenerToFilterChains(listeners []*listener.Listener) ([]*listener.FilterChain, map[int]enabledInspector) {
-	inspectorsMap := map[int]enabledInspector{}
-	chains := make([]*listener.FilterChain, 0)
-	for _, l := range listeners {
-		// default bindToPort is true and these listener should be skipped
-		if isBindtoPort(l) {
-			// A listener on real port should not be intercepted by virtual inbound listener
-			continue
-		}
-		for _, c := range l.FilterChains {
-			chain := golangproto.Clone(c).(*listener.FilterChain)
-			inspectors := amendFilterChainMatchFromInboundListener(chain, l)
-			chains = append(chains, chain)
-			// Aggregate the inspector options. If any listener on the port needs inspector, we should add it
-			// Generally there is 1 listener per port anyways.
-			port := int(l.Address.GetSocketAddress().GetPortValue())
-			if port > 0 {
-				prev := inspectorsMap[port]
-				prev.HTTPInspector = prev.HTTPInspector || inspectors.HTTPInspector
-				prev.TLSInspector = prev.TLSInspector || inspectors.TLSInspector
-				inspectorsMap[port] = prev
-			}
-		}
-	}
-	return chains, inspectorsMap
-}
-
-func needsTLS(inspectors map[int]enabledInspector) bool {
-	for _, i := range inspectors {
-		if i.TLSInspector {
-			return true
-		}
-	}
-	return false
-}
-
-func mergeInspectors(a, b map[int]enabledInspector) map[int]enabledInspector {
-	result := map[int]enabledInspector{}
-	for p, i := range a {
-		result[p] = i
-	}
-	for p, i := range b {
-		result[p] = i
-	}
-	return result
-}
-
-func (lb *ListenerBuilder) aggregateVirtualInboundListener(passthroughInspectors map[int]enabledInspector) *ListenerBuilder {
-	// Deprecated by envoyproxy. Replaced
-	// 1. filter chains in this listener
-	// 2. explicit original_dst listener filter
-	// UseOriginalDst: proto.BoolTrue,
-	lb.virtualInboundListener.UseOriginalDst = nil
-	lb.virtualInboundListener.ListenerFilters = append(lb.virtualInboundListener.ListenerFilters,
-		xdsfilters.OriginalDestination,
-	)
-	if lb.node.GetInterceptionMode() == model.InterceptionTproxy {
-		lb.virtualInboundListener.ListenerFilters = append(lb.virtualInboundListener.ListenerFilters, xdsfilters.OriginalSrc)
-	}
-	// TODO: Trim the inboundListeners properly. Those that have been added to filter chains should
-	// be removed while those that haven't been added need to remain in the inboundListeners list.
-	filterChains, inspectors := reduceInboundListenerToFilterChains(lb.inboundListeners)
-	sort.SliceStable(filterChains, func(i, j int) bool {
-		return filterChains[i].Name < filterChains[j].Name
-	})
-
-	lb.virtualInboundListener.FilterChains = append(lb.virtualInboundListener.FilterChains, filterChains...)
-
-	tlsInspectors := mergeInspectors(inspectors, passthroughInspectors)
-	if needsTLS(tlsInspectors) {
-		lb.virtualInboundListener.ListenerFilters = append(lb.virtualInboundListener.ListenerFilters, buildTLSInspector(tlsInspectors))
-	}
-
-	// Note: the HTTP inspector should be after TLS inspector.
-	// If TLS inspector sets transport protocol to tls, the http inspector
-	// won't inspect the packet.
-	if features.EnableProtocolSniffingForInbound {
-		lb.virtualInboundListener.ListenerFilters = append(lb.virtualInboundListener.ListenerFilters, buildHTTPInspector(inspectors))
-	}
-
-	timeout := lb.push.Mesh.GetProtocolDetectionTimeout()
-	if features.InboundProtocolDetectionTimeoutSet {
-		timeout = durationpb.New(features.InboundProtocolDetectionTimeout)
-	}
-	lb.virtualInboundListener.ListenerFiltersTimeout = timeout
-	lb.virtualInboundListener.ContinueOnListenerFiltersTimeout = true
-
-	// All listeners except bind_to_port=true listeners are now a part of virtual inbound and not needed
-	// we can filter these ones out.
-	bindToPortInbound := make([]*listener.Listener, 0, len(lb.inboundListeners))
-	for _, i := range lb.inboundListeners {
-		if isBindtoPort(i) {
-			bindToPortInbound = append(bindToPortInbound, i)
-		}
-	}
-	lb.inboundListeners = bindToPortInbound
-
-	return lb
-}
-
-// buildTLSInspector creates a tls inspector filter. Based on the configured ports, this may be enabled
-// for only some ports.
-func buildTLSInspector(inspectors map[int]enabledInspector) *listener.ListenerFilter {
-	defaultEnabled := inspectors[0].TLSInspector
-
-	// We have a split path here based on if the passthrough inspector is enabled
-	// If it is, then we need to explicitly opt ports out of the inspector
-	// If it isn't, then we need to explicitly opt ports into the inspector
-	if defaultEnabled {
-		ports := make([]int, 0, len(inspectors))
-		// Collect all ports where TLS inspector is disabled.
-		for p, i := range inspectors {
-			if p == 0 {
-				continue
-			}
-			if !i.TLSInspector {
-				ports = append(ports, p)
-			}
-		}
-		// No need to filter, return the cached version enabled for all ports
-		if len(ports) == 0 {
-			return xdsfilters.TLSInspector
-		}
-		// Ensure consistent ordering as we are looping over a map
-		sort.Ints(ports)
-		filter := &listener.ListenerFilter{
-			Name:           wellknown.TlsInspector,
-			ConfigType:     xdsfilters.TLSInspector.ConfigType,
-			FilterDisabled: listenerPredicateExcludePorts(ports),
-		}
-		return filter
-	}
-	ports := make([]int, 0, len(inspectors))
-	// Collect all ports where TLS inspector is disabled.
-	for p, i := range inspectors {
-		if p == 0 {
-			continue
-		}
-		if i.TLSInspector {
-			ports = append(ports, p)
-		}
-	}
-	// No need to filter, return the cached version enabled for all ports
-	if len(ports) == 0 {
-		return xdsfilters.TLSInspector
-	}
-	// Ensure consistent ordering as we are looping over a map
-	sort.Ints(ports)
-	filter := &listener.ListenerFilter{
-		Name:           wellknown.TlsInspector,
-		ConfigType:     xdsfilters.TLSInspector.ConfigType,
-		FilterDisabled: listenerPredicateIncludePorts(ports),
-	}
-	return filter
-}
-
-// buildHTTPInspector creates an http inspector filter. Based on the configured ports, this may be enabled
-// for only some ports.
-func buildHTTPInspector(inspectors map[int]enabledInspector) *listener.ListenerFilter {
-	ports := make([]int, 0, len(inspectors))
-	// Collect all ports where HTTP inspector is disabled.
-	for p, i := range inspectors {
-		if !i.HTTPInspector {
-			ports = append(ports, p)
-		}
-	}
-	// No need to filter, return the cached version enabled for all ports
-	if len(ports) == 0 {
-		return xdsfilters.HTTPInspector
-	}
-	// Ensure consistent ordering as we are looping over a map
-	sort.Ints(ports)
-	filter := &listener.ListenerFilter{
-		Name:           wellknown.HttpInspector,
-		ConfigType:     xdsfilters.HTTPInspector.ConfigType,
-		FilterDisabled: listenerPredicateExcludePorts(ports),
-	}
-	return filter
-}
-
-// listenerPredicateExcludePorts returns a listener filter predicate that will
-// match everything except the passed in ports. This is useful, for example, to
-// enable protocol sniffing on every port except port X and Y, because X and Y
-// are explicitly declared.
-func listenerPredicateExcludePorts(ports []int) *listener.ListenerFilterChainMatchPredicate {
-	ranges := []*listener.ListenerFilterChainMatchPredicate{}
-	for _, p := range ports {
-		ranges = append(ranges, &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_DestinationPortRange{
-			// Range is [start, end)
-			DestinationPortRange: &envoytype.Int32Range{
-				Start: int32(p),
-				End:   int32(p + 1),
-			},
-		}})
-	}
-	if len(ranges) > 1 {
-		return &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_OrMatch{
-			OrMatch: &listener.ListenerFilterChainMatchPredicate_MatchSet{
-				Rules: ranges,
-			},
-		}}
-	}
-	return &listener.ListenerFilterChainMatchPredicate{Rule: ranges[0].GetRule()}
-}
-
-func listenerPredicateIncludePorts(ports []int) *listener.ListenerFilterChainMatchPredicate {
-	rule := listenerPredicateExcludePorts(ports)
-	return &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_NotMatch{
-		NotMatch: rule,
-	}}
-}
-
 func NewListenerBuilder(node *model.Proxy, push *model.PushContext) *ListenerBuilder {
 	builder := &ListenerBuilder{
 		node: node,
@@ -341,7 +79,7 @@ func NewListenerBuilder(node *model.Proxy, push *model.PushContext) *ListenerBui
 }
 
 func (lb *ListenerBuilder) appendSidecarInboundListeners() *ListenerBuilder {
-	lb.inboundListeners = lb.buildSidecarInboundListeners(lb.node, lb.push)
+	lb.inboundListeners = lb.buildInboundListeners()
 	return lb
 }
 
@@ -391,47 +129,6 @@ func (lb *ListenerBuilder) buildVirtualOutboundListener() *ListenerBuilder {
 	return lb
 }
 
-// TProxy uses only the virtual outbound listener on 15001 for both directions
-// but we still ship the no-op virtual inbound listener, so that the code flow is same across REDIRECT and TPROXY.
-func (lb *ListenerBuilder) buildVirtualInboundListener() *ListenerBuilder {
-	if lb.node.GetInterceptionMode() == model.InterceptionNone {
-		// virtual listener is not necessary since workload is not using IPtables for traffic interception
-		return lb
-	}
-
-	var isTransparentProxy *wrappers.BoolValue
-	if lb.node.GetInterceptionMode() == model.InterceptionTproxy {
-		isTransparentProxy = proto.BoolTrue
-	}
-
-	actualWildcard, _ := getActualWildcardAndLocalHost(lb.node)
-	// add an extra listener that binds to the port that is the recipient of the iptables redirect
-	filterChains, passthroughInspector, usesQUIC := buildInboundCatchAllFilterChains(lb, lb.node, lb.push)
-
-	// exact balance used in Envoy is only supported over TCP connections
-	var connectionBalance *listener.Listener_ConnectionBalanceConfig
-	if !usesQUIC && bool(lb.node.Metadata.InboundListenerExactBalance) {
-		connectionBalance = &listener.Listener_ConnectionBalanceConfig{
-			BalanceType: &listener.Listener_ConnectionBalanceConfig_ExactBalance_{
-				ExactBalance: &listener.Listener_ConnectionBalanceConfig_ExactBalance{},
-			},
-		}
-	}
-	lb.virtualInboundListener = &listener.Listener{
-		Name:                    model.VirtualInboundListenerName,
-		Address:                 util.BuildAddress(actualWildcard, ProxyInboundListenPort),
-		Transparent:             isTransparentProxy,
-		UseOriginalDst:          proto.BoolTrue,
-		TrafficDirection:        core.TrafficDirection_INBOUND,
-		FilterChains:            filterChains,
-		ConnectionBalanceConfig: connectionBalance,
-	}
-	accessLogBuilder.setListenerAccessLog(lb.push, lb.node, lb.virtualInboundListener, istionetworking.ListenerClassSidecarInbound)
-	lb.aggregateVirtualInboundListener(passthroughInspector)
-
-	return lb
-}
-
 func (lb *ListenerBuilder) patchOneListener(l *listener.Listener, ctx networking.EnvoyFilter_PatchContext) *listener.Listener {
 	if l == nil {
 		return nil
@@ -466,21 +163,17 @@ func (lb *ListenerBuilder) patchListeners() {
 func (lb *ListenerBuilder) getListeners() []*listener.Listener {
 	if lb.node.Type == model.SidecarProxy {
 		nInbound, nOutbound := len(lb.inboundListeners), len(lb.outboundListeners)
-		nHTTPProxy, nVirtual, nVirtualInbound := 0, 0, 0
+		nHTTPProxy, nVirtual := 0, 0
 		if lb.httpProxyListener != nil {
 			nHTTPProxy = 1
 		}
 		if lb.virtualOutboundListener != nil {
 			nVirtual = 1
 		}
-		if lb.virtualInboundListener != nil {
-			nVirtualInbound = 1
-		}
 
-		nListener := nInbound + nOutbound + nHTTPProxy + nVirtual + nVirtualInbound
+		nListener := nInbound + nOutbound + nHTTPProxy + nVirtual
 
 		listeners := make([]*listener.Listener, 0, nListener)
-		listeners = append(listeners, lb.inboundListeners...)
 		listeners = append(listeners, lb.outboundListeners...)
 		if lb.httpProxyListener != nil {
 			listeners = append(listeners, lb.httpProxyListener)
@@ -488,209 +181,22 @@ func (lb *ListenerBuilder) getListeners() []*listener.Listener {
 		if lb.virtualOutboundListener != nil {
 			listeners = append(listeners, lb.virtualOutboundListener)
 		}
-		if lb.virtualInboundListener != nil {
-			listeners = append(listeners, lb.virtualInboundListener)
-		}
+		listeners = append(listeners, lb.inboundListeners...)
 
 		log.Debugf("Build %d listeners for node %s including %d outbound, %d http proxy, "+
-			"%d virtual outbound and %d virtual inbound listeners",
+			"%d virtual outbound",
 			nListener,
 			lb.node.ID,
 			nOutbound,
 			nHTTPProxy,
 			nVirtual,
-			nVirtualInbound)
+		)
 		return listeners
 	}
 
 	return lb.gatewayListeners
 }
 
-func buildInboundCatchAllFilterChains(lb *ListenerBuilder,
-	node *model.Proxy, push *model.PushContext) ([]*listener.FilterChain, map[int]enabledInspector, bool) {
-	usesQUIC := false
-
-	// ipv4 and ipv6 feature detect
-	ipVersions := make([]string, 0, 2)
-	if node.SupportsIPv4() {
-		ipVersions = append(ipVersions, util.InboundPassthroughClusterIpv4)
-	}
-	if node.SupportsIPv6() {
-		ipVersions = append(ipVersions, util.InboundPassthroughClusterIpv6)
-	}
-
-	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
-	filters = append(filters, buildMetricsNetworkFilters(push, node, istionetworking.ListenerClassSidecarInbound)...)
-	filters = append(filters, &listener.Filter{
-		Name: wellknown.TCPProxy,
-		ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(&tcp.TcpProxy{
-			StatPrefix:       util.BlackHoleCluster,
-			ClusterSpecifier: &tcp.TcpProxy_Cluster{Cluster: util.BlackHoleCluster},
-		})},
-	})
-	// Setup enough slots for common max size (permissive mode is 5 filter chains). This is not
-	// exact, just best effort optimization
-	filterChains := make([]*listener.FilterChain, 0, 1+5*len(ipVersions))
-	filterChains = append(filterChains, &listener.FilterChain{
-		Name: model.VirtualInboundBlackholeFilterChainName,
-		FilterChainMatch: &listener.FilterChainMatch{
-			DestinationPort: &wrappers.UInt32Value{Value: ProxyInboundListenPort},
-		},
-		Filters: filters,
-	})
-
-	inspectors := map[int]enabledInspector{}
-	for _, clusterName := range ipVersions {
-		matchingIP := ""
-		if clusterName == util.InboundPassthroughClusterIpv4 {
-			matchingIP = "0.0.0.0/0"
-		} else if clusterName == util.InboundPassthroughClusterIpv6 {
-			matchingIP = "::0/0"
-		}
-
-		in := &plugin.InputParams{
-			Node:            node,
-			ServiceInstance: dummyServiceInstance,
-			Push:            push,
-		}
-		listenerOpts := buildListenerOpts{
-			push:  push,
-			proxy: node,
-			bind:  matchingIP,
-			port: &model.Port{
-				Name:     "virtualInbound",
-				Port:     15006,
-				Protocol: protocol.HTTP,
-			},
-			class:    istionetworking.ListenerClassSidecarInbound,
-			protocol: istionetworking.ListenerProtocolAuto,
-		}
-		// Call plugins to get mtls policies.
-		fcOpts := lb.buildInboundFilterchains(in, listenerOpts, matchingIP, clusterName, true)
-		for _, opt := range fcOpts {
-			filterChain := &listener.FilterChain{
-				FilterChainMatch: opt.match,
-				Name:             opt.filterChainName,
-			}
-			if opt.httpOpts != nil {
-				opt.httpOpts.statPrefix = clusterName
-				if opt.httpOpts.http3Only {
-					usesQUIC = true
-				}
-				connectionManager := lb.buildHTTPConnectionManager(listenerOpts, opt.httpOpts)
-				filter := &listener.Filter{
-					Name:       wellknown.HTTPConnectionManager,
-					ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(connectionManager)},
-				}
-				filterChain.Filters = append(opt.filterChain.TCP, filter)
-			} else {
-				filterChain.Filters = append(filterChain.Filters, lb.authzCustomBuilder.BuildTCP()...)
-				filterChain.Filters = append(filterChain.Filters, lb.authzBuilder.BuildTCP()...)
-
-				filterChain.Filters = append(filterChain.Filters, opt.filterChain.TCP...)
-				filterChain.Filters = append(filterChain.Filters, opt.networkFilters...)
-			}
-			port := int(opt.match.DestinationPort.GetValue())
-			inspector := inspectors[port]
-			if opt.tlsContext != nil {
-				inspector.TLSInspector = true
-				// Update transport socket from the TLS context configured by the plugin.
-				filterChain.TransportSocket = &core.TransportSocket{
-					Name:       util.EnvoyTLSSocketName,
-					ConfigType: &core.TransportSocket_TypedConfig{TypedConfig: util.MessageToAny(opt.tlsContext)},
-				}
-			}
-			inspectors[port] = inspector
-			filterChains = append(filterChains, filterChain)
-		}
-	}
-
-	return filterChains, inspectors, usesQUIC
-}
-
-func (lb *ListenerBuilder) buildInboundFilterchains(in *plugin.InputParams, listenerOpts buildListenerOpts,
-	matchingIP string, clusterName string, passthrough bool) []*filterChainOpts {
-	newOpts := []*fcOpts{}
-
-	// unless the PeerAuthentication is set to "DISABLE",
-	// TLS settings won't take effect
-	hasMTLs := false
-
-	var mtlsConfigs []plugin.MTLSSettings
-	if passthrough {
-		mtlsConfigs = lb.authnBuilder.ForPassthrough()
-	} else {
-		mtlsConfigs = []plugin.MTLSSettings{lb.authnBuilder.ForPort(in.ServiceInstance.Endpoint.EndpointPort)}
-	}
-	for _, mtlsConfig := range mtlsConfigs {
-		hasMTLs = hasMTLs || mtlsConfig.Mode != model.MTLSDisable
-		for _, match := range getFilterChainMatchOptions(mtlsConfig, listenerOpts.protocol) {
-			opt := fcOpts{matchOpts: match}.populateFilterChain(mtlsConfig, mtlsConfig.Port, matchingIP)
-			newOpts = append(newOpts, &opt)
-		}
-	}
-
-	if listenerOpts.tlsSettings != nil && !hasMTLs {
-		newOpts = []*fcOpts{}
-		opt := fcOpts{matchOpts: FilterChainMatchOptions{IsCustomTLS: true}}
-		opt.fc.FilterChainMatch = &listener.FilterChainMatch{
-			TransportProtocol: xdsfilters.TLSTransportProtocol,
-			DestinationPort:   &wrappers.UInt32Value{Value: uint32(listenerOpts.port.Port)},
-		}
-		opt.fc.ListenerProtocol = listenerOpts.protocol
-		listenerOpts.tlsSettings.CipherSuites = filteredSidecarCipherSuites(listenerOpts.tlsSettings.CipherSuites)
-		opt.fc.TLSContext = BuildListenerTLSContext(listenerOpts.tlsSettings, in.Node, istionetworking.TransportProtocolTCP)
-		newOpts = append(newOpts, &opt)
-	}
-
-	// Run our filter chains through the plugin
-	fcs := make([]istionetworking.FilterChain, 0, len(newOpts))
-	for _, o := range newOpts {
-		fcs = append(fcs, o.fc)
-	}
-	mutable := &istionetworking.MutableObjects{
-		FilterChains: fcs,
-	}
-	// Merge the results back into our struct
-	for i, fc := range mutable.FilterChains {
-		newOpts[i].fc = fc
-	}
-
-	fcOpts := listenerOpts.filterChainOpts
-	for _, opt := range newOpts {
-		fcOpt := &filterChainOpts{
-			match: opt.fc.FilterChainMatch,
-		}
-		if len(opt.matchOpts.SNIHosts) > 0 {
-			fcOpt.sniHosts = opt.matchOpts.SNIHosts
-		}
-		if (opt.matchOpts.MTLS || opt.matchOpts.IsCustomTLS) && opt.fc.TLSContext != nil {
-			// Update transport socket from the TLS context configured by the plugin.
-			fcOpt.tlsContext = opt.fc.TLSContext
-		}
-		fcOpt.filterChain = opt.fc
-		switch opt.fc.ListenerProtocol {
-		case istionetworking.ListenerProtocolHTTP:
-			fcOpt.httpOpts = buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
-			fcOpt.filterChain.TCP = append(
-				buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound),
-				fcOpt.filterChain.TCP...)
-		case istionetworking.ListenerProtocolTCP:
-			fcOpt.networkFilters = buildInboundNetworkFilters(in.Push, in.Node, in.ServiceInstance, clusterName)
-		case istionetworking.ListenerProtocolAuto:
-			fcOpt.httpOpts = buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
-			fcOpt.networkFilters = buildInboundNetworkFilters(in.Push, in.Node, in.ServiceInstance, clusterName)
-		}
-		fcOpt.filterChainName = model.VirtualInboundListenerName
-		if opt.fc.ListenerProtocol == istionetworking.ListenerProtocolHTTP {
-			fcOpt.filterChainName = model.VirtualInboundCatchAllHTTPFilterChainName
-		}
-		fcOpts = append(fcOpts, fcOpt)
-	}
-	return fcOpts
-}
-
 func buildOutboundCatchAllNetworkFiltersOnly(push *model.PushContext, node *model.Proxy) []*listener.Filter {
 	var egressCluster string
 
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
index e5c4b0ce46..0a92983f7e 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
@@ -585,9 +585,10 @@ func TestInboundListenerFilters(t *testing.T) {
 				// Should not see HTTP inspector if we declare ports
 				80: true,
 				82: true,
-				// But should see for passthrough or unnamed ports
-				81:   false,
-				1000: false,
+				// This is 'auto', but for STRICT we always get requests over TLS so HTTP inspector is not in play
+				81: true,
+				// Even for passthrough, we do not need HTTP inspector because it is handled by TLS inspector
+				1000: true,
 			},
 			tls: map[int]bool{
 				// strict mode: inspector is set everywhere.
@@ -608,7 +609,7 @@ func TestInboundListenerFilters(t *testing.T) {
 			listeners := cg.Listeners(cg.SetupProxy(nil))
 			virtualInbound := xdstest.ExtractListener("virtualInbound", listeners)
 			filters := xdstest.ExtractListenerFilters(virtualInbound)
-			evaluateListenerFilterPredicates(t, filters[wellknown.HttpInspector].FilterDisabled, tt.http)
+			evaluateListenerFilterPredicates(t, filters[wellknown.HttpInspector].GetFilterDisabled(), tt.http)
 			if filters[wellknown.TlsInspector] == nil {
 				if len(tt.tls) > 0 {
 					t.Fatalf("Expected tls inspector, got none")
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_inbound.go b/pilot/pkg/networking/core/v1alpha3/listener_inbound.go
new file mode 100644
index 0000000000..d5741f478d
--- /dev/null
+++ b/pilot/pkg/networking/core/v1alpha3/listener_inbound.go
@@ -0,0 +1,704 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1alpha3
+
+import (
+	"fmt"
+	"sort"
+	"time"
+
+	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
+	tcp "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/tcp_proxy/v3"
+	envoytype "github.com/envoyproxy/go-control-plane/envoy/type/v3"
+	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
+	"github.com/golang/protobuf/ptypes/duration"
+	"google.golang.org/protobuf/types/known/durationpb"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
+
+	meshconfig "istio.io/api/mesh/v1alpha1"
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	istionetworking "istio.io/istio/pilot/pkg/networking"
+	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pilot/pkg/networking/util"
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/proto"
+	"istio.io/pkg/log"
+)
+
+// inboundChainConfig defines the configuration for a single inbound filter chain. This may be created
+// as a result of a Service, and Sidecar CR, or for the built-in passthrough filter chains.
+type inboundChainConfig struct {
+	// clusterName defines the destination cluster for this chain
+	clusterName string
+	// port defines the port configuration for this chain. Note that there is a Port and TargetPort;
+	// most usages should just use TargetPort. Port is mostly used for legacy compatibility and
+	// telemetry.
+	port ServiceInstancePort
+	// bind determines where (IP) this filter chain should bind. Note: typically we just end up using
+	// 'virtual' listener and do not literally bind to port; in these cases this just impacts naming
+	// and telemetry.
+	bind string
+
+	// tlsSettings defines the *custom* TLS settings for the chain. mTLS settings are orthogonal; this
+	// only configures TLS overrides.
+	tlsSettings *networking.ServerTLSSettings
+
+	// passthrough should be set to true for the 'passthrough' chains, which are the chains always
+	// present to handle all unmatched traffic. These have a few naming and quirks that require
+	// different configuration.
+	passthrough bool
+
+	// bindToPort determines if this chain should form a real listener that actually binds to a real port,
+	// or if it should just be a filter chain part of the 'virtual inbound' listener.
+	bindToPort bool
+
+	// telemetryMetadata defines additional information about the chain for telemetry purposes.
+	telemetryMetadata util.TelemetryMetadata
+}
+
+// StatPrefix returns the stat prefix for the config
+func (cc inboundChainConfig) StatPrefix() string {
+	if cc.passthrough {
+		// A bit arbitrary, but for backwards compatibility just use the cluster name
+		return cc.clusterName
+	}
+	return "inbound_" + cc.Name(istionetworking.ListenerProtocolHTTP)
+}
+
+// Name determines the name for this chain
+func (cc inboundChainConfig) Name(protocol istionetworking.ListenerProtocol) string {
+	if cc.passthrough {
+		// A bit arbitrary, but for backwards compatibility fixed names are used
+		// Passthrough chains have fix names based on protocol
+		if protocol == istionetworking.ListenerProtocolHTTP {
+			return model.VirtualInboundCatchAllHTTPFilterChainName
+		}
+		return model.VirtualInboundListenerName
+	}
+	// Everything else derived from bind/port
+	return getListenerName(cc.bind, int(cc.port.TargetPort), istionetworking.TransportProtocolTCP)
+}
+
+var (
+	IPv4PasstrhoughCIDR = []*core.CidrRange{util.ConvertAddressToCidr("0.0.0.0/0")}
+	IPv6PasstrhoughCIDR = []*core.CidrRange{util.ConvertAddressToCidr("::/0")}
+)
+
+// ToFilterChainMatch builds the FilterChainMatch for the config
+func (cc inboundChainConfig) ToFilterChainMatch(opt FilterChainMatchOptions) *listener.FilterChainMatch {
+	match := &listener.FilterChainMatch{}
+	match.ApplicationProtocols = opt.ApplicationProtocols
+	match.TransportProtocol = opt.TransportProtocol
+	if cc.passthrough {
+		// Pasthrough listeners do an IP match - but matching all IPs. This is really an IP *version* match,
+		// but Envoy doesn't explicitly have version check.
+		if cc.clusterName == util.InboundPassthroughClusterIpv4 {
+			match.PrefixRanges = IPv4PasstrhoughCIDR
+		} else {
+			match.PrefixRanges = IPv6PasstrhoughCIDR
+		}
+	}
+	if cc.port.TargetPort > 0 {
+		match.DestinationPort = &wrappers.UInt32Value{Value: cc.port.TargetPort}
+	}
+	return match
+}
+
+// ServiceInstancePort defines a port that has both a port and targetPort (which distinguishes it from model.Port)
+// Note: ServiceInstancePort only makes sense in the context of a specific ServiceInstance, because TargetPort depends on a specific instance.
+type ServiceInstancePort struct {
+	// Name ascribes a human readable name for the port object. When a
+	// service has multiple ports, the name field is mandatory
+	Name string `json:"name,omitempty"`
+
+	// Port number where the service can be reached. Does not necessarily
+	// map to the corresponding port numbers for the instances behind the
+	// service.
+	Port uint32 `json:"port"`
+
+	TargetPort uint32 `json:"targetPort"`
+
+	// Protocol to be used for the port.
+	Protocol protocol.Instance `json:"protocol,omitempty"`
+}
+
+// buildInboundListeners creates inbound listeners.
+// Typically, this a single listener with many filter chains for each applicable Service; traffic is redirect with iptables.
+// However, explicit listeners can be used in NONE mode or with Sidecar.Ingress configuration.
+func (lb *ListenerBuilder) buildInboundListeners() []*listener.Listener {
+	// All listeners we build
+	var listeners []*listener.Listener
+	// virtualInboundFilterChains builds up all of the filter chains for the virtual inbound listener
+	var virtualInboundFilterChains []*listener.FilterChain
+	// For each chain config we will build required filter chain(s)
+	for _, cc := range lb.buildInboundChainConfigs() {
+		// First, construct our set of filter chain matchers. For a given port, we will have multiple matches
+		// to handle mTLS vs plaintext and HTTP vs TCP (depending on protocol and PeerAuthentication).
+		var opts []FilterChainMatchOptions
+		mtls := lb.authnBuilder.ForPort(cc.port.TargetPort)
+		// Chain has explicit user TLS config. This can only apply when the mTLS settings are DISABLE to avoid conflicts
+		if cc.tlsSettings != nil && mtls.Mode == model.MTLSDisable {
+			// Since we are terminating TLS, we need to treat the protocol as if its terminated.
+			// Example: user specifies protocol=HTTPS and user TLS, we will use HTTP
+			cc.port.Protocol = cc.port.Protocol.AfterTLSTermination()
+			lp := istionetworking.ModelProtocolToListenerProtocol(cc.port.Protocol, core.TrafficDirection_INBOUND)
+			opts = getTLSFilterChainMatchOptions(lp)
+			mtls.TCP = BuildListenerTLSContext(cc.tlsSettings, lb.node, istionetworking.TransportProtocolTCP)
+			mtls.HTTP = mtls.TCP
+		} else {
+			lp := istionetworking.ModelProtocolToListenerProtocol(cc.port.Protocol, core.TrafficDirection_INBOUND)
+			opts = getFilterChainMatchOptions(mtls, lp)
+		}
+		// Build the actual chain
+		chains := lb.inboundChainForOpts(cc, mtls, opts)
+
+		if cc.bindToPort {
+			// If this config is for bindToPort, we want to actually create a real Listener.
+			listeners = append(listeners, lb.inboundCustomListener(cc, chains))
+		} else {
+			// Otherwise, just append the filter chain to the virtual inbound chains.
+			virtualInboundFilterChains = append(virtualInboundFilterChains, chains...)
+		}
+	}
+
+	if lb.node.GetInterceptionMode() != model.InterceptionNone {
+		// Prepend virtual inbound, as long as we are using redirection.
+		listeners = append([]*listener.Listener{lb.inboundVirtualListener(virtualInboundFilterChains)}, listeners...)
+	}
+
+	return listeners
+}
+
+// inboundVirtualListener builds the virtual inbound listener.
+func (lb *ListenerBuilder) inboundVirtualListener(chains []*listener.FilterChain) *listener.Listener {
+	actualWildcard, _ := getActualWildcardAndLocalHost(lb.node)
+
+	// Build the "virtual" inbound listener. This will capture all inbound redirected traffic and contains:
+	// * Passthrough filter chains, matching all unmatched traffic. There are a few of these to handle all cases
+	// * Service filter chains. These will either be for each Port exposed by a Service OR Sidecar.Ingress configuration.
+	allChains := buildInboundPassthroughChains(lb)
+	allChains = append(allChains, chains...)
+	return lb.buildInboundListener(model.VirtualInboundListenerName, util.BuildAddress(actualWildcard, ProxyInboundListenPort), false, allChains)
+}
+
+// inboundCustomListener build a custom listener that actually binds to a port, rather than relying on redirection.
+func (lb *ListenerBuilder) inboundCustomListener(cc inboundChainConfig, chains []*listener.FilterChain) *listener.Listener {
+	return lb.buildInboundListener(cc.Name(istionetworking.ListenerProtocolTCP), util.BuildAddress(cc.bind, cc.port.TargetPort), true, chains)
+}
+
+func (lb *ListenerBuilder) buildInboundListener(name string, address *core.Address, bindToPort bool, chains []*listener.FilterChain) *listener.Listener {
+	l := &listener.Listener{
+		Name:             name,
+		Address:          address,
+		TrafficDirection: core.TrafficDirection_INBOUND,
+	}
+	if lb.node.Metadata.InboundListenerExactBalance {
+		l.ConnectionBalanceConfig = &listener.Listener_ConnectionBalanceConfig{
+			BalanceType: &listener.Listener_ConnectionBalanceConfig_ExactBalance_{
+				ExactBalance: &listener.Listener_ConnectionBalanceConfig_ExactBalance{},
+			},
+		}
+	}
+	if !bindToPort && lb.node.GetInterceptionMode() == model.InterceptionTproxy {
+		l.Transparent = proto.BoolTrue
+	}
+
+	accessLogBuilder.setListenerAccessLog(lb.push, lb.node, l, istionetworking.ListenerClassSidecarInbound)
+	l.FilterChains = chains
+	l.ListenerFilters = populateListenerFilters(lb.node, l, bindToPort)
+	l.ListenerFiltersTimeout = getProtocolDetectionTimeout(lb.push.Mesh)
+	l.ContinueOnListenerFiltersTimeout = true
+	return l
+}
+
+// inboundChainForOpts builds a set of filter chains
+func (lb *ListenerBuilder) inboundChainForOpts(cc inboundChainConfig, mtls plugin.MTLSSettings, opts []FilterChainMatchOptions) []*listener.FilterChain {
+	chains := make([]*listener.FilterChain, 0, len(opts))
+	for _, opt := range opts {
+		switch opt.Protocol {
+		// Switch on the protocol. Note: we do not need to handle Auto protocol as it will already be split into a TCP and HTTP option.
+		case istionetworking.ListenerProtocolHTTP:
+			chains = append(chains, &listener.FilterChain{
+				FilterChainMatch: cc.ToFilterChainMatch(opt),
+				Filters:          lb.buildInboundNetworkFiltersForHTTP(cc),
+				TransportSocket:  buildDownstreamTLSTransportSocket(opt.ToTransportSocket(mtls)),
+				Name:             cc.Name(opt.Protocol),
+			})
+		case istionetworking.ListenerProtocolTCP:
+			chains = append(chains, &listener.FilterChain{
+				FilterChainMatch: cc.ToFilterChainMatch(opt),
+				Filters:          lb.buildInboundNetworkFilters(cc),
+				TransportSocket:  buildDownstreamTLSTransportSocket(opt.ToTransportSocket(mtls)),
+				Name:             cc.Name(opt.Protocol),
+			})
+		}
+	}
+	return chains
+}
+
+// buildInboundChainConfigs builds all the application chain configs.
+func (lb *ListenerBuilder) buildInboundChainConfigs() []inboundChainConfig {
+	chainsByPort := make(map[uint32]inboundChainConfig)
+	// No user supplied sidecar scope or the user supplied one has no ingress listeners.
+	if !lb.node.SidecarScope.HasIngressListener() {
+		// We will look at all Services that apply to this proxy and build chains for each distinct port.
+		// Note: this does mean that we may have multiple Services applying to the same port, which introduces a conflict
+		for _, i := range lb.node.ServiceInstances {
+			port := ServiceInstancePort{
+				Name:       i.ServicePort.Name,
+				Port:       uint32(i.ServicePort.Port),
+				TargetPort: i.Endpoint.EndpointPort,
+				Protocol:   i.ServicePort.Protocol,
+			}
+
+			cc := inboundChainConfig{
+				telemetryMetadata: util.TelemetryMetadata{InstanceHostname: i.Service.Hostname},
+				port:              port,
+				clusterName:       model.BuildInboundSubsetKey(int(port.TargetPort)),
+				bind:              "0.0.0.0", // TODO ipv6
+				bindToPort:        getBindToPort(networking.CaptureMode_DEFAULT, lb.node),
+			}
+			if i.Service.Attributes.ServiceRegistry == provider.Kubernetes {
+				cc.telemetryMetadata.KubernetesServiceNamespace = i.Service.Attributes.Namespace
+				cc.telemetryMetadata.KubernetesServiceName = i.Service.Attributes.Name
+			}
+			// First, make sure there is a distinct instance used per port.
+			// The Service is *almost* not relevant, but some Telemetry is per-service.
+			// If there is a conflict, we will use the oldest Service. This impacts the protocol used as well.
+			if old, f := chainsByPort[port.TargetPort]; f {
+				reportInboundConflict(lb, old, cc)
+				continue
+			}
+			chainsByPort[port.TargetPort] = cc
+		}
+	} else {
+		for _, i := range lb.node.SidecarScope.Sidecar.Ingress {
+			port := ServiceInstancePort{
+				Name:       i.Port.Name,
+				Port:       i.Port.Number,
+				TargetPort: i.Port.Number, // No targetPort support in the API
+				Protocol:   protocol.Parse(i.Port.Protocol),
+			}
+			bindtoPort := getBindToPort(i.CaptureMode, lb.node)
+			// Skip ports we cannot bind to
+			if !lb.node.CanBindToPort(bindtoPort, port.TargetPort) {
+				log.Warnf("buildInboundListeners: skipping privileged sidecar port %d for node %s as it is an unprivileged proxy",
+					i.Port.Number, lb.node.ID)
+				continue
+			}
+
+			cc := inboundChainConfig{
+				// Sidecar config doesn't have a real hostname. In order to give some telemetry info, make a synthetic hostname.
+				telemetryMetadata: util.TelemetryMetadata{
+					InstanceHostname: host.Name(lb.node.SidecarScope.Name + "." + lb.node.SidecarScope.Namespace),
+				},
+				port:        port,
+				clusterName: model.BuildInboundSubsetKey(int(port.TargetPort)),
+				bind:        i.Bind,
+				bindToPort:  bindtoPort,
+			}
+			if cc.bind == "" {
+				// If user didn't provide, pick one based on IP
+				cc.bind = getSidecarInboundBindIP(lb.node)
+			}
+			// If there is a conflict, we will use the oldest Service. This impacts the protocol used as well.
+			if old, f := chainsByPort[port.TargetPort]; f {
+				reportInboundConflict(lb, old, cc)
+				continue
+			}
+
+			if i.Tls != nil && features.EnableTLSOnSidecarIngress {
+				// User provided custom TLS settings
+				cc.tlsSettings = i.Tls.DeepCopy()
+				cc.tlsSettings.CipherSuites = filteredSidecarCipherSuites(cc.tlsSettings.CipherSuites)
+				cc.port.Protocol = cc.port.Protocol.AfterTLSTermination()
+			}
+
+			chainsByPort[port.TargetPort] = cc
+		}
+	}
+
+	chainConfigs := make([]inboundChainConfig, 0, len(chainsByPort))
+	for _, cc := range chainsByPort {
+		chainConfigs = append(chainConfigs, cc)
+	}
+	// Give a stable order to the chains
+	sort.Slice(chainConfigs, func(i, j int) bool {
+		return chainConfigs[i].port.TargetPort < chainConfigs[j].port.TargetPort
+	})
+
+	return chainConfigs
+}
+
+// getBindToPort determines whether we should bind to port based on the chain-specific config and the proxy
+func getBindToPort(mode networking.CaptureMode, node *model.Proxy) bool {
+	if mode == networking.CaptureMode_DEFAULT {
+		// Chain doesn't specify explicit config, so use the proxy defaults
+		return node.GetInterceptionMode() == model.InterceptionNone
+	}
+	// Explicitly configured in the config, ignore proxy defaults
+	return mode == networking.CaptureMode_NONE
+}
+
+func getProtocolDetectionTimeout(mesh *meshconfig.MeshConfig) *duration.Duration {
+	timeout := mesh.GetProtocolDetectionTimeout()
+	if features.InboundProtocolDetectionTimeoutSet {
+		timeout = durationpb.New(features.InboundProtocolDetectionTimeout)
+	}
+	return timeout
+}
+
+// populateListenerFilters determines the appropriate listener filters based on the listener
+// HTTP and TLS inspectors are automatically derived based on FilterChainMatch requirements.
+func populateListenerFilters(node *model.Proxy, vi *listener.Listener, bindToPort bool) []*listener.ListenerFilter {
+	lf := make([]*listener.ListenerFilter, 0, 4)
+	if !bindToPort {
+		lf = append(lf, xdsfilters.OriginalDestination)
+	}
+	if !bindToPort && node.GetInterceptionMode() == model.InterceptionTproxy {
+		lf = append(lf, xdsfilters.OriginalSrc)
+	}
+
+	// inspectors builds up a map of port -> required inspectors (TLS/HTTP)
+	inspectors := map[int]enabledInspector{}
+	for _, fc := range vi.FilterChains {
+		port := fc.GetFilterChainMatch().GetDestinationPort().GetValue()
+		needsTLS := fc.GetFilterChainMatch().GetTransportProtocol() == xdsfilters.TLSTransportProtocol
+		needHTTP := false
+		for _, ap := range fc.GetFilterChainMatch().GetApplicationProtocols() {
+			// Check for HTTP protocol - these require HTTP inspector
+			if ap == "http/1.1" || ap == "h2c" {
+				needHTTP = true
+				break
+			}
+		}
+		// Port may already have config; we OR them together. If any filter chain on that port is enabled
+		// we will enable the inspector.
+		i := inspectors[int(port)]
+		i.HTTPInspector = i.HTTPInspector || needHTTP
+		i.TLSInspector = i.TLSInspector || needsTLS
+		inspectors[int(port)] = i
+	}
+
+	// Enable TLS inspector on any ports we need it
+	if needsTLS(inspectors) {
+		lf = append(lf, buildTLSInspector(inspectors))
+	}
+
+	// Note: the HTTP inspector should be after TLS inspector.
+	// If TLS inspector sets transport protocol to tls, the http inspector
+	// won't inspect the packet.
+	if features.EnableProtocolSniffingForInbound && needsHTTP(inspectors) {
+		lf = append(lf, buildHTTPInspector(inspectors))
+	}
+
+	return lf
+}
+
+// listenerPredicateExcludePorts returns a listener filter predicate that will
+// match everything except the passed in ports. This is useful, for example, to
+// enable protocol sniffing on every port except port X and Y, because X and Y
+// are explicitly declared.
+func listenerPredicateExcludePorts(ports []int) *listener.ListenerFilterChainMatchPredicate {
+	ranges := []*listener.ListenerFilterChainMatchPredicate{}
+	for _, p := range ports {
+		ranges = append(ranges, &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_DestinationPortRange{
+			// Range is [start, end)
+			DestinationPortRange: &envoytype.Int32Range{
+				Start: int32(p),
+				End:   int32(p + 1),
+			},
+		}})
+	}
+	if len(ranges) > 1 {
+		return &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_OrMatch{
+			OrMatch: &listener.ListenerFilterChainMatchPredicate_MatchSet{
+				Rules: ranges,
+			},
+		}}
+	}
+	return &listener.ListenerFilterChainMatchPredicate{Rule: ranges[0].GetRule()}
+}
+
+func listenerPredicateIncludePorts(ports []int) *listener.ListenerFilterChainMatchPredicate {
+	rule := listenerPredicateExcludePorts(ports)
+	return &listener.ListenerFilterChainMatchPredicate{Rule: &listener.ListenerFilterChainMatchPredicate_NotMatch{
+		NotMatch: rule,
+	}}
+}
+
+func needsTLS(inspectors map[int]enabledInspector) bool {
+	for _, i := range inspectors {
+		if i.TLSInspector {
+			return true
+		}
+	}
+	return false
+}
+
+func needsHTTP(inspectors map[int]enabledInspector) bool {
+	for _, i := range inspectors {
+		if i.HTTPInspector {
+			return true
+		}
+	}
+	return false
+}
+
+// buildTLSInspector creates a tls inspector filter. Based on the configured ports, this may be enabled
+// for only some ports.
+func buildTLSInspector(inspectors map[int]enabledInspector) *listener.ListenerFilter {
+	// TODO share logic with HTTP inspector
+	defaultEnabled := inspectors[0].TLSInspector
+
+	// We have a split path here based on if the passthrough inspector is enabled
+	// If it is, then we need to explicitly opt ports out of the inspector
+	// If it isn't, then we need to explicitly opt ports into the inspector
+	if defaultEnabled {
+		ports := make([]int, 0, len(inspectors))
+		// Collect all ports where TLS inspector is disabled.
+		for p, i := range inspectors {
+			if p == 0 {
+				continue
+			}
+			if !i.TLSInspector {
+				ports = append(ports, p)
+			}
+		}
+		// No need to filter, return the cached version enabled for all ports
+		if len(ports) == 0 {
+			return xdsfilters.TLSInspector
+		}
+		// Ensure consistent ordering as we are looping over a map
+		sort.Ints(ports)
+		filter := &listener.ListenerFilter{
+			Name:           wellknown.TlsInspector,
+			ConfigType:     xdsfilters.TLSInspector.ConfigType,
+			FilterDisabled: listenerPredicateExcludePorts(ports),
+		}
+		return filter
+	}
+	ports := make([]int, 0, len(inspectors))
+	// Collect all ports where TLS inspector is disabled.
+	for p, i := range inspectors {
+		if p == 0 {
+			continue
+		}
+		if i.TLSInspector {
+			ports = append(ports, p)
+		}
+	}
+	// No need to filter, return the cached version enabled for all ports
+	if len(ports) == 0 {
+		return xdsfilters.TLSInspector
+	}
+	// Ensure consistent ordering as we are looping over a map
+	sort.Ints(ports)
+	filter := &listener.ListenerFilter{
+		Name:       wellknown.TlsInspector,
+		ConfigType: xdsfilters.TLSInspector.ConfigType,
+		// Exclude all disabled ports
+		FilterDisabled: listenerPredicateIncludePorts(ports),
+	}
+	return filter
+}
+
+// buildHTTPInspector creates an http inspector filter. Based on the configured ports, this may be enabled
+// for only some ports.
+func buildHTTPInspector(inspectors map[int]enabledInspector) *listener.ListenerFilter {
+	ports := make([]int, 0, len(inspectors))
+	// Collect all ports where HTTP inspector is disabled.
+	for p, i := range inspectors {
+		if !i.HTTPInspector {
+			ports = append(ports, p)
+		}
+	}
+	// No need to filter, return the cached version enabled for all ports
+	if len(ports) == 0 {
+		return xdsfilters.HTTPInspector
+	}
+	// Ensure consistent ordering as we are looping over a map
+	sort.Ints(ports)
+	filter := &listener.ListenerFilter{
+		Name:       wellknown.HttpInspector,
+		ConfigType: xdsfilters.HTTPInspector.ConfigType,
+		// Exclude all disabled ports
+		FilterDisabled: listenerPredicateExcludePorts(ports),
+	}
+	return filter
+}
+
+func reportInboundConflict(lb *ListenerBuilder, old inboundChainConfig, cc inboundChainConfig) {
+	// If the protocols and service do not match, we have a real conflict. For example, one Service may
+	// define TCP and the other HTTP. Report this up to the user.
+	if old.port.Protocol != cc.port.Protocol && old.telemetryMetadata.InstanceHostname != cc.telemetryMetadata.InstanceHostname {
+		lb.push.AddMetric(model.ProxyStatusConflictInboundListener, lb.node.ID, lb.node.ID,
+			fmt.Sprintf("Conflicting inbound listener:%d. existing: %s, incoming: %s", cc.port.TargetPort,
+				old.telemetryMetadata.InstanceHostname, cc.telemetryMetadata.InstanceHostname))
+		return
+	}
+	// This can happen if two services select the same pod with same port and protocol - we should skip
+	// building listener again, but no need to report to the user
+	if old.telemetryMetadata.InstanceHostname != cc.telemetryMetadata.InstanceHostname {
+		log.Debugf("skipping inbound listener:%d as we have already build it for existing host: %s, new host: %s",
+			cc.port.TargetPort,
+			old.telemetryMetadata.InstanceHostname, cc.telemetryMetadata.InstanceHostname)
+	}
+}
+
+// buildInboundPassthroughChains builds the passthrough chains. These match any unmatched traffic.
+// This allows traffic to ports not exposed by any Service, for example.
+func buildInboundPassthroughChains(lb *ListenerBuilder) []*listener.FilterChain {
+	// ipv4 and ipv6 feature detect
+	ipVersions := make([]string, 0, 2)
+	if lb.node.SupportsIPv4() {
+		ipVersions = append(ipVersions, util.InboundPassthroughClusterIpv4)
+	}
+	if lb.node.SupportsIPv6() {
+		ipVersions = append(ipVersions, util.InboundPassthroughClusterIpv6)
+	}
+
+	// Setup enough slots for common max size (permissive mode is 5 filter chains). This is not
+	// exact, just best effort optimization
+	filterChains := make([]*listener.FilterChain, 0, 1+5*len(ipVersions))
+	filterChains = append(filterChains, buildInboundBlackhole(lb))
+
+	for _, clusterName := range ipVersions {
+		mtlsOptions := lb.authnBuilder.ForPassthrough()
+		for _, mtls := range mtlsOptions {
+			cc := inboundChainConfig{
+				port: ServiceInstancePort{
+					Name: model.VirtualInboundListenerName,
+					// Port as 0 doesn't completely make sense here, since we get weird tracing decorators like `:0/*`,
+					// but this is backwards compatible and there aren't any perfect options.
+					Port:       0,
+					Protocol:   protocol.Unsupported,
+					TargetPort: mtls.Port,
+				},
+				clusterName: clusterName,
+				passthrough: true,
+			}
+			opts := getFilterChainMatchOptions(mtls, istionetworking.ListenerProtocolAuto)
+			filterChains = append(filterChains, lb.inboundChainForOpts(cc, mtls, opts)...)
+		}
+	}
+
+	return filterChains
+}
+
+// buildInboundBlackhole builds a special filter chain for the virtual inbound matching traffic to the port the listener is actually on.
+// This avoids a possible loop where traffic sent to this port would continually call itself indefinitely.
+func buildInboundBlackhole(lb *ListenerBuilder) *listener.FilterChain {
+	var filters []*listener.Filter
+	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, buildMetricsNetworkFilters(lb.push, lb.node, istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, &listener.Filter{
+		Name: wellknown.TCPProxy,
+		ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(&tcp.TcpProxy{
+			StatPrefix:       util.BlackHoleCluster,
+			ClusterSpecifier: &tcp.TcpProxy_Cluster{Cluster: util.BlackHoleCluster},
+		})},
+	})
+	return &listener.FilterChain{
+		Name: model.VirtualInboundBlackholeFilterChainName,
+		FilterChainMatch: &listener.FilterChainMatch{
+			DestinationPort: &wrappers.UInt32Value{Value: ProxyInboundListenPort},
+		},
+		Filters: filters,
+	}
+}
+
+// buildSidecarInboundHTTPOpts sets up HTTP options for a given chain.
+func buildSidecarInboundHTTPOpts(lb *ListenerBuilder, cc inboundChainConfig) *httpListenerOpts {
+	httpOpts := &httpListenerOpts{
+		routeConfig:      buildSidecarInboundHTTPRouteConfig(lb, cc),
+		rds:              "", // no RDS for inbound traffic
+		useRemoteAddress: false,
+		connectionManager: &hcm.HttpConnectionManager{
+			// Append and forward client cert to backend.
+			ForwardClientCertDetails: hcm.HttpConnectionManager_APPEND_FORWARD,
+			SetCurrentClientCertDetails: &hcm.HttpConnectionManager_SetCurrentClientCertDetails{
+				Subject: proto.BoolTrue,
+				Uri:     true,
+				Dns:     true,
+			},
+			ServerName: EnvoyServerName,
+		},
+		protocol:   cc.port.Protocol,
+		class:      istionetworking.ListenerClassSidecarInbound,
+		statPrefix: cc.StatPrefix(),
+	}
+	// See https://github.com/grpc/grpc-web/tree/master/net/grpc/gateway/examples/helloworld#configure-the-proxy
+	if cc.port.Protocol.IsHTTP2() {
+		httpOpts.connectionManager.Http2ProtocolOptions = &core.Http2ProtocolOptions{}
+	}
+
+	if features.HTTP10 || enableHTTP10(lb.node.Metadata.HTTP10) {
+		httpOpts.connectionManager.HttpProtocolOptions = &core.Http1ProtocolOptions{
+			AcceptHttp_10: true,
+		}
+	}
+
+	return httpOpts
+}
+
+// buildInboundNetworkFiltersForHTTP builds the network filters that should be inserted before an HCM.
+// This should only be used with HTTP; see buildInboundNetworkFilters for TCP
+func (lb *ListenerBuilder) buildInboundNetworkFiltersForHTTP(cc inboundChainConfig) []*listener.Filter {
+	var filters []*listener.Filter
+	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
+
+	httpOpts := buildSidecarInboundHTTPOpts(lb, cc)
+	hcm := lb.buildHTTPConnectionManager(httpOpts)
+	filters = append(filters, &listener.Filter{
+		Name:       wellknown.HTTPConnectionManager,
+		ConfigType: &listener.Filter_TypedConfig{TypedConfig: util.MessageToAny(hcm)},
+	})
+	return filters
+}
+
+// buildInboundNetworkFilters generates a TCP proxy network filter on the inbound path
+func (lb *ListenerBuilder) buildInboundNetworkFilters(fcc inboundChainConfig) []*listener.Filter {
+	statPrefix := fcc.clusterName
+	// If stat name is configured, build the stat prefix from configured pattern.
+	if len(lb.push.Mesh.InboundClusterStatName) != 0 {
+		statPrefix = util.BuildInboundStatPrefix(lb.push.Mesh.InboundClusterStatName, fcc.telemetryMetadata, "", fcc.port.Port, fcc.port.Name)
+	}
+	tcpProxy := &tcp.TcpProxy{
+		StatPrefix:       statPrefix,
+		ClusterSpecifier: &tcp.TcpProxy_Cluster{Cluster: fcc.clusterName},
+	}
+	idleTimeout, err := time.ParseDuration(lb.node.Metadata.IdleTimeout)
+	if err == nil {
+		tcpProxy.IdleTimeout = durationpb.New(idleTimeout)
+	}
+	tcpFilter := setAccessLogAndBuildTCPFilter(lb.push, lb.node, tcpProxy, istionetworking.ListenerClassSidecarInbound)
+
+	var filters []*listener.Filter
+	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, lb.authzCustomBuilder.BuildTCP()...)
+	filters = append(filters, lb.authzBuilder.BuildTCP()...)
+	filters = append(filters, buildMetricsNetworkFilters(lb.push, lb.node, istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, buildNetworkFiltersStack(fcc.port.Protocol, tcpFilter, statPrefix, fcc.clusterName)...)
+
+	return filters
+}
diff --git a/pilot/pkg/networking/core/v1alpha3/networkfilter.go b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
index a040452ecc..3ac7c2638e 100644
--- a/pilot/pkg/networking/core/v1alpha3/networkfilter.go
+++ b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
@@ -55,31 +55,6 @@ func buildMetricsNetworkFilters(push *model.PushContext, proxy *model.Proxy, cla
 	return push.Telemetry.TCPFilters(proxy, class)
 }
 
-// buildInboundNetworkFilters generates a TCP proxy network filter on the inbound path
-func buildInboundNetworkFilters(push *model.PushContext, proxy *model.Proxy, instance *model.ServiceInstance, clusterName string) []*listener.Filter {
-	statPrefix := clusterName
-	// If stat name is configured, build the stat prefix from configured pattern.
-	if len(push.Mesh.InboundClusterStatName) != 0 {
-		statPrefix = util.BuildStatPrefix(push.Mesh.InboundClusterStatName,
-			string(instance.Service.Hostname), "", instance.ServicePort, &instance.Service.Attributes)
-	}
-	tcpProxy := &tcp.TcpProxy{
-		StatPrefix:       statPrefix,
-		ClusterSpecifier: &tcp.TcpProxy_Cluster{Cluster: clusterName},
-	}
-	idleTimeout, err := time.ParseDuration(proxy.Metadata.IdleTimeout)
-	if err == nil {
-		tcpProxy.IdleTimeout = durationpb.New(idleTimeout)
-	}
-	tcpFilter := setAccessLogAndBuildTCPFilter(push, proxy, tcpProxy, istionetworking.ListenerClassSidecarInbound)
-
-	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
-	filters = append(filters, buildMetricsNetworkFilters(push, proxy, istionetworking.ListenerClassSidecarInbound)...)
-	filters = append(filters, buildNetworkFiltersStack(instance.ServicePort, tcpFilter, statPrefix, clusterName)...)
-	return filters
-}
-
 // setAccessLogAndBuildTCPFilter sets the AccessLog configuration in the given
 // TcpProxy instance and builds a TCP filter out of it.
 func setAccessLogAndBuildTCPFilter(push *model.PushContext, node *model.Proxy, config *tcp.TcpProxy, class istionetworking.ListenerClass) *listener.Filter {
@@ -112,7 +87,7 @@ func buildOutboundNetworkFiltersWithSingleDestination(push *model.PushContext, n
 	var filters []*listener.Filter
 	filters = append(filters, buildMetadataExchangeNetworkFilters(class)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, class)...)
-	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
+	filters = append(filters, buildNetworkFiltersStack(port.Protocol, tcpFilter, statPrefix, clusterName)...)
 	return filters
 }
 
@@ -157,7 +132,7 @@ func buildOutboundNetworkFiltersWithWeightedClusters(node *model.Proxy, routes [
 	var filters []*listener.Filter
 	filters = append(filters, buildMetadataExchangeNetworkFilters(class)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, class)...)
-	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
+	filters = append(filters, buildNetworkFiltersStack(port.Protocol, tcpFilter, statPrefix, clusterName)...)
 	return filters
 }
 
@@ -190,9 +165,9 @@ func maybeSetHashPolicy(destinationRule *networking.DestinationRule, tcpProxy *t
 
 // buildNetworkFiltersStack builds a slice of network filters based on
 // the protocol in use and the given TCP filter instance.
-func buildNetworkFiltersStack(port *model.Port, tcpFilter *listener.Filter, statPrefix string, clusterName string) []*listener.Filter {
+func buildNetworkFiltersStack(p protocol.Instance, tcpFilter *listener.Filter, statPrefix string, clusterName string) []*listener.Filter {
 	filterstack := make([]*listener.Filter, 0)
-	switch port.Protocol {
+	switch p {
 	case protocol.Mongo:
 		if features.EnableMongoFilter {
 			filterstack = append(filterstack, buildMongoFilter(statPrefix), tcpFilter)
@@ -284,7 +259,7 @@ func buildRedisFilter(statPrefix, clusterName string) *listener.Filter {
 		LatencyInMicros: true,       // redis latency stats are captured in micro seconds which is typically the case.
 		StatPrefix:      statPrefix, // redis stats are prefixed with redis.<statPrefix> by Envoy
 		Settings: &redis.RedisProxy_ConnPoolSettings{
-			OpTimeout: durationpb.New(redisOpTimeout), // TODO: Make this user configurable
+			OpTimeout: durationpb.New(redisOpTimeout),
 		},
 		PrefixRoutes: &redis.RedisProxy_PrefixRoutes{
 			CatchAllRoute: &redis.RedisProxy_PrefixRoutes_Route{
diff --git a/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go b/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
index 8f63aa2905..580a568e0a 100644
--- a/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/networkfilter_test.go
@@ -27,6 +27,7 @@
 
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/config/protocol"
@@ -88,26 +89,12 @@ func TestInboundNetworkFilterStatPrefix(t *testing.T) {
 				MeshConfig: m,
 			})
 
-			instance := &model.ServiceInstance{
-				Service: &model.Service{
-					Hostname:       "v0.default.example.org",
-					DefaultAddress: "9.9.9.9",
-					CreationTime:   tnow,
-					Attributes: model.ServiceAttributes{
-						Namespace: "not-default",
-					},
-				},
-				ServicePort: &model.Port{
-					Port: 9999,
-					Name: "http",
-				},
-				Endpoint: &model.IstioEndpoint{
-					EndpointPort: 8888,
-				},
+			fcc := inboundChainConfig{
+				telemetryMetadata: util.TelemetryMetadata{InstanceHostname: "v0.default.example.org"},
+				clusterName:       "inbound|8888||",
 			}
 
-			listenerFilters := buildInboundNetworkFilters(cg.PushContext(), cg.SetupProxy(nil),
-				instance, model.BuildInboundSubsetKey(int(instance.Endpoint.EndpointPort)))
+			listenerFilters := NewListenerBuilder(cg.SetupProxy(nil), cg.PushContext()).buildInboundNetworkFilters(fcc)
 			tcp := &tcp.TcpProxy{}
 			listenerFilters[len(listenerFilters)-1].GetTypedConfig().UnmarshalTo(tcp)
 			if tcp.StatPrefix != tt.expectedStatPrefix {
@@ -148,26 +135,9 @@ func TestInboundNetworkFilterIdleTimeout(t *testing.T) {
 		t.Run(tt.name, func(t *testing.T) {
 			cg := NewConfigGenTest(t, TestOptions{Services: services})
 
-			instance := &model.ServiceInstance{
-				Service: &model.Service{
-					Hostname:       "v0.default.example.org",
-					DefaultAddress: "9.9.9.9",
-					CreationTime:   tnow,
-					Attributes: model.ServiceAttributes{
-						Namespace: "not-default",
-					},
-				},
-				ServicePort: &model.Port{
-					Port: 9999,
-					Name: "http",
-				},
-				Endpoint: &model.IstioEndpoint{
-					EndpointPort: 8888,
-				},
-			}
+			fcc := inboundChainConfig{}
 			node := &model.Proxy{Metadata: &model.NodeMetadata{IdleTimeout: tt.idleTimeout}}
-			listenerFilters := buildInboundNetworkFilters(cg.PushContext(), node,
-				instance, model.BuildInboundSubsetKey(int(instance.Endpoint.EndpointPort)))
+			listenerFilters := NewListenerBuilder(cg.SetupProxy(node), cg.PushContext()).buildInboundNetworkFilters(fcc)
 			tcp := &tcp.TcpProxy{}
 			listenerFilters[len(listenerFilters)-1].GetTypedConfig().UnmarshalTo(tcp)
 			if !reflect.DeepEqual(tcp.IdleTimeout, tt.expected) {
diff --git a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
index 0ffcecde3e..5d05b5ee10 100644
--- a/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/sidecar_simulation_test.go
@@ -480,9 +480,8 @@ func extractClusterMetadataServices(t test.Failer, c *cluster.Cluster) []string
 	return res
 }
 
-func TestInbound(t *testing.T) {
-	mtlsMode := func(m string) string {
-		return fmt.Sprintf(`apiVersion: security.istio.io/v1beta1
+func mtlsMode(m string) string {
+	return fmt.Sprintf(`apiVersion: security.istio.io/v1beta1
 kind: PeerAuthentication
 metadata:
   name: default
@@ -491,7 +490,9 @@ func TestInbound(t *testing.T) {
   mtls:
     mode: %s
 `, m)
-	}
+}
+
+func TestInbound(t *testing.T) {
 	svc := `
 apiVersion: networking.istio.io/v1alpha3
 kind: ServiceEntry
@@ -1383,7 +1384,11 @@ func TestInboundSidecarTLSModes(t *testing.T) {
 	}
 	expectedTLSContext := func(filterChain *listener.FilterChain) error {
 		tlsContext := &tls.DownstreamTlsContext{}
-		if err := filterChain.GetTransportSocket().GetTypedConfig().UnmarshalTo(tlsContext); err != nil {
+		ts := filterChain.GetTransportSocket().GetTypedConfig()
+		if ts == nil {
+			return fmt.Errorf("expected transport socket for chain %v", filterChain.GetName())
+		}
+		if err := ts.UnmarshalTo(tlsContext); err != nil {
 			return err
 		}
 		commonTLSContext := tlsContext.CommonTlsContext
diff --git a/pilot/pkg/networking/core/v1alpha3/tracing.go b/pilot/pkg/networking/core/v1alpha3/tracing.go
index 30257422ed..1ab44fadbf 100644
--- a/pilot/pkg/networking/core/v1alpha3/tracing.go
+++ b/pilot/pkg/networking/core/v1alpha3/tracing.go
@@ -47,16 +47,25 @@
 // this is used for testing. it should not be changed in regular code.
 var clusterLookupFn = extensionproviders.LookupCluster
 
-func configureTracing(opts buildListenerOpts, hcm *hpb.HttpConnectionManager) (*xdsfilters.RouterFilterContext,
-	*requestidextension.UUIDRequestIDExtensionContext) {
-	tracing := opts.push.Telemetry.Tracing(opts.proxy)
-	return configureTracingFromSpec(tracing, opts, hcm)
+func configureTracing(
+	push *model.PushContext,
+	proxy *model.Proxy,
+	hcm *hpb.HttpConnectionManager,
+	class networking.ListenerClass,
+) (*xdsfilters.RouterFilterContext, *requestidextension.UUIDRequestIDExtensionContext) {
+	tracing := push.Telemetry.Tracing(proxy)
+	return configureTracingFromSpec(tracing, push, proxy, hcm, class)
 }
 
-func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOpts, hcm *hpb.HttpConnectionManager) (*xdsfilters.RouterFilterContext,
-	*requestidextension.UUIDRequestIDExtensionContext) {
-	meshCfg := opts.push.Mesh
-	proxyCfg := opts.proxy.Metadata.ProxyConfigOrDefault(opts.push.Mesh.DefaultConfig)
+func configureTracingFromSpec(
+	tracing *model.TracingConfig,
+	push *model.PushContext,
+	proxy *model.Proxy,
+	hcm *hpb.HttpConnectionManager,
+	class networking.ListenerClass,
+) (*xdsfilters.RouterFilterContext, *requestidextension.UUIDRequestIDExtensionContext) {
+	meshCfg := push.Mesh
+	proxyCfg := proxy.Metadata.ProxyConfigOrDefault(push.Mesh.DefaultConfig)
 
 	if tracing == nil {
 		// No Telemetry config for tracing, fallback to legacy mesh config
@@ -67,7 +76,7 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 		// use the prior configuration bits of sampling and custom tags
 		hcm.Tracing = &hpb.HttpConnectionManager_Tracing{}
 		configureSampling(hcm.Tracing, proxyConfigSamplingValue(proxyCfg))
-		configureCustomTags(hcm.Tracing, map[string]*telemetrypb.Tracing_CustomTag{}, proxyCfg, opts.proxy.Metadata)
+		configureCustomTags(hcm.Tracing, map[string]*telemetrypb.Tracing_CustomTag{}, proxyCfg, proxy.Metadata)
 		if proxyCfg.GetTracing().GetMaxPathTagLength() != 0 {
 			hcm.Tracing.MaxPathTagLength = wrapperspb.UInt32(proxyCfg.GetTracing().MaxPathTagLength)
 		}
@@ -75,7 +84,7 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 	}
 
 	spec := tracing.ServerSpec
-	if opts.class == networking.ListenerClassSidecarOutbound || opts.class == networking.ListenerClassGateway {
+	if class == networking.ListenerClassSidecarOutbound || class == networking.ListenerClassGateway {
 		spec = tracing.ClientSpec
 	}
 
@@ -85,7 +94,7 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 
 	var routerFilterCtx *xdsfilters.RouterFilterContext
 	if spec.Provider != nil {
-		tcfg, rfCtx, err := configureFromProviderConfig(opts.push, opts.proxy.Metadata, spec.Provider)
+		tcfg, rfCtx, err := configureFromProviderConfig(push, proxy.Metadata, spec.Provider)
 		if err != nil {
 			log.Warnf("Not able to configure requested tracing provider %q: %v", spec.Provider.Name, err)
 			return nil, nil
@@ -103,7 +112,7 @@ func configureTracingFromSpec(tracing *model.TracingConfig, opts buildListenerOp
 	// gracefully fallback to MeshConfig configuration. It will act as an implicit
 	// parent configuration during transition period.
 	configureSampling(hcm.Tracing, spec.RandomSamplingPercentage)
-	configureCustomTags(hcm.Tracing, spec.CustomTags, proxyCfg, opts.proxy.Metadata)
+	configureCustomTags(hcm.Tracing, spec.CustomTags, proxyCfg, proxy.Metadata)
 
 	// if there is configured max tag length somewhere, fallback to it.
 	if hcm.GetTracing().GetMaxPathTagLength() == nil && proxyCfg.GetTracing().GetMaxPathTagLength() != 0 {
diff --git a/pilot/pkg/networking/core/v1alpha3/tracing_test.go b/pilot/pkg/networking/core/v1alpha3/tracing_test.go
index b678847357..49eeb9820b 100644
--- a/pilot/pkg/networking/core/v1alpha3/tracing_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/tracing_test.go
@@ -158,7 +158,7 @@ func TestConfigureTracing(t *testing.T) {
 	for _, tc := range testcases {
 		t.Run(tc.name, func(t *testing.T) {
 			hcm := &hpb.HttpConnectionManager{}
-			gotRfCtx, gotReqIDExtCtx := configureTracingFromSpec(tc.inSpec, tc.opts, hcm)
+			gotRfCtx, gotReqIDExtCtx := configureTracingFromSpec(tc.inSpec, tc.opts.push, tc.opts.proxy, hcm, 0)
 			if diff := cmp.Diff(tc.want, hcm.Tracing, protocmp.Transform()); diff != "" {
 				t.Fatalf("configureTracing returned unexpected diff (-want +got):\n%s", diff)
 			}
diff --git a/pilot/pkg/networking/util/util.go b/pilot/pkg/networking/util/util.go
index 97260bbbfd..3d5c125e74 100644
--- a/pilot/pkg/networking/util/util.go
+++ b/pilot/pkg/networking/util/util.go
@@ -42,6 +42,7 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pkg/cluster"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/network"
 	"istio.io/istio/pkg/proto/merge"
@@ -562,6 +563,16 @@ func BuildStatPrefix(statPattern string, host string, subset string, port *model
 	return prefix
 }
 
+// BuildInboundStatPrefix builds a stat prefix based on the stat pattern.
+func BuildInboundStatPrefix(statPattern string, tm TelemetryMetadata, subset string, port uint32, portName string) string {
+	prefix := strings.ReplaceAll(statPattern, serviceStatPattern, tm.ShortHostname())
+	prefix = strings.ReplaceAll(prefix, serviceFQDNStatPattern, tm.InstanceHostname.String())
+	prefix = strings.ReplaceAll(prefix, subsetNameStatPattern, subset)
+	prefix = strings.ReplaceAll(prefix, servicePortStatPattern, strconv.Itoa(int(port)))
+	prefix = strings.ReplaceAll(prefix, servicePortNameStatPattern, portName)
+	return prefix
+}
+
 // shortHostName constructs the name from kubernetes hosts based on attributes (name and namespace).
 // For other hosts like VMs, this method does not do any thing - just returns the passed in host as is.
 func shortHostName(host string, attributes *model.ServiceAttributes) string {
@@ -726,3 +737,26 @@ func TraceOperation(host string, port int) string {
 	// Format : "%s:%d/*"
 	return DomainName(host, port) + "/*"
 }
+
+// TelemetryMetadata defines additional filter chain metadata for telemetry use
+type TelemetryMetadata struct {
+	// InstanceHostname defines the hostname of the service this filter chain is built for.
+	// Note: This is best effort; this may be empty if generated by Sidecar config, and there may be multiple
+	// Services that make up the filter chain.
+	InstanceHostname host.Name
+	// KubernetesServiceNamespace is the namespace the service is defined in, if it is for a Kubernetes Service.
+	// Note: This is best effort; this may be empty if generated by Sidecar config, and there may be multiple
+	// Services that make up the filter chain.
+	KubernetesServiceNamespace string
+	// KubernetesServiceName is the name of service, if it is for a Kubernetes Service.
+	// Note: This is best effort; this may be empty if generated by Sidecar config, and there may be multiple
+	// Services that make up the filter chain.
+	KubernetesServiceName string
+}
+
+func (tm TelemetryMetadata) ShortHostname() string {
+	if tm.KubernetesServiceName != "" {
+		return tm.KubernetesServiceName + "." + tm.KubernetesServiceNamespace
+	}
+	return tm.InstanceHostname.String()
+}
diff --git a/pilot/pkg/simulation/traffic.go b/pilot/pkg/simulation/traffic.go
index 2e6ffa0950..e62a290db6 100644
--- a/pilot/pkg/simulation/traffic.go
+++ b/pilot/pkg/simulation/traffic.go
@@ -40,8 +40,11 @@
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/util/sets"
+	istiolog "istio.io/pkg/log"
 )
 
+var log = istiolog.RegisterScope("simulation", "", 0)
+
 type Protocol string
 
 const (
@@ -172,6 +175,7 @@ type Result struct {
 }
 
 func (r Result) Matches(t *testing.T, want Result) {
+	t.Helper()
 	r.StrictMatch = want.StrictMatch // to make diff pass
 	r.Skip = want.Skip               // to make diff pass
 	diff := cmp.Diff(want, r, cmpopts.IgnoreUnexported(Result{}), cmpopts.EquateErrors())
@@ -184,24 +188,39 @@ func (r Result) Matches(t *testing.T, want Result) {
 	}
 	if want.ListenerMatched != "" && want.ListenerMatched != r.ListenerMatched {
 		t.Errorf("want listener matched %q got %q", want.ListenerMatched, r.ListenerMatched)
+	} else {
+		// Populate each field in case we did not care about it. This avoids confusing errors when we have fields
+		// we don't care about in the test that are present in the result.
+		want.ListenerMatched = r.ListenerMatched
 	}
 	if want.FilterChainMatched != "" && want.FilterChainMatched != r.FilterChainMatched {
 		t.Errorf("want filter chain matched %q got %q", want.FilterChainMatched, r.FilterChainMatched)
+	} else {
+		want.FilterChainMatched = r.FilterChainMatched
 	}
 	if want.RouteMatched != "" && want.RouteMatched != r.RouteMatched {
 		t.Errorf("want route matched %q got %q", want.RouteMatched, r.RouteMatched)
+	} else {
+		want.RouteMatched = r.RouteMatched
 	}
 	if want.RouteConfigMatched != "" && want.RouteConfigMatched != r.RouteConfigMatched {
 		t.Errorf("want route config matched %q got %q", want.RouteConfigMatched, r.RouteConfigMatched)
+	} else {
+		want.RouteConfigMatched = r.RouteConfigMatched
 	}
 	if want.VirtualHostMatched != "" && want.VirtualHostMatched != r.VirtualHostMatched {
 		t.Errorf("want virtual host matched %q got %q", want.VirtualHostMatched, r.VirtualHostMatched)
+	} else {
+		want.VirtualHostMatched = r.VirtualHostMatched
 	}
 	if want.ClusterMatched != "" && want.ClusterMatched != r.ClusterMatched {
 		t.Errorf("want cluster matched %q got %q", want.ClusterMatched, r.ClusterMatched)
+	} else {
+		want.ClusterMatched = r.ClusterMatched
 	}
 	if t.Failed() {
 		t.Logf("Diff: %+v", diff)
+		t.Logf("Full Diff: %+v", cmp.Diff(want, r, cmpopts.IgnoreUnexported(Result{}), cmpopts.EquateErrors()))
 	} else if want.Skip != "" {
 		t.Skip(fmt.Sprintf("Known bug: %v", r.Skip))
 	}
@@ -482,12 +501,12 @@ func (sim *Simulation) matchVirtualHost(rc *route.RouteConfiguration, host strin
 // matches one criteria but not another.
 func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultChain *listener.FilterChain,
 	input Call, hasTLSInspector bool) (*listener.FilterChain, error) {
-	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
+	chains = filter("DestinationPort", chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetDestinationPort() == nil
 	}, func(fc *listener.FilterChainMatch) bool {
 		return int(fc.GetDestinationPort().GetValue()) == input.Port
 	})
-	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
+	chains = filter("PrefixRanges", chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetPrefixRanges() == nil
 	}, func(fc *listener.FilterChainMatch) bool {
 		ranger := cidranger.NewPCTrieRanger()
@@ -507,7 +526,7 @@ func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultC
 		}
 		return f
 	})
-	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
+	chains = filter("ServerNames", chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetServerNames() == nil
 	}, func(fc *listener.FilterChainMatch) bool {
 		sni := host.Name(input.Sni)
@@ -518,7 +537,7 @@ func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultC
 		}
 		return false
 	})
-	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
+	chains = filter("TransportProtocol", chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetTransportProtocol() == ""
 	}, func(fc *listener.FilterChainMatch) bool {
 		if !hasTLSInspector {
@@ -533,13 +552,16 @@ func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultC
 		}
 		return false
 	})
-	chains = filter(chains, func(fc *listener.FilterChainMatch) bool {
+	chains = filter("ApplicationProtocols", chains, func(fc *listener.FilterChainMatch) bool {
 		return fc.GetApplicationProtocols() == nil
 	}, func(fc *listener.FilterChainMatch) bool {
 		return sets.New(fc.GetApplicationProtocols()...).Contains(input.Alpn)
 	})
 	// We do not implement the "source" based filters as we do not use them
 	if len(chains) > 1 {
+		for _, c := range chains {
+			log.Warnf("Matched chain %v", c.Name)
+		}
 		return nil, ErrMultipleFilterChain
 	}
 	if len(chains) == 0 {
@@ -551,7 +573,7 @@ func (sim *Simulation) matchFilterChain(chains []*listener.FilterChain, defaultC
 	return chains[0], nil
 }
 
-func filter(chains []*listener.FilterChain,
+func filter(desc string, chains []*listener.FilterChain,
 	empty func(fc *listener.FilterChainMatch) bool,
 	match func(fc *listener.FilterChainMatch) bool) []*listener.FilterChain {
 	res := []*listener.FilterChain{}
@@ -563,10 +585,12 @@ func filter(chains []*listener.FilterChain,
 		}
 	}
 	if !anySet {
+		log.Debugf("%v: none set, skipping", desc)
 		return chains
 	}
-	for _, c := range chains {
+	for i, c := range chains {
 		if match(c.GetFilterChainMatch()) {
+			log.Debugf("%v: matched chain %v/%v", desc, i, c.GetName())
 			res = append(res, c)
 		}
 	}
@@ -576,8 +600,9 @@ func filter(chains []*listener.FilterChain,
 	}
 	// Unless there were no matches - in which case we return all filter chains that did not have a
 	// match set
-	for _, c := range chains {
+	for i, c := range chains {
 		if empty(c.GetFilterChainMatch()) {
+			log.Debugf("%v: no matches, found empty chain match %v/%v", desc, i, c.GetName())
 			res = append(res, c)
 		}
 	}
diff --git a/pilot/test/xdstest/test.go b/pilot/test/xdstest/test.go
index defeb78275..f6df8bb692 100644
--- a/pilot/test/xdstest/test.go
+++ b/pilot/test/xdstest/test.go
@@ -22,7 +22,7 @@
 // This is exposed for testing only, and should not be used in XDS generation code
 func EvaluateListenerFilterPredicates(predicate *listener.ListenerFilterChainMatchPredicate, port int) bool {
 	if predicate == nil {
-		return false
+		return true
 	}
 	switch r := predicate.Rule.(type) {
 	case *listener.ListenerFilterChainMatchPredicate_NotMatch:
diff --git a/pkg/config/protocol/instance.go b/pkg/config/protocol/instance.go
index 94ae9dde8e..276f0864b8 100644
--- a/pkg/config/protocol/instance.go
+++ b/pkg/config/protocol/instance.go
@@ -153,3 +153,15 @@ func (i Instance) IsGRPC() bool {
 func (i Instance) IsUnsupported() bool {
 	return i == Unsupported
 }
+
+// AfterTLSTermination returns the protocol that will be used if TLS is terminated on the current protocol.
+func (i Instance) AfterTLSTermination() Instance {
+	switch i {
+	case HTTPS:
+		return HTTP
+	case TLS:
+		return TCP
+	default:
+		return i
+	}
+}
-- 
2.35.3

