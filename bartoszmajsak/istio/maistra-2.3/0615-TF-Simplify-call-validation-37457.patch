From 06398ba3f1c80cebef4f8c9c3bad92a5c834751c Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Tue, 22 Feb 2022 11:00:36 -0800
Subject: [TF] Simplify call validation (#37457)

There is currently validation logic in several places (ParsedResponse, ParsedResponses, eecho.Validator).

This change moves all of the validation logic into the echo client library. In addition, it allows an optimization for being able to run several checks on each message, rather than having to process a single check across all messages.
---
 pilot/pkg/networking/grpcgen/grpcecho_test.go |   6 +-
 pkg/test/echo/check/checker.go                |  26 +
 pkg/test/echo/check/checkers.go               | 236 ++++++
 pkg/test/echo/{client => }/client.go          |  22 +-
 pkg/test/echo/client/parsedresponse.go        | 453 -----------
 .../response/response.go => fields.go}        |  16 +-
 pkg/test/echo/parse.go                        | 126 +++
 pkg/test/echo/response.go                     |  99 +++
 pkg/test/echo/responses.go                    |  55 ++
 pkg/test/echo/server/endpoint/grpc.go         |  20 +-
 pkg/test/echo/server/endpoint/http.go         |  22 +-
 pkg/test/echo/server/endpoint/tcp.go          |  16 +-
 pkg/test/echo/server/endpoint/util.go         |   4 +-
 pkg/test/echo/server/forwarder/http.go        |   4 +-
 pkg/test/echo/server/forwarder/tcp.go         |   4 +-
 .../response/response.go => status.go}        |  20 +-
 pkg/test/framework/components/echo/call.go    | 178 +----
 .../framework/components/echo/common/call.go  |  29 +-
 pkg/test/framework/components/echo/echo.go    |  12 +-
 .../components/echo/echotest/fake.go          |  10 +-
 .../components/echo/kube/instance.go          |  20 +-
 .../components/echo/kube/workload.go          |  10 +-
 .../components/echo/staticvm/instance.go      |  14 +-
 .../components/echo/staticvm/workload.go      |  10 +-
 .../components/echo/util/traffic/generator.go |   5 +-
 .../components/echo/util/traffic/result.go    |   4 +-
 .../framework/components/istio/ingress.go     |  12 +-
 tests/integration/pilot/common/routing.go     | 724 ++++++++----------
 tests/integration/pilot/common/traffic.go     |  21 +-
 tests/integration/pilot/ingress_test.go       |  98 +--
 tests/integration/pilot/locality_test.go      |  16 +-
 .../discoverability/discoverability_test.go   |  49 +-
 .../pilot/multi_version_revision_test.go      |   8 +-
 tests/integration/pilot/multicluster_test.go  |  13 +-
 .../pilot/original_src_addr_test.go           |  16 +-
 .../pilot/revisions/revisions_test.go         |  14 +-
 tests/integration/pilot/vm_test.go            |   8 +-
 .../security/authorization_test.go            |  22 +-
 .../trust_domain_validation_test.go           |   7 +-
 .../mtls_strict_test.go                       |  11 +-
 .../egress_gateway_origination_test.go        |  41 +-
 .../file_mounted_certs/p2p_mtls_test.go       |  12 +-
 .../destination_rule_tls_test.go              |   8 +-
 .../egress_gateway_origination_test.go        |  10 +-
 .../security/https_jwt/https_jwt_test.go      |   6 +-
 tests/integration/security/jwt_test.go        |  62 +-
 .../security/normalization_test.go            |  13 +-
 .../pass_through_filter_chain_test.go         |  47 +-
 .../sds_istio_mutual_egress_test.go           |   6 +-
 .../security/sds_ingress/util/util.go         |  41 +-
 .../security/util/authn/authn_util.go         |  16 +-
 .../security/util/connection/checker.go       |   9 +-
 .../security/util/rbac_util/util.go           |  90 ++-
 .../telemetry/outboundtrafficpolicy/helper.go |   6 +-
 .../telemetry/policy/envoy_ratelimit_test.go  |   4 +-
 .../telemetry/stats/prometheus/stats.go       |   9 +-
 tests/util/sanitycheck/sanity_check.go        |   7 +-
 57 files changed, 1328 insertions(+), 1499 deletions(-)
 create mode 100644 pkg/test/echo/check/checker.go
 create mode 100644 pkg/test/echo/check/checkers.go
 rename pkg/test/echo/{client => }/client.go (85%)
 delete mode 100644 pkg/test/echo/client/parsedresponse.go
 copy pkg/test/echo/{common/response/response.go => fields.go} (72%)
 create mode 100644 pkg/test/echo/parse.go
 create mode 100644 pkg/test/echo/response.go
 create mode 100644 pkg/test/echo/responses.go
 rename pkg/test/echo/{common/response/response.go => status.go} (61%)

diff --git a/pilot/pkg/networking/grpcgen/grpcecho_test.go b/pilot/pkg/networking/grpcgen/grpcecho_test.go
index 0e5c8cdc21..136dc1cc7e 100644
--- a/pilot/pkg/networking/grpcgen/grpcecho_test.go
+++ b/pilot/pkg/networking/grpcgen/grpcecho_test.go
@@ -35,7 +35,7 @@
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/collections"
-	"istio.io/istio/pkg/test/echo/client"
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/echo/server/endpoint"
@@ -159,9 +159,9 @@ func makeWE(s echoCfg, host string, port int) config.Config {
 	}
 }
 
-func (t *configGenTest) dialEcho(addr string) *client.Instance {
+func (t *configGenTest) dialEcho(addr string) *echo.Client {
 	resolver := resolverForTest(t, t.xdsPort, "default")
-	out, err := client.New(addr, nil, grpc.WithResolvers(resolver))
+	out, err := echo.New(addr, nil, grpc.WithResolvers(resolver))
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/pkg/test/echo/check/checker.go b/pkg/test/echo/check/checker.go
new file mode 100644
index 0000000000..f93a884bef
--- /dev/null
+++ b/pkg/test/echo/check/checker.go
@@ -0,0 +1,26 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package check
+
+import (
+	"istio.io/istio/pkg/test/echo"
+)
+
+// Checker inspects echo call results for errors.
+type Checker func(echo.Responses, error) error
+
+func (c Checker) Check(rs echo.Responses, err error) error {
+	return c(rs, err)
+}
diff --git a/pkg/test/echo/check/checkers.go b/pkg/test/echo/check/checkers.go
new file mode 100644
index 0000000000..9cf64fcce2
--- /dev/null
+++ b/pkg/test/echo/check/checkers.go
@@ -0,0 +1,236 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package check
+
+import (
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+
+	"github.com/hashicorp/go-multierror"
+
+	"istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/framework/components/cluster"
+	"istio.io/istio/pkg/util/istiomultierror"
+)
+
+// WithInfo adds additional context information to any error returned by the provided Checker.
+func WithInfo(info string, c Checker) Checker {
+	return FilterError(func(err error) error {
+		return fmt.Errorf("%s: %v", info, err)
+	}, c)
+}
+
+// FilterError applies the given filter function to any errors returned by the Checker.
+func FilterError(filter func(error) error, c Checker) Checker {
+	return func(rs echo.Responses, err error) error {
+		if err := c(rs, err); err != nil {
+			return filter(err)
+		}
+		return nil
+	}
+}
+
+// Each applies the given per-response function across all responses.
+func Each(c func(r echo.Response) error) Checker {
+	return func(rs echo.Responses, _ error) error {
+		if rs.Len() == 0 {
+			return fmt.Errorf("no responses received")
+		}
+		outErr := istiomultierror.New()
+		for i, r := range rs {
+			if err := c(r); err != nil {
+				outErr = multierror.Append(outErr, fmt.Errorf("response[%d]: %v", i, err))
+			}
+		}
+		return outErr.ErrorOrNil()
+	}
+}
+
+// And is an aggregate Checker that requires all Checkers succeed.
+func And(checkers ...Checker) Checker {
+	return func(r echo.Responses, err error) error {
+		for _, c := range checkers {
+			if err := c(r, err); err != nil {
+				return err
+			}
+		}
+		return nil
+	}
+}
+
+// None provides a Checker that returns the original raw call error, unaltered.
+func None() Checker {
+	return func(_ echo.Responses, err error) error {
+		return err
+	}
+}
+
+// NoError is similar to None, but provides additional context information.
+func NoError() Checker {
+	return WithInfo("expected no error, but encountered", None())
+}
+
+// Error provides a checker that returns an error if the call succeeds.
+func Error() Checker {
+	return func(_ echo.Responses, err error) error {
+		if err == nil {
+			return errors.New("expected error, but none occurred")
+		}
+		return nil
+	}
+}
+
+func OK() Checker {
+	return Code(echo.StatusCodeOK)
+}
+
+func Code(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.Code != expected {
+			return fmt.Errorf("expected response code %s, got %q", expected, r.Code)
+		}
+		return nil
+	})
+}
+
+func Host(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.Host != expected {
+			return fmt.Errorf("expected host %s, received %s", expected, r.Host)
+		}
+		return nil
+	})
+}
+
+func MTLSForHTTP() Checker {
+	return Each(func(r echo.Response) error {
+		if !strings.HasPrefix(r.RequestURL, "http://") &&
+			!strings.HasPrefix(r.RequestURL, "grpc://") &&
+			!strings.HasPrefix(r.RequestURL, "ws://") {
+			// Non-HTTP traffic. Fail open, we cannot check mTLS.
+			return nil
+		}
+		_, f1 := r.RawResponse["X-Forwarded-Client-Cert"]
+		_, f2 := r.RawResponse["x-forwarded-client-cert"] // grpc has different casing
+		if f1 || f2 {
+			return nil
+		}
+		return fmt.Errorf("expected X-Forwarded-Client-Cert but not found: %v", r)
+	})
+}
+
+func Port(expected int) Checker {
+	return Each(func(r echo.Response) error {
+		expectedStr := strconv.Itoa(expected)
+		if r.Port != expectedStr {
+			return fmt.Errorf("expected port %s, received %s", expectedStr, r.Port)
+		}
+		return nil
+	})
+}
+
+func Key(key, expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.RawResponse[key] != expected {
+			return fmt.Errorf("%s: HTTP code %s, expected %s, received %s", key, r.Code, expected, r.RawResponse[key])
+		}
+		return nil
+	})
+}
+
+func Cluster(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.Cluster != expected {
+			return fmt.Errorf("expected cluster %s, received %s", expected, r.Cluster)
+		}
+		return nil
+	})
+}
+
+func URL(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.URL != expected {
+			return fmt.Errorf("expected URL %s, received %s", expected, r.URL)
+		}
+		return nil
+	})
+}
+
+func IP(expected string) Checker {
+	return Each(func(r echo.Response) error {
+		if r.IP != expected {
+			return fmt.Errorf("expected IP %s, received %s", expected, r.IP)
+		}
+		return nil
+	})
+}
+
+// ReachedClusters returns an error if there wasn't at least one response from each of the given clusters.
+// This can be used in combination with echo.Responses.Clusters(), for example:
+//     echoA[0].CallOrFail(t, ...).CheckReachedClusters(echoB.Clusters())
+func ReachedClusters(clusters cluster.Clusters) Checker {
+	return func(r echo.Responses, err error) error {
+		hits := clusterDistribution(r)
+		exp := map[string]struct{}{}
+		for _, expCluster := range clusters {
+			exp[expCluster.Name()] = struct{}{}
+			if hits[expCluster.Name()] == 0 {
+				return fmt.Errorf("did not reach all of %v, got %v", clusters, hits)
+			}
+		}
+		for hitCluster := range hits {
+			if _, ok := exp[hitCluster]; !ok {
+				return fmt.Errorf("reached cluster not in %v, got %v", clusters, hits)
+			}
+		}
+		return nil
+	}
+}
+
+// EqualClusterTraffic checks that traffic was equally distributed across the given clusters, allowing some percent error.
+// For example, with 100 requests and 20 percent error, each cluster must given received 20±4 responses. Only the passed
+// in clusters will be validated.
+func EqualClusterTraffic(clusters cluster.Clusters, precisionPct int) Checker {
+	return func(r echo.Responses, err error) error {
+		clusterHits := clusterDistribution(r)
+		expected := len(r) / len(clusters)
+		precision := int(float32(expected) * (float32(precisionPct) / 100))
+		for _, hits := range clusterHits {
+			if !almostEquals(hits, expected, precision) {
+				return fmt.Errorf("requests were not equally distributed across clusters: %v", clusterHits)
+			}
+		}
+		return nil
+	}
+}
+
+func clusterDistribution(r echo.Responses) map[string]int {
+	hits := map[string]int{}
+	for _, rr := range r {
+		hits[rr.Cluster]++
+	}
+	return hits
+}
+
+func almostEquals(a, b, precision int) bool {
+	upper := a + precision
+	lower := a - precision
+	if b < lower || b > upper {
+		return false
+	}
+	return true
+}
diff --git a/pkg/test/echo/client/client.go b/pkg/test/echo/client.go
similarity index 85%
rename from pkg/test/echo/client/client.go
rename to pkg/test/echo/client.go
index f3e912905e..43fd3ee78c 100644
--- a/pkg/test/echo/client/client.go
+++ b/pkg/test/echo/client.go
@@ -12,7 +12,7 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 
-package client
+package echo
 
 import (
 	"context"
@@ -32,16 +32,16 @@
 	"istio.io/istio/pkg/test/echo/proto"
 )
 
-var _ io.Closer = &Instance{}
+var _ io.Closer = &Client{}
 
-// Instance is a client of an Echo server that simplifies request/response processing for Forward commands.
-type Instance struct {
+// Client of an Echo server that simplifies request/response processing for Forward commands.
+type Client struct {
 	conn   *grpc.ClientConn
 	client proto.EchoTestServiceClient
 }
 
 // New creates a new echo client.Instance that is connected to the given server address.
-func New(address string, tlsSettings *common.TLSSettings, extraDialOpts ...grpc.DialOption) (*Instance, error) {
+func New(address string, tlsSettings *common.TLSSettings, extraDialOpts ...grpc.DialOption) (*Client, error) {
 	// Connect to the GRPC (command) endpoint of 'this' app.
 	// TODO: make use of common.ConnectionTimeout once it increases
 	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
@@ -84,35 +84,35 @@ func New(address string, tlsSettings *common.TLSSettings, extraDialOpts ...grpc.
 	}
 	client := proto.NewEchoTestServiceClient(conn)
 
-	return &Instance{
+	return &Client{
 		conn:   conn,
 		client: client,
 	}, nil
 }
 
 // Close the EchoClient and free any resources.
-func (c *Instance) Close() error {
+func (c *Client) Close() error {
 	if c.conn != nil {
 		return c.conn.Close()
 	}
 	return nil
 }
 
-func (c *Instance) Echo(ctx context.Context, request *proto.EchoRequest) (*ParsedResponse, error) {
+func (c *Client) Echo(ctx context.Context, request *proto.EchoRequest) (Response, error) {
 	resp, err := c.client.Echo(ctx, request)
 	if err != nil {
-		return nil, err
+		return Response{}, err
 	}
 	return parseResponse(resp.Message), nil
 }
 
 // ForwardEcho sends the given forward request and parses the response for easier processing. Only fails if the request fails.
-func (c *Instance) ForwardEcho(ctx context.Context, request *proto.ForwardEchoRequest) (ParsedResponses, error) {
+func (c *Client) ForwardEcho(ctx context.Context, request *proto.ForwardEchoRequest) (Responses, error) {
 	// Forward a request from 'this' service to the destination service.
 	resp, err := c.client.ForwardEcho(ctx, request)
 	if err != nil {
 		return nil, err
 	}
 
-	return ParseForwardedResponse(request, resp), nil
+	return ParseResponses(request, resp), nil
 }
diff --git a/pkg/test/echo/client/parsedresponse.go b/pkg/test/echo/client/parsedresponse.go
deleted file mode 100644
index 3544dc0d61..0000000000
--- a/pkg/test/echo/client/parsedresponse.go
+++ /dev/null
@@ -1,453 +0,0 @@
-//  Copyright Istio Authors
-//
-//  Licensed under the Apache License, Version 2.0 (the "License");
-//  you may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-
-package client
-
-import (
-	"fmt"
-	"regexp"
-	"sort"
-	"strconv"
-	"strings"
-
-	"github.com/hashicorp/go-multierror"
-
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/common/response"
-	"istio.io/istio/pkg/test/echo/proto"
-	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/util/istiomultierror"
-)
-
-var (
-	requestIDFieldRegex      = regexp.MustCompile("(?i)" + string(response.RequestIDField) + "=(.*)")
-	serviceVersionFieldRegex = regexp.MustCompile(string(response.ServiceVersionField) + "=(.*)")
-	servicePortFieldRegex    = regexp.MustCompile(string(response.ServicePortField) + "=(.*)")
-	statusCodeFieldRegex     = regexp.MustCompile(string(response.StatusCodeField) + "=(.*)")
-	hostFieldRegex           = regexp.MustCompile(string(response.HostField) + "=(.*)")
-	hostnameFieldRegex       = regexp.MustCompile(string(response.HostnameField) + "=(.*)")
-	responseHeaderFieldRegex = regexp.MustCompile(string(response.ResponseHeader) + "=(.*)")
-	URLFieldRegex            = regexp.MustCompile(string(response.URLField) + "=(.*)")
-	ClusterFieldRegex        = regexp.MustCompile(string(response.ClusterField) + "=(.*)")
-	IstioVersionFieldRegex   = regexp.MustCompile(string(response.IstioVersionField) + "=(.*)")
-	IPFieldRegex             = regexp.MustCompile(string(response.IPField) + "=(.*)")
-)
-
-// ParsedResponse represents a response to a single echo request.
-type ParsedResponse struct {
-	// RequestURL is the requested URL. This differs from URL, which is the just the path.
-	// For example, RequestURL=http://foo/bar, URL=/bar
-	RequestURL string
-	// Body is the body of the response
-	Body string
-	// ID is a unique identifier of the resource in the response
-	ID string
-	// URL is the url the request is sent to
-	URL string
-	// Version is the version of the resource in the response
-	Version string
-	// Port is the port of the resource in the response
-	Port string
-	// Code is the response code
-	Code string
-	// Host is the host called by the request
-	Host string
-	// Hostname is the host that responded to the request
-	Hostname string
-	// The cluster where the server is deployed.
-	Cluster string
-	// IstioVersion for the Istio sidecar.
-	IstioVersion string
-	// IP is the requester's ip address
-	IP string
-	// RawResponse gives a map of all values returned in the response (headers, etc)
-	RawResponse map[string]string
-}
-
-// IsOK indicates whether or not the code indicates a successful request.
-func (r *ParsedResponse) IsOK() bool {
-	return r.Code == response.StatusCodeOK
-}
-
-// Count occurrences of the given text within the body of this response.
-func (r *ParsedResponse) Count(text string) int {
-	return strings.Count(r.Body, text)
-}
-
-func (r *ParsedResponse) String() string {
-	out := ""
-	out += fmt.Sprintf("Body:         %s\n", r.Body)
-	out += fmt.Sprintf("ID:           %s\n", r.ID)
-	out += fmt.Sprintf("URL:          %s\n", r.URL)
-	out += fmt.Sprintf("Version:      %s\n", r.Version)
-	out += fmt.Sprintf("Port:         %s\n", r.Port)
-	out += fmt.Sprintf("Code:         %s\n", r.Code)
-	out += fmt.Sprintf("Host:         %s\n", r.Host)
-	out += fmt.Sprintf("Hostname:     %s\n", r.Hostname)
-	out += fmt.Sprintf("Cluster:      %s\n", r.Cluster)
-	out += fmt.Sprintf("IstioVersion: %s\n", r.IstioVersion)
-	out += fmt.Sprintf("IP:           %s\n", r.IP)
-
-	return out
-}
-
-// ParsedResponses is an ordered list of parsed response objects.
-type ParsedResponses []*ParsedResponse
-
-// Len returns the length of the parsed responses.
-func (r ParsedResponses) Len() int {
-	return len(r)
-}
-
-func (r ParsedResponses) Check(check func(int, *ParsedResponse) error) error {
-	if r.Len() == 0 {
-		return fmt.Errorf("no responses received")
-	}
-	err := istiomultierror.New()
-	for i, resp := range r {
-		if e := check(i, resp); e != nil {
-			err = multierror.Append(err, e)
-		}
-	}
-	return err.ErrorOrNil()
-}
-
-func (r ParsedResponses) CheckOrFail(t test.Failer, check func(int, *ParsedResponse) error) ParsedResponses {
-	t.Helper()
-	if err := r.Check(check); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-func (r ParsedResponses) CheckOK() error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if !response.IsOK() {
-			return fmt.Errorf("response[%d] Status Code: %s", i, response.Code)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckOKOrFail(t test.Failer) ParsedResponses {
-	t.Helper()
-	if err := r.CheckOK(); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-func (r ParsedResponses) CheckCode(expected string) error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.Code != expected {
-			return fmt.Errorf("expected response code %s, got %q", expected, response.Code)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckCodeOrFail(t test.Failer, expected string) ParsedResponses {
-	t.Helper()
-	if err := r.CheckCode(expected); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-func (r ParsedResponses) CheckHost(expected string) error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.Host != expected {
-			return fmt.Errorf("response[%d] Host: expected %s, received %s", i, expected, response.Host)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckHostOrFail(t test.Failer, expected string) ParsedResponses {
-	t.Helper()
-	if err := r.CheckHost(expected); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-// CheckMTLSForHTTP asserts that mutual TLS was used.
-// Note: this only is detectable for *successful* HTTP based traffic. Other types will always pass
-func (r ParsedResponses) CheckMTLSForHTTP() error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if !strings.HasPrefix(response.RequestURL, "http://") &&
-			!strings.HasPrefix(response.RequestURL, "grpc://") &&
-			!strings.HasPrefix(response.RequestURL, "ws://") {
-			// Non-HTTP traffic. Fail open, we cannot check mTLS.
-			return nil
-		}
-		_, f1 := response.RawResponse["X-Forwarded-Client-Cert"]
-		_, f2 := response.RawResponse["x-forwarded-client-cert"] // grpc has different casing
-		if f1 || f2 {
-			return nil
-		}
-		return fmt.Errorf("response[%d] X-Forwarded-Client-Cert expected but not found: %v", i, response)
-	})
-}
-
-func (r ParsedResponses) CheckPort(expected int) error {
-	expectedStr := strconv.Itoa(expected)
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.Port != expectedStr {
-			return fmt.Errorf("response[%d] Port: expected %s, received %s", i, expectedStr, response.Port)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckPortOrFail(t test.Failer, expected int) ParsedResponses {
-	t.Helper()
-	if err := r.CheckPort(expected); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-func (r ParsedResponses) clusterDistribution() map[string]int {
-	hits := map[string]int{}
-	for _, rr := range r {
-		hits[rr.Cluster]++
-	}
-	return hits
-}
-
-// CheckReachedClusters returns an error if there wasn't at least one response from each of the given clusters.
-// This can be used in combination with echo.Instances.Clusters(), for example:
-//     echoA[0].CallOrFail(t, ...).CheckReachedClusters(echoB.Clusters())
-func (r ParsedResponses) CheckReachedClusters(clusters cluster.Clusters) error {
-	hits := r.clusterDistribution()
-	exp := map[string]struct{}{}
-	for _, expCluster := range clusters {
-		exp[expCluster.Name()] = struct{}{}
-		if hits[expCluster.Name()] == 0 {
-			return fmt.Errorf("did not reach all of %v, got %v", clusters, hits)
-		}
-	}
-	for hitCluster := range hits {
-		if _, ok := exp[hitCluster]; !ok {
-			return fmt.Errorf("reached cluster not in %v, got %v", clusters, hits)
-		}
-	}
-	return nil
-}
-
-// CheckEqualClusterTraffic checks that traffic was equally distributed across the given clusters, allowing some percent error.
-// For example, with 100 requests and 20 percent error, each cluster must given received 20±4 responses. Only the passed
-// in clusters will be validated.
-func (r ParsedResponses) CheckEqualClusterTraffic(clusters cluster.Clusters, precisionPct int) error {
-	clusterHits := r.clusterDistribution()
-	expected := len(r) / len(clusters)
-	precision := int(float32(expected) * (float32(precisionPct) / 100))
-	for _, hits := range clusterHits {
-		if !almostEquals(hits, expected, precision) {
-			return fmt.Errorf("requests were not equally distributed across clusters: %v", clusterHits)
-		}
-	}
-	return nil
-}
-
-func almostEquals(a, b, precision int) bool {
-	upper := a + precision
-	lower := a - precision
-	if b < lower || b > upper {
-		return false
-	}
-	return true
-}
-
-func (r ParsedResponses) CheckKey(key, expected string) error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.RawResponse[key] != expected {
-			return fmt.Errorf("response[%d] %s: HTTP code %s, expected %s, received %s", i, key, response.Code, expected, response.RawResponse[key])
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckCluster(expected string) error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.Cluster != expected {
-			return fmt.Errorf("response[%d] Cluster: expected %s, received %s", i, expected, response.Cluster)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckClusterOrFail(t test.Failer, expected string) ParsedResponses {
-	t.Helper()
-	if err := r.CheckCluster(expected); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-func (r ParsedResponses) CheckIP(expected string) error {
-	return r.Check(func(i int, response *ParsedResponse) error {
-		if response.IP != expected {
-			return fmt.Errorf("response[%d] IP: expected %s, received %s", i, expected, response.IP)
-		}
-		return nil
-	})
-}
-
-func (r ParsedResponses) CheckIPOrFail(t test.Failer, expected string) ParsedResponses {
-	t.Helper()
-	if err := r.CheckIP(expected); err != nil {
-		t.Fatal(err)
-	}
-	return r
-}
-
-// Count occurrences of the given text within the bodies of all responses.
-func (r ParsedResponses) Count(text string) int {
-	count := 0
-	for _, c := range r {
-		count += c.Count(text)
-	}
-	return count
-}
-
-// Match returns a subset of ParsedResponses that match the given predicate.
-func (r ParsedResponses) Match(f func(r *ParsedResponse) bool) ParsedResponses {
-	var matched []*ParsedResponse
-	for _, rr := range r {
-		if f(rr) {
-			matched = append(matched, rr)
-		}
-	}
-	return matched
-}
-
-func (r ParsedResponses) String() string {
-	out := ""
-	for i, resp := range r {
-		out += fmt.Sprintf("Response[%d]:\n%s", i, resp.String())
-	}
-	return out
-}
-
-// ResponseBody returns the body of the response, in order
-func (r *ParsedResponse) ResponseBody() []string {
-	type kv struct {
-		k, v string
-	}
-	kvs := []kv{}
-	// RawResponse is in random order, so get the order back via sorting.
-	for k, v := range r.RawResponse {
-		kvs = append(kvs, kv{k, v})
-	}
-	sort.Slice(kvs, func(i, j int) bool {
-		return kvs[i].k < kvs[j].k
-	})
-	resp := []string{}
-	for _, v := range kvs {
-		resp = append(resp, v.v)
-	}
-	return resp
-}
-
-func ParseForwardedResponse(req *proto.ForwardEchoRequest, resp *proto.ForwardEchoResponse) ParsedResponses {
-	responses := make([]*ParsedResponse, len(resp.Output))
-	for i, output := range resp.Output {
-		responses[i] = parseResponse(output)
-		responses[i].RequestURL = req.Url
-	}
-	return responses
-}
-
-func parseResponse(output string) *ParsedResponse {
-	out := ParsedResponse{
-		Body: output,
-	}
-
-	match := requestIDFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.ID = match[1]
-	}
-
-	match = serviceVersionFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Version = match[1]
-	}
-
-	match = servicePortFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Port = match[1]
-	}
-
-	match = statusCodeFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Code = match[1]
-	}
-
-	match = hostFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Host = match[1]
-	}
-
-	match = hostnameFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Hostname = match[1]
-	}
-
-	match = URLFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.URL = match[1]
-	}
-
-	match = ClusterFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.Cluster = match[1]
-	}
-
-	match = IstioVersionFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.IstioVersion = match[1]
-	}
-
-	match = IPFieldRegex.FindStringSubmatch(output)
-	if match != nil {
-		out.IP = match[1]
-	}
-
-	out.RawResponse = map[string]string{}
-
-	matches := responseHeaderFieldRegex.FindAllStringSubmatch(output, -1)
-	for _, kv := range matches {
-		sl := strings.SplitN(kv[1], ":", 2)
-		if len(sl) != 2 {
-			continue
-		}
-		out.RawResponse[sl[0]] = sl[1]
-	}
-
-	for _, l := range strings.Split(output, "\n") {
-		prefixSplit := strings.Split(l, "body] ")
-		if len(prefixSplit) != 2 {
-			continue
-		}
-		kv := strings.SplitN(prefixSplit[1], "=", 2)
-		if len(kv) != 2 {
-			continue
-		}
-		out.RawResponse[kv[0]] = kv[1]
-	}
-
-	return &out
-}
diff --git a/pkg/test/echo/common/response/response.go b/pkg/test/echo/fields.go
similarity index 72%
copy from pkg/test/echo/common/response/response.go
copy to pkg/test/echo/fields.go
index f72942c83d..4d8e1ef7f2 100644
--- a/pkg/test/echo/common/response/response.go
+++ b/pkg/test/echo/fields.go
@@ -12,21 +12,7 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 
-package response
-
-import (
-	"net/http"
-	"strconv"
-)
-
-var (
-	StatusCodeOK              = strconv.Itoa(http.StatusOK)
-	StatusUnauthorized        = strconv.Itoa(http.StatusUnauthorized)
-	StatusCodeForbidden       = strconv.Itoa(http.StatusForbidden)
-	StatusCodeUnavailable     = strconv.Itoa(http.StatusServiceUnavailable)
-	StatusCodeBadRequest      = strconv.Itoa(http.StatusBadRequest)
-	StatusCodeTooManyRequests = strconv.Itoa(http.StatusTooManyRequests)
-)
+package echo
 
 // Field is a list of fields returned in responses from the Echo server.
 type Field string
diff --git a/pkg/test/echo/parse.go b/pkg/test/echo/parse.go
new file mode 100644
index 0000000000..3347a1e81f
--- /dev/null
+++ b/pkg/test/echo/parse.go
@@ -0,0 +1,126 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package echo
+
+import (
+	"regexp"
+	"strings"
+
+	"istio.io/istio/pkg/test/echo/proto"
+)
+
+var (
+	requestIDFieldRegex      = regexp.MustCompile("(?i)" + string(RequestIDField) + "=(.*)")
+	serviceVersionFieldRegex = regexp.MustCompile(string(ServiceVersionField) + "=(.*)")
+	servicePortFieldRegex    = regexp.MustCompile(string(ServicePortField) + "=(.*)")
+	statusCodeFieldRegex     = regexp.MustCompile(string(StatusCodeField) + "=(.*)")
+	hostFieldRegex           = regexp.MustCompile(string(HostField) + "=(.*)")
+	hostnameFieldRegex       = regexp.MustCompile(string(HostnameField) + "=(.*)")
+	responseHeaderFieldRegex = regexp.MustCompile(string(ResponseHeader) + "=(.*)")
+	URLFieldRegex            = regexp.MustCompile(string(URLField) + "=(.*)")
+	ClusterFieldRegex        = regexp.MustCompile(string(ClusterField) + "=(.*)")
+	IstioVersionFieldRegex   = regexp.MustCompile(string(IstioVersionField) + "=(.*)")
+	IPFieldRegex             = regexp.MustCompile(string(IPField) + "=(.*)")
+)
+
+func ParseResponses(req *proto.ForwardEchoRequest, resp *proto.ForwardEchoResponse) Responses {
+	responses := make([]Response, len(resp.Output))
+	for i, output := range resp.Output {
+		responses[i] = parseResponse(output)
+		responses[i].RequestURL = req.Url
+	}
+	return responses
+}
+
+func parseResponse(output string) Response {
+	out := Response{
+		Body: output,
+	}
+
+	match := requestIDFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.ID = match[1]
+	}
+
+	match = serviceVersionFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Version = match[1]
+	}
+
+	match = servicePortFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Port = match[1]
+	}
+
+	match = statusCodeFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Code = match[1]
+	}
+
+	match = hostFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Host = match[1]
+	}
+
+	match = hostnameFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Hostname = match[1]
+	}
+
+	match = URLFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.URL = match[1]
+	}
+
+	match = ClusterFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.Cluster = match[1]
+	}
+
+	match = IstioVersionFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.IstioVersion = match[1]
+	}
+
+	match = IPFieldRegex.FindStringSubmatch(output)
+	if match != nil {
+		out.IP = match[1]
+	}
+
+	out.RawResponse = map[string]string{}
+
+	matches := responseHeaderFieldRegex.FindAllStringSubmatch(output, -1)
+	for _, kv := range matches {
+		sl := strings.SplitN(kv[1], ":", 2)
+		if len(sl) != 2 {
+			continue
+		}
+		out.RawResponse[sl[0]] = sl[1]
+	}
+
+	for _, l := range strings.Split(output, "\n") {
+		prefixSplit := strings.Split(l, "body] ")
+		if len(prefixSplit) != 2 {
+			continue
+		}
+		kv := strings.SplitN(prefixSplit[1], "=", 2)
+		if len(kv) != 2 {
+			continue
+		}
+		out.RawResponse[kv[0]] = kv[1]
+	}
+
+	return out
+}
diff --git a/pkg/test/echo/response.go b/pkg/test/echo/response.go
new file mode 100644
index 0000000000..8fe6fdf2cc
--- /dev/null
+++ b/pkg/test/echo/response.go
@@ -0,0 +1,99 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package echo
+
+import (
+	"fmt"
+	"sort"
+	"strings"
+)
+
+// Response represents a response to a single echo request.
+type Response struct {
+	// RequestURL is the requested URL. This differs from URL, which is the just the path.
+	// For example, RequestURL=http://foo/bar, URL=/bar
+	RequestURL string
+	// Body is the body of the response
+	Body string
+	// ID is a unique identifier of the resource in the response
+	ID string
+	// URL is the url the request is sent to
+	URL string
+	// Version is the version of the resource in the response
+	Version string
+	// Port is the port of the resource in the response
+	Port string
+	// Code is the response code
+	Code string
+	// Host is the host called by the request
+	Host string
+	// Hostname is the host that responded to the request
+	Hostname string
+	// The cluster where the server is deployed.
+	Cluster string
+	// IstioVersion for the Istio sidecar.
+	IstioVersion string
+	// IP is the requester's ip address
+	IP string
+	// RawResponse gives a map of all values returned in the response (headers, etc)
+	RawResponse map[string]string
+}
+
+// IsOK indicates whether or not the code indicates a successful request.
+func (r Response) IsOK() bool {
+	return r.Code == StatusCodeOK
+}
+
+// Count occurrences of the given text within the body of this response.
+func (r Response) Count(text string) int {
+	return strings.Count(r.Body, text)
+}
+
+// ResponseBody returns the body of the response, in order
+func (r Response) ResponseBody() []string {
+	type kv struct {
+		k, v string
+	}
+	kvs := []kv{}
+	// RawResponse is in random order, so get the order back via sorting.
+	for k, v := range r.RawResponse {
+		kvs = append(kvs, kv{k, v})
+	}
+	sort.Slice(kvs, func(i, j int) bool {
+		return kvs[i].k < kvs[j].k
+	})
+	resp := []string{}
+	for _, v := range kvs {
+		resp = append(resp, v.v)
+	}
+	return resp
+}
+
+func (r Response) String() string {
+	out := ""
+	out += fmt.Sprintf("Body:         %s\n", r.Body)
+	out += fmt.Sprintf("ID:           %s\n", r.ID)
+	out += fmt.Sprintf("URL:          %s\n", r.URL)
+	out += fmt.Sprintf("Version:      %s\n", r.Version)
+	out += fmt.Sprintf("Port:         %s\n", r.Port)
+	out += fmt.Sprintf("Code:         %s\n", r.Code)
+	out += fmt.Sprintf("Host:         %s\n", r.Host)
+	out += fmt.Sprintf("Hostname:     %s\n", r.Hostname)
+	out += fmt.Sprintf("Cluster:      %s\n", r.Cluster)
+	out += fmt.Sprintf("IstioVersion: %s\n", r.IstioVersion)
+	out += fmt.Sprintf("IP:           %s\n", r.IP)
+
+	return out
+}
diff --git a/pkg/test/echo/responses.go b/pkg/test/echo/responses.go
new file mode 100644
index 0000000000..aafc487047
--- /dev/null
+++ b/pkg/test/echo/responses.go
@@ -0,0 +1,55 @@
+//  Copyright Istio Authors
+//
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package echo
+
+import (
+	"fmt"
+)
+
+// Responses is an ordered list of parsed response objects.
+type Responses []Response
+
+// Len returns the length of the parsed responses.
+func (r Responses) Len() int {
+	return len(r)
+}
+
+// Count occurrences of the given text within the bodies of all responses.
+func (r Responses) Count(text string) int {
+	count := 0
+	for _, c := range r {
+		count += c.Count(text)
+	}
+	return count
+}
+
+// Match returns a subset of Responses that match the given predicate.
+func (r Responses) Match(f func(r Response) bool) Responses {
+	var matched []Response
+	for _, rr := range r {
+		if f(rr) {
+			matched = append(matched, rr)
+		}
+	}
+	return matched
+}
+
+func (r Responses) String() string {
+	out := ""
+	for i, resp := range r {
+		out += fmt.Sprintf("Response[%d]:\n%s", i, resp.String())
+	}
+	return out
+}
diff --git a/pkg/test/echo/server/endpoint/grpc.go b/pkg/test/echo/server/endpoint/grpc.go
index d959924bfe..e0631ebbc9 100644
--- a/pkg/test/echo/server/endpoint/grpc.go
+++ b/pkg/test/echo/server/endpoint/grpc.go
@@ -40,8 +40,8 @@
 	"k8s.io/utils/env"
 
 	"istio.io/istio/pkg/istio-agent/grpcxds"
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/echo/server/forwarder"
 	"istio.io/istio/pkg/test/util/retry"
@@ -241,9 +241,9 @@ func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.
 			if strings.HasSuffix(key, "-bin") {
 				continue
 			}
-			field := response.Field(key)
+			field := echo.Field(key)
 			if key == ":authority" {
-				field = response.HostField
+				field = echo.HostField
 			}
 			for _, value := range values {
 				writeField(&body, field, value)
@@ -264,16 +264,16 @@ func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.
 		ip, _, _ = net.SplitHostPort(peerInfo.Addr.String())
 	}
 
-	writeField(&body, response.StatusCodeField, response.StatusCodeOK)
-	writeField(&body, response.ServiceVersionField, h.Version)
-	writeField(&body, response.ServicePortField, strconv.Itoa(portNumber))
-	writeField(&body, response.ClusterField, h.Cluster)
-	writeField(&body, response.IPField, ip)
-	writeField(&body, response.IstioVersionField, h.IstioVersion)
+	writeField(&body, echo.StatusCodeField, echo.StatusCodeOK)
+	writeField(&body, echo.ServiceVersionField, h.Version)
+	writeField(&body, echo.ServicePortField, strconv.Itoa(portNumber))
+	writeField(&body, echo.ClusterField, h.Cluster)
+	writeField(&body, echo.IPField, ip)
+	writeField(&body, echo.IstioVersionField, h.IstioVersion)
 	writeField(&body, "Echo", req.GetMessage())
 
 	if hostname, err := os.Hostname(); err == nil {
-		writeField(&body, response.HostnameField, hostname)
+		writeField(&body, echo.HostnameField, hostname)
 	}
 
 	epLog.WithLabels("id", id).Infof("GRPC Response")
diff --git a/pkg/test/echo/server/endpoint/http.go b/pkg/test/echo/server/endpoint/http.go
index 0081a9d1f9..003f74a4ae 100644
--- a/pkg/test/echo/server/endpoint/http.go
+++ b/pkg/test/echo/server/endpoint/http.go
@@ -33,8 +33,8 @@
 	"golang.org/x/net/http2"
 	"golang.org/x/net/http2/h2c"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 	"istio.io/istio/pkg/test/util/retry"
 )
 
@@ -290,7 +290,7 @@ func (h *httpHandler) webSocketEcho(w http.ResponseWriter, r *http.Request) {
 	h.addResponsePayload(r, &body)
 	body.Write(message)
 
-	writeField(&body, response.StatusCodeField, response.StatusCodeOK)
+	writeField(&body, echo.StatusCodeField, echo.StatusCodeOK)
 
 	// pong
 	err = c.WriteMessage(mt, body.Bytes())
@@ -307,18 +307,18 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 		port = strconv.Itoa(h.Port.Port)
 	}
 
-	writeField(body, response.ServiceVersionField, h.Version)
-	writeField(body, response.ServicePortField, port)
-	writeField(body, response.HostField, r.Host)
+	writeField(body, echo.ServiceVersionField, h.Version)
+	writeField(body, echo.ServicePortField, port)
+	writeField(body, echo.HostField, r.Host)
 	// Use raw path, we don't want golang normalizing anything since we use this for testing purposes
-	writeField(body, response.URLField, r.RequestURI)
-	writeField(body, response.ClusterField, h.Cluster)
-	writeField(body, response.IstioVersionField, h.IstioVersion)
+	writeField(body, echo.URLField, r.RequestURI)
+	writeField(body, echo.ClusterField, h.Cluster)
+	writeField(body, echo.IstioVersionField, h.IstioVersion)
 
 	writeField(body, "Method", r.Method)
 	writeField(body, "Proto", r.Proto)
 	ip, _, _ := net.SplitHostPort(r.RemoteAddr)
-	writeField(body, response.IPField, ip)
+	writeField(body, echo.IPField, ip)
 
 	// Note: since this is the NegotiatedProtocol, it will be set to empty if the client sends an ALPN
 	// not supported by the server (ie one of h2,http/1.1,http/1.0)
@@ -336,12 +336,12 @@ func (h *httpHandler) addResponsePayload(r *http.Request, body *bytes.Buffer) {
 	for _, key := range keys {
 		values := r.Header[key]
 		for _, value := range values {
-			writeField(body, response.Field(key), value)
+			writeField(body, echo.Field(key), value)
 		}
 	}
 
 	if hostname, err := os.Hostname(); err == nil {
-		writeField(body, response.HostnameField, hostname)
+		writeField(body, echo.HostnameField, hostname)
 	}
 }
 
diff --git a/pkg/test/echo/server/endpoint/tcp.go b/pkg/test/echo/server/endpoint/tcp.go
index edf114deed..940a7c1847 100644
--- a/pkg/test/echo/server/endpoint/tcp.go
+++ b/pkg/test/echo/server/endpoint/tcp.go
@@ -23,8 +23,8 @@
 
 	"github.com/google/uuid"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 	"istio.io/istio/pkg/test/util/retry"
 )
 
@@ -147,13 +147,13 @@ func (s *tcpInstance) echo(conn net.Conn) {
 func (s *tcpInstance) writeResponse(conn net.Conn) {
 	ip, _, _ := net.SplitHostPort(conn.RemoteAddr().String())
 	// Write non-request fields specific to the instance
-	respFields := map[response.Field]string{
-		response.StatusCodeField:     response.StatusCodeOK,
-		response.ClusterField:        s.Cluster,
-		response.IstioVersionField:   s.IstioVersion,
-		response.ServiceVersionField: s.Version,
-		response.ServicePortField:    strconv.Itoa(s.Port.Port),
-		response.IPField:             ip,
+	respFields := map[echo.Field]string{
+		echo.StatusCodeField:     echo.StatusCodeOK,
+		echo.ClusterField:        s.Cluster,
+		echo.IstioVersionField:   s.IstioVersion,
+		echo.ServiceVersionField: s.Version,
+		echo.ServicePortField:    strconv.Itoa(s.Port.Port),
+		echo.IPField:             ip,
 	}
 	for field, val := range respFields {
 		val := fmt.Sprintf("%s=%s\n", string(field), val)
diff --git a/pkg/test/echo/server/endpoint/util.go b/pkg/test/echo/server/endpoint/util.go
index aefb3765e4..b0eb7ae1b1 100644
--- a/pkg/test/echo/server/endpoint/util.go
+++ b/pkg/test/echo/server/endpoint/util.go
@@ -21,7 +21,7 @@
 	"os"
 	"strconv"
 
-	"istio.io/istio/pkg/test/echo/common/response"
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/pkg/log"
 )
 
@@ -58,6 +58,6 @@ func listenOnUDS(uds string) (net.Listener, error) {
 }
 
 // nolint: interfacer
-func writeField(out *bytes.Buffer, field response.Field, value string) {
+func writeField(out *bytes.Buffer, field echo.Field, value string) {
 	_, _ = out.WriteString(string(field) + "=" + value + "\n")
 }
diff --git a/pkg/test/echo/server/forwarder/http.go b/pkg/test/echo/server/forwarder/http.go
index fe0e9937fc..5494f144e5 100644
--- a/pkg/test/echo/server/forwarder/http.go
+++ b/pkg/test/echo/server/forwarder/http.go
@@ -26,8 +26,8 @@
 	"github.com/lucas-clemente/quic-go/http3"
 	"golang.org/x/net/http2"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 )
 
 var _ protocol = &httpProtocol{}
@@ -117,7 +117,7 @@ func (c *httpProtocol) makeRequest(ctx context.Context, req *request) (string, e
 		return outBuffer.String(), err
 	}
 
-	outBuffer.WriteString(fmt.Sprintf("[%d] %s=%d\n", req.RequestID, response.StatusCodeField, httpResp.StatusCode))
+	outBuffer.WriteString(fmt.Sprintf("[%d] %s=%d\n", req.RequestID, echo.StatusCodeField, httpResp.StatusCode))
 
 	keys := []string{}
 	for k := range httpResp.Header {
diff --git a/pkg/test/echo/server/forwarder/tcp.go b/pkg/test/echo/server/forwarder/tcp.go
index 4180f49829..3cb8f20b18 100644
--- a/pkg/test/echo/server/forwarder/tcp.go
+++ b/pkg/test/echo/server/forwarder/tcp.go
@@ -23,8 +23,8 @@
 	"net"
 	"strings"
 
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 )
 
 var _ protocol = &tcpProtocol{}
@@ -107,7 +107,7 @@ func (c *tcpProtocol) makeRequest(ctx context.Context, req *request) (string, er
 	}
 
 	msg := msgBuilder.String()
-	expected := fmt.Sprintf("%s=%s", string(response.StatusCodeField), response.StatusCodeOK)
+	expected := fmt.Sprintf("%s=%s", string(echo.StatusCodeField), echo.StatusCodeOK)
 	if req.ExpectedResponse != nil {
 		expected = req.ExpectedResponse.GetValue()
 	}
diff --git a/pkg/test/echo/common/response/response.go b/pkg/test/echo/status.go
similarity index 61%
rename from pkg/test/echo/common/response/response.go
rename to pkg/test/echo/status.go
index f72942c83d..7133063a62 100644
--- a/pkg/test/echo/common/response/response.go
+++ b/pkg/test/echo/status.go
@@ -12,7 +12,7 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 
-package response
+package echo
 
 import (
 	"net/http"
@@ -27,21 +27,3 @@
 	StatusCodeBadRequest      = strconv.Itoa(http.StatusBadRequest)
 	StatusCodeTooManyRequests = strconv.Itoa(http.StatusTooManyRequests)
 )
-
-// Field is a list of fields returned in responses from the Echo server.
-type Field string
-
-const (
-	RequestIDField      Field = "X-Request-Id"
-	ServiceVersionField Field = "ServiceVersion"
-	ServicePortField    Field = "ServicePort"
-	StatusCodeField     Field = "StatusCode"
-	URLField            Field = "URL"
-	HostField           Field = "Host"
-	HostnameField       Field = "Hostname"
-	MethodField         Field = "Method"
-	ResponseHeader      Field = "ResponseHeader"
-	ClusterField        Field = "Cluster"
-	IstioVersionField   Field = "IstioVersion"
-	IPField             Field = "IP" // The Requester’s IP Address.
-)
diff --git a/pkg/test/framework/components/echo/call.go b/pkg/test/framework/components/echo/call.go
index f60d99cb76..431587d738 100644
--- a/pkg/test/framework/components/echo/call.go
+++ b/pkg/test/framework/components/echo/call.go
@@ -15,16 +15,13 @@
 package echo
 
 import (
-	"errors"
-	"fmt"
 	"net/http"
 	"time"
 
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
-	"istio.io/istio/pkg/test/echo/client"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
-	"istio.io/istio/pkg/test/framework/components/cluster"
 )
 
 // CallOptions defines options for calling a Endpoint.
@@ -90,9 +87,9 @@ type CallOptions struct {
 	// is returned directly.
 	FollowRedirects bool
 
-	// Validator for server responses. If no validator is provided, only the number of responses received
-	// will be verified.
-	Validator Validator
+	// Check the server responses. If none is provided, only the number of responses received
+	// will be checked.
+	Check check.Checker
 
 	// HTTProxy used for making ingress echo call via proxy
 	HTTPProxy string
@@ -139,170 +136,3 @@ func (o CallOptions) DeepCopy() CallOptions {
 	}
 	return clone
 }
-
-// Validator validates that the given responses are expected.
-type Validator interface {
-	// Validate performs the validation check for this Validator.
-	Validate(client.ParsedResponses, error) error
-}
-
-type validators []Validator
-
-var _ Validator = validators{}
-
-// Validate executes all validators in order, exiting on the first error encountered.
-func (all validators) Validate(inResp client.ParsedResponses, err error) error {
-	if len(all) == 0 {
-		// By default, just assume no error.
-		return ExpectNoError().Validate(inResp, err)
-	}
-
-	for _, v := range all {
-		if e := v.Validate(inResp, err); e != nil {
-			return e
-		}
-	}
-	return nil
-}
-
-func (all validators) And(v Validator) Validator {
-	if v == nil {
-		return all
-	}
-	return append(append(validators{}, all...), v)
-}
-
-var (
-	expectNoError = ValidatorFunc(func(resp client.ParsedResponses, err error) error {
-		if err != nil {
-			return fmt.Errorf("expected no error, but encountered: %v", err)
-		}
-		return nil
-	})
-
-	expectError = ValidatorFunc(func(resp client.ParsedResponses, err error) error {
-		if err == nil {
-			return errors.New("expected error, but none occurred")
-		}
-		return nil
-	})
-
-	identityValidator = ValidatorFunc(func(_ client.ParsedResponses, err error) error {
-		return err
-	})
-)
-
-// ExpectNoError returns a Validator that fails if the call returned an error.
-func ExpectNoError() Validator {
-	return expectNoError
-}
-
-// ExpectError returns a Validator that fails if the call did not return an error.
-func ExpectError() Validator {
-	return expectError
-}
-
-// ExpectOK returns a Validator that calls CheckOK on the given responses.
-func ExpectOK() Validator {
-	return And(ExpectNoError(), ValidatorFunc(func(resp client.ParsedResponses, err error) error {
-		return resp.CheckOK()
-	}))
-}
-
-// ExpectReachedClusters returns a Validator that checks that all provided clusters are reached.
-func ExpectReachedClusters(clusters cluster.Clusters) Validator {
-	return ValidatorFunc(func(responses client.ParsedResponses, _ error) error {
-		return responses.CheckReachedClusters(clusters)
-	})
-}
-
-// ExpectCluster returns a validator that checks responses for the given cluster ID.
-func ExpectCluster(expected string) Validator {
-	return ValidatorFunc(func(responses client.ParsedResponses, _ error) error {
-		return responses.CheckCluster(expected)
-	})
-}
-
-// ExpectKey returns a validator that checks a key matches the provided value
-func ExpectKey(key, expected string) Validator {
-	return ValidatorFunc(func(responses client.ParsedResponses, _ error) error {
-		return responses.CheckKey(key, expected)
-	})
-}
-
-// ExpectHost returns a Validator that checks the responses for the given host header.
-func ExpectHost(expected string) Validator {
-	return ValidatorFunc(func(responses client.ParsedResponses, _ error) error {
-		return responses.CheckHost(expected)
-	})
-}
-
-// ExpectCode returns a Validator that checks the responses for the given response code.
-func ExpectCode(expected string) Validator {
-	return ValidatorFunc(func(responses client.ParsedResponses, _ error) error {
-		return responses.CheckCode(expected)
-	})
-}
-
-// ValidatorFunc is a function that serves as a Validator.
-type ValidatorFunc func(client.ParsedResponses, error) error
-
-var _ Validator = ValidatorFunc(func(client.ParsedResponses, error) error { return nil })
-
-func (v ValidatorFunc) Validate(resp client.ParsedResponses, err error) error {
-	return v(resp, err)
-}
-
-// And combines the validators into a chain. If no validators are provided, returns
-// the identity validator that just returns the original error.
-func And(vs ...Validator) Validator {
-	out := make(validators, 0)
-
-	for _, v := range vs {
-		if v != nil {
-			out = append(out, v)
-		}
-	}
-
-	if len(out) == 0 {
-		return identityValidator
-	}
-
-	if len(out) == 1 {
-		return out[0]
-	}
-
-	return out
-}
-
-// Or returns a validator that passes when any of the supplied validators pass. If no validators
-// are provided, returns the identity validator that just returns the original error.
-func Or(vs ...Validator) Validator {
-	out := make(validators, 0)
-
-	for _, v := range vs {
-		if v != nil {
-			out = append(out, v)
-		}
-	}
-
-	if len(out) == 0 {
-		return identityValidator
-	}
-
-	if len(out) == 1 {
-		return out[0]
-	}
-
-	return ValidatorFunc(func(responses client.ParsedResponses, err error) error {
-		var lasterr error
-		for _, v := range out {
-			if e := v.Validate(responses, err); e != nil {
-				lasterr = err
-				continue
-			}
-			return nil
-		}
-		return fmt.Errorf("no validators succeeded: %v", lasterr)
-	})
-}
diff --git a/pkg/test/framework/components/echo/common/call.go b/pkg/test/framework/components/echo/common/call.go
index 31ed1572b1..18ffecca95 100644
--- a/pkg/test/framework/components/echo/common/call.go
+++ b/pkg/test/framework/components/echo/common/call.go
@@ -26,7 +26,8 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/echo/client"
+	echoclient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/echo/proto"
@@ -36,10 +37,10 @@
 	"istio.io/istio/pkg/test/util/retry"
 )
 
-type sendFunc func(req *proto.ForwardEchoRequest) (client.ParsedResponses, error)
+type sendFunc func(req *proto.ForwardEchoRequest) (echoclient.Responses, error)
 
 func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
-	doRetry bool, retryOptions ...retry.Option) (client.ParsedResponses, error) {
+	doRetry bool, retryOptions ...retry.Option) (echoclient.Responses, error) {
 	if err := fillInCallOptions(opts); err != nil {
 		return nil, err
 	}
@@ -92,7 +93,7 @@ func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 		}
 	}
 
-	var responses client.ParsedResponses
+	var responses echoclient.Responses
 	sendAndValidate := func() error {
 		var err error
 		responses, err = send(req)
@@ -106,7 +107,7 @@ func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 		}
 
 		// Return the results from the validator.
-		return opts.Validator.Validate(responses, err)
+		return opts.Check(responses, err)
 	}
 
 	formatError := func(err error) error {
@@ -130,8 +131,8 @@ func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 	return responses, formatError(err)
 }
 
-func CallEcho(opts *echo.CallOptions, retry bool, retryOptions ...retry.Option) (client.ParsedResponses, error) {
-	send := func(req *proto.ForwardEchoRequest) (client.ParsedResponses, error) {
+func CallEcho(opts *echo.CallOptions, retry bool, retryOptions ...retry.Option) (echoclient.Responses, error) {
+	send := func(req *proto.ForwardEchoRequest) (echoclient.Responses, error) {
 		instance, err := forwarder.New(forwarder.Config{
 			Request: req,
 			Proxy:   opts.HTTPProxy,
@@ -146,7 +147,7 @@ func CallEcho(opts *echo.CallOptions, retry bool, retryOptions ...retry.Option)
 		if err != nil {
 			return nil, err
 		}
-		resp := client.ParseForwardedResponse(req, ret)
+		resp := echoclient.ParseResponses(req, ret)
 		return resp, nil
 	}
 	return callInternal("TestRunner", opts, send, retry, retryOptions...)
@@ -154,11 +155,11 @@ func CallEcho(opts *echo.CallOptions, retry bool, retryOptions ...retry.Option)
 
 // EchoClientProvider provides dynamic creation of Echo clients. This allows retries to potentially make
 // use of different (ready) workloads for forward requests.
-type EchoClientProvider func() (*client.Instance, error)
+type EchoClientProvider func() (*echoclient.Client, error)
 
 func ForwardEcho(srcName string, clientProvider EchoClientProvider, opts *echo.CallOptions,
-	retry bool, retryOptions ...retry.Option) (client.ParsedResponses, error) {
-	res, err := callInternal(srcName, opts, func(req *proto.ForwardEchoRequest) (client.ParsedResponses, error) {
+	retry bool, retryOptions ...retry.Option) (echoclient.Responses, error) {
+	res, err := callInternal(srcName, opts, func(req *proto.ForwardEchoRequest) (echoclient.Responses, error) {
 		c, err := clientProvider()
 		if err != nil {
 			return nil, err
@@ -258,8 +259,10 @@ func fillInCallOptions(opts *echo.CallOptions) error {
 		opts.Count = common.DefaultCount
 	}
 
-	// This is a quick and dirty way of getting the identity validator if the validator was not set.
-	opts.Validator = echo.And(opts.Validator)
+	// If no Check was specified, assume no error.
+	if opts.Check == nil {
+		opts.Check = check.None()
+	}
 	return nil
 }
 
diff --git a/pkg/test/framework/components/echo/echo.go b/pkg/test/framework/components/echo/echo.go
index 62b81b5e5e..ed53b20981 100644
--- a/pkg/test/framework/components/echo/echo.go
+++ b/pkg/test/framework/components/echo/echo.go
@@ -22,7 +22,7 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	"istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -64,13 +64,13 @@ type Builder interface {
 
 type Caller interface {
 	// Call makes a call from this Instance to a target Instance.
-	Call(options CallOptions) (client.ParsedResponses, error)
-	CallOrFail(t test.Failer, options CallOptions) client.ParsedResponses
+	Call(options CallOptions) (echo.Responses, error)
+	CallOrFail(t test.Failer, options CallOptions) echo.Responses
 
 	// CallWithRetry is the same as call, except that it will attempt to retry based on the provided
 	// options. If no options are provided, uses defaults.
-	CallWithRetry(options CallOptions, retryOptions ...retry.Option) (client.ParsedResponses, error)
-	CallWithRetryOrFail(t test.Failer, options CallOptions, retryOptions ...retry.Option) client.ParsedResponses
+	CallWithRetry(options CallOptions, retryOptions ...retry.Option) (echo.Responses, error)
+	CallWithRetryOrFail(t test.Failer, options CallOptions, retryOptions ...retry.Option) echo.Responses
 }
 
 type Callers []Caller
@@ -164,7 +164,7 @@ type Workload interface {
 	Sidecar() Sidecar
 
 	// ForwardEcho executes specific call from this workload.
-	ForwardEcho(context.Context, *proto.ForwardEchoRequest) (client.ParsedResponses, error)
+	ForwardEcho(context.Context, *proto.ForwardEchoRequest) (echo.Responses, error)
 
 	// Logs returns the logs for the app container
 	Logs() (string, error)
diff --git a/pkg/test/framework/components/echo/echotest/fake.go b/pkg/test/framework/components/echo/echotest/fake.go
index 0e7e73cf97..0f2d0a883c 100644
--- a/pkg/test/framework/components/echo/echotest/fake.go
+++ b/pkg/test/framework/components/echo/echotest/fake.go
@@ -18,7 +18,7 @@
 	"fmt"
 
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -56,19 +56,19 @@ func (f fakeInstance) WorkloadsOrFail(t test.Failer) []echo.Workload {
 	panic("implement me")
 }
 
-func (f fakeInstance) Call(options echo.CallOptions) (client.ParsedResponses, error) {
+func (f fakeInstance) Call(options echo.CallOptions) (echoClient.Responses, error) {
 	panic("implement me")
 }
 
-func (f fakeInstance) CallOrFail(t test.Failer, options echo.CallOptions) client.ParsedResponses {
+func (f fakeInstance) CallOrFail(t test.Failer, options echo.CallOptions) echoClient.Responses {
 	panic("implement me")
 }
 
-func (f fakeInstance) CallWithRetry(options echo.CallOptions, retryOptions ...retry.Option) (client.ParsedResponses, error) {
+func (f fakeInstance) CallWithRetry(options echo.CallOptions, retryOptions ...retry.Option) (echoClient.Responses, error) {
 	panic("implement me")
 }
 
-func (f fakeInstance) CallWithRetryOrFail(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) client.ParsedResponses {
+func (f fakeInstance) CallWithRetryOrFail(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoClient.Responses {
 	panic("implement me")
 }
 
diff --git a/pkg/test/framework/components/echo/kube/instance.go b/pkg/test/framework/components/echo/kube/instance.go
index 6a24ded4b9..2536fe0f3b 100644
--- a/pkg/test/framework/components/echo/kube/instance.go
+++ b/pkg/test/framework/components/echo/kube/instance.go
@@ -26,7 +26,7 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	appEcho "istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -125,7 +125,7 @@ func (c *instance) WorkloadsOrFail(t test.Failer) []echo.Workload {
 	return out
 }
 
-func (c *instance) firstClient() (*appEcho.Instance, error) {
+func (c *instance) firstClient() (*echoClient.Client, error) {
 	workloads, err := c.Workloads()
 	if err != nil {
 		return nil, err
@@ -146,11 +146,11 @@ func (c *instance) Config() echo.Config {
 	return c.cfg
 }
 
-func (c *instance) Call(opts echo.CallOptions) (appEcho.ParsedResponses, error) {
+func (c *instance) Call(opts echo.CallOptions) (echoClient.Responses, error) {
 	return c.aggregateResponses(opts, false)
 }
 
-func (c *instance) CallOrFail(t test.Failer, opts echo.CallOptions) appEcho.ParsedResponses {
+func (c *instance) CallOrFail(t test.Failer, opts echo.CallOptions) echoClient.Responses {
 	t.Helper()
 	r, err := c.Call(opts)
 	if err != nil {
@@ -160,12 +160,12 @@ func (c *instance) CallOrFail(t test.Failer, opts echo.CallOptions) appEcho.Pars
 }
 
 func (c *instance) CallWithRetry(opts echo.CallOptions,
-	retryOptions ...retry.Option) (appEcho.ParsedResponses, error) {
+	retryOptions ...retry.Option) (echoClient.Responses, error) {
 	return c.aggregateResponses(opts, true, retryOptions...)
 }
 
 func (c *instance) CallWithRetryOrFail(t test.Failer, opts echo.CallOptions,
-	retryOptions ...retry.Option) appEcho.ParsedResponses {
+	retryOptions ...retry.Option) echoClient.Responses {
 	t.Helper()
 	r, err := c.CallWithRetry(opts, retryOptions...)
 	if err != nil {
@@ -206,14 +206,14 @@ func (c *instance) Restart() error {
 }
 
 // aggregateResponses forwards an echo request from all workloads belonging to this echo instance and aggregates the results.
-func (c *instance) aggregateResponses(opts echo.CallOptions, retry bool, retryOptions ...retry.Option) (appEcho.ParsedResponses, error) {
+func (c *instance) aggregateResponses(opts echo.CallOptions, retry bool, retryOptions ...retry.Option) (echoClient.Responses, error) {
 	// TODO put this somewhere else, or require users explicitly set the protocol - quite hacky
 	if c.Config().IsProxylessGRPC() && (opts.Scheme == scheme.GRPC || opts.PortName == "grpc" || opts.Port != nil && opts.Port.Protocol == protocol.GRPC) {
 		// for gRPC calls, use XDS resolver
 		opts.Scheme = scheme.XDS
 	}
 
-	resps := make([]*appEcho.ParsedResponse, 0)
+	resps := make(echoClient.Responses, 0)
 	workloads, err := c.Workloads()
 	if err != nil {
 		return nil, err
@@ -228,9 +228,7 @@ func (c *instance) aggregateResponses(opts echo.CallOptions, retry bool, retryOp
 			aggErr = multierror.Append(aggErr, err)
 			continue
 		}
-		for _, r := range out {
-			resps = append(resps, r)
-		}
+		resps = append(resps, out...)
 	}
 	if aggErr.ErrorOrNil() != nil {
 		return nil, aggErr
diff --git a/pkg/test/framework/components/echo/kube/workload.go b/pkg/test/framework/components/echo/kube/workload.go
index 0a4e93e6c2..6097410827 100644
--- a/pkg/test/framework/components/echo/kube/workload.go
+++ b/pkg/test/framework/components/echo/kube/workload.go
@@ -25,7 +25,7 @@
 
 	istioKube "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -50,7 +50,7 @@ type workloadConfig struct {
 }
 
 type workload struct {
-	client *client.Instance
+	client *echoClient.Client
 
 	workloadConfig
 	forwarder  istioKube.PortForwarder
@@ -81,7 +81,7 @@ func (w *workload) IsReady() bool {
 	return ready
 }
 
-func (w *workload) Client() (c *client.Instance, err error) {
+func (w *workload) Client() (c *echoClient.Client, err error) {
 	w.mutex.Lock()
 	c = w.client
 	if c == nil {
@@ -135,7 +135,7 @@ func (w *workload) Address() string {
 	return ip
 }
 
-func (w *workload) ForwardEcho(ctx context.Context, request *proto.ForwardEchoRequest) (client.ParsedResponses, error) {
+func (w *workload) ForwardEcho(ctx context.Context, request *proto.ForwardEchoRequest) (echoClient.Responses, error) {
 	w.mutex.Lock()
 	c := w.client
 	if c == nil {
@@ -199,7 +199,7 @@ func (w *workload) connect(pod kubeCore.Pod) (err error) {
 	}
 
 	// Create a gRPC client to this workload.
-	w.client, err = client.New(w.forwarder.Address(), w.tls)
+	w.client, err = echoClient.New(w.forwarder.Address(), w.tls)
 	if err != nil {
 		return fmt.Errorf("failed connecting to grpc client to pod %s/%s : %v",
 			pod.Namespace, pod.Name, err)
diff --git a/pkg/test/framework/components/echo/staticvm/instance.go b/pkg/test/framework/components/echo/staticvm/instance.go
index ed32b12d11..0b179dec96 100644
--- a/pkg/test/framework/components/echo/staticvm/instance.go
+++ b/pkg/test/framework/components/echo/staticvm/instance.go
@@ -25,7 +25,7 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
@@ -129,15 +129,15 @@ func (i *instance) WorkloadsOrFail(t test.Failer) []echo.Workload {
 	return w
 }
 
-func (i *instance) defaultClient() (*client.Instance, error) {
-	return i.workloads[0].(*workload).Instance, nil
+func (i *instance) defaultClient() (*echoClient.Client, error) {
+	return i.workloads[0].(*workload).Client, nil
 }
 
-func (i *instance) Call(opts echo.CallOptions) (client.ParsedResponses, error) {
+func (i *instance) Call(opts echo.CallOptions) (echoClient.Responses, error) {
 	return common.ForwardEcho(i.Config().Service, i.defaultClient, &opts, false)
 }
 
-func (i *instance) CallOrFail(t test.Failer, opts echo.CallOptions) client.ParsedResponses {
+func (i *instance) CallOrFail(t test.Failer, opts echo.CallOptions) echoClient.Responses {
 	t.Helper()
 	res, err := i.Call(opts)
 	if err != nil {
@@ -146,11 +146,11 @@ func (i *instance) CallOrFail(t test.Failer, opts echo.CallOptions) client.Parse
 	return res
 }
 
-func (i *instance) CallWithRetry(opts echo.CallOptions, retryOptions ...retry.Option) (client.ParsedResponses, error) {
+func (i *instance) CallWithRetry(opts echo.CallOptions, retryOptions ...retry.Option) (echoClient.Responses, error) {
 	return common.ForwardEcho(i.Config().Service, i.defaultClient, &opts, true, retryOptions...)
 }
 
-func (i *instance) CallWithRetryOrFail(t test.Failer, opts echo.CallOptions, retryOptions ...retry.Option) client.ParsedResponses {
+func (i *instance) CallWithRetryOrFail(t test.Failer, opts echo.CallOptions, retryOptions ...retry.Option) echoClient.Responses {
 	t.Helper()
 	res, err := i.CallWithRetry(opts, retryOptions...)
 	if err != nil {
diff --git a/pkg/test/framework/components/echo/staticvm/workload.go b/pkg/test/framework/components/echo/staticvm/workload.go
index fe6e287a0f..f7af596223 100644
--- a/pkg/test/framework/components/echo/staticvm/workload.go
+++ b/pkg/test/framework/components/echo/staticvm/workload.go
@@ -22,7 +22,7 @@
 	"github.com/hashicorp/go-multierror"
 
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo"
 )
@@ -30,7 +30,7 @@
 var _ echo.Workload = &workload{}
 
 type workload struct {
-	*client.Instance
+	*echoClient.Client
 	address string
 }
 
@@ -61,13 +61,13 @@ func newWorkload(addresses string, grpcPort int, tls *common.TLSSettings) (*work
 		internal = parts[1]
 	}
 
-	c, err := client.New(net.JoinHostPort(external, fmt.Sprint(grpcPort)), tls)
+	c, err := echoClient.New(net.JoinHostPort(external, fmt.Sprint(grpcPort)), tls)
 	if err != nil {
 		return nil, err
 	}
 	return &workload{
-		Instance: c,
-		address:  internal,
+		Client:  c,
+		address: internal,
 	}, nil
 }
 
diff --git a/pkg/test/framework/components/echo/util/traffic/generator.go b/pkg/test/framework/components/echo/util/traffic/generator.go
index 539561dfb8..f96784e40b 100644
--- a/pkg/test/framework/components/echo/util/traffic/generator.go
+++ b/pkg/test/framework/components/echo/util/traffic/generator.go
@@ -18,6 +18,7 @@
 	"time"
 
 	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework/components/echo"
 )
 
@@ -120,7 +121,7 @@ func fillInDefaults(cfg *Config) {
 	if cfg.StopTimeout == 0 {
 		cfg.StopTimeout = defaultTimeout
 	}
-	if cfg.Options.Validator == nil {
-		cfg.Options.Validator = echo.ExpectOK()
+	if cfg.Options.Check == nil {
+		cfg.Options.Check = check.OK()
 	}
 }
diff --git a/pkg/test/framework/components/echo/util/traffic/result.go b/pkg/test/framework/components/echo/util/traffic/result.go
index 489cf94e4e..9da7a73b84 100644
--- a/pkg/test/framework/components/echo/util/traffic/result.go
+++ b/pkg/test/framework/components/echo/util/traffic/result.go
@@ -21,7 +21,7 @@
 	"github.com/hashicorp/go-multierror"
 
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	"istio.io/istio/pkg/test/echo"
 )
 
 // Result of a traffic generation operation.
@@ -42,7 +42,7 @@ func (r Result) String() string {
 	return buf.String()
 }
 
-func (r *Result) add(resp client.ParsedResponses, err error) {
+func (r *Result) add(resp echo.Responses, err error) {
 	count := resp.Len()
 	if count == 0 {
 		count = 1
diff --git a/pkg/test/framework/components/istio/ingress.go b/pkg/test/framework/components/istio/ingress.go
index 7e032785d3..27b400de35 100644
--- a/pkg/test/framework/components/istio/ingress.go
+++ b/pkg/test/framework/components/istio/ingress.go
@@ -24,7 +24,7 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
@@ -168,11 +168,11 @@ func (c *ingressImpl) DiscoveryAddress() net.TCPAddr {
 	return net.TCPAddr{IP: ip, Port: port}
 }
 
-func (c *ingressImpl) Call(options echo.CallOptions) (client.ParsedResponses, error) {
+func (c *ingressImpl) Call(options echo.CallOptions) (echoClient.Responses, error) {
 	return c.callEcho(options, false)
 }
 
-func (c *ingressImpl) CallOrFail(t test.Failer, options echo.CallOptions) client.ParsedResponses {
+func (c *ingressImpl) CallOrFail(t test.Failer, options echo.CallOptions) echoClient.Responses {
 	t.Helper()
 	resp, err := c.Call(options)
 	if err != nil {
@@ -182,12 +182,12 @@ func (c *ingressImpl) CallOrFail(t test.Failer, options echo.CallOptions) client
 }
 
 func (c *ingressImpl) CallWithRetry(options echo.CallOptions,
-	retryOptions ...retry.Option) (client.ParsedResponses, error) {
+	retryOptions ...retry.Option) (echoClient.Responses, error) {
 	return c.callEcho(options, true, retryOptions...)
 }
 
 func (c *ingressImpl) CallWithRetryOrFail(t test.Failer, options echo.CallOptions,
-	retryOptions ...retry.Option) client.ParsedResponses {
+	retryOptions ...retry.Option) echoClient.Responses {
 	t.Helper()
 	resp, err := c.CallWithRetry(options, retryOptions...)
 	if err != nil {
@@ -196,7 +196,7 @@ func (c *ingressImpl) CallWithRetryOrFail(t test.Failer, options echo.CallOption
 	return resp
 }
 
-func (c *ingressImpl) callEcho(options echo.CallOptions, retry bool, retryOptions ...retry.Option) (client.ParsedResponses, error) {
+func (c *ingressImpl) callEcho(options echo.CallOptions, retry bool, retryOptions ...retry.Option) (echoClient.Responses, error) {
 	if options.Port == nil || options.Port.Protocol == "" {
 		return nil, fmt.Errorf("must provide protocol")
 	}
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 7b0ed6ee2e..3f1d6abcc3 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -35,7 +35,8 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/security"
 	"istio.io/istio/pkg/test"
-	echoclient "istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -155,14 +156,9 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.RawResponse["Istio-Custom-Header"], "user-defined-value", "request header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("request header", check.Key("Istio-Custom-Header", "user-defined-value"))),
 			},
 			workloadAgnostic: true,
 		},
@@ -187,14 +183,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.RawResponse["X-Custom"], "some-value", "added request header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added request header", check.Key("X-Custom", "some-value"))),
 			},
 			workloadAgnostic: true,
 		},
@@ -219,14 +210,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.RawResponse["Host"], "my-custom-authority", "added authority header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added authority header", check.Key("Host", "my-custom-authority"))),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.10.0",
@@ -252,14 +238,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.RawResponse["Host"], "my-custom-authority", "added authority header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added request header", check.Key("Host", "my-custom-authority"))),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.10.0",
@@ -289,15 +270,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								// Route takes precedence
-								return ExpectString(response.RawResponse["Host"], "route-authority", "added authority header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added request header", check.Key("Host", "route-authority"))),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -331,15 +306,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								// Route takes precedence
-								return ExpectString(response.RawResponse["Host"], "route-authority", "added authority header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added authority header", check.Key("Host", "route-authority"))),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -373,15 +342,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 			opts: echo.CallOptions{
 				PortName: "http",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								// Route takes precedence
-								return ExpectString(response.RawResponse["Host"], "dest-authority", "added authority header")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("added authority header", check.Key("Host", "dest-authority"))),
 			},
 			workloadAgnostic: true,
 			minIstioVersion:  "1.12.0",
@@ -413,14 +376,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 				Path:            "/foo?key=value",
 				FollowRedirects: true,
 				Count:           1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.URL, "/new/path?key=value", "URL")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.URL("/new/path?key=value")),
 			},
 			workloadAgnostic: true,
 		},
@@ -447,19 +405,17 @@ func(response echoclient.ParsedResponses, _ error) error {
 				Path:            "/foo",
 				FollowRedirects: false,
 				Count:           1,
-				Validator: echo.And(
-					echo.ExpectCode("301"),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								originalHostname, err := url.Parse(response.RequestURL)
-								if err != nil {
-									return err
-								}
-								return ExpectString(response.RawResponse["Location"],
-									fmt.Sprintf("https://%s:%d/foo", originalHostname.Hostname(), FindPortByName("http").ServicePort),
-									"Location")
-							})
+				Check: check.And(
+					check.Code("301"),
+					check.Each(
+						func(r echoClient.Response) error {
+							originalHostname, err := url.Parse(r.RequestURL)
+							if err != nil {
+								return err
+							}
+							return ExpectString(r.RawResponse["Location"],
+								fmt.Sprintf("https://%s:%d/foo", originalHostname.Hostname(), FindPortByName("http").ServicePort),
+								"Location")
 						})),
 			},
 			workloadAgnostic: true,
@@ -487,14 +443,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 				PortName: "http",
 				Path:     "/foo?key=value#hash",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.URL, "/new/path?key=value", "URL")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.URL("/new/path?key=value")),
 			},
 			workloadAgnostic: true,
 		},
@@ -521,14 +472,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 				PortName: "http",
 				Path:     "/foo",
 				Count:    1,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								return ExpectString(response.Host, "new-authority", "authority")
-							})
-						})),
+				Check: check.And(
+					check.OK(),
+					check.WithInfo("authority", check.Host("new-authority"))),
 			},
 			workloadAgnostic: true,
 		},
@@ -572,30 +518,12 @@ func(response echoclient.ParsedResponses, _ error) error {
 							Method:   "OPTIONS",
 							Headers:  header,
 							Count:    1,
-							Validator: echo.And(
-								echo.ExpectOK(),
-								echo.ValidatorFunc(
-									func(response echoclient.ParsedResponses, _ error) error {
-										return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-											if err := ExpectString(response.RawResponse["Access-Control-Allow-Origin"],
-												"cors.com", "preflight CORS origin"); err != nil {
-												return err
-											}
-											if err := ExpectString(response.RawResponse["Access-Control-Allow-Methods"],
-												"POST,GET", "preflight CORS method"); err != nil {
-												return err
-											}
-											if err := ExpectString(response.RawResponse["Access-Control-Allow-Headers"],
-												"X-Foo-Bar,X-Foo-Baz", "preflight CORS headers"); err != nil {
-												return err
-											}
-											if err := ExpectString(response.RawResponse["Access-Control-Max-Age"],
-												"86400", "preflight CORS max age"); err != nil {
-												return err
-											}
-											return nil
-										})
-									})),
+							Check: check.And(
+								check.OK(),
+								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Origin", "cors.com")),
+								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Methods", "POST,GET")),
+								check.WithInfo("CORS preflight header", check.Key("Access-Control-Allow-Headers", "X-Foo-Bar,X-Foo-Baz")),
+								check.WithInfo("CORS preflight header", check.Key("Access-Control-Max-Age", "86400"))),
 						}
 					}(),
 				},
@@ -608,13 +536,9 @@ func(response echoclient.ParsedResponses, _ error) error {
 							PortName: "http",
 							Headers:  header,
 							Count:    1,
-							Validator: echo.And(
-								echo.ExpectOK(),
-								echo.ValidatorFunc(
-									func(response echoclient.ParsedResponses, _ error) error {
-										return ExpectString(response[0].RawResponse["Access-Control-Allow-Origin"],
-											"cors.com", "GET CORS origin")
-									})),
+							Check: check.And(
+								check.OK(),
+								check.WithInfo("CORS origin", check.Key("Access-Control-Allow-Origin", "cors.com"))),
 						}
 					}(),
 				},
@@ -624,18 +548,15 @@ func(response echoclient.ParsedResponses, _ error) error {
 					opts: echo.CallOptions{
 						PortName: "http",
 						Count:    1,
-						Validator: echo.And(
-							echo.ExpectOK(),
-							echo.ValidatorFunc(
-								func(response echoclient.ParsedResponses, _ error) error {
-									return ExpectString(response[0].RawResponse["Access-Control-Allow-Origin"], "", "mismatched CORS origin")
-								})),
+						Check: check.And(
+							check.OK(),
+							check.WithInfo("mismatched CORS origin", check.Key("Access-Control-Allow-Origin", ""))),
 					},
 				},
 			},
 			workloadAgnostic: true,
 		},
-		// Retry conditions have been added to just validate that config is correct.
+		// Retry conditions have been added to just check that config is correct.
 		// Retries are not specifically tested.
 		TrafficTestCase{
 			name: "retry conditions",
@@ -657,9 +578,9 @@ func(response echoclient.ParsedResponses, _ error) error {
       retryOn: gateway-error,connect-failure,refused-stream
       retryRemoteLocalities: true`,
 			opts: echo.CallOptions{
-				PortName:  "http",
-				Count:     1,
-				Validator: echo.ExpectOK(),
+				PortName: "http",
+				Count:    1,
+				Check:    check.OK(),
 			},
 			workloadAgnostic: true,
 		},
@@ -683,9 +604,9 @@ func(response echoclient.ParsedResponses, _ error) error {
           value: 100
         httpStatus: 418`,
 			opts: echo.CallOptions{
-				PortName:  "http",
-				Count:     1,
-				Validator: echo.ExpectCode("418"),
+				PortName: "http",
+				Count:    1,
+				Check:    check.Code("418"),
 			},
 			workloadAgnostic: true,
 		},
@@ -741,10 +662,10 @@ func(response echoclient.ParsedResponses, _ error) error {
       weight: {{ ( index $split $idx ) }}
 {{- end }}
 `,
-			validateForN: func(src echo.Caller, dests echo.Services, opts *echo.CallOptions) echo.Validator {
-				return echo.And(
-					echo.ExpectOK(),
-					echo.ValidatorFunc(func(responses echoclient.ParsedResponses, err error) error {
+			checkForN: func(src echo.Caller, dests echo.Services, opts *echo.CallOptions) check.Checker {
+				return check.And(
+					check.OK(),
+					func(responses echoClient.Responses, err error) error {
 						errorThreshold := 10
 						if len(split) != len(dests) {
 							// shouldn't happen
@@ -755,7 +676,7 @@ func(response echoclient.ParsedResponses, _ error) error {
 							splitPerHost[dests.Services()[i]] = pct
 						}
 						for hostName, exp := range splitPerHost {
-							hostResponses := responses.Match(func(r *echoclient.ParsedResponse) bool {
+							hostResponses := responses.Match(func(r echoClient.Response) bool {
 								return strings.HasPrefix(r.Hostname, hostName)
 							})
 							if !AlmostEquals(len(hostResponses), exp, errorThreshold) {
@@ -770,13 +691,13 @@ func(response echoclient.ParsedResponses, _ error) error {
 								// Conditionally check reached clusters to work around connection load balancing issues
 								// See https://github.com/istio/istio/issues/32208 for details
 								// We want to skip this for requests from the cross-network pod
-								if err := hostResponses.CheckReachedClusters(targetClusters); err != nil {
+								if err := check.ReachedClusters(targetClusters).Check(hostResponses, nil); err != nil {
 									return fmt.Errorf("did not reach all clusters for %s: %v", hostName, err)
 								}
 							}
 						}
 						return nil
-					}))
+					})
 			},
 			setupOpts: func(src echo.Caller, dest echo.Instances, opts *echo.CallOptions) {
 				// TODO force this globally in echotest?
@@ -833,12 +754,14 @@ func tlsOriginationCases(apps *EchoDeployments) []TrafficTestCase {
 			tc.children = append(tc.children, TrafficCall{
 				name: fmt.Sprintf("%s: %s", c.Config().Cluster.StableName(), e.alpn),
 				opts: echo.CallOptions{
-					Port:      &echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
-					Count:     1,
-					Address:   apps.External[0].Address(),
-					Headers:   HostHeader(apps.External[0].Config().DefaultHostHeader),
-					Scheme:    scheme.HTTP,
-					Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("Alpn", e.alpn)),
+					Port:    &echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
+					Count:   1,
+					Address: apps.External[0].Address(),
+					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
+					Scheme:  scheme.HTTP,
+					Check: check.And(
+						check.OK(),
+						check.Key("Alpn", e.alpn)),
 				},
 				call: c.CallWithRetryOrFail,
 			})
@@ -862,9 +785,9 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				PortName: "http",
 				Count:    1,
 				HTTP2:    true,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ExpectKey("Proto", "HTTP/2.0"),
+				Check: check.And(
+					check.OK(),
+					check.Key("Proto", "HTTP/2.0"),
 				),
 			},
 			minIstioVersion: "1.10.0",
@@ -878,9 +801,9 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				Count:    1,
 				Target:   destination,
 				HTTP2:    false,
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ExpectKey("Proto", "HTTP/1.1"),
+				Check: check.And(
+					check.OK(),
+					check.Key("Proto", "HTTP/1.1"),
 				),
 			},
 		},
@@ -900,11 +823,11 @@ func destinationRuleCases(apps *EchoDeployments) []TrafficTestCase {
 			config: idletimeoutDestinationRule("idletimeout-dr", destination.Config().Service),
 			call:   client[0].CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Target:    destination,
-				PortName:  "http",
-				Count:     1,
-				HTTP2:     true,
-				Validator: echo.ExpectOK(),
+				Target:   destination,
+				PortName: "http",
+				Count:    1,
+				HTTP2:    true,
+				Check:    check.OK(),
 			},
 			minIstioVersion: "1.10.0",
 		},
@@ -921,7 +844,7 @@ func trafficLoopCases(apps *EchoDeployments) []TrafficTestCase {
 				c, d, port := c, d, port
 				cases = append(cases, TrafficTestCase{
 					name: port,
-					call: func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoclient.ParsedResponses {
+					call: func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoClient.Responses {
 						dwl := d.WorkloadsOrFail(t)[0]
 						cwl := c.WorkloadsOrFail(t)[0]
 						resp, err := cwl.ForwardEcho(context.Background(), &epb.ForwardEchoRequest{
@@ -982,7 +905,7 @@ func autoPassthroughCases(apps *EchoDeployments) []TrafficTestCase {
 						},
 						ServerName: sni,
 						Alpn:       al,
-						Validator:  echo.ExpectError(),
+						Check:      check.Error(),
 						Timeout:    5 * time.Second,
 					},
 				},
@@ -1068,7 +991,7 @@ func gatewayCases() []TrafficTestCase {
 				Headers: map[string][]string{
 					"Host": {"foo.bar"},
 				},
-				Validator: echo.ExpectCode("404"),
+				Check: check.Code("404"),
 			},
 			setupOpts: noTarget,
 		},
@@ -1100,7 +1023,7 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Validator: echo.ExpectCode("301"),
+				Check: check.Code("301"),
 			},
 			setupOpts: fqdnHostHeader,
 		},
@@ -1162,7 +1085,7 @@ func gatewayCases() []TrafficTestCase {
 					// In real world, this may be set by a downstream LB that terminates the TLS
 					"X-Forwarded-Proto": {"https"},
 				},
-				Validator: echo.ExpectOK(),
+				Check: check.OK(),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1222,7 +1145,7 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Validator: echo.ExpectCode("301"),
+				Check: check.Code("301"),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1293,7 +1216,7 @@ func gatewayCases() []TrafficTestCase {
 					// In real world, this may be set by a downstream LB that terminates the TLS
 					"X-Forwarded-Proto": {"https"},
 				},
-				Validator: echo.ExpectCode("400"),
+				Check: check.Code("400"),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1332,7 +1255,9 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("Proto", "HTTP/1.1")),
+				Check: check.And(
+					check.OK(),
+					check.Key("Proto", "HTTP/1.1")),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1372,13 +1297,12 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Validator: echo.And(
-					echo.ExpectOK(),
+				Check: check.And(
+					check.OK(),
 					// Gateway doesn't implicitly use downstream
-					echo.ExpectKey("Proto", "HTTP/1.1"),
+					check.Key("Proto", "HTTP/1.1"),
 					// Regression test; if this is set it means the inbound sideacr is treating it as TCP
-					echo.ExpectKey("X-Envoy-Peer-Metadata", ""),
-				),
+					check.Key("X-Envoy-Peer-Metadata", "")),
 			},
 			setupOpts: fqdnHostHeader,
 			templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1430,13 +1354,12 @@ func gatewayCases() []TrafficTestCase {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Validator: echo.And(
-							echo.ExpectOK(),
+						Check: check.And(
+							check.OK(),
 							// We did configure to use client protocol
-							echo.ExpectKey("Proto", expectedProto),
+							check.Key("Proto", expectedProto),
 							// Regression test; if this is set it means the inbound sidecar is treating it as TCP
-							echo.ExpectKey("X-Envoy-Peer-Metadata", ""),
-						),
+							check.Key("X-Envoy-Peer-Metadata", "")),
 					},
 					setupOpts: fqdnHostHeader,
 					templateVars: func(_ echo.Callers, dests echo.Instances) map[string]interface{} {
@@ -1488,15 +1411,9 @@ func gatewayCases() []TrafficTestCase {
 					Port: &echo.Port{
 						Protocol: proto,
 					},
-					Validator: echo.And(
-						echo.ExpectOK(),
-						echo.ValidatorFunc(
-							func(response echoclient.ParsedResponses, _ error) error {
-								return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-									// We check a header is added to ensure our VS actually applied
-									return ExpectString(response.RawResponse["Istio-Custom-Header"], "user-defined-value", "request header")
-								})
-							})),
+					Check: check.And(
+						check.OK(),
+						check.WithInfo("request header", check.Key("Istio-Custom-Header", "user-defined-value"))),
 				},
 				// to keep tests fast, we only run the basic protocol test per-workload and scheme match once (per cluster)
 				targetFilters:    singleTarget,
@@ -1536,28 +1453,26 @@ func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
 					"X-Forwarded-For": {"56.5.6.7, 72.9.5.6, 98.1.2.3"},
 					"Host":            {fqdn},
 				},
-				Validator: echo.ValidatorFunc(
-					func(response echoclient.ParsedResponses, _ error) error {
-						return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-							externalAddress, ok := response.RawResponse["X-Envoy-External-Address"]
-							if !ok {
-								return fmt.Errorf("missing X-Envoy-External-Address Header")
-							}
-							if err := ExpectString(externalAddress, "72.9.5.6", "envoy-external-address header"); err != nil {
-								return err
-							}
-							xffHeader, ok := response.RawResponse["X-Forwarded-For"]
-							if !ok {
-								return fmt.Errorf("missing X-Forwarded-For Header")
-							}
+				Check: check.Each(
+					func(r echoClient.Response) error {
+						externalAddress, ok := r.RawResponse["X-Envoy-External-Address"]
+						if !ok {
+							return fmt.Errorf("missing X-Envoy-External-Address Header")
+						}
+						if err := ExpectString(externalAddress, "72.9.5.6", "envoy-external-address header"); err != nil {
+							return err
+						}
+						xffHeader, ok := r.RawResponse["X-Forwarded-For"]
+						if !ok {
+							return fmt.Errorf("missing X-Forwarded-For Header")
+						}
 
-							xffIPs := strings.Split(xffHeader, ",")
-							if len(xffIPs) != 4 {
-								return fmt.Errorf("did not receive expected 4 hosts in X-Forwarded-For header")
-							}
+						xffIPs := strings.Split(xffHeader, ",")
+						if len(xffIPs) != 4 {
+							return fmt.Errorf("did not receive expected 4 hosts in X-Forwarded-For header")
+						}
 
-							return ExpectString(strings.TrimSpace(xffIPs[1]), "72.9.5.6", "ip in xff header")
-						})
+						return ExpectString(strings.TrimSpace(xffIPs[1]), "72.9.5.6", "ip in xff header")
 					}),
 			},
 		})
@@ -1670,13 +1585,13 @@ function envoy_on_request(request_handle)
 			opts: echo.CallOptions{
 				PortName: "http",
 				Target:   apps.PodB[0],
-				Validator: echo.And(
-					echo.ExpectOK(),
-					echo.ExpectKey("X-Vhost-Inbound", "hello world"),
-					echo.ExpectKey("X-Vhost-Outbound", "hello world"),
-					echo.ExpectKey("X-Lua-Inbound", "hello world"),
-					echo.ExpectKey("X-Lua-Outbound", "hello world"),
-					echo.ExpectKey("Proto", "HTTP/2.0"),
+				Check: check.And(
+					check.OK(),
+					check.Key("X-Vhost-Inbound", "hello world"),
+					check.Key("X-Vhost-Outbound", "hello world"),
+					check.Key("X-Lua-Inbound", "hello world"),
+					check.Key("X-Lua-Outbound", "hello world"),
+					check.Key("Proto", "HTTP/2.0"),
 				),
 			},
 		})
@@ -1719,10 +1634,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallWithRetryOrFail,
 				opts: echo.CallOptions{
-					PortName:  "auto-http",
-					Target:    apps.Headless[0],
-					Headers:   HostHeader(h),
-					Validator: echo.ExpectOK(),
+					PortName: "auto-http",
+					Target:   apps.Headless[0],
+					Headers:  HostHeader(h),
+					Check:    check.OK(),
 				},
 			})
 		}
@@ -1748,10 +1663,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				name: name,
 				call: c.CallWithRetryOrFail,
 				opts: echo.CallOptions{
-					PortName:  "http",
-					Target:    apps.Headless[0],
-					Headers:   HostHeader(h),
-					Validator: echo.ExpectOK(),
+					PortName: "http",
+					Target:   apps.Headless[0],
+					Headers:  HostHeader(h),
+					Check:    check.OK(),
 				},
 			})
 		}
@@ -1795,11 +1710,11 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			config: svc,
 			call:   c.CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Count:     1,
-				Address:   "b-alt-1",
-				Port:      &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
-				Timeout:   time.Millisecond * 100,
-				Validator: echo.ExpectOK(),
+				Count:   1,
+				Address: "b-alt-1",
+				Port:    &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
+				Timeout: time.Millisecond * 100,
+				Check:   check.OK(),
 			},
 		})
 
@@ -1824,12 +1739,12 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			config: svc,
 			call:   c.CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Count:     1,
-				Address:   "b-alt-2",
-				Port:      &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.TCP},
-				Scheme:    scheme.TCP,
-				Timeout:   time.Millisecond * 100,
-				Validator: echo.ExpectOK(),
+				Count:   1,
+				Address: "b-alt-2",
+				Port:    &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.TCP},
+				Scheme:  scheme.TCP,
+				Timeout: time.Millisecond * 100,
+				Check:   check.OK(),
 			},
 		})
 
@@ -1853,11 +1768,11 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			config: svc,
 			call:   c.CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Count:     1,
-				Address:   "b-alt-3",
-				Port:      &echo.Port{ServicePort: 12345, Protocol: protocol.HTTP},
-				Timeout:   time.Millisecond * 100,
-				Validator: echo.ExpectOK(),
+				Count:   1,
+				Address: "b-alt-3",
+				Port:    &echo.Port{ServicePort: 12345, Protocol: protocol.HTTP},
+				Timeout: time.Millisecond * 100,
+				Check:   check.OK(),
 			},
 		})
 
@@ -1881,11 +1796,11 @@ func serviceCases(apps *EchoDeployments) []TrafficTestCase {
 			config: svc,
 			call:   c.CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Count:     1,
-				Address:   "b-alt-4",
-				Port:      &echo.Port{ServicePort: 12346, Protocol: protocol.HTTP},
-				Timeout:   time.Millisecond * 100,
-				Validator: echo.ExpectOK(),
+				Count:   1,
+				Address: "b-alt-4",
+				Port:    &echo.Port{ServicePort: 12346, Protocol: protocol.HTTP},
+				Timeout: time.Millisecond * 100,
+				Check:   check.OK(),
 			},
 		})
 	}
@@ -1957,15 +1872,15 @@ func consistentHashCases(apps *EchoDeployments) []TrafficTestCase {
 					Count:   10,
 					Address: svcName,
 					Port:    &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
-					Validator: echo.And(
-						echo.ExpectOK(),
-						echo.ValidatorFunc(func(responses echoclient.ParsedResponses, rerr error) error {
-							err := ConsistentHostValidator.Validate(responses, rerr)
+					Check: check.And(
+						check.OK(),
+						func(responses echoClient.Responses, rerr error) error {
+							err := ConsistentHostChecker.Check(responses, rerr)
 							if err == nil {
 								return fmt.Errorf("expected inconsistent hash, but it was consistent")
 							}
 							return nil
-						}),
+						},
 					),
 				},
 			})
@@ -1977,18 +1892,18 @@ func consistentHashCases(apps *EchoDeployments) []TrafficTestCase {
 				Path:    "/?some-query-param=bar",
 				Headers: headers,
 				Port:    &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
-				Validator: echo.And(
-					echo.ExpectOK(),
-					ConsistentHostValidator,
+				Check: check.And(
+					check.OK(),
+					ConsistentHostChecker,
 				),
 			}
 			tcpCallopts := echo.CallOptions{
 				Count:   10,
 				Address: svcName,
 				Port:    &echo.Port{ServicePort: FindPortByName("tcp").ServicePort, Protocol: protocol.TCP},
-				Validator: echo.And(
-					echo.ExpectOK(),
-					ConsistentHostValidator,
+				Check: check.And(
+					check.OK(),
+					ConsistentHostChecker,
 				),
 			}
 			if c.Config().Class() == echotypes.Proxyless {
@@ -2025,19 +1940,18 @@ func consistentHashCases(apps *EchoDeployments) []TrafficTestCase {
 	return cases
 }
 
-var ConsistentHostValidator echo.Validator = echo.ValidatorFunc(func(responses echoclient.ParsedResponses, _ error) error {
+var ConsistentHostChecker check.Checker = func(responses echoClient.Responses, _ error) error {
 	hostnames := make([]string, len(responses))
-	_ = responses.Check(func(i int, response *echoclient.ParsedResponse) error {
-		hostnames[i] = response.Hostname
-		return nil
-	})
+	for i, r := range responses {
+		hostnames[i] = r.Hostname
+	}
 	scopes.Framework.Infof("requests landed on hostnames: %v", hostnames)
 	unique := sets.NewSet(hostnames...).SortedList()
 	if len(unique) != 1 {
 		return fmt.Errorf("excepted only one destination, got: %v", unique)
 	}
 	return nil
-})
+}
 
 func flatten(clients ...[]echo.Instance) []echo.Instance {
 	instances := []echo.Instance{}
@@ -2055,9 +1969,11 @@ func selfCallsCases() []TrafficTestCase {
 			name:             "to service",
 			workloadAgnostic: true,
 			opts: echo.CallOptions{
-				Count:     1,
-				PortName:  "http",
-				Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("X-Envoy-Attempt-Count", "1")),
+				Count:    1,
+				PortName: "http",
+				Check: check.And(
+					check.OK(),
+					check.Key("X-Envoy-Attempt-Count", "1")),
 			},
 		},
 		// Localhost calls will go directly to localhost, bypassing Envoy. No envoy headers added.
@@ -2069,11 +1985,13 @@ func selfCallsCases() []TrafficTestCase {
 				opts.Target = nil
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Address:   "localhost",
-				Port:      &echo.Port{ServicePort: 8080},
-				Scheme:    scheme.HTTP,
-				Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("X-Envoy-Attempt-Count", "")),
+				Count:   1,
+				Address: "localhost",
+				Port:    &echo.Port{ServicePort: 8080},
+				Scheme:  scheme.HTTP,
+				Check: check.And(
+					check.OK(),
+					check.Key("X-Envoy-Attempt-Count", "")),
 			},
 		},
 		// PodIP calls will go directly to podIP, bypassing Envoy. No envoy headers added.
@@ -2088,10 +2006,12 @@ func selfCallsCases() []TrafficTestCase {
 				opts.Target = nil
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Scheme:    scheme.HTTP,
-				Port:      &echo.Port{ServicePort: 8080},
-				Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("X-Envoy-Attempt-Count", "")),
+				Count:  1,
+				Scheme: scheme.HTTP,
+				Port:   &echo.Port{ServicePort: 8080},
+				Check: check.And(
+					check.OK(),
+					check.Key("X-Envoy-Attempt-Count", "")),
 			},
 		},
 	}
@@ -2131,7 +2051,7 @@ type protocolCase struct {
 		{"auto-grpc", scheme.GRPC},
 	}
 
-	// so we can validate all clusters are hit
+	// so we can check all clusters are hit
 	for _, call := range protocols {
 		call := call
 		cases = append(cases, TrafficTestCase{
@@ -2144,15 +2064,15 @@ type protocolCase struct {
 				Scheme:   call.scheme,
 				Timeout:  time.Second * 5,
 			},
-			validate: func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) echo.Validator {
+			check: func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) check.Checker {
 				if call.scheme == scheme.TCP || src.(echo.Instance).Config().IsProxylessGRPC() {
 					// no host header for TCP
 					// TODO understand why proxyless adds the port to :authority md
-					return echo.ExpectOK()
+					return check.OK()
 				}
-				return echo.And(
-					echo.ExpectOK(),
-					echo.ExpectHost(opts.GetHost()))
+				return check.And(
+					check.OK(),
+					check.Host(opts.GetHost()))
 			},
 			comboFilters: func() []echotest.CombinationFilter {
 				if call.scheme != scheme.GRPC {
@@ -2237,7 +2157,7 @@ type protocolCase struct {
 			},
 		},
 	)
-	//validate: func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) echo.Validator {
+	//check: func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) echo.Validator {
 	//	if call.scheme == scheme.TCP || src.(echo.Instance).Config().IsProxylessGRPC() {
 	//		// no host header for TCP
 	//		// TODO understand why proxyless adds the port to :authority md
@@ -2386,12 +2306,12 @@ func instanceIPTests(apps *EchoDeployments) []TrafficTestCase {
 					call:   client.CallWithRetryOrFail,
 					config: config,
 					opts: echo.CallOptions{
-						Count:     1,
-						Target:    destination,
-						PortName:  ipCase.port,
-						Scheme:    scheme.HTTP,
-						Timeout:   time.Second * 5,
-						Validator: echo.ExpectCode(fmt.Sprint(ipCase.code)),
+						Count:    1,
+						Target:   destination,
+						PortName: ipCase.port,
+						Scheme:   scheme.HTTP,
+						Timeout:  time.Second * 5,
+						Check:    check.Code(fmt.Sprint(ipCase.code)),
 					},
 					minIstioVersion: ipCase.minIstioVersion,
 				})
@@ -2508,27 +2428,26 @@ func DNSTestCases(apps *EchoDeployments, cniEnabled bool) []TrafficTestCase {
 			if tt.server != "" {
 				address += "&server=" + tt.server
 			}
-			var validator echo.Validator = echo.ValidatorFunc(
-				func(response echoclient.ParsedResponses, _ error) error {
-					return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-						if !reflect.DeepEqual(response.ResponseBody(), tt.expected) {
-							return fmt.Errorf("unexpected dns response: wanted %v, got %v", tt.expected, response.ResponseBody())
-						}
-						return nil
-					})
-				})
+			var checker check.Checker = func(responses echoClient.Responses, _ error) error {
+				for _, r := range responses {
+					if !reflect.DeepEqual(r.ResponseBody(), tt.expected) {
+						return fmt.Errorf("unexpected dns response: wanted %v, got %v", tt.expected, r.ResponseBody())
+					}
+				}
+				return nil
+			}
 			if tt.expected == nil {
-				validator = echo.ExpectError()
+				checker = check.Error()
 			}
 			tcases = append(tcases, TrafficTestCase{
 				name:   fmt.Sprintf("%s/%s", client.Config().Service, tt.name),
 				config: makeSE(tt.ips),
 				call:   client.CallWithRetryOrFail,
 				opts: echo.CallOptions{
-					Scheme:    scheme.DNS,
-					Count:     1,
-					Address:   address,
-					Validator: validator,
+					Scheme:  scheme.DNS,
+					Count:   1,
+					Address: address,
+					Check:   checker,
 				},
 			})
 		}
@@ -2570,21 +2489,20 @@ func(response echoclient.ParsedResponses, _ error) error {
 					Count:   1,
 					Scheme:  scheme.DNS,
 					Address: address,
-					Validator: echo.ValidatorFunc(
-						func(response echoclient.ParsedResponses, _ error) error {
-							return response.Check(func(_ int, response *echoclient.ParsedResponse) error {
-								ips := []string{}
-								for _, v := range response.RawResponse {
-									ips = append(ips, v)
-								}
-								sort.Strings(ips)
-								exp := []string{expected}
-								if !reflect.DeepEqual(ips, exp) {
-									return fmt.Errorf("unexpected dns response: wanted %v, got %v", exp, ips)
-								}
-								return nil
-							})
-						}),
+					Check: func(responses echoClient.Responses, _ error) error {
+						for _, r := range responses {
+							ips := []string{}
+							for _, v := range r.RawResponse {
+								ips = append(ips, v)
+							}
+							sort.Strings(ips)
+							exp := []string{expected}
+							if !reflect.DeepEqual(ips, exp) {
+								return fmt.Errorf("unexpected dns response: wanted %v, got %v", exp, ips)
+							}
+						}
+						return nil
+					},
 				},
 			})
 		}
@@ -2664,21 +2582,21 @@ func VMTestCases(vms echo.Instances, apps *EchoDeployments) []TrafficTestCase {
 	cases := make([]TrafficTestCase, 0)
 	for _, c := range testCases {
 		c := c
-		validators := []echo.Validator{echo.ExpectOK()}
+		checker := check.OK()
 		if !c.to.ContainsMatch(echo.IsHeadless()) {
 			// headless load-balancing can be inconsistent
-			validators = append(validators, echo.ExpectReachedClusters(c.to.Clusters()))
+			checker = check.And(checker, check.ReachedClusters(c.to.Clusters()))
 		}
 		cases = append(cases, TrafficTestCase{
 			name: fmt.Sprintf("%s from %s", c.name, c.from.Config().Cluster.StableName()),
 			call: c.from.CallWithRetryOrFail,
 			opts: echo.CallOptions{
 				// assume that all echos in `to` only differ in which cluster they're deployed in
-				Target:    c.to[0],
-				PortName:  "http",
-				Address:   c.host,
-				Count:     callsPerCluster * len(c.to),
-				Validator: echo.And(validators...),
+				Target:   c.to[0],
+				PortName: "http",
+				Address:  c.host,
+				Count:    callsPerCluster * len(c.to),
+				Check:    checker,
 			},
 		})
 	}
@@ -2767,38 +2685,38 @@ func serverFirstTestCases(apps *EchoDeployments) []TrafficTestCase {
 	clients := apps.PodA
 	destination := apps.PodC[0]
 	configs := []struct {
-		port      string
-		dest      string
-		auth      string
-		validator echo.Validator
+		port    string
+		dest    string
+		auth    string
+		checker check.Checker
 	}{
 		// TODO: All these cases *should* succeed (except the TLS mismatch cases) - but don't due to issues in our implementation
 
 		// For auto port, outbound request will be delayed by the protocol sniffer, regardless of configuration
-		{"auto-tcp-server", "DISABLE", "DISABLE", echo.ExpectError()},
-		{"auto-tcp-server", "DISABLE", "PERMISSIVE", echo.ExpectError()},
-		{"auto-tcp-server", "DISABLE", "STRICT", echo.ExpectError()},
-		{"auto-tcp-server", "ISTIO_MUTUAL", "DISABLE", echo.ExpectError()},
-		{"auto-tcp-server", "ISTIO_MUTUAL", "PERMISSIVE", echo.ExpectError()},
-		{"auto-tcp-server", "ISTIO_MUTUAL", "STRICT", echo.ExpectError()},
+		{"auto-tcp-server", "DISABLE", "DISABLE", check.Error()},
+		{"auto-tcp-server", "DISABLE", "PERMISSIVE", check.Error()},
+		{"auto-tcp-server", "DISABLE", "STRICT", check.Error()},
+		{"auto-tcp-server", "ISTIO_MUTUAL", "DISABLE", check.Error()},
+		{"auto-tcp-server", "ISTIO_MUTUAL", "PERMISSIVE", check.Error()},
+		{"auto-tcp-server", "ISTIO_MUTUAL", "STRICT", check.Error()},
 
 		// These is broken because we will still enable inbound sniffing for the port. Since there is no tls,
 		// there is no server-first "upgrading" to client-first
-		{"tcp-server", "DISABLE", "DISABLE", echo.ExpectOK()},
-		{"tcp-server", "DISABLE", "PERMISSIVE", echo.ExpectError()},
+		{"tcp-server", "DISABLE", "DISABLE", check.OK()},
+		{"tcp-server", "DISABLE", "PERMISSIVE", check.Error()},
 
 		// Expected to fail, incompatible configuration
-		{"tcp-server", "DISABLE", "STRICT", echo.ExpectError()},
-		{"tcp-server", "ISTIO_MUTUAL", "DISABLE", echo.ExpectError()},
+		{"tcp-server", "DISABLE", "STRICT", check.Error()},
+		{"tcp-server", "ISTIO_MUTUAL", "DISABLE", check.Error()},
 
 		// In these cases, we expect success
 		// There is no sniffer on either side
-		{"tcp-server", "DISABLE", "DISABLE", echo.ExpectOK()},
+		{"tcp-server", "DISABLE", "DISABLE", check.OK()},
 
 		// On outbound, we have no sniffer involved
 		// On inbound, the request is TLS, so its not server first
-		{"tcp-server", "ISTIO_MUTUAL", "PERMISSIVE", echo.ExpectOK()},
-		{"tcp-server", "ISTIO_MUTUAL", "STRICT", echo.ExpectOK()},
+		{"tcp-server", "ISTIO_MUTUAL", "PERMISSIVE", check.OK()},
+		{"tcp-server", "ISTIO_MUTUAL", "STRICT", check.OK()},
 	}
 	for _, client := range clients {
 		for _, c := range configs {
@@ -2813,9 +2731,9 @@ func serverFirstTestCases(apps *EchoDeployments) []TrafficTestCase {
 					PortName: c.port,
 					Scheme:   scheme.TCP,
 					// Inbound timeout is 1s. We want to test this does not hit the listener filter timeout
-					Timeout:   time.Millisecond * 100,
-					Count:     1,
-					Validator: c.validator,
+					Timeout: time.Millisecond * 100,
+					Count:   1,
+					Check:   c.checker,
 				},
 			})
 		}
@@ -2918,11 +2836,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("200"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("200"),
 			},
 		},
 		{
@@ -2937,11 +2855,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("200"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("200"),
 			},
 		},
 		{
@@ -2959,11 +2877,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("200"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("200"),
 			},
 		},
 		{
@@ -2978,11 +2896,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("200"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("200"),
 			},
 		},
 		{
@@ -2997,11 +2915,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("404"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("404"),
 			},
 		},
 		{
@@ -3017,11 +2935,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("200"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("200"),
 			},
 		},
 		{
@@ -3039,11 +2957,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("404"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("404"),
 			},
 		},
 		{
@@ -3058,11 +2976,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("404"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("404"),
 			},
 		},
 		{
@@ -3077,11 +2995,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headersWithInvalidToken,
-				Validator: echo.ExpectCode("401"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headersWithInvalidToken,
+				Check:    check.Code("401"),
 			},
 		},
 		{
@@ -3096,11 +3014,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headersWithNoToken,
-				Validator: echo.ExpectCode("404"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headersWithNoToken,
+				Check:    check.Code("404"),
 			},
 		},
 		{
@@ -3119,8 +3037,8 @@ type configData struct {
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
 				// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
-				Headers:   headersWithNoTokenButSameHeader,
-				Validator: echo.ExpectCode("404"),
+				Headers: headersWithNoTokenButSameHeader,
+				Check:   check.Code("404"),
 			},
 		},
 		{
@@ -3135,11 +3053,11 @@ type configData struct {
 				}
 			},
 			opts: echo.CallOptions{
-				Count:     1,
-				Port:      &echo.Port{Protocol: protocol.HTTP},
-				PortName:  "http",
-				Headers:   headers,
-				Validator: echo.ExpectCode("404"),
+				Count:    1,
+				Port:     &echo.Port{Protocol: protocol.HTTP},
+				PortName: "http",
+				Headers:  headers,
+				Check:    check.Code("404"),
 			},
 		},
 	}
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index 000b1670e9..7ea624164d 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -21,7 +21,8 @@
 	"fmt"
 
 	"istio.io/istio/pkg/test"
-	echoclient "istio.io/istio/pkg/test/echo/client"
+	echoclient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
@@ -39,7 +40,7 @@
 
 type TrafficCall struct {
 	name string
-	call func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoclient.ParsedResponses
+	call func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoclient.Responses
 	opts echo.CallOptions
 }
 
@@ -52,14 +53,14 @@ type TrafficTestCase struct {
 	children []TrafficCall
 
 	// Single call. Cannot be used with children or workloadAgnostic tests.
-	call func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoclient.ParsedResponses
+	call func(t test.Failer, options echo.CallOptions, retryOptions ...retry.Option) echoclient.Responses
 	// opts specifies the echo call options. When using RunForApps, the Target will be set dynamically.
 	opts echo.CallOptions
 	// setupOpts allows modifying options based on sources/destinations
 	setupOpts func(src echo.Caller, dest echo.Instances, opts *echo.CallOptions)
-	// validate is used to build validators dynamically when using RunForApps based on the active/src dest pair
-	validate     func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) echo.Validator
-	validateForN func(src echo.Caller, dst echo.Services, opts *echo.CallOptions) echo.Validator
+	// check is used to build validators dynamically when using RunForApps based on the active/src dest pair
+	check     func(src echo.Caller, dst echo.Instances, opts *echo.CallOptions) check.Checker
+	checkForN func(src echo.Caller, dst echo.Services, opts *echo.CallOptions) check.Checker
 
 	// setting cases to skipped is better than not adding them - gives visibility to what needs to be fixed
 	skip bool
@@ -146,11 +147,11 @@ func (c TrafficTestCase) RunForApps(t framework.TestContext, apps echo.Instances
 			buildOpts := func(options echo.CallOptions) echo.CallOptions {
 				opts := options
 				opts.Target = dsts[0][0]
-				if c.validate != nil {
-					opts.Validator = c.validate(src, dsts[0], &opts)
+				if c.check != nil {
+					opts.Check = c.check(src, dsts[0], &opts)
 				}
-				if c.validateForN != nil {
-					opts.Validator = c.validateForN(src, dsts, &opts)
+				if c.checkForN != nil {
+					opts.Check = c.checkForN(src, dsts, &opts)
 				}
 				if opts.Count == 0 {
 					opts.Count = callsPerCluster * len(dsts) * len(dsts[0])
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index f4638b9a3c..66b2ff9ad1 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -31,6 +31,8 @@
 
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pkg/config/protocol"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -218,10 +220,12 @@ func TestGateway(t *testing.T) {
 					})
 					t.NewSubTest("mesh").Run(func(t framework.TestContext) {
 						_ = apps.PodA[0].CallWithRetryOrFail(t, echo.CallOptions{
-							Target:    apps.PodB[0],
-							PortName:  "http",
-							Path:      "/path",
-							Validator: echo.And(echo.ExpectOK(), echo.ExpectKey("My-Added-Header", "added-value")),
+							Target:   apps.PodB[0],
+							PortName: "http",
+							Path:     "/path",
+							Check: check.And(
+								check.OK(),
+								check.Key("My-Added-Header", "added-value")),
 						})
 					})
 					t.NewSubTest("status").Run(func(t framework.TestContext) {
@@ -268,8 +272,8 @@ func TestGateway(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"bar.example.com"},
 						},
-						Address:   fmt.Sprintf("gateway.%s.svc.cluster.local", apps.Namespace.Name()),
-						Validator: echo.ExpectOK(),
+						Address: fmt.Sprintf("gateway.%s.svc.cluster.local", apps.Namespace.Name()),
+						Check:   check.OK(),
 					}, retry.Timeout(time.Minute))
 				})
 			}
@@ -374,8 +378,8 @@ func TestIngress(t *testing.T) {
 `
 			}
 
-			successValidator := echo.And(echo.ExpectOK(), echo.ExpectReachedClusters(apps.PodB.Clusters()))
-			failureValidator := echo.ExpectCode("404")
+			successChecker := check.And(check.OK(), check.ReachedClusters(apps.PodB.Clusters()))
+			failureChecker := check.Code("404")
 			count := 1
 			if t.Clusters().IsMulticluster() {
 				count = 2 * len(t.Clusters())
@@ -398,8 +402,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: successValidator,
-						Count:     count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -415,8 +419,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: successValidator,
-						Count:     count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix/should",
@@ -432,8 +436,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: successValidator,
-						Count:     count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix/test/",
@@ -449,8 +453,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: successValidator,
-						Count:     count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix/test",
@@ -466,8 +470,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: failureValidator,
-						Count:     count,
+						Check: failureChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix/test",
@@ -483,8 +487,8 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: successValidator,
-						Count:     count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/",
@@ -500,9 +504,9 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"foo.example.com"},
 						},
-						CaCert:    ingressutil.IngressCredentialA.CaCert,
-						Validator: successValidator,
-						Count:     count,
+						CaCert: ingressutil.IngressCredentialA.CaCert,
+						Check:  successChecker,
+						Count:  count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -518,9 +522,9 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"bar.example.com"},
 						},
-						CaCert:    ingressutil.IngressCredentialB.CaCert,
-						Validator: successValidator,
-						Count:     count,
+						CaCert: ingressutil.IngressCredentialB.CaCert,
+						Check:  successChecker,
+						Count:  count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -536,9 +540,9 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"bar.example.com"},
 						},
-						CaCert:    ingressutil.IngressCredentialB.CaCert,
-						Validator: successValidator,
-						Count:     count,
+						CaCert: ingressutil.IngressCredentialB.CaCert,
+						Check:  successChecker,
+						Count:  count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -634,7 +638,13 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: echo.Or(echo.ExpectError(), echo.ExpectCode("404")),
+						Check: func(rs echoClient.Responses, err error) error {
+							if err != nil {
+								return nil
+							}
+
+							return check.Code("404").Check(rs, nil)
+						},
 					},
 				},
 				{
@@ -649,7 +659,7 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: echo.ExpectCode("200"),
+						Check: check.Code("200"),
 					},
 				},
 				{
@@ -664,7 +674,7 @@ func TestIngress(t *testing.T) {
 						Headers: map[string][]string{
 							"Host": {"server"},
 						},
-						Validator: echo.ExpectCode("200"),
+						Check: check.Code("200"),
 					},
 				},
 			}
@@ -776,10 +786,10 @@ func TestCustomGateway(t *testing.T) {
 					return err
 				}, retry.Timeout(time.Minute*2))
 				apps.PodB[0].CallWithRetryOrFail(t, echo.CallOptions{
-					Port:      &echo.Port{ServicePort: 80},
-					Scheme:    scheme.HTTP,
-					Address:   fmt.Sprintf("custom-gateway.%s.svc.cluster.local", gatewayNs.Name()),
-					Validator: echo.ExpectOK(),
+					Port:    &echo.Port{ServicePort: 80},
+					Scheme:  scheme.HTTP,
+					Address: fmt.Sprintf("custom-gateway.%s.svc.cluster.local", gatewayNs.Name()),
+					Check:   check.OK(),
 				})
 			})
 			// TODO we could add istioctl as well, but the framework adds a bunch of stuff beyond just `istioctl install`
@@ -849,10 +859,10 @@ func TestCustomGateway(t *testing.T) {
           number: 80
 `, apps.PodA[0].Config().ClusterLocalFQDN()))
 				apps.PodB[0].CallWithRetryOrFail(t, echo.CallOptions{
-					Port:      &echo.Port{ServicePort: 80},
-					Scheme:    scheme.HTTP,
-					Address:   fmt.Sprintf("custom-gateway-helm.%s.svc.cluster.local", gatewayNs.Name()),
-					Validator: echo.ExpectOK(),
+					Port:    &echo.Port{ServicePort: 80},
+					Scheme:  scheme.HTTP,
+					Address: fmt.Sprintf("custom-gateway-helm.%s.svc.cluster.local", gatewayNs.Name()),
+					Check:   check.OK(),
 				})
 			})
 			t.NewSubTest("helm-simple").Run(func(t framework.TestContext) {
@@ -916,10 +926,10 @@ func TestCustomGateway(t *testing.T) {
           number: 80
 `, apps.PodA[0].Config().ClusterLocalFQDN()))
 				apps.PodB[0].CallWithRetryOrFail(t, echo.CallOptions{
-					Port:      &echo.Port{ServicePort: 80},
-					Scheme:    scheme.HTTP,
-					Address:   fmt.Sprintf("helm-simple.%s.svc.cluster.local", gatewayNs.Name()),
-					Validator: echo.ExpectOK(),
+					Port:    &echo.Port{ServicePort: 80},
+					Scheme:  scheme.HTTP,
+					Address: fmt.Sprintf("helm-simple.%s.svc.cluster.local", gatewayNs.Name()),
+					Check:   check.OK(),
 				})
 			})
 		})
diff --git a/tests/integration/pilot/locality_test.go b/tests/integration/pilot/locality_test.go
index 4e09fc4000..7bf889cf26 100644
--- a/tests/integration/pilot/locality_test.go
+++ b/tests/integration/pilot/locality_test.go
@@ -28,7 +28,7 @@
 	"github.com/Masterminds/sprig/v3"
 
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/scopes"
@@ -227,7 +227,7 @@ func sendTrafficOrFail(t framework.TestContext, from echo.Instance, host string,
 	t.Helper()
 	headers := http.Header{}
 	headers.Add("Host", host)
-	validator := echo.ValidatorFunc(func(resp client.ParsedResponses, inErr error) error {
+	checker := func(resp echoClient.Responses, inErr error) error {
 		if inErr != nil {
 			return inErr
 		}
@@ -249,15 +249,15 @@ func sendTrafficOrFail(t framework.TestContext, from echo.Instance, host string,
 			}
 		}
 		return nil
-	})
+	}
 	// This is a hack to remain infrastructure agnostic when running these tests
 	// We actually call the host set above not the endpoint we pass
 	_ = from.CallWithRetryOrFail(t, echo.CallOptions{
-		Target:    from,
-		PortName:  "http",
-		Headers:   headers,
-		Count:     sendCount,
-		Validator: validator,
+		Target:   from,
+		PortName: "http",
+		Headers:  headers,
+		Count:    sendCount,
+		Check:    checker,
 	})
 }
 
diff --git a/tests/integration/pilot/mcs/discoverability/discoverability_test.go b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
index 0ec7ced8b4..8b8673a43a 100644
--- a/tests/integration/pilot/mcs/discoverability/discoverability_test.go
+++ b/tests/integration/pilot/mcs/discoverability/discoverability_test.go
@@ -40,7 +40,8 @@
 	"istio.io/api/annotation"
 	kube "istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
 	"istio.io/istio/pkg/kube/mcs"
-	echoClient "istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -98,17 +99,17 @@ func TestClusterLocal(t *testing.T) {
 			for _, ht := range hostTypes {
 				t.NewSubTest(ht.String()).Run(func(t framework.TestContext) {
 					runForAllClusterCombinations(t, func(t framework.TestContext, src echo.Instance, dst echo.Instances) {
-						var validator echo.Validator
+						var checker check.Checker
 						if ht == hostTypeClusterLocal {
 							// For calls to cluster.local, ensure that all requests stay in the same cluster
 							expectedClusters := cluster.Clusters{src.Config().Cluster}
-							validator = validateClustersReached(expectedClusters)
+							checker = checkClustersReached(expectedClusters)
 						} else {
 							// For calls to clusterset.local, we should fail DNS lookup. The clusterset.local host
 							// is only available for a service when it is exported in at least one cluster.
-							validator = validateDNSLookupFailed()
+							checker = checkDNSLookupFailed()
 						}
-						callAndValidate(t, ht, src, dst, validator)
+						callAndValidate(t, ht, src, dst, checker)
 					})
 				})
 			}
@@ -133,7 +134,7 @@ func TestMeshWide(t *testing.T) {
 							// Ensure that requests to clusterset.local reach all destination clusters.
 							expectedClusters = dst.Clusters()
 						}
-						callAndValidate(t, ht, src, dst, validateClustersReached(expectedClusters))
+						callAndValidate(t, ht, src, dst, checkClustersReached(expectedClusters))
 					})
 				})
 			}
@@ -174,7 +175,7 @@ func TestServiceExportedInOneCluster(t *testing.T) {
 											expectedClusters = append(expectedClusters, src.Config().Cluster)
 										}
 									}
-									callAndValidate(t, ht, src, dst, validateClustersReached(expectedClusters))
+									callAndValidate(t, ht, src, dst, checkClustersReached(expectedClusters))
 								})
 							})
 						}
@@ -222,20 +223,24 @@ func newServiceExport(service string, serviceExportGVR schema.GroupVersionResour
 	}
 }
 
-func validateClustersReached(clusters cluster.Clusters) echo.Validator {
-	return echo.And(echo.ExpectOK(), echo.ExpectReachedClusters(clusters))
+func checkClustersReached(clusters cluster.Clusters) check.Checker {
+	return check.And(
+		check.OK(),
+		check.ReachedClusters(clusters))
 }
 
-func validateDNSLookupFailed() echo.Validator {
-	return echo.And(echo.ExpectError(), echo.ValidatorFunc(func(_ echoClient.ParsedResponses, err error) error {
-		if strings.Contains(err.Error(), "no such host") {
-			return nil
-		}
-		return err
-	}))
+func checkDNSLookupFailed() check.Checker {
+	return check.And(
+		check.Error(),
+		func(_ echoClient.Responses, err error) error {
+			if strings.Contains(err.Error(), "no such host") {
+				return nil
+			}
+			return err
+		})
 }
 
-func callAndValidate(t framework.TestContext, ht hostType, src echo.Instance, dst echo.Instances, validator echo.Validator) {
+func callAndValidate(t framework.TestContext, ht hostType, src echo.Instance, dst echo.Instances, checker check.Checker) {
 	t.Helper()
 
 	dest := dst[0]
@@ -249,11 +254,11 @@ func callAndValidate(t framework.TestContext, ht hostType, src echo.Instance, ds
 	}
 
 	_, err := src.CallWithRetry(echo.CallOptions{
-		Address:   address,
-		Target:    dest,
-		Count:     requestCountMultiplier * len(dst),
-		PortName:  "http",
-		Validator: validator,
+		Address:  address,
+		Target:   dest,
+		Count:    requestCountMultiplier * len(dst),
+		PortName: "http",
+		Check:    checker,
 	}, retryDelay, retryTimeout)
 	if err != nil {
 		t.Fatalf("failed calling host %s: %v\nCluster Details:\n%s", address, err,
diff --git a/tests/integration/pilot/multi_version_revision_test.go b/tests/integration/pilot/multi_version_revision_test.go
index fd2e421245..bbd13cb259 100644
--- a/tests/integration/pilot/multi_version_revision_test.go
+++ b/tests/integration/pilot/multi_version_revision_test.go
@@ -25,6 +25,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -143,10 +144,9 @@ func testAllEchoCalls(t framework.TestContext, echoInstances []echo.Instance) {
 								Target:   dest,
 								PortName: trafficType,
 							})
-							if err != nil {
-								return err
-							}
-							return resp.CheckOK()
+							return check.And(
+								check.NoError(),
+								check.OK()).Check(resp, err)
 						}, retry.Delay(time.Millisecond*150))
 					})
 			}
diff --git a/tests/integration/pilot/multicluster_test.go b/tests/integration/pilot/multicluster_test.go
index 99b450dc4e..d18fe0bf92 100644
--- a/tests/integration/pilot/multicluster_test.go
+++ b/tests/integration/pilot/multicluster_test.go
@@ -26,6 +26,7 @@
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -126,9 +127,9 @@ func(t framework.TestContext) {
 								Count:    multiclusterRequestCountMultiplier * len(destination),
 								PortName: "http",
 								Scheme:   scheme.HTTP,
-								Validator: echo.And(
-									echo.ExpectOK(),
-									echo.ExpectReachedClusters(cluster.Clusters{source.Config().Cluster}),
+								Check: check.And(
+									check.OK(),
+									check.ReachedClusters(cluster.Clusters{source.Config().Cluster}),
 								),
 							}, multiclusterRetryDelay, multiclusterRetryTimeout)
 						})
@@ -146,9 +147,9 @@ func(t framework.TestContext) {
 							Count:    multiclusterRequestCountMultiplier * len(destination),
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Validator: echo.And(
-								echo.ExpectOK(),
-								echo.ExpectReachedClusters(destination.Clusters()),
+							Check: check.And(
+								check.OK(),
+								check.ReachedClusters(destination.Clusters()),
 							),
 						}, multiclusterRetryDelay, multiclusterRetryTimeout)
 					})
diff --git a/tests/integration/pilot/original_src_addr_test.go b/tests/integration/pilot/original_src_addr_test.go
index 2827c321cc..1a1d0b47ff 100644
--- a/tests/integration/pilot/original_src_addr_test.go
+++ b/tests/integration/pilot/original_src_addr_test.go
@@ -21,7 +21,7 @@
 	"fmt"
 	"testing"
 
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -52,7 +52,7 @@ func TestTproxy(t *testing.T) {
 
 func checkOriginalSrcIP(t framework.TestContext, src echo.Caller, dest echo.Instance, expected []string) {
 	t.Helper()
-	validator := echo.ValidatorFunc(func(resp client.ParsedResponses, inErr error) error {
+	checker := func(resp echoClient.Responses, inErr error) error {
 		// Check that each response saw one of the workload IPs for the src echo instance
 		for _, r := range resp {
 			found := false
@@ -68,12 +68,12 @@ func checkOriginalSrcIP(t framework.TestContext, src echo.Caller, dest echo.Inst
 		}
 
 		return nil
-	})
+	}
 	_ = src.CallWithRetryOrFail(t, echo.CallOptions{
-		Target:    dest,
-		PortName:  "http",
-		Scheme:    scheme.HTTP,
-		Count:     1,
-		Validator: validator,
+		Target:   dest,
+		PortName: "http",
+		Scheme:   scheme.HTTP,
+		Count:    1,
+		Check:    checker,
 	})
 }
diff --git a/tests/integration/pilot/revisions/revisions_test.go b/tests/integration/pilot/revisions/revisions_test.go
index 47660975dd..0f4a416903 100644
--- a/tests/integration/pilot/revisions/revisions_test.go
+++ b/tests/integration/pilot/revisions/revisions_test.go
@@ -22,6 +22,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
@@ -111,15 +112,14 @@ func TestMultiRevision(t *testing.T) {
 							Target:   dst[0],
 							PortName: "http",
 							Count:    len(t.Clusters()) * 3,
-							Validator: echo.And(
-								echo.ExpectOK(),
-								echo.ExpectReachedClusters(t.Clusters()),
+							Check: check.And(
+								check.OK(),
+								check.ReachedClusters(t.Clusters()),
 							),
 						})
-						if err != nil {
-							return err
-						}
-						return resp.CheckOK()
+						return check.And(
+							check.NoError(),
+							check.OK()).Check(resp, err)
 					}, retry.Delay(time.Millisecond*100))
 				})
 		})
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 17bd3329c1..39b18810b7 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -30,6 +30,7 @@
 	"istio.io/client-go/pkg/apis/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/controller/workloadentry"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	echocommon "istio.io/istio/pkg/test/framework/components/echo/common"
@@ -111,10 +112,9 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 			t.NewSubTest("initial registration").Run(func(t framework.TestContext) {
 				retry.UntilSuccessOrFail(t, func() error {
 					res, err := client.Call(echo.CallOptions{Target: autoVM, Port: &autoVM.Config().Ports[0]})
-					if err != nil {
-						return err
-					}
-					return res.CheckOK()
+					return check.And(
+						check.NoError(),
+						check.OK()).Check(res, err)
 				}, retry.Timeout(15*time.Second))
 			})
 			t.NewSubTest("reconnect reuses WorkloadEntry").Run(func(t framework.TestContext) {
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 6f47b8ca06..1a8fc3b1fd 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -25,7 +25,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoclient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework"
@@ -731,7 +731,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name: "allow path to company.com",
 							path: "/allow",
-							code: response.StatusCodeOK,
+							code: echoclient.StatusCodeOK,
 							body: "handled-by-egress-gateway",
 							host: "www.company.com",
 							from: getWorkload(a[0], t),
@@ -739,7 +739,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name: "deny path to company.com",
 							path: "/deny",
-							code: response.StatusCodeForbidden,
+							code: echoclient.StatusCodeForbidden,
 							body: "RBAC: access denied",
 							host: "www.company.com",
 							from: getWorkload(a[0], t),
@@ -747,7 +747,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name: "allow service account a to a-only.com over mTLS",
 							path: "/",
-							code: response.StatusCodeOK,
+							code: echoclient.StatusCodeOK,
 							body: "handled-by-egress-gateway",
 							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
 							from: getWorkload(a[0], t),
@@ -755,7 +755,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name: "deny service account b to a-only.com over mTLS",
 							path: "/",
-							code: response.StatusCodeForbidden,
+							code: echoclient.StatusCodeForbidden,
 							body: "RBAC: access denied",
 							host: fmt.Sprintf("%s-only.com", a[0].Config().Service),
 							from: getWorkload(c[0], t),
@@ -763,7 +763,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "allow a with JWT to jwt-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeOK,
+							code:  echoclient.StatusCodeOK,
 							body:  "handled-by-egress-gateway",
 							host:  "jwt-only.com",
 							from:  getWorkload(a[0], t),
@@ -772,7 +772,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "allow b with JWT to jwt-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeOK,
+							code:  echoclient.StatusCodeOK,
 							body:  "handled-by-egress-gateway",
 							host:  "jwt-only.com",
 							from:  getWorkload(c[0], t),
@@ -781,7 +781,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "deny b with wrong JWT to jwt-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeForbidden,
+							code:  echoclient.StatusCodeForbidden,
 							body:  "RBAC: access denied",
 							host:  "jwt-only.com",
 							from:  getWorkload(c[0], t),
@@ -790,7 +790,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "allow service account a with JWT to jwt-and-a-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeOK,
+							code:  echoclient.StatusCodeOK,
 							body:  "handled-by-egress-gateway",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
 							from:  getWorkload(a[0], t),
@@ -799,7 +799,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "deny service account c with JWT to jwt-and-a-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeForbidden,
+							code:  echoclient.StatusCodeForbidden,
 							body:  "RBAC: access denied",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
 							from:  getWorkload(c[0], t),
@@ -808,7 +808,7 @@ func TestAuthorization_EgressGateway(t *testing.T) {
 						{
 							name:  "deny service account a with wrong JWT to jwt-and-a-only.com over mTLS",
 							path:  "/",
-							code:  response.StatusCodeForbidden,
+							code:  echoclient.StatusCodeForbidden,
 							body:  "RBAC: access denied",
 							host:  fmt.Sprintf("jwt-and-%s-only.com", a[0].Config().Service),
 							from:  getWorkload(a[0], t),
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index 9e06430530..cd7d307870 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -27,7 +27,8 @@
 	"testing"
 	"time"
 
-	client2 "istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/env"
@@ -143,7 +144,7 @@ func(ctx framework.TestContext) {
 								Key:      trustDomains[td].key,
 							}
 							retry.UntilSuccessOrFail(t, func() error {
-								var resp client2.ParsedResponses
+								var resp echoClient.Responses
 								var err error
 								if port == passThrough {
 									// Manually make the request for pass through port.
@@ -159,7 +160,7 @@ func(ctx framework.TestContext) {
 								if allow {
 									if err != nil {
 										return fmt.Errorf("want allow but got error: %v", err)
-									} else if err := resp.CheckOK(); err != nil {
+									} else if err := check.OK().Check(resp, nil); err != nil {
 										return fmt.Errorf("want allow but got %v: %v", resp, err)
 									}
 								} else {
diff --git a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
index b525aab79b..1ff94afa49 100644
--- a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
+++ b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
@@ -23,6 +23,7 @@
 	"strings"
 	"testing"
 
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -70,11 +71,11 @@ func TestStrictMTLS(t *testing.T) {
 			t.ConfigIstio().WaitForConfigOrFail(t, t, apps.Namespace.Name(), drTemplate)
 
 			apps.Client.CallWithRetryOrFail(t, echo.CallOptions{
-				Target:    apps.Server,
-				PortName:  "http",
-				Scheme:    scheme.HTTP,
-				Count:     1,
-				Validator: echo.ExpectOK(),
+				Target:   apps.Server,
+				PortName: "http",
+				Scheme:   scheme.HTTP,
+				Count:    1,
+				Check:    check.OK(),
 			})
 
 			certPEMs := cert.DumpCertFromSidecar(t, apps.Client, apps.Server, "http")
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 1df3a60595..bdbd6dcedd 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -25,8 +25,8 @@
 	"testing"
 
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -74,7 +74,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// This root certificate can validate the server cert presented by the echoboot server instance.
 				{
 					Name:            "simple",
-					Response:        response.StatusCodeOK,
+					Response:        echoClient.StatusCodeOK,
 					CredentialToUse: strings.TrimSuffix(credName, "-cacert"),
 					Gateway:         true,
 				},
@@ -82,7 +82,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// This root certificate cannot validate the server cert presented by the echoboot server instance.
 				{
 					Name:            "fake root",
-					Response:        response.StatusCodeUnavailable,
+					Response:        echoClient.StatusCodeUnavailable,
 					CredentialToUse: strings.TrimSuffix(fakeCredName, "-cacert"),
 					Gateway:         false,
 				},
@@ -91,7 +91,7 @@ func TestSimpleTlsOrigination(t *testing.T) {
 				// Secret fetching error at Gateway, results in a 503 response.
 				{
 					Name:            "missing secret",
-					Response:        response.StatusCodeUnavailable,
+					Response:        echoClient.StatusCodeUnavailable,
 					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
 					Gateway:         false,
 				},
@@ -171,7 +171,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// validate the client cert. Secret is of type generic.
 				{
 					Name:            "generic",
-					Response:        response.StatusCodeOK,
+					Response:        echoClient.StatusCodeOK,
 					CredentialToUse: strings.TrimSuffix(credNameGeneric, "-cacert"),
 					Gateway:         true,
 				},
@@ -180,7 +180,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// validate the client cert. Secret is not of type generic.
 				{
 					Name:            "non-generic",
-					Response:        response.StatusCodeOK,
+					Response:        echoClient.StatusCodeOK,
 					CredentialToUse: strings.TrimSuffix(credNameNotGeneric, "-cacert"),
 					Gateway:         true,
 				},
@@ -189,7 +189,7 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// cannot validate the client cert. Returns 503 response as TLS handshake fails.
 				{
 					Name:            "invalid client cert",
-					Response:        response.StatusCodeUnavailable,
+					Response:        echoClient.StatusCodeUnavailable,
 					CredentialToUse: strings.TrimSuffix(fakeCredNameA, "-cacert"),
 					Gateway:         false,
 				},
@@ -198,13 +198,13 @@ func TestMutualTlsOrigination(t *testing.T) {
 				// Secret fetching error at Gateway, results in a 503 response.
 				{
 					Name:            "missing",
-					Response:        response.StatusCodeUnavailable,
+					Response:        echoClient.StatusCodeUnavailable,
 					CredentialToUse: strings.TrimSuffix(credNameMissing, "-cacert"),
 					Gateway:         false,
 				},
 				{
 					Name:            "no client certs",
-					Response:        response.StatusCodeUnavailable,
+					Response:        echoClient.StatusCodeUnavailable,
 					CredentialToUse: strings.TrimSuffix(simpleCredName, "-cacert"),
 					Gateway:         false,
 				},
@@ -364,23 +364,16 @@ func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions
 		Headers: map[string][]string{
 			"Host": {host},
 		},
-		Validator: echo.And(echo.ValidatorFunc(
-			func(responses client.ParsedResponses, err error) error {
-				if err != nil {
-					return fmt.Errorf("request failed: %v", err)
-				}
-				for _, r := range responses {
-					if r.Code != tc.Response {
-						return fmt.Errorf("got code %s, expected %s", r.Code, tc.Response)
-					}
-				}
-				for _, r := range responses {
+		Check: check.And(
+			check.NoError(),
+			check.And(
+				check.Code(tc.Response),
+				check.Each(func(r echoClient.Response) error {
 					if _, f := r.RawResponse["Handled-By-Egress-Gateway"]; tc.Gateway && !f {
 						return fmt.Errorf("expected to be handled by gateway. response: %+v", r.RawResponse)
 					}
-				}
-				return nil
-			})),
+					return nil
+				}))),
 	}
 }
 
diff --git a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
index a84171a9be..d61fd372dd 100644
--- a/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
+++ b/tests/integration/security/file_mounted_certs/p2p_mtls_test.go
@@ -25,7 +25,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -51,14 +51,14 @@ func TestClientToServiceTls(t *testing.T) {
 	framework.NewTest(t).
 		Features("security.peer.file-mounted-certs").
 		Run(func(t framework.TestContext) {
-			echoClient, echoServer, serviceNamespace := setupEcho(t, t)
+			client, server, serviceNamespace := setupEcho(t, t)
 
 			createObject(t, serviceNamespace.Name(), DestinationRuleConfigMutual)
 			createObject(t, "istio-system", PeerAuthenticationConfig)
 
 			retry.UntilSuccessOrFail(t, func() error {
-				resp, err := echoClient.Call(echo.CallOptions{
-					Target:   echoServer,
+				resp, err := client.Call(echo.CallOptions{
+					Target:   server,
 					PortName: "http",
 					Scheme:   scheme.HTTP,
 				})
@@ -70,8 +70,8 @@ func TestClientToServiceTls(t *testing.T) {
 				for _, r := range resp {
 					codes = append(codes, r.Code)
 				}
-				if !reflect.DeepEqual(codes, []string{response.StatusCodeOK}) {
-					return fmt.Errorf("got codes %q, expected %q", codes, []string{response.StatusCodeOK})
+				if !reflect.DeepEqual(codes, []string{echoClient.StatusCodeOK}) {
+					return fmt.Errorf("got codes %q, expected %q", codes, []string{echoClient.StatusCodeOK})
 				}
 				for _, r := range resp {
 					if xfcc, f := r.RawResponse["X-Forwarded-Client-Cert"]; f {
diff --git a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
index 1bca0a5869..77bfd771ee 100644
--- a/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
+++ b/tests/integration/security/filebased_tls_origination/destination_rule_tls_test.go
@@ -24,6 +24,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
@@ -139,10 +140,9 @@ func TestDestinationRuleTls(t *testing.T) {
 							opts.Scheme = scheme.TCP
 						}
 						resp, err := client.Call(opts)
-						if err != nil {
-							return err
-						}
-						return resp.CheckOK()
+						return check.And(
+							check.NoError(),
+							check.OK()).Check(resp, err)
 					}, retry.Delay(time.Millisecond*100))
 				})
 			}
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index 6607381326..e0564a6773 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -31,8 +31,8 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
-	"istio.io/istio/pkg/test/echo/common/response"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -79,7 +79,7 @@ func TestEgressGatewayTls(t *testing.T) {
 				//      --> externalServer(443 with only Simple TLS used and client cert is not verified)
 				"Mutual TLS origination from egress gateway to https endpoint": {
 					destinationRuleMode: "MUTUAL",
-					response:            []string{response.StatusCodeOK},
+					response:            []string{echoClient.StatusCodeOK},
 					gateway:             true,
 					fakeRootCert:        false,
 				},
@@ -90,7 +90,7 @@ func TestEgressGatewayTls(t *testing.T) {
 
 				"SIMPLE TLS origination from egress gateway to https endpoint": {
 					destinationRuleMode: "SIMPLE",
-					response:            []string{response.StatusCodeOK},
+					response:            []string{echoClient.StatusCodeOK},
 					gateway:             true,
 					fakeRootCert:        false,
 				},
@@ -100,7 +100,7 @@ func TestEgressGatewayTls(t *testing.T) {
 				//      --> externalServer(443 with TLS enforced) request fails as gateway tries plain text only
 				"No TLS origination from egress gateway to https endpoint": {
 					destinationRuleMode: "DISABLE",
-					response:            []string{response.StatusCodeBadRequest},
+					response:            []string{echoClient.StatusCodeBadRequest},
 					gateway:             false, // 400 response will not contain header
 				},
 				// 5. SIMPLE TLS origination with "fake" root cert::
@@ -110,7 +110,7 @@ func TestEgressGatewayTls(t *testing.T) {
 				//    request fails as the server cert can't be validated using the fake root cert used during origination
 				"SIMPLE TLS origination from egress gateway to https endpoint with fake root cert": {
 					destinationRuleMode: "SIMPLE",
-					response:            []string{response.StatusCodeUnavailable},
+					response:            []string{echoClient.StatusCodeUnavailable},
 					gateway:             false, // 503 response will not contain header
 					fakeRootCert:        true,
 				},
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 982ff316f3..8471efbc36 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -23,7 +23,7 @@
 	"strings"
 	"testing"
 
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -102,7 +102,7 @@ func TestJWTHTTPS(t *testing.T) {
 						Path:  "/valid-token-forward-remote-jwks",
 						Count: callCount,
 					},
-					ExpectResponseCode: response.StatusCodeOK,
+					ExpectResponseCode: echoClient.StatusCodeOK,
 					ExpectHeaders: map[string]string{
 						authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
 						"X-Test-Payload": payload1,
@@ -143,7 +143,7 @@ func TestJWTHTTPS(t *testing.T) {
 						t.NewSubTest(testCase.Name).Run(func(t framework.TestContext) {
 							testCase.CallOpts.Target = dest[0]
 							testCase.DestClusters = dest.Match(echo.InCluster(src.Config().Cluster)).Clusters()
-							testCase.CallOpts.Validator = echo.And(echo.ValidatorFunc(testCase.CheckAuthn))
+							testCase.CallOpts.Check = testCase.CheckAuthn
 							src.CallWithRetryOrFail(t, testCase.CallOpts, echo.DefaultCallRetryOptions()...)
 						})
 					})
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index 56579fcc10..3aed5d520d 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -22,7 +22,7 @@
 	"strings"
 	"testing"
 
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -87,7 +87,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-token-noauthz",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 						ExpectHeaders: map[string]string{
 							authHeaderKey:    "",
 							"X-Test-Payload": payload1,
@@ -105,7 +105,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-token-2-noauthz",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 						ExpectHeaders: map[string]string{
 							authHeaderKey:    "",
 							"X-Test-Payload": payload2,
@@ -123,7 +123,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/expired-token-noauthz",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "expired-token-cors-preflight-request-allowed",
@@ -140,7 +140,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:   "/expired-token-cors-preflight-request-allowed",
 							Count:  callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "expired-token-bad-cors-preflight-request-rejected",
@@ -157,7 +157,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:   "/expired-token-cors-preflight-request-allowed",
 							Count:  callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "no-token-noauthz",
@@ -168,7 +168,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/no-token-noauthz",
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					// Destination app is configured with authorization, only request with valid JWT succeed.
 					{
@@ -183,7 +183,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-token",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 						ExpectHeaders: map[string]string{
 							authHeaderKey: "",
 						},
@@ -200,7 +200,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/expired-token",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "no-token",
@@ -211,7 +211,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/no-token",
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeForbidden,
+						ExpectResponseCode: echoClient.StatusCodeForbidden,
 					},
 					{
 						Name: "no-authn-authz",
@@ -221,7 +221,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/no-authn-authz",
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "valid-token-forward",
@@ -235,7 +235,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-token-forward",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 						ExpectHeaders: map[string]string{
 							authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
 							"X-Test-Payload": payload1,
@@ -253,7 +253,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-token-forward-remote-jwks",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 						ExpectHeaders: map[string]string{
 							authHeaderKey:    "Bearer " + jwt.TokenIssuer1,
 							"X-Test-Payload": payload1,
@@ -275,7 +275,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-aud",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeForbidden,
+						ExpectResponseCode: echoClient.StatusCodeForbidden,
 					},
 					{
 						Name:   "valid-aud",
@@ -289,7 +289,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/valid-aud",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "verify-policies-are-combined",
@@ -303,7 +303,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/verify-policies-are-combined",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "invalid-jwks-valid-token-noauthz",
@@ -316,7 +316,7 @@ func TestRequestAuthentication(t *testing.T) {
 							},
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "invalid-jwks-expired-token-noauthz",
@@ -330,7 +330,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:  "/invalid-jwks-valid-token-noauthz",
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "invalid-jwks-no-token-noauthz",
@@ -341,7 +341,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/invalid-jwks-no-token-noauthz",
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "valid-params",
@@ -352,7 +352,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/valid-token?token=" + jwt.TokenIssuer1,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "valid-params-secondary",
@@ -363,7 +363,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/valid-token?secondary_token=" + jwt.TokenIssuer1,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "invalid-params",
@@ -374,7 +374,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/valid-token?token_value=" + jwt.TokenIssuer1,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeForbidden,
+						ExpectResponseCode: echoClient.StatusCodeForbidden,
 					},
 					{
 						Name:   "valid-token-set",
@@ -385,7 +385,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenIssuer1,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "invalid-token-set",
@@ -396,7 +396,7 @@ func TestRequestAuthentication(t *testing.T) {
 							Path:     "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenExpired,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name:   "valid-header",
@@ -409,7 +409,7 @@ func TestRequestAuthentication(t *testing.T) {
 							},
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "valid-header-secondary",
@@ -422,7 +422,7 @@ func TestRequestAuthentication(t *testing.T) {
 							},
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 					{
 						Name:   "invalid-header",
@@ -435,7 +435,7 @@ func TestRequestAuthentication(t *testing.T) {
 							},
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusCodeForbidden,
+						ExpectResponseCode: echoClient.StatusCodeForbidden,
 					},
 				}
 				for _, c := range testCases {
@@ -469,7 +469,7 @@ func TestRequestAuthentication(t *testing.T) {
 							t.NewSubTest(c.Name).Run(func(t framework.TestContext) {
 								c.CallOpts.Target = dest[0]
 								c.DestClusters = dest.Match(echo.InCluster(src.Config().Cluster)).Clusters()
-								c.CallOpts.Validator = echo.And(echo.ValidatorFunc(c.CheckAuthn))
+								c.CallOpts.Check = c.CheckAuthn
 								src.CallWithRetryOrFail(t, c.CallOpts, echo.DefaultCallRetryOptions()...)
 							})
 						})
@@ -519,7 +519,7 @@ func TestIngressRequestAuthentication(t *testing.T) {
 							},
 							Count: callCount,
 						},
-						ExpectResponseCode: response.StatusUnauthorized,
+						ExpectResponseCode: echoClient.StatusUnauthorized,
 					},
 					{
 						Name: "in-mesh-without-token",
@@ -528,7 +528,7 @@ func TestIngressRequestAuthentication(t *testing.T) {
 							Scheme:   scheme.HTTP,
 							Count:    callCount,
 						},
-						ExpectResponseCode: response.StatusCodeOK,
+						ExpectResponseCode: echoClient.StatusCodeOK,
 					},
 				}
 				echotest.New(t, apps.All).
@@ -558,7 +558,7 @@ func TestIngressRequestAuthentication(t *testing.T) {
 							t.NewSubTest(c.Name).Run(func(t framework.TestContext) {
 								c.CallOpts.Target = dest[0]
 								c.DestClusters = dest.Clusters()
-								c.CallOpts.Validator = echo.And(echo.ValidatorFunc(c.CheckAuthn))
+								c.CallOpts.Check = c.CheckAuthn
 								src.CallWithRetryOrFail(t, c.CallOpts, echo.DefaultCallRetryOptions()...)
 							})
 						}
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index ecf26f7822..1fa6232ecc 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -24,6 +24,7 @@
 	"testing"
 
 	meshconfig "istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
@@ -228,15 +229,15 @@ type expect struct {
 					for _, c := range apps.A {
 						for _, tt := range tt.expectations {
 							t.NewSubTest(tt.in).Run(func(t framework.TestContext) {
-								validator := echo.ExpectKey("URL", tt.out)
+								checker := check.Key("URL", tt.out)
 								if tt.out == "400" {
-									validator = echo.ExpectCode("400")
+									checker = check.Code("400")
 								}
 								c.CallWithRetryOrFail(t, echo.CallOptions{
-									Target:    apps.B[0],
-									Path:      tt.in,
-									PortName:  "http",
-									Validator: validator,
+									Target:   apps.B[0],
+									Path:     tt.in,
+									PortName: "http",
+									Check:    checker,
 								})
 							})
 						}
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index fe043c2af0..89287ab652 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -23,8 +23,8 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
@@ -651,30 +651,29 @@ func(instances echo.Instances) echo.Instances { return instances.Match(echo.Name
 									// Do not set Target to dest, otherwise fillInCallOptions() will
 									// complain with port does not match.
 									Address: getWorkload(dest[0], t).Address(),
-									Validator: echo.And(echo.ValidatorFunc(
-										func(responses client.ParsedResponses, err error) error {
-											if want {
-												if err != nil {
-													return fmt.Errorf("want allow but got error: %v", err)
-												}
-												if responses.Len() < 1 {
-													return fmt.Errorf("received no responses from request to %s", host)
-												}
-												if okErr := responses.CheckOK(); okErr != nil && expect.port.Protocol == protocol.HTTP {
-													return fmt.Errorf("want status %s but got %s", response.StatusCodeOK, okErr.Error())
-												}
-											} else {
-												// Check HTTP forbidden response
-												if responses.Len() >= 1 && responses.CheckCode(response.StatusCodeForbidden) == nil {
-													return nil
-												}
+									Check: func(responses echoClient.Responses, err error) error {
+										if want {
+											if err != nil {
+												return fmt.Errorf("want allow but got error: %v", err)
+											}
+											if responses.Len() < 1 {
+												return fmt.Errorf("received no responses from request to %s", host)
+											}
+											if okErr := check.OK().Check(responses, err); okErr != nil && expect.port.Protocol == protocol.HTTP {
+												return fmt.Errorf("want status %s but got %s", echoClient.StatusCodeOK, okErr.Error())
+											}
+										} else {
+											// Check HTTP forbidden response
+											if responses.Len() >= 1 && check.Code(echoClient.StatusCodeForbidden).Check(responses, err) == nil {
+												return nil
+											}
 
-												if err == nil {
-													return fmt.Errorf("want error but got none: %v", responses.String())
-												}
+											if err == nil {
+												return fmt.Errorf("want error but got none: %v", responses.String())
 											}
-											return nil
-										})),
+										}
+										return nil
+									},
 								}
 								t.NewSubTest(name).Run(func(t framework.TestContext) {
 									src.CallWithRetryOrFail(t, callOpt, echo.DefaultCallRetryOptions()...)
diff --git a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
index 10f7922709..08034611b8 100644
--- a/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
+++ b/tests/integration/security/sds_egress/sds_istio_mutual_egress_test.go
@@ -23,7 +23,7 @@
 	"testing"
 	"time"
 
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
 	epb "istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -70,11 +70,11 @@ func TestSdsEgressGatewayIstioMutual(t *testing.T) {
 			}{
 				"ISTIO_MUTUAL TLS mode requests are routed through egress succeed": {
 					configPath: istioMutualTLSGatewayConfig,
-					response:   response.StatusCodeOK,
+					response:   echoClient.StatusCodeOK,
 				},
 				"SIMPLE TLS mode requests are routed through gateway but fail with 503": {
 					configPath: simpleTLSGatewayConfig,
-					response:   response.StatusCodeUnavailable,
+					response:   echoClient.StatusCodeUnavailable,
 				},
 			}
 
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index e982d51f1e..26a39fa83b 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -34,7 +34,8 @@
 
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/echo/client"
+	echoClient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -296,27 +297,25 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 		},
 		HTTP3:  useHTTP3,
 		CaCert: tlsCtx.CaCert,
-		Validator: echo.And(
-			echo.ValidatorFunc(
-				func(resp client.ParsedResponses, err error) error {
-					// Check that the error message is expected.
-					if err != nil {
-						// If expected error message is empty, but we got some error
-						// message then it should be treated as error when error message
-						// verification is not skipped. Error message verification is skipped
-						// when the error message is non-deterministic.
-						if !exRsp.SkipErrorMessageVerification && len(exRsp.ErrorMessage) == 0 {
-							return fmt.Errorf("unexpected error: %w", err)
-						}
-						if !exRsp.SkipErrorMessageVerification && !strings.Contains(err.Error(), exRsp.ErrorMessage) {
-							return fmt.Errorf("expected response error message %s but got %w",
-								exRsp.ErrorMessage, err)
-						}
-						return nil
-					}
+		Check: func(resp echoClient.Responses, err error) error {
+			// Check that the error message is expected.
+			if err != nil {
+				// If expected error message is empty, but we got some error
+				// message then it should be treated as error when error message
+				// verification is not skipped. Error message verification is skipped
+				// when the error message is non-deterministic.
+				if !exRsp.SkipErrorMessageVerification && len(exRsp.ErrorMessage) == 0 {
+					return fmt.Errorf("unexpected error: %w", err)
+				}
+				if !exRsp.SkipErrorMessageVerification && !strings.Contains(err.Error(), exRsp.ErrorMessage) {
+					return fmt.Errorf("expected response error message %s but got %w",
+						exRsp.ErrorMessage, err)
+				}
+				return nil
+			}
 
-					return resp.CheckCode(strconv.Itoa(exRsp.ResponseCode))
-				})),
+			return check.Code(strconv.Itoa(exRsp.ResponseCode)).Check(resp, nil)
+		},
 	}
 
 	if callType == Mtls {
diff --git a/tests/integration/security/util/authn/authn_util.go b/tests/integration/security/util/authn/authn_util.go
index 0de64c9b54..bd00e7ffd3 100644
--- a/tests/integration/security/util/authn/authn_util.go
+++ b/tests/integration/security/util/authn/authn_util.go
@@ -23,8 +23,8 @@
 	"strings"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/echo/client"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoclient "istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -51,7 +51,7 @@ func (c *TestCase) String() string {
 }
 
 // CheckAuthn checks a request based on ExpectResponseCode.
-func (c *TestCase) CheckAuthn(responses client.ParsedResponses, err error) error {
+func (c *TestCase) CheckAuthn(responses echoclient.Responses, err error) error {
 	if len(responses) == 0 {
 		return fmt.Errorf("%s: no response", c)
 	}
@@ -72,8 +72,8 @@ func (c *TestCase) CheckAuthn(responses client.ParsedResponses, err error) error
 			}
 		}
 	}
-	if c.ExpectResponseCode == response.StatusCodeOK && c.DestClusters.IsMulticluster() {
-		return responses.CheckReachedClusters(c.DestClusters)
+	if c.ExpectResponseCode == echoclient.StatusCodeOK && c.DestClusters.IsMulticluster() {
+		return check.ReachedClusters(c.DestClusters).Check(responses, nil)
 	}
 	return nil
 }
@@ -92,9 +92,9 @@ func CheckIngressOrFail(ctx framework.TestContext, ingr ingress.Instance, host s
 		Port: &echo.Port{
 			Protocol: protocol.HTTP,
 		},
-		Path:      path,
-		Headers:   headers,
-		Validator: echo.ExpectCode(strconv.Itoa(expectResponseCode)),
+		Path:    path,
+		Headers: headers,
+		Check:   check.Code(strconv.Itoa(expectResponseCode)),
 	}
 	if len(token) != 0 {
 		opts.Headers["Authorization"] = []string{
diff --git a/tests/integration/security/util/connection/checker.go b/tests/integration/security/util/connection/checker.go
index e3921f981d..ee81a32356 100644
--- a/tests/integration/security/util/connection/checker.go
+++ b/tests/integration/security/util/connection/checker.go
@@ -21,6 +21,7 @@
 	"fmt"
 
 	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -41,7 +42,7 @@ func (c *Checker) Check() error {
 	results, err := c.From.Call(c.Options)
 	if c.ExpectSuccess {
 		if err == nil {
-			err = results.CheckOK()
+			err = check.OK().Check(results, err)
 		}
 		if err != nil {
 			return fmt.Errorf("%s to %s:%s using %s: expected success but failed: %v",
@@ -50,13 +51,13 @@ func (c *Checker) Check() error {
 		// TODO: check why grpc can not reach all clusters
 		// headless will have inconsistent loadbalancing, so we don't check clusters
 		if c.DestClusters.IsMulticluster() && c.Options.Scheme != scheme.GRPC && c.Options.Count > 1 && !c.Options.Target.Config().IsHeadless() {
-			err = results.CheckReachedClusters(c.DestClusters)
+			err = check.ReachedClusters(c.DestClusters).Check(results, nil)
 			if err != nil {
 				return err
 			}
 		}
 		if c.ExpectMTLS {
-			err := results.CheckMTLSForHTTP()
+			err := check.MTLSForHTTP().Check(results, nil)
 			gotMtls := err == nil
 			if gotMtls != c.ExpectMTLS {
 				return fmt.Errorf("%s to %s:%s using %s: expected mtls=%v, got mtls=%v",
@@ -67,7 +68,7 @@ func (c *Checker) Check() error {
 	}
 
 	// Expect failure...
-	if err == nil && results.CheckOK() == nil {
+	if err == nil && check.OK().Check(results, nil) == nil {
 		return fmt.Errorf("%s to %s:%s using %s: expected failed, actually success",
 			c.From.Config().Service, c.Options.Target.Config().Service, c.Options.PortName, c.Options.Scheme)
 	}
diff --git a/tests/integration/security/util/rbac_util/util.go b/tests/integration/security/util/rbac_util/util.go
index 87847892e3..a6f15e9ae9 100644
--- a/tests/integration/security/util/rbac_util/util.go
+++ b/tests/integration/security/util/rbac_util/util.go
@@ -23,8 +23,8 @@
 	"strings"
 	"time"
 
-	"istio.io/istio/pkg/test/echo/client"
-	"istio.io/istio/pkg/test/echo/common/response"
+	"istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/tests/integration/security/util/connection"
@@ -57,7 +57,7 @@ func getError(req connection.Checker, expect, actual string) error {
 		actual)
 }
 
-func checkValues(i int, response *client.ParsedResponse, want []ExpectContains) error {
+func checkValues(i int, response echo.Response, want []ExpectContains) error {
 	for _, w := range want {
 		key := w.Key
 		for _, value := range w.Values {
@@ -98,49 +98,57 @@ func (tc TestCase) CheckRBACRequest() error {
 	resp, err := req.From.Call(tc.Request.Options)
 
 	if tc.ExpectAllowed {
-		if err == nil {
-			err = resp.CheckOK()
-		}
-		if err != nil {
-			return getError(req, "allow with code 200", fmt.Sprintf("error: %v", err))
-		}
-		if err := resp.Check(func(i int, parsedResponse *client.ParsedResponse) error {
-			return checkValues(i, parsedResponse, tc.ExpectHTTPResponse)
-		}); err != nil {
-			return err
-		}
-		if req.DestClusters.IsMulticluster() {
-			return resp.CheckReachedClusters(req.DestClusters)
-		}
-	} else {
-		if strings.HasPrefix(req.Options.PortName, "tcp") || req.Options.PortName == "grpc" {
-			expectedErrMsg := "EOF" // TCP deny message.
-			if req.Options.PortName == "grpc" {
-				expectedErrMsg = "rpc error: code = PermissionDenied desc = RBAC: access denied"
-			}
-			if err == nil || !strings.Contains(err.Error(), expectedErrMsg) {
-				expect := fmt.Sprintf("deny with %s error", expectedErrMsg)
-				actual := fmt.Sprintf("error: %v", err)
-				return getError(req, expect, actual)
+		checker := func(rs echo.Responses, err error) error {
+			if err == nil {
+				err = check.OK().Check(rs, nil)
 			}
-		} else {
 			if err != nil {
-				return getError(req, "deny with code 403", fmt.Sprintf("error: %v", err))
+				return getError(req, "allow with code 200", fmt.Sprintf("error: %v", err))
 			}
-			var result string
-			if len(resp) == 0 {
-				result = "no response"
-			} else if resp[0].Code != response.StatusCodeForbidden {
-				result = resp[0].Code
-			}
-			if result != "" {
-				return getError(req, "deny with code 403", result)
+
+			for i, r := range rs {
+				if err := checkValues(i, r, tc.ExpectHTTPResponse); err != nil {
+					return err
+				}
 			}
-			if err := resp.Check(func(i int, parsedResponse *client.ParsedResponse) error {
-				return checkValues(i, parsedResponse, tc.ExpectHTTPResponse)
-			}); err != nil {
-				return err
+
+			if req.DestClusters.IsMulticluster() {
+				return check.ReachedClusters(req.DestClusters).Check(rs, err)
 			}
+			return nil
+		}
+		return checker(resp, err)
+	}
+
+	if strings.HasPrefix(req.Options.PortName, "tcp") || req.Options.PortName == "grpc" {
+		expectedErrMsg := "EOF" // TCP deny message.
+		if req.Options.PortName == "grpc" {
+			expectedErrMsg = "rpc error: code = PermissionDenied desc = RBAC: access denied"
+		}
+		if err == nil || !strings.Contains(err.Error(), expectedErrMsg) {
+			expect := fmt.Sprintf("deny with %s error", expectedErrMsg)
+			actual := fmt.Sprintf("error: %v", err)
+			return getError(req, expect, actual)
+		}
+		return nil
+	}
+
+	if err != nil {
+		return getError(req, "deny with code 403", fmt.Sprintf("error: %v", err))
+	}
+	var result string
+	if len(resp) == 0 {
+		result = "no response"
+	} else if resp[0].Code != echo.StatusCodeForbidden {
+		result = resp[0].Code
+	}
+	if result != "" {
+		return getError(req, "deny with code 403", result)
+	}
+
+	for i, r := range resp {
+		if err := checkValues(i, r, tc.ExpectHTTPResponse); err != nil {
+			return err
 		}
 	}
 	return nil
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index b2afb03887..e2f1cd57c4 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -25,7 +25,7 @@
 	"testing"
 
 	"istio.io/istio/pkg/config/protocol"
-	echoclient "istio.io/istio/pkg/test/echo/client"
+	echoclient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
@@ -259,7 +259,7 @@ func RunExternalRequest(cases []*TestCase, prometheus prometheus.Instance, mode
 							"Host": {tc.Host},
 						},
 						HTTP2: tc.HTTP2,
-						Validator: echo.ValidatorFunc(func(resp echoclient.ParsedResponses, err error) error {
+						Check: func(resp echoclient.Responses, err error) error {
 							// the expected response from a blackhole test case will have err
 							// set; use the length of the expected code to ignore this condition
 							if err != nil && len(tc.Expected.ResponseCode) != 0 {
@@ -281,7 +281,7 @@ func RunExternalRequest(cases []*TestCase, prometheus prometheus.Instance, mode
 								}
 							}
 							return nil
-						}),
+						},
 					})
 
 					if tc.Expected.Metric != "" {
diff --git a/tests/integration/telemetry/policy/envoy_ratelimit_test.go b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
index a7077658a2..6664e474e8 100644
--- a/tests/integration/telemetry/policy/envoy_ratelimit_test.go
+++ b/tests/integration/telemetry/policy/envoy_ratelimit_test.go
@@ -25,7 +25,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/echo/common/response"
+	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
@@ -221,7 +221,7 @@ func sendTrafficAndCheckIfRatelimited(t *testing.T) {
 		received409 := false
 		if parsedResponse, err := clt.Call(httpOpts); err == nil {
 			for _, resp := range parsedResponse {
-				if response.StatusCodeTooManyRequests == resp.Code {
+				if echoClient.StatusCodeTooManyRequests == resp.Code {
 					received409 = true
 					break
 				}
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index c51bbb1b6d..70a268dd90 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -26,6 +26,7 @@
 	"golang.org/x/sync/errgroup"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
@@ -319,10 +320,10 @@ func TestSetup(ctx resource.Context) (err error) {
 // SendTraffic makes a client call to the "server" service on the http port.
 func SendTraffic(cltInstance echo.Instance) error {
 	_, err := cltInstance.Call(echo.CallOptions{
-		Target:    server[0],
-		PortName:  "http",
-		Count:     util.RequestCountMultipler * len(server),
-		Validator: echo.ExpectOK(),
+		Target:   server[0],
+		PortName: "http",
+		Count:    util.RequestCountMultipler * len(server),
+		Check:    check.OK(),
 	})
 	if err != nil {
 		return err
diff --git a/tests/util/sanitycheck/sanity_check.go b/tests/util/sanitycheck/sanity_check.go
index 3536728e5d..f5d86e835e 100644
--- a/tests/util/sanitycheck/sanity_check.go
+++ b/tests/util/sanitycheck/sanity_check.go
@@ -16,6 +16,7 @@
 
 import (
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
@@ -62,8 +63,8 @@ func SetupTrafficTest(t framework.TestContext, ctx resource.Context, revision st
 
 func RunTrafficTestClientServer(t framework.TestContext, client, server echo.Instance) {
 	_ = client.CallWithRetryOrFail(t, echo.CallOptions{
-		Target:    server,
-		PortName:  "http",
-		Validator: echo.ExpectOK(),
+		Target:   server,
+		PortName: "http",
+		Check:    check.OK(),
 	})
 }
-- 
2.35.3

