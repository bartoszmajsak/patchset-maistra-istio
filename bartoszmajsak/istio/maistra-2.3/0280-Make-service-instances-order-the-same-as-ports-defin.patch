From 9295b20a71bebc749222ec421296ca3cf3301a15 Mon Sep 17 00:00:00 2001
From: Pengyuan Bian <bianpengyuan@google.com>
Date: Mon, 20 Dec 2021 11:01:33 -0800
Subject: Make service instances order the same as ports defined at service
 spec (#36462)

* Remove port protocol from target pods dedup.

* update.

* rework.
---
 .../kube/controller/controller.go             |  16 ++-
 .../kube/controller/controller_test.go        | 109 +++++++++++++++---
 releasenotes/notes/36434.yaml                 |  10 ++
 3 files changed, 117 insertions(+), 18 deletions(-)
 create mode 100644 releasenotes/notes/36434.yaml

diff --git a/pilot/pkg/serviceregistry/kube/controller/controller.go b/pilot/pkg/serviceregistry/kube/controller/controller.go
index 838160f31f..9a9ea5f327 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller.go
@@ -1276,6 +1276,7 @@ func (c *Controller) getProxyServiceInstancesFromMetadata(proxy *model.Proxy) ([
 			discoverabilityPolicy := c.exports.EndpointDiscoverabilityPolicy(modelService)
 
 			tps := make(map[model.Port]*model.Port)
+			tpsList := make([]model.Port, 0)
 			for _, port := range svc.Spec.Ports {
 				svcPort, f := modelService.Ports.Get(port.Name)
 				if !f {
@@ -1302,11 +1303,15 @@ func (c *Controller) getProxyServiceInstancesFromMetadata(proxy *model.Proxy) ([
 				}
 				if _, exists := tps[targetPort]; !exists {
 					tps[targetPort] = svcPort
+					tpsList = append(tpsList, targetPort)
 				}
 			}
 
 			epBuilder := NewEndpointBuilderFromMetadata(c, proxy)
-			for tp, svcPort := range tps {
+			// Iterate over target ports in the same order as defined in service spec, in case of
+			// protocol conflict for a port causes unstable protocol selection for a port.
+			for _, tp := range tpsList {
+				svcPort := tps[tp]
 				// consider multiple IP scenarios
 				for _, ip := range proxy.IPAddresses {
 					// Construct the ServiceInstance
@@ -1330,6 +1335,7 @@ func (c *Controller) getProxyServiceInstancesByPod(pod *v1.Pod,
 		discoverabilityPolicy := c.exports.EndpointDiscoverabilityPolicy(svc)
 
 		tps := make(map[model.Port]*model.Port)
+		tpsList := make([]model.Port, 0)
 		for _, port := range service.Spec.Ports {
 			svcPort, exists := svc.Ports.Get(port.Name)
 			if !exists {
@@ -1348,13 +1354,17 @@ func (c *Controller) getProxyServiceInstancesByPod(pod *v1.Pod,
 				Port:     portNum,
 				Protocol: svcPort.Protocol,
 			}
-			if _, exists = tps[targetPort]; !exists {
+			if _, exists := tps[targetPort]; !exists {
 				tps[targetPort] = svcPort
+				tpsList = append(tpsList, targetPort)
 			}
 		}
 
 		builder := NewEndpointBuilder(c, pod)
-		for tp, svcPort := range tps {
+		// Iterate over target ports in the same order as defined in service spec, in case of
+		// protocol conflict for a port causes unstable protocol selection for a port.
+		for _, tp := range tpsList {
+			svcPort := tps[tp]
 			// consider multiple IP scenarios
 			for _, ip := range proxy.IPAddresses {
 				istioEndpoint := builder.buildIstioEndpoint(ip, int32(tp.Port), svcPort.Name, discoverabilityPolicy)
diff --git a/pilot/pkg/serviceregistry/kube/controller/controller_test.go b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
index 8e1aac4688..d2af5b4f2d 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller_test.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
@@ -598,11 +598,11 @@ func TestGetProxyServiceInstances(t *testing.T) {
 func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 	pod1 := generatePod("128.0.0.1", "pod1", "nsa", "foo", "node1", map[string]string{"app": "test-app"}, map[string]string{})
 	testCases := []struct {
-		name    string
-		pods    []*coreV1.Pod
-		ips     []string
-		ports   []coreV1.ServicePort
-		wantNum int
+		name          string
+		pods          []*coreV1.Pod
+		ips           []string
+		ports         []coreV1.ServicePort
+		wantEndpoints []model.IstioEndpoint
 	}{
 		{
 			name: "multiple proxy ips single port",
@@ -616,7 +616,18 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 8080},
 				},
 			},
-			wantNum: 2,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+				{
+					Address:         "192.168.2.6",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+			},
 		},
 		{
 			name: "single proxy ip single port",
@@ -630,7 +641,13 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 8080},
 				},
 			},
-			wantNum: 1,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+			},
 		},
 		{
 			name: "multiple proxy ips multiple ports",
@@ -638,19 +655,40 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 			ips:  []string{"128.0.0.1", "192.168.2.6"},
 			ports: []coreV1.ServicePort{
 				{
-					Name:       "tcp-port",
+					Name:       "tcp-port-1",
 					Port:       8080,
 					Protocol:   "http",
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 8080},
 				},
 				{
-					Name:       "tcp-port",
+					Name:       "tcp-port-2",
 					Port:       9090,
 					Protocol:   "http",
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 9090},
 				},
 			},
-			wantNum: 4,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port-1",
+					EndpointPort:    8080,
+				},
+				{
+					Address:         "192.168.2.6",
+					ServicePortName: "tcp-port-1",
+					EndpointPort:    8080,
+				},
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port-2",
+					EndpointPort:    9090,
+				},
+				{
+					Address:         "192.168.2.6",
+					ServicePortName: "tcp-port-2",
+					EndpointPort:    9090,
+				},
+			},
 		},
 		{
 			name: "single proxy ip multiple ports same target port with different protocols",
@@ -670,7 +708,18 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 8080},
 				},
 			},
-			wantNum: 2,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "http-port",
+					EndpointPort:    8080,
+				},
+			},
 		},
 		{
 			name: "single proxy ip multiple ports same target port with overlapping protocols",
@@ -696,7 +745,18 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 7442},
 				},
 			},
-			wantNum: 2,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "http-7442",
+					EndpointPort:    7442,
+				},
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-8443",
+					EndpointPort:    7442,
+				},
+			},
 		},
 		{
 			name: "single proxy ip multiple ports",
@@ -716,7 +776,18 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 9090},
 				},
 			},
-			wantNum: 2,
+			wantEndpoints: []model.IstioEndpoint{
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "tcp-port",
+					EndpointPort:    8080,
+				},
+				{
+					Address:         "128.0.0.1",
+					ServicePortName: "http-port",
+					EndpointPort:    9090,
+				},
+			},
 		},
 	}
 
@@ -742,8 +813,16 @@ func TestGetProxyServiceInstancesWithMultiIPsAndTargetPorts(t *testing.T) {
 				}
 				serviceInstances := controller.GetProxyServiceInstances(&model.Proxy{Metadata: &model.NodeMetadata{}, IPAddresses: c.ips})
 
-				if len(serviceInstances) != c.wantNum {
-					t.Fatalf("GetProxyServiceInstances() returned wrong # of endpoints => %d, want %d", len(serviceInstances), c.wantNum)
+				for i, svc := range serviceInstances {
+					if svc.Endpoint.Address != c.wantEndpoints[i].Address {
+						t.Errorf("wrong endpoint address at #i endpoint, got %v want %v", svc.Endpoint.Address, c.wantEndpoints[i].Address)
+					}
+					if svc.Endpoint.EndpointPort != c.wantEndpoints[i].EndpointPort {
+						t.Errorf("wrong endpoint port at #i endpoint, got %v want %v", svc.Endpoint.EndpointPort, c.wantEndpoints[i].EndpointPort)
+					}
+					if svc.Endpoint.ServicePortName != c.wantEndpoints[i].ServicePortName {
+						t.Errorf("wrong svc port at #i endpoint, got %v want %v", svc.Endpoint.ServicePortName, c.wantEndpoints[i].ServicePortName)
+					}
 				}
 			})
 		}
diff --git a/releasenotes/notes/36434.yaml b/releasenotes/notes/36434.yaml
new file mode 100644
index 0000000000..692b36abc7
--- /dev/null
+++ b/releasenotes/notes/36434.yaml
@@ -0,0 +1,10 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+  - https://github.com/istio/istio/issues/36462
+
+releaseNotes:
+  - |
+    **Fixed** an issue where specifying conflict protocols for a service target port
+    will cause unstable protocol selection for that port.
-- 
2.35.3

