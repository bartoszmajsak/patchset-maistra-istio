From c82d0bbb81b672b802378fa75f0e857df087484f Mon Sep 17 00:00:00 2001
From: AdamKorcz <44787359+AdamKorcz@users.noreply.github.com>
Date: Wed, 17 Nov 2021 10:45:18 +0000
Subject: Fuzzing: Add more coverage (#35727)

* Fuzzing: Add more coverage

* Use kube.NewFakeClient in kube_ingress_fuzzer

* Move Noptester to fuzz utils

* Minimize config validation fuzzer
---
 tests/fuzz/config_validation_fuzzer.go        | 130 ++++++++++
 tests/fuzz/helm_reconciler_fuzzer.go          |  16 +-
 tests/fuzz/kube_controller_fuzzer.go          | 226 ++++++++++++++++++
 tests/fuzz/kube_ingress_fuzzer.go             | 103 ++++++++
 ...orking_core_v1alpha3_envoyfilter_fuzzer.go |  84 +++++++
 tests/fuzz/networking_core_v1alpha3_fuzzer.go | 203 ++++++++++++++++
 tests/fuzz/oss_fuzz_build.sh                  |  39 +++
 ...r_fuzzer.go => pilot_networking_fuzzer.go} |  38 +--
 tests/fuzz/pilot_security_fuzzer.go           |  95 ++++++++
 tests/fuzz/regression_test.go                 |  11 +
 tests/fuzz/security_authz_builder_fuzzer.go   |  74 ++++++
 .../{v1alpha3_fuzzer.go => utils/utils.go}    |  54 +----
 tests/fuzz/v1alpha3_fuzzer.go                 |  30 +--
 13 files changed, 1005 insertions(+), 98 deletions(-)
 create mode 100644 tests/fuzz/kube_controller_fuzzer.go
 create mode 100644 tests/fuzz/kube_ingress_fuzzer.go
 create mode 100644 tests/fuzz/networking_core_v1alpha3_envoyfilter_fuzzer.go
 create mode 100644 tests/fuzz/networking_core_v1alpha3_fuzzer.go
 copy tests/fuzz/{helm_reconciler_fuzzer.go => pilot_networking_fuzzer.go} (53%)
 create mode 100644 tests/fuzz/pilot_security_fuzzer.go
 create mode 100644 tests/fuzz/security_authz_builder_fuzzer.go
 copy tests/fuzz/{v1alpha3_fuzzer.go => utils/utils.go} (52%)

diff --git a/tests/fuzz/config_validation_fuzzer.go b/tests/fuzz/config_validation_fuzzer.go
index 198421182e..51eef57b37 100644
--- a/tests/fuzz/config_validation_fuzzer.go
+++ b/tests/fuzz/config_validation_fuzzer.go
@@ -20,9 +20,15 @@
 	apimeta "k8s.io/apimachinery/pkg/api/meta"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 
+	extensions "istio.io/api/extensions/v1alpha1"
+	networking "istio.io/api/networking/v1alpha3"
+	networkingv1beta1 "istio.io/api/networking/v1beta1"
+	security_beta "istio.io/api/security/v1beta1"
+	telemetry "istio.io/api/telemetry/v1alpha1"
 	"istio.io/istio/pilot/pkg/config/kube/crdclient"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/config/validation"
 	"istio.io/istio/pkg/kube"
 )
 
@@ -100,3 +106,127 @@ func FuzzConfigValidation2(data []byte) int {
 	})
 	return 1
 }
+
+func FuzzConfigValidation3(data []byte) int {
+	if len(data) < 10 {
+		return 0
+	}
+	f := fuzz.NewConsumer(data)
+	c := config.Config{}
+	err := f.GenerateStruct(&c)
+	if err != nil {
+		return 0
+	}
+	targetNumber, err := f.GetInt()
+	if err != nil {
+		return 0
+	}
+	numberOfTargets := targetNumber % 13
+	switch numberOfTargets {
+	case 0:
+		in := &networking.Gateway{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateGateway(c)
+	case 1:
+		in := &networking.TrafficPolicy{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateDestinationRule(c)
+	case 2:
+		in := &networking.EnvoyFilter_EnvoyConfigObjectPatch{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateEnvoyFilter(c)
+	case 3:
+		in := &networking.Sidecar{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateSidecar(c)
+	case 4:
+		in := &security_beta.AuthorizationPolicy{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateAuthorizationPolicy(c)
+	case 5:
+		in := &security_beta.RequestAuthentication{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateRequestAuthentication(c)
+	case 6:
+		in := &security_beta.PeerAuthentication{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidatePeerAuthentication(c)
+	case 7:
+		in := &networking.VirtualService{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateVirtualService(c)
+	case 8:
+		in := &networking.WorkloadEntry{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateWorkloadEntry(c)
+	case 9:
+		in := &networking.ServiceEntry{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateServiceEntry(c)
+	case 10:
+		in := &networkingv1beta1.ProxyConfig{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateProxyConfig(c)
+	case 11:
+		in := &telemetry.Telemetry{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateTelemetry(c)
+	case 12:
+		in := &extensions.WasmPlugin{}
+		err = f.GenerateStruct(in)
+		if err != nil {
+			return 0
+		}
+		c.Spec = in
+		_, _ = validation.ValidateWasmPlugin(c)
+	}
+	return 1
+}
diff --git a/tests/fuzz/helm_reconciler_fuzzer.go b/tests/fuzz/helm_reconciler_fuzzer.go
index 050e8f8963..c8c8d63ea0 100644
--- a/tests/fuzz/helm_reconciler_fuzzer.go
+++ b/tests/fuzz/helm_reconciler_fuzzer.go
@@ -16,10 +16,12 @@
 package fuzz
 
 import (
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/client/fake"
 
 	"istio.io/istio/operator/pkg/helmreconciler"
+	"istio.io/istio/operator/pkg/name"
 	"istio.io/istio/operator/pkg/object"
 )
 
@@ -28,7 +30,17 @@ type fakeClientWrapper struct {
 }
 
 func FuzzHelmReconciler(data []byte) int {
-	k8obj, err := object.ParseYAMLToK8sObject(data)
+	f := fuzz.NewConsumer(data)
+	k8sobjBytes, err := f.GetBytes()
+	if err != nil {
+		return 0
+	}
+	k8obj, err := object.ParseYAMLToK8sObject(k8sobjBytes)
+	if err != nil {
+		return 0
+	}
+	m := name.Manifest{}
+	err = f.GenerateStruct(&m)
 	if err != nil {
 		return 0
 	}
@@ -46,5 +58,7 @@ func FuzzHelmReconciler(data []byte) int {
 		return 0
 	}
 	_ = h.ApplyObject(obj, false)
+	_, _ = h.Reconcile()
+	_, _, _ = h.ApplyManifest(m, false)
 	return 1
 }
diff --git a/tests/fuzz/kube_controller_fuzzer.go b/tests/fuzz/kube_controller_fuzzer.go
new file mode 100644
index 0000000000..4462c2e909
--- /dev/null
+++ b/tests/fuzz/kube_controller_fuzzer.go
@@ -0,0 +1,226 @@
+//go:build gofuzz
+// +build gofuzz
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package controller
+
+import (
+	"context"
+
+	"k8s.io/apimachinery/pkg/api/errors"
+
+	"istio.io/istio/pkg/network"
+	coreV1 "k8s.io/api/core/v1"
+	discovery "k8s.io/api/discovery/v1"
+	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+)
+
+func InternalFuzzKubeController(data []byte) int {
+	networkID := network.ID("fakeNetwork")
+	fco := FakeControllerOptions{}
+	f := fuzz.NewConsumer(data)
+	f.AllowUnexportedFields()
+	err := f.GenerateStruct(&fco)
+	if err != nil {
+		return 0
+	}
+	controller, fx := NewFakeControllerWithOptions(fco)
+	controller.network = networkID
+	defer controller.Stop()
+
+	p, err := generatePodFuzz(f)
+	if err != nil {
+		return 0
+	}
+	err = addPodsForFuzzing(controller, fx, p)
+	if err != nil {
+		return 0
+	}
+
+	err = createServiceForFuzzing(controller, f)
+	if err != nil {
+		return 0
+	}
+
+	err = createEndpointsForFuzzing(f, controller)
+	if err != nil {
+		return 0
+	}
+
+	node, err := generateNodeForFuzzing(f)
+	if err != nil {
+		return 0
+	}
+
+	err = addNodesForFuzzing(controller, node)
+	if err != nil {
+		return 0
+	}
+	return 1
+}
+
+func generatePodFuzz(f *fuzz.ConsumeFuzzer) (*coreV1.Pod, error) {
+	pod := &coreV1.Pod{}
+	return pod, f.GenerateStruct(pod)
+
+}
+
+func generateNodeForFuzzing(f *fuzz.ConsumeFuzzer) (*coreV1.Node, error) {
+	node := &coreV1.Node{}
+	return node, f.GenerateStruct(node)
+}
+
+func addPodsForFuzzing(controller *FakeController, fx *FakeXdsUpdater, pods ...*coreV1.Pod) error {
+	for _, pod := range pods {
+		p, _ := controller.client.CoreV1().Pods(pod.Namespace).Get(context.TODO(), pod.Name, metaV1.GetOptions{})
+		var newPod *coreV1.Pod
+		var err error
+		if p == nil {
+			newPod, err = controller.client.CoreV1().Pods(pod.Namespace).Create(context.TODO(), pod, metaV1.CreateOptions{})
+			if err != nil {
+				return err
+			}
+		} else {
+			newPod, err = controller.client.CoreV1().Pods(pod.Namespace).Update(context.TODO(), pod, metaV1.UpdateOptions{})
+			if err != nil {
+				return err
+			}
+		}
+
+		setPodReadyForFuzzing(newPod)
+		newPod.Status.PodIP = pod.Status.PodIP
+		newPod.Status.Phase = coreV1.PodRunning
+		_, _ = controller.client.CoreV1().Pods(pod.Namespace).UpdateStatus(context.TODO(), newPod, metaV1.UpdateOptions{})
+		fx.Wait("proxy")
+	}
+	return nil
+}
+
+func setPodReadyForFuzzing(pod *coreV1.Pod) {
+	pod.Status.Conditions = []coreV1.PodCondition{
+		{
+			Type:               coreV1.PodReady,
+			Status:             coreV1.ConditionTrue,
+			LastTransitionTime: metaV1.Now(),
+		},
+	}
+}
+
+func addNodesForFuzzing(controller *FakeController, nodes ...*coreV1.Node) error {
+	fakeClient := controller.client
+	for _, node := range nodes {
+		_, err := fakeClient.CoreV1().Nodes().Create(context.TODO(), node, metaV1.CreateOptions{})
+		if errors.IsAlreadyExists(err) {
+			if _, err := fakeClient.CoreV1().Nodes().Update(context.TODO(), node, metaV1.UpdateOptions{}); err != nil {
+				return nil
+			}
+		} else if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func createServiceForFuzzing(controller *FakeController, f *fuzz.ConsumeFuzzer) error {
+	service := &coreV1.Service{}
+	namespace, err := f.GetString()
+	if err != nil {
+		return err
+	}
+	err = f.GenerateStruct(service)
+	if err != nil {
+		return err
+	}
+	_, err = controller.client.CoreV1().Services(namespace).Create(context.TODO(), service, metaV1.CreateOptions{})
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
+func createEndpointsForFuzzing(f *fuzz.ConsumeFuzzer, controller *FakeController) error {
+	labels := make(map[string]string)
+	// Add the reference to the service. Used by EndpointSlice logic only.
+	name, err := f.GetString()
+	if err != nil {
+		return err
+	}
+	labels[discovery.LabelServiceName] = name
+
+	eas := make([]coreV1.EndpointAddress, 0)
+	number, err := f.GetInt()
+	if err != nil {
+		return err
+	}
+	for i := 0; i < number%50; i++ {
+		ea := coreV1.EndpointAddress{}
+		err = f.GenerateStruct(&ea)
+		if err != nil {
+			return err
+		}
+		eas = append(eas, ea)
+	}
+
+	eps := make([]coreV1.EndpointPort, 0)
+	number, err = f.GetInt()
+	if err != nil {
+		return err
+	}
+	for i := 0; i < number%50; i++ {
+		ep := coreV1.EndpointPort{}
+		err = f.GenerateStruct(&ep)
+		if err != nil {
+			return err
+		}
+		eps = append(eps, ep)
+	}
+
+	endpoint := &coreV1.Endpoints{}
+	err = f.GenerateStruct(endpoint)
+	if err != nil {
+		return err
+	}
+	namespace, err := f.GetString()
+	if err != nil {
+		return err
+	}
+	if _, err := controller.client.CoreV1().Endpoints(namespace).Create(context.TODO(), endpoint, metaV1.CreateOptions{}); err != nil {
+		if errors.IsAlreadyExists(err) {
+			_, err = controller.client.CoreV1().Endpoints(namespace).Update(context.TODO(), endpoint, metaV1.UpdateOptions{})
+		}
+		if err != nil {
+			return err
+		}
+	}
+
+	endpointSlice := &discovery.EndpointSlice{}
+	err = f.GenerateStruct(endpointSlice)
+	if err != nil {
+		return err
+	}
+	if _, err := controller.client.DiscoveryV1().EndpointSlices(namespace).Create(context.TODO(), endpointSlice, metaV1.CreateOptions{}); err != nil {
+		if errors.IsAlreadyExists(err) {
+			_, err = controller.client.DiscoveryV1().EndpointSlices(namespace).Update(context.TODO(), endpointSlice, metaV1.UpdateOptions{})
+		}
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
diff --git a/tests/fuzz/kube_ingress_fuzzer.go b/tests/fuzz/kube_ingress_fuzzer.go
new file mode 100644
index 0000000000..60a2847f1d
--- /dev/null
+++ b/tests/fuzz/kube_ingress_fuzzer.go
@@ -0,0 +1,103 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package fuzz
+
+import (
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+	coreV1 "k8s.io/api/core/v1"
+	knetworking "k8s.io/api/networking/v1"
+	networkingV1beta1 "k8s.io/api/networking/v1beta1"
+	"k8s.io/apimachinery/pkg/runtime"
+	listerv1 "k8s.io/client-go/listers/core/v1"
+
+	meshconfig "istio.io/api/mesh/v1alpha1"
+	kubeIngress "istio.io/istio/pilot/pkg/config/kube/ingress"
+	ingressv1 "istio.io/istio/pilot/pkg/config/kube/ingressv1"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/kube"
+)
+
+func FuzzConvertIngressVirtualService(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	ingress := knetworking.Ingress{}
+	err := f.GenerateStruct(&ingress)
+	if err != nil {
+		return 0
+	}
+	service := &coreV1.Service{}
+	cfgs := map[string]*config.Config{}
+	serviceLister, teardown := newServiceLister(service)
+	defer teardown()
+	ingressv1.ConvertIngressVirtualService(ingress, "mydomain", cfgs, serviceLister)
+	return 1
+}
+
+func FuzzConvertIngressVirtualService2(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	ingress := networkingV1beta1.Ingress{}
+	err := f.GenerateStruct(&ingress)
+	if err != nil {
+		return 0
+	}
+	service := &coreV1.Service{}
+	cfgs := map[string]*config.Config{}
+	serviceLister, teardown := newServiceLister(service)
+	defer teardown()
+	kubeIngress.ConvertIngressVirtualService(ingress, "mydomain", cfgs, serviceLister)
+	return 1
+}
+
+func FuzzConvertIngressV1alpha3(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	ingress := knetworking.Ingress{}
+	err := f.GenerateStruct(&ingress)
+	if err != nil {
+		return 0
+	}
+	m := &meshconfig.MeshConfig{}
+	err = f.GenerateStruct(m)
+	if err != nil {
+		return 0
+	}
+	ingressv1.ConvertIngressV1alpha3(ingress, m, "mydomain")
+	return 1
+}
+
+func FuzzConvertIngressV1alpha32(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	ingress := networkingV1beta1.Ingress{}
+	err := f.GenerateStruct(&ingress)
+	if err != nil {
+		return 0
+	}
+	m := &meshconfig.MeshConfig{}
+	err = f.GenerateStruct(m)
+	if err != nil {
+		return 0
+	}
+	kubeIngress.ConvertIngressV1alpha3(ingress, m, "mydomain")
+	return 1
+}
+
+func newServiceLister(objects ...runtime.Object) (listerv1.ServiceLister, func()) {
+	client := kube.NewFakeClient(objects...)
+	stop := make(chan struct{})
+	client.RunAndWait(stop)
+	teardown := func() {
+		close(stop)
+	}
+	return client.KubeInformer().Core().V1().Services().Lister(), teardown
+}
diff --git a/tests/fuzz/networking_core_v1alpha3_envoyfilter_fuzzer.go b/tests/fuzz/networking_core_v1alpha3_envoyfilter_fuzzer.go
new file mode 100644
index 0000000000..c580c35dc2
--- /dev/null
+++ b/tests/fuzz/networking_core_v1alpha3_envoyfilter_fuzzer.go
@@ -0,0 +1,84 @@
+//go:build gofuzz
+// +build gofuzz
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package envoyfilter
+
+import (
+	cluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
+	meshconfig "istio.io/api/mesh/v1alpha1"
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/memory"
+	"istio.io/istio/pkg/config/host"
+
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+)
+
+func InternalFuzzApplyClusterMerge(data []byte) int {
+	f := fuzz.NewConsumer(data)
+
+	// create config patches
+	number, err := f.GetInt()
+	if err != nil {
+		return 0
+	}
+	numberOfPatches := number % 30
+	configPatches := make([]*networking.EnvoyFilter_EnvoyConfigObjectPatch, numberOfPatches)
+	for i := 0; i < numberOfPatches; i++ {
+		patch := &networking.EnvoyFilter_EnvoyConfigObjectPatch{}
+		err = f.GenerateStruct(patch)
+		if err != nil {
+			return 0
+		}
+		configPatches = append(configPatches, patch)
+	}
+
+	// create proxy
+	proxy := &model.Proxy{}
+	err = f.GenerateStruct(proxy)
+	if err != nil {
+		return 0
+	}
+
+	// crete mesh config
+	testMesh := meshconfig.MeshConfig{}
+	err = f.GenerateStruct(&testMesh)
+	if err != nil {
+		return 0
+	}
+
+	// create host
+	fuzz_host, err := f.GetString()
+	if err != nil {
+		return 0
+	}
+
+	c := &cluster.Cluster{}
+	err = f.GenerateStruct(c)
+	if err != nil {
+		return 0
+	}
+
+	serviceDiscovery := memory.NewServiceDiscovery(nil)
+	env := newTestEnvironment(serviceDiscovery, testMesh, buildEnvoyFilterConfigStore(configPatches))
+	push := model.NewPushContext()
+	push.InitContext(env, nil, nil)
+	efw := push.EnvoyFilters(proxy)
+	_ = ApplyClusterMerge(networking.EnvoyFilter_GATEWAY, efw, c, []host.Name{host.Name(fuzz_host)})
+	return 1
+}
diff --git a/tests/fuzz/networking_core_v1alpha3_fuzzer.go b/tests/fuzz/networking_core_v1alpha3_fuzzer.go
new file mode 100644
index 0000000000..cea980e43f
--- /dev/null
+++ b/tests/fuzz/networking_core_v1alpha3_fuzzer.go
@@ -0,0 +1,203 @@
+//go:build gofuzz
+// +build gofuzz
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package v1alpha3
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"testing"
+
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+
+	route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/tests/fuzz/utils"
+)
+
+func init() {
+	testing.Init()
+}
+
+func ValidateTestOptions(to TestOptions) error {
+	for _, plugin := range to.Plugins {
+		if plugin == nil {
+			return errors.New("a Plugin was nil")
+		}
+	}
+	for _, csc := range to.ConfigStoreCaches {
+		if csc == nil {
+			return errors.New("a ConfigStoreCache was nil")
+		}
+	}
+	for _, sr := range to.ServiceRegistries {
+		if sr == nil {
+			return errors.New("a ServiceRegistry was nil")
+		}
+	}
+	return nil
+}
+
+func InternalFuzzbuildGatewayListeners(data []byte) int {
+	proxy := &model.Proxy{}
+	f := fuzz.NewConsumer(data)
+	to := TestOptions{}
+	err := f.GenerateStruct(&to)
+	if err != nil {
+		return 0
+	}
+	err = ValidateTestOptions(to)
+	if err != nil {
+		return 0
+	}
+	err = f.GenerateStruct(proxy)
+	if err != nil {
+		return 0
+	}
+	lb := &ListenerBuilder{}
+	err = f.GenerateStruct(lb)
+	if err != nil {
+		return 0
+	}
+	cg := NewConfigGenTest(utils.NopTester{}, to)
+	lb.node = cg.SetupProxy(proxy)
+	lb.push = cg.PushContext()
+	_ = cg.ConfigGen.buildGatewayListeners(lb)
+	return 1
+}
+
+func InternalFuzzbuildSidecarOutboundHTTPRouteConfig(data []byte) int {
+	proxy := &model.Proxy{}
+	f := fuzz.NewConsumer(data)
+	to := TestOptions{}
+	err := f.GenerateStruct(&to)
+	if err != nil {
+		return 0
+	}
+	err = ValidateTestOptions(to)
+	if err != nil {
+		return 0
+	}
+	err = f.GenerateStruct(proxy)
+	if err != nil {
+		return 0
+	}
+	req := &model.PushRequest{}
+	err = f.GenerateStruct(req)
+	if err != nil {
+		return 0
+	}
+	cg := NewConfigGenTest(utils.NopTester{}, to)
+	req.Push = cg.PushContext()
+
+	vHostCache := make(map[int][]*route.VirtualHost)
+
+	_, _ = cg.ConfigGen.buildSidecarOutboundHTTPRouteConfig(
+		cg.SetupProxy(proxy), req, "80", vHostCache, nil, nil)
+	return 1
+}
+
+func InternalFuzzbuildSidecarInboundListeners(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	proxy := model.Proxy{}
+	err := f.GenerateStruct(&proxy)
+	if err != nil {
+		return 0
+	}
+
+	// create fuzzed plugins
+	number, err := f.GetInt()
+	if err != nil {
+		return 0
+	}
+	maxPlugins := number % 20
+	if maxPlugins == 0 {
+		return 0
+	}
+	allPlugins := make([]plugin.Plugin, maxPlugins)
+	for i := 0; i < maxPlugins; i++ {
+		p := &fakePlugin{}
+		err = f.GenerateStruct(p)
+		if err != nil {
+			return 0
+		}
+		allPlugins = append(allPlugins, p)
+	}
+	cg := NewConfigGenerator(allPlugins, &model.DisabledCache{})
+
+	// create services
+	number, err = f.GetInt()
+	if err != nil {
+		return 0
+	}
+	maxServices := number % 20
+	if maxServices == 0 {
+		return 0
+	}
+	allServices := make([]*model.Service, maxServices)
+	for i := 0; i < maxServices; i++ {
+		s := &model.Service{}
+		err = f.GenerateStruct(s)
+		if err != nil {
+			return 0
+		}
+		allServices = append(allServices, s)
+	}
+	if len(allServices) == 0 {
+		return 0
+	}
+	env := buildListenerEnv(allServices)
+	if err := env.PushContext.InitContext(env, nil, nil); err != nil {
+		return 0
+	}
+	proxy.SetServiceInstances(env)
+	proxy.IstioVersion = model.ParseIstioVersion(proxy.Metadata.IstioVersion)
+	proxy.SidecarScope = model.DefaultSidecarScopeForNamespace(env.PushContext, "not-default")
+
+	fmt.Println("Calling our target:")
+	listeners := cg.buildSidecarInboundListeners(&proxy, env.PushContext)
+	_ = listeners
+	return 1
+}
+
+func InternalFuzzbuildSidecarOutboundListeners(data []byte) int {
+	t := &testing.T{}
+	proxy := &model.Proxy{}
+	f := fuzz.NewConsumer(data)
+	to := TestOptions{}
+	err := f.GenerateStruct(&to)
+	if err != nil {
+		return 0
+	}
+	err = ValidateTestOptions(to)
+	if err != nil {
+		return 0
+	}
+	err = f.GenerateStruct(proxy)
+	if err != nil {
+		return 0
+	}
+	cg := NewConfigGenTest(t, to)
+	p := cg.SetupProxy(proxy)
+	listeners := cg.ConfigGen.buildSidecarOutboundListeners(p, cg.env.PushContext)
+	_ = listeners
+	return 1
+}
diff --git a/tests/fuzz/oss_fuzz_build.sh b/tests/fuzz/oss_fuzz_build.sh
index bf2ed184e5..48c0dc4d65 100755
--- a/tests/fuzz/oss_fuzz_build.sh
+++ b/tests/fuzz/oss_fuzz_build.sh
@@ -14,8 +14,47 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+set -o nounset
+set -o pipefail
+set -o errexit
+set -x
+
 sed -i 's/out.initJwksResolver()/\/\/out.initJwksResolver()/g' "${SRC}"/istio/pilot/pkg/xds/discovery.go
 
+# Some of the fuzzers are moved to their respective packages before they are compiled. These are compiled first. TODO: Add support for regression testing of these fuzzers.
+export CUR_FUZZ_PATH="${SRC}"/istio/pilot/pkg/networking/core/v1alpha3/envoyfilter
+mv "${SRC}"/istio/tests/fuzz/networking_core_v1alpha3_envoyfilter_fuzzer.go "${CUR_FUZZ_PATH}"/
+mv "${CUR_FUZZ_PATH}"/cluster_patch_test.go "${CUR_FUZZ_PATH}"/cluster_patch_test_fuzz.go
+mv "${CUR_FUZZ_PATH}"/listener_patch_test.go "${CUR_FUZZ_PATH}"/listener_patch_test_fuzz.go
+compile_go_fuzzer istio.io/istio/pilot/pkg/networking/core/v1alpha3/envoyfilter InternalFuzzApplyClusterMerge fuzz_apply_cluster_merge
+
+export CUR_FUZZ_PATH="${SRC}"/istio/pilot/pkg/networking/core/v1alpha3
+mv "${SRC}"/istio/tests/fuzz/networking_core_v1alpha3_fuzzer.go "${CUR_FUZZ_PATH}"/
+mv "${CUR_FUZZ_PATH}"/listener_test.go "${CUR_FUZZ_PATH}"/listener_test_fuzz.go
+compile_go_fuzzer istio.io/istio/pilot/pkg/networking/core/v1alpha3 InternalFuzzbuildGatewayListeners fuzz_build_gateway_listeners
+compile_go_fuzzer istio.io/istio/pilot/pkg/networking/core/v1alpha3 InternalFuzzbuildSidecarOutboundHTTPRouteConfig fuzz_build_sidecar_outbound_http_route_config
+compile_go_fuzzer istio.io/istio/pilot/pkg/networking/core/v1alpha3 InternalFuzzbuildSidecarInboundListeners fuzz_build_sidecar_inbound_listeners
+compile_go_fuzzer istio.io/istio/pilot/pkg/networking/core/v1alpha3 InternalFuzzbuildSidecarOutboundListeners fuzz_build_sidecar_outbound_listeners
+
+mv "${SRC}"/istio/tests/fuzz/kube_controller_fuzzer.go "${SRC}"/istio/pilot/pkg/serviceregistry/kube/controller/
+compile_go_fuzzer istio.io/istio/pilot/pkg/serviceregistry/kube/controller InternalFuzzKubeController fuzz_kube_controller
+
+mv "${SRC}"/istio/tests/fuzz/security_authz_builder_fuzzer.go "${SRC}"/istio/pilot/pkg/security/authz/builder/
+compile_go_fuzzer istio.io/istio/pilot/pkg/security/authz/builder InternalFuzzBuildHTTP fuzz_build_http
+compile_go_fuzzer istio.io/istio/pilot/pkg/security/authz/builder InternalFuzzBuildTCP fuzz_build_tcp
+
+# Now compile fuzzers from tests/fuzz
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConfigValidation3 fuzz_config_validation_3
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzCidrRange fuzz_cidr_range
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzHeaderMatcher fuzz_header_matcher
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzHostMatcherWithRegex fuzz_hostMatcher_with_regex
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzHostMatcher fuzz_host_matcher
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzMetadataListMatcher fuzz_metadata_list_matcher
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzGrpcGenGenerate fuzz_grpc_gen_generate
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConvertIngressVirtualService fuzz_convert_ingress_virtual_service
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConvertIngressVirtualService2 fuzz_convert_ingress_virtual_service2
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConvertIngressV1alpha3 fuzz_convert_ingress_v1alpha3
+compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConvertIngressV1alpha32 fuzz_convert_ingress_v1alpha32
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzParseInputs fuzz_parse_inputs
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzParseAndBuildSchema fuzz_parse_and_build_schema
 compile_go_fuzzer istio.io/istio/tests/fuzz FuzzConfigValidation fuzz_config_validation
diff --git a/tests/fuzz/helm_reconciler_fuzzer.go b/tests/fuzz/pilot_networking_fuzzer.go
similarity index 53%
copy from tests/fuzz/helm_reconciler_fuzzer.go
copy to tests/fuzz/pilot_networking_fuzzer.go
index 050e8f8963..5798b77755 100644
--- a/tests/fuzz/helm_reconciler_fuzzer.go
+++ b/tests/fuzz/pilot_networking_fuzzer.go
@@ -16,35 +16,41 @@
 package fuzz
 
 import (
-	"sigs.k8s.io/controller-runtime/pkg/client"
-	"sigs.k8s.io/controller-runtime/pkg/client/fake"
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
 
-	"istio.io/istio/operator/pkg/helmreconciler"
-	"istio.io/istio/operator/pkg/object"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/grpcgen"
 )
 
-type fakeClientWrapper struct {
-	client.Client
-}
+func FuzzGrpcGenGenerate(data []byte) int {
+	f := fuzz.NewConsumer(data)
 
-func FuzzHelmReconciler(data []byte) int {
-	k8obj, err := object.ParseYAMLToK8sObject(data)
+	proxy := &model.Proxy{}
+	err := f.GenerateStruct(proxy)
 	if err != nil {
 		return 0
 	}
-	obj := k8obj.UnstructuredObject()
-	gvk := obj.GetObjectKind().GroupVersionKind()
-	if len(gvk.Kind) == 0 {
+
+	push := &model.PushContext{}
+	err = f.GenerateStruct(push)
+	if err != nil {
 		return 0
 	}
-	if len(gvk.Version) == 0 {
+
+	w := &model.WatchedResource{}
+	err = f.GenerateStruct(w)
+	if err != nil {
 		return 0
 	}
-	cl := &fakeClientWrapper{fake.NewClientBuilder().WithRuntimeObjects(obj).Build()}
-	h, err := helmreconciler.NewHelmReconciler(cl, nil, nil, nil, nil)
+
+	updates := &model.PushRequest{}
+	err = f.GenerateStruct(updates)
 	if err != nil {
 		return 0
 	}
-	_ = h.ApplyObject(obj, false)
+
+	generator := &grpcgen.GrpcConfigGenerator{}
+	_, _, _ = generator.Generate(proxy, push, w, updates)
+
 	return 1
 }
diff --git a/tests/fuzz/pilot_security_fuzzer.go b/tests/fuzz/pilot_security_fuzzer.go
new file mode 100644
index 0000000000..44b32c823d
--- /dev/null
+++ b/tests/fuzz/pilot_security_fuzzer.go
@@ -0,0 +1,95 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package fuzz
+
+import (
+	"fmt"
+
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+
+	"istio.io/istio/pilot/pkg/security/authz/matcher"
+)
+
+func FuzzCidrRange(data []byte) int {
+	_, _ = matcher.CidrRange(string(data))
+	return 1
+}
+
+func FuzzHeaderMatcher(data []byte) int {
+	k, v, err := getKandV(data)
+	if err != nil {
+		return 0
+	}
+	_ = matcher.HeaderMatcher(k, v)
+	return 1
+}
+
+func FuzzHostMatcherWithRegex(data []byte) int {
+	k, v, err := getKandV(data)
+	if err != nil {
+		return 0
+	}
+	_ = matcher.HostMatcherWithRegex(k, v)
+	return 1
+}
+
+func FuzzHostMatcher(data []byte) int {
+	k, v, err := getKandV(data)
+	if err != nil {
+		return 0
+	}
+	_ = matcher.HostMatcher(k, v)
+	return 1
+}
+
+func FuzzMetadataListMatcher(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	filter, err := f.GetString()
+	if err != nil {
+		return 0
+	}
+	number, err := f.GetInt()
+	if err != nil {
+		return 0
+	}
+	maxKeys := number % 100
+	keys := make([]string, maxKeys)
+	for i := 0; i < maxKeys; i++ {
+		key, err := f.GetString()
+		if err != nil {
+			return 0
+		}
+		keys = append(keys, key)
+	}
+	value, err := f.GetString()
+	if err != nil {
+		return 0
+	}
+	_ = matcher.MetadataListMatcher(filter, keys, matcher.StringMatcher(value))
+	return 1
+}
+
+func getKandV(data []byte) (string, string, error) {
+	if len(data) < 10 {
+		return "", "", fmt.Errorf("not enough bytes")
+	}
+	if len(data)%2 != 0 {
+		return "", "", fmt.Errorf("not correct amount of bytes")
+	}
+	k := string(data[:len(data)/2])
+	v := string(data[(len(data)/2)+1:])
+	return k, v, nil
+}
diff --git a/tests/fuzz/regression_test.go b/tests/fuzz/regression_test.go
index 1a82381c28..a182b2074b 100644
--- a/tests/fuzz/regression_test.go
+++ b/tests/fuzz/regression_test.go
@@ -146,6 +146,17 @@ func TestFuzzers(t *testing.T) {
 		{"FuzzInmemoryKube", FuzzInmemoryKube},
 		{"FuzzGenCSR", FuzzGenCSR},
 		{"FuzzCreateCertE2EUsingClientCertAuthenticator", FuzzCreateCertE2EUsingClientCertAuthenticator},
+		{"FuzzConfigValidation3", FuzzConfigValidation3},
+		{"FuzzCidrRange", FuzzCidrRange},
+		{"FuzzHeaderMatcher", FuzzHeaderMatcher},
+		{"FuzzHostMatcherWithRegex", FuzzHostMatcherWithRegex},
+		{"FuzzHostMatcher", FuzzHostMatcher},
+		{"FuzzMetadataListMatcher", FuzzMetadataListMatcher},
+		{"FuzzGrpcGenGenerate", FuzzGrpcGenGenerate},
+		{"FuzzConvertIngressVirtualService", FuzzConvertIngressVirtualService},
+		{"FuzzConvertIngressVirtualService2", FuzzConvertIngressVirtualService2},
+		{"FuzzConvertIngressV1alpha3", FuzzConvertIngressV1alpha3},
+		{"FuzzConvertIngressV1alpha32", FuzzConvertIngressV1alpha32},
 	}
 	for _, tt := range cases {
 		if testedFuzzers.Contains(tt.name) {
diff --git a/tests/fuzz/security_authz_builder_fuzzer.go b/tests/fuzz/security_authz_builder_fuzzer.go
new file mode 100644
index 0000000000..b5263588ef
--- /dev/null
+++ b/tests/fuzz/security_authz_builder_fuzzer.go
@@ -0,0 +1,74 @@
+//go:build gofuzz
+// +build gofuzz
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// nolint: golint
+package builder
+
+import (
+	"istio.io/istio/pilot/pkg/networking/plugin"
+	"istio.io/istio/pilot/pkg/security/trustdomain"
+
+	fuzz "github.com/AdaLogics/go-fuzz-headers"
+)
+
+func InternalFuzzBuildHTTP(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	bundle := trustdomain.Bundle{}
+	err := f.GenerateStruct(&bundle)
+
+	in := &plugin.InputParams{}
+	err = f.GenerateStruct(in)
+	if err != nil {
+		return 0
+	}
+
+	option := Option{}
+	err = f.GenerateStruct(&option)
+	if err != nil {
+		return 0
+	}
+	g := New(bundle, in, option)
+	if g == nil {
+		return 0
+	}
+	g.BuildHTTP()
+	return 1
+}
+
+func InternalFuzzBuildTCP(data []byte) int {
+	f := fuzz.NewConsumer(data)
+	bundle := trustdomain.Bundle{}
+	err := f.GenerateStruct(&bundle)
+
+	in := &plugin.InputParams{}
+	err = f.GenerateStruct(in)
+	if err != nil {
+		return 0
+	}
+
+	option := Option{}
+	err = f.GenerateStruct(&option)
+	if err != nil {
+		return 0
+	}
+	g := New(bundle, in, option)
+	if g == nil {
+		return 0
+	}
+	g.BuildTCP()
+	return 1
+}
diff --git a/tests/fuzz/v1alpha3_fuzzer.go b/tests/fuzz/utils/utils.go
similarity index 52%
copy from tests/fuzz/v1alpha3_fuzzer.go
copy to tests/fuzz/utils/utils.go
index 44d56d29cc..a45c9ace31 100644
--- a/tests/fuzz/v1alpha3_fuzzer.go
+++ b/tests/fuzz/utils/utils.go
@@ -13,24 +13,14 @@
 // limitations under the License.
 
 // nolint: golint
-package fuzz
+package utils
 
 import (
-	"errors"
 	"os"
-	"testing"
 
-	fuzz "github.com/AdaLogics/go-fuzz-headers"
-
-	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
 	"istio.io/istio/pkg/test"
 )
 
-func init() {
-	testing.Init()
-}
-
 type NopTester struct{}
 
 func (n NopTester) Fail() {}
@@ -55,45 +45,3 @@ func (n NopTester) Helper() {}
 func (n NopTester) Cleanup(f func()) {}
 
 var _ test.Failer = NopTester{}
-
-func ValidateTestOptions(to v1alpha3.TestOptions) error {
-	for _, plugin := range to.Plugins {
-		if plugin == nil {
-			return errors.New("a Plugin was nil")
-		}
-	}
-	for _, csc := range to.ConfigStoreCaches {
-		if csc == nil {
-			return errors.New("a ConfigStoreCache was nil")
-		}
-	}
-	for _, sr := range to.ServiceRegistries {
-		if sr == nil {
-			return errors.New("a ServiceRegistry was nil")
-		}
-	}
-	return nil
-}
-
-func FuzzValidateClusters(data []byte) int {
-	proxy := model.Proxy{}
-	f := fuzz.NewConsumer(data)
-	to := v1alpha3.TestOptions{}
-	err := f.GenerateStruct(&to)
-	if err != nil {
-		return 0
-	}
-	err = ValidateTestOptions(to)
-	if err != nil {
-		return 0
-	}
-	err = f.GenerateStruct(&proxy)
-	if err != nil {
-		return 0
-	}
-	cg := v1alpha3.NewConfigGenTest(NopTester{}, to)
-	p := cg.SetupProxy(&proxy)
-	_ = cg.Clusters(p)
-	_ = cg.Routes(p)
-	return 1
-}
diff --git a/tests/fuzz/v1alpha3_fuzzer.go b/tests/fuzz/v1alpha3_fuzzer.go
index 44d56d29cc..c95ac5af84 100644
--- a/tests/fuzz/v1alpha3_fuzzer.go
+++ b/tests/fuzz/v1alpha3_fuzzer.go
@@ -17,45 +17,19 @@
 
 import (
 	"errors"
-	"os"
 	"testing"
 
 	fuzz "github.com/AdaLogics/go-fuzz-headers"
 
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3"
-	"istio.io/istio/pkg/test"
+	"istio.io/istio/tests/fuzz/utils"
 )
 
 func init() {
 	testing.Init()
 }
 
-type NopTester struct{}
-
-func (n NopTester) Fail() {}
-
-func (n NopTester) FailNow() {}
-
-func (n NopTester) Fatal(args ...interface{}) {}
-
-func (n NopTester) Fatalf(format string, args ...interface{}) {}
-
-func (n NopTester) Log(args ...interface{}) {}
-
-func (n NopTester) Logf(format string, args ...interface{}) {}
-
-func (n NopTester) TempDir() string {
-	tempDir, _ := os.MkdirTemp("", "test")
-	return tempDir
-}
-
-func (n NopTester) Helper() {}
-
-func (n NopTester) Cleanup(f func()) {}
-
-var _ test.Failer = NopTester{}
-
 func ValidateTestOptions(to v1alpha3.TestOptions) error {
 	for _, plugin := range to.Plugins {
 		if plugin == nil {
@@ -91,7 +65,7 @@ func FuzzValidateClusters(data []byte) int {
 	if err != nil {
 		return 0
 	}
-	cg := v1alpha3.NewConfigGenTest(NopTester{}, to)
+	cg := v1alpha3.NewConfigGenTest(utils.NopTester{}, to)
 	p := cg.SetupProxy(&proxy)
 	_ = cg.Clusters(p)
 	_ = cg.Routes(p)
-- 
2.35.3

