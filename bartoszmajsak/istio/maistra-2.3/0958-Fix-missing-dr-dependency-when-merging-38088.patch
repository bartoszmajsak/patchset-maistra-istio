From 9fcfe231afabf24969e0c2de54e692cc5dcdc297 Mon Sep 17 00:00:00 2001
From: Zhonghu Xu <xuzhonghu@huawei.com>
Date: Fri, 1 Apr 2022 09:12:29 +0800
Subject: Fix missing dr dependency when merging (#38088)

---
 pilot/pkg/model/config.go                |   2 +-
 pilot/pkg/model/destination_rule.go      |  71 ++++++++---
 pilot/pkg/model/destination_rule_test.go | 149 +++++++++++++++++++++++
 pilot/pkg/model/push_context.go          |  47 ++++---
 pilot/pkg/model/push_context_test.go     |  95 ++++++++++-----
 pilot/pkg/model/sidecar.go               |  42 ++++---
 releasenotes/notes/38088.yaml            |  13 ++
 7 files changed, 335 insertions(+), 84 deletions(-)
 create mode 100644 pilot/pkg/model/destination_rule_test.go
 create mode 100644 releasenotes/notes/38088.yaml

diff --git a/pilot/pkg/model/config.go b/pilot/pkg/model/config.go
index bca7442769..c5157a30ee 100644
--- a/pilot/pkg/model/config.go
+++ b/pilot/pkg/model/config.go
@@ -282,7 +282,7 @@ func resolveGatewayName(gwname string, meta config.Meta) string {
 
 // MostSpecificHostMatch compares the map of the stack to the needle, and returns the longest element
 // matching the needle, or false if no element in the map matches the needle.
-func MostSpecificHostMatch(needle host.Name, m map[host.Name][]*config.Config) (host.Name, bool) {
+func MostSpecificHostMatch(needle host.Name, m map[host.Name][]*consolidatedDestRule) (host.Name, bool) {
 	matches := []host.Name{}
 
 	// exact match first
diff --git a/pilot/pkg/model/destination_rule.go b/pilot/pkg/model/destination_rule.go
index 4eb2da68c6..af4c489965 100644
--- a/pilot/pkg/model/destination_rule.go
+++ b/pilot/pkg/model/destination_rule.go
@@ -18,6 +18,7 @@
 	"fmt"
 
 	"google.golang.org/protobuf/proto"
+	"k8s.io/apimachinery/pkg/types"
 
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pkg/config"
@@ -41,8 +42,8 @@ func (ps *PushContext) mergeDestinationRule(p *consolidatedDestRules, destRuleCo
 	if mdrList, exists := p.destRules[resolvedHost]; exists {
 		// `addRuleToProcessedDestRules` determines if the incoming destination rule would become a new unique entry in the processedDestRules list.
 		addRuleToProcessedDestRules := true
-		for i, mdr := range mdrList {
-			existingRule := mdr.Spec.(*networking.DestinationRule)
+		for _, mdr := range mdrList {
+			existingRule := mdr.rule.Spec.(*networking.DestinationRule)
 			bothWithoutSelector := rule.GetWorkloadSelector() == nil && existingRule.GetWorkloadSelector() == nil
 			bothWithSelector := existingRule.GetWorkloadSelector() != nil && rule.GetWorkloadSelector() != nil
 			selectorsMatch := labels.Instance(existingRule.GetWorkloadSelector().GetMatchLabels()).Equals(rule.GetWorkloadSelector().GetMatchLabels())
@@ -52,7 +53,6 @@ func (ps *PushContext) mergeDestinationRule(p *consolidatedDestRules, destRuleCo
 				// if the selectors do not match
 				continue
 			}
-
 			// If both the destination rules are without a workload selector or with matching workload selectors, simply merge them.
 			// If the incoming rule has a workload selector, it has to be merged with the existing rules with workload selector, and
 			// at the same time added as a unique entry in the processedDestRules.
@@ -62,8 +62,9 @@ func (ps *PushContext) mergeDestinationRule(p *consolidatedDestRules, destRuleCo
 
 			// Deep copy destination rule, to prevent mutate it later when merge with a new one.
 			// This can happen when there are more than one destination rule of same host in one namespace.
-			copied := mdr.DeepCopy()
-			p.destRules[resolvedHost][i] = &copied
+			copied := mdr.rule.DeepCopy()
+			mdr.rule = &copied
+			mdr.from = append(mdr.from, types.NamespacedName{Namespace: destRuleConfig.Namespace, Name: destRuleConfig.Name})
 			mergedRule := copied.Spec.(*networking.DestinationRule)
 
 			existingSubset := map[string]struct{}{}
@@ -99,17 +100,17 @@ func (ps *PushContext) mergeDestinationRule(p *consolidatedDestRules, destRuleCo
 			}
 		}
 		if addRuleToProcessedDestRules {
-			p.destRules[resolvedHost] = append(p.destRules[resolvedHost], &destRuleConfig)
+			p.destRules[resolvedHost] = append(p.destRules[resolvedHost], convertConsolidatedDestRule(&destRuleConfig))
 		}
 		return
 	}
 	// DestinationRule does not exist for the resolved host so add it
-	p.destRules[resolvedHost] = append(p.destRules[resolvedHost], &destRuleConfig)
+	p.destRules[resolvedHost] = append(p.destRules[resolvedHost], convertConsolidatedDestRule(&destRuleConfig))
 	p.exportTo[resolvedHost] = exportToMap
 }
 
 // inheritDestinationRule child config inherits settings from parent mesh/namespace
-func (ps *PushContext) inheritDestinationRule(parent, child *config.Config) *config.Config {
+func (ps *PushContext) inheritDestinationRule(parent, child *consolidatedDestRule) *consolidatedDestRule {
 	if parent == nil {
 		return child
 	}
@@ -117,24 +118,64 @@ func (ps *PushContext) inheritDestinationRule(parent, child *config.Config) *con
 		return parent
 	}
 
-	parentDR := parent.Spec.(*networking.DestinationRule)
+	if parent.Equals(child) {
+		return parent
+	}
+
+	parentDR := parent.rule.Spec.(*networking.DestinationRule)
 	if parentDR.TrafficPolicy == nil {
 		return child
 	}
 
-	merged := parent.DeepCopy()
+	merged := parent.rule.DeepCopy()
 	// merge child into parent, child fields will overwrite parent's
-	proto.Merge(merged.Spec.(proto.Message), child.Spec.(proto.Message))
-	merged.Meta = child.Meta
-	merged.Status = child.Status
+	proto.Merge(merged.Spec.(proto.Message), child.rule.Spec.(proto.Message))
+	merged.Meta = child.rule.Meta
+	merged.Status = child.rule.Status
 
-	childDR := child.Spec.(*networking.DestinationRule)
+	childDR := child.rule.Spec.(*networking.DestinationRule)
 	// if parent has MUTUAL+certs/secret specified and child specifies SIMPLE, could break caCertificates
 	// if both parent and child specify TLS context, child's will be used only
 	if parentDR.TrafficPolicy.Tls != nil && (childDR.TrafficPolicy != nil && childDR.TrafficPolicy.Tls != nil) {
 		mergedDR := merged.Spec.(*networking.DestinationRule)
 		mergedDR.TrafficPolicy.Tls = childDR.TrafficPolicy.Tls.DeepCopy()
 	}
+	out := &consolidatedDestRule{}
+	out.rule = &merged
+	out.from = append(out.from, parent.from...)
+	out.from = append(out.from, child.from...)
+	return out
+}
+
+func convertConsolidatedDestRule(cfg *config.Config) *consolidatedDestRule {
+	return &consolidatedDestRule{
+		rule: cfg,
+		from: []types.NamespacedName{
+			{
+				Namespace: cfg.Namespace,
+				Name:      cfg.Name,
+			},
+		},
+	}
+}
+
+// Equals compare l equals r consolidatedDestRule or not.
+func (l *consolidatedDestRule) Equals(r *consolidatedDestRule) bool {
+	if l == r {
+		return true
+	}
+	if l == nil || r == nil {
+		return false
+	}
 
-	return &merged
+	// compare from
+	if len(l.from) != len(r.from) {
+		return false
+	}
+	for i, v := range l.from {
+		if v != r.from[i] {
+			return false
+		}
+	}
+	return true
 }
diff --git a/pilot/pkg/model/destination_rule_test.go b/pilot/pkg/model/destination_rule_test.go
new file mode 100644
index 0000000000..4f3f57d38a
--- /dev/null
+++ b/pilot/pkg/model/destination_rule_test.go
@@ -0,0 +1,149 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
+
+import (
+	"testing"
+
+	"k8s.io/apimachinery/pkg/types"
+
+	"istio.io/istio/pkg/test/util/assert"
+)
+
+func TestConsolidatedDestRuleEquals(t *testing.T) {
+	testcases := []struct {
+		name     string
+		l        *consolidatedDestRule
+		r        *consolidatedDestRule
+		expected bool
+	}{
+		{
+			name:     "two nil",
+			expected: true,
+		},
+		{
+			name: "l is nil",
+			l:    nil,
+			r: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+				},
+			},
+			expected: false,
+		},
+		{
+			name: "r is nil",
+			l: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+				},
+			},
+			r:        nil,
+			expected: false,
+		},
+		{
+			name: "from length not equal",
+			l: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+				},
+			},
+			r: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+					{
+						Namespace: "default",
+						Name:      "dr2",
+					},
+				},
+			},
+			expected: false,
+		},
+		{
+			name: "from length equals but element is different",
+			l: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+					{
+						Namespace: "default",
+						Name:      "dr2",
+					},
+				},
+			},
+			r: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+					{
+						Namespace: "default",
+						Name:      "dr3",
+					},
+				},
+			},
+			expected: false,
+		},
+		{
+			name: "all from elements equal",
+			l: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+					{
+						Namespace: "default",
+						Name:      "dr2",
+					},
+				},
+			},
+			r: &consolidatedDestRule{
+				from: []types.NamespacedName{
+					{
+						Namespace: "default",
+						Name:      "dr1",
+					},
+					{
+						Namespace: "default",
+						Name:      "dr2",
+					},
+				},
+			},
+			expected: true,
+		},
+	}
+
+	for _, tc := range testcases {
+		t.Run(tc.name, func(t *testing.T) {
+			assert.Equal(t, tc.l.Equals(tc.r), tc.expected)
+		})
+	}
+}
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index daa5408bd0..9f05d65d59 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -25,6 +25,7 @@
 	"time"
 
 	"go.uber.org/atomic"
+	"k8s.io/apimachinery/pkg/types"
 
 	extensions "istio.io/api/extensions/v1alpha1"
 	meshconfig "istio.io/api/mesh/v1alpha1"
@@ -115,14 +116,14 @@ type destinationRuleIndex struct {
 	exportedByNamespace map[string]*consolidatedDestRules
 	rootNamespaceLocal  *consolidatedDestRules
 	// mesh/namespace dest rules to be inherited
-	inheritedByNamespace map[string]*config.Config
+	inheritedByNamespace map[string]*consolidatedDestRule
 }
 
 func newDestinationRuleIndex() destinationRuleIndex {
 	return destinationRuleIndex{
 		namespaceLocal:       map[string]*consolidatedDestRules{},
 		exportedByNamespace:  map[string]*consolidatedDestRules{},
-		inheritedByNamespace: map[string]*config.Config{},
+		inheritedByNamespace: map[string]*consolidatedDestRule{},
 	}
 }
 
@@ -252,7 +253,15 @@ type consolidatedDestRules struct {
 	// Map of dest rule host to the list of namespaces to which this destination rule has been exported to
 	exportTo map[host.Name]map[visibility.Instance]bool
 	// Map of dest rule host and the merged destination rules for that host
-	destRules map[host.Name][]*config.Config
+	destRules map[host.Name][]*consolidatedDestRule
+}
+
+// consolidatedDestRule represents a dr and from which it is consolidated.
+type consolidatedDestRule struct {
+	// rule is merged from the following destinationRules.
+	rule *config.Config
+	// the original dest rules from which above rule is merged.
+	from []types.NamespacedName
 }
 
 // XDSUpdater is used for direct updates of the xDS model and incremental push.
@@ -987,7 +996,7 @@ func (ps *PushContext) getSidecarScope(proxy *Proxy, workloadLabels labels.Colle
 }
 
 // destinationRule returns a destination rule for a service name in a given namespace.
-func (ps *PushContext) destinationRule(proxyNameSpace string, service *Service) []*config.Config {
+func (ps *PushContext) destinationRule(proxyNameSpace string, service *Service) []*consolidatedDestRule {
 	if service == nil {
 		return nil
 	}
@@ -1054,18 +1063,18 @@ func (ps *PushContext) destinationRule(proxyNameSpace string, service *Service)
 	if features.EnableDestinationRuleInheritance {
 		// return namespace rule if present
 		if out := ps.destinationRuleIndex.inheritedByNamespace[proxyNameSpace]; out != nil {
-			return []*config.Config{out}
+			return []*consolidatedDestRule{out}
 		}
 		// return mesh rule
 		if out := ps.destinationRuleIndex.inheritedByNamespace[ps.Mesh.RootNamespace]; out != nil {
-			return []*config.Config{out}
+			return []*consolidatedDestRule{out}
 		}
 	}
 
 	return nil
 }
 
-func (ps *PushContext) getExportedDestinationRuleFromNamespace(owningNamespace string, hostname host.Name, clientNamespace string) []*config.Config {
+func (ps *PushContext) getExportedDestinationRuleFromNamespace(owningNamespace string, hostname host.Name, clientNamespace string) []*consolidatedDestRule {
 	if ps.destinationRuleIndex.exportedByNamespace[owningNamespace] != nil {
 		if specificHostname, ok := MostSpecificHostMatch(hostname,
 			ps.destinationRuleIndex.exportedByNamespace[owningNamespace].destRules,
@@ -1074,13 +1083,13 @@ func (ps *PushContext) getExportedDestinationRuleFromNamespace(owningNamespace s
 			exportToMap := ps.destinationRuleIndex.exportedByNamespace[owningNamespace].exportTo[specificHostname]
 			if len(exportToMap) == 0 || exportToMap[visibility.Public] || exportToMap[visibility.Instance(clientNamespace)] {
 				if features.EnableDestinationRuleInheritance {
-					var parent *config.Config
+					var parent *consolidatedDestRule
 					// client inherits global DR from its own namespace, not from the exported DR's owning namespace
 					// grab the client namespace DR or mesh if none exists
 					if parent = ps.destinationRuleIndex.inheritedByNamespace[clientNamespace]; parent == nil {
 						parent = ps.destinationRuleIndex.inheritedByNamespace[ps.Mesh.RootNamespace]
 					}
-					var inheritedDrList []*config.Config
+					var inheritedDrList []*consolidatedDestRule
 					for _, child := range ps.destinationRuleIndex.exportedByNamespace[owningNamespace].destRules[specificHostname] {
 						inheritedDr := ps.inheritDestinationRule(parent, child)
 						if inheritedDr != nil {
@@ -1658,10 +1667,10 @@ func (ps *PushContext) initDestinationRules(env *Environment) error {
 	return nil
 }
 
-func newProcessedDestRules() *consolidatedDestRules {
+func newConsolidatedDestRules() *consolidatedDestRules {
 	return &consolidatedDestRules{
 		exportTo:  map[host.Name]map[visibility.Instance]bool{},
-		destRules: map[host.Name][]*config.Config{},
+		destRules: map[host.Name][]*consolidatedDestRule{},
 	}
 }
 
@@ -1675,20 +1684,20 @@ func (ps *PushContext) SetDestinationRules(configs []config.Config) {
 	sortConfigByCreationTime(configs)
 	namespaceLocalDestRules := make(map[string]*consolidatedDestRules)
 	exportedDestRulesByNamespace := make(map[string]*consolidatedDestRules)
-	rootNamespaceLocalDestRules := newProcessedDestRules()
-	inheritedConfigs := make(map[string]*config.Config)
+	rootNamespaceLocalDestRules := newConsolidatedDestRules()
+	inheritedConfigs := make(map[string]*consolidatedDestRule)
 
 	for i := range configs {
 		rule := configs[i].Spec.(*networking.DestinationRule)
 
 		if features.EnableDestinationRuleInheritance && rule.Host == "" {
 			if t, ok := inheritedConfigs[configs[i].Namespace]; ok {
-				log.Warnf(
-					"Namespace/mesh-level DestinationRule is already defined for %q at time %v. Ignore %q which was created at time %v",
-					configs[i].Namespace, t.CreationTimestamp, configs[i].Name, configs[i].CreationTimestamp)
+				log.Warnf("Namespace/mesh-level DestinationRule is already defined for %q at time %v."+
+					" Ignore %q which was created at time %v",
+					configs[i].Namespace, t.rule.CreationTimestamp, configs[i].Name, configs[i].CreationTimestamp)
 				continue
 			}
-			inheritedConfigs[configs[i].Namespace] = &configs[i]
+			inheritedConfigs[configs[i].Namespace] = convertConsolidatedDestRule(&configs[i])
 		}
 
 		rule.Host = string(ResolveShortnameToFQDN(rule.Host, configs[i].Meta))
@@ -1709,7 +1718,7 @@ func (ps *PushContext) SetDestinationRules(configs []config.Config) {
 			// a proxy from this namespace will first look here for the destination rule for a given service
 			// This pool consists of both public/private destination rules.
 			if _, exist := namespaceLocalDestRules[configs[i].Namespace]; !exist {
-				namespaceLocalDestRules[configs[i].Namespace] = newProcessedDestRules()
+				namespaceLocalDestRules[configs[i].Namespace] = newConsolidatedDestRules()
 			}
 			// Merge this destination rule with any public/private dest rules for same host in the same namespace
 			// If there are no duplicates, the dest rule will be added to the list
@@ -1732,7 +1741,7 @@ func (ps *PushContext) SetDestinationRules(configs []config.Config) {
 
 		if !isPrivateOnly {
 			if _, exist := exportedDestRulesByNamespace[configs[i].Namespace]; !exist {
-				exportedDestRulesByNamespace[configs[i].Namespace] = newProcessedDestRules()
+				exportedDestRulesByNamespace[configs[i].Namespace] = newConsolidatedDestRules()
 			}
 			// Merge this destination rule with any other exported dest rule for the same host in the same namespace
 			// If there are no duplicates, the dest rule will be added to the list
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index 14710858e4..ffc333255e 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -31,6 +31,7 @@
 	"google.golang.org/protobuf/testing/protocmp"
 	"google.golang.org/protobuf/types/known/durationpb"
 	"google.golang.org/protobuf/types/known/structpb"
+	"k8s.io/apimachinery/pkg/types"
 
 	extensions "istio.io/api/extensions/v1alpha1"
 	meshconfig "istio.io/api/mesh/v1alpha1"
@@ -942,7 +943,7 @@ func TestInitPushContext(t *testing.T) {
 		// Allow looking into exported fields for parts of push context
 		cmp.AllowUnexported(PushContext{}, exportToDefaults{}, serviceIndex{}, virtualServiceIndex{},
 			destinationRuleIndex{}, gatewayIndex{}, consolidatedDestRules{}, IstioEgressListenerWrapper{}, SidecarScope{},
-			AuthenticationPolicies{}, NetworkManager{}, sidecarIndex{}, Telemetries{}, ProxyConfigs{}),
+			AuthenticationPolicies{}, NetworkManager{}, sidecarIndex{}, Telemetries{}, ProxyConfigs{}, consolidatedDestRule{}),
 		// These are not feasible/worth comparing
 		cmpopts.IgnoreTypes(sync.RWMutex{}, localServiceDiscovery{}, FakeStore{}, atomic.Bool{}, sync.Mutex{}),
 		cmpopts.IgnoreInterfaces(struct{ mesh.Holder }{}),
@@ -1274,12 +1275,13 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 		},
 	}
 	testCases := []struct {
-		name            string
-		proxyNs         string
-		serviceNs       string
-		serviceHostname string
-		expectedConfig  string
-		expectedPolicy  *networking.TrafficPolicy
+		name               string
+		proxyNs            string
+		serviceNs          string
+		serviceHostname    string
+		expectedConfig     string
+		expectedSourceRule []types.NamespacedName
+		expectedPolicy     *networking.TrafficPolicy
 	}{
 		{
 			name:            "merge mesh+namespace+service DR",
@@ -1287,6 +1289,11 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 			serviceNs:       "test",
 			serviceHostname: testhost,
 			expectedConfig:  "svcRule",
+			expectedSourceRule: []types.NamespacedName{
+				{"istio-system", "meshRule"},
+				{"test", "nsRule"},
+				{"test", "svcRule"},
+			},
 			expectedPolicy: &networking.TrafficPolicy{
 				ConnectionPool: &networking.ConnectionPoolSettings{
 					Http: &networking.ConnectionPoolSettings_HTTPSettings{
@@ -1313,6 +1320,10 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 			serviceNs:       "test2",
 			serviceHostname: testhost,
 			expectedConfig:  "svcRule2",
+			expectedSourceRule: []types.NamespacedName{
+				{"istio-system", "meshRule"},
+				{"test2", "svcRule2"},
+			},
 			expectedPolicy: &networking.TrafficPolicy{
 				ConnectionPool: &networking.ConnectionPoolSettings{
 					Tcp: &networking.ConnectionPoolSettings_TCPSettings{
@@ -1334,6 +1345,11 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 			serviceNs:       "test2",
 			serviceHostname: testhost,
 			expectedConfig:  "drRule2",
+			expectedSourceRule: []types.NamespacedName{
+				{"istio-system", "meshRule"},
+				{"test2", "drRule2"},
+				{"test2", "svcRule2"},
+			},
 			expectedPolicy: &networking.TrafficPolicy{
 				ConnectionPool: &networking.ConnectionPoolSettings{
 					Http: &networking.ConnectionPoolSettings_HTTPSettings{
@@ -1361,6 +1377,10 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 			serviceNs:       "test",
 			serviceHostname: "unknown.host",
 			expectedConfig:  "nsRule",
+			expectedSourceRule: []types.NamespacedName{
+				{"istio-system", "meshRule"},
+				{"test", "nsRule"},
+			},
 			expectedPolicy: &networking.TrafficPolicy{
 				ConnectionPool: &networking.ConnectionPoolSettings{
 					Http: &networking.ConnectionPoolSettings_HTTPSettings{
@@ -1389,31 +1409,37 @@ func TestSetDestinationRuleInheritance(t *testing.T) {
 			serviceNs:       "unknown",
 			serviceHostname: "unknown.host",
 			expectedConfig:  "meshRule",
-			expectedPolicy:  meshDestinationRule.Spec.(*networking.DestinationRule).TrafficPolicy,
+			expectedSourceRule: []types.NamespacedName{
+				{"istio-system", "meshRule"},
+			},
+			expectedPolicy: meshDestinationRule.Spec.(*networking.DestinationRule).TrafficPolicy,
 		},
 	}
 
 	ps.SetDestinationRules([]config.Config{meshDestinationRule, nsDestinationRule, svcDestinationRule, destinationRuleNamespace2, workloadSpecificDrNamespace2})
 
 	for _, tt := range testCases {
-		mergedConfigList := ps.destinationRule(tt.proxyNs,
-			&Service{
-				Hostname: host.Name(tt.serviceHostname),
-				Attributes: ServiceAttributes{
-					Namespace: tt.serviceNs,
-				},
-			})
-		expectedConfigPresent := false
-		for _, mergedConfig := range mergedConfigList {
-			if mergedConfig.Name == tt.expectedConfig {
-				expectedConfigPresent = true
-				mergedPolicy := mergedConfig.Spec.(*networking.DestinationRule).TrafficPolicy
-				assert.Equal(t, mergedPolicy, tt.expectedPolicy)
+		t.Run(tt.name, func(t *testing.T) {
+			mergedConfigList := ps.destinationRule(tt.proxyNs,
+				&Service{
+					Hostname: host.Name(tt.serviceHostname),
+					Attributes: ServiceAttributes{
+						Namespace: tt.serviceNs,
+					},
+				})
+			expectedConfigPresent := false
+			for _, mergedConfig := range mergedConfigList {
+				if mergedConfig.rule.Name == tt.expectedConfig {
+					expectedConfigPresent = true
+					mergedPolicy := mergedConfig.rule.Spec.(*networking.DestinationRule).TrafficPolicy
+					assert.Equal(t, mergedPolicy, tt.expectedPolicy)
+					assert.Equal(t, mergedConfig.from, tt.expectedSourceRule)
+				}
 			}
-		}
-		if !expectedConfigPresent {
-			t.Errorf("case %s failed, merged config should contain most specific config name, wanted %v but missing", tt.name, tt.expectedConfig)
-		}
+			if !expectedConfigPresent {
+				t.Errorf("case %s failed, merged config should contain most specific config name, wanted %v but missing", tt.name, tt.expectedConfig)
+			}
+		})
 	}
 }
 
@@ -1580,8 +1606,8 @@ func TestSetDestinationRuleWithWorkloadSelector(t *testing.T) {
 			t.Errorf("case %s failed, %d destinationRules for host %v got %v", tt.name, tt.expectedDrCount, tt.serviceHostname, drList)
 		}
 		for i, dr := range drList {
-			if dr.Meta.Name != tt.expectedDrName[i] {
-				t.Errorf("case %s failed, destinationRuleName expected %v got %v", tt.name, tt.expectedDrName[i], dr.Meta.Name)
+			if dr.rule.Name != tt.expectedDrName[i] {
+				t.Errorf("case %s failed, destinationRuleName expected %v got %v", tt.name, tt.expectedDrName[i], dr.rule.Name)
 			}
 		}
 	}
@@ -1625,13 +1651,20 @@ func TestSetDestinationRuleMerging(t *testing.T) {
 			},
 		},
 	}
+	expectedDestRules := []types.NamespacedName{
+		{"test", "rule1"},
+		{"test", "rule2"},
+	}
 	ps.SetDestinationRules([]config.Config{destinationRuleNamespace1, destinationRuleNamespace2})
-	subsetsLocal := ps.destinationRuleIndex.namespaceLocal["test"].destRules[host.Name(testhost)][0].Spec.(*networking.DestinationRule).Subsets
-	subsetsExport := ps.destinationRuleIndex.exportedByNamespace["test"].destRules[host.Name(testhost)][0].Spec.(*networking.DestinationRule).Subsets
+	private := ps.destinationRuleIndex.namespaceLocal["test"].destRules[host.Name(testhost)]
+	public := ps.destinationRuleIndex.exportedByNamespace["test"].destRules[host.Name(testhost)]
+	subsetsLocal := private[0].rule.Spec.(*networking.DestinationRule).Subsets
+	subsetsExport := public[0].rule.Spec.(*networking.DestinationRule).Subsets
+	assert.Equal(t, private[0].from, expectedDestRules)
+	assert.Equal(t, public[0].from, expectedDestRules)
 	if len(subsetsLocal) != 4 {
 		t.Errorf("want %d, but got %d", 4, len(subsetsLocal))
 	}
-
 	if len(subsetsExport) != 4 {
 		t.Errorf("want %d, but got %d", 4, len(subsetsExport))
 	}
@@ -1859,7 +1892,7 @@ func TestSetDestinationRuleWithExportTo(t *testing.T) {
 			if destRuleConfig == nil {
 				t.Fatalf("proxy in %s namespace: dest rule is nil, expected subsets %+v", tt.proxyNs, tt.wantSubsets)
 			}
-			destRule := destRuleConfig.Spec.(*networking.DestinationRule)
+			destRule := destRuleConfig.rule.Spec.(*networking.DestinationRule)
 			var gotSubsets []string
 			for _, ss := range destRule.Subsets {
 				gotSubsets = append(gotSubsets, ss.Name)
diff --git a/pilot/pkg/model/sidecar.go b/pilot/pkg/model/sidecar.go
index 4dfa28f3c3..82125b5bb4 100644
--- a/pilot/pkg/model/sidecar.go
+++ b/pilot/pkg/model/sidecar.go
@@ -98,7 +98,8 @@ type SidecarScope struct {
 	// corresponds to a service in the services array above. When computing
 	// CDS, we simply have to find the matching service and return the
 	// destination rule.
-	destinationRules map[host.Name][]*config.Config
+	destinationRules map[host.Name][]*consolidatedDestRule
+
 	// OutboundTrafficPolicy defines the outbound traffic policy for this sidecar.
 	// If OutboundTrafficPolicy is ALLOW_ANY traffic to unknown destinations will
 	// be forwarded.
@@ -184,7 +185,7 @@ func DefaultSidecarScopeForNamespace(ps *PushContext, configNamespace string) *S
 		Namespace:          configNamespace,
 		EgressListeners:    []*IstioEgressListenerWrapper{defaultEgressListener},
 		services:           defaultEgressListener.services,
-		destinationRules:   make(map[host.Name][]*config.Config),
+		destinationRules:   make(map[host.Name][]*consolidatedDestRule),
 		servicesByHostname: make(map[host.Name]*Service, len(defaultEgressListener.services)),
 		configDependencies: make(map[uint64]struct{}),
 		RootNamespace:      ps.Mesh.RootNamespace,
@@ -218,11 +219,13 @@ func DefaultSidecarScopeForNamespace(ps *PushContext, configNamespace string) *S
 
 	for _, drList := range out.destinationRules {
 		for _, dr := range drList {
-			out.AddConfigDependencies(ConfigKey{
-				Kind:      gvk.DestinationRule,
-				Name:      dr.Name,
-				Namespace: dr.Namespace,
-			})
+			for _, namespacedName := range dr.from {
+				out.AddConfigDependencies(ConfigKey{
+					Kind:      gvk.DestinationRule,
+					Name:      namespacedName.Name,
+					Namespace: namespacedName.Namespace,
+				})
+			}
 		}
 	}
 
@@ -402,17 +405,20 @@ type serviceIndex struct {
 	// this config namespace) will see, identify all the destinationRules
 	// that these services need
 	out.servicesByHostname = make(map[host.Name]*Service, len(out.services))
-	out.destinationRules = make(map[host.Name][]*config.Config)
+	out.destinationRules = make(map[host.Name][]*consolidatedDestRule)
 	for _, s := range out.services {
 		out.servicesByHostname[s.Hostname] = s
-		if drList := ps.destinationRule(configNamespace, s); drList != nil {
+		drList := ps.destinationRule(configNamespace, s)
+		if drList != nil {
 			out.destinationRules[s.Hostname] = drList
 			for _, dr := range drList {
-				out.AddConfigDependencies(ConfigKey{
-					Kind:      gvk.DestinationRule,
-					Name:      dr.Name,
-					Namespace: dr.Namespace,
-				})
+				for _, key := range dr.from {
+					out.AddConfigDependencies(ConfigKey{
+						Kind:      gvk.DestinationRule,
+						Name:      key.Name,
+						Namespace: key.Namespace,
+					})
+				}
 			}
 		}
 	}
@@ -559,20 +565,20 @@ func (sc *SidecarScope) DestinationRule(direction TrafficDirection, proxy *Proxy
 	destinationRules := sc.destinationRules[svc]
 	var catchAllDr *config.Config
 	for _, destRule := range destinationRules {
-		destinationRule := destRule.Spec.(*networking.DestinationRule)
+		destinationRule := destRule.rule.Spec.(*networking.DestinationRule)
 		if destinationRule.GetWorkloadSelector() == nil {
-			catchAllDr = destRule
+			catchAllDr = destRule.rule
 		}
 		// filter DestinationRule based on workloadSelector for outbound configs.
 		// WorkloadSelector configuration is honored only for outbound configuration, because
 		// for inbound configuration, the settings at sidecar would be more explicit and the preferred way forward.
-		if sc.Namespace == destRule.Namespace &&
+		if sc.Namespace == destRule.rule.Namespace &&
 			destinationRule.GetWorkloadSelector() != nil && direction == TrafficDirectionOutbound {
 			workloadLabels := labels.Collection{proxy.Metadata.Labels}
 			workloadSelector := labels.Instance(destinationRule.GetWorkloadSelector().GetMatchLabels())
 			// return destination rule if workload selector matches
 			if workloadLabels.IsSupersetOf(workloadSelector) {
-				return destRule
+				return destRule.rule
 			}
 		}
 	}
diff --git a/releasenotes/notes/38088.yaml b/releasenotes/notes/38088.yaml
new file mode 100644
index 0000000000..051b90499b
--- /dev/null
+++ b/releasenotes/notes/38088.yaml
@@ -0,0 +1,13 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+  - 38082
+releaseNotes:
+  - |
+    **Fixed** xDS may not be updated when there are multiple destinationRules for a service are merged.
+    In this case the merged rule does only record one name/namespace pair of all the destinationRules.
+    however this meta is used to record config dependencies of a sidecar.
+
+    In this fix, we inroduce a new struct `consolidatedDestRule` and record all the destinationrules' meta.
+    And then we will not miss any destinationRule dependency.
\ No newline at end of file
-- 
2.35.3

