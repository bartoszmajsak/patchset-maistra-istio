From 8c8c0d8a5f7dbb5b0da3c9bc793f27055427baea Mon Sep 17 00:00:00 2001
From: zirain <hejianpeng2@huawei.com>
Date: Tue, 19 Apr 2022 17:37:38 +0800
Subject: fix passthrough idle timeout (#38422)

* fix passthrough idle timeout

* unset inbound blackhole idle timeout

* update UT

Signed-off-by: hejianpeng <hejianpeng2@huawei.com>
---
 .../core/v1alpha3/listener_builder.go         |  6 +++
 .../networking/core/v1alpha3/listener_test.go | 45 +++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index e542a925dc..858db460cb 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -16,6 +16,7 @@
 
 import (
 	"sort"
+	"time"
 
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
@@ -714,10 +715,15 @@ func buildOutboundCatchAllNetworkFiltersOnly(push *model.PushContext, node *mode
 	} else {
 		egressCluster = util.BlackHoleCluster
 	}
+	idleTimeoutDuration, err := time.ParseDuration(node.Metadata.IdleTimeout)
+	if err != nil {
+		idleTimeoutDuration = 0
+	}
 
 	tcpProxy := &tcp.TcpProxy{
 		StatPrefix:       egressCluster,
 		ClusterSpecifier: &tcp.TcpProxy_Cluster{Cluster: egressCluster},
+		IdleTimeout:      durationpb.New(idleTimeoutDuration),
 	}
 	filterStack := buildMetricsNetworkFilters(push, node, istionetworking.ListenerClassSidecarOutbound)
 	accessLogBuilder.setTCPAccessLog(push, node, tcpProxy)
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 5e49dad89a..e47805f56d 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -34,6 +34,7 @@
 	"github.com/google/go-cmp/cmp"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/testing/protocmp"
+	"google.golang.org/protobuf/types/known/durationpb"
 	"google.golang.org/protobuf/types/known/structpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
@@ -2979,6 +2980,7 @@ func TestAppendListenerFallthroughRouteForCompleteListener(t *testing.T) {
 		listenerOpts *buildListenerOpts
 		node         *model.Proxy
 		hostname     string
+		idleTimeout  *durationpb.Duration
 	}{
 		{
 			name:     "Registry_Only",
@@ -3014,6 +3016,46 @@ func TestAppendListenerFallthroughRouteForCompleteListener(t *testing.T) {
 			},
 			hostname: util.PassthroughCluster,
 		},
+		{
+			name:     "idle_timeout",
+			listener: &listener.Listener{},
+			listenerOpts: &buildListenerOpts{
+				push: push,
+			},
+			node: &model.Proxy{
+				ID: "foo.bar",
+				Metadata: &model.NodeMetadata{
+					IdleTimeout: "15s",
+				},
+				SidecarScope: &model.SidecarScope{
+					OutboundTrafficPolicy: &networking.OutboundTrafficPolicy{
+						Mode: networking.OutboundTrafficPolicy_ALLOW_ANY,
+					},
+				},
+			},
+			hostname:    util.PassthroughCluster,
+			idleTimeout: durationpb.New(15 * time.Second),
+		},
+		{
+			name:     "invalid_idle_timeout",
+			listener: &listener.Listener{},
+			listenerOpts: &buildListenerOpts{
+				push: push,
+			},
+			node: &model.Proxy{
+				ID: "foo.bar",
+				Metadata: &model.NodeMetadata{
+					IdleTimeout: "s15s",
+				},
+				SidecarScope: &model.SidecarScope{
+					OutboundTrafficPolicy: &networking.OutboundTrafficPolicy{
+						Mode: networking.OutboundTrafficPolicy_ALLOW_ANY,
+					},
+				},
+			},
+			hostname:    util.PassthroughCluster,
+			idleTimeout: durationpb.New(0 * time.Second),
+		},
 	}
 	configgen := NewConfigGenerator([]plugin.Plugin{}, &model.DisabledCache{})
 	for idx := range tests {
@@ -3036,6 +3078,9 @@ func TestAppendListenerFallthroughRouteForCompleteListener(t *testing.T) {
 			if tcpProxy.GetCluster() != tests[idx].hostname {
 				t.Errorf("Expected cluster %s but got %s\n", tests[idx].hostname, tcpProxy.GetCluster())
 			}
+			if tests[idx].idleTimeout != nil && !reflect.DeepEqual(tcpProxy.IdleTimeout, tests[idx].idleTimeout) {
+				t.Errorf("Expected IdleTimeout %s but got %s\n", tests[idx].idleTimeout, tcpProxy.IdleTimeout)
+			}
 		})
 	}
 }
-- 
2.35.3

