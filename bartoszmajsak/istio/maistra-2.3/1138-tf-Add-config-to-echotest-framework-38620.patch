From 503d2d01631f9bec35e4af5281ebd6225a9f652b Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Wed, 27 Apr 2022 16:26:33 -0700
Subject: [tf] Add config to echotest framework (#38620)

This supports https://github.com/istio/istio/pull/37914. Allows the echotest framework to automatically determine when to apply configuration.
---
 .../components/echo/config/builder.go         | 265 ++++++++++++++++++
 .../components/echo/config/param/params.go    |  78 ++++++
 .../components/echo/config/param/template.go  |  97 +++++++
 .../echo/config/param/template_test.go        |  73 +++++
 .../components/echo/config/param/wellknown.go |  37 +++
 .../components/echo/config/source.go          | 170 +++++++++++
 .../components/echo/echotest/config.go        |  25 ++
 .../components/echo/echotest/echotest.go      |  10 +-
 .../framework/components/echo/echotest/run.go |  30 +-
 9 files changed, 780 insertions(+), 5 deletions(-)
 create mode 100644 pkg/test/framework/components/echo/config/builder.go
 create mode 100644 pkg/test/framework/components/echo/config/param/params.go
 create mode 100644 pkg/test/framework/components/echo/config/param/template.go
 create mode 100644 pkg/test/framework/components/echo/config/param/template_test.go
 create mode 100644 pkg/test/framework/components/echo/config/param/wellknown.go
 create mode 100644 pkg/test/framework/components/echo/config/source.go
 create mode 100644 pkg/test/framework/components/echo/echotest/config.go

diff --git a/pkg/test/framework/components/echo/config/builder.go b/pkg/test/framework/components/echo/config/builder.go
new file mode 100644
index 0000000000..1dc057accf
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/builder.go
@@ -0,0 +1,265 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package config
+
+import (
+	"fmt"
+	"reflect"
+	"time"
+
+	"istio.io/istio/pkg/test/framework"
+	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/config/param"
+	"istio.io/istio/pkg/test/framework/components/istio"
+	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/test/framework/resource/config"
+	"istio.io/istio/pkg/test/framework/resource/config/apply"
+	"istio.io/istio/pkg/test/scopes"
+)
+
+// Builder of configuration.
+type Builder struct {
+	t             framework.TestContext
+	out           config.Plan
+	needFrom      []Source
+	needTo        []Source
+	needFromAndTo []Source
+	complete      []Source
+}
+
+func New(t framework.TestContext) *Builder {
+	return NewWithOutput(t, t.ConfigIstio().New())
+}
+
+// NewWithOutput creates a new Builder that targets the given config as output.
+func NewWithOutput(t framework.TestContext, out config.Plan) *Builder {
+	t.Helper()
+	checkNotNil("t", t)
+	checkNotNil("out", out)
+
+	return &Builder{
+		t:   t,
+		out: out,
+	}
+}
+
+func checkNotNil(name string, value interface{}) {
+	if value == nil {
+		panic(fmt.Sprintf("%s must not be nil", name))
+	}
+}
+
+// Output returns a copy of this Builder with the given output set.
+func (b *Builder) Output(out config.Plan) *Builder {
+	b.t.Helper()
+
+	checkNotNil("out", out)
+
+	ret := b.Copy()
+	ret.out = out
+	return ret
+}
+
+// Context returns a copy of this Builder with the given context set.
+func (b *Builder) Context(t framework.TestContext) *Builder {
+	checkNotNil("t", t)
+	out := b.Copy()
+	out.t = t
+	return out
+}
+
+// Source returns a copy of this Builder with the given Source added.
+func (b *Builder) Source(s Source) *Builder {
+	b.t.Helper()
+	out := b.Copy()
+
+	// If the caller set namespaces with literal strings, replace with namespace.Instance objects.
+	s = replaceNamespaceStrings(s)
+
+	tpl := s.TemplateOrFail(out.t)
+	need := tpl.MissingParams(s.Params())
+	needFrom := need.Contains(param.From.String())
+	needTo := need.Contains(param.To.String())
+
+	if needFrom && needTo {
+		out.needFromAndTo = append(out.needFromAndTo, s)
+	} else if needFrom {
+		out.needFrom = append(out.needFrom, s)
+	} else if needTo {
+		out.needTo = append(out.needTo, s)
+	} else {
+		// No well-known parameters are missing.
+		out.complete = append(out.complete, s)
+	}
+	return out
+}
+
+// BuildCompleteSources builds only those sources that already contain all parameters
+// needed by their templates. Specifically, they are not missing any of the well-known
+// parameters: "From", "To", or "Namespace".
+func (b *Builder) BuildCompleteSources() *Builder {
+	b.t.Helper()
+	out := b.Copy()
+
+	systemNS := istio.ClaimSystemNamespaceOrFail(out.t, out.t)
+
+	// Build all the complete config that doesn't require well-known parameters.
+	for _, s := range out.complete {
+		out.addYAML(withParams(s, param.Params{
+			param.SystemNamespace.String(): systemNS,
+		}))
+	}
+
+	return out
+}
+
+// BuildFrom builds only those sources that require only the "From" parameter.
+func (b *Builder) BuildFrom(fromAll ...echo.Caller) *Builder {
+	b.t.Helper()
+	out := b.Copy()
+
+	systemNS := istio.ClaimSystemNamespaceOrFail(out.t, out.t)
+
+	for _, from := range fromAll {
+		for _, s := range out.needFrom {
+			out.addYAML(withParams(s, param.Params{
+				param.From.String():            from,
+				param.SystemNamespace.String(): systemNS,
+			}))
+		}
+	}
+
+	return out
+}
+
+// BuildFromAndTo builds only those sources that require both the "From" and "To" parameters.
+func (b *Builder) BuildFromAndTo(fromAll echo.Callers, toAll echo.Services) *Builder {
+	b.t.Helper()
+	out := b.Copy()
+
+	systemNS := istio.ClaimSystemNamespaceOrFail(out.t, out.t)
+
+	for _, from := range fromAll {
+		for _, to := range toAll {
+			for _, s := range out.needFromAndTo {
+				out.addYAML(withParams(s, param.Params{
+					param.From.String():            from,
+					param.To.String():              to,
+					param.Namespace.String():       to.Config().Namespace,
+					param.SystemNamespace.String(): systemNS,
+				}))
+			}
+		}
+	}
+
+	for _, to := range toAll {
+		for _, s := range out.needTo {
+			out.addYAML(withParams(s, param.Params{
+				param.To.String():              to,
+				param.Namespace.String():       to.Config().Namespace,
+				param.SystemNamespace.String(): systemNS,
+			}))
+		}
+	}
+
+	return out
+}
+
+// BuildAll builds the config for all sources.
+func (b *Builder) BuildAll(fromAll echo.Callers, toAll echo.Services) *Builder {
+	b.t.Helper()
+
+	return b.BuildCompleteSources().
+		BuildFrom(fromAll...).
+		BuildFromAndTo(fromAll, toAll)
+}
+
+func (b *Builder) Apply(opts ...apply.Option) {
+	start := time.Now()
+	scopes.Framework.Info("=== BEGIN: Deploy config ===")
+
+	b.out.ApplyOrFail(b.t, opts...)
+
+	scopes.Framework.Infof("=== SUCCEEDED: Deploy config in %v ===", time.Since(start))
+}
+
+// Replace any namespace strings with namespace.Instance objects.
+func replaceNamespaceStrings(s Source) Source {
+	params := s.Params()
+	newParams := param.NewParams()
+	for _, nsKey := range []param.WellKnown{param.Namespace, param.SystemNamespace} {
+		if params.ContainsWellKnown(nsKey) {
+			val := params.GetWellKnown(nsKey)
+			if strVal, ok := val.(string); ok {
+				newParams.SetWellKnown(nsKey, namespace.Static(strVal))
+			}
+		}
+	}
+	return s.WithParams(newParams)
+}
+
+func (b *Builder) addYAML(s Source) {
+	b.t.Helper()
+
+	// Ensure all parameters have been set.
+	b.checkMissing(s)
+
+	// Get the namespace where the config should be applied.
+	ns := b.getNamespace(s)
+
+	// Generate the YAML and add it to the configuration.
+	b.out.YAML(ns.Name(), s.YAMLOrFail(b.t))
+}
+
+func withParams(s Source, params param.Params) Source {
+	return s.WithParams(s.Params().SetAllNoOverwrite(params))
+}
+
+func (b *Builder) checkMissing(s Source) {
+	b.t.Helper()
+	tpl := s.TemplateOrFail(b.t)
+	missing := tpl.MissingParams(s.Params())
+	if missing.Len() > 0 {
+		b.t.Fatalf("config template requires missing params: %v", missing.SortedList())
+	}
+}
+
+func (b *Builder) getNamespace(s Source) namespace.Instance {
+	b.t.Helper()
+	ns := s.Params().GetWellKnown(param.Namespace)
+	if ns == nil {
+		b.t.Fatalf("no %s specified in config params", param.Namespace)
+	}
+	inst, ok := ns.(namespace.Instance)
+	if !ok {
+		b.t.Fatalf("%s was of unexpected type: %v", param.Namespace, reflect.TypeOf(ns))
+	}
+	return inst
+}
+
+func (b *Builder) Copy() *Builder {
+	return &Builder{
+		t:             b.t,
+		needFrom:      copySources(b.needFrom),
+		needTo:        copySources(b.needTo),
+		needFromAndTo: copySources(b.needFromAndTo),
+		complete:      copySources(b.complete),
+		out:           b.out.Copy(),
+	}
+}
+
+func copySources(sources []Source) []Source {
+	return append([]Source{}, sources...)
+}
diff --git a/pkg/test/framework/components/echo/config/param/params.go b/pkg/test/framework/components/echo/config/param/params.go
new file mode 100644
index 0000000000..a2b7be47d3
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/param/params.go
@@ -0,0 +1,78 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package param
+
+// Params for a Template.
+type Params map[string]interface{}
+
+// NewParams returns a new Params instance.
+func NewParams() Params {
+	return make(Params)
+}
+
+func (p Params) Get(k string) interface{} {
+	return p[k]
+}
+
+func (p Params) GetWellKnown(k WellKnown) interface{} {
+	return p[k.String()]
+}
+
+func (p Params) Set(k string, v interface{}) Params {
+	p[k] = v
+	return p
+}
+
+func (p Params) SetAll(other Params) Params {
+	for k, v := range other {
+		p[k] = v
+	}
+	return p
+}
+
+func (p Params) SetAllNoOverwrite(other Params) Params {
+	for k, v := range other {
+		if !p.Contains(k) {
+			p[k] = v
+		}
+	}
+	return p
+}
+
+func (p Params) SetWellKnown(k WellKnown, v interface{}) Params {
+	p[k.String()] = v
+	return p
+}
+
+func (p Params) Contains(k string) bool {
+	_, found := p[k]
+	return found
+}
+
+func (p Params) ContainsWellKnown(k WellKnown) bool {
+	return p.Contains(k.String())
+}
+
+func (p Params) Copy() Params {
+	if p == nil {
+		return NewParams()
+	}
+
+	out := make(map[string]interface{})
+	for k, v := range p {
+		out[k] = v
+	}
+	return out
+}
diff --git a/pkg/test/framework/components/echo/config/param/template.go b/pkg/test/framework/components/echo/config/param/template.go
new file mode 100644
index 0000000000..e21c9710cf
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/param/template.go
@@ -0,0 +1,97 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package param
+
+import (
+	"text/template"
+	"text/template/parse"
+
+	"istio.io/istio/pkg/util/sets"
+)
+
+// Template that has been parsed to search for template parameters.
+type Template struct {
+	*template.Template
+	params sets.Set
+}
+
+// Parse the given template to find the set of template parameters used.
+func Parse(t *template.Template) *Template {
+	return &Template{
+		Template: t,
+		params:   getParams(t.Root),
+	}
+}
+
+// Params returns the set of parameters that were found in this template.
+func (t Template) Params() sets.Set {
+	return t.params.Copy()
+}
+
+// Contains returns true if the given parameter is used by this Template.
+func (t Template) Contains(p string) bool {
+	return t.params.Contains(p)
+}
+
+// ContainsWellKnown returns true if the given well-known parameter is used by
+// this Template.
+func (t Template) ContainsWellKnown(p WellKnown) bool {
+	return t.Contains(p.String())
+}
+
+// MissingParams checks the provided params against the parameters used in this Template.
+// Returns the set of template parameters not defined in params.
+func (t Template) MissingParams(params Params) sets.Set {
+	out := sets.New()
+	for needed := range t.params {
+		if !params.Contains(needed) {
+			out.Insert(needed)
+		}
+	}
+	return out
+}
+
+func getParams(n parse.Node) sets.Set {
+	out := sets.New()
+	switch n.Type() {
+	case parse.NodeField:
+		// Only look at the first identifier. For example, if the action
+		// is {{.To.Config.Service}}, this will return "To" as the parameter.
+		// That's all we need when looking for well-known params.
+		firstIdentifier := n.(*parse.FieldNode).Ident[0]
+		out.Insert(firstIdentifier)
+	case parse.NodeIf:
+		out.Merge(getParams(n.(*parse.IfNode).Pipe))
+	case parse.NodeWith:
+		out.Merge(getParams(n.(*parse.WithNode).Pipe))
+	case parse.NodeRange:
+		out.Merge(getParams(n.(*parse.RangeNode).Pipe))
+	case parse.NodeAction:
+		out.Merge(getParams(n.(*parse.ActionNode).Pipe))
+	case parse.NodeCommand:
+		for _, arg := range n.(*parse.CommandNode).Args {
+			out.Merge(getParams(arg))
+		}
+	case parse.NodePipe:
+		for _, c := range n.(*parse.PipeNode).Cmds {
+			out.Merge(getParams(c))
+		}
+	case parse.NodeList:
+		for _, next := range n.(*parse.ListNode).Nodes {
+			out.Merge(getParams(next))
+		}
+	}
+	return out
+}
diff --git a/pkg/test/framework/components/echo/config/param/template_test.go b/pkg/test/framework/components/echo/config/param/template_test.go
new file mode 100644
index 0000000000..1016d6383a
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/param/template_test.go
@@ -0,0 +1,73 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package param_test
+
+import (
+	"testing"
+
+	. "github.com/onsi/gomega"
+
+	"istio.io/istio/pkg/test/framework/components/echo/config/param"
+	"istio.io/istio/pkg/test/util/tmpl"
+)
+
+func TestContains(t *testing.T) {
+	cases := []struct {
+		name        string
+		template    string
+		expectFound bool
+	}{
+		{
+			name:        "empty",
+			template:    "",
+			expectFound: false,
+		},
+		{
+			name:        "wrong param",
+			template:    "{{ .Other.some.thing }}",
+			expectFound: false,
+		},
+		{
+			name:        "basic",
+			template:    "{{ .To }}",
+			expectFound: true,
+		},
+		{
+			name:        "with method calls",
+			template:    "{{ .To.some.thing }}",
+			expectFound: true,
+		},
+		{
+			name:        "if",
+			template:    "{{ if .To.some.thing }}{{ end }}",
+			expectFound: true,
+		},
+		{
+			name:        "range",
+			template:    "{{- range $key, $val := .To.some.thing }}{{ $key }}{{ $val }}{{- end }}",
+			expectFound: true,
+		},
+	}
+
+	for _, c := range cases {
+		t.Run(c.name, func(t *testing.T) {
+			tpl := param.Parse(tmpl.ParseOrFail(t, c.template))
+			actual := tpl.ContainsWellKnown(param.To)
+
+			g := NewWithT(t)
+			g.Expect(actual).To(Equal(c.expectFound))
+		})
+	}
+}
diff --git a/pkg/test/framework/components/echo/config/param/wellknown.go b/pkg/test/framework/components/echo/config/param/wellknown.go
new file mode 100644
index 0000000000..7af9247fbc
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/param/wellknown.go
@@ -0,0 +1,37 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package param
+
+// WellKnown defines a well-known template parameter injected automatically by the echo testing framework.
+type WellKnown string
+
+const (
+	// From is the template parameter used for injecting the source of a call. It will be of type echo.Caller,
+	// which is generally either of type echo.Instance or istio.Ingress (for ingress-based tests).
+	From WellKnown = "From"
+
+	// To is the template parameter used for injecting the echo.Target of a call.
+	To WellKnown = "To"
+
+	// Namespace is the template parameter used for injecting the target namespace.Instance of the applied config.
+	Namespace WellKnown = "Namespace"
+
+	// SystemNamespace is the template parameter used for injecting the namespace.Instance of the Istio system.
+	SystemNamespace WellKnown = "SystemNamespace"
+)
+
+func (p WellKnown) String() string {
+	return string(p)
+}
diff --git a/pkg/test/framework/components/echo/config/source.go b/pkg/test/framework/components/echo/config/source.go
new file mode 100644
index 0000000000..dbc5d875fa
--- /dev/null
+++ b/pkg/test/framework/components/echo/config/source.go
@@ -0,0 +1,170 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package config
+
+import (
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/framework/components/echo/config/param"
+	"istio.io/istio/pkg/test/util/file"
+	"istio.io/istio/pkg/test/util/tmpl"
+)
+
+// Source of YAML text.
+type Source interface {
+	// Template reads the raw input and creates a Template from this source.
+	Template() (*param.Template, error)
+
+	// TemplateOrFail calls Template and fails if an error occurs.
+	TemplateOrFail(t test.Failer) *param.Template
+
+	// MustTemplate calls Template and panics if an error occurs.
+	MustTemplate() *param.Template
+
+	// YAML reads the yaml from this Source. If this source contains parameters,
+	// it is evaluated as a template.
+	YAML() (string, error)
+
+	// YAMLOrFail calls GetYAML and fails if an error occurs.
+	YAMLOrFail(t test.Failer) string
+
+	// MustYAML calls GetYAML and panics if an error occurs.
+	MustYAML() string
+
+	// Params returns a copy of the parameters for this Source.
+	Params() param.Params
+
+	// WithParams creates a new Source with the given template parameters.
+	// If a Source contains params, it will be evaluated as a template by GetYAML.
+	// If this source already has parameters, the returned Source will contain
+	// a union of the two sets. If the same entry appears in the existing params,
+	// the new value overwrites the existing.
+	WithParams(params param.Params) Source
+}
+
+// YAML returns a Source of raw YAML text.
+func YAML(text string) Source {
+	return sourceImpl{
+		read: func() (string, error) {
+			return text, nil
+		},
+	}
+}
+
+// File returns a Source of YAML text stored in files.
+func File(filePath string) Source {
+	return sourceImpl{
+		read: func() (string, error) {
+			return file.AsString(filePath)
+		},
+	}
+}
+
+type sourceImpl struct {
+	read   func() (string, error)
+	params param.Params
+}
+
+func (s sourceImpl) Template() (*param.Template, error) {
+	raw, err := s.read()
+	if err != nil {
+		return nil, err
+	}
+
+	tpl, err := tmpl.Parse(raw)
+	if err != nil {
+		return nil, err
+	}
+	return param.Parse(tpl), nil
+}
+
+func (s sourceImpl) TemplateOrFail(t test.Failer) *param.Template {
+	t.Helper()
+	tpl, err := s.Template()
+	if err != nil {
+		t.Fatal(err)
+	}
+	return tpl
+}
+
+func (s sourceImpl) MustTemplate() *param.Template {
+	tpl, err := s.Template()
+	if err != nil {
+		panic(err)
+	}
+	return tpl
+}
+
+func (s sourceImpl) YAML() (string, error) {
+	// If params were specified, process the yaml as a template.
+	if s.params != nil {
+		t, err := s.Template()
+		if err != nil {
+			return "", err
+		}
+		return tmpl.Execute(t.Template, s.params)
+	}
+
+	// Otherwise, just read the yaml.
+	return s.read()
+}
+
+func (s sourceImpl) YAMLOrFail(t test.Failer) string {
+	t.Helper()
+	out, err := s.YAML()
+	if err != nil {
+		t.Fatal(err)
+	}
+	return out
+}
+
+func (s sourceImpl) MustYAML() string {
+	out, err := s.YAML()
+	if err != nil {
+		panic(err)
+	}
+	return out
+}
+
+func (s sourceImpl) Params() param.Params {
+	return s.params.Copy()
+}
+
+func (s sourceImpl) WithParams(params param.Params) Source {
+	if len(params) == 0 {
+		return s
+	}
+
+	// Merge the parameters (if needed).
+	mergedParams := params
+	if len(s.params) > 0 {
+		// Make a copy of params.
+		mergedParams = make(map[string]interface{}, len(params)+len(s.params))
+		for k, v := range params {
+			mergedParams[k] = v
+		}
+
+		// Copy non-conflicting values from this Source.
+		for k, v := range s.params {
+			if _, ok := mergedParams[k]; !ok {
+				mergedParams[k] = v
+			}
+		}
+	}
+
+	return sourceImpl{
+		read:   s.read,
+		params: mergedParams,
+	}
+}
diff --git a/pkg/test/framework/components/echo/echotest/config.go b/pkg/test/framework/components/echo/echotest/config.go
new file mode 100644
index 0000000000..5784adcc64
--- /dev/null
+++ b/pkg/test/framework/components/echo/echotest/config.go
@@ -0,0 +1,25 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echotest
+
+import (
+	"istio.io/istio/pkg/test/framework/components/echo/config"
+)
+
+// Config adds a configuration source that will be applied during the run of this tester.
+func (t *T) Config(s config.Source) *T {
+	t.cfg = t.cfg.Source(s)
+	return t
+}
diff --git a/pkg/test/framework/components/echo/echotest/echotest.go b/pkg/test/framework/components/echo/echotest/echotest.go
index fe791fa942..c3f4ded84a 100644
--- a/pkg/test/framework/components/echo/echotest/echotest.go
+++ b/pkg/test/framework/components/echo/echotest/echotest.go
@@ -17,6 +17,7 @@
 import (
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
+	"istio.io/istio/pkg/test/framework/components/echo/config"
 	"istio.io/istio/pkg/test/framework/components/echo/match"
 )
 
@@ -33,6 +34,8 @@ type T struct {
 	sourceDeploymentSetup      []srcSetupFn
 	deploymentPairSetup        []svcPairSetupFn
 	destinationDeploymentSetup []dstSetupFn
+
+	cfg *config.Builder
 }
 
 // New creates a *T using the given applications as sources and destinations for each subtest.
@@ -40,7 +43,12 @@ func New(ctx framework.TestContext, instances echo.Instances) *T {
 	s, d := make(echo.Instances, len(instances)), make(echo.Instances, len(instances))
 	copy(s, instances)
 	copy(d, instances)
-	t := &T{rootCtx: ctx, sources: s, destinations: d}
+	t := &T{
+		rootCtx:      ctx,
+		cfg:          config.New(ctx),
+		sources:      s,
+		destinations: d,
+	}
 	if ctx.Settings().Skip(echo.VM) {
 		t = t.FromMatch(match.NotVM).ToMatch(match.NotVM)
 	}
diff --git a/pkg/test/framework/components/echo/echotest/run.go b/pkg/test/framework/components/echo/echotest/run.go
index b03f4553ba..6b3e0dca78 100644
--- a/pkg/test/framework/components/echo/echotest/run.go
+++ b/pkg/test/framework/components/echo/echotest/run.go
@@ -53,10 +53,25 @@ func (t *T) Run(testFn oneToOneTest) {
 	t.rootCtx.Logf("Running tests with: sources %v -> destinations %v",
 		t.sources.Services().NamespacedNames().NamesWithNamespacePrefix(),
 		t.destinations.Services().NamespacedNames().NamesWithNamespacePrefix())
+
+	// Build and apply any completed configuration that does not require to/from params.
+	t.cfg.BuildCompleteSources().Apply()
+
 	t.fromEachDeployment(t.rootCtx, func(ctx framework.TestContext, from echo.Instances) {
+		// Build and apply per-source configuration.
+		// TODO(nmittler): Consider merging this with t.setup below.
+		callers := from.Callers()
+		firstCaller := echo.Callers{callers[0]}
+		t.cfg.Context(ctx).BuildFrom(firstCaller...).Apply()
+
+		// Run setup functions for the callers.
 		t.setup(ctx, from.Callers())
+
 		t.toEachDeployment(ctx, func(ctx framework.TestContext, to echo.Instances) {
-			t.setupPair(ctx, from.Callers(), echo.Services{to})
+			// Build and apply per-destination config
+			t.cfg.Context(ctx).BuildFromAndTo(firstCaller, to.Services()).Apply()
+
+			t.setupPair(ctx, callers, echo.Services{to})
 			t.fromEachWorkloadCluster(ctx, from, func(ctx framework.TestContext, from echo.Instance) {
 				filteredDst := t.applyCombinationFilters(from, to)
 				if len(filteredDst) == 0 {
@@ -128,11 +143,18 @@ func (t *T) RunToN(n int, testFn oneToNTest) {
 }
 
 func (t *T) RunViaIngress(testFn ingressTest) {
-	i := istio.GetOrFail(t.rootCtx, t.rootCtx)
+	// Build and apply any completed configuration that does not require to/from params.
+	t.cfg.BuildCompleteSources().Apply()
+
+	istioInstance := istio.GetOrFail(t.rootCtx, t.rootCtx)
 	t.toEachDeployment(t.rootCtx, func(ctx framework.TestContext, dstInstances echo.Instances) {
-		t.setupPair(ctx, i.Ingresses().Callers(), echo.Services{dstInstances})
+		// Build and apply per-destination config
+		callers := istioInstance.Ingresses().Callers()
+		t.cfg.Context(ctx).BuildFromAndTo(callers, dstInstances.Services()).Apply()
+
+		t.setupPair(ctx, callers, echo.Services{dstInstances})
 		doTest := func(ctx framework.TestContext, fromCluster cluster.Cluster, dst echo.Instances) {
-			ingr := i.IngressFor(fromCluster)
+			ingr := istioInstance.IngressFor(fromCluster)
 			if ingr == nil {
 				ctx.Skipf("no ingress for %s", fromCluster.StableName())
 			}
-- 
2.35.3

