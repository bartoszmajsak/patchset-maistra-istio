From 155b8a42f4687af1244187b258ea4affc6cd7122 Mon Sep 17 00:00:00 2001
From: Yaroslav Skopets <yaroslav@tetrate.io>
Date: Wed, 23 Feb 2022 01:47:27 +0100
Subject: vm support: don't generate inbound/outbound listeners for privileged
 ports (1-1023) when sidecar is not using Iptables and explicitly indicated
 that it is unprivileged (#37387)

* vm support: don't generate inbound/outbound listeners for privileged ports (1-1023) when sidecar is not using Iptables and explicitly indicated that it is unprivileged

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* add unit tests

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* fix linting

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>
---
 pilot/pkg/model/context.go                    |  27 +++
 .../pkg/networking/core/v1alpha3/listener.go  |  23 ++
 .../networking/core/v1alpha3/listener_test.go | 202 ++++++++++++++++++
 3 files changed, 252 insertions(+)

diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 778e71393b..2a90cb435b 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -1077,6 +1077,33 @@ func (node *Proxy) GetInterceptionMode() TrafficInterceptionMode {
 	return InterceptionRedirect
 }
 
+// IsUnprivileged returns true if the proxy has explicitly indicated that it is
+// unprivileged, i.e. it cannot bind to the privileged ports 1-1023.
+func (node *Proxy) IsUnprivileged() bool {
+	if node == nil || node.Metadata == nil {
+		return false
+	}
+	// expect explicit "true" value
+	unprivileged, _ := strconv.ParseBool(node.Metadata.UnprivilegedPod)
+	return unprivileged
+}
+
+// CanBindToPort returns true if the proxy can bind to a given port.
+func (node *Proxy) CanBindToPort(bindTo bool, port uint32) bool {
+	if bindTo && IsPrivilegedPort(port) && node.IsUnprivileged() {
+		return false
+	}
+	return true
+}
+
+// IsPrivilegedPort returns true if a given port is in the range 1-1023.
+func IsPrivilegedPort(port uint32) bool {
+	// check for 0 is important because:
+	// 1) technically, 0 is not a privileged port; any process can ask to bind to 0
+	// 2) this function will be receiving 0 on input in the case of UDS listeners
+	return 0 < port && port < 1024
+}
+
 func (node *Proxy) IsVM() bool {
 	// TODO use node metadata to indicate that this is a VM intstead of the TestVMLabel
 	return node.Metadata != nil && node.Metadata.Labels[constants.TestVMLabel] != ""
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index 4674faa0e5..0e0e595533 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -327,6 +327,13 @@ func (configgen *ConfigGeneratorImpl) buildSidecarInboundListeners(
 			bindToPort = true
 		}
 
+		// Skip ports we cannot bind to
+		if !node.CanBindToPort(bindToPort, ingressListener.Port.Number) {
+			log.Warnf("buildSidecarInboundListeners: skipping privileged sidecar port %d for node %s as it is an unprivileged proxy",
+				ingressListener.Port.Number, node.ID)
+			continue
+		}
+
 		listenPort := &model.Port{
 			Port:     int(ingressListener.Port.Number),
 			Protocol: protocol.Parse(ingressListener.Port.Protocol),
@@ -602,6 +609,13 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 			// multiple ports, we expect the user to provide a virtualService
 			// that will route to a proper Service.
 
+			// Skip ports we cannot bind to
+			if !node.CanBindToPort(bindToPort, egressListener.IstioListener.Port.Number) {
+				log.Warnf("buildSidecarOutboundListeners: skipping privileged sidecar port %d for node %s as it is an unprivileged proxy",
+					egressListener.IstioListener.Port.Number, node.ID)
+				continue
+			}
+
 			listenPort := &model.Port{
 				Port:     int(egressListener.IstioListener.Port.Number),
 				Protocol: protocol.Parse(egressListener.IstioListener.Port.Protocol),
@@ -689,6 +703,15 @@ func (configgen *ConfigGeneratorImpl) buildSidecarOutboundListeners(node *model.
 			for _, service := range services {
 				saddress := service.GetAddressForProxy(node)
 				for _, servicePort := range service.Ports {
+					// Skip ports we cannot bind to
+					if !node.CanBindToPort(bindToPort, uint32(servicePort.Port)) {
+						// here, we log at DEBUG level instead of WARN to avoid noise
+						// when the catch all egress listener hits ports 80 and 443
+						log.Debugf("buildSidecarOutboundListeners: skipping privileged sidecar port %d for node %s as it is an unprivileged proxy",
+							servicePort.Port, node.ID)
+						continue
+					}
+
 					// bind might have been modified by below code, so reset it for every Service.
 					listenerOpts.bind = bind
 					// port depends on servicePort.
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 5b5f05bb50..8cae98b449 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -17,6 +17,7 @@
 import (
 	"fmt"
 	"reflect"
+	"strconv"
 	"strings"
 	"testing"
 	"time"
@@ -830,6 +831,207 @@ func TestFilterChainMatchFields(t *testing.T) {
 	}
 }
 
+func TestInboundListener_PrivilegedPorts(t *testing.T) {
+	// Verify that an explicit ingress listener will not bind to privileged ports
+	// if proxy is not using Iptables and cannot bind to privileged ports (1-1023).
+	//
+	// Even if a user explicitly created a Sidecar config with an ingress listener for a privileged port,
+	// it is still not worth it creating such a listener if we already known that a proxy will end up
+	// rejecting it.
+	testPrivilegedPorts(t, func(t *testing.T, proxy *model.Proxy, port uint32) []*listener.Listener {
+		p := &fakePlugin{}
+
+		// simulate user-defined Sidecar config with an ingress listener for a given port
+		sidecarConfig := &config.Config{
+			Meta: config.Meta{
+				Name:             "sidecar-with-ingress-listener",
+				Namespace:        proxy.ConfigNamespace,
+				GroupVersionKind: gvk.Sidecar,
+			},
+			Spec: &networking.Sidecar{
+				Ingress: []*networking.IstioIngressListener{
+					{
+						Port: &networking.Port{
+							Number:   port,
+							Protocol: "HTTP",
+							Name:     strconv.Itoa(int(port)),
+						},
+						DefaultEndpoint: "127.0.0.1:8080",
+					},
+				},
+			},
+		}
+
+		return buildInboundListeners(t, p, proxy, sidecarConfig)
+	})
+}
+
+func TestOutboundListener_PrivilegedPorts(t *testing.T) {
+	// Verify that an implicit catch all egress listener will not bind to privileged ports
+	// if proxy is not using Iptables and cannot bind to privileged ports (1-1023).
+	//
+	// It is very common for the catch all egress listener to match services on ports 80 and 443.
+	// Therefore, the default behavior should not force users to start from looking for a workaround.
+	t.Run("implicit catch all egress listener", func(t *testing.T) {
+		testPrivilegedPorts(t, func(t *testing.T, proxy *model.Proxy, port uint32) []*listener.Listener {
+			p := &fakePlugin{}
+
+			// simulate a service on a given port
+			services := []*model.Service{buildServiceWithPort("httpbin.com", int(port), protocol.HTTP, tnow.Add(1*time.Second))}
+
+			return buildOutboundListeners(t, p, proxy, nil, nil, services...)
+		})
+	})
+
+	// Verify that an explicit per-port egress listener will not bind to privileged ports
+	// if proxy is not using Iptables and cannot bind to privileged ports (1-1023).
+	//
+	// Even if a user explicitly created a Sidecar config with an egress listener for a privileged port,
+	// it is still not worth it creating such a listener if we already known that a proxy will end up
+	// rejecting it.
+	t.Run("explicit per-port egress listener", func(t *testing.T) {
+		testPrivilegedPorts(t, func(t *testing.T, proxy *model.Proxy, port uint32) []*listener.Listener {
+			p := &fakePlugin{}
+
+			// simulate a service on a given port
+			services := []*model.Service{buildServiceWithPort("httpbin.com", int(port), protocol.HTTP, tnow.Add(1*time.Second))}
+
+			// simulate user-defined Sidecar config with an egress listener for a given port
+			sidecarConfig := &config.Config{
+				Meta: config.Meta{
+					Name:             "sidecar-with-per-port-egress-listener",
+					Namespace:        proxy.ConfigNamespace,
+					GroupVersionKind: gvk.Sidecar,
+				},
+				Spec: &networking.Sidecar{
+					Egress: []*networking.IstioEgressListener{
+						{
+							Hosts: []string{"default/*"},
+							Port: &networking.Port{
+								Number:   port,
+								Protocol: "HTTP",
+								Name:     strconv.Itoa(int(port)),
+							},
+						},
+					},
+				},
+			}
+
+			return buildOutboundListeners(t, p, proxy, sidecarConfig, nil, services...)
+		})
+	})
+}
+
+func testPrivilegedPorts(t *testing.T, buildListeners func(t *testing.T, proxy *model.Proxy, port uint32) []*listener.Listener) {
+	privilegedPorts := []uint32{1, 80, 443, 1023}
+	unprivilegedPorts := []uint32{1024, 8080, 8443, 15443}
+	anyPorts := append(privilegedPorts, unprivilegedPorts...)
+
+	// multiple test cases to ensure that privileged ports get treated differently
+	// only under certain conditions, namely
+	// 1) proxy explicitly indicated it is not using Iptables
+	// 2) proxy explicitly indicated it is not a privileged process (cannot bind to  1-1023)
+	cases := []struct {
+		name           string
+		unprivileged   bool // whether proxy is unprivileged
+		mode           model.TrafficInterceptionMode
+		ports          []uint32
+		expectListener bool // expect listener to be generated
+	}{
+		{
+			name:           "privileged proxy; implicit REDIRECT mode; any ports",
+			unprivileged:   false,
+			mode:           "",
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "privileged proxy; explicit REDIRECT mode; any ports",
+			unprivileged:   false,
+			mode:           model.InterceptionRedirect,
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "privileged proxy; explicit TPROXY mode; any ports",
+			unprivileged:   false,
+			mode:           model.InterceptionTproxy,
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "privileged proxy; explicit NONE mode; any ports",
+			unprivileged:   false,
+			mode:           model.InterceptionNone,
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "unprivileged proxy; implicit REDIRECT mode; any ports",
+			unprivileged:   true,
+			mode:           "",
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "unprivileged proxy; explicit REDIRECT mode; any ports",
+			unprivileged:   true,
+			mode:           model.InterceptionRedirect,
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "unprivileged proxy; explicit TPROXY mode; any ports",
+			unprivileged:   true,
+			mode:           model.InterceptionTproxy,
+			ports:          anyPorts,
+			expectListener: true,
+		},
+		{
+			name:           "unprivileged proxy; explicit NONE mode; privileged ports",
+			unprivileged:   true,
+			mode:           model.InterceptionNone,
+			ports:          privilegedPorts,
+			expectListener: false,
+		},
+		{
+			name:           "unprivileged proxy; explicit NONE mode; unprivileged ports",
+			unprivileged:   true,
+			mode:           model.InterceptionNone,
+			ports:          unprivilegedPorts,
+			expectListener: true,
+		},
+	}
+
+	for _, tc := range cases {
+		t.Run(tc.name, func(t *testing.T) {
+			for _, port := range tc.ports {
+				t.Run(strconv.Itoa(int(port)), func(t *testing.T) {
+					proxy := getProxy()
+					proxy.Metadata.UnprivilegedPod = strconv.FormatBool(tc.unprivileged)
+					proxy.Metadata.InterceptionMode = tc.mode
+
+					listeners := buildListeners(t, proxy, port)
+
+					if tc.expectListener {
+						if expected := 1; len(listeners) != expected {
+							t.Fatalf("expected %d listeners, found %d", expected, len(listeners))
+						}
+						l := findListenerByPort(listeners, port)
+						if l == nil {
+							t.Fatalf("expected listener on port %d, but not found", port)
+						}
+					} else {
+						if expected := 0; len(listeners) != expected {
+							t.Fatalf("expected %d listeners, found %d", expected, len(listeners))
+						}
+					}
+				})
+			}
+		})
+	}
+}
+
 func testOutboundListenerConflictWithSniffingDisabled(t *testing.T, services ...*model.Service) {
 	t.Helper()
 
-- 
2.35.3

