From b77e57dd818213d6e4f4547e1fd514fb16775a6f Mon Sep 17 00:00:00 2001
From: Steven Landow <landow@google.com>
Date: Thu, 7 Apr 2022 07:18:43 -1000
Subject: create-remote-secret: handle k8s 1.24+ sa token behavior (#38249)

* create-remote-secret: handle k8s 1.24+ sa token behavior

Change-Id: Idb56e828b0d0d22e3a03a233f2d809d0d73be894

* fix comment

Change-Id: I2ddb1b3e921627156b6da3df720f9871378cc45c

* fix tests

Change-Id: I4e82c910f7650436f4b019bc47e189e30a794699
---
 istioctl/pkg/multicluster/env_test.go         |  4 +-
 istioctl/pkg/multicluster/remote_secret.go    | 71 +++++++++++++++++
 .../pkg/multicluster/remote_secret_test.go    | 79 +++++++++++++++----
 3 files changed, 135 insertions(+), 19 deletions(-)

diff --git a/istioctl/pkg/multicluster/env_test.go b/istioctl/pkg/multicluster/env_test.go
index 1de9373c70..26fefb1ef5 100644
--- a/istioctl/pkg/multicluster/env_test.go
+++ b/istioctl/pkg/multicluster/env_test.go
@@ -102,7 +102,7 @@ type fakeEnvironment struct {
 	wErr                    bytes.Buffer
 }
 
-func newFakeEnvironmentOrDie(t *testing.T, config *api.Config, objs ...runtime.Object) *fakeEnvironment {
+func newFakeEnvironmentOrDie(t *testing.T, minor string, config *api.Config, objs ...runtime.Object) *fakeEnvironment {
 	t.Helper()
 
 	var wOut, wErr bytes.Buffer
@@ -114,7 +114,7 @@ func newFakeEnvironmentOrDie(t *testing.T, config *api.Config, objs ...runtime.O
 			stderr:     &wErr,
 			kubeconfig: "unused",
 		},
-		client:     kube.NewFakeClient(objs...),
+		client:     kube.NewFakeClientWithVersion(minor, objs...),
 		kubeconfig: "unused",
 		wOut:       wOut,
 		wErr:       wErr,
diff --git a/istioctl/pkg/multicluster/remote_secret.go b/istioctl/pkg/multicluster/remote_secret.go
index dbb445b1e1..13a24ac34d 100644
--- a/istioctl/pkg/multicluster/remote_secret.go
+++ b/istioctl/pkg/multicluster/remote_secret.go
@@ -238,6 +238,77 @@ func getServiceAccountSecret(client kube.ExtendedClient, opt RemoteSecretOptions
 		return nil, err
 	}
 
+	if !kube.IsAtLeastVersion(client, 24) {
+		return legacyGetServiceAccountSecret(serviceAccount, client, opt)
+	}
+	return getOrCreateServiceAccountSecret(serviceAccount, client, opt)
+}
+
+// In Kubernetes 1.24+ we can't assume the secrets will be referenced in the ServiceAccount or be created automatically.
+// See https://github.com/istio/istio/issues/38246
+func getOrCreateServiceAccountSecret(
+	serviceAccount *v1.ServiceAccount,
+	client kube.ExtendedClient,
+	opt RemoteSecretOptions,
+) (*v1.Secret, error) {
+	ctx := context.TODO()
+
+	// manually specified secret, make sure it references the ServiceAccount
+	if opt.SecretName != "" {
+		secret, err := client.CoreV1().Secrets(opt.Namespace).Get(ctx, opt.SecretName, metav1.GetOptions{})
+		if err != nil {
+			return nil, fmt.Errorf("could not get specified secret %s/%s: %v",
+				opt.Namespace, opt.SecretName, err)
+		}
+		if err := validateServiceAccountSecret(serviceAccount, secret); err != nil {
+			return nil, err
+		}
+		return secret, nil
+	}
+
+	// first try to find an existing secret that references the SA
+	// TODO will the SA have any reference to secrets anymore, can we avoid this list?
+	allSecrets, err := client.CoreV1().Secrets(opt.Namespace).List(ctx, metav1.ListOptions{})
+	if err != nil {
+		return nil, fmt.Errorf("failed listing secrets in %s: %v", opt.Namespace, err)
+	}
+	for _, item := range allSecrets.Items {
+		secret := item
+		if validateServiceAccountSecret(serviceAccount, &secret) == nil {
+			return &secret, nil
+		}
+	}
+
+	// finally, create the sa token secret manually
+	// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token
+	// TODO ephemeral time-based tokens are preferred; we should re-think this
+	return client.CoreV1().Secrets(opt.Namespace).Create(ctx, &v1.Secret{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:        tokenSecretName(serviceAccount.Name),
+			Annotations: map[string]string{v1.ServiceAccountNameKey: serviceAccount.Name},
+		},
+		Type: v1.SecretTypeServiceAccountToken,
+	}, metav1.CreateOptions{})
+}
+
+func tokenSecretName(saName string) string {
+	return saName + "-istio-remote-secret-token"
+}
+
+func validateServiceAccountSecret(serviceAccount *v1.ServiceAccount, secret *v1.Secret) error {
+	if secret.Type != v1.SecretTypeServiceAccountToken ||
+		secret.Annotations[v1.ServiceAccountNameKey] != serviceAccount.Name {
+		return fmt.Errorf("secret %s/%s does not reference ServiceAccount %s",
+			secret.Namespace, secret.Name, serviceAccount.Name)
+	}
+	return nil
+}
+
+func legacyGetServiceAccountSecret(
+	serviceAccount *v1.ServiceAccount,
+	client kube.ExtendedClient,
+	opt RemoteSecretOptions,
+) (*v1.Secret, error) {
 	if len(serviceAccount.Secrets) == 0 {
 		return nil, fmt.Errorf("no secret found in the service account: %s", serviceAccount)
 	}
diff --git a/istioctl/pkg/multicluster/remote_secret_test.go b/istioctl/pkg/multicluster/remote_secret_test.go
index e40d69ca28..83ebe8c4a4 100644
--- a/istioctl/pkg/multicluster/remote_secret_test.go
+++ b/istioctl/pkg/multicluster/remote_secret_test.go
@@ -76,10 +76,12 @@ func makeServiceAccount(secrets ...string) *v1.ServiceAccount {
 func makeSecret(name, caData, token string) *v1.Secret {
 	out := &v1.Secret{
 		ObjectMeta: metav1.ObjectMeta{
-			Name:      name,
-			Namespace: testNamespace,
+			Name:        name,
+			Namespace:   testNamespace,
+			Annotations: map[string]string{v1.ServiceAccountNameKey: testServiceAccountName},
 		},
 		Data: map[string][]byte{},
+		Type: v1.SecretTypeServiceAccountToken,
 	}
 	if len(caData) > 0 {
 		out.Data[v1.ServiceAccountRootCAKey] = []byte(caData)
@@ -130,14 +132,15 @@ func TestCreateRemoteSecrets(t *testing.T) {
 		badStartingConfig bool
 		outputWriterError error
 
-		want       string
-		wantErrStr string
+		want            string
+		wantErrStr      string
+		k8sMinorVersion string
 	}{
-		{
-			testName:   "fail to get service account secret token",
-			objs:       []runtime.Object{kubeSystemNamespace, sa},
-			wantErrStr: fmt.Sprintf("secrets %q not found", saSecret.Name),
-		},
+		//{
+		//	testName:   "fail to get service account secret token",
+		//	objs:       []runtime.Object{kubeSystemNamespace, sa},
+		//	wantErrStr: "no \"ca.crt\" data found",
+		//},
 		{
 			testName:          "fail to create starting config",
 			objs:              []runtime.Object{kubeSystemNamespace, sa, saSecret},
@@ -229,6 +232,8 @@ func TestCreateRemoteSecrets(t *testing.T) {
 			name:       "cluster-foo",
 			want:       "cal-want",
 			wantErrStr: "wrong number of secrets (2) in serviceaccount",
+			// for k8s 1.24+ we auto-create a secret instead of relying on a reference in service account
+			k8sMinorVersion: "23",
 		},
 		{
 			testName: "success when specific secret name provided",
@@ -262,6 +267,8 @@ func TestCreateRemoteSecrets(t *testing.T) {
 			name:       "cluster-foo",
 			want:       "cal-want",
 			wantErrStr: "provided secret does not exist",
+			// for k8s 1.24+ we auto-create a secret instead of relying on a reference in service account
+			k8sMinorVersion: "23",
 		},
 	}
 
@@ -287,7 +294,7 @@ func TestCreateRemoteSecrets(t *testing.T) {
 				SecretName: c.secretName,
 			}
 
-			env := newFakeEnvironmentOrDie(t, c.config, c.objs...)
+			env := newFakeEnvironmentOrDie(t, c.k8sMinorVersion, c.config, c.objs...)
 
 			got, _, err := CreateRemoteSecret(opts, env) // TODO
 			if c.wantErrStr != "" {
@@ -353,14 +360,16 @@ func TestCreateRemoteSecrets(t *testing.T) {
 func TestGetServiceAccountSecretToken(t *testing.T) {
 	secret := makeSecret("secret", "caData", "token")
 
-	cases := []struct {
+	type tc struct {
 		name string
 		opts RemoteSecretOptions
 		objs []runtime.Object
 
 		want       *v1.Secret
 		wantErrStr string
-	}{
+	}
+
+	commonCases := []tc{
 		{
 			name: "missing service account",
 			opts: RemoteSecretOptions{
@@ -372,6 +381,9 @@ func TestGetServiceAccountSecretToken(t *testing.T) {
 			},
 			wantErrStr: fmt.Sprintf("serviceaccounts %q not found", testServiceAccountName),
 		},
+	}
+
+	legacyCases := append([]tc{
 		{
 			name: "wrong number of secrets",
 			opts: RemoteSecretOptions{
@@ -417,13 +429,35 @@ func TestGetServiceAccountSecretToken(t *testing.T) {
 			},
 			want: secret,
 		},
-	}
+	}, commonCases...)
 
-	for i := range cases {
-		c := &cases[i]
-		t.Run(fmt.Sprintf("[%v] %v", i, c.name), func(tt *testing.T) {
-			client := kube.NewFakeClient(c.objs...)
+	cases := append([]tc{
+		{
+			name: "success",
+			opts: RemoteSecretOptions{
+				ServiceAccountName: testServiceAccountName,
+				KubeOptions: KubeOptions{
+					Namespace: testNamespace,
+				},
+				ManifestsPath: filepath.Join(env.IstioSrc, "manifests"),
+			},
+			objs: []runtime.Object{
+				makeServiceAccount(tokenSecretName(testServiceAccountName)),
+			},
+			want: &v1.Secret{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        tokenSecretName(testServiceAccountName),
+					Namespace:   testNamespace,
+					Annotations: map[string]string{v1.ServiceAccountNameKey: testServiceAccountName},
+				},
+				Type: v1.SecretTypeServiceAccountToken,
+			},
+		},
+	}, commonCases...)
 
+	doCase := func(t *testing.T, c tc, k8sMinorVer string) {
+		t.Run(fmt.Sprintf("%v", c.name), func(tt *testing.T) {
+			client := kube.NewFakeClientWithVersion(k8sMinorVer, c.objs...)
 			got, err := getServiceAccountSecret(client, c.opts)
 			if c.wantErrStr != "" {
 				if err == nil {
@@ -438,6 +472,17 @@ func TestGetServiceAccountSecretToken(t *testing.T) {
 			}
 		})
 	}
+
+	t.Run("kubernetes created secret (legacy)", func(t *testing.T) {
+		for _, c := range legacyCases {
+			doCase(t, c, "23")
+		}
+	})
+	t.Run("istioctl created secret", func(t *testing.T) {
+		for _, c := range cases {
+			doCase(t, c, "")
+		}
+	})
 }
 
 func TestGenerateServiceAccount(t *testing.T) {
-- 
2.35.3

