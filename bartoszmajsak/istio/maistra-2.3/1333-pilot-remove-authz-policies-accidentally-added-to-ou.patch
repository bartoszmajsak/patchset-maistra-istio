From 6678c677ba040e6c47eb46a64b4dd5266647baec Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Thu, 26 May 2022 18:41:50 -0700
Subject: pilot: remove authz policies accidentally added to outbound paths
 (#39154)

Fixes https://github.com/istio/istio/issues/39148
Fixes https://github.com/istio/istio/issues/39000
---
 .../pkg/networking/core/v1alpha3/listener.go  | 13 ------
 .../networking/core/v1alpha3/listener_test.go |  9 ++++
 .../core/v1alpha3/listenertest/match.go       | 41 +++++++++----------
 3 files changed, 28 insertions(+), 35 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index 035175595f..4862004d19 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -565,12 +565,6 @@ func (lb *ListenerBuilder) buildHTTPProxy(node *model.Proxy,
 			FilterChains: []istionetworking.FilterChain{{}},
 		},
 	}
-	for cnum := range mutable.FilterChains {
-		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
-		}
-	}
 	if err := mutable.build(lb, opts); err != nil {
 		log.Warn("buildHTTPProxy filter chain error  ", err.Error())
 		return nil
@@ -942,13 +936,6 @@ func (lb *ListenerBuilder) buildSidecarOutboundListenerForPortOrUDS(listenerOpts
 		},
 	}
 
-	for cnum := range mutable.FilterChains {
-		if mutable.FilterChains[cnum].ListenerProtocol == istionetworking.ListenerProtocolTCP {
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzCustomBuilder.BuildTCP()...)
-			mutable.FilterChains[cnum].TCP = append(mutable.FilterChains[cnum].TCP, lb.authzBuilder.BuildTCP()...)
-		}
-	}
-
 	// Filters are serialized one time into an opaque struct once we have the complete list.
 	if err := mutable.build(lb, listenerOpts); err != nil {
 		log.Warn("buildSidecarOutboundListeners: ", err.Error())
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 396ec93b77..14e05e8f71 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -376,6 +376,15 @@ func TestOutboundListenerTCPWithVS(t *testing.T) {
 			if listeners[0].ConnectionBalanceConfig != nil {
 				t.Fatalf("expected connection balance config to be set to empty, found %v", listeners[0].ConnectionBalanceConfig)
 			}
+
+			for _, l := range listeners {
+				for _, fc := range l.GetFilterChains() {
+					listenertest.VerifyFilterChain(t, fc, listenertest.FilterChainTest{
+						NetworkFilters: []string{wellknown.TCPProxy},
+						TotalMatch:     true,
+					})
+				}
+			}
 		})
 	}
 }
diff --git a/pilot/pkg/networking/core/v1alpha3/listenertest/match.go b/pilot/pkg/networking/core/v1alpha3/listenertest/match.go
index 0bee0ea8fd..fe5364a267 100644
--- a/pilot/pkg/networking/core/v1alpha3/listenertest/match.go
+++ b/pilot/pkg/networking/core/v1alpha3/listenertest/match.go
@@ -126,10 +126,10 @@ func VerifyListener(t test.Failer, l *listener.Listener, lt ListenerTest) {
 	if lt.Filters != nil {
 		if lt.TotalMatch {
 			assert.Equal(t, lt.Filters, haveFilters, l.Name+": listener filters should be equal")
-		}
-	} else {
-		if missing := sets.New(lt.Filters...).Difference(sets.New(haveFilters...)).SortedList(); len(missing) > 0 {
-			t.Fatalf("%v: missing listener filters: %v", l.Name, missing)
+		} else {
+			if missing := sets.New(lt.Filters...).Difference(sets.New(haveFilters...)).SortedList(); len(missing) > 0 {
+				t.Fatalf("%v: missing listener filters: %v", l.Name, missing)
+			}
 		}
 	}
 
@@ -147,21 +147,9 @@ func VerifyListener(t test.Failer, l *listener.Listener, lt ListenerTest) {
 			// Now check they are equivalent
 			for i := range lt.FilterChains {
 				have := l.FilterChains[i]
-				haveType := classifyFilterChain(have)
 				want := lt.FilterChains[i]
-				context := func(s string) string {
-					return fmt.Sprintf("%v/%v: %v", have.Name, haveType, s)
-				}
-				if want.Name != "" {
-					assert.Equal(t, want.Name, have.Name, context("name should be equal"))
-				}
-				if want.Type != "" {
-					assert.Equal(t, want.Type, haveType, context("type should be equal"))
-				}
-				if want.Port != 0 {
-					assert.Equal(t, want.Port, have.GetFilterChainMatch().GetDestinationPort().GetValue(), context("port should be equal"))
-				}
-				assertFilterChain(t, have, want)
+
+				VerifyFilterChain(t, have, want)
 			}
 		} else {
 			for _, want := range lt.FilterChains {
@@ -178,7 +166,7 @@ func VerifyListener(t test.Failer, l *listener.Listener, lt ListenerTest) {
 						continue
 					}
 					found++
-					assertFilterChain(t, have, want)
+					VerifyFilterChain(t, have, want)
 				}
 				if found == 0 {
 					t.Fatalf("No matching chain found for %+v", want)
@@ -191,12 +179,21 @@ func VerifyListener(t test.Failer, l *listener.Listener, lt ListenerTest) {
 	}
 }
 
-func assertFilterChain(t test.Failer, have *listener.FilterChain, want FilterChainTest) {
+func VerifyFilterChain(t test.Failer, have *listener.FilterChain, want FilterChainTest) {
 	t.Helper()
 	haveType := classifyFilterChain(have)
 	context := func(s string) string {
 		return fmt.Sprintf("%v/%v: %v", have.Name, haveType, s)
 	}
+	if want.Name != "" {
+		assert.Equal(t, want.Name, have.Name, context("name should be equal"))
+	}
+	if want.Type != "" {
+		assert.Equal(t, want.Type, haveType, context("type should be equal"))
+	}
+	if want.Port != 0 {
+		assert.Equal(t, want.Port, have.GetFilterChainMatch().GetDestinationPort().GetValue(), context("port should be equal"))
+	}
 	haveNetwork, haveHTTP := xdstest.ExtractFilterNames(t, have)
 	if want.TotalMatch {
 		if want.NetworkFilters != nil {
@@ -207,10 +204,10 @@ func assertFilterChain(t test.Failer, have *listener.FilterChain, want FilterCha
 		}
 	} else {
 		if missing := sets.New(want.NetworkFilters...).Difference(sets.New(haveNetwork...)).SortedList(); len(missing) > 0 {
-			t.Fatalf("%v/%v: missing network filters: %v", have.Name, haveType, missing)
+			t.Fatalf("%v/%v: missing network filters: %v, have %v", have.Name, haveType, missing, haveNetwork)
 		}
 		if missing := sets.New(want.HTTPFilters...).Difference(sets.New(haveHTTP...)).SortedList(); len(missing) > 0 {
-			t.Fatalf("%v/%v: missing network filters: %v", have.Name, haveType, missing)
+			t.Fatalf("%v/%v: missing network filters: %v, have %v", have.Name, haveType, missing, haveHTTP)
 		}
 	}
 	if want.ValidateHCM != nil {
-- 
2.35.3

