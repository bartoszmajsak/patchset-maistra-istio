From 199b33bf6d0515c995cde922973a2ec2a4dd4c20 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Mon, 14 Feb 2022 14:20:09 -0800
Subject: [TF] Create common WaitForConfig implementation (#37328)

Security tests have a custom implementation to deal with issues related to WaitForConfig. Moving to a common implementation.
---
 .../framework/components/istioctl/istioctl.go |  4 +-
 .../framework/components/istioctl/kube.go     |  2 +-
 pkg/test/framework/config.go                  | 37 +++++++++++++++++++
 pkg/test/framework/resource/context.go        |  6 +++
 .../security/authorization_test.go            | 16 ++++----
 .../mtls_strict_test.go                       |  5 +--
 .../security/https_jwt/https_jwt_test.go      |  2 +-
 tests/integration/security/jwt_test.go        |  6 +--
 tests/integration/security/util/framework.go  | 19 ----------
 .../security/util/reachability/context.go     |  2 +-
 .../api/stackdriver_filter_test.go            |  4 +-
 .../telemetry/stackdriver/common.go           |  6 +--
 .../stackdriver_filter_audit_test.go          |  6 +--
 .../stackdriver_filter_dry_run_test.go        | 25 ++++++-------
 .../stackdriver/stackdriver_filter_test.go    |  4 +-
 .../stackdriver_tcp_filter_test.go            |  2 +-
 .../customize_metrics_test.go                 | 12 ++----
 17 files changed, 86 insertions(+), 72 deletions(-)

diff --git a/pkg/test/framework/components/istioctl/istioctl.go b/pkg/test/framework/components/istioctl/istioctl.go
index 257f68447e..1fcbc3b2b0 100644
--- a/pkg/test/framework/components/istioctl/istioctl.go
+++ b/pkg/test/framework/components/istioctl/istioctl.go
@@ -24,8 +24,8 @@
 
 // Instance represents "istioctl"
 type Instance interface {
-	// WaitForConfigs will wait until all passed in config has been distributed
-	WaitForConfigs(defaultNamespace string, configs string) error
+	// WaitForConfig will wait until all passed in config has been distributed
+	WaitForConfig(defaultNamespace string, configs string) error
 
 	// Invoke invokes an istioctl command and returns the output and exception.
 	// stdout and stderr will be returned as different strings
diff --git a/pkg/test/framework/components/istioctl/kube.go b/pkg/test/framework/components/istioctl/kube.go
index ea39505cf1..4094115ef2 100644
--- a/pkg/test/framework/components/istioctl/kube.go
+++ b/pkg/test/framework/components/istioctl/kube.go
@@ -51,7 +51,7 @@ func newKube(ctx resource.Context, config Config) (Instance, error) {
 }
 
 // Invoke implements WaitForConfigs
-func (c *kubeComponent) WaitForConfigs(defaultNamespace string, configs string) error {
+func (c *kubeComponent) WaitForConfig(defaultNamespace string, configs string) error {
 	cfgs, _, err := crd.ParseInputs(configs)
 	if err != nil {
 		return fmt.Errorf("failed to parse input: %v", err)
diff --git a/pkg/test/framework/config.go b/pkg/test/framework/config.go
index 14fa8a8c78..57f26b8eca 100644
--- a/pkg/test/framework/config.go
+++ b/pkg/test/framework/config.go
@@ -18,8 +18,11 @@
 	"fmt"
 	"strings"
 
+	"github.com/hashicorp/go-multierror"
+
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/cluster"
+	"istio.io/istio/pkg/test/framework/components/istioctl"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/scopes"
 )
@@ -112,6 +115,40 @@ func (c *configManager) DeleteYAMLOrFail(t test.Failer, ns string, yamlText ...s
 	}
 }
 
+func (c *configManager) WaitForConfig(ctx resource.Context, ns string, yamlText ...string) error {
+	var outErr error
+	for _, c := range c.ctx.Clusters() {
+		ik, err := istioctl.New(ctx, istioctl.Config{Cluster: c})
+		if err != nil {
+			return err
+		}
+
+		for _, config := range yamlText {
+			config := config
+
+			// TODO(https://github.com/istio/istio/issues/37324): It's currently unsafe
+			// to call istioctl concurrently since it relies on the istioctl library
+			// (rather than calling the binary from the command line) which uses a number
+			// of global variables, which will be overwritten for each call.
+			if err := ik.WaitForConfig(ns, config); err != nil {
+				// Get proxy status for additional debugging
+				s, _, _ := ik.Invoke([]string{"ps"})
+				outErr = multierror.Append(err, fmt.Errorf("failed waiting for config for cluster %s: err=%v. Proxy status: %v",
+					c.StableName(), err, s))
+			}
+		}
+	}
+	return outErr
+}
+
+func (c *configManager) WaitForConfigOrFail(ctx resource.Context, t test.Failer, ns string, yamlText ...string) {
+	err := c.WaitForConfig(ctx, ns, yamlText...)
+	if err != nil {
+		// TODO(https://github.com/istio/istio/issues/37148) fail hard in this case
+		t.Log(err)
+	}
+}
+
 func (c *configManager) WithFilePrefix(prefix string) resource.ConfigManager {
 	return &configManager{
 		ctx:      c.ctx,
diff --git a/pkg/test/framework/resource/context.go b/pkg/test/framework/resource/context.go
index 586f720f1c..b075d1d393 100644
--- a/pkg/test/framework/resource/context.go
+++ b/pkg/test/framework/resource/context.go
@@ -38,6 +38,12 @@ type ConfigManager interface {
 	// DeleteYAMLOrFail deletes the given config yaml text.
 	DeleteYAMLOrFail(t test.Failer, ns string, yamlText ...string)
 
+	// WaitForConfig waits for the given config yaml to be applied.
+	WaitForConfig(ctx Context, ns string, yamlText ...string) error
+
+	// WaitForConfigOrFail calls WaitForConfig and fails if an error is encountered.
+	WaitForConfigOrFail(ctx Context, t test.Failer, ns string, yamlText ...string)
+
 	// WithFilePrefix sets the prefix used for intermediate files.
 	WithFilePrefix(prefix string) ConfigManager
 }
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 6da2830cb0..5ee809a72e 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -65,7 +65,7 @@ func TestAuthorization_mTLS(t *testing.T) {
 				policies := tmpl.EvaluateAllOrFail(t, args,
 					file.AsStringOrFail(t, "testdata/authz/v1beta1-mtls.yaml.tmpl"))
 				t.ConfigIstio().ApplyYAMLOrFail(t, apps.Namespace1.Name(), policies...)
-				util.WaitForConfig(t, apps.Namespace1, policies...)
+				t.ConfigIstio().WaitForConfigOrFail(t, t, apps.Namespace1.Name(), policies...)
 				for _, cluster := range t.Clusters() {
 					t.NewSubTest(fmt.Sprintf("From %s", cluster.StableName())).Run(func(t framework.TestContext) {
 						a := apps.A.Match(echo.InCluster(cluster).And(echo.Namespace(apps.Namespace1.Name())))
@@ -125,7 +125,7 @@ func TestAuthorization_JWT(t *testing.T) {
 				policies := tmpl.EvaluateAllOrFail(t, args,
 					file.AsStringOrFail(t, "testdata/authz/v1beta1-jwt.yaml.tmpl"))
 				t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-				util.WaitForConfig(t, ns, policies...)
+				t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
 				for _, srcCluster := range t.Clusters() {
 					t.NewSubTest(fmt.Sprintf("From %s", srcCluster.StableName())).Run(func(t framework.TestContext) {
 						a := apps.A.Match(echo.InCluster(srcCluster).And(echo.Namespace(ns.Name())))
@@ -304,7 +304,7 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 							applyPolicy := func(filename string, ns namespace.Instance) {
 								policy := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, filename))
 								t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-								util.WaitForConfig(t, ns, policy...)
+								t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
 							}
 							applyPolicy("testdata/authz/v1beta1-workload-ns1.yaml.tmpl", ns1)
 							applyPolicy("testdata/authz/v1beta1-workload-ns2.yaml.tmpl", ns2)
@@ -341,7 +341,7 @@ func TestAuthorization_Deny(t *testing.T) {
 			applyPolicy := func(filename string, ns namespace.Instance) {
 				policy := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, filename))
 				t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-				util.WaitForConfig(t, ns, policy...)
+				t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
 			}
 			applyPolicy("testdata/authz/v1beta1-deny.yaml.tmpl", ns)
 			applyPolicy("testdata/authz/v1beta1-deny-ns-root.yaml.tmpl", rootns)
@@ -1135,7 +1135,7 @@ func TestAuthorization_GRPC(t *testing.T) {
 							policies := tmpl.EvaluateAllOrFail(t, args,
 								file.AsStringOrFail(t, "testdata/authz/v1beta1-grpc.yaml.tmpl"))
 							t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-							util.WaitForConfig(t, ns, policies...)
+							t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
 							cases := []rbacUtil.TestCase{
 								{
 									Request: connection.Checker{
@@ -1200,7 +1200,7 @@ func TestAuthorization_Path(t *testing.T) {
 						policies := tmpl.EvaluateAllOrFail(t, args,
 							file.AsStringOrFail(t, "testdata/authz/v1beta1-path.yaml.tmpl"))
 						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-						util.WaitForConfig(t, ns, policies...)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
 
 						callCount := 1
 						if t.Clusters().IsMulticluster() {
@@ -1295,7 +1295,7 @@ func TestAuthorization_Audit(t *testing.T) {
 					applyPolicy := func(filename string, ns namespace.Instance) {
 						policy := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, filename))
 						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-						util.WaitForConfig(t, ns, policy...)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
 					}
 					applyPolicy("testdata/authz/v1beta1-audit.yaml.tmpl", ns)
 
@@ -1346,7 +1346,7 @@ func TestAuthorization_Audit(t *testing.T) {
 						}
 						policies := tmpl.EvaluateAllOrFail(t, args, file.AsStringOrFail(t, tc.configFile))
 						t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-						util.WaitForConfig(t, ns, policies...)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policies...)
 						rbacUtil.RunRBACTest(t, tc.subCases)
 					})
 			}
diff --git a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
index ffb0e438fb..b525aab79b 100644
--- a/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
+++ b/tests/integration/security/ecc_signature_algorithm/mtls_strict_test.go
@@ -27,7 +27,6 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/util/tmpl"
-	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/security/util/cert"
 )
 
@@ -64,11 +63,11 @@ func TestStrictMTLS(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			peerTemplate := tmpl.EvaluateOrFail(t, PeerAuthenticationConfig, map[string]string{"AppNamespace": apps.Namespace.Name()})
 			t.ConfigIstio().ApplyYAMLOrFail(t, apps.Namespace.Name(), peerTemplate)
-			util.WaitForConfig(t, apps.Namespace, peerTemplate)
+			t.ConfigIstio().WaitForConfigOrFail(t, t, apps.Namespace.Name(), peerTemplate)
 
 			drTemplate := tmpl.EvaluateOrFail(t, DestinationRuleConfigIstioMutual, map[string]string{"AppNamespace": apps.Namespace.Name()})
 			t.ConfigIstio().ApplyYAMLOrFail(t, apps.Namespace.Name(), drTemplate)
-			util.WaitForConfig(t, apps.Namespace, drTemplate)
+			t.ConfigIstio().WaitForConfigOrFail(t, t, apps.Namespace.Name(), drTemplate)
 
 			apps.Client.CallWithRetryOrFail(t, echo.CallOptions{
 				Target:    apps.Server,
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index e19a225cd0..982ff316f3 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -130,7 +130,7 @@ func TestJWTHTTPS(t *testing.T) {
 								t.Logf("failed to apply security config %s: %v", testCase.Config, err)
 								return err
 							}
-							util.WaitForConfig(t, ns, policy)
+							t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy)
 						}
 						return nil
 					}).
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index 4f5e41c537..56579fcc10 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -456,7 +456,7 @@ func TestRequestAuthentication(t *testing.T) {
 									t.Logf("failed to apply security config %s: %v", c.Config, err)
 									return err
 								}
-								util.WaitForConfig(t, ns, policy)
+								t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy)
 							}
 							return nil
 						}).
@@ -496,7 +496,7 @@ func TestIngressRequestAuthentication(t *testing.T) {
 			applyPolicy := func(filename string, ns namespace.Instance) {
 				policy := tmpl.EvaluateAllOrFail(t, namespaceTmpl, file.AsStringOrFail(t, filename))
 				t.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policy...)
-				util.WaitForConfig(t, ns, policy...)
+				t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy...)
 			}
 			applyPolicy("testdata/requestauthn/global-jwt.yaml.tmpl", newRootNS(t))
 
@@ -544,7 +544,7 @@ func TestIngressRequestAuthentication(t *testing.T) {
 							t.Logf("failed to deploy ingress: %v", err)
 							return err
 						}
-						util.WaitForConfig(t, ns, policy)
+						t.ConfigIstio().WaitForConfigOrFail(t, t, ns.Name(), policy)
 						return nil
 					}).
 					From(util.SourceFilter(t, apps, ns.Name(), false)...).
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index 79ce7a6b3f..30becc8b84 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -30,7 +30,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
 	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/components/istioctl"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
 )
@@ -336,24 +335,6 @@ func CheckExistence(ctx framework.TestContext, instances ...echo.Instances) {
 	}
 }
 
-func WaitForConfig(ctx framework.TestContext, namespace namespace.Instance, configs ...string) {
-	for _, config := range configs {
-		for _, c := range ctx.Clusters().Primaries() {
-			c := c
-			ik := istioctl.NewOrFail(ctx, ctx, istioctl.Config{Cluster: c})
-			// calling istioctl invoke in parallel can cause issues due to heavy package-var usage
-			if err := ik.WaitForConfigs(namespace.Name(), config); err != nil {
-				// Get proxy status for additional debugging
-				s, _, _ := ik.Invoke([]string{"ps"})
-				ctx.Logf("wait failed: %v", err)
-				ctx.Logf("proxy status: %v", s)
-				// TODO(https://github.com/istio/istio/issues/37148) fail hard in this case
-			}
-		}
-		// Continue anyways, so we can assess the effectiveness of using `istioctl wait`
-	}
-}
-
 // SourceFilter returns workload pod A with sidecar injected and VM
 func SourceFilter(t framework.TestContext, apps *EchoDeployments, ns string, skipVM bool) []echotest.Filter {
 	rt := []echotest.Filter{func(instances echo.Instances) echo.Instances {
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 4a56443944..5547c654df 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -107,7 +107,7 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 				return t.ConfigIstio().ApplyYAML(c.Namespace.Name(), policyYAML)
 			})
 			t.NewSubTest("wait for config").Run(func(t framework.TestContext) {
-				util.WaitForConfig(t, c.Namespace, policyYAML)
+				t.ConfigIstio().WaitForConfigOrFail(t, t, c.Namespace.Name(), policyYAML)
 			})
 			for _, clients := range []echo.Instances{apps.A, apps.B.Match(echo.Namespace(apps.Namespace1.Name())), apps.Headless, apps.Naked, apps.HeadlessNaked} {
 				for _, client := range clients {
diff --git a/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go b/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
index a3bd97a0fd..6886c3e8a4 100644
--- a/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/api/stackdriver_filter_test.go
@@ -60,7 +60,7 @@ func TestStackdriverMonitoring(t *testing.T) {
 				cltInstance := cltInstance
 				g.Go(func() error {
 					err := retry.UntilSuccess(func() error {
-						if err := stackdrivertest.SendTraffic(t, cltInstance, http.Header{}, false); err != nil {
+						if err := stackdrivertest.SendTraffic(cltInstance, http.Header{}, false); err != nil {
 							return err
 						}
 						clName := cltInstance.Config().Cluster.Name()
@@ -74,7 +74,7 @@ func TestStackdriverMonitoring(t *testing.T) {
 						}
 						t.Logf("Metrics validated")
 
-						if err := stackdrivertest.ValidateLogs(t, filepath.Join(env.IstioSrc, serverLogEntry), clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
+						if err := stackdrivertest.ValidateLogs(filepath.Join(env.IstioSrc, serverLogEntry), clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
 							return err
 						}
 						t.Logf("logs validated")
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index 66156023e3..f91155438b 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -154,8 +154,7 @@ func TestSetup(ctx resource.Context) (err error) {
 }
 
 // send both a grpc and http requests (http with forced tracing).
-func SendTraffic(t *testing.T, cltInstance echo.Instance, headers http.Header, onlyTCP bool) error {
-	t.Helper()
+func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) error {
 	//  All server instance have same names, so setting target as srv[0].
 	// Sending the number of total request same as number of servers, so that load balancing gets a chance to send request to all the clusters.
 	if onlyTCP {
@@ -253,8 +252,7 @@ func ConditionallySetupMetadataServer(ctx resource.Context) (err error) {
 	return nil
 }
 
-func ValidateLogs(t *testing.T, srvLogEntry, clName, trustDomain string, filter stackdriver.LogType) error {
-	t.Helper()
+func ValidateLogs(srvLogEntry, clName, trustDomain string, filter stackdriver.LogType) error {
 	var wantLog loggingpb.LogEntry
 	if err := unmarshalFromTemplateFile(srvLogEntry, &wantLog, clName, trustDomain); err != nil {
 		return fmt.Errorf("logs: failed to parse wanted log entry: %v", err)
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
index 3f8b72207f..0d08c8685a 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
@@ -77,21 +77,21 @@ func TestStackdriverHTTPAuditLogging(t *testing.T) {
 
 						var errs []string
 
-						errAuditFoo := ValidateLogs(t, filepath.Join(env.IstioSrc, serverAuditFooLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
+						errAuditFoo := ValidateLogs(filepath.Join(env.IstioSrc, serverAuditFooLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
 						if errAuditFoo == nil {
 							t.Logf("Foo Audit Log validated for cluster %v", clName)
 						} else {
 							errs = append(errs, errAuditFoo.Error())
 						}
 
-						errAuditBar := ValidateLogs(t, filepath.Join(env.IstioSrc, serverAuditBarLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
+						errAuditBar := ValidateLogs(filepath.Join(env.IstioSrc, serverAuditBarLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
 						if errAuditBar == nil {
 							t.Logf("Bar Audit Log validated for cluster %v", clName)
 						} else {
 							errs = append(errs, errAuditBar.Error())
 						}
 
-						errAuditAll := ValidateLogs(t, filepath.Join(env.IstioSrc, serverAuditAllLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
+						errAuditAll := ValidateLogs(filepath.Join(env.IstioSrc, serverAuditAllLogEntry), clName, trustDomain, stackdriver.ServerAuditLog)
 						if errAuditAll == nil {
 							t.Logf("All Audit Log validated for cluster %v", clName)
 						} else {
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
index e4ed6898c4..728b763f96 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_dry_run_test.go
@@ -30,7 +30,6 @@
 	"istio.io/istio/pkg/test/util/file"
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/pkg/test/util/tmpl"
-	"istio.io/istio/tests/integration/security/util"
 	"istio.io/istio/tests/integration/telemetry"
 )
 
@@ -62,19 +61,19 @@ func testDryRun(t *testing.T, policies []string, cases []dryRunCase, isTCP bool)
 		Features("observability.telemetry.stackdriver").
 		Run(func(ctx framework.TestContext) {
 			for _, policy := range policies {
-				createDryRunPolicy(t, ctx, policy)
+				createDryRunPolicy(ctx, policy)
 			}
 			for _, tc := range cases {
-				t.Run(tc.name, func(t *testing.T) {
+				ctx.NewSubTest(tc.name).Run(func(ctx framework.TestContext) {
 					g, _ := errgroup.WithContext(context.Background())
 					for _, cltInstance := range Clt {
 						cltInstance := cltInstance
 						g.Go(func() error {
 							err := retry.UntilSuccess(func() error {
-								if err := SendTraffic(t, cltInstance, tc.headers, isTCP); err != nil {
+								if err := SendTraffic(cltInstance, tc.headers, isTCP); err != nil {
 									return err
 								}
-								return verifyAccessLog(t, cltInstance, tc.wantLog)
+								return verifyAccessLog(ctx, cltInstance, tc.wantLog)
 							}, retry.Delay(framework.TelemetryRetryDelay), retry.Timeout(framework.TelemetryRetryTimeout))
 							if err != nil {
 								return err
@@ -83,7 +82,7 @@ func testDryRun(t *testing.T, policies []string, cases []dryRunCase, isTCP bool)
 						})
 					}
 					if err := g.Wait(); err != nil {
-						t.Fatalf("test failed: %v", err)
+						ctx.Fatalf("test failed: %v", err)
 					}
 				})
 			}
@@ -195,18 +194,18 @@ func TestTCPStackdriverAuthzDryRun_DenyAndAllow(t *testing.T) {
 	})
 }
 
-func createDryRunPolicy(t *testing.T, ctx framework.TestContext, authz string) {
+func createDryRunPolicy(ctx framework.TestContext, authz string) {
 	ns := EchoNsInst
-	policies := tmpl.EvaluateAllOrFail(t, map[string]string{"Namespace": ns.Name()}, file.AsStringOrFail(t, authz))
-	ctx.ConfigIstio().ApplyYAMLOrFail(t, ns.Name(), policies...)
-	util.WaitForConfig(ctx, ns, policies...)
+	policies := tmpl.EvaluateAllOrFail(ctx, map[string]string{"Namespace": ns.Name()}, file.AsStringOrFail(ctx, authz))
+	ctx.ConfigIstio().ApplyYAMLOrFail(ctx, ns.Name(), policies...)
+	ctx.ConfigIstio().WaitForConfigOrFail(ctx, ctx, ns.Name(), policies...)
 }
 
-func verifyAccessLog(t *testing.T, cltInstance echo.Instance, wantLog string) error {
-	t.Logf("Validating for cluster %v", cltInstance.Config().Cluster.Name())
+func verifyAccessLog(ctx framework.TestContext, cltInstance echo.Instance, wantLog string) error {
+	ctx.Logf("Validating for cluster %v", cltInstance.Config().Cluster.Name())
 	clName := cltInstance.Config().Cluster.Name()
 	trustDomain := telemetry.GetTrustDomain(cltInstance.Config().Cluster, Ist.Settings().SystemNamespace)
-	if err := ValidateLogs(t, wantLog, clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
+	if err := ValidateLogs(wantLog, clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
 		return err
 	}
 	return nil
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_test.go
index bb47fd7354..3cc2a5623f 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_test.go
@@ -56,7 +56,7 @@ func TestStackdriverMonitoring(t *testing.T) {
 				cltInstance := cltInstance
 				g.Go(func() error {
 					err := retry.UntilSuccess(func() error {
-						if err := SendTraffic(t, cltInstance, http.Header{}, false); err != nil {
+						if err := SendTraffic(cltInstance, http.Header{}, false); err != nil {
 							return err
 						}
 						clName := cltInstance.Config().Cluster.Name()
@@ -69,7 +69,7 @@ func TestStackdriverMonitoring(t *testing.T) {
 							return err
 						}
 						t.Logf("Metrics validated")
-						if err := ValidateLogs(t, filepath.Join(env.IstioSrc, serverLogEntry), clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
+						if err := ValidateLogs(filepath.Join(env.IstioSrc, serverLogEntry), clName, trustDomain, stackdriver.ServerAccessLog); err != nil {
 							return err
 						}
 						t.Logf("logs validated")
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
index 04d09f14a3..e9ea2997ec 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_tcp_filter_test.go
@@ -63,7 +63,7 @@ func TestTCPStackdriverMonitoring(t *testing.T) {
 							filepath.Join(env.IstioSrc, tcpClientConnectionCount), clName, trustDomain); err != nil {
 							return err
 						}
-						if err := ValidateLogs(t, filepath.Join(env.IstioSrc, tcpServerLogEntry), clName,
+						if err := ValidateLogs(filepath.Join(env.IstioSrc, tcpServerLogEntry), clName,
 							trustDomain, stackdriver.ServerAccessLog); err != nil {
 							return err
 						}
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index c7e22bf4f9..d786d9e56a 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -31,7 +31,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
 	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/components/istioctl"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/components/prometheus"
 	"istio.io/istio/pkg/test/framework/label"
@@ -251,14 +250,9 @@ func setupEnvoyFilter(ctx resource.Context) error {
 	if err := ctx.ConfigIstio().ApplyYAML("istio-system", bootstrapPatch); err != nil {
 		return err
 	}
-	// Ensure bootstrap patch is applied before starting echo.
-	ik, err := istioctl.New(ctx, istioctl.Config{Cluster: ctx.Clusters()[0]})
-	if err != nil {
-		return err
-	}
-	// calling istioctl invoke in parallel can cause issues due to heavy package-var usage
-	if err := ik.WaitForConfigs("istio-system", bootstrapPatch); err != nil {
-		log.Warnf("failed to wait for config: %v", err)
+	if err := ctx.ConfigIstio().WaitForConfig(ctx, "istio-system", bootstrapPatch); err != nil {
+		// TODO(https://github.com/istio/istio/issues/37148) fail hard in this case
+		log.Warnf(err)
 	}
 	return nil
 }
-- 
2.35.3

