From 2ffbf677e1b0bd202dfaa44783494279848fda5e Mon Sep 17 00:00:00 2001
From: Rama Chavali <rama.rao@salesforce.com>
Date: Wed, 16 Feb 2022 23:04:23 +0530
Subject: remove feature flags for se selecting pods (#37374)

* remove feature flags for selecting pods

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>

* fix test

Signed-off-by: Rama Chavali <rama.rao@salesforce.com>
---
 pilot/pkg/features/pilot.go                   |  8 -----
 .../kube/controller/controller.go             | 14 +++-----
 .../kube/controller/controller_test.go        | 15 --------
 .../kube/controller/endpointcontroller.go     | 16 ++++-----
 .../kube/controller/multicluster.go           | 36 +++++++++----------
 5 files changed, 29 insertions(+), 60 deletions(-)

diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 2303da3000..0a12a4d3dc 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -389,14 +389,6 @@
 		"If enabled, pilot will authorize XDS clients, to ensure they are acting only as namespaces they have permissions for.",
 	).Get()
 
-	EnableServiceEntrySelectPods = env.RegisterBoolVar("PILOT_ENABLE_SERVICEENTRY_SELECT_PODS", true,
-		"If enabled, service entries with selectors will select pods from the cluster. "+
-			"It is safe to disable it if you are quite sure you don't need this feature").Get()
-
-	EnableK8SServiceSelectWorkloadEntries = env.RegisterBoolVar("PILOT_ENABLE_K8S_SELECT_WORKLOAD_ENTRIES", true,
-		"If enabled, Kubernetes services with selectors will select workload entries with matching labels. "+
-			"It is safe to disable it if you are quite sure you don't need this feature").Get()
-
 	InjectionWebhookConfigName = env.RegisterStringVar("INJECTION_WEBHOOK_CONFIG_NAME", "istio-sidecar-injector",
 		"Name of the mutatingwebhookconfiguration to patch, if istioctl is not used.").Get()
 
diff --git a/pilot/pkg/serviceregistry/kube/controller/controller.go b/pilot/pkg/serviceregistry/kube/controller/controller.go
index 0fcf8c8a11..5716231aaf 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller.go
@@ -590,11 +590,9 @@ func (c *Controller) addOrUpdateService(svc *v1.Service, svcConv *model.Service,
 	// We also need to update when the Service changes. For Kubernetes, a service change will result in Endpoint updates,
 	// but workload entries will also need to be updated.
 	// TODO(nmittler): Build different sets of endpoints for cluster.local and clusterset.local.
-	if updateEDSCache || features.EnableK8SServiceSelectWorkloadEntries {
-		endpoints := c.buildEndpointsForService(svcConv, updateEDSCache)
-		if len(endpoints) > 0 {
-			c.opts.XDSUpdater.EDSCacheUpdate(shard, string(svcConv.Hostname), ns, endpoints)
-		}
+	endpoints := c.buildEndpointsForService(svcConv, updateEDSCache)
+	if len(endpoints) > 0 {
+		c.opts.XDSUpdater.EDSCacheUpdate(shard, string(svcConv.Hostname), ns, endpoints)
 	}
 
 	c.opts.XDSUpdater.SvcUpdate(shard, string(svcConv.Hostname), ns, event)
@@ -604,10 +602,8 @@ func (c *Controller) addOrUpdateService(svc *v1.Service, svcConv *model.Service,
 
 func (c *Controller) buildEndpointsForService(svc *model.Service, updateCache bool) []*model.IstioEndpoint {
 	endpoints := c.endpoints.buildIstioEndpointsWithService(svc.Attributes.Name, svc.Attributes.Namespace, svc.Hostname, updateCache)
-	if features.EnableK8SServiceSelectWorkloadEntries {
-		fep := c.collectWorkloadInstanceEndpoints(svc)
-		endpoints = append(endpoints, fep...)
-	}
+	fep := c.collectWorkloadInstanceEndpoints(svc)
+	endpoints = append(endpoints, fep...)
 	return endpoints
 }
 
diff --git a/pilot/pkg/serviceregistry/kube/controller/controller_test.go b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
index d44595db16..18b12af205 100644
--- a/pilot/pkg/serviceregistry/kube/controller/controller_test.go
+++ b/pilot/pkg/serviceregistry/kube/controller/controller_test.go
@@ -38,7 +38,6 @@
 	"istio.io/api/annotation"
 	"istio.io/api/label"
 	meshconfig "istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller/filter"
@@ -2694,24 +2693,10 @@ func TestUpdateEdsCacheOnServiceUpdate(t *testing.T) {
 		"app": "prod-app",
 		"foo": "bar",
 	}
-	// set `K8SServiceSelectWorkloadEntries` to false temporarily
-	tmp := features.EnableK8SServiceSelectWorkloadEntries
-	features.EnableK8SServiceSelectWorkloadEntries = false
-	defer func() {
-		features.EnableK8SServiceSelectWorkloadEntries = tmp
-	}()
-	svc = updateService(controller, svc, t)
-	// don't update eds cache if `K8S_SELECT_WORKLOAD_ENTRIES` is disabled
-	if ev := fx.Wait("eds cache"); ev != nil {
-		t.Fatal("Update eds cache unexpectedly")
-	}
-
-	features.EnableK8SServiceSelectWorkloadEntries = true
 	svc.Spec.Selector = map[string]string{
 		"app": "prod-app",
 	}
 	updateService(controller, svc, t)
-	// update eds cache if `K8S_SELECT_WORKLOAD_ENTRIES` is enabled
 	if ev := fx.Wait("eds cache"); ev == nil {
 		t.Fatal("Timeout updating eds cache")
 	}
diff --git a/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go b/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go
index 5e77da92fb..082bcb3812 100644
--- a/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go
+++ b/pilot/pkg/serviceregistry/kube/controller/endpointcontroller.go
@@ -106,15 +106,13 @@ func updateEDS(c *Controller, epc kubeEndpointsController, ep interface{}, event
 			endpoints = epc.buildIstioEndpoints(ep, hostName)
 		}
 
-		if features.EnableK8SServiceSelectWorkloadEntries {
-			svc := c.GetService(hostName)
-			if svc != nil {
-				fep := c.collectWorkloadInstanceEndpoints(svc)
-				endpoints = append(endpoints, fep...)
-			} else {
-				log.Debugf("Handle EDS endpoint: skip collecting workload entry endpoints, service %s/%s has not been populated",
-					namespacedName.Namespace, namespacedName.Name)
-			}
+		svc := c.GetService(hostName)
+		if svc != nil {
+			fep := c.collectWorkloadInstanceEndpoints(svc)
+			endpoints = append(endpoints, fep...)
+		} else {
+			log.Debugf("Handle EDS endpoint: skip collecting workload entry endpoints, service %s/%s has not been populated",
+				namespacedName.Namespace, namespacedName.Name)
 		}
 
 		c.opts.XDSUpdater.EDSUpdate(shard, string(hostName), namespacedName.Namespace, endpoints)
diff --git a/pilot/pkg/serviceregistry/kube/controller/multicluster.go b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
index b276df7ee2..1c23570107 100644
--- a/pilot/pkg/serviceregistry/kube/controller/multicluster.go
+++ b/pilot/pkg/serviceregistry/kube/controller/multicluster.go
@@ -174,30 +174,28 @@ func (m *Multicluster) ClusterAdded(cluster *multicluster.Cluster, clusterStopCh
 	m.m.Unlock()
 
 	// TODO move instance cache out of registries
-	if m.serviceEntryStore != nil && features.EnableServiceEntrySelectPods {
+	if m.serviceEntryStore != nil {
 		// Add an instance handler in the kubernetes registry to notify service entry store about pod events
 		kubeRegistry.AppendWorkloadHandler(m.serviceEntryStore.WorkloadInstanceHandler)
 	}
 
 	// TODO implement deduping in aggregate registry to allow multiple k8s registries to handle WorkloadEntry
-	if features.EnableK8SServiceSelectWorkloadEntries {
-		if m.serviceEntryStore != nil && localCluster {
-			// Add an instance handler in the service entry store to notify kubernetes about workload entry events
-			m.serviceEntryStore.AppendWorkloadHandler(kubeRegistry.WorkloadInstanceHandler)
-		} else if features.WorkloadEntryCrossCluster {
-			// TODO only do this for non-remotes, can't guarantee CRDs in remotes (depends on https://github.com/istio/istio/pull/29824)
-			if configStore, err := createConfigStore(client, m.revision, options); err == nil {
-				m.remoteKubeControllers[cluster.ID].workloadEntryStore = serviceentry.NewServiceDiscovery(
-					configStore, model.MakeIstioStore(configStore), options.XDSUpdater,
-					serviceentry.DisableServiceEntryProcessing(), serviceentry.WithClusterID(cluster.ID),
-					serviceentry.WithNetworkIDCb(kubeRegistry.Network))
-				// Services can select WorkloadEntry from the same cluster. We only duplicate the Service to configure kube-dns.
-				m.remoteKubeControllers[cluster.ID].workloadEntryStore.AppendWorkloadHandler(kubeRegistry.WorkloadInstanceHandler)
-				m.opts.MeshServiceController.AddRegistryAndRun(m.remoteKubeControllers[cluster.ID].workloadEntryStore, clusterStopCh)
-				go configStore.Run(clusterStopCh)
-			} else {
-				return fmt.Errorf("failed creating config configStore for cluster %s: %v", cluster.ID, err)
-			}
+	if m.serviceEntryStore != nil && localCluster {
+		// Add an instance handler in the service entry store to notify kubernetes about workload entry events
+		m.serviceEntryStore.AppendWorkloadHandler(kubeRegistry.WorkloadInstanceHandler)
+	} else if features.WorkloadEntryCrossCluster {
+		// TODO only do this for non-remotes, can't guarantee CRDs in remotes (depends on https://github.com/istio/istio/pull/29824)
+		if configStore, err := createConfigStore(client, m.revision, options); err == nil {
+			m.remoteKubeControllers[cluster.ID].workloadEntryStore = serviceentry.NewServiceDiscovery(
+				configStore, model.MakeIstioStore(configStore), options.XDSUpdater,
+				serviceentry.DisableServiceEntryProcessing(), serviceentry.WithClusterID(cluster.ID),
+				serviceentry.WithNetworkIDCb(kubeRegistry.Network))
+			// Services can select WorkloadEntry from the same cluster. We only duplicate the Service to configure kube-dns.
+			m.remoteKubeControllers[cluster.ID].workloadEntryStore.AppendWorkloadHandler(kubeRegistry.WorkloadInstanceHandler)
+			m.opts.MeshServiceController.AddRegistryAndRun(m.remoteKubeControllers[cluster.ID].workloadEntryStore, clusterStopCh)
+			go configStore.Run(clusterStopCh)
+		} else {
+			return fmt.Errorf("failed creating config configStore for cluster %s: %v", cluster.ID, err)
 		}
 	}
 
-- 
2.35.3

