From ad28f463a413f2e55288d2751a39adfb9da3a47d Mon Sep 17 00:00:00 2001
From: Shriram Sharma <shriram.sharma22@gmail.com>
Date: Thu, 20 Jan 2022 15:38:09 -0800
Subject: fixed the mtls check for tls on sidecar (#36897)

* fixed the mtls check for tls on sidecar

* added some tests

* added release notes

* fixed linting errors

* fixed release notes

* change release notes from bugfix to feature

* deleted the release notes

Co-authored-by: Shriram Sharma <shriram_sharma@intuit.com>
---
 .../core/v1alpha3/listener_builder.go         |   6 +-
 .../core/v1alpha3/listener_builder_test.go    | 183 ++++++++++++++++++
 2 files changed, 185 insertions(+), 4 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 70482bcc79..492d896b96 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -592,13 +592,11 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 
 	// unless the PeerAuthentication is set to "DISABLE",
 	// TLS settings won't take effect
-	hasMTLs := true
+	hasMTLs := false
 
 	mtlsConfigs := getMtlsSettings(configgen, in, passthrough)
 	for _, mtlsConfig := range mtlsConfigs {
-		if mtlsConfig.Mode == model.MTLSDisable {
-			hasMTLs = false
-		}
+		hasMTLs = hasMTLs || mtlsConfig.Mode != model.MTLSDisable
 		for _, match := range getFilterChainMatchOptions(mtlsConfig, listenerOpts.protocol) {
 			opt := fcOpts{matchOpts: match}.populateFilterChain(mtlsConfig, mtlsConfig.Port, matchingIP)
 			newOpts = append(newOpts, &opt)
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
index fc20e0dc8a..aeea9d4498 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder_test.go
@@ -22,6 +22,7 @@
 
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
 	"github.com/gogo/protobuf/jsonpb"
 	"github.com/gogo/protobuf/types"
@@ -29,6 +30,7 @@
 	networking "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
+	istionetworking "istio.io/istio/pilot/pkg/networking"
 	"istio.io/istio/pilot/pkg/networking/plugin"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/test/xdstest"
@@ -702,3 +704,184 @@ func evaluateListenerFilterPredicates(t testing.TB, predicate *listener.Listener
 		}
 	}
 }
+
+type TestAuthnPlugin struct {
+	mtlsSettings []plugin.MTLSSettings
+}
+
+func TestSidecarInboundListenerFilters(t *testing.T) {
+	services := []*model.Service{
+		buildServiceWithPort("test.com", 80, protocol.HTTPS, tnow),
+	}
+	instances := make([]*model.ServiceInstance, 0, len(services))
+	for _, s := range services {
+		instances = append(instances, &model.ServiceInstance{
+			Service: s,
+			Endpoint: &model.IstioEndpoint{
+				EndpointPort: uint32(s.Ports[0].Port),
+				Address:      "1.1.1.1",
+			},
+			ServicePort: s.Ports[0],
+		})
+	}
+	cases := []struct {
+		name           string
+		sidecarScope   *model.SidecarScope
+		mtlsSettings   []plugin.MTLSSettings
+		expectedResult func(filterChain *listener.FilterChain)
+	}{
+		{
+			name: "simulate peer auth disabled on port 80",
+			sidecarScope: &model.SidecarScope{
+				Sidecar: &networking.Sidecar{
+					Ingress: []*networking.IstioIngressListener{
+						{
+							Port: &networking.Port{Name: "https-port", Protocol: "https", Number: 80},
+							Tls: &networking.ServerTLSSettings{
+								Mode:              networking.ServerTLSSettings_SIMPLE,
+								ServerCertificate: "cert.pem",
+								PrivateKey:        "privatekey.pem",
+							},
+						},
+					},
+				},
+			},
+			mtlsSettings: []plugin.MTLSSettings{{
+				Mode: model.MTLSDisable,
+			}},
+			expectedResult: func(filterChain *listener.FilterChain) {
+				tlsContext := &tls.DownstreamTlsContext{}
+				if err := filterChain.GetTransportSocket().GetTypedConfig().UnmarshalTo(tlsContext); err != nil {
+					t.Fatal(err)
+				}
+				commonTLSContext := tlsContext.CommonTlsContext
+				if len(commonTLSContext.TlsCertificateSdsSecretConfigs) == 0 {
+					t.Fatal("expected tls certificates")
+				}
+				if commonTLSContext.TlsCertificateSdsSecretConfigs[0].Name != "file-cert:cert.pem~privatekey.pem" {
+					t.Fatalf("expected certificate httpbin.pem, actual %s",
+						commonTLSContext.TlsCertificates[0].CertificateChain.String())
+				}
+				if tlsContext.RequireClientCertificate.Value == true {
+					t.Fatalf("expected RequireClientCertificate to be false")
+				}
+			},
+		},
+		{
+			name: "simulate peer auth strict",
+			sidecarScope: &model.SidecarScope{
+				Sidecar: &networking.Sidecar{
+					Ingress: []*networking.IstioIngressListener{
+						{
+							Port: &networking.Port{Name: "https-port", Protocol: "https", Number: 80},
+							Tls: &networking.ServerTLSSettings{
+								Mode:              networking.ServerTLSSettings_SIMPLE,
+								ServerCertificate: "cert.pem",
+								PrivateKey:        "privatekey.pem",
+							},
+						},
+					},
+				},
+			},
+			mtlsSettings: []plugin.MTLSSettings{{
+				Mode: model.MTLSStrict,
+			}},
+			expectedResult: func(filterChain *listener.FilterChain) {
+				if filterChain.GetTransportSocket() != nil {
+					t.Fatal("expected transport socket to be nil")
+				}
+			},
+		},
+		{
+			name: "simulate peer auth permissive",
+			sidecarScope: &model.SidecarScope{
+				Sidecar: &networking.Sidecar{
+					Ingress: []*networking.IstioIngressListener{
+						{
+							Port: &networking.Port{Name: "https-port", Protocol: "https", Number: 80},
+							Tls: &networking.ServerTLSSettings{
+								Mode:              networking.ServerTLSSettings_SIMPLE,
+								ServerCertificate: "cert.pem",
+								PrivateKey:        "privatekey.pem",
+							},
+						},
+					},
+				},
+			},
+			mtlsSettings: []plugin.MTLSSettings{{
+				Mode: model.MTLSPermissive,
+			}},
+			expectedResult: func(filterChain *listener.FilterChain) {
+				if filterChain.GetTransportSocket() != nil {
+					t.Fatal("expected transport socket to be nil")
+				}
+			},
+		},
+		{
+			name: "simulate multiple mode returned in mtlssettings",
+			sidecarScope: &model.SidecarScope{
+				Sidecar: &networking.Sidecar{
+					Ingress: []*networking.IstioIngressListener{
+						{
+							Port: &networking.Port{Name: "https-port", Protocol: "https", Number: 80},
+							Tls: &networking.ServerTLSSettings{
+								Mode:              networking.ServerTLSSettings_SIMPLE,
+								ServerCertificate: "cert.pem",
+								PrivateKey:        "privatekey.pem",
+							},
+						},
+					},
+				},
+			},
+			mtlsSettings: []plugin.MTLSSettings{
+				{
+					Mode: model.MTLSStrict,
+				},
+				{
+					Mode: model.MTLSDisable,
+				},
+			},
+			expectedResult: func(filterChain *listener.FilterChain) {
+				if filterChain.GetTransportSocket() != nil {
+					t.Fatal("expected transport socket to be nil")
+				}
+			},
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			testPlugin := &TestAuthnPlugin{
+				mtlsSettings: tt.mtlsSettings,
+			}
+			cg := NewConfigGenTest(t, TestOptions{
+				Services:  services,
+				Instances: instances,
+				Plugins:   []plugin.Plugin{testPlugin},
+			})
+			proxy := cg.SetupProxy(nil)
+			proxy.Metadata = &model.NodeMetadata{Labels: map[string]string{"app": "foo"}}
+			proxy.SidecarScope = tt.sidecarScope
+			features.EnableTLSOnSidecarIngress = true
+			listeners := cg.Listeners(proxy)
+			virtualInbound := xdstest.ExtractListener("virtualInbound", listeners)
+			filterChain := xdstest.ExtractFilterChain("1.1.1.1_80", virtualInbound)
+			tt.expectedResult(filterChain)
+		})
+	}
+}
+
+func (t TestAuthnPlugin) OnOutboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
+	return nil
+}
+
+func (t TestAuthnPlugin) OnInboundListener(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
+	return nil
+}
+
+func (t TestAuthnPlugin) OnInboundPassthrough(in *plugin.InputParams, mutable *istionetworking.MutableObjects) error {
+	return nil
+}
+
+func (t TestAuthnPlugin) InboundMTLSConfiguration(in *plugin.InputParams, passthrough bool) []plugin.MTLSSettings {
+	return t.mtlsSettings
+}
-- 
2.35.3

