From 800652efa1b7aadd881bd628991cd2ab562d3c36 Mon Sep 17 00:00:00 2001
From: Pengyuan Bian <bianpengyuan@google.com>
Date: Fri, 14 Jan 2022 14:53:00 -0800
Subject: Only inject metadata exchange filters when proxy version is GE 1.12.
 (#36797)

* Only inject metadata exchange filters when proxy version is GE 1.12.

* add rn

* Check EnvoyFilter for mx injection.

* update.

* update.
---
 pilot/pkg/model/push_context.go               | 10 +++++
 pilot/pkg/model/push_context_test.go          |  9 +++++
 .../core/v1alpha3/cluster_builder.go          | 10 ++---
 .../pkg/networking/core/v1alpha3/listener.go  |  2 +-
 .../core/v1alpha3/listener_builder.go         |  4 +-
 .../networking/core/v1alpha3/networkfilter.go | 12 +++---
 pilot/pkg/networking/util/util.go             | 39 +++++++++++++++++++
 releasenotes/notes/36796.yaml                 |  9 +++++
 8 files changed, 82 insertions(+), 13 deletions(-)
 create mode 100644 releasenotes/notes/36796.yaml

diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index a3e4f97908..c7111abd38 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -1915,6 +1915,16 @@ func (ps *PushContext) getMatchedEnvoyFilters(proxy *Proxy, namespaces string) [
 	return matchedEnvoyFilters
 }
 
+// HasEnvoyFilters checks if an EnvoyFilter exists with the given name at the given namespace.
+func (ps *PushContext) HasEnvoyFilters(name, namespace string) bool {
+	for _, efw := range ps.envoyFiltersByNamespace[namespace] {
+		if efw.Name == name {
+			return true
+		}
+	}
+	return false
+}
+
 // pre computes gateways per namespace
 func (ps *PushContext) initGateways(env *Environment) error {
 	gatewayConfigs, err := env.List(gvk.Gateway, NamespaceAll)
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index 71dcd1b222..99a4efbaad 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -146,6 +146,7 @@ func TestEnvoyFilters(t *testing.T) {
 	proxyVersionRegex := regexp.MustCompile(`1\.4.*`)
 	envoyFilters := []*EnvoyFilterWrapper{
 		{
+			Name:             "ef1",
 			workloadSelector: map[string]string{"app": "v1"},
 			Patches: map[networking.EnvoyFilter_ApplyTo][]*EnvoyFilterConfigPatchWrapper{
 				networking.EnvoyFilter_LISTENER: {
@@ -161,6 +162,7 @@ func TestEnvoyFilters(t *testing.T) {
 			},
 		},
 		{
+			Name:             "ef2",
 			workloadSelector: map[string]string{"app": "v1"},
 			Patches: map[networking.EnvoyFilter_ApplyTo][]*EnvoyFilterConfigPatchWrapper{
 				networking.EnvoyFilter_CLUSTER: {
@@ -187,6 +189,13 @@ func TestEnvoyFilters(t *testing.T) {
 		},
 	}
 
+	if !push.HasEnvoyFilters("ef1", "test-ns") {
+		t.Errorf("Check presence of EnvoyFilter ef1 at test-ns got false, want true")
+	}
+	if push.HasEnvoyFilters("ef3", "test-ns") {
+		t.Errorf("Check presence of EnvoyFilter ef3 at test-ns got true, want false")
+	}
+
 	cases := []struct {
 		name                    string
 		proxy                   *Proxy
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster_builder.go b/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
index 4fcdb4d5ec..7a35fbfe5c 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster_builder.go
@@ -223,7 +223,7 @@ func (cb *ClusterBuilder) buildSubsetCluster(opts buildClusterOpts, destRule *co
 	maybeApplyEdsConfig(subsetCluster.cluster)
 
 	if cb.proxyType == model.Router || opts.direction == model.TrafficDirectionOutbound {
-		cb.applyMetadataExchange(opts.mutable.cluster)
+		cb.applyMetadataExchange(cb.req.Push, opts.mutable.cluster)
 	}
 
 	// Add the DestinationRule+subsets metadata. Metadata here is generated on a per-cluster
@@ -267,7 +267,7 @@ func (cb *ClusterBuilder) applyDestinationRule(mc *MutableCluster, clusterMode C
 	maybeApplyEdsConfig(mc.cluster)
 
 	if cb.proxyType == model.Router || opts.direction == model.TrafficDirectionOutbound {
-		cb.applyMetadataExchange(opts.mutable.cluster)
+		cb.applyMetadataExchange(cb.req.Push, opts.mutable.cluster)
 	}
 
 	if destRule != nil {
@@ -283,8 +283,8 @@ func (cb *ClusterBuilder) applyDestinationRule(mc *MutableCluster, clusterMode C
 	return subsetClusters
 }
 
-func (cb *ClusterBuilder) applyMetadataExchange(c *cluster.Cluster) {
-	if features.MetadataExchange {
+func (cb *ClusterBuilder) applyMetadataExchange(pc *model.PushContext, c *cluster.Cluster) {
+	if features.MetadataExchange && util.CheckProxyVerionForMX(pc, model.ParseIstioVersion(cb.proxyVersion)) {
 		c.Filters = append(c.Filters, xdsfilters.TCPClusterMx)
 	}
 }
@@ -702,7 +702,7 @@ func (cb *ClusterBuilder) buildDefaultPassthroughCluster() *cluster.Cluster {
 		},
 	}
 	cb.applyConnectionPool(cb.req.Push.Mesh, NewMutableCluster(cluster), &networking.ConnectionPoolSettings{})
-	cb.applyMetadataExchange(cluster)
+	cb.applyMetadataExchange(cb.req.Push, cluster)
 	return cluster
 }
 
diff --git a/pilot/pkg/networking/core/v1alpha3/listener.go b/pilot/pkg/networking/core/v1alpha3/listener.go
index 7319ece3c8..7f01ba96c6 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener.go
@@ -1399,7 +1399,7 @@ func buildHTTPConnectionManager(listenerOpts buildListenerOpts, httpOpts *httpLi
 	filters := make([]*hcm.HttpFilter, len(httpFilters))
 	copy(filters, httpFilters)
 
-	if features.MetadataExchange {
+	if features.MetadataExchange && util.CheckProxyVerionForMX(listenerOpts.push, listenerOpts.proxy.IstioVersion) {
 		filters = append(filters, xdsfilters.HTTPMx)
 	}
 
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 55792bf074..70482bcc79 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -505,7 +505,7 @@ func buildInboundCatchAllFilterChains(configgen *ConfigGeneratorImpl,
 	}
 
 	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, buildMetadataExchangeNetworkFilters(push, istionetworking.ListenerClassSidecarInbound, node.IstioVersion)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, istionetworking.ListenerClassSidecarInbound)...)
 	filters = append(filters, &listener.Filter{
 		Name: wellknown.TCPProxy,
@@ -660,7 +660,7 @@ func (configgen *ConfigGeneratorImpl) buildInboundFilterchains(in *plugin.InputP
 		case istionetworking.ListenerProtocolHTTP:
 			fcOpt.httpOpts = configgen.buildSidecarInboundHTTPListenerOptsForPortOrUDS(in.Node, in, clusterName)
 			fcOpt.filterChain.TCP = append(
-				buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound),
+				buildMetadataExchangeNetworkFilters(in.Push, istionetworking.ListenerClassSidecarInbound, in.Node.IstioVersion),
 				fcOpt.filterChain.TCP...)
 		case istionetworking.ListenerProtocolTCP:
 			fcOpt.networkFilters = buildInboundNetworkFilters(in.Push, in.Node, in.ServiceInstance, clusterName)
diff --git a/pilot/pkg/networking/core/v1alpha3/networkfilter.go b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
index 8e84e6affb..732c7902be 100644
--- a/pilot/pkg/networking/core/v1alpha3/networkfilter.go
+++ b/pilot/pkg/networking/core/v1alpha3/networkfilter.go
@@ -41,9 +41,11 @@
 // redisOpTimeout is the default operation timeout for the Redis proxy filter.
 var redisOpTimeout = 5 * time.Second
 
-func buildMetadataExchangeNetworkFilters(class istionetworking.ListenerClass) []*listener.Filter {
+func buildMetadataExchangeNetworkFilters(push *model.PushContext, class istionetworking.ListenerClass, version *model.IstioVersion) []*listener.Filter {
 	filterstack := make([]*listener.Filter, 0)
-
+	if !util.CheckProxyVerionForMX(push, version) {
+		return filterstack
+	}
 	// We add metadata exchange on inbound only; outbound is handled in cluster filter
 	if class == istionetworking.ListenerClassSidecarInbound {
 		filterstack = append(filterstack, xdsfilters.TCPListenerMx)
@@ -71,7 +73,7 @@ func buildInboundNetworkFilters(push *model.PushContext, proxy *model.Proxy, ins
 	tcpFilter := setAccessLogAndBuildTCPFilter(push, proxy, tcpProxy)
 
 	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(istionetworking.ListenerClassSidecarInbound)...)
+	filters = append(filters, buildMetadataExchangeNetworkFilters(push, istionetworking.ListenerClassSidecarInbound, proxy.IstioVersion)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, proxy, istionetworking.ListenerClassSidecarInbound)...)
 	filters = append(filters, buildNetworkFiltersStack(instance.ServicePort, tcpFilter, statPrefix, clusterName)...)
 	return filters
@@ -106,7 +108,7 @@ func buildOutboundNetworkFiltersWithSingleDestination(push *model.PushContext, n
 	tcpFilter := setAccessLogAndBuildTCPFilter(push, node, tcpProxy)
 
 	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(model.OutboundListenerClass(node.Type))...)
+	filters = append(filters, buildMetadataExchangeNetworkFilters(push, model.OutboundListenerClass(node.Type), node.IstioVersion)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, model.OutboundListenerClass(node.Type))...)
 	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
 	return filters
@@ -150,7 +152,7 @@ func buildOutboundNetworkFiltersWithWeightedClusters(node *model.Proxy, routes [
 	tcpFilter := setAccessLogAndBuildTCPFilter(push, node, tcpProxy)
 
 	var filters []*listener.Filter
-	filters = append(filters, buildMetadataExchangeNetworkFilters(model.OutboundListenerClass(node.Type))...)
+	filters = append(filters, buildMetadataExchangeNetworkFilters(push, model.OutboundListenerClass(node.Type), node.IstioVersion)...)
 	filters = append(filters, buildMetricsNetworkFilters(push, node, model.OutboundListenerClass(node.Type))...)
 	filters = append(filters, buildNetworkFiltersStack(port, tcpFilter, statPrefix, clusterName)...)
 	return filters
diff --git a/pilot/pkg/networking/util/util.go b/pilot/pkg/networking/util/util.go
index cf1c76caa3..5555b26579 100644
--- a/pilot/pkg/networking/util/util.go
+++ b/pilot/pkg/networking/util/util.go
@@ -100,6 +100,11 @@
 
 	// Well-known header names
 	AltSvcHeader = "alt-svc"
+
+	// Well-known metadata exchange EnvoyFilter config name
+	// TODO: Remove these at 1.14.
+	MXName110 = "metadata-exchange-1.10"
+	MXName111 = "metadata-exchange-1.11"
 )
 
 // ALPNH2Only advertises that Proxy is going to use HTTP/2 when talking to the cluster.
@@ -255,6 +260,18 @@ func SortVirtualHosts(hosts []*route.VirtualHost) {
 	})
 }
 
+// IsIstioVersionGE110 checks whether the given Istio version is greater than or equals 1.10.
+func IsIstioVersionGE110(version *model.IstioVersion) bool {
+	return version == nil ||
+		version.Compare(&model.IstioVersion{Major: 1, Minor: 10, Patch: -1}) >= 0
+}
+
+// IsIstioVersionGE111 checks whether the given Istio version is greater than or equals 1.11.
+func IsIstioVersionGE111(version *model.IstioVersion) bool {
+	return version == nil ||
+		version.Compare(&model.IstioVersion{Major: 1, Minor: 11, Patch: -1}) >= 0
+}
+
 // IsIstioVersionGE112 checks whether the given Istio version is greater than or equals 1.12.
 func IsIstioVersionGE112(version *model.IstioVersion) bool {
 	return version == nil ||
@@ -702,3 +719,25 @@ func TraceOperation(host string, port int) string {
 	// Format : "%s:%d/*"
 	return DomainName(host, port) + "/*"
 }
+
+// CheckProxyVerionForMX checks whether metadata exchange filters should be injected
+// based on proxy version and presence of the well known metadata exchange EnvoyFilter.
+// TODO: Remove this at 1.14 release, since we support skip version upgrade
+//       now and 1.11 proxy can talk to 1.13 control plane.
+func CheckProxyVerionForMX(push *model.PushContext, proxyVersion *model.IstioVersion) bool {
+	if IsIstioVersionGE112(proxyVersion) {
+		// Always inject for proxy >= 1.12 since mx EnvoyFilters are removed.
+		return true
+	}
+	if IsIstioVersionGE111(proxyVersion) {
+		// If Istio version is >= 1.11 and < 1.12, inject only if the well known 1.11 EnvoyFilter does not present.
+		return !push.HasEnvoyFilters(MXName111, push.Mesh.RootNamespace)
+	}
+	if IsIstioVersionGE110(proxyVersion) {
+		// If Istio version is >= 1.10 and < 1.11, inject only if the well known 1.10 EnvoyFilter does not present.
+		return !push.HasEnvoyFilters(MXName110, push.Mesh.RootNamespace)
+	}
+
+	// For proxy < 1.10, this is not a supported case, we inject anyway.
+	return true
+}
diff --git a/releasenotes/notes/36796.yaml b/releasenotes/notes/36796.yaml
new file mode 100644
index 0000000000..4d4c1bd5d5
--- /dev/null
+++ b/releasenotes/notes/36796.yaml
@@ -0,0 +1,9 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+  - https://github.com/istio/istio/pull/36797
+releaseNotes:
+  - |
+    **Fixed** an issue where in place upgrade will cause tcp connection between <1.12 proxy and 1.12 proxy to fail.
+
-- 
2.35.3

