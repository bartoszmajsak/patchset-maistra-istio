From 08f5cebeeab43046282510b0f241a91a09106507 Mon Sep 17 00:00:00 2001
From: John Howard <howardjohn@google.com>
Date: Thu, 4 Nov 2021 10:25:48 -0700
Subject: docker: rewrite make+bash with a simple golang tool (#35882)

* wip

* Core building

* fix up buildx gen

* Simple e2e

* Add script to conditionally build

* Seems to be 100% functional

* saving

* hack untagged default

* Move more things over to new builder

* fix extra space

* fix lint

* final cleanup

* lint

* fix save in CI

* fix cni

* add safety check

* Switch to local out
---
 pkg/test/env/istio.go                         |  23 ++
 .../customize_metrics_test.go                 |  15 +-
 tools/docker                                  |  36 ++
 tools/docker-builder/main.go                  | 338 ++++++++++++++++++
 tools/docker-builder/types.go                 | 193 ++++++++++
 tools/docker-copy.sh                          |   6 +-
 tools/istio-docker.mk                         |  39 ++
 7 files changed, 632 insertions(+), 18 deletions(-)
 create mode 100755 tools/docker
 create mode 100644 tools/docker-builder/main.go
 create mode 100644 tools/docker-builder/types.go

diff --git a/pkg/test/env/istio.go b/pkg/test/env/istio.go
index 170f81b7e4..0ad7d598be 100644
--- a/pkg/test/env/istio.go
+++ b/pkg/test/env/istio.go
@@ -15,6 +15,7 @@
 package env
 
 import (
+	"encoding/json"
 	"fmt"
 	"os"
 	"path"
@@ -121,3 +122,25 @@ func CheckFileExists(path string) error {
 	}
 	return nil
 }
+
+func ReadProxySHA() (string, error) {
+	type DepsFile struct {
+		Name          string `json:"name"`
+		LastStableSHA string `json:"lastStableSHA"`
+	}
+	f := filepath.Join(IstioSrc, "istio.deps")
+	depJSON, err := os.ReadFile(f)
+	if err != nil {
+		return "", err
+	}
+	var deps []DepsFile
+	if err := json.Unmarshal(depJSON, &deps); err != nil {
+		return "", err
+	}
+	for _, d := range deps {
+		if d.Name == "PROXY_REPO_SHA" {
+			return d.LastStableSHA, nil
+		}
+	}
+	return "", fmt.Errorf("PROXY_REPO_SHA not found")
+}
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index 9b17e0ba75..f132d9ccfd 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -18,11 +18,9 @@
 package customizemetrics
 
 import (
-	"encoding/json"
 	"fmt"
 	"net/http"
 	"os"
-	"path"
 	"strings"
 	"testing"
 	"time"
@@ -200,21 +198,10 @@ func setupEnvoyFilter(ctx resource.Context) error {
 	if nsErr != nil {
 		return nsErr
 	}
-	proxyDepFile := path.Join(env.IstioSrc, "istio.deps")
-	depJSON, err := os.ReadFile(proxyDepFile)
+	proxySHA, err := env.ReadProxySHA()
 	if err != nil {
 		return err
 	}
-	var deps []interface{}
-	if err := json.Unmarshal(depJSON, &deps); err != nil {
-		return err
-	}
-	proxySHA := ""
-	for _, d := range deps {
-		if dm, ok := d.(map[string]interface{}); ok && dm["repoName"].(string) == "proxy" {
-			proxySHA = dm["lastStableSHA"].(string)
-		}
-	}
 	content, err := os.ReadFile("testdata/attributegen_envoy_filter.yaml")
 	if err != nil {
 		return err
diff --git a/tools/docker b/tools/docker
new file mode 100755
index 0000000000..c588973d0a
--- /dev/null
+++ b/tools/docker
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+# Copyright Istio Authors. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+WD=$(dirname "$0")
+WD=$(cd "$WD"; pwd)
+ROOT=$(dirname "$WD")
+
+set -eu
+
+cd "${ROOT}"
+
+export REPO_ROOT="${ROOT}"
+
+if [[ -f out/linux_amd64/docker-builder ]]; then
+  CURRENT_BUILD="$(./common/scripts/report_build_info.sh | grep buildGitRevision | cut -d= -f2)"
+  PREBUILT="$(out/linux_amd64/docker-builder --version)"
+  if [[ "${CURRENT_BUILD}" != "${PREBUILT}" ]]; then
+    ./common/scripts/gobuild.sh out/linux_amd64/docker-builder ./tools/docker-builder
+  fi
+else
+  ./common/scripts/gobuild.sh out/linux_amd64/docker-builder ./tools/docker-builder
+fi
+out/linux_amd64/docker-builder "$@"
diff --git a/tools/docker-builder/main.go b/tools/docker-builder/main.go
new file mode 100644
index 0000000000..ac241e483c
--- /dev/null
+++ b/tools/docker-builder/main.go
@@ -0,0 +1,338 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"encoding/json"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"path"
+	"path/filepath"
+	"strings"
+
+	"github.com/spf13/cobra"
+
+	"istio.io/istio/pilot/pkg/util/sets"
+	testenv "istio.io/istio/pkg/test/env"
+	"istio.io/pkg/log"
+	pkgversion "istio.io/pkg/version"
+)
+
+func main() {
+	rootCmd.Flags().StringVar(&args.Hub, "hub", args.Hub, "docker hub")
+	rootCmd.Flags().StringVar(&args.Tag, "tag", args.Tag, "docker tag")
+
+	rootCmd.Flags().StringVar(&args.BaseVersion, "base-version", args.BaseVersion, "base version to use")
+	rootCmd.Flags().StringVar(&args.ProxyVersion, "proxy-version", args.ProxyVersion, "proxy version to use")
+	rootCmd.Flags().StringVar(&args.IstioVersion, "istio-version", args.IstioVersion, "istio version to use")
+
+	rootCmd.Flags().StringSliceVar(&args.Targets, "targets", args.Targets, "targets to build")
+	rootCmd.Flags().StringSliceVar(&args.Variants, "variants", args.Variants, "variants to build")
+	rootCmd.Flags().StringSliceVar(&args.Architectures, "architecures", args.Architectures, "architectures to build")
+	rootCmd.Flags().BoolVar(&args.Push, "push", args.Push, "push targets to registry")
+	rootCmd.Flags().BoolVar(&args.Save, "save", args.Save, "save targets to tar.gz")
+	rootCmd.Flags().BoolVar(&args.BuildxEnabled, "buildx", args.BuildxEnabled, "use buildx for builds")
+	rootCmd.Flags().BoolVar(&version, "version", version, "show build version")
+
+	if err := rootCmd.Execute(); err != nil {
+		os.Exit(-1)
+	}
+}
+
+var rootCmd = &cobra.Command{
+	Use:   "",
+	Short: "Builds Istio docker images",
+	RunE: func(cmd *cobra.Command, _ []string) error {
+		if version {
+			fmt.Println(pkgversion.Info.GitRevision)
+			os.Exit(0)
+		}
+		log.Infof("Args: %+v", args)
+		if args.Push && args.Save {
+			// TODO(https://github.com/moby/buildkit/issues/1555) support both
+			return fmt.Errorf("--push and --save are mutually exclusive")
+		}
+		_, inCI := os.LookupEnv("CI")
+		if (args.Hub == "docker.io/istio" || args.Hub == "istio" || args.Hub == "gcr.io/istio-release") && !inCI {
+			// Safety check against developer error. If they have a legitimate use case, they can set CI var
+			return fmt.Errorf("pushing to official registry only supported in CI")
+		}
+
+		tarFiles, err := ConstructBakeFile(args)
+		if err != nil {
+			return err
+		}
+		targets := []string{}
+		for _, t := range args.Targets {
+			targets = append(targets, fmt.Sprintf("docker.%s", t))
+		}
+		if err := RunMake(args, targets...); err != nil {
+			return err
+		}
+		if err := RunBake(args); err != nil {
+			return err
+		}
+		if err := RunSave(args, tarFiles); err != nil {
+			return err
+		}
+
+		return nil
+	},
+}
+
+func RunBake(args Args) error {
+	out := filepath.Join(testenv.LocalOut, "dockerx_build", "docker-bake.json")
+	_ = os.MkdirAll(filepath.Join(testenv.LocalOut, "release", "docker"), 0o755)
+	if err := createBuildxBuilderIfNeeded(args); err != nil {
+		return err
+	}
+	c := VerboseCommand("docker", "buildx", "bake", "-f", out, "all")
+	c.Stdout = os.Stdout
+	return c.Run()
+}
+
+// --save requires a custom builder. Automagically create it if needed
+func createBuildxBuilderIfNeeded(a Args) error {
+	if !a.Save {
+		return nil
+	}
+	if _, f := os.LookupEnv("CI"); !f {
+		// For now only do this for CI, we do not want to mess with users config. And users rarely use --save
+		return nil
+	}
+	return exec.Command("sh", "-c", `
+export DOCKER_CLI_EXPERIMENTAL=enabled
+if ! docker buildx ls | grep -q container-builder; then
+  docker buildx create --driver-opt network=host,image=gcr.io/istio-testing/buildkit:v0.8.3 --name container-builder --buildkitd-flags="--debug"
+  # Pre-warm the builder. If it fails, fetch logs, but continue
+  docker buildx inspect --bootstrap container-builder || docker logs buildx_buildkit_container-builder0 || true
+fi
+docker buildx use container-builder`).Run()
+}
+
+// RunSave handles the --save portion. Part of this is done by buildx natively - it will emit .tar
+// files. We need tar.gz though, so we have a bit more work to do
+func RunSave(a Args, files map[string]string) error {
+	if !a.Save {
+		return nil
+	}
+
+	root := filepath.Join(testenv.LocalOut, "release", "docker")
+	for name, alias := range files {
+		// Gzip the file
+		if err := VerboseCommand("gzip", "--fast", "--force", filepath.Join(root, name+".tar")).Run(); err != nil {
+			return err
+		}
+		// If it has an alias (ie pilot-debug -> pilot), copy it over. Copy after gzip to avoid double compute.
+		if alias != "" {
+			if err := CopyFile(filepath.Join(root, name+".tar.gz"), filepath.Join(root, alias+".tar.gz")); err != nil {
+				return err
+			}
+		}
+	}
+
+	return nil
+}
+
+func CopyFile(src, dst string) error {
+	log.Infof("Copying %v -> %v", src, dst)
+	in, err := os.Open(src)
+	if err != nil {
+		return fmt.Errorf("failed to open file %v to copy: %v", src, err)
+	}
+	defer in.Close()
+
+	if err := os.MkdirAll(path.Join(dst, ".."), 0o750); err != nil {
+		return fmt.Errorf("failed to make destination directory %v: %v", dst, err)
+	}
+	out, err := os.Create(dst)
+	if err != nil {
+		return fmt.Errorf("failed to create file %v to copy to: %v", dst, err)
+	}
+	defer out.Close()
+
+	if _, err = io.Copy(out, in); err != nil {
+		return fmt.Errorf("failed to copy %v to %v: %v", src, dst, err)
+	}
+
+	return nil
+}
+
+func sp(s string) *string {
+	return &s
+}
+
+// ConstructBakeFile constructs a docker-bake.json to be passed to `docker buildx bake`.
+// This command is an extremely powerful command to build many images in parallel, but is pretty undocumented.
+// Most info can be found from the source at https://github.com/docker/buildx/blob/master/bake/bake.go.
+func ConstructBakeFile(a Args) (map[string]string, error) {
+	// Targets defines all images we are actually going to build
+	targets := map[string]Target{}
+	// Groups just bundles targets together to make them easier to work with
+	groups := map[string]Group{}
+
+	variants := sets.NewSet(a.Variants...)
+	// hasDoubleDefault checks if we defined both DefaultVariant and PrimaryVariant. If we did, these
+	// are the same exact docker build, just requesting different tags. As an optimization, and to ensure
+	// byte-for-byte identical images, we will collapse these into a single build with multiple tags.
+	hasDoubleDefault := variants.Contains(DefaultVariant) && variants.Contains(PrimaryVariant)
+
+	allGroups := sets.NewSet()
+	// Tar files builds a mapping of tar file name (when used with --save) -> alias for that
+	// If the value is "", the tar file exists but has no aliases
+	tarFiles := map[string]string{}
+	for _, variant := range a.Variants {
+		for _, target := range a.Targets {
+			if variant == DefaultVariant && hasDoubleDefault {
+				// This will be process by the PrimaryVariant, skip it here
+				continue
+			}
+
+			baseDist := variant
+			if baseDist == DefaultVariant {
+				baseDist = PrimaryVariant
+			}
+
+			// These images do not actually use distroless even when specified. So skip to avoid extra building
+			if strings.HasPrefix(target, "app_") && variant == DistrolessVariant {
+				continue
+			}
+			p := filepath.Join(testenv.LocalOut, "dockerx_build", fmt.Sprintf("docker.%s", target))
+			t := Target{
+				Context:    sp(p),
+				Dockerfile: sp(fmt.Sprintf("Dockerfile.%s", target)),
+				Args: map[string]string{
+					// Base version defines the tag of the base image to use. Typically, set in the Makefile and not overridden.
+					"BASE_VERSION": args.BaseVersion,
+					// Base distribution picks which variant to build
+					"BASE_DISTRIBUTION": baseDist,
+					// Additional metadata injected into some images
+					"proxy_version":    args.ProxyVersion,
+					"istio_version":    args.IstioVersion,
+					"VM_IMAGE_NAME":    vmImageName(target),
+					"VM_IMAGE_VERSION": vmImageVersion(target),
+				},
+				Platforms: args.Architectures,
+			}
+
+			if variant == DefaultVariant {
+				// For default, we have no suffix
+				t.Tags = []string{fmt.Sprintf("%s/%s:%s", a.Hub, target, a.Tag)}
+			} else {
+				// Otherwise, we have a suffix with the variant
+				t.Tags = []string{fmt.Sprintf("%s/%s:%s-%s", a.Hub, target, a.Tag, variant)}
+				// If we need a default as well, add it as a second tag for the same image to avoid building twice
+				if variant == PrimaryVariant && hasDoubleDefault {
+					t.Tags = append(t.Tags, fmt.Sprintf("%s/%s:%s", a.Hub, target, a.Tag))
+				}
+			}
+
+			// See https://docs.docker.com/engine/reference/commandline/buildx_build/#output
+			if args.Push {
+				t.Outputs = []string{"type=registry"}
+			} else if args.Save {
+				n := target
+				if variant != "" {
+					n += "-" + variant
+				}
+
+				tarFiles[n] = ""
+				if variant == PrimaryVariant && hasDoubleDefault {
+					tarFiles[n] = target
+				}
+				t.Outputs = []string{"type=docker,dest=" + filepath.Join(testenv.LocalOut, "release", "docker", n+".tar")}
+			} else {
+				t.Outputs = []string{"type=docker"}
+			}
+
+			name := fmt.Sprintf("%s-%s", target, variant)
+			targets[name] = t
+			tgts := groups[variant].Targets
+			tgts = append(tgts, name)
+			groups[variant] = Group{tgts}
+
+			allGroups.Insert(variant)
+		}
+	}
+	groups["all"] = Group{allGroups.SortedList()}
+	bf := BakeFile{
+		Target: targets,
+		Group:  groups,
+	}
+	out := filepath.Join(testenv.LocalOut, "dockerx_build", "docker-bake.json")
+	j, err := json.MarshalIndent(bf, "", "  ")
+	if err != nil {
+		return nil, err
+	}
+	_ = os.MkdirAll(filepath.Join(testenv.LocalOut, "dockerx_build"), 0o755)
+	return tarFiles, os.WriteFile(out, j, 0o644)
+}
+
+func vmImageName(target string) string {
+	if !strings.HasPrefix(target, "app_sidecar") {
+		// Not a VM
+		return ""
+	}
+	return strings.Split(target, "_")[2]
+}
+
+func vmImageVersion(target string) string {
+	if !strings.HasPrefix(target, "app_sidecar") {
+		// Not a VM
+		return ""
+	}
+	return strings.Split(target, "_")[3]
+}
+
+// VerboseCommand runs a command, outputting stderr and stdout
+func VerboseCommand(name string, arg ...string) *exec.Cmd {
+	log.Infof("Running command: %v %v", name, strings.Join(arg, " "))
+	cmd := exec.Command(name, arg...)
+	cmd.Stderr = os.Stderr
+	cmd.Stdout = os.Stdout
+	return cmd
+}
+
+func StandardEnv(args Args) []string {
+	env := os.Environ()
+	if len(sets.NewSet(args.Targets...).Delete("proxyv2")) <= 1 {
+		// If we are building multiple, it is faster to build all binaries in a single invocation
+		// Otherwise, build just the single item. proxyv2 is special since it is always built separately with tag=agent.
+		// Ideally we would just always build the targets we need but our Makefile is not that smart
+		env = append(env, "BUILD_ALL=false")
+	}
+
+	env = append(env,
+		// Build should already run in container, having multiple layers of docker causes issues
+		"BUILD_WITH_CONTAINER=0",
+		// Overwrite rules for buildx
+		"DOCKER_RULE=./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@",
+		"RENAME_TEMPLATE=mkdir -p $(DOCKERX_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKERX_BUILD_TOP)/$@/Dockerfile$(suffix $@)",
+	)
+	return env
+}
+
+// RunMake runs a make command for the repo, with standard environment variables set
+func RunMake(args Args, c ...string) error {
+	cmd := VerboseCommand("make", c...)
+	cmd.Env = StandardEnv(args)
+	cmd.Stderr = os.Stderr
+	cmd.Stdout = os.Stdout
+	cmd.Dir = testenv.IstioSrc
+	log.Infof("Running make %v", strings.Join(c, " "))
+	return cmd.Run()
+}
diff --git a/tools/docker-builder/types.go b/tools/docker-builder/types.go
new file mode 100644
index 0000000000..4c7768be53
--- /dev/null
+++ b/tools/docker-builder/types.go
@@ -0,0 +1,193 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"regexp"
+	"strings"
+
+	"k8s.io/utils/env"
+
+	"istio.io/istio/pilot/pkg/util/sets"
+	testenv "istio.io/istio/pkg/test/env"
+	"istio.io/pkg/log"
+)
+
+// Types mirrored from https://github.com/docker/buildx/blob/master/bake/bake.go
+type Group struct {
+	Targets []string `json:"targets" hcl:"targets"`
+}
+
+type BakeFile struct {
+	Target map[string]Target `json:"target,omitempty"`
+	Group  map[string]Group  `json:"group,omitempty"`
+}
+
+type Target struct {
+	Context          *string           `json:"context,omitempty" hcl:"context,optional"`
+	Dockerfile       *string           `json:"dockerfile,omitempty" hcl:"dockerfile,optional"`
+	DockerfileInline *string           `json:"dockerfile-inline,omitempty" hcl:"dockerfile-inline,optional"`
+	Args             map[string]string `json:"args,omitempty" hcl:"args,optional"`
+	Labels           map[string]string `json:"labels,omitempty" hcl:"labels,optional"`
+	Tags             []string          `json:"tags,omitempty" hcl:"tags,optional"`
+	CacheFrom        []string          `json:"cache-from,omitempty"  hcl:"cache-from,optional"`
+	CacheTo          []string          `json:"cache-to,omitempty"  hcl:"cache-to,optional"`
+	Target           *string           `json:"target,omitempty" hcl:"target,optional"`
+	Secrets          []string          `json:"secret,omitempty" hcl:"secret,optional"`
+	SSH              []string          `json:"ssh,omitempty" hcl:"ssh,optional"`
+	Platforms        []string          `json:"platforms,omitempty" hcl:"platforms,optional"`
+	Outputs          []string          `json:"output,omitempty" hcl:"output,optional"`
+	Pull             *bool             `json:"pull,omitempty" hcl:"pull,optional"`
+	NoCache          *bool             `json:"no-cache,omitempty" hcl:"no-cache,optional"`
+}
+
+type Args struct {
+	Push          bool
+	Save          bool
+	BuildxEnabled bool
+	Targets       []string
+	Variants      []string
+	Architectures []string
+	BaseVersion   string
+	ProxyVersion  string
+	IstioVersion  string
+	Tag           string
+	Hub           string
+}
+
+// Define variants, which control the base image of an image.
+// Tags will have the variant append (like 1.0-distroless).
+// The DefaultVariant is a special variant that has no explicit tag (like 1.0); it
+// is not a unique variant though. Currently, it represents DebugVariant.
+// If both DebugVariant and DefaultVariant are built, there will be a single build but multiple tags
+const (
+	// PrimaryVariant is the variant that DefaultVariant actually builds
+	PrimaryVariant = DebugVariant
+
+	DefaultVariant    = "default"
+	DebugVariant      = "debug"
+	DistrolessVariant = "distroless"
+)
+
+func DefaultArgs() Args {
+	// By default, we build all targets
+	targets := []string{
+		"pilot",
+		"proxyv2",
+		"app",
+		"istioctl",
+		"operator",
+		"install-cni",
+
+		"app_sidecar_ubuntu_xenial",
+		"app_sidecar_ubuntu_bionic",
+		"app_sidecar_ubuntu_focal",
+		"app_sidecar_debian_9",
+		"app_sidecar_debian_10",
+		"app_sidecar_centos_8",
+		"app_sidecar_centos_7",
+	}
+	if legacy, f := os.LookupEnv("DOCKER_TARGETS"); f {
+		// Allow env var config. It is a string separated list like "docker.pilot docker.proxy"
+		targets = []string{}
+		for _, v := range strings.Split(legacy, " ") {
+			if v == "" {
+				continue
+			}
+			targets = append(targets, strings.TrimPrefix(v, "docker."))
+		}
+	}
+	pv, err := testenv.ReadProxySHA()
+	if err != nil {
+		log.Warnf("failed to read proxy sha")
+		pv = "unknown"
+	}
+	variants := []string{DefaultVariant}
+	if legacy, f := os.LookupEnv("DOCKER_BUILD_VARIANTS"); f {
+		variants = strings.Split(legacy, " ")
+	}
+
+	if os.Getenv("INCLUDE_UNTAGGED_DEFAULT") == "true" {
+		// This legacy env var was to workaround the old build logic not being very smart
+		// In the new builder, we automagically detect this. So just insert the 'default' variant
+		cur := sets.NewSet(variants...)
+		cur.Insert(DefaultVariant)
+		variants = cur.SortedList()
+	}
+
+	arch := []string{"linux/amd64"}
+	if legacy, f := os.LookupEnv("DOCKER_ARCHITECTURES"); f {
+		arch = strings.Split(legacy, ",")
+	}
+	return Args{
+		Push:          false,
+		Save:          false,
+		BuildxEnabled: true,
+		Hub:           env.GetString("HUB", "localhost:5000"),
+		Tag:           env.GetString("TAG", "latest"),
+		BaseVersion:   fetchBaseVersion(),
+		IstioVersion:  fetchIstioVersion(),
+		ProxyVersion:  pv,
+		Architectures: arch,
+		Targets:       targets,
+		Variants:      variants,
+	}
+}
+
+var (
+	args    = DefaultArgs()
+	version = false
+)
+
+var baseVersionRegexp = regexp.MustCompile(`BASE_VERSION \?= (.*)`)
+
+func fetchBaseVersion() string {
+	if b, f := os.LookupEnv("BASE_VERSION"); f {
+		return b
+	}
+	b, err := ioutil.ReadFile(filepath.Join(testenv.IstioSrc, "Makefile.core.mk"))
+	if err != nil {
+		log.Fatalf("failed to read file: %v", err)
+		return "unknown"
+	}
+	match := baseVersionRegexp.FindSubmatch(b)
+	if len(match) < 2 {
+		log.Fatalf("failed to find match")
+		return "unknown"
+	}
+	return string(match[1])
+}
+
+var istioVersionRegexp = regexp.MustCompile(`VERSION \?= (.*)`)
+
+func fetchIstioVersion() string {
+	if b, f := os.LookupEnv("VERSION"); f {
+		return b
+	}
+	b, err := ioutil.ReadFile(filepath.Join(testenv.IstioSrc, "Makefile.core.mk"))
+	if err != nil {
+		log.Fatalf("failed to read file: %v", err)
+		return "unknown"
+	}
+	match := istioVersionRegexp.FindSubmatch(b)
+	if len(match) < 2 {
+		log.Fatalf("failed to find match")
+		return "unknown"
+	}
+	return string(match[1])
+}
diff --git a/tools/docker-copy.sh b/tools/docker-copy.sh
index b6c945e064..5c1d1a60ce 100755
--- a/tools/docker-copy.sh
+++ b/tools/docker-copy.sh
@@ -41,7 +41,7 @@ function may_copy_into_arch_named_sub_dir() {
       *aarch64*)
         mkdir -p "${DOCKER_WORKING_DIR}/arm64/" && cp -rp "${FILE}" "${DOCKER_WORKING_DIR}/arm64/"
         ;;
-        *)
+      *)
         cp -rp "${FILE}" "${DOCKER_WORKING_DIR}"
         ;;
     esac
@@ -66,9 +66,7 @@ function may_copy_into_arch_named_sub_dir() {
   fi
 }
 
-
+mkdir -p "${DOCKER_WORKING_DIR}"
 for FILE in "${FILES[@]}"; do
   may_copy_into_arch_named_sub_dir "${FILE}"
 done
-
-ls "${DOCKER_WORKING_DIR}";
\ No newline at end of file
diff --git a/tools/istio-docker.mk b/tools/istio-docker.mk
index 6f67905211..83f1cca85d 100644
--- a/tools/istio-docker.mk
+++ b/tools/istio-docker.mk
@@ -17,8 +17,11 @@
 .PHONY: docker.save
 .PHONY: docker.push
 
+DOCKER_V2_BUILDER ?= true
+
 # Docker target will build the go binaries and package the docker for local testing.
 # It does not upload to a registry.
+
 docker: docker.all
 
 # Add new docker targets to the end of the DOCKER_TARGETS list.
@@ -105,6 +108,14 @@ docker.pilot: $(ISTIO_OUT_LINUX)/pilot-discovery
 docker.pilot: pilot/docker/Dockerfile.pilot
 	$(DOCKER_RULE)
 
+docker.pilot2: BUILD_PRE=&& chmod 644 envoy_bootstrap.json gcp_envoy_bootstrap.json
+docker.pilot2: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
+docker.pilot2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/envoy_bootstrap.json
+docker.pilot2: ${ISTIO_ENVOY_BOOTSTRAP_CONFIG_DIR}/gcp_envoy_bootstrap.json
+docker.pilot2: $(ISTIO_OUT_LINUX)/pilot-discovery
+docker.pilot2: pilot/docker/Dockerfile.pilot
+	@$(DOCKER_BUILDER_RULE)
+
 # Test application
 docker.app: BUILD_PRE=
 docker.app: BUILD_ARGS=--build-arg BASE_VERSION=${BASE_VERSION}
@@ -225,6 +236,10 @@ DOCKER_ARCHITECTURES ?= linux/amd64
 # We then override the docker rule and "build" all of these, where building just copies the dependencies
 # We then generate a "bake" file, which defines all of the docker files in the repo
 # Finally, we call `docker buildx bake` to generate the images.
+ifeq ($(DOCKER_V2_BUILDER), true)
+dockerx:
+	./tools/docker --push=$(or $(DOCKERX_PUSH),$(DOCKERX_PUSH),false)
+else
 dockerx: DOCKER_RULE?=mkdir -p $(DOCKERX_BUILD_TOP)/$@ && TARGET_ARCH=$(TARGET_ARCH) ./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@ && cd $(DOCKERX_BUILD_TOP)/$@ $(BUILD_PRE)
 dockerx: RENAME_TEMPLATE?=mkdir -p $(DOCKERX_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKERX_BUILD_TOP)/$@/Dockerfile$(suffix $@)
 dockerx: docker | $(ISTIO_DOCKER_TAR)
@@ -243,6 +258,7 @@ dockerx:
 	@# Retry works around https://github.com/docker/buildx/issues/298
 	DOCKER_CLI_EXPERIMENTAL=enabled bin/retry.sh "read: connection reset by peer" docker buildx bake $(BUILDX_BAKE_EXTRA_OPTIONS) -f $(DOCKERX_BUILD_TOP)/docker-bake.hcl $(or $(DOCKER_BUILD_VARIANTS),default) || \
 		{ tools/dump-docker-logs.sh; exit 1; }
+endif
 
 # Support individual images like `dockerx.pilot`
 dockerx.%:
@@ -324,11 +340,17 @@ DOCKER_ALL_VARIANTS ?= debug distroless
 INCLUDE_UNTAGGED_DEFAULT ?= false
 DEFAULT_DISTRIBUTION=debug
 DOCKER_RULE ?= $(foreach VARIANT,$(DOCKER_BUILD_VARIANTS), time (mkdir -p $(DOCKER_BUILD_TOP)/$@ && TARGET_ARCH=$(TARGET_ARCH) ./tools/docker-copy.sh $^ $(DOCKER_BUILD_TOP)/$@ && cd $(DOCKER_BUILD_TOP)/$@ $(BUILD_PRE) && docker build $(BUILD_ARGS) --build-arg BASE_DISTRIBUTION=$(call normalize-tag,$(VARIANT)) -t $(HUB)/$(subst docker.,,$@):$(TAG)$(call variant-tag,$(VARIANT)) -f Dockerfile$(suffix $@) . ); )
+DOCKER_BUILDER_RULE ?= ./tools/docker-copy.sh $^ $(DOCKERX_BUILD_TOP)/$@
 RENAME_TEMPLATE ?= mkdir -p $(DOCKER_BUILD_TOP)/$@ && cp $(ECHO_DOCKER)/$(VM_OS_DOCKERFILE_TEMPLATE) $(DOCKER_BUILD_TOP)/$@/Dockerfile$(suffix $@)
 
 # This target will package all docker images used in test and release, without re-building
 # go binaries. It is intended for CI/CD systems where the build is done in separate job.
+ifeq ($(DOCKER_V2_BUILDER), true)
+docker.all:
+	./tools/docker
+else
 docker.all: $(DOCKER_TARGETS)
+endif
 
 # for each docker.XXX target create a tar.docker.XXX target that says how
 # to make a $(ISTIO_OUT_LINUX)/docker/XXX.tar.gz from the docker XXX image
@@ -347,6 +369,10 @@ $(foreach TGT,$(DOCKER_TARGETS),$(eval tar.$(TGT): $(TGT) | $(ISTIO_DOCKER_TAR)
 $(foreach TGT,$(DOCKER_TARGETS),$(eval DOCKER_TAR_TARGETS+=tar.$(TGT)))
 
 # this target saves a tar.gz of each docker image to ${ISTIO_OUT_LINUX}/docker/
+ifeq ($(DOCKER_V2_BUILDER), true)
+dockerx.save:
+	./tools/docker --save
+else
 dockerx.save: dockerx $(ISTIO_DOCKER_TAR)
 	$(foreach TGT,$(DOCKER_TARGETS), \
 	$(foreach VARIANT,$(DOCKER_BUILD_VARIANTS) default, \
@@ -358,6 +384,7 @@ dockerx.save: dockerx $(ISTIO_DOCKER_TAR)
 	   ); \
 	   fi; \
 	 ))
+endif
 
 docker.save: dockerx.save
 
@@ -378,13 +405,25 @@ DOCKER_PUSH_TARGETS:=
 $(foreach TGT,$(DOCKER_TARGETS),$(eval DOCKER_PUSH_TARGETS+=push.$(TGT)))
 
 # Will build and push docker images.
+ifeq ($(DOCKER_V2_BUILDER), true)
+docker.push: DOCKERX_PUSH=true
+docker.push: dockerx
+	:
+else
 docker.push: $(DOCKER_PUSH_TARGETS)
+endif
 
 # Build and push docker images using dockerx
+ifeq ($(DOCKER_V2_BUILDER), true)
+dockerx.push: DOCKERX_PUSH=true
+dockerx.push: dockerx
+	:
+else
 dockerx.push: dockerx
 	$(foreach TGT,$(DOCKER_TARGETS), time ( \
 		set -e && for distro in $(DOCKER_BUILD_VARIANTS); do tag=$(TAG)-$${distro}; docker push $(HUB)/$(subst docker.,,$(TGT)):$${tag%-default}; done); \
 	)
+endif
 
 # Build and push docker images using dockerx. Pushing is done inline as an optimization
 # This is not done in the dockerx.push target because it requires using the docker-container driver.
-- 
2.35.3

