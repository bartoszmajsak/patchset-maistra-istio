From f8612d82a52895f3ab94abc9a3d5f72499218c30 Mon Sep 17 00:00:00 2001
From: Costin Manolache <costin@gmail.com>
Date: Tue, 8 Mar 2022 10:48:42 -0800
Subject: add RBAC support to proxyless gRPC (#37076)

* Add RBAC support for proxyless grpc

Change-Id: I78d72ed96d559645e8b59f272c80c25ad13b9696

* Minor refactoring of the test

Change-Id: Idc2bad396aa9fb5d77716dcc7272c07b406086e4

* Use unique names

Change-Id: I36854fa6245b6c674b96cbef9eb9e6106f3cc217

* Update grpc after merge

Change-Id: I35ba19c01d28066dee3fa756abb942f0eb2d8493

* Fix merge

Change-Id: Ia6d7d2fa54f6bcea0d6985ce36cb51e4ba77f752

* Lints

Change-Id: Ib072e7a9b3544b70fc1456c0c4557702019495f1

* gen

Change-Id: Ia254fe33a7f80cd1c620d8b1dab06f73263985ea

Co-authored-by: Costin Manolache <costin@google.com>
---
 pilot/pkg/networking/grpcgen/grpcecho_test.go |  15 +-
 pilot/pkg/networking/grpcgen/grpcgen_test.go  | 377 +++++++++++++-----
 pilot/pkg/networking/grpcgen/lds.go           |  88 +++-
 .../grpcgen/testdata/xds_bootstrap.json       |  24 +-
 pilot/pkg/serviceregistry/memory/discovery.go |   3 +-
 pkg/test/echo/server/endpoint/grpc.go         |   8 +-
 6 files changed, 402 insertions(+), 113 deletions(-)

diff --git a/pilot/pkg/networking/grpcgen/grpcecho_test.go b/pilot/pkg/networking/grpcgen/grpcecho_test.go
index 136dc1cc7e..9205893366 100644
--- a/pilot/pkg/networking/grpcgen/grpcecho_test.go
+++ b/pilot/pkg/networking/grpcgen/grpcecho_test.go
@@ -90,12 +90,7 @@ func newConfigGenTest(t *testing.T, discoveryOpts xds.FakeOptions, servers ...ec
 			s.namespace = "default"
 		}
 		// TODO this breaks without extra ifonfig aliases on OSX, and probably elsewhere
-		host := fmt.Sprintf("127.0.0.%d", i+1)
-		nodeID := fmt.Sprintf("sidecar~%s~echo-%s.%s~cluster.local", host, s.version, s.namespace)
-		bootstrapBytes, err := bootstrapForTest(nodeID, s.namespace, xdsPort)
-		if err != nil {
-			t.Fatal(err)
-		}
+		ip := fmt.Sprintf("127.0.0.%d", i+1)
 
 		ep, err := endpoint.New(endpoint.Config{
 			Port: &common.Port{
@@ -104,9 +99,9 @@ func newConfigGenTest(t *testing.T, discoveryOpts xds.FakeOptions, servers ...ec
 				Protocol:         protocol.GRPC,
 				XDSServer:        true,
 				XDSReadinessTLS:  s.tls,
-				XDSTestBootstrap: bootstrapBytes,
+				XDSTestBootstrap: GRPCBootstrap("echo-"+s.version, s.namespace, ip, xdsPort),
 			},
-			ListenerIP: host,
+			ListenerIP: ip,
 			Version:    s.version,
 		})
 		if err != nil {
@@ -119,11 +114,11 @@ func newConfigGenTest(t *testing.T, discoveryOpts xds.FakeOptions, servers ...ec
 			t.Fatal(err)
 		}
 
-		cfgs = append(cfgs, makeWE(s, host, ep.GetConfig().Port.Port))
+		cfgs = append(cfgs, makeWE(s, ip, ep.GetConfig().Port.Port))
 		cgt.endpoints = append(cgt.endpoints, ep)
 		t.Cleanup(func() {
 			if err := ep.Close(); err != nil {
-				t.Errorf("failed to close endpoint %s: %v", host, err)
+				t.Errorf("failed to close endpoint %s: %v", ip, err)
 			}
 		})
 	}
diff --git a/pilot/pkg/networking/grpcgen/grpcgen_test.go b/pilot/pkg/networking/grpcgen/grpcgen_test.go
index c4d19bfe34..0bf0cdd3d5 100644
--- a/pilot/pkg/networking/grpcgen/grpcgen_test.go
+++ b/pilot/pkg/networking/grpcgen/grpcgen_test.go
@@ -27,21 +27,31 @@
 
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 	"google.golang.org/grpc"
-	"google.golang.org/grpc/balancer"
+	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/credentials/insecure"
+	xdscreds "google.golang.org/grpc/credentials/xds"
+	"google.golang.org/grpc/metadata"
 	"google.golang.org/grpc/resolver"
 	"google.golang.org/grpc/serviceconfig"
+	"google.golang.org/grpc/status"
 
 	// To install the xds resolvers and balancers.
-	grpcxdsresolver "google.golang.org/grpc/xds"
+	xdsgrpc "google.golang.org/grpc/xds"
 
 	networking "istio.io/api/networking/v1alpha3"
+	security "istio.io/api/security/v1beta1"
 	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/memory"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/istio-agent/grpcxds"
 	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/echo/common"
+	echoproto "istio.io/istio/pkg/test/echo/proto"
+	"istio.io/istio/pkg/test/echo/server/endpoint"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/pkg/log"
 )
@@ -49,7 +59,30 @@
 // Address of the Istiod gRPC service, used in tests.
 var istiodSvcHost = "istiod.istio-system.svc.cluster.local"
 
-func bootstrapForTest(nodeID, namespace string, port int) ([]byte, error) {
+// Local integration tests for proxyless gRPC.
+// The tests will start an in-process Istiod, using the memory store, and use
+// proxyless grpc servers and clients to validate the config generation.
+// GRPC project has more extensive tests for each language, we mainly verify that Istiod
+// generates the expected XDS, and gRPC tests verify that the XDS is correctly interpreted.
+//
+// To debug, set GRPC_GO_LOG_SEVERITY_LEVEL=info;GRPC_GO_LOG_VERBOSITY_LEVEL=99 for
+// verbose logs from gRPC side.
+
+// GRPCBootstrap creates the bootstrap bytes dynamically.
+// This can be used with NewXDSResolverWithConfigForTesting, and used when creating clients.
+//
+// See pkg/istio-agent/testdata/grpc-bootstrap.json for a sample bootstrap as expected by Istio agent.
+func GRPCBootstrap(app, namespace, ip string, xdsPort int) []byte {
+	if ip == "" {
+		ip = "127.0.0.1"
+	}
+	if namespace == "" {
+		namespace = "default"
+	}
+	if app == "" {
+		app = "app"
+	}
+	nodeID := "sidecar~" + ip + "~" + app + "." + namespace + "~" + namespace + ".svc.cluster.local"
 	bootstrap, err := grpcxds.GenerateBootstrap(grpcxds.GenerateBootstrapOptions{
 		Node: &model.Node{
 			ID: nodeID,
@@ -61,25 +94,23 @@ func bootstrapForTest(nodeID, namespace string, port int) ([]byte, error) {
 				},
 			},
 		},
-		DiscoveryAddress: fmt.Sprintf("127.0.0.1:%d", port),
+		DiscoveryAddress: fmt.Sprintf("127.0.0.1:%d", xdsPort),
 		CertDir:          path.Join(env.IstioSrc, "tests/testdata/certs/default"),
 	})
 	if err != nil {
-		return nil, fmt.Errorf("failed generating bootstrap: %v", err)
+		return []byte{}
 	}
 	bootstrapBytes, err := json.Marshal(bootstrap)
 	if err != nil {
-		return nil, fmt.Errorf("failed marshaling bootstrap: %v", err)
+		return []byte{}
 	}
-	return bootstrapBytes, nil
+	return bootstrapBytes
 }
 
-func resolverForTest(t test.Failer, port int, ns string) resolver.Builder {
-	bootstrap, err := bootstrapForTest("sidecar~10.0.0.1~foo."+ns+"~"+ns+".svc.cluster.local", ns, port)
-	if err != nil {
-		t.Fatal(err)
-	}
-	xdsresolver, err := grpcxdsresolver.NewXDSResolverWithConfigForTesting(bootstrap)
+// resolverForTest creates a resolver for xds:// names using dynamic bootstrap.
+func resolverForTest(t test.Failer, xdsPort int, ns string) resolver.Builder {
+	xdsresolver, err := xdsgrpc.NewXDSResolverWithConfigForTesting(
+		GRPCBootstrap("foo", ns, "10.0.0.1", xdsPort))
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -94,56 +125,21 @@ func init() {
 }
 
 func TestGRPC(t *testing.T) {
+	// Init Istiod in-process server.
 	ds := xds.NewXDS(make(chan struct{}))
-
 	sd := ds.DiscoveryServer.MemRegistry
 	sd.ClusterID = "Kubernetes"
-	sd.AddHTTPService("fortio1.fortio.svc.cluster.local", "10.10.10.1", 8081)
 
-	se := collections.IstioNetworkingV1Alpha3Serviceentries.Resource()
-	store := ds.MemoryConfigStore
-
-	store.Create(config.Config{
-		Meta: config.Meta{
-			GroupVersionKind: se.GroupVersionKind(),
-			Name:             "fortio",
-			Namespace:        "fortio",
-		},
-		Spec: &networking.ServiceEntry{
-			Hosts: []string{
-				"fortio.fortio.svc",
-				"fortio.fortio.svc.cluster.local",
-			},
-			Addresses: []string{"1.2.3.4"},
-
-			Ports: []*networking.Port{
-				{Number: 14057, Name: "grpc-insecure", Protocol: "http"},
-			},
-
-			Endpoints: []*networking.WorkloadEntry{
-				{
-					Address: "127.0.0.1",
-					Ports:   map[string]uint32{"grpc-insecure": 8080},
-				},
-			},
-			Location:   networking.ServiceEntry_MESH_EXTERNAL,
-			Resolution: networking.ServiceEntry_STATIC,
-		},
-	})
-
-	_, _ = store.Create(config.Config{
-		Meta: config.Meta{
-			GroupVersionKind: collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
-			Name:             "mtls",
-			Namespace:        "istio-system",
-		},
-		Spec: &networking.DestinationRule{
-			Host: istiodSvcHost,
-			TrafficPolicy: &networking.TrafficPolicy{Tls: &networking.ClientTLSSettings{
-				Mode: networking.ClientTLSSettings_ISTIO_MUTUAL,
-			}},
-		},
-	})
+	lis, err := net.Listen("tcp", ":0")
+	if err != nil {
+		t.Fatalf("net.Listen failed: %v", err)
+	}
+	lis.Addr()
+	_, ports, _ := net.SplitHostPort(lis.Addr().String())
+	port, _ := strconv.Atoi(ports)
+	// Echo service
+	// initRBACTests(sd, store, "echo-rbac-plain", 14058, false)
+	initRBACTests(sd, ds.MemoryConfigStore, "echo-rbac-mtls", port, true)
 
 	xdsAddr, err := ds.StartGRPC("127.0.0.1:0")
 	if err != nil {
@@ -154,16 +150,7 @@ func TestGRPC(t *testing.T) {
 	_, xdsPorts, _ := net.SplitHostPort(xdsAddr)
 	xdsPort, _ := strconv.Atoi(xdsPorts)
 
-	xdsresolver := resolverForTest(t, xdsPort, "istio-system")
-
-	sd.AddHTTPService(istiodSvcHost, "10.10.10.2", xdsPort)
-	sd.SetEndpoints(istiodSvcHost, "", []*model.IstioEndpoint{
-		{
-			Address:         "127.0.0.1",
-			EndpointPort:    uint32(xdsPort),
-			ServicePortName: "http-main",
-		},
-	})
+	addIstiod(sd, xdsPort)
 
 	env := ds.DiscoveryServer.Env
 	env.Init()
@@ -172,11 +159,21 @@ func TestGRPC(t *testing.T) {
 	}
 	ds.DiscoveryServer.UpdateServiceShards(env.PushContext)
 
+	// Client bootstrap - will show as "foo.clientns"
+	xdsresolver := resolverForTest(t, xdsPort, "clientns")
+
+	// Test the xdsresolver - query LDS and RDS for a specific service, wait for the update.
+	// Should be very fast (~20ms) and validate bootstrap and basic XDS connection.
+	// Unfortunately we have no way to look at the response except using the logs from XDS.
+	// This does not attempt to resolve CDS or EDS.
 	t.Run("gRPC-resolve", func(t *testing.T) {
 		rb := xdsresolver
 		stateCh := &Channel{ch: make(chan interface{}, 1)}
 		errorCh := &Channel{ch: make(chan interface{}, 1)}
-		_, err := rb.Build(resolver.Target{URL: url.URL{Scheme: "xds", Path: "/" + net.JoinHostPort(istiodSvcHost, xdsPorts)}},
+		_, err := rb.Build(resolver.Target{URL: url.URL{
+			Scheme: "xds",
+			Path:   "/" + net.JoinHostPort(istiodSvcHost, xdsPorts),
+		}},
 			&testClientConn{stateCh: stateCh, errorCh: errorCh}, resolver.BuildOptions{})
 		if err != nil {
 			t.Fatal("Failed to resolve XDS ", err)
@@ -192,21 +189,37 @@ func TestGRPC(t *testing.T) {
 		}
 	})
 
-	t.Run("gRPC-cdslb", func(t *testing.T) {
-		rb := balancer.Get("cluster_resolver_experimental")
-		b := rb.Build(&testLBClientConn{}, balancer.BuildOptions{})
-		defer b.Close()
+	t.Run("gRPC-svc", func(t *testing.T) {
+		t.Run("gRPC-svc-tls", func(t *testing.T) {
+			// Replaces: insecure.NewCredentials
+			creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
+			if err != nil {
+				t.Fatal(err)
+			}
+
+			grpcOptions := []grpc.ServerOption{
+				grpc.Creds(creds),
+			}
+
+			bootstrapB := GRPCBootstrap("echo-rbac-mtls", "test", "127.0.1.1", xdsPort)
+			grpcOptions = append(grpcOptions, xdsgrpc.BootstrapContentsForTesting(bootstrapB))
+
+			// Replaces: grpc NewServer
+			grpcServer := xdsgrpc.NewGRPCServer(grpcOptions...)
+
+			testRBAC(t, grpcServer, xdsresolver, "echo-rbac-mtls", port, lis)
+		})
 	})
 
 	t.Run("gRPC-dial", func(t *testing.T) {
 		for _, host := range []string{
 			"istiod.istio-system.svc.cluster.local",
-			"istiod.istio-system.svc",
-			"istiod.istio-system",
-			"istiod",
+			//"istiod.istio-system.svc",
+			//"istiod.istio-system",
+			//"istiod",
 		} {
 			t.Run(host, func(t *testing.T) {
-				ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
+				ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
 				defer cancel()
 				conn, err := grpc.DialContext(ctx, "xds:///"+host+":"+xdsPorts, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock(),
 					grpc.WithResolvers(xdsresolver))
@@ -224,8 +237,196 @@ func TestGRPC(t *testing.T) {
 	})
 }
 
-type testLBClientConn struct {
-	balancer.ClientConn
+func addIstiod(sd *memory.ServiceDiscovery, xdsPort int) {
+	sd.AddService(&model.Service{
+		Attributes: model.ServiceAttributes{
+			Name:      "istiod",
+			Namespace: "istio-system",
+		},
+		Hostname:       host.Name(istiodSvcHost),
+		DefaultAddress: "127.0.1.12",
+		Ports: model.PortList{
+			{
+				Name:     "grpc-main",
+				Port:     xdsPort,
+				Protocol: protocol.GRPC, // SetEndpoints hardcodes this
+			},
+		},
+	})
+	sd.SetEndpoints(istiodSvcHost, "istio-system", []*model.IstioEndpoint{
+		{
+			Address:         "127.0.0.1",
+			EndpointPort:    uint32(xdsPort),
+			ServicePortName: "grpc-main",
+		},
+	})
+}
+
+func initRBACTests(sd *memory.ServiceDiscovery, store model.IstioConfigStore, svcname string, port int, mtls bool) {
+	ns := "test"
+	hn := svcname + "." + ns + ".svc.cluster.local"
+	// The 'memory' store GetProxyServiceInstances uses the IP address of the node and endpoints to
+	// identify the service. In k8s store, labels are matched instead.
+	// For server configs to work, the server XDS bootstrap must match the IP.
+	sd.AddService(&model.Service{
+		// Required: namespace (otherwise DR matching fails)
+		Attributes: model.ServiceAttributes{
+			Name:      svcname,
+			Namespace: ns,
+		},
+		Hostname:       host.Name(hn),
+		DefaultAddress: "127.0.5.1",
+		Ports: model.PortList{
+			{
+				Name:     "grpc-main",
+				Port:     port,
+				Protocol: protocol.GRPC,
+			},
+		},
+	})
+	// The address will be matched against the INSTANCE_IPS and id in the node id. If they match, the service is returned.
+	sd.SetEndpoints(hn, ns, []*model.IstioEndpoint{
+		{
+			Address:         "127.0.1.1",
+			EndpointPort:    uint32(port),
+			ServicePortName: "grpc-main",
+		},
+	})
+
+	store.Create(config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+			Name:             svcname,
+			Namespace:        ns,
+		},
+		Spec: &security.AuthorizationPolicy{
+			Rules: []*security.Rule{
+				{
+					When: []*security.Condition{
+						{
+							Key: "request.headers[echo]",
+							Values: []string{
+								"block",
+							},
+						},
+					},
+				},
+			},
+			Action: security.AuthorizationPolicy_DENY,
+		},
+	})
+
+	store.Create(config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+			Name:             svcname + "-allow",
+			Namespace:        ns,
+		},
+		Spec: &security.AuthorizationPolicy{
+			Rules: []*security.Rule{
+				{
+					When: []*security.Condition{
+						{
+							Key: "request.headers[echo]",
+							Values: []string{
+								"allow",
+							},
+						},
+					},
+				},
+			},
+			Action: security.AuthorizationPolicy_ALLOW,
+		},
+	})
+	if mtls {
+		// Client side.
+		_, _ = store.Create(config.Config{
+			Meta: config.Meta{
+				GroupVersionKind: collections.IstioNetworkingV1Alpha3Destinationrules.Resource().GroupVersionKind(),
+				Name:             svcname,
+				Namespace:        "test",
+			},
+			Spec: &networking.DestinationRule{
+				Host: svcname + ".test.svc.cluster.local",
+				TrafficPolicy: &networking.TrafficPolicy{Tls: &networking.ClientTLSSettings{
+					Mode: networking.ClientTLSSettings_ISTIO_MUTUAL,
+				}},
+			},
+		})
+
+		// Server side.
+		_, _ = store.Create(config.Config{
+			Meta: config.Meta{
+				GroupVersionKind: collections.IstioSecurityV1Beta1Peerauthentications.Resource().GroupVersionKind(),
+				Name:             svcname,
+				Namespace:        "test",
+			},
+			Spec: &security.PeerAuthentication{
+				Mtls: &security.PeerAuthentication_MutualTLS{Mode: security.PeerAuthentication_MutualTLS_STRICT},
+			},
+		})
+
+		_, _ = store.Create(config.Config{
+			Meta: config.Meta{
+				GroupVersionKind: collections.IstioSecurityV1Beta1Authorizationpolicies.Resource().GroupVersionKind(),
+				Name:             svcname,
+				Namespace:        "test",
+			},
+			Spec: &security.AuthorizationPolicy{
+				Rules: []*security.Rule{
+					{
+						From: []*security.Rule_From{
+							{
+								Source: &security.Source{
+									Principals: []string{"evie"},
+								},
+							},
+						},
+					},
+				},
+				Action: security.AuthorizationPolicy_DENY,
+			},
+		})
+	}
+}
+
+func testRBAC(t *testing.T, grpcServer *xdsgrpc.GRPCServer, xdsresolver resolver.Builder, svcname string, port int, lis net.Listener) {
+	echos := &endpoint.EchoGrpcHandler{Config: endpoint.Config{Port: &common.Port{Port: port}}}
+	echoproto.RegisterEchoTestServiceServer(grpcServer, echos)
+
+	go func() {
+		err := grpcServer.Serve(lis)
+		if err != nil {
+			log.Errora(err)
+		}
+	}()
+	time.Sleep(3 * time.Second)
+	ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
+	defer cancel()
+
+	creds, _ := xdscreds.NewClientCredentials(xdscreds.ClientOptions{
+		FallbackCreds: insecure.NewCredentials(),
+	})
+
+	conn, err := grpc.DialContext(ctx, fmt.Sprintf("xds:///%s.test.svc.cluster.local:%d", svcname, port),
+		grpc.WithTransportCredentials(creds),
+		grpc.WithBlock(),
+		grpc.WithResolvers(xdsresolver))
+	if err != nil {
+		t.Fatal("XDS gRPC", err)
+	}
+	defer conn.Close()
+	echoc := echoproto.NewEchoTestServiceClient(conn)
+	md := metadata.New(map[string]string{"echo": "block"})
+	outctx := metadata.NewOutgoingContext(context.Background(), md)
+	_, err = echoc.Echo(outctx, &echoproto.EchoRequest{})
+	if err == nil {
+		t.Fatal("RBAC rule not enforced")
+	}
+	if status.Code(err) != codes.PermissionDenied {
+		t.Fatal("Unexpected error", err)
+	}
+	t.Log(err)
 }
 
 type Channel struct {
@@ -258,14 +459,12 @@ func (t *testClientConn) ReportError(err error) {
 
 func (t *testClientConn) ParseServiceConfig(jsonSC string) *serviceconfig.ParseResult {
 	// Will be called with something like:
-	//
-	//	"loadBalancingConfig":[
-	//	{
-	//		"cds_experimental":{
-	//			"Cluster": "istiod.istio-system.svc.cluster.local:14056"
-	//		}
-	//	}
-	//]
-	//}
+	// {"loadBalancingConfig":[
+	//  {"xds_cluster_manager_experimental":{
+	//     "children":{
+	//        "cluster:outbound|14057||istiod.istio-system.svc.cluster.local":{
+	//           "childPolicy":[
+	//          {"cds_experimental":
+	//         		{"cluster":"outbound|14057||istiod.istio-system.svc.cluster.local"}}]}}}}]}
 	return &serviceconfig.ParseResult{}
 }
diff --git a/pilot/pkg/networking/grpcgen/lds.go b/pilot/pkg/networking/grpcgen/lds.go
index c1a5a06cb0..c0274959f9 100644
--- a/pilot/pkg/networking/grpcgen/lds.go
+++ b/pilot/pkg/networking/grpcgen/lds.go
@@ -22,7 +22,9 @@
 
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	rbacpb "github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3"
 	route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
+	rbachttppb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3"
 	hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
 	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
@@ -32,6 +34,7 @@
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/security/authn"
 	"istio.io/istio/pilot/pkg/security/authn/factory"
+	authzmodel "istio.io/istio/pilot/pkg/security/authz/model"
 	"istio.io/istio/pilot/pkg/util/sets"
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pkg/config/labels"
@@ -43,6 +46,11 @@
 	xdsfilters.Router,
 }
 
+const (
+	RBACHTTPFilterName     = "envoy.filters.http.rbac"
+	RBACHTTPFilterNameDeny = "envoy.filters.http.rbac.DENY"
+)
+
 // BuildListeners handles a LDS request, returning listeners of ApiListener type.
 // The request may include a list of resource names, using the full_hostname[:port] format to select only
 // specific services.
@@ -52,7 +60,7 @@ func (g *GrpcConfigGenerator) BuildListeners(node *model.Proxy, push *model.Push
 	log.Debugf("building lds for %s with filter:\n%v", node.ID, filter)
 
 	resp := make(model.Resources, 0, len(filter))
-	resp = append(resp, buildOutboundListeners(node, filter)...)
+	resp = append(resp, buildOutboundListeners(node, push, filter)...)
 	resp = append(resp, buildInboundListeners(node, push, filter.inboundNames())...)
 
 	return resp
@@ -139,16 +147,48 @@ func buildInboundFilterChains(node *model.Proxy, push *model.PushContext, si *mo
 	var out []*listener.FilterChain
 	switch mode {
 	case model.MTLSDisable:
-		out = append(out, buildInboundFilterChain("plaintext", nil))
+		out = append(out, buildInboundFilterChain(node, push, "plaintext", nil))
 	case model.MTLSStrict:
-		out = append(out, buildInboundFilterChain("mtls", tlsContext))
+		out = append(out, buildInboundFilterChain(node, push, "mtls", tlsContext))
 		// TODO permissive builts both plaintext and mtls; when tlsContext is present add a match for protocol
 	}
 
 	return out
 }
 
-func buildInboundFilterChain(nameSuffix string, tlsContext *tls.DownstreamTlsContext) *listener.FilterChain {
+func buildInboundFilterChain(node *model.Proxy, push *model.PushContext, nameSuffix string, tlsContext *tls.DownstreamTlsContext) *listener.FilterChain {
+	fc := []*hcm.HttpFilter{}
+	// See security/authz/builder and grpc internal/xds/rbac
+	// grpc supports ALLOW and DENY actions (fail if it is not one of them), so we can't use the normal generator
+	policies := push.AuthzPolicies.ListAuthorizationPolicies(node.ConfigNamespace, labels.Collection{node.Metadata.Labels})
+	if len(policies.Deny)+len(policies.Allow) > 0 {
+		rules := buildRBAC(node, push, nameSuffix, tlsContext, rbacpb.RBAC_DENY, policies.Deny)
+		if rules != nil && len(rules.Policies) > 0 {
+			rbac := &rbachttppb.RBAC{
+				Rules: rules,
+			}
+			fc = append(fc,
+				&hcm.HttpFilter{
+					Name:       RBACHTTPFilterNameDeny,
+					ConfigType: &hcm.HttpFilter_TypedConfig{TypedConfig: util.MessageToAny(rbac)},
+				})
+		}
+		arules := buildRBAC(node, push, nameSuffix, tlsContext, rbacpb.RBAC_ALLOW, policies.Allow)
+		if arules != nil && len(arules.Policies) > 0 {
+			rbac := &rbachttppb.RBAC{
+				Rules: arules,
+			}
+			fc = append(fc,
+				&hcm.HttpFilter{
+					Name:       RBACHTTPFilterName,
+					ConfigType: &hcm.HttpFilter_TypedConfig{TypedConfig: util.MessageToAny(rbac)},
+				})
+		}
+	}
+
+	// Must be last
+	fc = append(fc, xdsfilters.Router)
+
 	out := &listener.FilterChain{
 		Name:             "inbound-" + nameSuffix,
 		FilterChainMatch: nil,
@@ -171,7 +211,7 @@ func buildInboundFilterChain(nameSuffix string, tlsContext *tls.DownstreamTlsCon
 							}},
 						},
 					},
-					HttpFilters: []*hcm.HttpFilter{xdsfilters.Router},
+					HttpFilters: fc,
 				}),
 			},
 		}},
@@ -185,7 +225,43 @@ func buildInboundFilterChain(nameSuffix string, tlsContext *tls.DownstreamTlsCon
 	return out
 }
 
-func buildOutboundListeners(node *model.Proxy, filter listenerNames) model.Resources {
+// buildRBAC builds the RBAC config expected by gRPC.
+//
+// See: xds/interal/httpfilter/rbac
+//
+//
+// TODO: gRPC also supports 'per route override' - not yet clear how to use it, Istio uses path expressions instead and we don't generate
+// vhosts or routes for the inbound listener.
+//
+// For gateways it would make a lot of sense to use this concept, same for moving path prefix at top level ( more scalable, easier for users)
+// This should probably be done for the v2 API.
+//
+//
+//
+// nolint: unparam
+func buildRBAC(node *model.Proxy, push *model.PushContext, suffix string, context *tls.DownstreamTlsContext,
+	a rbacpb.RBAC_Action, policies []model.AuthorizationPolicy) *rbacpb.RBAC {
+	rules := &rbacpb.RBAC{
+		Action:   a,
+		Policies: map[string]*rbacpb.Policy{},
+	}
+	for _, policy := range policies {
+		for i, rule := range policy.Spec.Rules {
+			name := fmt.Sprintf("%s-%s-%d", policy.Namespace, policy.Name, i)
+			m, err := authzmodel.New(rule)
+			if err != nil {
+				log.Warn("Invalid rule ", rule, err)
+			}
+			generated, _ := m.Generate(false, a)
+			rules.Policies[name] = generated
+		}
+	}
+
+	return rules
+}
+
+// nolint: unparam
+func buildOutboundListeners(node *model.Proxy, push *model.PushContext, filter listenerNames) model.Resources {
 	out := make(model.Resources, 0, len(filter))
 	for _, sv := range node.SidecarScope.Services() {
 		serviceHost := string(sv.Hostname)
diff --git a/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json b/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
index 0e9c9a49ce..5457e65da6 100644
--- a/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
+++ b/pilot/pkg/networking/grpcgen/testdata/xds_bootstrap.json
@@ -7,10 +7,28 @@
     }
   ],
   "node": {
-    "id": "sidecar~10.0.0.1~foo.default~cluster.local",
+    "id": "sidecar~127.0.1.1~echo.test~cluster.local",
     "metadata": {
+      "INSTANCE_IPS": "127.0.1.1",
+      "PILOT_SAN": [
+        "istiod.istio-system.svc"
+      ],
       "GENERATOR": "grpc",
-      "NAMESPACE": "default"
+      "NAMESPACE": "test"
+    },
+    "localisty": {},
+    "UserAgentVersionType": "istiov1"
+  },
+  "certificate_providers": {
+    "default": {
+      "plugin_name": "file_watcher",
+      "config": {
+        "certificate_file": "../../../../tests/testdata/certs/default/cert-chain.pem",
+        "private_key_file": "../../../../tests/testdata/certs/default/key.pem",
+        "ca_certificate_file": "../../../../tests/testdata/certs/default/root-cert.pem",
+        "refresh_interval": "900s"
+      }
     }
-  }
+  },
+  "server_listener_resource_name_template": "xds.istio.io/grpc/lds/inbound/%s"
 }
diff --git a/pilot/pkg/serviceregistry/memory/discovery.go b/pilot/pkg/serviceregistry/memory/discovery.go
index 1cbeecfcbc..375ba76a49 100644
--- a/pilot/pkg/serviceregistry/memory/discovery.go
+++ b/pilot/pkg/serviceregistry/memory/discovery.go
@@ -185,6 +185,7 @@ func (sd *ServiceDiscovery) SetEndpoints(service string, namespace string, endpo
 	sd.mutex.Lock()
 	svc := sd.services[sh]
 	if svc == nil {
+		sd.mutex.Unlock()
 		return
 	}
 
@@ -214,7 +215,7 @@ func (sd *ServiceDiscovery) SetEndpoints(service string, namespace string, endpo
 			ServicePort: &model.Port{
 				Name:     e.ServicePortName,
 				Port:     p.Port,
-				Protocol: protocol.HTTP,
+				Protocol: p.Protocol,
 			},
 			Endpoint: e,
 		}
diff --git a/pkg/test/echo/server/endpoint/grpc.go b/pkg/test/echo/server/endpoint/grpc.go
index 70bac4867c..d88bc78ae3 100644
--- a/pkg/test/echo/server/endpoint/grpc.go
+++ b/pkg/test/echo/server/endpoint/grpc.go
@@ -120,7 +120,7 @@ func (s *grpcInstance) Start(onReady OnReadyFunc) error {
 	healthServer := health.NewServer()
 	grpcHealth.RegisterHealthServer(s.server, healthServer)
 
-	proto.RegisterEchoTestServiceServer(s.server, &grpcHandler{
+	proto.RegisterEchoTestServiceServer(s.server, &EchoGrpcHandler{
 		Config: s.Config,
 	})
 	reflection.Register(s.server)
@@ -228,12 +228,12 @@ func (s *grpcInstance) Close() error {
 	return nil
 }
 
-type grpcHandler struct {
+type EchoGrpcHandler struct {
 	proto.UnimplementedEchoTestServiceServer
 	Config
 }
 
-func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.EchoResponse, error) {
+func (h *EchoGrpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.EchoResponse, error) {
 	defer common.Metrics.GrpcRequests.With(common.PortLabel.Value(strconv.Itoa(h.Port.Port))).Increment()
 	body := bytes.Buffer{}
 	md, ok := metadata.FromIncomingContext(ctx)
@@ -288,7 +288,7 @@ func (h *grpcHandler) Echo(ctx context.Context, req *proto.EchoRequest) (*proto.
 	return &proto.EchoResponse{Message: body.String()}, nil
 }
 
-func (h *grpcHandler) ForwardEcho(ctx context.Context, req *proto.ForwardEchoRequest) (*proto.ForwardEchoResponse, error) {
+func (h *EchoGrpcHandler) ForwardEcho(ctx context.Context, req *proto.ForwardEchoRequest) (*proto.ForwardEchoResponse, error) {
 	id := uuid.New()
 	l := epLog.WithLabels("url", req.Url, "id", id)
 	l.Infof("ForwardEcho request")
-- 
2.35.3

