From eb0cbbe813ec80725ac96aec0f332d06237f6fb6 Mon Sep 17 00:00:00 2001
From: Nathan Mittler <nmittler@gmail.com>
Date: Thu, 3 Mar 2022 16:24:04 -0800
Subject: [TF] General echo cleanup (#37693)

Splitting out structures into separate files and creating substructures in ConfigOptions.
---
 pkg/http/headers/wellknown.go                 |   1 +
 .../echo/{call.go => calloptions.go}          | 197 ++++++++++---
 .../components/echo/cmd/echogen/echogen.go    |  15 +-
 .../framework/components/echo/common/call.go  | 151 ++--------
 .../components/echo/common/config.go          | 162 -----------
 .../echo/common/{defaults.go => ports.go}     |   0
 pkg/test/framework/components/echo/config.go  | 176 +++++++++++-
 pkg/test/framework/components/echo/echo.go    | 124 --------
 .../components/echo/echoboot/echoboot.go      |   8 +-
 .../components/echo/echotest/echotest.go      |   3 +-
 .../components/echo/echotest/fake.go          |   3 +-
 .../framework/components/echo/instance.go     |  40 +++
 .../framework/components/echo/instances.go    | 108 -------
 .../components/echo/kube/deployment.go        |  97 +++----
 .../components/echo/kube/deployment_test.go   |  19 +-
 .../components/echo/kube/workload_manager.go  |   3 +-
 .../echo/{echotypes/types.go => matcher.go}   |  19 +-
 .../framework/components/echo/matchers.go     | 126 ++++++++
 pkg/test/framework/components/echo/port.go    |  69 +++++
 .../components/echo/{common => }/portgen.go   |   2 +-
 pkg/test/framework/components/echo/sidecar.go |  55 ++++
 .../components/echo/staticvm/instance.go      |   2 +-
 .../framework/components/echo/workload.go     |  42 +++
 .../{echotypes/types.go => workloadclass.go}  |  25 +-
 pkg/test/framework/components/istio/config.go |  49 ++--
 .../framework/components/istio/eastwest.go    |  13 +-
 .../framework/components/istio/ingress.go     |   9 +-
 .../framework/components/istio/operator.go    |  59 ++--
 .../framework/components/namespace/kube.go    |  10 +-
 pkg/test/framework/image/flags.go             |  62 ----
 pkg/test/framework/image/settings.go          | 123 --------
 pkg/test/framework/resource/flags.go          |  62 ++--
 pkg/test/framework/resource/settings.go       |  86 +++++-
 tests/integration/helm/install_test.go        |   9 +-
 tests/integration/helm/upgrade/util.go        |  36 +--
 tests/integration/operator/switch_cr_test.go  |  27 +-
 tests/integration/operator/verify_test.go     |  10 +-
 tests/integration/pilot/common/apps.go        |   5 +-
 tests/integration/pilot/common/routing.go     | 272 +++++++++++-------
 tests/integration/pilot/common/traffic.go     |   5 +-
 tests/integration/pilot/gw_topology_test.go   |   5 +-
 tests/integration/pilot/ingress_test.go       | 122 ++++----
 tests/integration/pilot/locality_test.go      |  11 +-
 tests/integration/pilot/mirror_test.go        |   2 +-
 .../pilot/original_src_addr_test.go           |   3 +-
 tests/integration/pilot/vm_test.go            |   5 +-
 .../security/authorization_test.go            |  82 ++++--
 .../trust_domain_validation_test.go           |   6 +-
 .../egress_gateway_origination_test.go        |   5 +-
 .../egress_gateway_origination_test.go        |   5 +-
 .../security/https_jwt/https_jwt_test.go      |   4 +-
 tests/integration/security/jwt_test.go        | 128 ++++-----
 tests/integration/security/main_test.go       |   8 +-
 .../security/normalization_test.go            |   6 +-
 .../pass_through_filter_chain_test.go         |   5 +-
 .../integration/security/reachability_test.go |  32 ++-
 .../security/sds_ingress/util/util.go         |  20 +-
 .../security/sds_ingress_k8sca/main_test.go   |   5 +-
 tests/integration/security/util/cert/cert.go  |   4 +-
 tests/integration/security/util/framework.go  |   3 +-
 .../security/util/reachability/context.go     |   2 +-
 .../telemetry/outboundtrafficpolicy/helper.go |   7 +-
 .../telemetry/stackdriver/common.go           |   6 +-
 .../stackdriver_filter_audit_test.go          |   8 +-
 .../customize_metrics_test.go                 |  10 +-
 .../prometheus/nullvm/accesslogs_test.go      |   8 +-
 .../stats/prometheus/nullvm/dashboard_test.go |  13 +-
 .../telemetry/stats/prometheus/stats.go       |  20 +-
 .../integration/telemetry/tracing/tracing.go  |   4 +-
 69 files changed, 1420 insertions(+), 1403 deletions(-)
 rename pkg/test/framework/components/echo/{call.go => calloptions.go} (58%)
 delete mode 100644 pkg/test/framework/components/echo/common/config.go
 rename pkg/test/framework/components/echo/common/{defaults.go => ports.go} (100%)
 create mode 100644 pkg/test/framework/components/echo/instance.go
 copy pkg/test/framework/components/echo/{echotypes/types.go => matcher.go} (57%)
 create mode 100644 pkg/test/framework/components/echo/matchers.go
 create mode 100644 pkg/test/framework/components/echo/port.go
 rename pkg/test/framework/components/echo/{common => }/portgen.go (99%)
 create mode 100644 pkg/test/framework/components/echo/sidecar.go
 create mode 100644 pkg/test/framework/components/echo/workload.go
 rename pkg/test/framework/components/echo/{echotypes/types.go => workloadclass.go} (56%)
 delete mode 100644 pkg/test/framework/image/flags.go
 delete mode 100644 pkg/test/framework/image/settings.go

diff --git a/pkg/http/headers/wellknown.go b/pkg/http/headers/wellknown.go
index 9cac5548d2..8d524ba4f3 100644
--- a/pkg/http/headers/wellknown.go
+++ b/pkg/http/headers/wellknown.go
@@ -20,4 +20,5 @@
 	XForwardedFor              = "X-Forwarded-For"
 	AccessControlRequestMethod = "Access-Control-Request-Method"
 	Origin                     = "Origin"
+	XForwardedProto            = "X-Forwarded-Proto"
 )
diff --git a/pkg/test/framework/components/echo/call.go b/pkg/test/framework/components/echo/calloptions.go
similarity index 58%
rename from pkg/test/framework/components/echo/call.go
rename to pkg/test/framework/components/echo/calloptions.go
index 431587d738..e6d907c0b3 100644
--- a/pkg/test/framework/components/echo/call.go
+++ b/pkg/test/framework/components/echo/calloptions.go
@@ -15,15 +15,69 @@
 package echo
 
 import (
+	"errors"
+	"fmt"
 	"net/http"
+	"reflect"
 	"time"
 
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test/echo/check"
+	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 )
 
+// HTTP settings
+type HTTP struct {
+	// If true, h2c will be used in HTTP requests
+	HTTP2 bool
+
+	// If true, HTTP/3 request over QUIC will be used.
+	// It is mandatory to specify TLS settings
+	HTTP3 bool
+
+	// Path specifies the URL path for the HTTP(s) request.
+	Path string
+
+	// Method to send. Defaults to GET.
+	Method string
+
+	// Headers indicates headers that should be sent in the request. Ignored for WebSocket calls.
+	// If no Host header is provided, a default will be chosen for the target service endpoint.
+	Headers http.Header
+
+	// FollowRedirects will instruct the call to follow 301 redirects. Otherwise, the original 301 response
+	// is returned directly.
+	FollowRedirects bool
+
+	// HTTProxy used for making ingress echo call via proxy
+	HTTPProxy string
+}
+
+// TLS settings
+type TLS struct {
+	// Use the custom certificate to make the call. This is mostly used to make mTLS request directly
+	// (without proxy) from naked client to test certificates issued by custom CA instead of the Istio self-signed CA.
+	Cert, Key, CaCert string
+
+	// Use the custom certificates file to make the call.
+	CertFile, KeyFile, CaCertFile string
+
+	// Skip verify peer's certificate.
+	InsecureSkipVerify bool
+
+	Alpn       []string
+	ServerName string
+}
+
+// TCP settings
+type TCP struct {
+	// ExpectedResponse asserts this is in the response for TCP requests.
+	ExpectedResponse *wrappers.StringValue
+}
+
 // CallOptions defines options for calling a Endpoint.
 type CallOptions struct {
 	// Target instance of the call. Required.
@@ -39,71 +93,40 @@ type CallOptions struct {
 	// port will be used (if feasible).
 	Scheme scheme.Instance
 
-	// If true, h2c will be used in HTTP requests
-	HTTP2 bool
-
-	// If true, HTTP/3 request over QUIC will be used.
-	// It is mandatory to specify TLS settings
-	HTTP3 bool
-
 	// Address specifies the host name or IP address to be used on the request. If not provided,
 	// an appropriate default is chosen for the target Instance.
 	Address string
 
-	// Path specifies the URL path for the HTTP(s) request.
-	Path string
-
 	// Count indicates the number of exchanges that should be made with the service endpoint.
 	// If Count <= 0, defaults to 1.
 	Count int
 
-	// Headers indicates headers that should be sent in the request. Ignored for WebSocket calls.
-	// If no Host header is provided, a default will be chosen for the target service endpoint.
-	Headers http.Header
-
 	// Timeout used for each individual request. Must be > 0, otherwise 5 seconds is used.
 	Timeout time.Duration
 
-	// Message to be sent if this is a GRPC request
-	Message string
+	// HTTP settings.
+	HTTP HTTP
 
-	// ExpectedResponse asserts this is in the response for TCP requests.
-	ExpectedResponse *wrappers.StringValue
+	// TCP settings.
+	TCP TCP
 
-	// Method to send. Defaults to HTTP. Only relevant for HTTP.
-	Method string
+	// TLS settings.
+	TLS TLS
 
-	// Use the custom certificate to make the call. This is mostly used to make mTLS request directly
-	// (without proxy) from naked client to test certificates issued by custom CA instead of the Istio self-signed CA.
-	Cert, Key, CaCert string
-
-	// Use the custom certificates file to make the call.
-	CertFile, KeyFile, CaCertFile string
-
-	// Skip verify peer's certificate.
-	InsecureSkipVerify bool
-
-	// FollowRedirects will instruct the call to follow 301 redirects. Otherwise, the original 301 response
-	// is returned directly.
-	FollowRedirects bool
+	// Message to be sent.
+	Message string
 
 	// Check the server responses. If none is provided, only the number of responses received
 	// will be checked.
 	Check check.Checker
-
-	// HTTProxy used for making ingress echo call via proxy
-	HTTPProxy string
-
-	Alpn       []string
-	ServerName string
 }
 
 // GetHost returns the best default host for the call. Returns the first host defined from the following
 // sources (in order of precedence): Host header, target's DefaultHostHeader, Address, target's FQDN.
 func (o CallOptions) GetHost() string {
 	// First, use the host header, if specified.
-	if h := o.Headers["Host"]; len(h) > 0 {
-		return o.Headers["Host"][0]
+	if h := o.HTTP.Headers["Host"]; len(h) > 0 {
+		return o.HTTP.Headers["Host"][0]
 	}
 
 	// Next use the target's default, if specified.
@@ -130,9 +153,95 @@ func (o CallOptions) DeepCopy() CallOptions {
 		dc := *o.Port
 		clone.Port = &dc
 	}
-	if o.Alpn != nil {
-		clone.Alpn = make([]string, len(o.Alpn))
-		copy(clone.Alpn, o.Alpn)
+	if o.TLS.Alpn != nil {
+		clone.TLS.Alpn = make([]string, len(o.TLS.Alpn))
+		copy(clone.TLS.Alpn, o.TLS.Alpn)
 	}
 	return clone
 }
+
+// FillDefaults fills out any defaults that haven't been explicitly specified.
+func (o *CallOptions) FillDefaults() error {
+	if o.Target != nil {
+		targetPorts := o.Target.Config().Ports
+		if o.PortName == "" {
+			// Validate the Port value.
+
+			if o.Port == nil {
+				return errors.New("callOptions: PortName or Port must be provided")
+			}
+
+			// Check the specified port for a match against the Target Instance
+			found := false
+			for _, port := range targetPorts {
+				if reflect.DeepEqual(port, *o.Port) {
+					found = true
+					break
+				}
+			}
+			if !found {
+				return fmt.Errorf("callOptions: Port does not match any Target port")
+			}
+		} else {
+			// Look up the port.
+			found := false
+			for i, port := range targetPorts {
+				if o.PortName == port.Name {
+					found = true
+					o.Port = &targetPorts[i]
+					break
+				}
+			}
+			if !found {
+				return fmt.Errorf("callOptions: no port named %s available in Target Instance", o.PortName)
+			}
+		}
+	} else if o.Scheme == scheme.DNS {
+		// Just need address
+		if o.Address == "" {
+			return fmt.Errorf("for DNS, address must be set")
+		}
+		o.Port = &Port{}
+	} else if o.Port == nil || o.Port.ServicePort == 0 || (o.Port.Protocol == "" && o.Scheme == "") || o.Address == "" {
+		return fmt.Errorf("if target is not set, then port.servicePort, port.protocol or schema, and address must be set")
+	}
+
+	if o.Scheme == "" {
+		// No protocol, fill it in.
+		var err error
+		if o.Scheme, err = o.Port.Scheme(); err != nil {
+			return err
+		}
+	}
+
+	if o.Address == "" {
+		// No host specified, use the fully qualified domain name for the service.
+		o.Address = o.Target.Config().ClusterLocalFQDN()
+	}
+
+	// Initialize the headers and add a default Host header if none provided.
+	if o.HTTP.Headers == nil {
+		o.HTTP.Headers = make(http.Header)
+	} else {
+		// Avoid mutating input, which can lead to concurrent writes
+		o.HTTP.Headers = o.HTTP.Headers.Clone()
+	}
+
+	if h := o.GetHost(); len(h) > 0 {
+		o.HTTP.Headers.Set(headers.Host, h)
+	}
+
+	if o.Timeout <= 0 {
+		o.Timeout = common.DefaultRequestTimeout
+	}
+
+	if o.Count <= 0 {
+		o.Count = common.DefaultCount
+	}
+
+	// If no Check was specified, assume no error.
+	if o.Check == nil {
+		o.Check = check.None()
+	}
+	return nil
+}
diff --git a/pkg/test/framework/components/echo/cmd/echogen/echogen.go b/pkg/test/framework/components/echo/cmd/echogen/echogen.go
index 4a9ca866d5..5847902ff8 100644
--- a/pkg/test/framework/components/echo/cmd/echogen/echogen.go
+++ b/pkg/test/framework/components/echo/cmd/echogen/echogen.go
@@ -28,7 +28,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/kube"
 	"istio.io/istio/pkg/test/framework/config"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/yml"
 )
@@ -81,8 +80,7 @@ func generate(input, output string, outputDir bool, outstream io.StringWriter) {
 
 type generator struct {
 	// settings
-	settings    *resource.Settings
-	imgSettings *image.Settings
+	settings *resource.Settings
 
 	// internal
 	configs   []echo.Config
@@ -95,14 +93,9 @@ func newGenerator() generator {
 	if err != nil {
 		log.Fatalf("failed reading test framework settings: %v", err)
 	}
-	imgSettings, err := image.SettingsFromCommandLine()
-	if err != nil {
-		log.Fatalf("failed reading test framework settings: %v", err)
-	}
 
 	return generator{
-		settings:    settings,
-		imgSettings: imgSettings,
+		settings: settings,
 	}
 }
 
@@ -126,7 +119,7 @@ func (g *generator) load(input string) error {
 			}
 		}
 		cfg.Cluster = c
-		if err := common.FillInDefaults(nil, &cfg); err != nil {
+		if err := cfg.FillDefaults(nil); err != nil {
 			return fmt.Errorf("failed filling defaults for %s: %v", cfg.ClusterLocalFQDN(), err)
 		}
 		g.configs[i] = cfg
@@ -145,7 +138,7 @@ func (g *generator) generate() error {
 			errs = multierror.Append(errs, fmt.Errorf("failed generating service for %s: %v", id, err))
 			continue
 		}
-		deployment, err := kube.GenerateDeployment(cfg, g.imgSettings, g.settings)
+		deployment, err := kube.GenerateDeployment(cfg, g.settings)
 		if err != nil {
 			errs = multierror.Append(errs, fmt.Errorf("failed generating deployment for %s: %v", id, err))
 			continue
diff --git a/pkg/test/framework/components/echo/common/call.go b/pkg/test/framework/components/echo/common/call.go
index 18ffecca95..9117276ec1 100644
--- a/pkg/test/framework/components/echo/common/call.go
+++ b/pkg/test/framework/components/echo/common/call.go
@@ -16,18 +16,13 @@
 
 import (
 	"context"
-	"errors"
 	"fmt"
 	"net"
-	"net/http"
-	"reflect"
 	"strconv"
 	"strings"
 	"time"
 
-	"istio.io/istio/pkg/config/protocol"
 	echoclient "istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/echo/proto"
@@ -41,7 +36,7 @@
 
 func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 	doRetry bool, retryOptions ...retry.Option) (echoclient.Responses, error) {
-	if err := fillInCallOptions(opts); err != nil {
+	if err := opts.FillDefaults(); err != nil {
 		return nil, err
 	}
 
@@ -57,14 +52,11 @@ func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 	case scheme.XDS:
 		targetURL = fmt.Sprintf("%s:///%s", string(opts.Scheme), addressAndPort)
 	default:
-		targetURL = fmt.Sprintf("%s://%s%s", string(opts.Scheme), addressAndPort, opts.Path)
+		targetURL = fmt.Sprintf("%s://%s%s", string(opts.Scheme), addressAndPort, opts.HTTP.Path)
 	}
 
 	// Copy all the headers.
-	protoHeaders := make([]*proto.Header, 0, len(opts.Headers))
-	for k := range opts.Headers {
-		protoHeaders = append(protoHeaders, &proto.Header{Key: k, Value: opts.Headers.Get(k)})
-	}
+	protoHeaders := common.HTTPToProtoHeaders(opts.HTTP.Headers)
 
 	req := &proto.ForwardEchoRequest{
 		Url:                targetURL,
@@ -72,24 +64,24 @@ func callInternal(srcName string, opts *echo.CallOptions, send sendFunc,
 		Headers:            protoHeaders,
 		TimeoutMicros:      common.DurationToMicros(opts.Timeout),
 		Message:            opts.Message,
-		ExpectedResponse:   opts.ExpectedResponse,
-		Http2:              opts.HTTP2,
-		Http3:              opts.HTTP3,
-		Method:             opts.Method,
+		ExpectedResponse:   opts.TCP.ExpectedResponse,
+		Http2:              opts.HTTP.HTTP2,
+		Http3:              opts.HTTP.HTTP3,
+		Method:             opts.HTTP.Method,
 		ServerFirst:        opts.Port.ServerFirst,
-		Cert:               opts.Cert,
-		Key:                opts.Key,
-		CaCert:             opts.CaCert,
-		CertFile:           opts.CertFile,
-		KeyFile:            opts.KeyFile,
-		CaCertFile:         opts.CaCertFile,
-		InsecureSkipVerify: opts.InsecureSkipVerify,
-		FollowRedirects:    opts.FollowRedirects,
-		ServerName:         opts.ServerName,
-	}
-	if opts.Alpn != nil {
+		Cert:               opts.TLS.Cert,
+		Key:                opts.TLS.Key,
+		CaCert:             opts.TLS.CaCert,
+		CertFile:           opts.TLS.CertFile,
+		KeyFile:            opts.TLS.KeyFile,
+		CaCertFile:         opts.TLS.CaCertFile,
+		InsecureSkipVerify: opts.TLS.InsecureSkipVerify,
+		FollowRedirects:    opts.HTTP.FollowRedirects,
+		ServerName:         opts.TLS.ServerName,
+	}
+	if opts.TLS.Alpn != nil {
 		req.Alpn = &proto.Alpn{
-			Value: opts.Alpn,
+			Value: opts.TLS.Alpn,
 		}
 	}
 
@@ -135,7 +127,7 @@ func CallEcho(opts *echo.CallOptions, retry bool, retryOptions ...retry.Option)
 	send := func(req *proto.ForwardEchoRequest) (echoclient.Responses, error) {
 		instance, err := forwarder.New(forwarder.Config{
 			Request: req,
-			Proxy:   opts.HTTPProxy,
+			Proxy:   opts.HTTP.HTTPProxy,
 		})
 		if err != nil {
 			return nil, err
@@ -173,111 +165,10 @@ func ForwardEcho(srcName string, clientProvider EchoClientProvider, opts *echo.C
 				strings.ToLower(string(opts.Port.Protocol)),
 				opts.Address,
 				opts.Port.ServicePort,
-				opts.Path,
+				opts.HTTP.Path,
 				err)
 		}
 		return nil, err
 	}
 	return res, nil
 }
-
-func fillInCallOptions(opts *echo.CallOptions) error {
-	if opts.Target != nil {
-		targetPorts := opts.Target.Config().Ports
-		if opts.PortName == "" {
-			// Validate the Port value.
-
-			if opts.Port == nil {
-				return errors.New("callOptions: PortName or Port must be provided")
-			}
-
-			// Check the specified port for a match against the Target Instance
-			found := false
-			for _, port := range targetPorts {
-				if reflect.DeepEqual(port, *opts.Port) {
-					found = true
-					break
-				}
-			}
-			if !found {
-				return fmt.Errorf("callOptions: Port does not match any Target port")
-			}
-		} else {
-			// Look up the port.
-			found := false
-			for i, port := range targetPorts {
-				if opts.PortName == port.Name {
-					found = true
-					opts.Port = &targetPorts[i]
-					break
-				}
-			}
-			if !found {
-				return fmt.Errorf("callOptions: no port named %s available in Target Instance", opts.PortName)
-			}
-		}
-	} else if opts.Scheme == scheme.DNS {
-		// Just need address
-		if opts.Address == "" {
-			return fmt.Errorf("for DNS, address must be set")
-		}
-		opts.Port = &echo.Port{}
-	} else if opts.Port == nil || opts.Port.ServicePort == 0 || (opts.Port.Protocol == "" && opts.Scheme == "") || opts.Address == "" {
-		return fmt.Errorf("if target is not set, then port.servicePort, port.protocol or schema, and address must be set")
-	}
-
-	if opts.Scheme == "" {
-		// No protocol, fill it in.
-		var err error
-		if opts.Scheme, err = schemeForPort(opts.Port); err != nil {
-			return err
-		}
-	}
-
-	if opts.Address == "" {
-		// No host specified, use the fully qualified domain name for the service.
-		opts.Address = opts.Target.Config().ClusterLocalFQDN()
-	}
-
-	// Initialize the headers and add a default Host header if none provided.
-	if opts.Headers == nil {
-		opts.Headers = make(http.Header)
-	} else {
-		// Avoid mutating input, which can lead to concurrent writes
-		opts.Headers = opts.Headers.Clone()
-	}
-
-	if h := opts.GetHost(); len(h) > 0 {
-		opts.Headers["Host"] = []string{h}
-	}
-
-	if opts.Timeout <= 0 {
-		opts.Timeout = common.DefaultRequestTimeout
-	}
-
-	if opts.Count <= 0 {
-		opts.Count = common.DefaultCount
-	}
-
-	// If no Check was specified, assume no error.
-	if opts.Check == nil {
-		opts.Check = check.None()
-	}
-	return nil
-}
-
-func schemeForPort(port *echo.Port) (scheme.Instance, error) {
-	switch port.Protocol {
-	case protocol.GRPC, protocol.GRPCWeb, protocol.HTTP2:
-		return scheme.GRPC, nil
-	case protocol.HTTP:
-		return scheme.HTTP, nil
-	case protocol.HTTPS:
-		return scheme.HTTPS, nil
-	case protocol.TCP:
-		return scheme.TCP, nil
-	default:
-		return "", fmt.Errorf("failed creating call for port %s: unsupported protocol %s",
-			port.Name, port.Protocol)
-	}
-}
diff --git a/pkg/test/framework/components/echo/common/config.go b/pkg/test/framework/components/echo/common/config.go
deleted file mode 100644
index 06b2662927..0000000000
--- a/pkg/test/framework/components/echo/common/config.go
+++ /dev/null
@@ -1,162 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package common
-
-import (
-	"fmt"
-	"strings"
-
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/resource"
-)
-
-const (
-	defaultService   = "echo"
-	defaultVersion   = "v1"
-	defaultNamespace = "echo"
-	defaultDomain    = constants.DefaultKubernetesDomain
-)
-
-func FillInDefaults(ctx resource.Context, c *echo.Config) (err error) {
-	if c.Service == "" {
-		c.Service = defaultService
-	}
-
-	if c.Version == "" {
-		c.Version = defaultVersion
-	}
-
-	if c.Domain == "" {
-		c.Domain = defaultDomain
-	}
-
-	if c.VMDistro == "" {
-		c.VMDistro = echo.DefaultVMDistro
-	}
-	if c.StatefulSet {
-		// Statefulset requires headless
-		c.Headless = true
-	}
-
-	// Convert legacy config to workload oritended.
-	if c.Subsets == nil {
-		c.Subsets = []echo.SubsetConfig{
-			{
-				Version: c.Version,
-			},
-		}
-	}
-
-	for i := range c.Subsets {
-		if c.Subsets[i].Version == "" {
-			c.Subsets[i].Version = c.Version
-		}
-	}
-	AddPortIfMissing(c, protocol.GRPC)
-	// If no namespace was provided, use the default.
-	if c.Namespace == nil && ctx != nil {
-		nsConfig := namespace.Config{
-			Prefix: defaultNamespace,
-			Inject: true,
-		}
-		if c.Namespace, err = namespace.New(ctx, nsConfig); err != nil {
-			return err
-		}
-	}
-
-	// Make a copy of the ports array. This avoids potential corruption if multiple Echo
-	// Instances share the same underlying ports array.
-	c.Ports = append([]echo.Port{}, c.Ports...)
-
-	// Mark all user-defined ports as used, so the port generator won't assign them.
-	portGen := newPortGenerators()
-	for _, p := range c.Ports {
-		if p.ServicePort > 0 {
-			if portGen.Service.IsUsed(p.ServicePort) {
-				return fmt.Errorf("failed configuring port %s: service port already used %d", p.Name, p.ServicePort)
-			}
-			portGen.Service.SetUsed(p.ServicePort)
-		}
-		if p.InstancePort > 0 {
-			if portGen.Instance.IsUsed(p.InstancePort) {
-				return fmt.Errorf("failed configuring port %s: instance port already used %d", p.Name, p.InstancePort)
-			}
-			portGen.Instance.SetUsed(p.InstancePort)
-		}
-	}
-	for _, p := range c.WorkloadOnlyPorts {
-		if p.Port > 0 {
-			if portGen.Instance.IsUsed(p.Port) {
-				return fmt.Errorf("failed configuring workload only port %d: port already used", p.Port)
-			}
-			portGen.Instance.SetUsed(p.Port)
-			if portGen.Service.IsUsed(p.Port) {
-				return fmt.Errorf("failed configuring workload only port %d: port already used", p.Port)
-			}
-			portGen.Service.SetUsed(p.Port)
-		}
-	}
-
-	// Second pass: try to make unassigned instance ports match service port.
-	for i, p := range c.Ports {
-		if p.InstancePort <= 0 && p.ServicePort > 0 && !portGen.Instance.IsUsed(p.ServicePort) {
-			c.Ports[i].InstancePort = p.ServicePort
-			portGen.Instance.SetUsed(p.ServicePort)
-		}
-	}
-
-	// Final pass: assign default values for any ports that haven't been specified.
-	for i, p := range c.Ports {
-		if p.ServicePort <= 0 {
-			c.Ports[i].ServicePort = portGen.Service.Next(p.Protocol)
-		}
-		if p.InstancePort <= 0 {
-			c.Ports[i].InstancePort = portGen.Instance.Next(p.Protocol)
-		}
-	}
-
-	// If readiness probe is not specified by a test, wait a long time
-	// Waiting forever would cause the test to timeout and lose logs
-	if c.ReadinessTimeout == 0 {
-		c.ReadinessTimeout = echo.DefaultReadinessTimeout()
-	}
-
-	return nil
-}
-
-// GetPortForProtocol returns the first port found with the given protocol, or nil if none was found.
-func GetPortForProtocol(c *echo.Config, protocol protocol.Instance) *echo.Port {
-	for _, p := range c.Ports {
-		if p.Protocol == protocol {
-			return &p
-		}
-	}
-	return nil
-}
-
-// AddPortIfMissing adds a port for the given protocol if none was found.
-func AddPortIfMissing(c *echo.Config, protocol protocol.Instance) {
-	if GetPortForProtocol(c, protocol) == nil {
-		c.Ports = append([]echo.Port{
-			{
-				Name:     strings.ToLower(string(protocol)),
-				Protocol: protocol,
-			},
-		}, c.Ports...)
-	}
-}
diff --git a/pkg/test/framework/components/echo/common/defaults.go b/pkg/test/framework/components/echo/common/ports.go
similarity index 100%
rename from pkg/test/framework/components/echo/common/defaults.go
rename to pkg/test/framework/components/echo/common/ports.go
diff --git a/pkg/test/framework/components/echo/config.go b/pkg/test/framework/components/echo/config.go
index 6b29431eb3..a62301b550 100644
--- a/pkg/test/framework/components/echo/config.go
+++ b/pkg/test/framework/components/echo/config.go
@@ -24,10 +24,11 @@
 	"gopkg.in/yaml.v3"
 
 	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/namespace"
+	"istio.io/istio/pkg/test/framework/resource"
 )
 
 // Cluster that can deploy echo instances.
@@ -252,6 +253,142 @@ func (c Config) IsExternal() bool {
 	return c.HostHeader() != c.ClusterLocalFQDN()
 }
 
+const (
+	defaultService   = "echo"
+	defaultVersion   = "v1"
+	defaultNamespace = "echo"
+	defaultDomain    = constants.DefaultKubernetesDomain
+)
+
+func (c *Config) FillDefaults(ctx resource.Context) (err error) {
+	if c.Service == "" {
+		c.Service = defaultService
+	}
+
+	if c.Version == "" {
+		c.Version = defaultVersion
+	}
+
+	if c.Domain == "" {
+		c.Domain = defaultDomain
+	}
+
+	if c.VMDistro == "" {
+		c.VMDistro = DefaultVMDistro
+	}
+	if c.StatefulSet {
+		// Statefulset requires headless
+		c.Headless = true
+	}
+
+	// Convert legacy config to workload oritended.
+	if c.Subsets == nil {
+		c.Subsets = []SubsetConfig{
+			{
+				Version: c.Version,
+			},
+		}
+	}
+
+	for i := range c.Subsets {
+		if c.Subsets[i].Version == "" {
+			c.Subsets[i].Version = c.Version
+		}
+	}
+	c.addPortIfMissing(protocol.GRPC)
+	// If no namespace was provided, use the default.
+	if c.Namespace == nil && ctx != nil {
+		nsConfig := namespace.Config{
+			Prefix: defaultNamespace,
+			Inject: true,
+		}
+		if c.Namespace, err = namespace.New(ctx, nsConfig); err != nil {
+			return err
+		}
+	}
+
+	// Make a copy of the ports array. This avoids potential corruption if multiple Echo
+	// Instances share the same underlying ports array.
+	c.Ports = append([]Port{}, c.Ports...)
+
+	// Mark all user-defined ports as used, so the port generator won't assign them.
+	portGen := newPortGenerators()
+	for _, p := range c.Ports {
+		if p.ServicePort > 0 {
+			if portGen.Service.IsUsed(p.ServicePort) {
+				return fmt.Errorf("failed configuring port %s: service port already used %d", p.Name, p.ServicePort)
+			}
+			portGen.Service.SetUsed(p.ServicePort)
+		}
+		if p.InstancePort > 0 {
+			if portGen.Instance.IsUsed(p.InstancePort) {
+				return fmt.Errorf("failed configuring port %s: instance port already used %d", p.Name, p.InstancePort)
+			}
+			portGen.Instance.SetUsed(p.InstancePort)
+		}
+	}
+	for _, p := range c.WorkloadOnlyPorts {
+		if p.Port > 0 {
+			if portGen.Instance.IsUsed(p.Port) {
+				return fmt.Errorf("failed configuring workload only port %d: port already used", p.Port)
+			}
+			portGen.Instance.SetUsed(p.Port)
+			if portGen.Service.IsUsed(p.Port) {
+				return fmt.Errorf("failed configuring workload only port %d: port already used", p.Port)
+			}
+			portGen.Service.SetUsed(p.Port)
+		}
+	}
+
+	// Second pass: try to make unassigned instance ports match service port.
+	for i, p := range c.Ports {
+		if p.InstancePort <= 0 && p.ServicePort > 0 && !portGen.Instance.IsUsed(p.ServicePort) {
+			c.Ports[i].InstancePort = p.ServicePort
+			portGen.Instance.SetUsed(p.ServicePort)
+		}
+	}
+
+	// Final pass: assign default values for any ports that haven't been specified.
+	for i, p := range c.Ports {
+		if p.ServicePort <= 0 {
+			c.Ports[i].ServicePort = portGen.Service.Next(p.Protocol)
+		}
+		if p.InstancePort <= 0 {
+			c.Ports[i].InstancePort = portGen.Instance.Next(p.Protocol)
+		}
+	}
+
+	// If readiness probe is not specified by a test, wait a long time
+	// Waiting forever would cause the test to timeout and lose logs
+	if c.ReadinessTimeout == 0 {
+		c.ReadinessTimeout = DefaultReadinessTimeout()
+	}
+
+	return nil
+}
+
+// GetPortForProtocol returns the first port found with the given protocol, or nil if none was found.
+func (c Config) GetPortForProtocol(protocol protocol.Instance) *Port {
+	for _, p := range c.Ports {
+		if p.Protocol == protocol {
+			return &p
+		}
+	}
+	return nil
+}
+
+// addPortIfMissing adds a port for the given protocol if none was found.
+func (c *Config) addPortIfMissing(protocol protocol.Instance) {
+	if c.GetPortForProtocol(protocol) == nil {
+		c.Ports = append([]Port{
+			{
+				Name:     strings.ToLower(string(protocol)),
+				Protocol: protocol,
+			},
+		}, c.Ports...)
+	}
+}
+
 func copyInternal(v interface{}) interface{} {
 	copied, err := copystructure.Copy(v)
 	if err != nil {
@@ -293,26 +430,41 @@ func ParseConfigs(bytes []byte) ([]Config, error) {
 	return configs, nil
 }
 
-// Class returns the type of workload a given config is.
-func (c Config) Class() echotypes.Class {
+// WorkloadClass returns the type of workload a given config is.
+func (c Config) WorkloadClass() WorkloadClass {
 	if c.IsProxylessGRPC() {
-		return echotypes.Proxyless
+		return Proxyless
 	} else if c.IsVM() {
-		return echotypes.VM
+		return VM
 	} else if c.IsTProxy() {
-		return echotypes.TProxy
+		return TProxy
 	} else if c.IsNaked() {
-		return echotypes.Naked
+		return Naked
 	} else if c.IsExternal() {
-		return echotypes.External
+		return External
 	} else if c.IsStatefulSet() {
-		return echotypes.StatefulSet
+		return StatefulSet
 	} else if c.IsDelta() {
 		// TODO remove if delta is on by default
-		return echotypes.Delta
+		return Delta
 	}
 	if c.IsHeadless() {
-		return echotypes.Headless
+		return Headless
 	}
-	return echotypes.Standard
+	return Standard
+}
+
+// WorkloadPort exposed by an Echo instance
+type WorkloadPort struct {
+	// Port number
+	Port int
+
+	// Protocol to be used for this port.
+	Protocol protocol.Instance
+
+	// TLS determines whether the connection will be plain text or TLS. By default this is false (plain text).
+	TLS bool
+
+	// ServerFirst determines whether the port will use server first communication, meaning the client will not send the first byte.
+	ServerFirst bool
 }
diff --git a/pkg/test/framework/components/echo/echo.go b/pkg/test/framework/components/echo/echo.go
index ed53b20981..f128a4d726 100644
--- a/pkg/test/framework/components/echo/echo.go
+++ b/pkg/test/framework/components/echo/echo.go
@@ -15,17 +15,9 @@
 package echo
 
 import (
-	"context"
-
-	envoyAdmin "github.com/envoyproxy/go-control-plane/envoy/admin/v3"
-	dto "github.com/prometheus/client_model/go"
-
-	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/echo"
-	"istio.io/istio/pkg/test/echo/proto"
 	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/retry"
 )
 
@@ -87,119 +79,3 @@ func (c Callers) Instances() Instances {
 	}
 	return out
 }
-
-// Instance is a component that provides access to a deployed echo service.
-type Instance interface {
-	Caller
-	resource.Resource
-
-	// Config returns the configuration of the Echo instance.
-	Config() Config
-
-	// Address of the service (e.g. Kubernetes cluster IP). May be "" if headless.
-	Address() string
-
-	// Workloads retrieves the list of all deployed workloads for this Echo service.
-	// Guarantees at least one workload, if error == nil.
-	Workloads() ([]Workload, error)
-	WorkloadsOrFail(t test.Failer) []Workload
-
-	// Restart restarts the workloads associated with this echo instance
-	Restart() error
-}
-
-// Workload port exposed by an Echo instance
-type WorkloadPort struct {
-	// Port number
-	Port int
-
-	// Protocol to be used for this port.
-	Protocol protocol.Instance
-
-	// TLS determines whether the connection will be plain text or TLS. By default this is false (plain text).
-	TLS bool
-
-	// ServerFirst determines whether the port will use server first communication, meaning the client will not send the first byte.
-	ServerFirst bool
-}
-
-// Port exposed by an Echo Instance
-type Port struct {
-	// Name of this port
-	Name string
-
-	// Protocol to be used for the port.
-	Protocol protocol.Instance
-
-	// ServicePort number where the service can be reached. Does not necessarily
-	// map to the corresponding port numbers for the instances behind the
-	// service.
-	ServicePort int
-
-	// InstancePort number where this instance is listening for connections.
-	// This need not be the same as the ServicePort where the service is accessed.
-	InstancePort int
-
-	// TLS determines whether the connection will be plain text or TLS. By default this is false (plain text).
-	TLS bool
-
-	// ServerFirst determines whether the port will use server first communication, meaning the client will not send the first byte.
-	ServerFirst bool
-
-	// InstanceIP determines if echo will listen on the instance IP; otherwise, it will listen on wildcard
-	InstanceIP bool
-
-	// LocalhostIP determines if echo will listen on the localhost IP; otherwise, it will listen on wildcard
-	LocalhostIP bool
-}
-
-// Workload provides an interface for a single deployed echo server.
-type Workload interface {
-	// PodName gets the original pod name for the workload.
-	PodName() string
-	// Address returns the network address of the endpoint.
-	Address() string
-
-	// Sidecar if one was specified.
-	Sidecar() Sidecar
-
-	// ForwardEcho executes specific call from this workload.
-	ForwardEcho(context.Context, *proto.ForwardEchoRequest) (echo.Responses, error)
-
-	// Logs returns the logs for the app container
-	Logs() (string, error)
-	// LogsOrFail returns the logs for the app container, or aborts if an error is found
-	LogsOrFail(t test.Failer) string
-}
-
-// Sidecar provides an interface to execute queries against a single Envoy sidecar.
-type Sidecar interface {
-	// Info about the Envoy instance.
-	Info() (*envoyAdmin.ServerInfo, error)
-	InfoOrFail(t test.Failer) *envoyAdmin.ServerInfo
-
-	// Config of the Envoy instance.
-	Config() (*envoyAdmin.ConfigDump, error)
-	ConfigOrFail(t test.Failer) *envoyAdmin.ConfigDump
-
-	// WaitForConfig queries the Envoy configuration an executes the given accept handler. If the
-	// response is not accepted, the request will be retried until either a timeout or a response
-	// has been accepted.
-	WaitForConfig(accept func(*envoyAdmin.ConfigDump) (bool, error), options ...retry.Option) error
-	WaitForConfigOrFail(t test.Failer, accept func(*envoyAdmin.ConfigDump) (bool, error), options ...retry.Option)
-
-	// Clusters for the Envoy instance
-	Clusters() (*envoyAdmin.Clusters, error)
-	ClustersOrFail(t test.Failer) *envoyAdmin.Clusters
-
-	// Listeners for the Envoy instance
-	Listeners() (*envoyAdmin.Listeners, error)
-	ListenersOrFail(t test.Failer) *envoyAdmin.Listeners
-
-	// Logs returns the logs for the sidecar container
-	Logs() (string, error)
-	// LogsOrFail returns the logs for the sidecar container, or aborts if an error is found
-	LogsOrFail(t test.Failer) string
-	Stats() (map[string]*dto.MetricFamily, error)
-	StatsOrFail(t test.Failer) map[string]*dto.MetricFamily
-}
diff --git a/pkg/test/framework/components/echo/echoboot/echoboot.go b/pkg/test/framework/components/echo/echoboot/echoboot.go
index bda68c331a..a7c7ed5d42 100644
--- a/pkg/test/framework/components/echo/echoboot/echoboot.go
+++ b/pkg/test/framework/components/echo/echoboot/echoboot.go
@@ -30,8 +30,6 @@
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/common"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/echo/kube"
 
 	// force registraton of factory func
@@ -96,12 +94,12 @@ func (b builder) WithConfig(cfg echo.Config) echo.Builder {
 // to that cluster, otherwise the Config is applied to all WithClusters. Once built, if being built for a single cluster,
 // the instance pointer will be updated to point at the new Instance.
 func (b builder) With(i *echo.Instance, cfg echo.Config) echo.Builder {
-	if b.ctx.Settings().SkipWorkloadClasses.Contains(cfg.Class()) {
+	if b.ctx.Settings().SkipWorkloadClassesAsSet().Contains(cfg.WorkloadClass()) {
 		return b
 	}
 
 	cfg = cfg.DeepCopy()
-	if err := common.FillInDefaults(b.ctx, &cfg); err != nil {
+	if err := cfg.FillDefaults(b.ctx); err != nil {
 		b.errs = multierror.Append(b.errs, err)
 		return b
 	}
@@ -115,7 +113,7 @@ func (b builder) With(i *echo.Instance, cfg echo.Config) echo.Builder {
 	}
 
 	// If we didn't deploy VMs, but we don't care about VMs, we can ignore this.
-	shouldSkip := b.ctx.Settings().Skip(echotypes.VM) && cfg.IsVM()
+	shouldSkip := b.ctx.Settings().Skip(echo.VM) && cfg.IsVM()
 	deployedTo := 0
 	for idx, c := range targetClusters {
 		ec, ok := c.(echo.Cluster)
diff --git a/pkg/test/framework/components/echo/echotest/echotest.go b/pkg/test/framework/components/echo/echotest/echotest.go
index c5c15980a8..77f412c6a8 100644
--- a/pkg/test/framework/components/echo/echotest/echotest.go
+++ b/pkg/test/framework/components/echo/echotest/echotest.go
@@ -17,7 +17,6 @@
 import (
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 )
 
 // T enumerates subtests given a set of workloads as echo.Instances.
@@ -41,7 +40,7 @@ func New(ctx framework.TestContext, instances echo.Instances) *T {
 	copy(s, instances)
 	copy(d, instances)
 	t := &T{rootCtx: ctx, sources: s, destinations: d}
-	if ctx.Settings().Skip(echotypes.VM) {
+	if ctx.Settings().Skip(echo.VM) {
 		noVM := Not(FilterMatch(echo.IsVirtualMachine()))
 		t = t.From(noVM).To(noVM)
 	}
diff --git a/pkg/test/framework/components/echo/echotest/fake.go b/pkg/test/framework/components/echo/echotest/fake.go
index 0f2d0a883c..2e5c2c0172 100644
--- a/pkg/test/framework/components/echo/echotest/fake.go
+++ b/pkg/test/framework/components/echo/echotest/fake.go
@@ -20,7 +20,6 @@
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/retry"
 )
@@ -40,7 +39,7 @@ func (f fakeInstance) ID() resource.ID {
 
 func (f fakeInstance) Config() echo.Config {
 	cfg := echo.Config(f)
-	_ = common.FillInDefaults(nil, &cfg)
+	_ = cfg.FillDefaults(nil)
 	return cfg
 }
 
diff --git a/pkg/test/framework/components/echo/instance.go b/pkg/test/framework/components/echo/instance.go
new file mode 100644
index 0000000000..c23b0cbbd9
--- /dev/null
+++ b/pkg/test/framework/components/echo/instance.go
@@ -0,0 +1,40 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echo
+
+import (
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/framework/resource"
+)
+
+// Instance is a component that provides access to a deployed echo service.
+type Instance interface {
+	Caller
+	resource.Resource
+
+	// Config returns the configuration of the Echo instance.
+	Config() Config
+
+	// Address of the service (e.g. Kubernetes cluster IP). May be "" if headless.
+	Address() string
+
+	// Workloads retrieves the list of all deployed workloads for this Echo service.
+	// Guarantees at least one workload, if error == nil.
+	Workloads() ([]Workload, error)
+	WorkloadsOrFail(t test.Failer) []Workload
+
+	// Restart restarts the workloads associated with this echo instance
+	Restart() error
+}
diff --git a/pkg/test/framework/components/echo/instances.go b/pkg/test/framework/components/echo/instances.go
index 11b4b2e87e..febe23bf2d 100644
--- a/pkg/test/framework/components/echo/instances.go
+++ b/pkg/test/framework/components/echo/instances.go
@@ -53,114 +53,6 @@ func (i Instances) IsDeployment() bool {
 	return len(i.Services()) == 1
 }
 
-// Matcher is used to filter matching instances
-type Matcher func(Instance) bool
-
-// Any doesn't filter out any echos.
-func Any(_ Instance) bool {
-	return true
-}
-
-// And combines two or more matches. Example:
-//     Service("a").And(InCluster(c)).And(Match(func(...))
-func (m Matcher) And(other Matcher) Matcher {
-	return func(i Instance) bool {
-		return m(i) && other(i)
-	}
-}
-
-// Not negates the given matcher. Example:
-//     Not(IsNaked())
-func Not(m Matcher) Matcher {
-	return func(i Instance) bool {
-		return !m(i)
-	}
-}
-
-// ServicePrefix matches instances whose service name starts with the given prefix.
-func ServicePrefix(prefix string) Matcher {
-	return func(i Instance) bool {
-		return strings.HasPrefix(i.Config().Service, prefix)
-	}
-}
-
-// Service matches instances with have the given service name.
-func Service(value string) Matcher {
-	return func(i Instance) bool {
-		return value == i.Config().Service
-	}
-}
-
-// FQDN matches instances with have the given fully qualified domain name.
-func FQDN(value string) Matcher {
-	return func(i Instance) bool {
-		return value == i.Config().ClusterLocalFQDN()
-	}
-}
-
-// SameDeployment matches instnaces with the same FQDN and assumes they're part of the same Service and Namespace.
-func SameDeployment(match Instance) Matcher {
-	return func(instance Instance) bool {
-		return match.Config().ClusterLocalFQDN() == instance.Config().ClusterLocalFQDN()
-	}
-}
-
-// Namespace matches instances within the given namespace name.
-func Namespace(namespace string) Matcher {
-	return func(i Instance) bool {
-		return i.Config().Namespace.Name() == namespace
-	}
-}
-
-// InCluster matches instances deployed on the given cluster.
-func InCluster(c cluster.Cluster) Matcher {
-	return func(i Instance) bool {
-		return c.Name() == i.Config().Cluster.Name()
-	}
-}
-
-// InNetwork matches instances deployed in the given network.
-func InNetwork(n string) Matcher {
-	return func(i Instance) bool {
-		return i.Config().Cluster.NetworkName() == n
-	}
-}
-
-// IsVirtualMachine matches instances with DeployAsVM
-func IsVirtualMachine() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsVM()
-	}
-}
-
-// IsExternal matches instances that have a custom DefaultHostHeader defined
-func IsExternal() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsExternal()
-	}
-}
-
-// IsNaked matches instances that are Pods with a SidecarInject annotation equal to false.
-func IsNaked() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsNaked()
-	}
-}
-
-// IsHeadless matches instances that are backed by headless services.
-func IsHeadless() Matcher {
-	return func(i Instance) bool {
-		return i.Config().Headless
-	}
-}
-
-// IsProxylessGRPC matches instances that are Pods with a SidecarInjectTemplate annotation equal to grpc.
-func IsProxylessGRPC() Matcher {
-	return func(i Instance) bool {
-		return i.Config().IsProxylessGRPC()
-	}
-}
-
 // Match filters instances that matcher the given Matcher
 func (i Instances) Match(matches Matcher) Instances {
 	out := make(Instances, 0)
diff --git a/pkg/test/framework/components/echo/kube/deployment.go b/pkg/test/framework/components/echo/kube/deployment.go
index efa66d4364..793b56ae50 100644
--- a/pkg/test/framework/components/echo/kube/deployment.go
+++ b/pkg/test/framework/components/echo/kube/deployment.go
@@ -41,7 +41,6 @@
 	"istio.io/istio/pkg/test/framework/components/environment/kube"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istioctl"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/shell"
@@ -124,7 +123,7 @@
       labels:
         app: {{ $.Service }}
         version: {{ $subset.Version }}
-        test.istio.io/class: {{ $.Class }}
+        test.istio.io/class: {{ $.WorkloadClass }}
 {{- if $.Compatibility }}
         istio.io/rev: {{ $revision }}
 {{- end }}
@@ -141,9 +140,9 @@
 {{- if $.ServiceAccount }}
       serviceAccountName: {{ $.Service }}
 {{- end }}
-{{- if ne $.ImagePullSecret "" }}
+{{- if ne $.ImagePullSecretName "" }}
       imagePullSecrets:
-      - name: {{ $.ImagePullSecret }}
+      - name: {{ $.ImagePullSecretName }}
 {{- end }}
       containers:
 {{- if and
@@ -153,21 +152,21 @@
 }}
       - name: istio-proxy
         image: auto
-        imagePullPolicy: {{ $.PullPolicy }}
+        imagePullPolicy: {{ $.ImagePullPolicy }}
         securityContext: # to allow core dumps
           readOnlyRootFilesystem: false
 {{- end }}
 {{- if $.IncludeExtAuthz }}
       - name: ext-authz
         image: gcr.io/istio-testing/ext-authz:0.7
-        imagePullPolicy: {{ $.PullPolicy }}
+        imagePullPolicy: {{ $.ImagePullPolicy }}
         ports:
         - containerPort: 8000
         - containerPort: 9000
 {{- end }}
       - name: app
-        image: {{ $.Hub }}/app:{{ $.Tag }}
-        imagePullPolicy: {{ $.PullPolicy }}
+        image: {{ $.ImageHub }}/app:{{ $.ImageTag }}
+        imagePullPolicy: {{ $.ImagePullPolicy }}
         securityContext:
           runAsUser: 1338
           runAsGroup: 1338
@@ -348,14 +347,14 @@
           value: "1"
       # Disable service account mount, to mirror VM
       automountServiceAccountToken: false
-      {{- if $.ImagePullSecret }}
+      {{- if $.ImagePullSecretName }}
       imagePullSecrets:
-      - name: {{ $.ImagePullSecret }}
+      - name: {{ $.ImagePullSecretName }}
       {{- end }}
       containers:
       - name: istio-proxy
-        image: {{ $.Hub }}/{{ $.VM.Image }}:{{ $.Tag }}
-        imagePullPolicy: {{ $.PullPolicy }}
+        image: {{ $.ImageHub }}/{{ $.VM.Image }}:{{ $.ImageTag }}
+        imagePullPolicy: {{ $.ImagePullPolicy }}
         securityContext:
           capabilities:
             add:
@@ -508,7 +507,7 @@ func newDeployment(ctx resource.Context, cfg echo.Config) (*deployment, error) {
 		}
 	}
 
-	deploymentYAML, err := GenerateDeployment(cfg, nil, nil)
+	deploymentYAML, err := GenerateDeployment(cfg, nil)
 	if err != nil {
 		return nil, fmt.Errorf("failed generating echo deployment YAML for %s/%s: %v",
 			cfg.Namespace.Name(),
@@ -611,8 +610,8 @@ func (d *deployment) workloadEntryYAML(w *workload) string {
 `, name, podIP, sa, network, service, version)
 }
 
-func GenerateDeployment(cfg echo.Config, imgSettings *image.Settings, settings *resource.Settings) (string, error) {
-	params, err := templateParams(cfg, imgSettings, settings)
+func GenerateDeployment(cfg echo.Config, settings *resource.Settings) (string, error) {
+	params, err := templateParams(cfg, settings)
 	if err != nil {
 		return "", err
 	}
@@ -626,7 +625,7 @@ func GenerateDeployment(cfg echo.Config, imgSettings *image.Settings, settings *
 }
 
 func GenerateService(cfg echo.Config) (string, error) {
-	params, err := templateParams(cfg, nil, nil)
+	params, err := templateParams(cfg, nil)
 	if err != nil {
 		return "", err
 	}
@@ -644,7 +643,7 @@ func GenerateService(cfg echo.Config) (string, error) {
 	echo.Centos8:      "app_sidecar_centos_8",
 }
 
-func templateParams(cfg echo.Config, imgSettings *image.Settings, settings *resource.Settings) (map[string]interface{}, error) {
+func templateParams(cfg echo.Config, settings *resource.Settings) (map[string]interface{}, error) {
 	if settings == nil {
 		var err error
 		settings, err = resource.SettingsFromCommandLine("template")
@@ -652,13 +651,7 @@ func templateParams(cfg echo.Config, imgSettings *image.Settings, settings *reso
 			return nil, err
 		}
 	}
-	if imgSettings == nil {
-		var err error
-		imgSettings, err = image.SettingsFromCommandLine()
-		if err != nil {
-			return nil, err
-		}
-	}
+
 	supportStartupProbe := cfg.Cluster.MinKubeVersion(0)
 
 	vmImage := VMImages[cfg.VMDistro]
@@ -670,33 +663,33 @@ func templateParams(cfg echo.Config, imgSettings *image.Settings, settings *reso
 	if cfg.Namespace != nil {
 		namespace = cfg.Namespace.Name()
 	}
-	imagePullSecret, err := imgSettings.ImagePullSecretName()
+	imagePullSecretName, err := settings.Image.PullSecretName()
 	if err != nil {
 		return nil, err
 	}
 	params := map[string]interface{}{
-		"Hub":                imgSettings.Hub,
-		"Tag":                strings.TrimSuffix(imgSettings.Tag, "-distroless"),
-		"PullPolicy":         imgSettings.PullPolicy,
-		"Service":            cfg.Service,
-		"Version":            cfg.Version,
-		"Headless":           cfg.Headless,
-		"StatefulSet":        cfg.StatefulSet,
-		"ProxylessGRPC":      cfg.IsProxylessGRPC(),
-		"GRPCMagicPort":      grpcMagicPort,
-		"Locality":           cfg.Locality,
-		"ServiceAccount":     cfg.ServiceAccount,
-		"Ports":              cfg.Ports,
-		"WorkloadOnlyPorts":  cfg.WorkloadOnlyPorts,
-		"ContainerPorts":     getContainerPorts(cfg),
-		"ServiceAnnotations": cfg.ServiceAnnotations,
-		"Subsets":            cfg.Subsets,
-		"TLSSettings":        cfg.TLSSettings,
-		"Cluster":            cfg.Cluster.Name(),
-		"Namespace":          namespace,
-		"ImagePullSecret":    imagePullSecret,
-		"ReadinessTCPPort":   cfg.ReadinessTCPPort,
-		"ReadinessGRPCPort":  cfg.ReadinessGRPCPort,
+		"ImageHub":            settings.Image.Hub,
+		"ImageTag":            strings.TrimSuffix(settings.Image.Tag, "-distroless"),
+		"ImagePullPolicy":     settings.Image.PullPolicy,
+		"ImagePullSecretName": imagePullSecretName,
+		"Service":             cfg.Service,
+		"Version":             cfg.Version,
+		"Headless":            cfg.Headless,
+		"StatefulSet":         cfg.StatefulSet,
+		"ProxylessGRPC":       cfg.IsProxylessGRPC(),
+		"GRPCMagicPort":       grpcMagicPort,
+		"Locality":            cfg.Locality,
+		"ServiceAccount":      cfg.ServiceAccount,
+		"Ports":               cfg.Ports,
+		"WorkloadOnlyPorts":   cfg.WorkloadOnlyPorts,
+		"ContainerPorts":      getContainerPorts(cfg),
+		"ServiceAnnotations":  cfg.ServiceAnnotations,
+		"Subsets":             cfg.Subsets,
+		"TLSSettings":         cfg.TLSSettings,
+		"Cluster":             cfg.Cluster.Name(),
+		"Namespace":           namespace,
+		"ReadinessTCPPort":    cfg.ReadinessTCPPort,
+		"ReadinessGRPCPort":   cfg.ReadinessGRPCPort,
 		"VM": map[string]interface{}{
 			"Image": vmImage,
 		},
@@ -704,7 +697,7 @@ func templateParams(cfg echo.Config, imgSettings *image.Settings, settings *reso
 		"IncludeExtAuthz":   cfg.IncludeExtAuthz,
 		"Revisions":         settings.Revisions.TemplateMap(),
 		"Compatibility":     settings.Compatibility,
-		"Class":             cfg.Class(),
+		"WorkloadClass":     cfg.WorkloadClass(),
 		"OverlayIstioProxy": canCreateIstioProxy(settings.Revisions.Minimum()),
 	}
 	return params, nil
@@ -742,9 +735,9 @@ func createVMConfig(ctx resource.Context, cfg echo.Config) error {
   metadata:
     labels:
       app: {{.name}}
-      test.istio.io/class: {{ .class }}
+      test.istio.io/class: {{ .workloadClass }}
   template:
-    serviceAccount: {{.serviceaccount}}
+    serviceAccount: {{.serviceAccount}}
     network: "{{.network}}"
   probe:
     failureThreshold: 5
@@ -758,9 +751,9 @@ func createVMConfig(ctx resource.Context, cfg echo.Config) error {
 `, map[string]string{
 		"name":           cfg.Service,
 		"namespace":      cfg.Namespace.Name(),
-		"serviceaccount": serviceAccount(cfg),
+		"serviceAccount": serviceAccount(cfg),
 		"network":        cfg.Cluster.NetworkName(),
-		"class":          cfg.Class(),
+		"workloadClass":  cfg.WorkloadClass(),
 	})
 
 	// Push the WorkloadGroup for auto-registration
diff --git a/pkg/test/framework/components/echo/kube/deployment_test.go b/pkg/test/framework/components/echo/kube/deployment_test.go
index 02f6821af4..d80fa93499 100644
--- a/pkg/test/framework/components/echo/kube/deployment_test.go
+++ b/pkg/test/framework/components/echo/kube/deployment_test.go
@@ -21,19 +21,10 @@
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/cluster/clusterboot"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/config"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 )
 
-var imgSettings = &image.Settings{
-	Hub:             "testing.hub",
-	Tag:             "latest",
-	PullPolicy:      "Always",
-	ImagePullSecret: "testdata/secret.yaml",
-}
-
 func TestDeploymentYAML(t *testing.T) {
 	testCase := []struct {
 		name          string
@@ -189,7 +180,7 @@ func TestDeploymentYAML(t *testing.T) {
 				t.Fatal(err)
 			}
 			tc.config.Cluster = clusters[0]
-			if err := common.FillInDefaults(nil, &tc.config); err != nil {
+			if err := tc.config.FillDefaults(nil); err != nil {
 				t.Errorf("failed filling in defaults: %v", err)
 			}
 			if !config.Parsed() {
@@ -198,12 +189,18 @@ func TestDeploymentYAML(t *testing.T) {
 			settings := &resource.Settings{
 				Revisions:     tc.revVerMap,
 				Compatibility: tc.compatibility,
+				Image: resource.ImageSettings{
+					Hub:        "testing.hub",
+					Tag:        "latest",
+					PullPolicy: "Always",
+					PullSecret: "testdata/secret.yaml",
+				},
 			}
 			serviceYAML, err := GenerateService(tc.config)
 			if err != nil {
 				t.Errorf("failed to generate service %v", err)
 			}
-			deploymentYAML, err := GenerateDeployment(tc.config, imgSettings, settings)
+			deploymentYAML, err := GenerateDeployment(tc.config, settings)
 			if err != nil {
 				t.Errorf("failed to generate deployment %v", err)
 			}
diff --git a/pkg/test/framework/components/echo/kube/workload_manager.go b/pkg/test/framework/components/echo/kube/workload_manager.go
index 3ea1255a6f..2ed7eacdbb 100644
--- a/pkg/test/framework/components/echo/kube/workload_manager.go
+++ b/pkg/test/framework/components/echo/kube/workload_manager.go
@@ -26,7 +26,6 @@
 	"istio.io/istio/pkg/config/protocol"
 	echoCommon "istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/util/retry"
 )
@@ -62,7 +61,7 @@ func newWorkloadManager(ctx resource.Context, cfg echo.Config, handler workloadH
 		grpcInstancePort = grpcMagicPort
 	}
 	if grpcInstancePort == 0 {
-		grpcPort := common.GetPortForProtocol(&cfg, protocol.GRPC)
+		grpcPort := cfg.GetPortForProtocol(protocol.GRPC)
 		if grpcPort.TLS {
 			tls = cfg.TLSSettings
 		}
diff --git a/pkg/test/framework/components/echo/echotypes/types.go b/pkg/test/framework/components/echo/matcher.go
similarity index 57%
copy from pkg/test/framework/components/echo/echotypes/types.go
copy to pkg/test/framework/components/echo/matcher.go
index f415a8e753..f3f09b340b 100644
--- a/pkg/test/framework/components/echo/echotypes/types.go
+++ b/pkg/test/framework/components/echo/matcher.go
@@ -12,20 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// echotypes exists to avoid cyclical imports
-package echotypes
+package echo
 
-// Class is the class of workload in the echo instance
-type Class = string
-
-const (
-	Proxyless   Class = "proxyless"
-	VM          Class = "vm"
-	Delta       Class = "delta"
-	TProxy      Class = "tproxy"
-	Naked       Class = "naked"
-	External    Class = "external"
-	StatefulSet Class = "statefulset"
-	Headless    Class = "headless"
-	Standard    Class = "standard"
-)
+// Matcher is used to filter matching instances
+type Matcher func(Instance) bool
diff --git a/pkg/test/framework/components/echo/matchers.go b/pkg/test/framework/components/echo/matchers.go
new file mode 100644
index 0000000000..25e66c954a
--- /dev/null
+++ b/pkg/test/framework/components/echo/matchers.go
@@ -0,0 +1,126 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echo
+
+import (
+	"strings"
+
+	"istio.io/istio/pkg/test/framework/components/cluster"
+)
+
+// Any doesn't filter out any echos.
+var Any Matcher = func(_ Instance) bool {
+	return true
+}
+
+// And combines two or more matches. Example:
+//     Service("a").And(InCluster(c)).And(Match(func(...))
+func (m Matcher) And(other Matcher) Matcher {
+	return func(i Instance) bool {
+		return m(i) && other(i)
+	}
+}
+
+// Not negates the given matcher. Example:
+//     Not(IsNaked())
+func Not(m Matcher) Matcher {
+	return func(i Instance) bool {
+		return !m(i)
+	}
+}
+
+// ServicePrefix matches instances whose service name starts with the given prefix.
+func ServicePrefix(prefix string) Matcher {
+	return func(i Instance) bool {
+		return strings.HasPrefix(i.Config().Service, prefix)
+	}
+}
+
+// Service matches instances with have the given service name.
+func Service(value string) Matcher {
+	return func(i Instance) bool {
+		return value == i.Config().Service
+	}
+}
+
+// FQDN matches instances with have the given fully qualified domain name.
+func FQDN(value string) Matcher {
+	return func(i Instance) bool {
+		return value == i.Config().ClusterLocalFQDN()
+	}
+}
+
+// SameDeployment matches instnaces with the same FQDN and assumes they're part of the same Service and Namespace.
+func SameDeployment(match Instance) Matcher {
+	return func(instance Instance) bool {
+		return match.Config().ClusterLocalFQDN() == instance.Config().ClusterLocalFQDN()
+	}
+}
+
+// Namespace matches instances within the given namespace name.
+func Namespace(namespace string) Matcher {
+	return func(i Instance) bool {
+		return i.Config().Namespace.Name() == namespace
+	}
+}
+
+// InCluster matches instances deployed on the given cluster.
+func InCluster(c cluster.Cluster) Matcher {
+	return func(i Instance) bool {
+		return c.Name() == i.Config().Cluster.Name()
+	}
+}
+
+// InNetwork matches instances deployed in the given network.
+func InNetwork(n string) Matcher {
+	return func(i Instance) bool {
+		return i.Config().Cluster.NetworkName() == n
+	}
+}
+
+// IsVirtualMachine matches instances with DeployAsVM
+func IsVirtualMachine() Matcher {
+	return func(i Instance) bool {
+		return i.Config().IsVM()
+	}
+}
+
+// IsExternal matches instances that have a custom DefaultHostHeader defined
+func IsExternal() Matcher {
+	return func(i Instance) bool {
+		return i.Config().IsExternal()
+	}
+}
+
+// IsNaked matches instances that are Pods with a SidecarInject annotation equal to false.
+func IsNaked() Matcher {
+	return func(i Instance) bool {
+		return i.Config().IsNaked()
+	}
+}
+
+// IsHeadless matches instances that are backed by headless services.
+func IsHeadless() Matcher {
+	return func(i Instance) bool {
+		return i.Config().Headless
+	}
+}
+
+// IsProxylessGRPC matches instances that are Pods with a SidecarInjectTemplate annotation equal to grpc.
+func IsProxylessGRPC() Matcher {
+	return func(i Instance) bool {
+		return i.Config().IsProxylessGRPC()
+	}
+}
diff --git a/pkg/test/framework/components/echo/port.go b/pkg/test/framework/components/echo/port.go
new file mode 100644
index 0000000000..a3d51c9ae4
--- /dev/null
+++ b/pkg/test/framework/components/echo/port.go
@@ -0,0 +1,69 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echo
+
+import (
+	"fmt"
+
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test/echo/common/scheme"
+)
+
+// Port exposed by an Echo Instance
+type Port struct {
+	// Name of this port
+	Name string
+
+	// Protocol to be used for the port.
+	Protocol protocol.Instance
+
+	// ServicePort number where the service can be reached. Does not necessarily
+	// map to the corresponding port numbers for the instances behind the
+	// service.
+	ServicePort int
+
+	// InstancePort number where this instance is listening for connections.
+	// This need not be the same as the ServicePort where the service is accessed.
+	InstancePort int
+
+	// TLS determines whether the connection will be plain text or TLS. By default this is false (plain text).
+	TLS bool
+
+	// ServerFirst determines whether the port will use server first communication, meaning the client will not send the first byte.
+	ServerFirst bool
+
+	// InstanceIP determines if echo will listen on the instance IP; otherwise, it will listen on wildcard
+	InstanceIP bool
+
+	// LocalhostIP determines if echo will listen on the localhost IP; otherwise, it will listen on wildcard
+	LocalhostIP bool
+}
+
+// Scheme infers the scheme to be used based on the Protocol.
+func (p Port) Scheme() (scheme.Instance, error) {
+	switch p.Protocol {
+	case protocol.GRPC, protocol.GRPCWeb, protocol.HTTP2:
+		return scheme.GRPC, nil
+	case protocol.HTTP:
+		return scheme.HTTP, nil
+	case protocol.HTTPS:
+		return scheme.HTTPS, nil
+	case protocol.TCP:
+		return scheme.TCP, nil
+	default:
+		return "", fmt.Errorf("failed creating call for port %s: unsupported protocol %s",
+			p.Name, p.Protocol)
+	}
+}
diff --git a/pkg/test/framework/components/echo/common/portgen.go b/pkg/test/framework/components/echo/portgen.go
similarity index 99%
rename from pkg/test/framework/components/echo/common/portgen.go
rename to pkg/test/framework/components/echo/portgen.go
index ec82a2690f..847e5eeb77 100644
--- a/pkg/test/framework/components/echo/common/portgen.go
+++ b/pkg/test/framework/components/echo/portgen.go
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package common
+package echo
 
 import (
 	"math"
diff --git a/pkg/test/framework/components/echo/sidecar.go b/pkg/test/framework/components/echo/sidecar.go
new file mode 100644
index 0000000000..2631cc6c1e
--- /dev/null
+++ b/pkg/test/framework/components/echo/sidecar.go
@@ -0,0 +1,55 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echo
+
+import (
+	envoyAdmin "github.com/envoyproxy/go-control-plane/envoy/admin/v3"
+	dto "github.com/prometheus/client_model/go"
+
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/util/retry"
+)
+
+// Sidecar provides an interface to execute queries against a single Envoy sidecar.
+type Sidecar interface {
+	// Info about the Envoy instance.
+	Info() (*envoyAdmin.ServerInfo, error)
+	InfoOrFail(t test.Failer) *envoyAdmin.ServerInfo
+
+	// Config of the Envoy instance.
+	Config() (*envoyAdmin.ConfigDump, error)
+	ConfigOrFail(t test.Failer) *envoyAdmin.ConfigDump
+
+	// WaitForConfig queries the Envoy configuration an executes the given accept handler. If the
+	// response is not accepted, the request will be retried until either a timeout or a response
+	// has been accepted.
+	WaitForConfig(accept func(*envoyAdmin.ConfigDump) (bool, error), options ...retry.Option) error
+	WaitForConfigOrFail(t test.Failer, accept func(*envoyAdmin.ConfigDump) (bool, error), options ...retry.Option)
+
+	// Clusters for the Envoy instance
+	Clusters() (*envoyAdmin.Clusters, error)
+	ClustersOrFail(t test.Failer) *envoyAdmin.Clusters
+
+	// Listeners for the Envoy instance
+	Listeners() (*envoyAdmin.Listeners, error)
+	ListenersOrFail(t test.Failer) *envoyAdmin.Listeners
+
+	// Logs returns the logs for the sidecar container
+	Logs() (string, error)
+	// LogsOrFail returns the logs for the sidecar container, or aborts if an error is found
+	LogsOrFail(t test.Failer) string
+	Stats() (map[string]*dto.MetricFamily, error)
+	StatsOrFail(t test.Failer) map[string]*dto.MetricFamily
+}
diff --git a/pkg/test/framework/components/echo/staticvm/instance.go b/pkg/test/framework/components/echo/staticvm/instance.go
index 0b179dec96..eb71d9c949 100644
--- a/pkg/test/framework/components/echo/staticvm/instance.go
+++ b/pkg/test/framework/components/echo/staticvm/instance.go
@@ -72,7 +72,7 @@ func newInstances(ctx resource.Context, config []echo.Config) (echo.Instances, e
 func newInstance(ctx resource.Context, config echo.Config) (echo.Instance, error) {
 	// TODO is there a need for static cluster to create workload group/entry?
 
-	grpcPort := common.GetPortForProtocol(&config, protocol.GRPC)
+	grpcPort := config.GetPortForProtocol(protocol.GRPC)
 	if grpcPort == nil {
 		return nil, errors.New("unable fo find GRPC command port")
 	}
diff --git a/pkg/test/framework/components/echo/workload.go b/pkg/test/framework/components/echo/workload.go
new file mode 100644
index 0000000000..628fd6cbc4
--- /dev/null
+++ b/pkg/test/framework/components/echo/workload.go
@@ -0,0 +1,42 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package echo
+
+import (
+	"context"
+
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/echo"
+	"istio.io/istio/pkg/test/echo/proto"
+)
+
+// Workload provides an interface for a single deployed echo server.
+type Workload interface {
+	// PodName gets the original pod name for the workload.
+	PodName() string
+	// Address returns the network address of the endpoint.
+	Address() string
+
+	// Sidecar if one was specified.
+	Sidecar() Sidecar
+
+	// ForwardEcho executes specific call from this workload.
+	ForwardEcho(context.Context, *proto.ForwardEchoRequest) (echo.Responses, error)
+
+	// Logs returns the logs for the app container
+	Logs() (string, error)
+	// LogsOrFail returns the logs for the app container, or aborts if an error is found
+	LogsOrFail(t test.Failer) string
+}
diff --git a/pkg/test/framework/components/echo/echotypes/types.go b/pkg/test/framework/components/echo/workloadclass.go
similarity index 56%
rename from pkg/test/framework/components/echo/echotypes/types.go
rename to pkg/test/framework/components/echo/workloadclass.go
index f415a8e753..14dbec5aba 100644
--- a/pkg/test/framework/components/echo/echotypes/types.go
+++ b/pkg/test/framework/components/echo/workloadclass.go
@@ -12,20 +12,19 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// echotypes exists to avoid cyclical imports
-package echotypes
+package echo
 
-// Class is the class of workload in the echo instance
-type Class = string
+// WorkloadClass is the class of workload in the echo instance
+type WorkloadClass = string
 
 const (
-	Proxyless   Class = "proxyless"
-	VM          Class = "vm"
-	Delta       Class = "delta"
-	TProxy      Class = "tproxy"
-	Naked       Class = "naked"
-	External    Class = "external"
-	StatefulSet Class = "statefulset"
-	Headless    Class = "headless"
-	Standard    Class = "standard"
+	Proxyless   WorkloadClass = "proxyless"
+	VM          WorkloadClass = "vm"
+	Delta       WorkloadClass = "delta"
+	TProxy      WorkloadClass = "tproxy"
+	Naked       WorkloadClass = "naked"
+	External    WorkloadClass = "external"
+	StatefulSet WorkloadClass = "statefulset"
+	Headless    WorkloadClass = "headless"
+	Standard    WorkloadClass = "standard"
 )
diff --git a/pkg/test/framework/components/istio/config.go b/pkg/test/framework/components/istio/config.go
index f16e0ae3ab..d45069cf24 100644
--- a/pkg/test/framework/components/istio/config.go
+++ b/pkg/test/framework/components/istio/config.go
@@ -26,7 +26,6 @@
 	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/scopes"
 )
@@ -61,6 +60,15 @@
 	// IntegrationTestExternalIstiodConfigDefaultsIOP is the path of the default IstioOperator spec to use
 	// on external istiod config clusters for integration tests
 	IntegrationTestExternalIstiodConfigDefaultsIOP = "tests/integration/iop-externalistiod-config-integration-test-defaults.yaml"
+
+	// hubValuesKey values key for the Docker image hub.
+	hubValuesKey = "global.hub"
+
+	// tagValuesKey values key for the Docker image tag.
+	tagValuesKey = "global.tag"
+
+	// imagePullPolicyValuesKey values key for the Docker image pull policy.
+	imagePullPolicyValuesKey = "global.imagePullPolicy"
 )
 
 var (
@@ -147,30 +155,20 @@ type Config struct {
 	EnableCNI bool
 }
 
-func (c *Config) OverridesYAML() string {
-	s, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return ""
-	}
-
+func (c *Config) OverridesYAML(s *resource.Settings) string {
 	return fmt.Sprintf(`
 global:
   hub: %s
   tag: %s
-`, s.Hub, s.Tag)
+`, s.Image.Hub, s.Image.Tag)
 }
 
-func (c *Config) IstioOperatorConfigYAML(iopYaml string) string {
+func (c *Config) IstioOperatorConfigYAML(s *resource.Settings, iopYaml string) string {
 	data := ""
 	if iopYaml != "" {
 		data = Indent(iopYaml, "  ")
 	}
 
-	s, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return ""
-	}
-
 	return fmt.Sprintf(`
 apiVersion: install.istio.io/v1alpha1
 kind: IstioOperator
@@ -178,7 +176,7 @@ func (c *Config) IstioOperatorConfigYAML(iopYaml string) string {
   hub: %s
   tag: %s
 %s
-`, s.Hub, s.Tag, data)
+`, s.Image.Hub, s.Image.Tag, data)
 }
 
 // Indent indents a block of text with an indent string
@@ -211,12 +209,8 @@ func DefaultConfig(ctx resource.Context) (Config, error) {
 		scopes.Framework.Warnf("Default IOPFile missing: %v", err)
 	}
 
-	deps, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return Config{}, err
-	}
-
-	if s.Values, err = newHelmValues(ctx, deps); err != nil {
+	var err error
+	if s.Values, err = newHelmValues(ctx); err != nil {
 		return Config{}, err
 	}
 
@@ -243,7 +237,7 @@ func checkFileExists(path string) error {
 	return nil
 }
 
-func newHelmValues(ctx resource.Context, s *image.Settings) (map[string]string, error) {
+func newHelmValues(ctx resource.Context) (map[string]string, error) {
 	userValues, err := parseConfigOptions(helmValues)
 	if err != nil {
 		return nil, err
@@ -253,9 +247,10 @@ func newHelmValues(ctx resource.Context, s *image.Settings) (map[string]string,
 	values := make(map[string]string)
 
 	// Common values
-	values[image.HubValuesKey] = s.Hub
-	values[image.TagValuesKey] = s.Tag
-	values[image.ImagePullPolicyValuesKey] = s.PullPolicy
+	s := ctx.Settings()
+	values[hubValuesKey] = s.Image.Hub
+	values[tagValuesKey] = s.Image.Tag
+	values[imagePullPolicyValuesKey] = s.Image.PullPolicy
 
 	// Copy the user values.
 	for k, v := range userValues {
@@ -263,8 +258,8 @@ func newHelmValues(ctx resource.Context, s *image.Settings) (map[string]string,
 	}
 
 	// Always pull Docker images if using the "latest".
-	if values[image.TagValuesKey] == image.LatestTag {
-		values[image.ImagePullPolicyValuesKey] = string(kubeCore.PullAlways)
+	if values[tagValuesKey] == "latest" {
+		values[imagePullPolicyValuesKey] = string(kubeCore.PullAlways)
 	}
 
 	// We need more information on Envoy logs to detect usage of any deprecated feature
diff --git a/pkg/test/framework/components/istio/eastwest.go b/pkg/test/framework/components/istio/eastwest.go
index 58b0e4aa8c..36135d71da 100644
--- a/pkg/test/framework/components/istio/eastwest.go
+++ b/pkg/test/framework/components/istio/eastwest.go
@@ -29,7 +29,6 @@
 	"istio.io/istio/operator/cmd/mesh"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/components/cluster"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/pkg/test/util/tmpl"
@@ -45,11 +44,6 @@
 
 // deployEastWestGateway will create a separate gateway deployment for cross-cluster discovery or cross-network services.
 func (i *operatorComponent) deployEastWestGateway(cluster cluster.Cluster, revision string) error {
-	imgSettings, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return err
-	}
-
 	// generate istio operator yaml
 	args := []string{
 		"--cluster", cluster.Name(),
@@ -71,12 +65,13 @@ func (i *operatorComponent) deployEastWestGateway(cluster cluster.Cluster, revis
 	}
 
 	// Save the manifest generate output so we can later cleanup
+	s := i.ctx.Settings()
 	manifestGenArgs := &mesh.ManifestGenerateArgs{
 		InFilenames: []string{iopFile},
 		Set: []string{
-			"hub=" + imgSettings.Hub,
-			"tag=" + imgSettings.Tag,
-			"values.global.imagePullPolicy=" + imgSettings.PullPolicy,
+			"hub=" + s.Image.Hub,
+			"tag=" + s.Image.Tag,
+			"values.global.imagePullPolicy=" + s.Image.PullPolicy,
 			"values.gateways.istio-ingressgateway.autoscaleEnabled=false",
 		},
 		ManifestsPath: filepath.Join(env.IstioSrc, "manifests"),
diff --git a/pkg/test/framework/components/istio/ingress.go b/pkg/test/framework/components/istio/ingress.go
index 27b400de35..1424fda2e6 100644
--- a/pkg/test/framework/components/istio/ingress.go
+++ b/pkg/test/framework/components/istio/ingress.go
@@ -23,6 +23,7 @@
 	"time"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -231,14 +232,14 @@ func (c *ingressImpl) callEcho(options echo.CallOptions, retry bool, retryOption
 		// Default address based on port
 		options.Address = addr
 	}
-	if options.Headers == nil {
-		options.Headers = map[string][]string{}
+	if options.HTTP.Headers == nil {
+		options.HTTP.Headers = map[string][]string{}
 	}
 	if host := options.GetHost(); len(host) > 0 {
-		options.Headers["Host"] = []string{host}
+		options.HTTP.Headers.Set(headers.Host, host)
 	}
 	if len(c.cluster.HTTPProxy()) > 0 {
-		options.HTTPProxy = c.cluster.HTTPProxy()
+		options.HTTP.HTTPProxy = c.cluster.HTTPProxy()
 	}
 	return common.CallEcho(&options, retry, retryOptions...)
 }
diff --git a/pkg/test/framework/components/istio/operator.go b/pkg/test/framework/components/istio/operator.go
index ddf03e7f49..27f24f711f 100644
--- a/pkg/test/framework/components/istio/operator.go
+++ b/pkg/test/framework/components/istio/operator.go
@@ -48,7 +48,6 @@
 	"istio.io/istio/pkg/test/framework/components/environment/kube"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/istioctl"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	kube2 "istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/scopes"
@@ -319,7 +318,7 @@ func deploy(ctx resource.Context, env *kube.Environment, cfg Config) (Instance,
 	i.workDir = workDir
 
 	// generate common IstioOperator yamls for different cluster types (primary, remote, remote-config)
-	istioctlConfigFiles, err := createIstioctlConfigFile(workDir, cfg)
+	istioctlConfigFiles, err := createIstioctlConfigFile(ctx.Settings(), workDir, cfg)
 	if err != nil {
 		return nil, err
 	}
@@ -333,8 +332,9 @@ func deploy(ctx resource.Context, env *kube.Environment, cfg Config) (Instance,
 
 	// First install remote-config clusters.
 	// We do this first because the external istiod needs to read the config cluster at startup.
+	s := ctx.Settings()
 	for _, c := range ctx.Clusters().Kube().Configs().Remotes() {
-		if err = installConfigCluster(i, cfg, c, istioctlConfigFiles.configIopFile); err != nil {
+		if err = installConfigCluster(s, i, cfg, c, istioctlConfigFiles.configIopFile); err != nil {
 			return i, err
 		}
 	}
@@ -344,7 +344,7 @@ func deploy(ctx resource.Context, env *kube.Environment, cfg Config) (Instance,
 	for _, c := range ctx.AllClusters().Kube().Primaries() {
 		c := c
 		errG.Go(func() error {
-			return installControlPlaneCluster(i, cfg, c, istioctlConfigFiles.iopFile, istioctlConfigFiles.operatorSpec)
+			return installControlPlaneCluster(s, i, cfg, c, istioctlConfigFiles.iopFile, istioctlConfigFiles.operatorSpec)
 		})
 	}
 	if err := errG.Wait(); err != nil {
@@ -367,7 +367,7 @@ func deploy(ctx resource.Context, env *kube.Environment, cfg Config) (Instance,
 	for _, c := range ctx.Clusters().Kube().Remotes(ctx.Clusters().Configs()...) {
 		c := c
 		errG.Go(func() error {
-			if err := installRemoteCluster(i, cfg, c, istioctlConfigFiles.remoteIopFile); err != nil {
+			if err := installRemoteCluster(s, i, cfg, c, istioctlConfigFiles.remoteIopFile); err != nil {
 				return fmt.Errorf("failed installing remote cluster %s: %v", c.Name(), err)
 			}
 			return nil
@@ -390,7 +390,7 @@ func deploy(ctx resource.Context, env *kube.Environment, cfg Config) (Instance,
 			// before the external control plane cluster. Since remote clusters use gateway injection, we can't install the gateways
 			// until after the control plane is running, so we install them here. This is not really necessary for pure (non-config)
 			// remote clusters, but it's cleaner to just install gateways as a separate step for all remote clusters.
-			if err = installRemoteClusterGateways(i, c); err != nil {
+			if err = installRemoteClusterGateways(s, i, c); err != nil {
 				return i, err
 			}
 		}
@@ -483,8 +483,8 @@ func patchIstiodCustomHost(istiodAddress net.TCPAddr, cfg Config, c cluster.Clus
 	return nil
 }
 
-func initIOPFile(cfg Config, iopFile string, valuesYaml string) (*opAPI.IstioOperatorSpec, error) {
-	operatorYaml := cfg.IstioOperatorConfigYAML(valuesYaml)
+func initIOPFile(s *resource.Settings, cfg Config, iopFile string, valuesYaml string) (*opAPI.IstioOperatorSpec, error) {
+	operatorYaml := cfg.IstioOperatorConfigYAML(s, valuesYaml)
 
 	operatorCfg := &pkgAPI.IstioOperator{}
 	if err := gogoprotomarshal.ApplyYAML(operatorYaml, operatorCfg); err != nil {
@@ -529,7 +529,7 @@ func initIOPFile(cfg Config, iopFile string, valuesYaml string) (*opAPI.IstioOpe
 // installControlPlaneCluster installs the istiod control plane to the given cluster.
 // The cluster is considered a "primary" cluster if it is also a "config cluster", in which case components
 // like ingress will be installed.
-func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Cluster, iopFile string,
+func installControlPlaneCluster(s *resource.Settings, i *operatorComponent, cfg Config, c cluster.Cluster, iopFile string,
 	spec *opAPI.IstioOperatorSpec) error {
 	scopes.Framework.Infof("setting up %s as control-plane cluster", c.Name())
 
@@ -538,7 +538,7 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 			return err
 		}
 	}
-	installArgs, err := i.generateCommonInstallArgs(cfg, c, cfg.PrimaryClusterIOPFile, iopFile)
+	installArgs, err := i.generateCommonInstallArgs(s, cfg, c, cfg.PrimaryClusterIOPFile, iopFile)
 	if err != nil {
 		return err
 	}
@@ -613,20 +613,20 @@ func installControlPlaneCluster(i *operatorComponent, cfg Config, c cluster.Clus
 
 // installConfigCluster installs istio to a cluster that runs workloads and provides Istio configuration.
 // The installed components include CRDs, Roles, etc. but not istiod.
-func installConfigCluster(i *operatorComponent, cfg Config, c cluster.Cluster, configIopFile string) error {
+func installConfigCluster(s *resource.Settings, i *operatorComponent, cfg Config, c cluster.Cluster, configIopFile string) error {
 	scopes.Framework.Infof("setting up %s as config cluster", c.Name())
-	return installRemoteCommon(i, cfg, c, cfg.ConfigClusterIOPFile, configIopFile)
+	return installRemoteCommon(s, i, cfg, c, cfg.ConfigClusterIOPFile, configIopFile)
 }
 
 // installRemoteCluster installs istio to a remote cluster that does not also serve as a config cluster.
-func installRemoteCluster(i *operatorComponent, cfg Config, c cluster.Cluster, remoteIopFile string) error {
+func installRemoteCluster(s *resource.Settings, i *operatorComponent, cfg Config, c cluster.Cluster, remoteIopFile string) error {
 	scopes.Framework.Infof("setting up %s as remote cluster", c.Name())
-	return installRemoteCommon(i, cfg, c, cfg.RemoteClusterIOPFile, remoteIopFile)
+	return installRemoteCommon(s, i, cfg, c, cfg.RemoteClusterIOPFile, remoteIopFile)
 }
 
 // Common install on a either a remote-config or pure remote cluster.
-func installRemoteCommon(i *operatorComponent, cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) error {
-	installArgs, err := i.generateCommonInstallArgs(cfg, c, defaultsIOPFile, iopFile)
+func installRemoteCommon(s *resource.Settings, i *operatorComponent, cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) error {
+	installArgs, err := i.generateCommonInstallArgs(s, cfg, c, defaultsIOPFile, iopFile)
 	if err != nil {
 		return err
 	}
@@ -660,12 +660,7 @@ func installRemoteCommon(i *operatorComponent, cfg Config, c cluster.Cluster, de
 	return nil
 }
 
-func installRemoteClusterGateways(i *operatorComponent, c cluster.Cluster) error {
-	s, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return err
-	}
-
+func installRemoteClusterGateways(s *resource.Settings, i *operatorComponent, c cluster.Cluster) error {
 	kubeConfigFile, err := kubeConfigFileForCluster(c)
 	if err != nil {
 		return err
@@ -678,7 +673,7 @@ func installRemoteClusterGateways(i *operatorComponent, c cluster.Cluster) error
 			filepath.Join(testenv.IstioSrc, IntegrationTestRemoteGatewaysIOP),
 		},
 		Set: []string{
-			"values.global.imagePullPolicy=" + s.PullPolicy,
+			"values.global.imagePullPolicy=" + s.Image.PullPolicy,
 		},
 	}
 
@@ -701,12 +696,8 @@ type Filenamer interface {
 	return fn.Filename(), nil
 }
 
-func (i *operatorComponent) generateCommonInstallArgs(cfg Config, c cluster.Cluster, defaultsIOPFile, iopFile string) (*mesh.InstallArgs, error) {
-	s, err := image.SettingsFromCommandLine()
-	if err != nil {
-		return nil, err
-	}
-
+func (i *operatorComponent) generateCommonInstallArgs(s *resource.Settings, cfg Config, c cluster.Cluster, defaultsIOPFile,
+	iopFile string) (*mesh.InstallArgs, error) {
 	kubeConfigFile, err := kubeConfigFileForCluster(c)
 	if err != nil {
 		return nil, err
@@ -729,7 +720,7 @@ func (i *operatorComponent) generateCommonInstallArgs(cfg Config, c cluster.Clus
 			iopFile,
 		},
 		Set: []string{
-			"values.global.imagePullPolicy=" + s.PullPolicy,
+			"values.global.imagePullPolicy=" + s.Image.PullPolicy,
 		},
 	}
 
@@ -1103,7 +1094,7 @@ func (i *operatorComponent) configureRemoteConfigForControlPlane(c cluster.Clust
 	return nil
 }
 
-func createIstioctlConfigFile(workDir string, cfg Config) (istioctlConfigFiles, error) {
+func createIstioctlConfigFile(s *resource.Settings, workDir string, cfg Config) (istioctlConfigFiles, error) {
 	var err error
 	configFiles := istioctlConfigFiles{
 		iopFile:       "",
@@ -1112,7 +1103,7 @@ func createIstioctlConfigFile(workDir string, cfg Config) (istioctlConfigFiles,
 	}
 	// Generate the istioctl config file for control plane(primary) cluster
 	configFiles.iopFile = filepath.Join(workDir, "iop.yaml")
-	if configFiles.operatorSpec, err = initIOPFile(cfg, configFiles.iopFile, cfg.ControlPlaneValues); err != nil {
+	if configFiles.operatorSpec, err = initIOPFile(s, cfg, configFiles.iopFile, cfg.ControlPlaneValues); err != nil {
 		return configFiles, err
 	}
 
@@ -1122,7 +1113,7 @@ func createIstioctlConfigFile(workDir string, cfg Config) (istioctlConfigFiles,
 	}
 
 	configFiles.remoteIopFile = filepath.Join(workDir, "remote.yaml")
-	if configFiles.remoteOperatorSpec, err = initIOPFile(cfg, configFiles.remoteIopFile, cfg.RemoteClusterValues); err != nil {
+	if configFiles.remoteOperatorSpec, err = initIOPFile(s, cfg, configFiles.remoteIopFile, cfg.RemoteClusterValues); err != nil {
 		return configFiles, err
 	}
 
@@ -1131,7 +1122,7 @@ func createIstioctlConfigFile(workDir string, cfg Config) (istioctlConfigFiles,
 	configFiles.configOperatorSpec = configFiles.operatorSpec
 	if cfg.ConfigClusterValues != "" {
 		configFiles.configIopFile = filepath.Join(workDir, "config.yaml")
-		if configFiles.configOperatorSpec, err = initIOPFile(cfg, configFiles.configIopFile, cfg.ConfigClusterValues); err != nil {
+		if configFiles.configOperatorSpec, err = initIOPFile(s, cfg, configFiles.configIopFile, cfg.ConfigClusterValues); err != nil {
 			return configFiles, err
 		}
 	}
diff --git a/pkg/test/framework/components/namespace/kube.go b/pkg/test/framework/components/namespace/kube.go
index 6d365a1d00..a1710355dc 100644
--- a/pkg/test/framework/components/namespace/kube.go
+++ b/pkg/test/framework/components/namespace/kube.go
@@ -30,7 +30,6 @@
 	"k8s.io/apimachinery/pkg/types"
 
 	"istio.io/api/label"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	kube2 "istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/scopes"
@@ -196,6 +195,7 @@ func newKube(ctx resource.Context, nsConfig *Config) (Instance, error) {
 	id := ctx.TrackResource(n)
 	n.id = id
 
+	s := ctx.Settings()
 	for _, cluster := range n.ctx.Clusters().Kube() {
 		if _, err := cluster.CoreV1().Namespaces().Create(context.TODO(), &kubeApiCore.Namespace{
 			ObjectMeta: metav1.ObjectMeta{
@@ -205,12 +205,8 @@ func newKube(ctx resource.Context, nsConfig *Config) (Instance, error) {
 		}, metav1.CreateOptions{}); err != nil {
 			return nil, err
 		}
-		settings, err := image.SettingsFromCommandLine()
-		if err != nil {
-			return nil, err
-		}
-		if settings.ImagePullSecret != "" {
-			if err := cluster.ApplyYAMLFiles(n.name, settings.ImagePullSecret); err != nil {
+		if s.Image.PullSecret != "" {
+			if err := cluster.ApplyYAMLFiles(n.name, s.Image.PullSecret); err != nil {
 				return nil, err
 			}
 		}
diff --git a/pkg/test/framework/image/flags.go b/pkg/test/framework/image/flags.go
deleted file mode 100644
index 715e46b32d..0000000000
--- a/pkg/test/framework/image/flags.go
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package image
-
-import (
-	"flag"
-	"fmt"
-
-	"istio.io/istio/pkg/test/env"
-	"istio.io/istio/pkg/test/framework/config"
-)
-
-// Settings we will collect from the command-line.
-var settingsFromCommandLine = &Settings{
-	Hub:        env.HUB.ValueOrDefault("gcr.io/istio-testing"),
-	Tag:        env.TAG.ValueOrDefault("latest"),
-	PullPolicy: env.PULL_POLICY.Value(),
-}
-
-// SettingsFromCommandLine returns Settings obtained from command-line flags. config.Parse must be called before calling this function.
-func SettingsFromCommandLine() (*Settings, error) {
-	if !config.Parsed() {
-		panic("config.Parse must be called before this function")
-	}
-
-	s := settingsFromCommandLine.clone()
-
-	if s.PullPolicy == "" {
-		// Default to pull-always
-		s.PullPolicy = "Always"
-	}
-
-	if s.Hub == "" || s.Tag == "" {
-		return nil, fmt.Errorf("values for Hub & Tag are not detected. Please supply them through command-line or via environment")
-	}
-
-	return s, nil
-}
-
-func init() {
-	flag.StringVar(&settingsFromCommandLine.Hub, "istio.test.hub", settingsFromCommandLine.Hub,
-		"Container registry hub to use")
-	flag.StringVar(&settingsFromCommandLine.Tag, "istio.test.tag", settingsFromCommandLine.Tag,
-		"Common Container tag to use when deploying container images")
-	flag.StringVar(&settingsFromCommandLine.PullPolicy, "istio.test.pullpolicy", settingsFromCommandLine.PullPolicy,
-		"Common image pull policy to use when deploying container images")
-	flag.StringVar(&settingsFromCommandLine.ImagePullSecret, "istio.test.imagePullSecret", settingsFromCommandLine.ImagePullSecret,
-		"Path to a file containing a DockerConfig secret use for test apps. This will be pushed to all created namespaces."+
-			"Secret should already exist when used with istio.test.stableNamespaces.")
-}
diff --git a/pkg/test/framework/image/settings.go b/pkg/test/framework/image/settings.go
deleted file mode 100644
index d472bde07a..0000000000
--- a/pkg/test/framework/image/settings.go
+++ /dev/null
@@ -1,123 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package image
-
-import (
-	"fmt"
-	"os"
-
-	"gopkg.in/yaml.v3"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-
-	"istio.io/istio/pkg/test"
-)
-
-const (
-	// HubValuesKey values key for the Docker image hub.
-	HubValuesKey = "global.hub"
-
-	// TagValuesKey values key for the Docker image tag.
-	TagValuesKey = "global.tag"
-
-	// ImagePullPolicyValuesKey values key for the Docker image pull policy.
-	ImagePullPolicyValuesKey = "global.imagePullPolicy"
-
-	// LatestTag value
-	LatestTag = "latest"
-)
-
-// Settings provide kube-specific Settings from flags.
-type Settings struct {
-	// Hub value to use in Helm templates
-	Hub string
-
-	// Tag value to use in Helm templates
-	Tag string
-
-	// Image pull policy to use for deployments. If not specified, the defaults of each deployment will be used.
-	PullPolicy string
-
-	// ImagePullSecret path to a file containing a k8s secret in yaml so test pods can pull from protected registries.
-	ImagePullSecret string
-}
-
-func (s *Settings) clone() *Settings {
-	c := *s
-	return &c
-}
-
-// String implements fmt.Stringer
-func (s *Settings) String() string {
-	result := ""
-
-	result += fmt.Sprintf("Hub:             %s\n", s.Hub)
-	result += fmt.Sprintf("Tag:             %s\n", s.Tag)
-	result += fmt.Sprintf("PullPolicy:      %s\n", s.PullPolicy)
-	result += fmt.Sprintf("ImagePullSecret: %s\n", s.ImagePullSecret)
-
-	return result
-}
-
-func (s *Settings) ImagePullSecretName() (string, error) {
-	if s.ImagePullSecret == "" {
-		return "", nil
-	}
-	data, err := os.ReadFile(s.ImagePullSecret)
-	if err != nil {
-		return "", err
-	}
-	secret := unstructured.Unstructured{Object: map[string]interface{}{}}
-	if err := yaml.Unmarshal(data, secret.Object); err != nil {
-		return "", err
-	}
-	return secret.GetName(), nil
-}
-
-func PullSecretNameOrFail(t test.Failer) string {
-	s, err := SettingsFromCommandLine()
-	if err != nil {
-		t.Fatalf("failed reading image settings: %v", err)
-	}
-	name, err := s.ImagePullSecretName()
-	if err != nil {
-		t.Fatalf("failed getting name of image pull secret: %v", err)
-	}
-	return name
-}
-
-func PullImagePolicy(t test.Failer) string {
-	var (
-		Always       = "Always"
-		IfNotPresent = "IfNotPresent"
-		Never        = "Never"
-	)
-
-	s, err := SettingsFromCommandLine()
-	if err != nil || s == nil {
-		t.Logf("failed reading image settings: %v, set imagePullPolicy=Always", err)
-		return Always
-	}
-	switch s.PullPolicy {
-	case Always, "":
-		return Always
-	case IfNotPresent:
-		return IfNotPresent
-	case Never:
-		return Never
-	default:
-		t.Logf("invalid image pull policy: %s, set imagePullPolicy=Always", s.PullPolicy)
-		return Always
-	}
-}
diff --git a/pkg/test/framework/resource/flags.go b/pkg/test/framework/resource/flags.go
index 3989d42441..e0f00dd209 100644
--- a/pkg/test/framework/resource/flags.go
+++ b/pkg/test/framework/resource/flags.go
@@ -18,9 +18,8 @@
 	"flag"
 	"fmt"
 	"os"
-	"strings"
 
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
+	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework/config"
 	"istio.io/istio/pkg/test/framework/label"
 )
@@ -48,18 +47,28 @@ func SettingsFromCommandLine(testID string) (*Settings, error) {
 		return nil, err
 	}
 
-	for _, wl := range s.skipWorkloadClasses {
-		s.SkipWorkloadClasses.Insert(strings.Split(wl, ",")...)
+	// NOTE: not using echo.VM, etc. here to avoid circular dependency.
+	if s.SkipVM {
+		s.SkipWorkloadClasses = append(s.SkipWorkloadClasses, "vm")
 	}
-	if s.skipVM {
-		s.SkipWorkloadClasses.Insert(echotypes.VM)
+	if s.SkipTProxy {
+		s.SkipWorkloadClasses = append(s.SkipWorkloadClasses, "tproxy")
 	}
-	if s.skipTProxy {
-		s.SkipWorkloadClasses.Insert(echotypes.TProxy)
-	}
-	if s.skipDelta {
+	if s.SkipDelta {
 		// TODO we may also want to trigger this if we have an old verion
-		s.SkipWorkloadClasses.Insert(echotypes.Delta)
+		s.SkipWorkloadClasses = append(s.SkipWorkloadClasses, "delta")
+	}
+
+	if s.Image.Hub == "" {
+		s.Image.Hub = env.HUB.ValueOrDefault("gcr.io/istio-testing")
+	}
+
+	if s.Image.Tag == "" {
+		s.Image.Tag = env.TAG.ValueOrDefault("latest")
+	}
+
+	if s.Image.PullPolicy == "" {
+		s.Image.PullPolicy = env.PULL_POLICY.ValueOrDefault("Always")
 	}
 
 	if err = validate(s); err != nil {
@@ -94,6 +103,10 @@ func validate(s *Settings) error {
 		return fmt.Errorf("cannot use --istio.test.compatibility without setting --istio.test.revisions")
 	}
 
+	if s.Image.Hub == "" || s.Image.Tag == "" {
+		return fmt.Errorf("values for Hub & Tag are not detected. Please supply them through command-line or via environment")
+	}
+
 	return nil
 }
 
@@ -117,7 +130,7 @@ func init() {
 	flag.Var(&settingsFromCommandLine.SkipString, "istio.test.skip",
 		"Skip tests matching the regular expression. This follows the semantics of -test.run.")
 
-	flag.Var(&settingsFromCommandLine.skipWorkloadClasses, "istio.test.skipWorkloads",
+	flag.Var(&settingsFromCommandLine.SkipWorkloadClasses, "istio.test.skipWorkloads",
 		"Skips deploying and using workloads of the given comma-separated classes (e.g. vm, proxyless, etc.)")
 
 	flag.IntVar(&settingsFromCommandLine.Retries, "istio.test.retries", settingsFromCommandLine.Retries,
@@ -132,28 +145,27 @@ func init() {
 	flag.StringVar(&settingsFromCommandLine.Revision, "istio.test.revision", settingsFromCommandLine.Revision,
 		"If set to XXX, overwrite the default namespace label (istio-injection=enabled) with istio.io/rev=XXX.")
 
-	flag.BoolVar(&settingsFromCommandLine.skipVM, "istio.test.skipVM", settingsFromCommandLine.skipVM,
+	flag.BoolVar(&settingsFromCommandLine.SkipVM, "istio.test.skipVM", settingsFromCommandLine.SkipVM,
 		"Skip VM related parts in all tests.")
 
-	flag.BoolVar(&settingsFromCommandLine.skipDelta, "istio.test.skipDelta", settingsFromCommandLine.skipDelta,
+	flag.BoolVar(&settingsFromCommandLine.SkipDelta, "istio.test.skipDelta", settingsFromCommandLine.SkipDelta,
 		"Skip Delta XDS related parts in all tests.")
 
-	flag.BoolVar(&settingsFromCommandLine.skipTProxy, "istio.test.skipTProxy", settingsFromCommandLine.skipTProxy,
+	flag.BoolVar(&settingsFromCommandLine.SkipTProxy, "istio.test.skipTProxy", settingsFromCommandLine.SkipTProxy,
 		"Skip TProxy related parts in all tests.")
 
 	flag.BoolVar(&settingsFromCommandLine.Compatibility, "istio.test.compatibility", settingsFromCommandLine.Compatibility,
 		"Transparently deploy echo instances pointing to each revision set in `Revisions`")
 
 	flag.Var(&settingsFromCommandLine.Revisions, "istio.test.revisions", "Istio CP revisions available to the test framework and their corresponding versions.")
-}
-
-type arrayFlags []string
 
-func (i *arrayFlags) String() string {
-	return fmt.Sprint([]string(*i))
-}
-
-func (i *arrayFlags) Set(value string) error {
-	*i = append(*i, value)
-	return nil
+	flag.StringVar(&settingsFromCommandLine.Image.Hub, "istio.test.hub", settingsFromCommandLine.Image.Hub,
+		"Container registry hub to use")
+	flag.StringVar(&settingsFromCommandLine.Image.Tag, "istio.test.tag", settingsFromCommandLine.Image.Tag,
+		"Common Container tag to use when deploying container images")
+	flag.StringVar(&settingsFromCommandLine.Image.PullPolicy, "istio.test.pullpolicy", settingsFromCommandLine.Image.PullPolicy,
+		"Common image pull policy to use when deploying container images")
+	flag.StringVar(&settingsFromCommandLine.Image.PullSecret, "istio.test.imagePullSecret", settingsFromCommandLine.Image.PullSecret,
+		"Path to a file containing a DockerConfig secret use for test apps. This will be pushed to all created namespaces."+
+			"Secret should already exist when used with istio.test.stableNamespaces.")
 }
diff --git a/pkg/test/framework/resource/settings.go b/pkg/test/framework/resource/settings.go
index e1926dbd03..d08edadad0 100644
--- a/pkg/test/framework/resource/settings.go
+++ b/pkg/test/framework/resource/settings.go
@@ -16,13 +16,16 @@
 
 import (
 	"fmt"
+	"os"
 	"path"
 	"strings"
 
 	"github.com/google/uuid"
+	"gopkg.in/yaml.v3"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 
 	"istio.io/istio/pilot/pkg/util/sets"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
+	"istio.io/istio/pkg/test"
 	"istio.io/istio/pkg/test/framework/label"
 )
 
@@ -31,6 +34,45 @@
 	maxTestIDLength = 30
 )
 
+// ImageSettings for container images.
+type ImageSettings struct {
+	// Hub value to use in Helm templates
+	Hub string
+
+	// Tag value to use in Helm templates
+	Tag string
+
+	// Image pull policy to use for deployments. If not specified, the defaults of each deployment will be used.
+	PullPolicy string
+
+	// PullSecret path to a file containing a k8s secret in yaml so test pods can pull from protected registries.
+	PullSecret string
+}
+
+func (s *ImageSettings) PullSecretName() (string, error) {
+	if s.PullSecret == "" {
+		return "", nil
+	}
+	data, err := os.ReadFile(s.PullSecret)
+	if err != nil {
+		return "", err
+	}
+	secret := unstructured.Unstructured{Object: map[string]interface{}{}}
+	if err := yaml.Unmarshal(data, secret.Object); err != nil {
+		return "", err
+	}
+	return secret.GetName(), nil
+}
+
+func (s *ImageSettings) PullSecretNameOrFail(t test.Failer) string {
+	t.Helper()
+	out, err := s.PullSecretName()
+	if err != nil {
+		t.Fatal(err)
+	}
+	return out
+}
+
 // Settings is the set of arguments to the test driver.
 type Settings struct {
 	// Name of the test
@@ -66,12 +108,11 @@ type Settings struct {
 	// -test.run flag, which only supports positive match. If an entire package is meant to be
 	// excluded, it can be filtered with `go list` and explicitly passing the list of desired
 	// packages. For example: `go test $(go list ./... | grep -v bad-package)`.
-	SkipString  arrayFlags
+	SkipString  ArrayFlags
 	SkipMatcher *Matcher
 
 	// SkipWorkloadClasses can be used to skip deploying special workload types like TPROXY, VMs, etc.
-	skipWorkloadClasses arrayFlags
-	SkipWorkloadClasses sets.Set
+	SkipWorkloadClasses ArrayFlags
 
 	// The label selector, in parsed form.
 	Selector label.Selector
@@ -86,13 +127,13 @@ type Settings struct {
 	Revision string
 
 	// Skip VM related parts for all the tests.
-	skipVM bool
+	SkipVM bool
 
 	// Skip Delta XDS related parts for all the tests.
-	skipDelta bool
+	SkipDelta bool
 
 	// Skip TProxy related parts for all the tests.
-	skipTProxy bool
+	SkipTProxy bool
 
 	// Compatibility determines whether we should transparently deploy echo workloads attached to each revision
 	// specified in `Revisions` when creating echo instances. Used primarily for compatibility testing between revisions
@@ -106,10 +147,17 @@ type Settings struct {
 	// To configure it so that an Istio revision is on the latest version simply list the revision name without the version (i.e. "rev-a,rev-b")
 	// If using this flag with --istio.test.revision, this flag will take precedence.
 	Revisions RevVerMap
+
+	// Image settings
+	Image ImageSettings
+}
+
+func (s Settings) Skip(class string) bool {
+	return s.SkipWorkloadClassesAsSet().Contains(class)
 }
 
-func (s Settings) Skip(class echotypes.Class) bool {
-	return s.SkipWorkloadClasses.Contains(class)
+func (s *Settings) SkipWorkloadClassesAsSet() sets.Set {
+	return sets.NewSet(s.SkipWorkloadClasses...)
 }
 
 // RunDir is the name of the dir to output, for this particular run.
@@ -135,8 +183,7 @@ func (s *Settings) Clone() *Settings {
 // DefaultSettings returns a default settings instance.
 func DefaultSettings() *Settings {
 	return &Settings{
-		RunID:               uuid.New(),
-		SkipWorkloadClasses: sets.NewSet(),
+		RunID: uuid.New(),
 	}
 }
 
@@ -154,8 +201,23 @@ func (s *Settings) String() string {
 	result += fmt.Sprintf("Retries:           %v\n", s.Retries)
 	result += fmt.Sprintf("StableNamespaces:  %v\n", s.StableNamespaces)
 	result += fmt.Sprintf("Revision:          %v\n", s.Revision)
-	result += fmt.Sprintf("SkipWorkloads      %v\n", s.SkipWorkloadClasses.SortedList())
+	result += fmt.Sprintf("SkipWorkloads      %v\n", s.SkipWorkloadClasses)
 	result += fmt.Sprintf("Compatibility:     %v\n", s.Compatibility)
 	result += fmt.Sprintf("Revisions:         %v\n", s.Revisions.String())
+	result += fmt.Sprintf("Hub:               %s\n", s.Image.Hub)
+	result += fmt.Sprintf("Tag:               %s\n", s.Image.Tag)
+	result += fmt.Sprintf("PullPolicy:        %s\n", s.Image.PullPolicy)
+	result += fmt.Sprintf("PullSecret:        %s\n", s.Image.PullSecret)
 	return result
 }
+
+type ArrayFlags []string
+
+func (i *ArrayFlags) String() string {
+	return fmt.Sprint([]string(*i))
+}
+
+func (i *ArrayFlags) Set(value string) error {
+	*i = append(*i, value)
+	return nil
+}
diff --git a/tests/integration/helm/install_test.go b/tests/integration/helm/install_test.go
index fdd354cbba..b64c262ddd 100644
--- a/tests/integration/helm/install_test.go
+++ b/tests/integration/helm/install_test.go
@@ -25,7 +25,6 @@
 
 	"istio.io/istio/pkg/test/framework"
 	kubecluster "istio.io/istio/pkg/test/framework/components/cluster/kube"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/helm"
 	"istio.io/istio/tests/util/sanitycheck"
 )
@@ -70,11 +69,9 @@ func setupInstallation(overrideValuesStr string) func(t framework.TestContext) {
 		}
 		cs := t.Clusters().Default().(*kubecluster.Cluster)
 		h := helm.New(cs.Filename())
-		s, err := image.SettingsFromCommandLine()
-		if err != nil {
-			t.Fatal(err)
-		}
-		overrideValues := fmt.Sprintf(overrideValuesStr, s.Hub, s.Tag)
+
+		s := t.Settings()
+		overrideValues := fmt.Sprintf(overrideValuesStr, s.Image.Hub, s.Image.Tag)
 		overrideValuesFile := filepath.Join(workDir, "values.yaml")
 		if err := os.WriteFile(overrideValuesFile, []byte(overrideValues), os.ModePerm); err != nil {
 			t.Fatalf("failed to write iop cr file: %v", err)
diff --git a/tests/integration/helm/upgrade/util.go b/tests/integration/helm/upgrade/util.go
index 365ef703b8..efe68427d6 100644
--- a/tests/integration/helm/upgrade/util.go
+++ b/tests/integration/helm/upgrade/util.go
@@ -29,7 +29,6 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	kubecluster "istio.io/istio/pkg/test/framework/components/cluster/kube"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/helm"
 	kubetest "istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/scopes"
@@ -185,15 +184,8 @@ func performInPlaceUpgradeFunc(previousVersion string) func(framework.TestContex
 		_, oldClient, oldServer := sanitycheck.SetupTrafficTest(t, t, "")
 		sanitycheck.RunTrafficTestClientServer(t, oldClient, oldServer)
 
-		// now upgrade istio to the latest version found in this branch
-		// use the command line or environmental vars from the user to set
-		// the hub/tag
-		s, err := image.SettingsFromCommandLine()
-		if err != nil {
-			t.Fatal(err)
-		}
-
-		overrideValuesFile = getValuesOverrides(t, s.Hub, s.Tag, "")
+		s := t.Settings()
+		overrideValuesFile = getValuesOverrides(t, s.Image.Hub, s.Image.Tag, "")
 		upgradeCharts(t, h, overrideValuesFile)
 		helmtest.VerifyInstallation(t, cs, true)
 
@@ -245,15 +237,8 @@ func performRevisionUpgradeFunc(previousVersion, previousValidatingWebhookName s
 		_, oldClient, oldServer := sanitycheck.SetupTrafficTest(t, t, "")
 		sanitycheck.RunTrafficTestClientServer(t, oldClient, oldServer)
 
-		// now upgrade istio to the latest version found in this branch
-		// use the command line or environmental vars from the user to set
-		// the hub/tag
-		s, err := image.SettingsFromCommandLine()
-		if err != nil {
-			t.Fatal(err)
-		}
-
-		overrideValuesFile = getValuesOverrides(t, s.Hub, s.Tag, canaryTag)
+		s := t.Settings()
+		overrideValuesFile = getValuesOverrides(t, s.Image.Hub, s.Image.Tag, canaryTag)
 		helmtest.InstallIstioWithRevision(t, cs, h, "", "", canaryTag, overrideValuesFile, true, false)
 		helmtest.VerifyInstallation(t, cs, false)
 
@@ -325,18 +310,11 @@ func performRevisionTagsUpgradeFunc(previousVersion, previousValidatingWebhookNa
 		oldNs, oldClient, oldServer := sanitycheck.SetupTrafficTest(t, t, previousRevision)
 		sanitycheck.RunTrafficTestClientServer(t, oldClient, oldServer)
 
-		// now upgrade istio to the latest version found in this branch
-		// use the command line or environmental vars from the user to set
-		// the hub/tag
-		s, err := image.SettingsFromCommandLine()
-		if err != nil {
-			t.Fatal(err)
-		}
-
 		// install the charts from this branch with revision set to "latest"
 		// helm upgrade istio-base ../manifests/charts/base --namespace istio-system -f values.yaml
 		// helm install istiod-latest ../manifests/charts/istio-control/istio-discovery -f values.yaml
-		overrideValuesFile = getValuesOverrides(t, s.Hub, s.Tag, latestRevisionTag)
+		s := t.Settings()
+		overrideValuesFile = getValuesOverrides(t, s.Image.Hub, s.Image.Tag, latestRevisionTag)
 		helmtest.InstallIstioWithRevision(t, cs, h, "", "", latestRevisionTag, overrideValuesFile, true, false)
 		helmtest.VerifyInstallation(t, cs, false)
 
@@ -376,7 +354,7 @@ func performRevisionTagsUpgradeFunc(previousVersion, previousValidatingWebhookNa
 
 		// change the old namespace that was pointing to the old prod (1-10-0) to point to the
 		// 'latest' revision by setting the `istio.io/rev=prod` label on the namespace
-		err = oldNs.SetLabel(istioRevLabel, prodTag)
+		err := oldNs.SetLabel(istioRevLabel, prodTag)
 		if err != nil {
 			t.Fatal("could not remove istio.io/rev from old namespace")
 		}
diff --git a/tests/integration/operator/switch_cr_test.go b/tests/integration/operator/switch_cr_test.go
index 2c57438f4b..12a24f64af 100644
--- a/tests/integration/operator/switch_cr_test.go
+++ b/tests/integration/operator/switch_cr_test.go
@@ -41,7 +41,6 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
 	"istio.io/istio/pkg/test/framework/components/istioctl"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	kube2 "istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/scopes"
@@ -76,18 +75,15 @@ func TestController(t *testing.T) {
 				t.Fatal("failed to create test directory")
 			}
 			cs := t.Clusters().Default()
-			s, err := image.SettingsFromCommandLine()
-			if err != nil {
-				t.Fatal(err)
-			}
 			cleanupInClusterCRs(t, cs)
 			t.Cleanup(func() {
 				cleanupIstioResources(t, cs, istioCtl)
 			})
+			s := t.Settings()
 			initCmd := []string{
 				"operator", "init",
-				"--hub=" + s.Hub,
-				"--tag=" + s.Tag,
+				"--hub=" + s.Image.Hub,
+				"--tag=" + s.Image.Tag,
 				"--manifests=" + ManifestPath,
 			}
 			// install istio with default config for the first time by running operator init command
@@ -108,20 +104,20 @@ func TestController(t *testing.T) {
 			}
 			iopCRFile = filepath.Join(workDir, "iop_cr.yaml")
 			// later just run `kubectl apply -f newcr.yaml` to apply new installation cr files and verify.
-			installWithCRFile(t, t, cs, s, istioCtl, "demo", "")
+			installWithCRFile(t, t, cs, istioCtl, "demo", "")
 
 			initCmd = []string{
 				"operator", "init",
-				"--hub=" + s.Hub,
-				"--tag=" + s.Tag,
+				"--hub=" + s.Image.Hub,
+				"--tag=" + s.Image.Tag,
 				"--manifests=" + ManifestPath,
 				"--revision=" + "v2",
 			}
 			// install second operator deployment with different revision
 			istioCtl.InvokeOrFail(t, initCmd)
 			t.TrackResource(&operatorDumper{rev: "v2"})
-			installWithCRFile(t, t, cs, s, istioCtl, "default", "v2")
-			installWithCRFile(t, t, cs, s, istioCtl, "default", "")
+			installWithCRFile(t, t, cs, istioCtl, "default", "v2")
+			installWithCRFile(t, t, cs, istioCtl, "default", "")
 
 			// istio control plane resources expected to be deleted after deleting CRs
 			cleanupInClusterCRs(t, cs)
@@ -283,7 +279,7 @@ func cleanupInClusterCRs(t framework.TestContext, cs cluster.Cluster) {
 	}
 }
 
-func installWithCRFile(t framework.TestContext, ctx resource.Context, cs cluster.Cluster, s *image.Settings,
+func installWithCRFile(t framework.TestContext, ctx resource.Context, cs cluster.Cluster,
 	istioCtl istioctl.Instance, profileName string, revision string) {
 	scopes.Framework.Infof(fmt.Sprintf("=== install istio with profile: %s===\n", profileName))
 	metadataYAML := `
@@ -307,8 +303,9 @@ func installWithCRFile(t framework.TestContext, ctx resource.Context, cs cluster
     global:
       imagePullPolicy: %s
 `
-
-	overlayYAML := fmt.Sprintf(metadataYAML, revName("test-istiocontrolplane", revision), profileName, ManifestPathContainer, s.Hub, s.Tag, s.PullPolicy)
+	s := ctx.Settings()
+	overlayYAML := fmt.Sprintf(metadataYAML, revName("test-istiocontrolplane", revision), profileName, ManifestPathContainer,
+		s.Image.Hub, s.Image.Tag, s.Image.PullPolicy)
 
 	scopes.Framework.Infof("=== installing with IOP: ===\n%s\n", overlayYAML)
 
diff --git a/tests/integration/operator/verify_test.go b/tests/integration/operator/verify_test.go
index 2e06cbc49e..83202b1e13 100644
--- a/tests/integration/operator/verify_test.go
+++ b/tests/integration/operator/verify_test.go
@@ -26,7 +26,6 @@
 	"istio.io/istio/operator/pkg/util/clog"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/istioctl"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/scopes"
 )
 
@@ -37,18 +36,15 @@ func TestPostInstallControlPlaneVerification(t *testing.T) {
 		Run(func(t framework.TestContext) {
 			istioCtl := istioctl.NewOrFail(t, t, istioctl.Config{})
 			cs := t.Environment().Clusters().Default()
-			s, err := image.SettingsFromCommandLine()
-			if err != nil {
-				t.Fatal(err)
-			}
 			cleanupInClusterCRs(t, cs)
 			t.Cleanup(func() {
 				cleanupIstioResources(t, cs, istioCtl)
 			})
+			s := t.Settings()
 			installCmd := []string{
 				"install",
-				"--set", "hub=" + s.Hub,
-				"--set", "tag=" + s.Tag,
+				"--set", "hub=" + s.Image.Hub,
+				"--set", "tag=" + s.Image.Tag,
 				"--manifests=" + ManifestPath,
 				"-y",
 			}
diff --git a/tests/integration/pilot/common/apps.go b/tests/integration/pilot/common/apps.go
index 9dbfffcc46..910dfebaba 100644
--- a/tests/integration/pilot/common/apps.go
+++ b/tests/integration/pilot/common/apps.go
@@ -27,7 +27,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -227,7 +226,7 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 			WorkloadOnlyPorts: common.WorkloadPorts,
 		})
 
-	skipDelta := t.Settings().Skip(echotypes.Delta) || !t.Settings().Revisions.AtLeast("1.11")
+	skipDelta := t.Settings().Skip(echo.Delta) || !t.Settings().Revisions.AtLeast("1.11")
 	if !skipDelta {
 		builder = builder.
 			WithConfig(echo.Config{
@@ -276,7 +275,7 @@ func SetupApps(t resource.Context, i istio.Instance, apps *EchoDeployments) erro
 	apps.Naked = echos.Match(echo.Service(NakedSvc))
 	apps.External = echos.Match(echo.Service(ExternalSvc))
 	apps.ProxylessGRPC = echos.Match(echo.Service(ProxylessGRPCSvc))
-	if !t.Settings().Skip(echotypes.VM) {
+	if !t.Settings().Skip(echo.VM) {
 		apps.VM = echos.Match(echo.Service(VMSvc))
 	}
 	if !skipDelta {
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 339049b328..e6ea5875a6 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -34,6 +34,7 @@
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/security"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
@@ -42,7 +43,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/pkg/test/util/retry"
@@ -372,10 +372,12 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
     - destination:
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
-				PortName:        "http",
-				Path:            "/foo?key=value",
-				FollowRedirects: true,
-				Count:           1,
+				PortName: "http",
+				HTTP: echo.HTTP{
+					Path:            "/foo?key=value",
+					FollowRedirects: true,
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.URL("/new/path?key=value")),
@@ -401,10 +403,12 @@ func virtualServiceCases(skipVM bool) []TrafficTestCase {
       scheme: https
 `,
 			opts: echo.CallOptions{
-				PortName:        "http",
-				Path:            "/foo",
-				FollowRedirects: false,
-				Count:           1,
+				PortName: "http",
+				HTTP: echo.HTTP{
+					Path:            "/foo",
+					FollowRedirects: false,
+				},
+				Count: 1,
 				Check: check.And(
 					check.Status(http.StatusMovedPermanently),
 					check.Each(
@@ -441,8 +445,10 @@ func(r echoClient.Response) error {
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
 				PortName: "http",
-				Path:     "/foo?key=value#hash",
-				Count:    1,
+				HTTP: echo.HTTP{
+					Path: "/foo?key=value#hash",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.URL("/new/path?key=value")),
@@ -470,8 +476,10 @@ func(r echoClient.Response) error {
         host: {{ .dstSvc }}`,
 			opts: echo.CallOptions{
 				PortName: "http",
-				Path:     "/foo",
-				Count:    1,
+				HTTP: echo.HTTP{
+					Path: "/foo",
+				},
+				Count: 1,
 				Check: check.And(
 					check.OK(),
 					check.Host("new-authority")),
@@ -510,14 +518,16 @@ func(r echoClient.Response) error {
 				{
 					name: "preflight",
 					opts: func() echo.CallOptions {
-						header := http.Header{}
-						header.Add("Origin", "cors.com")
-						header.Add("Access-Control-Request-Method", "DELETE")
 						return echo.CallOptions{
 							PortName: "http",
-							Method:   "OPTIONS",
-							Headers:  header,
-							Count:    1,
+							HTTP: echo.HTTP{
+								Method: "OPTIONS",
+								Headers: headers.New().
+									With(headers.Origin, "cors.com").
+									With(headers.AccessControlRequestMethod, "DELETE").
+									Build(),
+							},
+							Count: 1,
 							Check: check.And(
 								check.OK(),
 								check.ResponseHeaders(map[string]string{
@@ -532,12 +542,12 @@ func(r echoClient.Response) error {
 				{
 					name: "get",
 					opts: func() echo.CallOptions {
-						header := http.Header{}
-						header.Add("Origin", "cors.com")
 						return echo.CallOptions{
 							PortName: "http",
-							Headers:  header,
-							Count:    1,
+							HTTP: echo.HTTP{
+								Headers: headers.New().With(headers.Origin, "cors.com").Build(),
+							},
+							Count: 1,
 							Check: check.And(
 								check.OK(),
 								check.ResponseHeader("Access-Control-Allow-Origin", "cors.com")),
@@ -719,9 +729,7 @@ func(responses echoClient.Responses, err error) error {
 }
 
 func HostHeader(header string) http.Header {
-	h := http.Header{}
-	h.Set("Host", header)
-	return h
+	return headers.New().WithHost(header).Build()
 }
 
 // tlsOriginationCases contains tests TLS origination from DestinationRule
@@ -759,8 +767,10 @@ func tlsOriginationCases(apps *EchoDeployments) []TrafficTestCase {
 					Port:    &echo.Port{ServicePort: e.port, Protocol: protocol.HTTP},
 					Count:   1,
 					Address: apps.External[0].Address(),
-					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
-					Scheme:  scheme.HTTP,
+					HTTP: echo.HTTP{
+						Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
+					},
+					Scheme: scheme.HTTP,
 					Check: check.And(
 						check.OK(),
 						check.Alpn(e.alpn)),
@@ -786,7 +796,9 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				Target:   destination,
 				PortName: "http",
 				Count:    1,
-				HTTP2:    true,
+				HTTP: echo.HTTP{
+					HTTP2: true,
+				},
 				Check: check.And(
 					check.OK(),
 					check.Protocol("HTTP/2.0"),
@@ -802,7 +814,9 @@ func useClientProtocolCases(apps *EchoDeployments) []TrafficTestCase {
 				PortName: "http",
 				Count:    1,
 				Target:   destination,
-				HTTP2:    false,
+				HTTP: echo.HTTP{
+					HTTP2: false,
+				},
 				Check: check.And(
 					check.OK(),
 					check.Protocol("HTTP/1.1"),
@@ -828,8 +842,10 @@ func destinationRuleCases(apps *EchoDeployments) []TrafficTestCase {
 				Target:   destination,
 				PortName: "http",
 				Count:    1,
-				HTTP2:    true,
-				Check:    check.OK(),
+				HTTP: echo.HTTP{
+					HTTP2: true,
+				},
+				Check: check.OK(),
 			},
 			minIstioVersion: "1.10.0",
 		},
@@ -905,10 +921,12 @@ func autoPassthroughCases(apps *EchoDeployments) []TrafficTestCase {
 							ServicePort: 443,
 							Protocol:    protocol.HTTPS,
 						},
-						ServerName: sni,
-						Alpn:       al,
-						Check:      check.Error(),
-						Timeout:    5 * time.Second,
+						TLS: echo.TLS{
+							ServerName: sni,
+							Alpn:       al,
+						},
+						Check:   check.Error(),
+						Timeout: 5 * time.Second,
 					},
 				},
 				)
@@ -968,10 +986,10 @@ func gatewayCases() []TrafficTestCase {
 	}
 	// allows setting the target indirectly via the host header
 	fqdnHostHeader := func(src echo.Caller, dsts echo.Instances, opts *echo.CallOptions) {
-		if opts.Headers == nil {
-			opts.Headers = map[string][]string{}
+		if opts.HTTP.Headers == nil {
+			opts.HTTP.Headers = make(http.Header)
 		}
-		opts.Headers["Host"] = []string{dsts[0].Config().ClusterLocalFQDN()}
+		opts.HTTP.Headers.Set(headers.Host, dsts[0].Config().ClusterLocalFQDN())
 		noTarget(src, dsts, opts)
 	}
 
@@ -990,8 +1008,8 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Headers: map[string][]string{
-					"Host": {"foo.bar"},
+				HTTP: echo.HTTP{
+					Headers: headers.New().WithHost("foo.bar").Build(),
 				},
 				Check: check.Status(http.StatusNotFound),
 			},
@@ -1083,9 +1101,9 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Headers: map[string][]string{
+				HTTP: echo.HTTP{
 					// In real world, this may be set by a downstream LB that terminates the TLS
-					"X-Forwarded-Proto": {"https"},
+					Headers: headers.New().With(headers.XForwardedProto, "https").Build(),
 				},
 				Check: check.OK(),
 			},
@@ -1214,9 +1232,9 @@ func gatewayCases() []TrafficTestCase {
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
 				},
-				Headers: map[string][]string{
+				HTTP: echo.HTTP{
 					// In real world, this may be set by a downstream LB that terminates the TLS
-					"X-Forwarded-Proto": {"https"},
+					Headers: headers.New().With(headers.XForwardedProto, "https").Build(),
 				},
 				Check: check.Status(http.StatusBadRequest),
 			},
@@ -1294,7 +1312,9 @@ func gatewayCases() []TrafficTestCase {
 ---
 ` + httpVirtualServiceTmpl,
 			opts: echo.CallOptions{
-				HTTP2: true,
+				HTTP: echo.HTTP{
+					HTTP2: true,
+				},
 				Count: 1,
 				Port: &echo.Port{
 					Protocol: protocol.HTTP,
@@ -1351,7 +1371,9 @@ func gatewayCases() []TrafficTestCase {
 ---
 ` + httpVirtualServiceTmpl + useClientProtocolDestinationRuleTmpl,
 					opts: echo.CallOptions{
-						HTTP2: h2,
+						HTTP: echo.HTTP{
+							HTTP2: h2,
+						},
 						Count: 1,
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
@@ -1451,9 +1473,11 @@ func XFFGatewayCase(apps *EchoDeployments, gateway string) []TrafficTestCase {
 				Port:    &echo.Port{ServicePort: 80},
 				Scheme:  scheme.HTTP,
 				Address: gateway,
-				Headers: map[string][]string{
-					"X-Forwarded-For": {"56.5.6.7, 72.9.5.6, 98.1.2.3"},
-					"Host":            {fqdn},
+				HTTP: echo.HTTP{
+					Headers: headers.New().
+						WithHost(fqdn).
+						With(headers.XForwardedFor, "56.5.6.7, 72.9.5.6, 98.1.2.3").
+						Build(),
 				},
 				Check: check.Each(
 					func(r echoClient.Response) error {
@@ -1640,8 +1664,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				opts: echo.CallOptions{
 					PortName: "auto-http",
 					Target:   apps.Headless[0],
-					Headers:  HostHeader(h),
-					Check:    check.OK(),
+					HTTP: echo.HTTP{
+						Headers: HostHeader(h),
+					},
+					Check: check.OK(),
 				},
 			})
 		}
@@ -1669,8 +1695,10 @@ func hostCases(apps *EchoDeployments) ([]TrafficTestCase, error) {
 				opts: echo.CallOptions{
 					PortName: "http",
 					Target:   apps.Headless[0],
-					Headers:  HostHeader(h),
-					Check:    check.OK(),
+					HTTP: echo.HTTP{
+						Headers: HostHeader(h),
+					},
+					Check: check.OK(),
 				},
 			})
 		}
@@ -1888,14 +1916,14 @@ func(responses echoClient.Responses, rerr error) error {
 					),
 				},
 			})
-			headers := http.Header{}
-			headers.Add("x-some-header", "baz")
 			callOpts := echo.CallOptions{
 				Count:   10,
 				Address: svcName,
-				Path:    "/?some-query-param=bar",
-				Headers: headers,
-				Port:    &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
+				HTTP: echo.HTTP{
+					Path:    "/?some-query-param=bar",
+					Headers: headers.New().With("x-some-header", "baz").Build(),
+				},
+				Port: &echo.Port{ServicePort: FindPortByName("http").ServicePort, Protocol: protocol.HTTP},
 				Check: check.And(
 					check.OK(),
 					ConsistentHostChecker,
@@ -1910,7 +1938,7 @@ func(responses echoClient.Responses, rerr error) error {
 					ConsistentHostChecker,
 				),
 			}
-			if c.Config().Class() == echotypes.Proxyless {
+			if c.Config().WorkloadClass() == echo.Proxyless {
 				callOpts.Port = &echo.Port{ServicePort: FindPortByName("grpc").ServicePort, Protocol: protocol.GRPC}
 			}
 			// Setup tests for various forms of the API
@@ -1936,7 +1964,7 @@ func(responses echoClient.Responses, rerr error) error {
 				config: svc + tmpl.MustEvaluate(destRule, "useSourceIp: true"),
 				call:   c.CallWithRetryOrFail,
 				opts:   tcpCallopts,
-				skip:   c.Config().Class() == echotypes.Proxyless,
+				skip:   c.Config().WorkloadClass() == echo.Proxyless,
 			})
 		}
 	}
@@ -2107,9 +2135,11 @@ type protocolCase struct {
 			Scheme:   scheme.TCP,
 			Message: `GET / HTTP/1.0
 `,
-			// Explicitly declared as HTTP, so we always go through http filter which fails
-			ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.1 426 Upgrade Required`},
-			Timeout:          time.Second * 5,
+			Timeout: time.Second * 5,
+			TCP: echo.TCP{
+				// Explicitly declared as HTTP, so we always go through http filter which fails
+				ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.1 426 Upgrade Required`},
+			},
 		},
 	},
 		TrafficTestCase{
@@ -2122,26 +2152,32 @@ type protocolCase struct {
 				Scheme:   scheme.TCP,
 				Message: `GET / HTTP/1.0
 `,
-				// Auto should be detected as TCP
-				ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
-				Timeout:          time.Second * 5,
+				Timeout: time.Second * 5,
+				TCP: echo.TCP{
+					// Auto should be detected as TCP
+					ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
+				},
 			},
 		},
 		TrafficTestCase{
 			name: "http10 to external",
 			call: apps.PodA[0].CallWithRetryOrFail,
 			opts: echo.CallOptions{
-				Address:  apps.External[0].Address(),
-				Headers:  HostHeader(apps.External[0].Config().DefaultHostHeader),
+				Address: apps.External[0].Address(),
+				HTTP: echo.HTTP{
+					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
+				},
 				Port:     &httpPort,
 				Count:    1,
 				PortName: "http",
 				Scheme:   scheme.TCP,
 				Message: `GET / HTTP/1.0
 `,
-				// There is no VIP so we fall back to 0.0.0.0 listener which sniffs
-				ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
-				Timeout:          time.Second * 5,
+				Timeout: time.Second * 5,
+				TCP: echo.TCP{
+					// There is no VIP so we fall back to 0.0.0.0 listener which sniffs
+					ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
+				},
 			},
 		},
 		TrafficTestCase{
@@ -2149,15 +2185,19 @@ type protocolCase struct {
 			call: apps.PodA[0].CallWithRetryOrFail,
 			opts: echo.CallOptions{
 				Address: apps.External[0].Address(),
-				Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
-				Port:    &autoPort,
-				Count:   1,
-				Scheme:  scheme.TCP,
+				HTTP: echo.HTTP{
+					Headers: HostHeader(apps.External[0].Config().DefaultHostHeader),
+				},
+				Port:   &autoPort,
+				Count:  1,
+				Scheme: scheme.TCP,
 				Message: `GET / HTTP/1.0
 `,
-				// Auto should be detected as TCP
-				ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
-				Timeout:          time.Second * 5,
+				Timeout: time.Second * 5,
+				TCP: echo.TCP{
+					// Auto should be detected as TCP
+					ExpectedResponse: &wrappers.StringValue{Value: `HTTP/1.0 200 OK`},
+				},
 			},
 		},
 	)
@@ -2840,8 +2880,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusOK),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2859,8 +2901,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusOK),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2881,8 +2925,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusOK),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2900,8 +2946,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusOK),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2919,8 +2967,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -2939,8 +2989,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusOK),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusOK),
 			},
 		},
 		{
@@ -2961,8 +3013,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -2980,8 +3034,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -2999,8 +3055,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headersWithInvalidToken,
-				Check:    check.Status(http.StatusUnauthorized),
+				HTTP: echo.HTTP{
+					Headers: headersWithInvalidToken,
+				},
+				Check: check.Status(http.StatusUnauthorized),
 			},
 		},
 		{
@@ -3018,8 +3076,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headersWithNoToken,
-				Check:    check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					Headers: headersWithNoToken,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -3037,9 +3097,11 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
-				Headers: headersWithNoTokenButSameHeader,
-				Check:   check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
+					Headers: headersWithNoTokenButSameHeader,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 		{
@@ -3057,8 +3119,10 @@ type configData struct {
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				Headers:  headers,
-				Check:    check.Status(http.StatusNotFound),
+				HTTP: echo.HTTP{
+					Headers: headers,
+				},
+				Check: check.Status(http.StatusNotFound),
 			},
 		},
 	}
diff --git a/tests/integration/pilot/common/traffic.go b/tests/integration/pilot/common/traffic.go
index bda5033415..e476874cbf 100644
--- a/tests/integration/pilot/common/traffic.go
+++ b/tests/integration/pilot/common/traffic.go
@@ -26,7 +26,6 @@
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/label"
@@ -237,7 +236,7 @@ func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *EchoDep
 	if !t.Settings().Selector.Excludes(label.NewSet(label.IPv4)) { // https://github.com/istio/istio/issues/35835
 		cases["jwt-claim-route"] = jwtClaimRoute(apps)
 	}
-	cases["virtualservice"] = virtualServiceCases(t.Settings().Skip(echotypes.VM))
+	cases["virtualservice"] = virtualServiceCases(t.Settings().Skip(echo.VM))
 	cases["sniffing"] = protocolSniffingCases(apps)
 	cases["selfcall"] = selfCallsCases()
 	cases["serverfirst"] = serverFirstTestCases(apps)
@@ -260,7 +259,7 @@ func RunAllTrafficTests(t framework.TestContext, i istio.Instance, apps *EchoDep
 	}
 	cases["use-client-protocol"] = useClientProtocolCases(apps)
 	cases["destinationrule"] = destinationRuleCases(apps)
-	if !t.Settings().Skip(echotypes.VM) {
+	if !t.Settings().Skip(echo.VM) {
 		cases["vm"] = VMTestCases(apps.VM, apps)
 	}
 	cases["dns"] = DNSTestCases(apps, i.Settings().EnableCNI)
diff --git a/tests/integration/pilot/gw_topology_test.go b/tests/integration/pilot/gw_topology_test.go
index cedee7abe3..c8783daf5b 100644
--- a/tests/integration/pilot/gw_topology_test.go
+++ b/tests/integration/pilot/gw_topology_test.go
@@ -25,7 +25,6 @@
 	"istio.io/istio/pkg/test/framework"
 	kubecluster "istio.io/istio/pkg/test/framework/components/cluster/kube"
 	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/image"
 	kubetest "istio.io/istio/pkg/test/kube"
 	"istio.io/istio/pkg/test/util/retry"
 	"istio.io/istio/tests/integration/pilot/common"
@@ -43,9 +42,9 @@ func TestXFFGateway(t *testing.T) {
 			}
 
 			templateParams := map[string]string{
-				"imagePullSecret": image.PullSecretNameOrFail(t),
+				"imagePullSecret": t.Settings().Image.PullSecret,
 				"injectLabel":     injectLabel,
-				"imagePullPolicy": image.PullImagePolicy(t),
+				"imagePullPolicy": t.Settings().Image.PullPolicy,
 			}
 
 			// we only apply to config clusters
diff --git a/tests/integration/pilot/ingress_test.go b/tests/integration/pilot/ingress_test.go
index dbd1a0b102..eeeab4ec3c 100644
--- a/tests/integration/pilot/ingress_test.go
+++ b/tests/integration/pilot/ingress_test.go
@@ -32,6 +32,7 @@
 
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
 	"istio.io/istio/pkg/test/echo/common/scheme"
@@ -41,7 +42,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/environment/kube"
 	"istio.io/istio/pkg/test/framework/components/namespace"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/pkg/test/helm"
 	kubetest "istio.io/istio/pkg/test/kube"
@@ -196,9 +196,9 @@ func TestGateway(t *testing.T) {
 								Port: &echo.Port{
 									Protocol: protocol.HTTP,
 								},
-								Path: path,
-								Headers: map[string][]string{
-									"Host": {"my.domain.example"},
+								HTTP: echo.HTTP{
+									Path:    path,
+									Headers: headers.New().WithHost("my.domain.example").Build(),
 								},
 							})
 						}
@@ -209,9 +209,9 @@ func TestGateway(t *testing.T) {
 								Protocol:    protocol.HTTP,
 								ServicePort: 31400,
 							},
-							Path: "/",
-							Headers: map[string][]string{
-								"Host": {"my.domain.example"},
+							HTTP: echo.HTTP{
+								Path:    "/",
+								Headers: headers.New().WithHost("my.domain.example").Build(),
 							},
 						})
 					})
@@ -219,7 +219,9 @@ func TestGateway(t *testing.T) {
 						_ = apps.PodA[0].CallWithRetryOrFail(t, echo.CallOptions{
 							Target:   apps.PodB[0],
 							PortName: "http",
-							Path:     "/path",
+							HTTP: echo.HTTP{
+								Path: "/path",
+							},
 							Check: check.And(
 								check.OK(),
 								check.RequestHeader("My-Added-Header", "added-value")),
@@ -266,8 +268,8 @@ func TestGateway(t *testing.T) {
 					apps.PodB[0].CallWithRetryOrFail(t, echo.CallOptions{
 						Port:   &echo.Port{ServicePort: 80},
 						Scheme: scheme.HTTP,
-						Headers: map[string][]string{
-							"Host": {"bar.example.com"},
+						HTTP: echo.HTTP{
+							Headers: headers.New().WithHost("bar.example.com").Build(),
 						},
 						Address: fmt.Sprintf("gateway.%s.svc.cluster.local", apps.Namespace.Name()),
 						Check:   check.OK(),
@@ -395,9 +397,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/test",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/test",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: successChecker,
 						Count: count,
@@ -412,9 +414,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/prefix/should/match",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/prefix/should/match",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: successChecker,
 						Count: count,
@@ -429,9 +431,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/prefix/test",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/prefix/test",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: successChecker,
 						Count: count,
@@ -446,9 +448,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/prefix/test/",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/prefix/test/",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: successChecker,
 						Count: count,
@@ -463,9 +465,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/prefix/testrandom/",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/prefix/testrandom/",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: failureChecker,
 						Count: count,
@@ -480,9 +482,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/testrandom",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/testrandom",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: successChecker,
 						Count: count,
@@ -497,13 +499,15 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTPS,
 						},
-						Path: "/test",
-						Headers: map[string][]string{
-							"Host": {"foo.example.com"},
+						HTTP: echo.HTTP{
+							Path:    "/test",
+							Headers: headers.New().WithHost("foo.example.com").Build(),
+						},
+						TLS: echo.TLS{
+							CaCert: ingressutil.IngressCredentialA.CaCert,
 						},
-						CaCert: ingressutil.IngressCredentialA.CaCert,
-						Check:  successChecker,
-						Count:  count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -515,13 +519,15 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTPS,
 						},
-						Path: "/test",
-						Headers: map[string][]string{
-							"Host": {"bar.example.com"},
+						HTTP: echo.HTTP{
+							Path:    "/test",
+							Headers: headers.New().WithHost("bar.example.com").Build(),
+						},
+						TLS: echo.TLS{
+							CaCert: ingressutil.IngressCredentialB.CaCert,
 						},
-						CaCert: ingressutil.IngressCredentialB.CaCert,
-						Check:  successChecker,
-						Count:  count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -533,13 +539,15 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTPS,
 						},
-						Path: "/test/namedport",
-						Headers: map[string][]string{
-							"Host": {"bar.example.com"},
+						HTTP: echo.HTTP{
+							Path:    "/test/namedport",
+							Headers: headers.New().WithHost("bar.example.com").Build(),
+						},
+						TLS: echo.TLS{
+							CaCert: ingressutil.IngressCredentialB.CaCert,
 						},
-						CaCert: ingressutil.IngressCredentialB.CaCert,
-						Check:  successChecker,
-						Count:  count,
+						Check: successChecker,
+						Count: count,
 					},
 					path:       "/test",
 					prefixPath: "/prefix",
@@ -634,9 +642,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/update-test",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/update-test",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: func(rs echoClient.Responses, err error) error {
 							if err != nil {
@@ -655,9 +663,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/update-test",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/update-test",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: check.OK(),
 					},
@@ -670,9 +678,9 @@ func TestIngress(t *testing.T) {
 						Port: &echo.Port{
 							Protocol: protocol.HTTP,
 						},
-						Path: "/updated",
-						Headers: map[string][]string{
-							"Host": {"server"},
+						HTTP: echo.HTTP{
+							Path:    "/updated",
+							Headers: headers.New().WithHost("server").Build(),
 						},
 						Check: check.OK(),
 					},
@@ -702,10 +710,10 @@ func TestCustomGateway(t *testing.T) {
 			}
 
 			templateParams := map[string]string{
-				"imagePullSecret": image.PullSecretNameOrFail(t),
+				"imagePullSecret": t.Settings().Image.PullSecretNameOrFail(t),
 				"injectLabel":     injectLabel,
 				"host":            apps.PodA[0].Config().ClusterLocalFQDN(),
-				"imagePullPolicy": image.PullImagePolicy(t),
+				"imagePullPolicy": t.Settings().Image.PullPolicy,
 			}
 
 			t.NewSubTest("minimal").Run(func(t framework.TestContext) {
diff --git a/tests/integration/pilot/locality_test.go b/tests/integration/pilot/locality_test.go
index 37c7dd2be0..74d013f9f3 100644
--- a/tests/integration/pilot/locality_test.go
+++ b/tests/integration/pilot/locality_test.go
@@ -31,7 +31,6 @@
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/scopes"
 	"istio.io/istio/tests/integration/pilot/common"
 )
@@ -115,7 +114,7 @@ func TestLocality(t *testing.T) {
 			destA := apps.PodB[0]
 			destB := apps.PodC[0]
 			destC := apps.Naked[0]
-			if !t.Settings().Skip(echotypes.VM) {
+			if !t.Settings().Skip(echo.VM) {
 				// TODO do we even need this to be a VM
 				destC = apps.VM[0]
 			}
@@ -256,9 +255,11 @@ func sendTrafficOrFail(t framework.TestContext, from echo.Instance, host string,
 	_ = from.CallWithRetryOrFail(t, echo.CallOptions{
 		Target:   from,
 		PortName: "http",
-		Headers:  headers,
-		Count:    sendCount,
-		Check:    checker,
+		HTTP: echo.HTTP{
+			Headers: headers,
+		},
+		Count: sendCount,
+		Check: checker,
 	})
 }
 
diff --git a/tests/integration/pilot/mirror_test.go b/tests/integration/pilot/mirror_test.go
index 3891a6d591..5b0640fffb 100644
--- a/tests/integration/pilot/mirror_test.go
+++ b/tests/integration/pilot/mirror_test.go
@@ -174,7 +174,7 @@ func sendTrafficMirror(from, to echo.Instance, proto protocol.Instance, testID s
 	}
 	switch proto {
 	case protocol.HTTP:
-		options.Path = "/" + testID
+		options.HTTP.Path = "/" + testID
 	case protocol.GRPC:
 		options.Message = testID
 	default:
diff --git a/tests/integration/pilot/original_src_addr_test.go b/tests/integration/pilot/original_src_addr_test.go
index ce3526541c..9bf8ec7fea 100644
--- a/tests/integration/pilot/original_src_addr_test.go
+++ b/tests/integration/pilot/original_src_addr_test.go
@@ -25,7 +25,6 @@
 	"istio.io/istio/pkg/test/echo/common/scheme"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/echo"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 )
 
 func TestTproxy(t *testing.T) {
@@ -34,7 +33,7 @@ func TestTproxy(t *testing.T) {
 		Features("traffic.original-source-ip").
 		RequiresSingleCluster().
 		Run(func(t framework.TestContext) {
-			if t.Settings().Skip(echotypes.TProxy) {
+			if t.Settings().Skip(echo.TProxy) {
 				t.Skip()
 			}
 			workloads, err := apps.PodA[0].Workloads()
diff --git a/tests/integration/pilot/vm_test.go b/tests/integration/pilot/vm_test.go
index 8f761f2755..d5f3f3b7b8 100644
--- a/tests/integration/pilot/vm_test.go
+++ b/tests/integration/pilot/vm_test.go
@@ -35,7 +35,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	echocommon "istio.io/istio/pkg/test/framework/components/echo/common"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/echo/kube"
 	"istio.io/istio/pkg/test/framework/label"
 	"istio.io/istio/pkg/test/scopes"
@@ -60,7 +59,7 @@ func TestVmOSPost(t *testing.T) {
 		Features("traffic.reachability").
 		Label(label.Postsubmit).
 		Run(func(t framework.TestContext) {
-			if t.Settings().Skip(echotypes.VM) {
+			if t.Settings().Skip(echo.VM) {
 				t.Skip("VM tests are disabled")
 			}
 			b := echoboot.NewBuilder(t, t.Clusters().Primaries().Default())
@@ -95,7 +94,7 @@ func TestVMRegistrationLifecycle(t *testing.T) {
 		RequiresSingleCluster().
 		Features("vm.autoregistration").
 		Run(func(t framework.TestContext) {
-			if t.Settings().Skip(echotypes.VM) {
+			if t.Settings().Skip(echo.VM) {
 				t.Skip()
 			}
 			scaleDeploymentOrFail(t, "istiod", i.Settings().SystemNamespace, 2)
diff --git a/tests/integration/security/authorization_test.go b/tests/integration/security/authorization_test.go
index 81e4170063..38508754de 100644
--- a/tests/integration/security/authorization_test.go
+++ b/tests/integration/security/authorization_test.go
@@ -81,8 +81,10 @@ func TestAuthorization_mTLS(t *testing.T) {
 									Target:   to[0],
 									PortName: "http",
 									Scheme:   scheme.HTTP,
-									Path:     path,
-									Count:    callCount,
+									HTTP: echo.HTTP{
+										Path: path,
+									},
+									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -148,9 +150,11 @@ func TestAuthorization_JWT(t *testing.T) {
 									Target:   to[0],
 									PortName: "http",
 									Scheme:   scheme.HTTP,
-									Path:     path,
-									Count:    callCount,
-									Headers:  headers.New().WithAuthz(jwt).Build(),
+									HTTP: echo.HTTP{
+										Path:    path,
+										Headers: headers.New().WithAuthz(jwt).Build(),
+									},
+									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -240,8 +244,10 @@ func TestAuthorization_WorkloadSelector(t *testing.T) {
 						Target:   to[0],
 						PortName: "http",
 						Scheme:   scheme.HTTP,
-						Path:     path,
-						Count:    callCount,
+						HTTP: echo.HTTP{
+							Path: path,
+						},
+						Count: callCount,
 					}
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -386,8 +392,10 @@ func TestAuthorization_Deny(t *testing.T) {
 								Target:   to[0],
 								PortName: "http",
 								Scheme:   scheme.HTTP,
-								Path:     path,
-								Count:    callCount,
+								HTTP: echo.HTTP{
+									Path: path,
+								},
+								Count: callCount,
 							}
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -477,8 +485,10 @@ func TestAuthorization_NegativeMatch(t *testing.T) {
 								Target:   to[0],
 								PortName: "http",
 								Scheme:   scheme.HTTP,
-								Path:     path,
-								Count:    callCount,
+								HTTP: echo.HTTP{
+									Path: path,
+								},
+								Count: callCount,
 							}
 							if expectAllowed {
 								opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -721,9 +731,11 @@ func TestAuthorization_IngressGateway(t *testing.T) {
 								Port: &echo.Port{
 									Protocol: protocol.HTTP,
 								},
-								Path:    tc.Path,
-								Headers: headers.New().WithHost(tc.Host).WithXForwardedFor(tc.IP).Build(),
-								Check:   check.Status(tc.WantCode),
+								HTTP: echo.HTTP{
+									Path:    tc.Path,
+									Headers: headers.New().WithHost(tc.Host).WithXForwardedFor(tc.IP).Build(),
+								},
+								Check: check.Status(tc.WantCode),
 							}
 							ingr.CallWithRetryOrFail(t, opts)
 						})
@@ -893,7 +905,9 @@ func TestAuthorization_TCP(t *testing.T) {
 						Target:   to[0],
 						PortName: portName,
 						Scheme:   s,
-						Path:     "/data",
+						HTTP: echo.HTTP{
+							Path: "/data",
+						},
 					}
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -1068,9 +1082,11 @@ func TestAuthorization_Conditions(t *testing.T) {
 										Target:   to[0],
 										PortName: "http",
 										Scheme:   scheme.HTTP,
-										Path:     path,
-										Headers:  headers,
-										Count:    callCount,
+										HTTP: echo.HTTP{
+											Path:    path,
+											Headers: headers,
+										},
+										Count: callCount,
 									}
 									if expectAllowed {
 										opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -1246,8 +1262,10 @@ func TestAuthorization_Path(t *testing.T) {
 									Target:   to[0],
 									PortName: "http",
 									Scheme:   scheme.HTTP,
-									Path:     path,
-									Count:    callCount,
+									HTTP: echo.HTTP{
+										Path: path,
+									},
+									Count: callCount,
 								}
 								if expectAllowed {
 									opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -1324,7 +1342,9 @@ func TestAuthorization_Audit(t *testing.T) {
 						Target:   to[0],
 						PortName: "http",
 						Scheme:   scheme.HTTP,
-						Path:     path,
+						HTTP: echo.HTTP{
+							Path: path,
+						},
 					}
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(to, &opts))
@@ -1468,8 +1488,10 @@ func TestAuthorization_Custom(t *testing.T) {
 						Target:   to,
 						PortName: port,
 						Scheme:   s,
-						Path:     path,
-						Headers:  headers,
+						HTTP: echo.HTTP{
+							Path:    path,
+							Headers: headers,
+						},
 					}
 					if expectAllowed {
 						opts.Check = check.And(check.OK(), scheck.ReachedClusters(echo.Instances{to}, &opts))
@@ -1559,11 +1581,13 @@ func TestAuthorization_Custom(t *testing.T) {
 								Protocol: protocol.HTTP,
 							},
 							Scheme: scheme.HTTP,
-							Path:   path,
-							Headers: headers.New().
-								WithHost("www.company.com").
-								With("X-Ext-Authz", h.Get("x-ext-authz")).
-								Build(),
+							HTTP: echo.HTTP{
+								Path: path,
+								Headers: headers.New().
+									WithHost("www.company.com").
+									With("X-Ext-Authz", h.Get("x-ext-authz")).
+									Build(),
+							},
 						}
 						if expectAllowed {
 							opts.Check = check.And(check.OK(), scheck.ReachedClusters(echo.Instances{to}, &opts))
@@ -1625,6 +1649,6 @@ func newRbacTestName(prefix string, expectAllowed bool, from echo.Instance, opts
 		from.Config().Service,
 		opts.Target.Config().Service,
 		opts.PortName,
-		opts.Path,
+		opts.HTTP.Path,
 		want))
 }
diff --git a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
index 49fba5fb40..e3b6e4f0ef 100644
--- a/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
+++ b/tests/integration/security/ca_custom_root/trust_domain_validation_test.go
@@ -138,8 +138,10 @@ func(ctx framework.TestContext) {
 								PortName: port,
 								Address:  "server",
 								Scheme:   s,
-								Cert:     trustDomains[td].cert,
-								Key:      trustDomains[td].key,
+								TLS: echo.TLS{
+									Cert: trustDomains[td].cert,
+									Key:  trustDomains[td].key,
+								},
 							}
 							retry.UntilSuccessOrFail(t, func() error {
 								var resp echoClient.Responses
diff --git a/tests/integration/security/egress_gateway_origination_test.go b/tests/integration/security/egress_gateway_origination_test.go
index 3394d9a882..f65c0bcf4a 100644
--- a/tests/integration/security/egress_gateway_origination_test.go
+++ b/tests/integration/security/egress_gateway_origination_test.go
@@ -25,6 +25,7 @@
 	"strings"
 	"testing"
 
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
@@ -359,8 +360,8 @@ func CallOpts(dest echo.Instance, host string, tc TLSTestCase) echo.CallOptions
 		Count:    util.CallsPerCluster,
 		PortName: "http",
 		Scheme:   scheme.HTTP,
-		Headers: map[string][]string{
-			"Host": {host},
+		HTTP: echo.HTTP{
+			Headers: headers.New().WithHost(host).Build(),
 		},
 		Check: check.And(
 			check.NoError(),
diff --git a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
index 1335b1e727..9d72675522 100644
--- a/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
+++ b/tests/integration/security/filebased_tls_origination/egress_gateway_origination_test.go
@@ -30,6 +30,7 @@
 	envoyAdmin "github.com/envoyproxy/go-control-plane/envoy/admin/v3"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
@@ -130,8 +131,8 @@ func TestEgressGatewayTls(t *testing.T) {
 						opts := echo.CallOptions{
 							Target:   externalServer,
 							PortName: "http",
-							Headers: map[string][]string{
-								"Host": {host},
+							HTTP: echo.HTTP{
+								Headers: headers.New().WithHost(host).Build(),
 							},
 							Check: check.And(
 								check.NoError(),
diff --git a/tests/integration/security/https_jwt/https_jwt_test.go b/tests/integration/security/https_jwt/https_jwt_test.go
index 60fcbc4be8..d393b5448f 100644
--- a/tests/integration/security/https_jwt/https_jwt_test.go
+++ b/tests/integration/security/https_jwt/https_jwt_test.go
@@ -84,8 +84,8 @@ func TestJWTHTTPS(t *testing.T) {
 					name:       "valid-token-forward-remote-jwks",
 					policyFile: "./testdata/remotehttps.yaml.tmpl",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token-forward-remote-jwks"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-token-forward-remote-jwks"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
diff --git a/tests/integration/security/jwt_test.go b/tests/integration/security/jwt_test.go
index 64e78e2901..43fe7094ad 100644
--- a/tests/integration/security/jwt_test.go
+++ b/tests/integration/security/jwt_test.go
@@ -103,8 +103,8 @@ type testCase struct {
 				{
 					name: "valid-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token-noauthz"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-token-noauthz"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
@@ -117,8 +117,8 @@ type testCase struct {
 				{
 					name: "valid-token-2-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token-2-noauthz"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
+						opts.HTTP.Path = "/valid-token-2-noauthz"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
@@ -131,17 +131,17 @@ type testCase struct {
 				{
 					name: "expired-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/expired-token-noauthz"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.HTTP.Path = "/expired-token-noauthz"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
 				{
 					name: "expired-token-cors-preflight-request-allowed",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/expired-token-cors-preflight-request-allowed"
-						opts.Method = "OPTIONS"
-						opts.Headers = headers.New().
+						opts.HTTP.Path = "/expired-token-cors-preflight-request-allowed"
+						opts.HTTP.Method = "OPTIONS"
+						opts.HTTP.Headers = headers.New().
 							WithAuthz(jwt.TokenExpired).
 							With(headers.AccessControlRequestMethod, "POST").
 							With(headers.Origin, "https://istio.io").
@@ -154,9 +154,9 @@ type testCase struct {
 				{
 					name: "expired-token-bad-cors-preflight-request-rejected",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/expired-token-cors-preflight-request-allowed"
-						opts.Method = "OPTIONS"
-						opts.Headers = headers.New().
+						opts.HTTP.Path = "/expired-token-cors-preflight-request-allowed"
+						opts.HTTP.Method = "OPTIONS"
+						opts.HTTP.Headers = headers.New().
 							WithAuthz(jwt.TokenExpired).
 							With(headers.AccessControlRequestMethod, "POST").
 							// the required Origin header is missing.
@@ -167,7 +167,7 @@ type testCase struct {
 				{
 					name: "no-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/no-token-noauthz"
+						opts.HTTP.Path = "/no-token-noauthz"
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -179,8 +179,8 @@ type testCase struct {
 				{
 					name: "valid-token",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-token"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
@@ -190,15 +190,15 @@ type testCase struct {
 				{
 					name: "expired-token",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/expired-token"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.HTTP.Path = "/expired-token"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
 				{
 					name: "no-token",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/no-token"
+						opts.HTTP.Path = "/no-token"
 						opts.Check = check.Status(http.StatusForbidden)
 					},
 				},
@@ -208,7 +208,7 @@ type testCase struct {
 				{
 					name: "no-authn-authz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/no-authn-authz"
+						opts.HTTP.Path = "/no-authn-authz"
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -220,8 +220,8 @@ type testCase struct {
 				{
 					name: "valid-token-forward",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token-forward"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-token-forward"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
@@ -237,8 +237,8 @@ type testCase struct {
 				{
 					name: "valid-token-forward-remote-jwks",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token-forward-remote-jwks"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-token-forward-remote-jwks"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts),
@@ -254,16 +254,16 @@ type testCase struct {
 				{
 					name: "invalid-aud",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-aud"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = "/valid-aud"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.Status(http.StatusForbidden)
 					},
 				},
 				{
 					name: "valid-aud",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-aud"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1WithAud).Build()
+						opts.HTTP.Path = "/valid-aud"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1WithAud).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -272,8 +272,8 @@ type testCase struct {
 				{
 					name: "verify-policies-are-combined",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/verify-policies-are-combined"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
+						opts.HTTP.Path = "/verify-policies-are-combined"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer2).Build()
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -285,23 +285,23 @@ type testCase struct {
 				{
 					name: "invalid-jwks-valid-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = ""
-						opts.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
+						opts.HTTP.Path = ""
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenIssuer1).Build()
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
 				{
 					name: "invalid-jwks-expired-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/invalid-jwks-valid-token-noauthz"
-						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.HTTP.Path = "/invalid-jwks-valid-token-noauthz"
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
 				{
 					name: "invalid-jwks-no-token-noauthz",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/invalid-jwks-no-token-noauthz"
+						opts.HTTP.Path = "/invalid-jwks-no-token-noauthz"
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -313,7 +313,7 @@ type testCase struct {
 				{
 					name: "valid-params",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1
+						opts.HTTP.Path = "/valid-token?token=" + jwt.TokenIssuer1
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -322,7 +322,7 @@ type testCase struct {
 				{
 					name: "valid-params-secondary",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token?secondary_token=" + jwt.TokenIssuer1
+						opts.HTTP.Path = "/valid-token?secondary_token=" + jwt.TokenIssuer1
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -331,14 +331,14 @@ type testCase struct {
 				{
 					name: "invalid-params",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token?token_value=" + jwt.TokenIssuer1
+						opts.HTTP.Path = "/valid-token?token_value=" + jwt.TokenIssuer1
 						opts.Check = check.Status(http.StatusForbidden)
 					},
 				},
 				{
 					name: "valid-token-set",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenIssuer1
+						opts.HTTP.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenIssuer1
 						opts.Check = check.And(
 							check.OK(),
 							scheck.ReachedClusters(to, opts))
@@ -347,15 +347,15 @@ type testCase struct {
 				{
 					name: "invalid-token-set",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenExpired
+						opts.HTTP.Path = "/valid-token?token=" + jwt.TokenIssuer1 + "&secondary_token=" + jwt.TokenExpired
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
 				{
 					name: "valid-header",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = ""
-						opts.Headers = headers.New().
+						opts.HTTP.Path = ""
+						opts.HTTP.Headers = headers.New().
 							With("X-Jwt-Token", "Value "+jwt.TokenIssuer1).
 							Build()
 						opts.Check = check.And(
@@ -366,8 +366,8 @@ type testCase struct {
 				{
 					name: "valid-header-secondary",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = ""
-						opts.Headers = headers.New().
+						opts.HTTP.Path = ""
+						opts.HTTP.Headers = headers.New().
 							With("Auth-Token", "Token "+jwt.TokenIssuer1).
 							Build()
 						opts.Check = check.And(
@@ -378,8 +378,8 @@ type testCase struct {
 				{
 					name: "invalid-header",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Path = ""
-						opts.Headers = headers.New().
+						opts.HTTP.Path = ""
+						opts.HTTP.Headers = headers.New().
 							With("Auth-Header-Param", "Bearer "+jwt.TokenIssuer1).
 							Build()
 						opts.Check = check.Status(http.StatusForbidden)
@@ -458,7 +458,7 @@ type testCase struct {
 				{
 					name: "in-mesh-with-expired-token",
 					customizeCall: func(to echo.Instances, opts *echo.CallOptions) {
-						opts.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
+						opts.HTTP.Headers = headers.New().WithAuthz(jwt.TokenExpired).Build()
 						opts.Check = check.Status(http.StatusUnauthorized)
 					},
 				},
@@ -490,16 +490,16 @@ type testCase struct {
 						{
 							name: "deny without token",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().WithHost("example.com").Build()
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().WithHost("example.com").Build()
 								opts.Check = check.Status(http.StatusForbidden)
 							},
 						},
 						{
 							name: "allow with sub-1 token",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("example.com").
 									WithAuthz(jwt.TokenIssuer1).
 									Build()
@@ -509,8 +509,8 @@ type testCase struct {
 						{
 							name: "deny with sub-2 token",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("example.com").
 									WithAuthz(jwt.TokenIssuer2).
 									Build()
@@ -520,8 +520,8 @@ type testCase struct {
 						{
 							name: "deny with expired token",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("example.com").
 									WithAuthz(jwt.TokenExpired).
 									Build()
@@ -531,8 +531,8 @@ type testCase struct {
 						{
 							name: "allow with sub-1 token on any.com",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("any-request-principlal-ok.com").
 									WithAuthz(jwt.TokenIssuer1).
 									Build()
@@ -542,8 +542,8 @@ type testCase struct {
 						{
 							name: "allow with sub-2 token on any.com",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("any-request-principlal-ok.com").
 									WithAuthz(jwt.TokenIssuer2).
 									Build()
@@ -553,8 +553,8 @@ type testCase struct {
 						{
 							name: "deny without token on any.com",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("any-request-principlal-ok.com").
 									Build()
 								opts.Check = check.Status(http.StatusForbidden)
@@ -563,8 +563,8 @@ type testCase struct {
 						{
 							name: "deny with token on other host",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/"
+								opts.HTTP.Headers = headers.New().
 									WithHost("other-host.com").
 									WithAuthz(jwt.TokenIssuer1).
 									Build()
@@ -574,8 +574,8 @@ type testCase struct {
 						{
 							name: "allow healthz",
 							customizeCall: func(opts *echo.CallOptions) {
-								opts.Path = "/healthz"
-								opts.Headers = headers.New().
+								opts.HTTP.Path = "/healthz"
+								opts.HTTP.Headers = headers.New().
 									WithHost("example.com").
 									Build()
 								opts.Check = check.OK()
diff --git a/tests/integration/security/main_test.go b/tests/integration/security/main_test.go
index 63513d824d..274308b1f9 100644
--- a/tests/integration/security/main_test.go
+++ b/tests/integration/security/main_test.go
@@ -24,7 +24,6 @@
 
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/istio"
-	"istio.io/istio/pkg/test/framework/image"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/tests/integration/security/util"
 	"istio.io/pkg/log"
@@ -49,11 +48,6 @@ func setupConfig(ctx resource.Context, cfg *istio.Config) {
 	if cfg == nil {
 		return
 	}
-	img, err := image.SettingsFromCommandLine()
-	if err != nil {
-		panic(err)
-	}
-
 	controlPlaneValues := `
 values:
   pilot: 
@@ -68,7 +62,7 @@ func setupConfig(ctx resource.Context, cfg *istio.Config) {
       numTrustedProxies: 1`
 
 	imageType := "default"
-	if strings.HasSuffix(img.Tag, "-distroless") {
+	if strings.HasSuffix(ctx.Settings().Image.Tag, "-distroless") {
 		imageType = "distroless"
 	}
 
diff --git a/tests/integration/security/normalization_test.go b/tests/integration/security/normalization_test.go
index 8f5b009d5e..c005dda426 100644
--- a/tests/integration/security/normalization_test.go
+++ b/tests/integration/security/normalization_test.go
@@ -235,8 +235,10 @@ type expect struct {
 									checker = check.Status(http.StatusBadRequest)
 								}
 								c.CallWithRetryOrFail(t, echo.CallOptions{
-									Target:   apps.B[0],
-									Path:     tt.in,
+									Target: apps.B[0],
+									HTTP: echo.HTTP{
+										Path: tt.in,
+									},
 									PortName: "http",
 									Check:    checker,
 								})
diff --git a/tests/integration/security/pass_through_filter_chain_test.go b/tests/integration/security/pass_through_filter_chain_test.go
index 8145eef2a6..eee0de04ef 100644
--- a/tests/integration/security/pass_through_filter_chain_test.go
+++ b/tests/integration/security/pass_through_filter_chain_test.go
@@ -23,6 +23,7 @@
 	"testing"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
@@ -645,8 +646,8 @@ func(instances echo.Instances) echo.Instances { return instances.Match(echo.Name
 								callOpt := echo.CallOptions{
 									Count: util.CallsPerCluster * len(dest),
 									Port:  expect.port,
-									Headers: map[string][]string{
-										"Host": {host},
+									HTTP: echo.HTTP{
+										Headers: headers.New().WithHost(host).Build(),
 									},
 									Message: "HelloWorld",
 									// Do not set Target to dest, otherwise fillInCallOptions() will
diff --git a/tests/integration/security/reachability_test.go b/tests/integration/security/reachability_test.go
index c0897cbab3..75def4e333 100644
--- a/tests/integration/security/reachability_test.go
+++ b/tests/integration/security/reachability_test.go
@@ -201,12 +201,16 @@ func TestReachability(t *testing.T) {
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vistio",
+							HTTP: echo.HTTP{
+								Path: "/vistio",
+							},
 						},
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vlegacy",
+							HTTP: echo.HTTP{
+								Path: "/vlegacy",
+							},
 						},
 					},
 					Include: func(src echo.Instance, opts echo.CallOptions) bool {
@@ -215,7 +219,7 @@ func TestReachability(t *testing.T) {
 					},
 					ExpectSuccess: Always,
 					ExpectMTLS: func(src echo.Instance, opts echo.CallOptions) bool {
-						return opts.Path == "/vistio"
+						return opts.HTTP.Path == "/vistio"
 					},
 				},
 				{
@@ -225,12 +229,16 @@ func TestReachability(t *testing.T) {
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vistio",
+							HTTP: echo.HTTP{
+								Path: "/vistio",
+							},
 						},
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vlegacy",
+							HTTP: echo.HTTP{
+								Path: "/vlegacy",
+							},
 						},
 					},
 					Include: func(src echo.Instance, opts echo.CallOptions) bool {
@@ -239,7 +247,7 @@ func TestReachability(t *testing.T) {
 					},
 					ExpectSuccess: func(src echo.Instance, opts echo.CallOptions) bool {
 						// Only the request to legacy one succeeds as we disable mtls explicitly.
-						return opts.Path == "/vlegacy"
+						return opts.HTTP.Path == "/vlegacy"
 					},
 					ExpectMTLS: Never,
 				},
@@ -250,12 +258,16 @@ func TestReachability(t *testing.T) {
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vistio",
+							HTTP: echo.HTTP{
+								Path: "/vistio",
+							},
 						},
 						{
 							PortName: "http",
 							Scheme:   scheme.HTTP,
-							Path:     "/vlegacy",
+							HTTP: echo.HTTP{
+								Path: "/vlegacy",
+							},
 						},
 					},
 					Include: func(src echo.Instance, opts echo.CallOptions) bool {
@@ -264,10 +276,10 @@ func TestReachability(t *testing.T) {
 					},
 					ExpectSuccess: func(src echo.Instance, opts echo.CallOptions) bool {
 						// Only the request to vistio one succeeds as we enable mtls explicitly.
-						return opts.Path == "/vistio"
+						return opts.HTTP.Path == "/vistio"
 					},
 					ExpectMTLS: func(src echo.Instance, opts echo.CallOptions) bool {
-						return opts.Path == "/vistio"
+						return opts.HTTP.Path == "/vistio"
 					},
 				},
 				// ----- end of automtls partial test suites -----
diff --git a/tests/integration/security/sds_ingress/util/util.go b/tests/integration/security/sds_ingress/util/util.go
index a23cc71266..55cd965132 100644
--- a/tests/integration/security/sds_ingress/util/util.go
+++ b/tests/integration/security/sds_ingress/util/util.go
@@ -33,6 +33,7 @@
 	"sigs.k8s.io/yaml"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/check"
@@ -41,7 +42,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/istio/ingress"
 	"istio.io/istio/pkg/test/framework/components/namespace"
@@ -292,12 +292,14 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 		Port: &echo.Port{
 			Protocol: protocol.HTTPS,
 		},
-		Path: fmt.Sprintf("/%s", path),
-		Headers: map[string][]string{
-			"Host": {host},
+		HTTP: echo.HTTP{
+			HTTP3:   useHTTP3,
+			Path:    fmt.Sprintf("/%s", path),
+			Headers: headers.New().WithHost(host).Build(),
+		},
+		TLS: echo.TLS{
+			CaCert: tlsCtx.CaCert,
 		},
-		HTTP3:  useHTTP3,
-		CaCert: tlsCtx.CaCert,
 		Check: func(resp echoClient.Responses, err error) error {
 			// Check that the error message is expected.
 			if err != nil {
@@ -320,8 +322,8 @@ func doSendRequestsOrFail(ctx framework.TestContext, ing ingress.Instance, host
 	}
 
 	if callType == Mtls {
-		opts.Key = tlsCtx.PrivateKey
-		opts.Cert = tlsCtx.Cert
+		opts.TLS.Key = tlsCtx.PrivateKey
+		opts.TLS.Cert = tlsCtx.Cert
 	}
 
 	// Certs occasionally take quite a while to become active in Envoy, so retry for a long time (2min)
@@ -399,7 +401,7 @@ func SetupTest(ctx resource.Context, apps *EchoDeployments) error {
 	if err != nil {
 		return err
 	}
-	buildVM := !ctx.Settings().Skip(echotypes.VM)
+	buildVM := !ctx.Settings().Skip(echo.VM)
 	echos, err := echoboot.NewBuilder(ctx).
 		WithClusters(ctx.Clusters()...).
 		WithConfig(EchoConfig(ASvc, apps.ServerNs, false)).
diff --git a/tests/integration/security/sds_ingress_k8sca/main_test.go b/tests/integration/security/sds_ingress_k8sca/main_test.go
index 1840bb42a2..c2754a6300 100644
--- a/tests/integration/security/sds_ingress_k8sca/main_test.go
+++ b/tests/integration/security/sds_ingress_k8sca/main_test.go
@@ -21,7 +21,7 @@
 	"testing"
 
 	"istio.io/istio/pkg/test/framework"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
+	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/resource"
 	"istio.io/istio/tests/integration/security/sds_ingress/util"
@@ -45,7 +45,8 @@ func TestMain(m *testing.M) {
 		Setup(istio.Setup(&inst, setupConfig)).
 		Setup(func(ctx resource.Context) (err error) {
 			// Skip VM as eastwest gateway is disabled.
-			ctx.Settings().SkipWorkloadClasses.Insert(echotypes.VM)
+			s := ctx.Settings()
+			s.SkipWorkloadClasses = append(s.SkipWorkloadClasses, echo.VM)
 			return util.SetupTest(ctx, apps)
 		}).
 		Run()
diff --git a/tests/integration/security/util/cert/cert.go b/tests/integration/security/util/cert/cert.go
index 6a7ed40a55..fd83dbf7f5 100644
--- a/tests/integration/security/util/cert/cert.go
+++ b/tests/integration/security/util/cert/cert.go
@@ -43,7 +43,9 @@ func DumpCertFromSidecar(t test.Failer, from, to echo.Instance, port string) []s
 		Target:   to,
 		PortName: port,
 		Scheme:   scheme.TLS,
-		Alpn:     []string{"istio"},
+		TLS: echo.TLS{
+			Alpn: []string{"istio"},
+		},
 	})
 	if resp.Len() != 1 {
 		t.Fatalf("dump cert failed, no responses")
diff --git a/tests/integration/security/util/framework.go b/tests/integration/security/util/framework.go
index d1ef762811..03df4313f4 100644
--- a/tests/integration/security/util/framework.go
+++ b/tests/integration/security/util/framework.go
@@ -29,7 +29,6 @@
 	"istio.io/istio/pkg/test/framework/components/echo"
 	"istio.io/istio/pkg/test/framework/components/echo/echoboot"
 	"istio.io/istio/pkg/test/framework/components/echo/echotest"
-	"istio.io/istio/pkg/test/framework/components/echo/echotypes"
 	"istio.io/istio/pkg/test/framework/components/istio"
 	"istio.io/istio/pkg/test/framework/components/namespace"
 	"istio.io/istio/pkg/test/framework/resource"
@@ -177,7 +176,7 @@ func MustReadCert(f string) string {
 }
 
 func SetupApps(ctx resource.Context, i istio.Instance, apps *EchoDeployments, buildVM bool) error {
-	if ctx.Settings().Skip(echotypes.VM) {
+	if ctx.Settings().Skip(echo.VM) {
 		buildVM = false
 	}
 	var err error
diff --git a/tests/integration/security/util/reachability/context.go b/tests/integration/security/util/reachability/context.go
index 5645c1437a..a325b1bd91 100644
--- a/tests/integration/security/util/reachability/context.go
+++ b/tests/integration/security/util/reachability/context.go
@@ -184,7 +184,7 @@ func Run(testCases []TestCase, t framework.TestContext, apps *util.EchoDeploymen
 										opts.Scheme,
 										dest.Config().Service,
 										opts.PortName,
-										opts.Path,
+										opts.HTTP.Path,
 										tpe)
 
 									t.NewSubTest(subTestName).
diff --git a/tests/integration/telemetry/outboundtrafficpolicy/helper.go b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
index c21fa840b4..8d939ba44e 100644
--- a/tests/integration/telemetry/outboundtrafficpolicy/helper.go
+++ b/tests/integration/telemetry/outboundtrafficpolicy/helper.go
@@ -25,6 +25,7 @@
 	"testing"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	echoClient "istio.io/istio/pkg/test/echo"
 	"istio.io/istio/pkg/test/echo/common"
 	"istio.io/istio/pkg/test/env"
@@ -255,10 +256,10 @@ func RunExternalRequest(t *testing.T, cases []*TestCase, prometheus prometheus.I
 					client.CallWithRetryOrFail(t, echo.CallOptions{
 						Target:   dest,
 						PortName: tc.PortName,
-						Headers: map[string][]string{
-							"Host": {tc.Host},
+						HTTP: echo.HTTP{
+							HTTP2:   tc.HTTP2,
+							Headers: headers.New().WithHost(tc.Host).Build(),
 						},
-						HTTP2: tc.HTTP2,
 						Check: func(rs echoClient.Responses, err error) error {
 							// the expected response from a blackhole test case will have err
 							// set; use the length of the expected code to ignore this condition
diff --git a/tests/integration/telemetry/stackdriver/common.go b/tests/integration/telemetry/stackdriver/common.go
index 93b1c91684..5d580f81d2 100644
--- a/tests/integration/telemetry/stackdriver/common.go
+++ b/tests/integration/telemetry/stackdriver/common.go
@@ -177,8 +177,10 @@ func SendTraffic(cltInstance echo.Instance, headers http.Header, onlyTCP bool) e
 	httpOpts := echo.CallOptions{
 		Target:   Srv[0],
 		PortName: "http",
-		Headers:  headers,
-		Count:    telemetry.RequestCountMultipler * len(Srv),
+		HTTP: echo.HTTP{
+			Headers: headers,
+		},
+		Count: telemetry.RequestCountMultipler * len(Srv),
 	}
 	if _, err := cltInstance.Call(grpcOpts); err != nil {
 		return err
diff --git a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
index fda033dec9..8193472a26 100644
--- a/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
+++ b/tests/integration/telemetry/stackdriver/stackdriver_filter_audit_test.go
@@ -133,9 +133,11 @@ func sendTrafficForAudit(t test.Failer, cltInstance echo.Instance) error {
 		return echo.CallOptions{
 			Target:   Srv[0],
 			PortName: "http",
-			Headers:  headers,
-			Path:     path,
-			Count:    telemetry.RequestCountMultipler,
+			HTTP: echo.HTTP{
+				Headers: headers,
+				Path:    path,
+			},
+			Count: telemetry.RequestCountMultipler,
 		}
 	}
 
diff --git a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
index d827a35888..110f677053 100644
--- a/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
+++ b/tests/integration/telemetry/stats/prometheus/customizemetrics/customize_metrics_test.go
@@ -249,16 +249,18 @@ func sendTraffic() error {
 		httpOpts := echo.CallOptions{
 			Target:   server[0],
 			PortName: "http",
-			Path:     "/path",
-			Count:    count,
-			Method:   "GET",
+			HTTP: echo.HTTP{
+				Path:   "/path",
+				Method: "GET",
+			},
+			Count: count,
 		}
 
 		if _, err := cltInstance.Call(httpOpts); err != nil {
 			return err
 		}
 
-		httpOpts.Method = "POST"
+		httpOpts.HTTP.Method = "POST"
 		if _, err := cltInstance.Call(httpOpts); err != nil {
 			return err
 		}
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
index a703dbc4a4..ae762b9fda 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/accesslogs_test.go
@@ -77,7 +77,9 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 				Target:   common.GetServerInstances()[0],
 				PortName: "http",
 				Count:    util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
-				Path:     "/" + testID,
+				HTTP: echo.HTTP{
+					Path: "/" + testID,
+				},
 			})
 			// Retry a bit to get the logs. There is some delay before they are output, so they may not be immediately ready
 			// If not ready in 5s, we retry sending a call again.
@@ -100,7 +102,9 @@ func runAccessLogsTests(t framework.TestContext, expectLogs bool) {
 				Target:   common.GetServerInstances()[0],
 				PortName: "http",
 				Count:    util.CallsPerCluster * len(common.GetServerInstances().Clusters()),
-				Path:     "/" + testID,
+				HTTP: echo.HTTP{
+					Path: "/" + testID,
+				},
 			})
 			// This is a negative test; there isn't much we can do other than wait a few seconds and ensure we didn't emit logs
 			// Logs should flush every 1s, so 2s should be plenty of time for logs to be emitted
diff --git a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
index 0b64595745..6e52ed40d5 100644
--- a/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
+++ b/tests/integration/telemetry/stats/prometheus/nullvm/dashboard_test.go
@@ -32,6 +32,7 @@
 	kubeApiMeta "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/http/headers"
 	"istio.io/istio/pkg/test/env"
 	"istio.io/istio/pkg/test/framework"
 	"istio.io/istio/pkg/test/framework/components/cluster"
@@ -310,9 +311,9 @@ func setupDashboardTest(done <-chan struct{}) {
 						Protocol: protocol.HTTP,
 					},
 					Count: 10,
-					Path:  fmt.Sprintf("/echo-%s?codes=418:10,520:15,200:75", common.GetAppNamespace().Name()),
-					Headers: map[string][]string{
-						"Host": {"server"},
+					HTTP: echo.HTTP{
+						Path:    fmt.Sprintf("/echo-%s?codes=418:10,520:15,200:75", common.GetAppNamespace().Name()),
+						Headers: headers.New().WithHost("server").Build(),
 					},
 				})
 				if err != nil {
@@ -326,9 +327,9 @@ func setupDashboardTest(done <-chan struct{}) {
 						ServicePort: port,
 					},
 					Address: host,
-					Path:    fmt.Sprintf("/echo-%s", common.GetAppNamespace().Name()),
-					Headers: map[string][]string{
-						"Host": {"server"},
+					HTTP: echo.HTTP{
+						Path:    fmt.Sprintf("/echo-%s", common.GetAppNamespace().Name()),
+						Headers: headers.New().WithHost("server").Build(),
 					},
 				})
 				if err != nil {
diff --git a/tests/integration/telemetry/stats/prometheus/stats.go b/tests/integration/telemetry/stats/prometheus/stats.go
index 9686694b35..6945533e01 100644
--- a/tests/integration/telemetry/stats/prometheus/stats.go
+++ b/tests/integration/telemetry/stats/prometheus/stats.go
@@ -150,14 +150,18 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {
 			for _, prom := range mockProm {
 				st := server.GetOrFail(t, echo.InCluster(prom.Config().Cluster))
 				prom.CallWithRetryOrFail(t, echo.CallOptions{
-					Address:            st.WorkloadsOrFail(t)[0].Address(),
-					Scheme:             scheme.HTTPS,
-					Port:               &echo.Port{ServicePort: 15014},
-					Path:               "/metrics",
-					CertFile:           "/etc/certs/custom/cert-chain.pem",
-					KeyFile:            "/etc/certs/custom/key.pem",
-					CaCertFile:         "/etc/certs/custom/root-cert.pem",
-					InsecureSkipVerify: true,
+					Address: st.WorkloadsOrFail(t)[0].Address(),
+					Scheme:  scheme.HTTPS,
+					Port:    &echo.Port{ServicePort: 15014},
+					HTTP: echo.HTTP{
+						Path: "/metrics",
+					},
+					TLS: echo.TLS{
+						CertFile:           "/etc/certs/custom/cert-chain.pem",
+						KeyFile:            "/etc/certs/custom/key.pem",
+						CaCertFile:         "/etc/certs/custom/root-cert.pem",
+						InsecureSkipVerify: true,
+					},
 				})
 			}
 		})
diff --git a/tests/integration/telemetry/tracing/tracing.go b/tests/integration/telemetry/tracing/tracing.go
index ee5c455b8e..3cdebc4544 100644
--- a/tests/integration/telemetry/tracing/tracing.go
+++ b/tests/integration/telemetry/tracing/tracing.go
@@ -185,7 +185,9 @@ func SendTraffic(t framework.TestContext, headers map[string][]string, cl cluste
 			Target:   server[0],
 			PortName: "http",
 			Count:    telemetry.RequestCountMultipler * len(server),
-			Headers:  headers,
+			HTTP: echo.HTTP{
+				Headers: headers,
+			},
 		})
 		if err != nil {
 			return err
-- 
2.35.3

