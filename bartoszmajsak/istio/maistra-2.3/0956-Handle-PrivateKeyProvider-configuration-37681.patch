From 1647479adec112d21a1386e6590eb8128013891f Mon Sep 17 00:00:00 2001
From: Ravi kumar Veeramally <ravikumar.veeramally@linux.intel.com>
Date: Fri, 1 Apr 2022 00:13:36 +0300
Subject: Handle PrivateKeyProvider configuration (#37681)

* Handle PrivateKeyProvider configuration

When the PrivateKeyProvider configuration information is provided
through Istio operator yaml file, parse and pass it to gateway or
sidecars. Envoy will act based on the information provided by the
configuration.

To set the mesh wide defaults, configure the `defaultConfig` section of `meshConfig`.
For example:

meshConfig:
  defaultConfig:
    privateKeyProvider:
      cryptomb:
        pollDelay: 0.01s

This can also be configured on a per-workload basis by configuring the `proxy.istio.io/config`
annotation on the pod.
For example:

annotations:
  proxy.istio.io/config: |
    privateKeyProvider:
      cryptomb:
        pollDelay: 0.01s

* add release notes

* add validation and tests

* modify according to api change

* address comments

* Fix lint issues

* address comments

* address jacob-delgado and howardjohn comments

* add tests

* use default config

* fix rebase conflicts

* fix config for gateway cert

* fix rebase conflicts
---
 pilot/pkg/bootstrap/server.go                 |  2 +-
 pilot/pkg/xds/fake.go                         |  2 +-
 pilot/pkg/xds/sds.go                          | 75 ++++++++++++++-----
 pkg/config/validation/validation.go           | 32 ++++++++
 pkg/config/validation/validation_test.go      | 59 +++++++++++++++
 pkg/istio-agent/agent.go                      |  3 +-
 pkg/istio-agent/agent_test.go                 |  2 +-
 releasenotes/notes/37681.yaml                 |  7 ++
 security/pkg/nodeagent/sds/sdsservice.go      | 60 +++++++++++----
 security/pkg/nodeagent/sds/sdsservice_test.go | 50 ++++++++++++-
 security/pkg/nodeagent/sds/server.go          |  5 +-
 11 files changed, 256 insertions(+), 41 deletions(-)
 create mode 100644 releasenotes/notes/37681.yaml

diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 1771bf10f2..7503884116 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -535,7 +535,7 @@ func (s *Server) initSDSServer() {
 				Reason: []model.TriggerReason{model.SecretTrigger},
 			})
 		})
-		s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(creds, s.XDSServer.Cache, s.clusterID)
+		s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(creds, s.XDSServer.Cache, s.clusterID, s.environment.Mesh())
 		s.multiclusterController.AddHandler(creds)
 	}
 }
diff --git a/pilot/pkg/xds/fake.go b/pilot/pkg/xds/fake.go
index 24842ac5fd..fc056cfc1e 100644
--- a/pilot/pkg/xds/fake.go
+++ b/pilot/pkg/xds/fake.go
@@ -173,7 +173,7 @@ func NewFakeDiscoveryServer(t test.Failer, opts FakeOptions) *FakeDiscoveryServe
 		}
 	}
 	creds := kubesecrets.NewMulticluster(opts.DefaultClusterName)
-	s.Generators[v3.SecretType] = NewSecretGen(creds, s.Cache, opts.DefaultClusterName)
+	s.Generators[v3.SecretType] = NewSecretGen(creds, s.Cache, opts.DefaultClusterName, nil)
 	for k8sCluster, objs := range k8sObjects {
 		client := kubelib.NewFakeClientWithVersion(opts.KubernetesVersion, objs...)
 		if opts.KubeClientModifier != nil {
diff --git a/pilot/pkg/xds/sds.go b/pilot/pkg/xds/sds.go
index 08a8378f89..13469fcd95 100644
--- a/pilot/pkg/xds/sds.go
+++ b/pilot/pkg/xds/sds.go
@@ -19,11 +19,16 @@
 	"encoding/pem"
 	"fmt"
 	"strings"
+	"time"
 
+	cryptomb "github.com/envoyproxy/go-control-plane/contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha"
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	envoytls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	"google.golang.org/protobuf/types/known/anypb"
+	"google.golang.org/protobuf/types/known/durationpb"
 
+	mesh "istio.io/api/mesh/v1alpha1"
 	credscontroller "istio.io/istio/pilot/pkg/credentials"
 	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
@@ -135,7 +140,7 @@ func (s *SecretGen) Generate(proxy *model.Proxy, w *model.WatchedResource, req *
 			continue
 		}
 		regenerated++
-		res := s.generate(sr, configClusterSecrets, proxyClusterSecrets)
+		res := s.generate(sr, configClusterSecrets, proxyClusterSecrets, proxy)
 		if res != nil {
 			s.cache.Add(sr, req, res)
 			results = append(results, res)
@@ -144,7 +149,7 @@ func (s *SecretGen) Generate(proxy *model.Proxy, w *model.WatchedResource, req *
 	return results, model.XdsLogDetails{AdditionalInfo: fmt.Sprintf("cached:%v/%v", cached, cached+regenerated)}, nil
 }
 
-func (s *SecretGen) generate(sr SecretResource, configClusterSecrets, proxyClusterSecrets credscontroller.Controller) *discovery.Resource {
+func (s *SecretGen) generate(sr SecretResource, configClusterSecrets, proxyClusterSecrets credscontroller.Controller, proxy *model.Proxy) *discovery.Resource {
 	// Fetch the appropriate cluster's secret, based on the credential type
 	var secretController credscontroller.Controller
 	switch sr.Type {
@@ -184,7 +189,7 @@ func (s *SecretGen) generate(sr SecretResource, configClusterSecrets, proxyClust
 			return nil
 		}
 	}
-	res := toEnvoyKeyCertSecret(sr.ResourceName, key, cert)
+	res := toEnvoyKeyCertSecret(sr.ResourceName, key, cert, proxy, s.meshConfig)
 	return res
 }
 
@@ -303,24 +308,57 @@ func toEnvoyCaSecret(name string, cert []byte) *discovery.Resource {
 	}
 }
 
-func toEnvoyKeyCertSecret(name string, key, cert []byte) *discovery.Resource {
-	res := util.MessageToAny(&envoytls.Secret{
-		Name: name,
-		Type: &envoytls.Secret_TlsCertificate{
-			TlsCertificate: &envoytls.TlsCertificate{
-				CertificateChain: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: cert,
+func toEnvoyKeyCertSecret(name string, key, cert []byte, proxy *model.Proxy, meshConfig *mesh.MeshConfig) *discovery.Resource {
+	var res *anypb.Any
+	pkpConf := proxy.Metadata.ProxyConfigOrDefault(meshConfig.GetDefaultConfig()).GetPrivateKeyProvider()
+	switch pkpConf.GetProvider().(type) {
+	case *mesh.PrivateKeyProvider_Cryptomb:
+		crypto := pkpConf.GetCryptomb()
+		msg := util.MessageToAny(&cryptomb.CryptoMbPrivateKeyMethodConfig{
+			PollDelay: durationpb.New(time.Duration(crypto.GetPollDelay().Nanos)),
+			PrivateKey: &core.DataSource{
+				Specifier: &core.DataSource_InlineBytes{
+					InlineBytes: key,
+				},
+			},
+		})
+		res = util.MessageToAny(&envoytls.Secret{
+			Name: name,
+			Type: &envoytls.Secret_TlsCertificate{
+				TlsCertificate: &envoytls.TlsCertificate{
+					CertificateChain: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: cert,
+						},
+					},
+					PrivateKeyProvider: &envoytls.PrivateKeyProvider{
+						ProviderName: "cryptomb",
+						ConfigType: &envoytls.PrivateKeyProvider_TypedConfig{
+							TypedConfig: msg,
+						},
 					},
 				},
-				PrivateKey: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: key,
+			},
+		})
+	default:
+		res = util.MessageToAny(&envoytls.Secret{
+			Name: name,
+			Type: &envoytls.Secret_TlsCertificate{
+				TlsCertificate: &envoytls.TlsCertificate{
+					CertificateChain: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: cert,
+						},
+					},
+					PrivateKey: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: key,
+						},
 					},
 				},
 			},
-		},
-	})
+		})
+	}
 	return &discovery.Resource{
 		Name:     name,
 		Resource: res,
@@ -360,16 +398,19 @@ type SecretGen struct {
 	// Cache for XDS resources
 	cache         model.XdsCache
 	configCluster cluster.ID
+	meshConfig    *mesh.MeshConfig
 }
 
 var _ model.XdsResourceGenerator = &SecretGen{}
 
-func NewSecretGen(sc credscontroller.MulticlusterController, cache model.XdsCache, configCluster cluster.ID) *SecretGen {
+func NewSecretGen(sc credscontroller.MulticlusterController, cache model.XdsCache, configCluster cluster.ID,
+	meshConfig *mesh.MeshConfig) *SecretGen {
 	// TODO: Currently we only have a single credentials controller (Kubernetes). In the future, we will need a mapping
 	// of resource type to secret controller (ie kubernetes:// -> KubernetesController, vault:// -> VaultController)
 	return &SecretGen{
 		secrets:       sc,
 		cache:         cache,
 		configCluster: configCluster,
+		meshConfig:    meshConfig,
 	}
 }
diff --git a/pkg/config/validation/validation.go b/pkg/config/validation/validation.go
index ca8c67b53b..b965d5286e 100644
--- a/pkg/config/validation/validation.go
+++ b/pkg/config/validation/validation.go
@@ -1645,6 +1645,32 @@ func validateServiceSettings(config *meshconfig.MeshConfig) (errs error) {
 	return
 }
 
+func validatePrivateKeyProvider(pkpConf *meshconfig.PrivateKeyProvider) error {
+	var errs error
+	if pkpConf.GetProvider() == nil {
+		errs = multierror.Append(errs, errors.New("private key provider confguration is required"))
+	}
+
+	switch pkpConf.GetProvider().(type) {
+	case *meshconfig.PrivateKeyProvider_Cryptomb:
+		cryptomb := pkpConf.GetCryptomb()
+		if cryptomb == nil {
+			errs = multierror.Append(errs, errors.New("cryptomb confguration is required"))
+		} else {
+			pollDelay := cryptomb.GetPollDelay()
+			if pollDelay == nil {
+				errs = multierror.Append(errs, errors.New("pollDelay is required"))
+			} else if pollDelay.GetSeconds() == 0 && pollDelay.GetNanos() == 0 {
+				errs = multierror.Append(errs, errors.New("pollDelay must be non zero"))
+			}
+		}
+	default:
+		errs = multierror.Append(errs, errors.New("unknown private key provider"))
+	}
+
+	return errs
+}
+
 // ValidateMeshConfigProxyConfig checks that the mesh config is well-formed
 func ValidateMeshConfigProxyConfig(config *meshconfig.ProxyConfig) (errs error) {
 	if config.ConfigPath == "" {
@@ -1748,6 +1774,12 @@ func ValidateMeshConfigProxyConfig(config *meshconfig.ProxyConfig) (errs error)
 		errs = multierror.Append(errs, multierror.Prefix(err, "invalid status port:"))
 	}
 
+	if pkpConf := config.GetPrivateKeyProvider(); pkpConf != nil {
+		if err := validatePrivateKeyProvider(pkpConf); err != nil {
+			errs = multierror.Append(errs, multierror.Prefix(err, "invalid private key provider confguration:"))
+		}
+	}
+
 	return
 }
 
diff --git a/pkg/config/validation/validation_test.go b/pkg/config/validation/validation_test.go
index 737e626d25..76574d92a7 100644
--- a/pkg/config/validation/validation_test.go
+++ b/pkg/config/validation/validation_test.go
@@ -495,6 +495,7 @@ func TestValidateMeshConfigProxyConfig(t *testing.T) {
 		ControlPlaneAuthPolicy: meshconfig.AuthenticationPolicy_MUTUAL_TLS,
 		Tracing:                nil,
 		StatusPort:             15020,
+		PrivateKeyProvider:     nil,
 	}
 
 	modify := func(config *meshconfig.ProxyConfig, fieldSetter func(*meshconfig.ProxyConfig)) *meshconfig.ProxyConfig {
@@ -810,6 +811,64 @@ func(c *meshconfig.ProxyConfig) {
 			),
 			isValid: false,
 		},
+		{
+			name: "private key provider with empty provider",
+			in: modify(valid,
+				func(c *meshconfig.ProxyConfig) {
+					c.PrivateKeyProvider = &meshconfig.PrivateKeyProvider{}
+				},
+			),
+			isValid: false,
+		},
+		{
+			name: "private key provider with cryptomb without poll_delay",
+			in: modify(valid,
+				func(c *meshconfig.ProxyConfig) {
+					c.PrivateKeyProvider = &meshconfig.PrivateKeyProvider{
+						Provider: &meshconfig.PrivateKeyProvider_Cryptomb{
+							Cryptomb: &meshconfig.PrivateKeyProvider_CryptoMb{},
+						},
+					}
+				},
+			),
+			isValid: false,
+		},
+		{
+			name: "private key provider with cryptomb zero poll_delay",
+			in: modify(valid,
+				func(c *meshconfig.ProxyConfig) {
+					c.PrivateKeyProvider = &meshconfig.PrivateKeyProvider{
+						Provider: &meshconfig.PrivateKeyProvider_Cryptomb{
+							Cryptomb: &meshconfig.PrivateKeyProvider_CryptoMb{
+								PollDelay: &durationpb.Duration{
+									Seconds: 0,
+									Nanos:   0,
+								},
+							},
+						},
+					}
+				},
+			),
+			isValid: false,
+		},
+		{
+			name: "private key provider with cryptomb",
+			in: modify(valid,
+				func(c *meshconfig.ProxyConfig) {
+					c.PrivateKeyProvider = &meshconfig.PrivateKeyProvider{
+						Provider: &meshconfig.PrivateKeyProvider_Cryptomb{
+							Cryptomb: &meshconfig.PrivateKeyProvider_CryptoMb{
+								PollDelay: &durationpb.Duration{
+									Seconds: 0,
+									Nanos:   10000,
+								},
+							},
+						},
+					}
+				},
+			),
+			isValid: true,
+		},
 	}
 	for _, c := range cases {
 		t.Run(c.name, func(t *testing.T) {
diff --git a/pkg/istio-agent/agent.go b/pkg/istio-agent/agent.go
index d5a78d902d..6126da746f 100644
--- a/pkg/istio-agent/agent.go
+++ b/pkg/istio-agent/agent.go
@@ -503,7 +503,8 @@ func (a *Agent) initSdsServer() error {
 		}
 	}
 
-	a.sdsServer = sds.NewServer(a.secOpts, a.secretCache)
+	pkpConf := a.proxyConfig.GetPrivateKeyProvider()
+	a.sdsServer = sds.NewServer(a.secOpts, a.secretCache, pkpConf)
 	a.secretCache.SetUpdateCallback(a.sdsServer.UpdateCallback)
 
 	return nil
diff --git a/pkg/istio-agent/agent_test.go b/pkg/istio-agent/agent_test.go
index 4cf4776dba..06f0aabe8f 100644
--- a/pkg/istio-agent/agent_test.go
+++ b/pkg/istio-agent/agent_test.go
@@ -284,7 +284,7 @@ func TestAgent(t *testing.T) {
 
 		// this SDS Server listens on the well-known socket path serving the certs copied to the temp directory,
 		// and acts as the external SDS Server that the Agent will detect at startup
-		sdsServer := sds.NewServer(secOpts, secretCache)
+		sdsServer := sds.NewServer(secOpts, secretCache, nil)
 		defer sdsServer.Stop()
 
 		Setup(t).Check(t, security.WorkloadKeyCertResourceName, security.RootCertReqResourceName)
diff --git a/releasenotes/notes/37681.yaml b/releasenotes/notes/37681.yaml
new file mode 100644
index 0000000000..73c5c7f992
--- /dev/null
+++ b/releasenotes/notes/37681.yaml
@@ -0,0 +1,7 @@
+apiVersion: release-notes/v2
+kind: feature
+area: security
+
+releaseNotes:
+- |
+  **Added** support for using PrivateKeyProvider in SDS. See [#35809](https://github.com/istio/istio/issues/35809)
diff --git a/security/pkg/nodeagent/sds/sdsservice.go b/security/pkg/nodeagent/sds/sdsservice.go
index a31bc9d6d4..3a6ab33067 100644
--- a/security/pkg/nodeagent/sds/sdsservice.go
+++ b/security/pkg/nodeagent/sds/sdsservice.go
@@ -21,6 +21,7 @@
 	"time"
 
 	"github.com/cenkalti/backoff/v4"
+	cryptomb "github.com/envoyproxy/go-control-plane/contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha"
 	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
@@ -28,7 +29,9 @@
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
+	"google.golang.org/protobuf/types/known/durationpb"
 
+	mesh "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/networking/util"
 	"istio.io/istio/pilot/pkg/xds"
@@ -47,6 +50,7 @@ type sdsservice struct {
 	XdsServer  *xds.DiscoveryServer
 	stop       chan struct{}
 	rootCaPath string
+	pkpConf    *mesh.PrivateKeyProvider
 }
 
 // Assert we implement the generator interface
@@ -88,10 +92,11 @@ func NewXdsServer(stop chan struct{}, gen model.XdsResourceGenerator) *xds.Disco
 }
 
 // newSDSService creates Secret Discovery Service which implements envoy SDS API.
-func newSDSService(st security.SecretManager, options *security.Options) *sdsservice {
+func newSDSService(st security.SecretManager, options *security.Options, pkpConf *mesh.PrivateKeyProvider) *sdsservice {
 	ret := &sdsservice{
-		st:   st,
-		stop: make(chan struct{}),
+		st:      st,
+		stop:    make(chan struct{}),
+		pkpConf: pkpConf,
 	}
 	ret.XdsServer = NewXdsServer(ret.stop, ret)
 
@@ -151,7 +156,7 @@ func (s *sdsservice) generate(resourceNames []string) (model.Resources, error) {
 			return nil, fmt.Errorf("failed to generate secret for %v: %v", resourceName, err)
 		}
 
-		res := util.MessageToAny(toEnvoySecret(secret, s.rootCaPath))
+		res := util.MessageToAny(toEnvoySecret(secret, s.rootCaPath, s.pkpConf))
 		resources = append(resources, &discovery.Resource{
 			Name:     resourceName,
 			Resource: res,
@@ -205,7 +210,7 @@ func (s *sdsservice) Close() {
 }
 
 // toEnvoySecret converts a security.SecretItem to an Envoy tls.Secret
-func toEnvoySecret(s *security.SecretItem, caRootPath string) *tls.Secret {
+func toEnvoySecret(s *security.SecretItem, caRootPath string, pkpConf *mesh.PrivateKeyProvider) *tls.Secret {
 	secret := &tls.Secret{
 		Name: s.ResourceName,
 	}
@@ -227,22 +232,49 @@ func toEnvoySecret(s *security.SecretItem, caRootPath string) *tls.Secret {
 			},
 		}
 	} else {
-		secret.Type = &tls.Secret_TlsCertificate{
-			TlsCertificate: &tls.TlsCertificate{
-				CertificateChain: &core.DataSource{
-					Specifier: &core.DataSource_InlineBytes{
-						InlineBytes: s.CertificateChain,
-					},
-				},
+		switch pkpConf.GetProvider().(type) {
+		case *mesh.PrivateKeyProvider_Cryptomb:
+			crypto := pkpConf.GetCryptomb()
+			msg := util.MessageToAny(&cryptomb.CryptoMbPrivateKeyMethodConfig{
+				PollDelay: durationpb.New(time.Duration(crypto.GetPollDelay().Nanos)),
 				PrivateKey: &core.DataSource{
 					Specifier: &core.DataSource_InlineBytes{
 						InlineBytes: s.PrivateKey,
 					},
 				},
-			},
+			})
+			secret.Type = &tls.Secret_TlsCertificate{
+				TlsCertificate: &tls.TlsCertificate{
+					CertificateChain: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.CertificateChain,
+						},
+					},
+					PrivateKeyProvider: &tls.PrivateKeyProvider{
+						ProviderName: "cryptomb",
+						ConfigType: &tls.PrivateKeyProvider_TypedConfig{
+							TypedConfig: msg,
+						},
+					},
+				},
+			}
+		default:
+			secret.Type = &tls.Secret_TlsCertificate{
+				TlsCertificate: &tls.TlsCertificate{
+					CertificateChain: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.CertificateChain,
+						},
+					},
+					PrivateKey: &core.DataSource{
+						Specifier: &core.DataSource_InlineBytes{
+							InlineBytes: s.PrivateKey,
+						},
+					},
+				},
+			}
 		}
 	}
-
 	return secret
 }
 
diff --git a/security/pkg/nodeagent/sds/sdsservice_test.go b/security/pkg/nodeagent/sds/sdsservice_test.go
index 355073af0a..3d7685469a 100644
--- a/security/pkg/nodeagent/sds/sdsservice_test.go
+++ b/security/pkg/nodeagent/sds/sdsservice_test.go
@@ -19,12 +19,16 @@
 	"strings"
 	"testing"
 
+	cryptomb "github.com/envoyproxy/go-control-plane/contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha"
+	tlsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
 	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 	"github.com/google/go-cmp/cmp"
 	"golang.org/x/net/context"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/protobuf/types/known/durationpb"
 
+	meshconfig "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/xds"
 	"istio.io/istio/pilot/test/xdstest"
 	ca2 "istio.io/istio/pkg/security"
@@ -43,8 +47,19 @@
 		PrivateKey:       fakePushPrivateKey,
 		ResourceName:     testResourceName,
 	}
-	testResourceName = "default"
-	rootResourceName = "ROOTCA"
+	testResourceName           = "default"
+	rootResourceName           = "ROOTCA"
+	fakePrivateKeyProviderConf = &meshconfig.PrivateKeyProvider{
+		Provider: &meshconfig.PrivateKeyProvider_Cryptomb{
+			Cryptomb: &meshconfig.PrivateKeyProvider_CryptoMb{
+				PollDelay: &durationpb.Duration{
+					Seconds: 0,
+					Nanos:   10000,
+				},
+			},
+		},
+	}
+	usefakePrivateKeyProviderConf = false
 )
 
 type TestServer struct {
@@ -75,6 +90,12 @@ type Expectation struct {
 	RootCert     []byte
 }
 
+func (s *TestServer) extractPrivateKeyProvider(provider *tlsv3.PrivateKeyProvider) []byte {
+	var cmb cryptomb.CryptoMbPrivateKeyMethodConfig
+	provider.GetTypedConfig().UnmarshalTo(&cmb)
+	return cmb.GetPrivateKey().GetInlineBytes()
+}
+
 func (s *TestServer) Verify(resp *discovery.DiscoveryResponse, expectations ...Expectation) *discovery.DiscoveryResponse {
 	s.t.Helper()
 	if len(resp.Resources) != len(expectations) {
@@ -83,9 +104,15 @@ func (s *TestServer) Verify(resp *discovery.DiscoveryResponse, expectations ...E
 	got := xdstest.ExtractTLSSecrets(s.t, resp.Resources)
 	for _, e := range expectations {
 		scrt := got[e.ResourceName]
+		var expectationKey []byte
+		if provider := scrt.GetTlsCertificate().GetPrivateKeyProvider(); provider != nil {
+			expectationKey = s.extractPrivateKeyProvider(provider)
+		} else {
+			expectationKey = scrt.GetTlsCertificate().GetPrivateKey().GetInlineBytes()
+		}
 		r := Expectation{
 			ResourceName: e.ResourceName,
-			Key:          scrt.GetTlsCertificate().GetPrivateKey().GetInlineBytes(),
+			Key:          expectationKey,
 			CertChain:    scrt.GetTlsCertificate().GetCertificateChain().GetInlineBytes(),
 			RootCert:     scrt.GetValidationContext().GetTrustedCa().GetInlineBytes(),
 		}
@@ -97,6 +124,7 @@ func (s *TestServer) Verify(resp *discovery.DiscoveryResponse, expectations ...E
 }
 
 func setupSDS(t *testing.T) *TestServer {
+	var server *Server
 	st := ca2.NewDirectSecretManager()
 	st.Set(testResourceName, &ca2.SecretItem{
 		CertificateChain: fakeCertificateChain,
@@ -109,7 +137,12 @@ func setupSDS(t *testing.T) *TestServer {
 	})
 
 	opts := &ca2.Options{}
-	server := NewServer(opts, st)
+
+	if usefakePrivateKeyProviderConf {
+		server = NewServer(opts, st, fakePrivateKeyProviderConf)
+	} else {
+		server = NewServer(opts, st, nil)
+	}
 	t.Cleanup(func() {
 		server.Stop()
 	})
@@ -282,6 +315,15 @@ func TestSDS(t *testing.T) {
 		c.RequestResponseNack(t, &discovery.DiscoveryRequest{ResourceNames: []string{testResourceName}})
 		c.ExpectNoResponse(t)
 	})
+	t.Run("connect_with_cryptomb", func(t *testing.T) {
+		usefakePrivateKeyProviderConf = true
+		s := setupSDS(t)
+		c := s.Connect()
+		s.Verify(c.RequestResponseAck(t, &discovery.DiscoveryRequest{ResourceNames: []string{testResourceName}}), expectCert)
+		// Close out the connection
+		c.Cleanup()
+		usefakePrivateKeyProviderConf = false
+	})
 }
 
 func setupConnection(socket string) (*grpc.ClientConn, error) {
diff --git a/security/pkg/nodeagent/sds/server.go b/security/pkg/nodeagent/sds/server.go
index f9716fa3ff..4b6d0a49de 100644
--- a/security/pkg/nodeagent/sds/server.go
+++ b/security/pkg/nodeagent/sds/server.go
@@ -21,6 +21,7 @@
 	"go.uber.org/atomic"
 	"google.golang.org/grpc"
 
+	mesh "istio.io/api/mesh/v1alpha1"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/security"
@@ -43,9 +44,9 @@ type Server struct {
 }
 
 // NewServer creates and starts the Grpc server for SDS.
-func NewServer(options *security.Options, workloadSecretCache security.SecretManager) *Server {
+func NewServer(options *security.Options, workloadSecretCache security.SecretManager, pkpConf *mesh.PrivateKeyProvider) *Server {
 	s := &Server{stopped: atomic.NewBool(false)}
-	s.workloadSds = newSDSService(workloadSecretCache, options)
+	s.workloadSds = newSDSService(workloadSecretCache, options, pkpConf)
 	s.initWorkloadSdsService()
 	sdsServiceLog.Infof("SDS server for workload certificates started, listening on %q", security.WorkloadIdentitySocketPath)
 	return s
-- 
2.35.3

