From a0285051156636f33497bbf867e011469de2356a Mon Sep 17 00:00:00 2001
From: Yaroslav Skopets <yaroslav@tetrate.io>
Date: Wed, 16 Feb 2022 03:55:16 +0100
Subject: vm support: don't generate virtual inbound/outbound listeners for
 proxies that are not using Iptables redirection (#37326)

* vm support: don't generate virtual inbound/outbound listeners for proxies that are not using Iptables redirection

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* add unit tests

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* code review: compact source code

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>

* cleanup

Signed-off-by: Yaroslav Skopets <yaroslav@tetrate.io>
---
 .../core/v1alpha3/accesslog_test.go           |  2 +-
 .../core/v1alpha3/listener_builder.go         | 10 +++
 .../networking/core/v1alpha3/listener_test.go | 88 +++++++++++++++++--
 3 files changed, 93 insertions(+), 7 deletions(-)

diff --git a/pilot/pkg/networking/core/v1alpha3/accesslog_test.go b/pilot/pkg/networking/core/v1alpha3/accesslog_test.go
index aa0c6ac25d..1564ba2238 100644
--- a/pilot/pkg/networking/core/v1alpha3/accesslog_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/accesslog_test.go
@@ -113,7 +113,7 @@ func TestListenerAccessLog(t *testing.T) {
 			accessLogBuilder.reset()
 
 			// Validate that access log filter uses the new format.
-			listeners := buildAllListeners(&fakePlugin{}, env)
+			listeners := buildAllListeners(&fakePlugin{}, env, getProxy())
 			for _, l := range listeners {
 				if l.AccessLog[0].Filter == nil {
 					t.Fatal("expected filter config in listener access log configuration")
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index c0f0c89caa..7d087c98ac 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -350,6 +350,11 @@ func (lb *ListenerBuilder) buildHTTPProxyListener(configgen *ConfigGeneratorImpl
 }
 
 func (lb *ListenerBuilder) buildVirtualOutboundListener(configgen *ConfigGeneratorImpl) *ListenerBuilder {
+	if lb.node.GetInterceptionMode() == model.InterceptionNone {
+		// virtual listener is not necessary since workload is not using IPtables for traffic interception
+		return lb
+	}
+
 	var isTransparentProxy *wrappers.BoolValue
 	if lb.node.GetInterceptionMode() == model.InterceptionTproxy {
 		isTransparentProxy = proto.BoolTrue
@@ -376,6 +381,11 @@ func (lb *ListenerBuilder) buildVirtualOutboundListener(configgen *ConfigGenerat
 // TProxy uses only the virtual outbound listener on 15001 for both directions
 // but we still ship the no-op virtual inbound listener, so that the code flow is same across REDIRECT and TPROXY.
 func (lb *ListenerBuilder) buildVirtualInboundListener(configgen *ConfigGeneratorImpl) *ListenerBuilder {
+	if lb.node.GetInterceptionMode() == model.InterceptionNone {
+		// virtual listener is not necessary since workload is not using IPtables for traffic interception
+		return lb
+	}
+
 	var isTransparentProxy *wrappers.BoolValue
 	if lb.node.GetInterceptionMode() == model.InterceptionTproxy {
 		isTransparentProxy = proto.BoolTrue
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_test.go b/pilot/pkg/networking/core/v1alpha3/listener_test.go
index 7556de22a2..5b5f05bb50 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_test.go
@@ -1614,12 +1614,79 @@ func testOutboundListenerConfigWithSidecarWithCaptureModeNone(t *testing.T, serv
 	}
 }
 
+func TestVirtualListeners_TrafficRedirectionEnabled(t *testing.T) {
+	cases := []struct {
+		name string
+		mode model.TrafficInterceptionMode
+	}{
+		{
+			name: "empty value",
+			mode: "",
+		},
+		{
+			name: "unknown value",
+			mode: model.TrafficInterceptionMode("UNKNOWN_VALUE"),
+		},
+		{
+			name: string(model.InterceptionTproxy),
+			mode: model.InterceptionTproxy,
+		},
+		{
+			name: string(model.InterceptionRedirect),
+			mode: model.InterceptionRedirect,
+		},
+	}
+	for _, tc := range cases {
+		t.Run(tc.name, func(t *testing.T) {
+			p := &fakePlugin{}
+			env := buildListenerEnv(nil)
+			proxy := getProxy()
+
+			// simulate particular interception mode
+			proxy.Metadata.InterceptionMode = tc.mode
+
+			got := buildAllListeners(p, env, proxy)
+
+			virtualInboundListener := findListenerByName(got, model.VirtualInboundListenerName)
+			if virtualInboundListener == nil {
+				t.Fatalf("buildSidecarListeners() did not generate virtual inbound listener")
+			}
+
+			virtualOutboundListener := findListenerByName(got, model.VirtualOutboundListenerName)
+			if virtualOutboundListener == nil {
+				t.Fatalf("buildSidecarListeners() did not generate virtual outbound listener")
+			}
+		})
+	}
+}
+
+func TestVirtualListeners_TrafficRedirectionDisabled(t *testing.T) {
+	p := &fakePlugin{}
+	env := buildListenerEnv(nil)
+	proxy := getProxy()
+
+	// simulate particular interception mode
+	proxy.Metadata.InterceptionMode = model.InterceptionNone
+
+	got := buildAllListeners(p, env, proxy)
+
+	virtualInboundListener := findListenerByName(got, model.VirtualInboundListenerName)
+	if virtualInboundListener != nil {
+		t.Fatalf("buildSidecarListeners() generated virtual inbound listener while it shouldn't")
+	}
+
+	virtualOutboundListener := findListenerByName(got, model.VirtualOutboundListenerName)
+	if virtualOutboundListener != nil {
+		t.Fatalf("buildSidecarListeners() generated virtual outbound listener while it shouldn't")
+	}
+}
+
 func TestOutboundListenerAccessLogs(t *testing.T) {
 	t.Helper()
 	p := &fakePlugin{}
 	env := buildListenerEnv(nil)
 	env.Mesh().AccessLogFile = "foo"
-	listeners := buildAllListeners(p, env)
+	listeners := buildAllListeners(p, env, getProxy())
 	found := false
 	for _, l := range listeners {
 		if l.Name == model.VirtualOutboundListenerName {
@@ -1648,7 +1715,7 @@ func TestOutboundListenerAccessLogs(t *testing.T) {
 	accessLogBuilder.reset()
 
 	// Validate that access log filter uses the new format.
-	listeners = buildAllListeners(p, env)
+	listeners = buildAllListeners(p, env, getProxy())
 	for _, l := range listeners {
 		if l.Name == model.VirtualOutboundListenerName {
 			validateAccessLog(t, l, "format modified")
@@ -1661,7 +1728,7 @@ func TestListenerAccessLogs(t *testing.T) {
 	p := &fakePlugin{}
 	env := buildListenerEnv(nil)
 	env.Mesh().AccessLogFile = "foo"
-	listeners := buildAllListeners(p, env)
+	listeners := buildAllListeners(p, env, getProxy())
 	for _, l := range listeners {
 
 		if l.AccessLog == nil {
@@ -1678,7 +1745,7 @@ func TestListenerAccessLogs(t *testing.T) {
 	accessLogBuilder.reset()
 
 	// Validate that access log filter uses the new format.
-	listeners = buildAllListeners(p, env)
+	listeners = buildAllListeners(p, env, getProxy())
 	for _, l := range listeners {
 		if l.AccessLog[0].Filter == nil {
 			t.Fatal("expected filter config in listener access log configuration")
@@ -2437,14 +2504,13 @@ func getOldestService(services ...*model.Service) *model.Service {
 	return oldestService
 }
 
-func buildAllListeners(p plugin.Plugin, env *model.Environment) []*listener.Listener {
+func buildAllListeners(p plugin.Plugin, env *model.Environment, proxy *model.Proxy) []*listener.Listener {
 	configgen := NewConfigGenerator([]plugin.Plugin{p}, &model.DisabledCache{})
 
 	if err := env.PushContext.InitContext(env, nil, nil); err != nil {
 		return nil
 	}
 
-	proxy := getProxy()
 	proxy.ServiceInstances = nil
 	proxy.SidecarScope = model.DefaultSidecarScopeForNamespace(env.PushContext, "not-default")
 	builder := NewListenerBuilder(proxy, env.PushContext)
@@ -2580,6 +2646,16 @@ func findListenerByAddress(listeners []*listener.Listener, address string) *list
 	return nil
 }
 
+func findListenerByName(listeners []*listener.Listener, name string) *listener.Listener {
+	for _, l := range listeners {
+		if name == l.Name {
+			return l
+		}
+	}
+
+	return nil
+}
+
 func buildService(hostname string, ip string, protocol protocol.Instance, creationTime time.Time) *model.Service {
 	return &model.Service{
 		CreationTime:   creationTime,
-- 
2.35.3

