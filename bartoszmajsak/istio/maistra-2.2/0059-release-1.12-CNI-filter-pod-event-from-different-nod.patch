From 1438a9e9a09e05deeee64ea754b3be2d32dc9745 Mon Sep 17 00:00:00 2001
From: Istio Automation <istio-testing-bot@google.com>
Date: Tue, 23 Nov 2021 09:04:40 -0800
Subject: [release-1.12] CNI: filter pod event from different node and detect
 pod that needs to be repaired before adding it to work queue. (#36118)

* Filter pod event based on node.

* update log message.

* do full detect before adding to the queue.

* update.

Co-authored-by: Pengyuan Bian <bianpengyuan@google.com>
---
 cni/pkg/repair/repair_test.go         | 39 +++++++++++++++++++++++++++
 cni/pkg/repair/repair_test_helpers.go |  1 +
 cni/pkg/repair/repaircontroller.go    | 18 +++++++++++--
 3 files changed, 56 insertions(+), 2 deletions(-)

diff --git a/cni/pkg/repair/repair_test.go b/cni/pkg/repair/repair_test.go
index fea4b06e49..d07579c5bf 100644
--- a/cni/pkg/repair/repair_test.go
+++ b/cni/pkg/repair/repair_test.go
@@ -30,6 +30,7 @@
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/kubernetes/fake"
+	"k8s.io/client-go/util/workqueue"
 
 	"istio.io/istio/cni/pkg/config"
 	"istio.io/istio/tools/istio-iptables/pkg/constants"
@@ -618,3 +619,41 @@ func checkStats(wantCount float64, wantTags []tag.Tag, exp *testExporter) error
 	}
 	return nil
 }
+
+func TestAddToWorkerQueue(t *testing.T) {
+	tests := []struct {
+		name           string
+		pod            v1.Pod
+		repairConfig   *config.RepairConfig
+		expectQueueLen int
+	}{
+		{
+			name:           "broken pod",
+			pod:            brokenPodWaiting,
+			expectQueueLen: 1,
+		},
+		{
+			name:           "normal pod",
+			pod:            workingPod,
+			expectQueueLen: 0,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			c := &Controller{
+				workQueue: workqueue.NewRateLimitingQueue(workqueue.NewItemExponentialFailureRateLimiter(0, 0)),
+				reconciler: brokenPodReconciler{
+					cfg: &config.RepairConfig{
+						SidecarAnnotation: "sidecar.istio.io/status",
+						InitContainerName: constants.ValidationContainerName,
+						InitExitCode:      126,
+					},
+				},
+			}
+			c.mayAddToWorkQueue(&tt.pod)
+			if tt.expectQueueLen != c.workQueue.Len() {
+				t.Errorf("work queue length got %v want %v", c.workQueue.Len(), tt.expectQueueLen)
+			}
+		})
+	}
+}
diff --git a/cni/pkg/repair/repair_test_helpers.go b/cni/pkg/repair/repair_test_helpers.go
index 0d69df3ad2..d90ecdab42 100644
--- a/cni/pkg/repair/repair_test_helpers.go
+++ b/cni/pkg/repair/repair_test_helpers.go
@@ -160,6 +160,7 @@ func makePod(args makePodArgs) *v1.Pod {
 		Annotations: map[string]string{
 			"sidecar.istio.io/status": "something",
 		},
+		NodeName:            "TestNode",
 		InitContainerStatus: &brokenInitContainerWaiting,
 	})
 
diff --git a/cni/pkg/repair/repaircontroller.go b/cni/pkg/repair/repaircontroller.go
index 154ee81b0f..9540f24a7c 100644
--- a/cni/pkg/repair/repaircontroller.go
+++ b/cni/pkg/repair/repaircontroller.go
@@ -15,6 +15,7 @@
 package repair
 
 import (
+	"fmt"
 	"strings"
 	"time"
 
@@ -62,6 +63,8 @@ func(options *metav1.ListOptions) {
 					fieldSelectors = append(fieldSelectors, fs)
 				}
 			}
+			// filter out pod events from different nodes
+			fieldSelectors = append(fieldSelectors, fmt.Sprintf("spec.nodeName=%v", reconciler.cfg.NodeName))
 			options.LabelSelector = strings.Join(labelSelectors, ",")
 			options.FieldSelector = strings.Join(fieldSelectors, ",")
 		},
@@ -69,16 +72,27 @@ func(options *metav1.ListOptions) {
 
 	_, c.podController = cache.NewInformer(podListWatch, &v1.Pod{}, 0, cache.ResourceEventHandlerFuncs{
 		AddFunc: func(newObj interface{}) {
-			c.workQueue.AddRateLimited(newObj)
+			c.mayAddToWorkQueue(newObj)
 		},
 		UpdateFunc: func(_, newObj interface{}) {
-			c.workQueue.AddRateLimited(newObj)
+			c.mayAddToWorkQueue(newObj)
 		},
 	})
 
 	return c, nil
 }
 
+func (rc *Controller) mayAddToWorkQueue(obj interface{}) {
+	pod, ok := obj.(*v1.Pod)
+	if !ok {
+		repairLog.Error("Cannot convert object to pod. Skip adding it to the repair working queue.")
+		return
+	}
+	if rc.reconciler.detectPod(*pod) {
+		rc.workQueue.AddRateLimited(obj)
+	}
+}
+
 func (rc *Controller) Run(stopCh <-chan struct{}) {
 	go rc.podController.Run(stopCh)
 	if !cache.WaitForCacheSync(stopCh, rc.podController.HasSynced) {
-- 
2.35.3

