From 1a53a8c2174850ec7b62fca5caf314a350369ce8 Mon Sep 17 00:00:00 2001
From: Istio Automation <istio-testing-bot@google.com>
Date: Fri, 5 Nov 2021 02:15:32 -0700
Subject: [release-1.12] update JWT claim routing implementation (#35910)

* add analyzer for JWT claim based routing

* fix test

* remove e2e test

* address comments

* update

* update to @request.auth.claims

* fix test

Co-authored-by: Yangmin Zhu <ymzhu@google.com>
---
 galley/pkg/config/analysis/analyzers/all.go   |   1 +
 .../analysis/analyzers/analyzers_test.go      |   8 +
 .../virtualservice_jwtclaimroute.yaml         |  38 +++++
 .../analyzers/virtualservice/jwtclaimroute.go | 142 ++++++++++++++++++
 .../pkg/config/analysis/msg/messages.gen.go   |  16 ++
 galley/pkg/config/analysis/msg/messages.yaml  |  13 ++
 .../networking/core/v1alpha3/route/route.go   |  19 +--
 .../v1alpha3/route/route_internal_test.go     |  22 +--
 .../core/v1alpha3/route/route_test.go         |   4 +-
 pilot/pkg/util/constant/constant.go           |  20 +++
 pkg/config/schema/metadata.gen.go             |   1 +
 pkg/config/schema/metadata.yaml               |   1 +
 pkg/config/validation/validation.go           |  21 +++
 pkg/config/validation/validation_test.go      |  21 +++
 tests/integration/pilot/common/routing.go     |  40 ++---
 15 files changed, 322 insertions(+), 45 deletions(-)
 create mode 100644 galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
 create mode 100644 galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
 create mode 100644 pilot/pkg/util/constant/constant.go

diff --git a/galley/pkg/config/analysis/analyzers/all.go b/galley/pkg/config/analysis/analyzers/all.go
index 5038c913ef..fe2b52bba0 100644
--- a/galley/pkg/config/analysis/analyzers/all.go
+++ b/galley/pkg/config/analysis/analyzers/all.go
@@ -56,6 +56,7 @@ func All() []analysis.Analyzer {
 		&virtualservice.DestinationHostAnalyzer{},
 		&virtualservice.DestinationRuleAnalyzer{},
 		&virtualservice.GatewayAnalyzer{},
+		&virtualservice.JWTClaimRouteAnalyzer{},
 		&virtualservice.RegexAnalyzer{},
 		&destinationrule.CaCertificateAnalyzer{},
 		&serviceentry.ProtocolAdressesAnalyzer{},
diff --git a/galley/pkg/config/analysis/analyzers/analyzers_test.go b/galley/pkg/config/analysis/analyzers/analyzers_test.go
index 0c45612599..5a4f34bd06 100644
--- a/galley/pkg/config/analysis/analyzers/analyzers_test.go
+++ b/galley/pkg/config/analysis/analyzers/analyzers_test.go
@@ -326,6 +326,14 @@ type testCase struct {
 			{msg.VirtualServiceHostNotFoundInGateway, "VirtualService httpbin"},
 		},
 	},
+	{
+		name:       "virtualServiceJWTClaimRoute",
+		inputFiles: []string{"testdata/virtualservice_jwtclaimroute.yaml"},
+		analyzer:   &virtualservice.JWTClaimRouteAnalyzer{},
+		expected: []message{
+			{msg.JwtClaimBasedRoutingWithoutRequestAuthN, "VirtualService foo"},
+		},
+	},
 	{
 		name:       "serviceMultipleDeployments",
 		inputFiles: []string{"testdata/deployment-multi-service.yaml"},
diff --git a/galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml b/galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
new file mode 100644
index 0000000000..050c276aa6
--- /dev/null
+++ b/galley/pkg/config/analysis/analyzers/testdata/virtualservice_jwtclaimroute.yaml
@@ -0,0 +1,38 @@
+# The following virtual service should cause the error IST0149 because it uses JWT claim based routing but there is
+# no request authentication applied on the gateway.
+apiVersion: networking.istio.io/v1alpha3
+kind: VirtualService
+metadata:
+  name: foo
+spec:
+  hosts:
+    - "foo.com"
+  gateways:
+    - foo-gateway
+  http:
+    - match:
+        - uri:
+            prefix: /
+          headers:
+            "@request.auth.claims.foo":
+              exact: foo
+      route:
+        - destination:
+            host: istiod.istio-system.svc.cluster.local
+            port:
+              number: 15010
+---
+apiVersion: networking.istio.io/v1alpha3
+kind: Gateway
+metadata:
+  name: foo-gateway
+spec:
+  selector:
+    istio: ingressgateway
+  servers:
+    - port:
+        number: 80
+        name: http
+        protocol: HTTP
+      hosts:
+        - "foo.com"
diff --git a/galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go b/galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
new file mode 100644
index 0000000000..19f666975d
--- /dev/null
+++ b/galley/pkg/config/analysis/analyzers/virtualservice/jwtclaimroute.go
@@ -0,0 +1,142 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package virtualservice
+
+import (
+	"strings"
+
+	v1 "k8s.io/api/core/v1"
+	k8s_labels "k8s.io/apimachinery/pkg/labels"
+
+	"istio.io/api/networking/v1alpha3"
+	"istio.io/api/security/v1beta1"
+	"istio.io/istio/galley/pkg/config/analysis"
+	"istio.io/istio/galley/pkg/config/analysis/analyzers/util"
+	"istio.io/istio/galley/pkg/config/analysis/msg"
+	"istio.io/istio/pilot/pkg/util/constant"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/resource"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+)
+
+type JWTClaimRouteAnalyzer struct{}
+
+var _ analysis.Analyzer = &JWTClaimRouteAnalyzer{}
+
+// Metadata implements Analyzer
+func (s *JWTClaimRouteAnalyzer) Metadata() analysis.Metadata {
+	return analysis.Metadata{
+		Name:        "virtualservice.JWTClaimRouteAnalyzer",
+		Description: "Checks the VirtualService using JWT claim based routing has corresponding RequestAuthentication",
+		Inputs: collection.Names{
+			collections.IstioNetworkingV1Alpha3Virtualservices.Name(),
+			collections.IstioSecurityV1Beta1Requestauthentications.Name(),
+			collections.IstioNetworkingV1Alpha3Gateways.Name(),
+			collections.K8SCoreV1Pods.Name(),
+		},
+	}
+}
+
+// Analyze implements Analyzer
+func (s *JWTClaimRouteAnalyzer) Analyze(c analysis.Context) {
+	requestAuthNByNamespace := map[string][]k8s_labels.Selector{}
+	c.ForEach(collections.IstioSecurityV1Beta1Requestauthentications.Name(), func(r *resource.Instance) bool {
+		ns := r.Metadata.FullName.Namespace.String()
+		if _, found := requestAuthNByNamespace[ns]; !found {
+			requestAuthNByNamespace[ns] = []k8s_labels.Selector{}
+		}
+		ra := r.Message.(*v1beta1.RequestAuthentication)
+		raSelector := k8s_labels.SelectorFromSet(ra.GetSelector().GetMatchLabels())
+		requestAuthNByNamespace[ns] = append(requestAuthNByNamespace[ns], raSelector)
+		return true
+	})
+
+	c.ForEach(collections.IstioNetworkingV1Alpha3Virtualservices.Name(), func(r *resource.Instance) bool {
+		s.analyze(r, c, requestAuthNByNamespace)
+		return true
+	})
+}
+
+func (s *JWTClaimRouteAnalyzer) analyze(r *resource.Instance, c analysis.Context, requestAuthNByNamespace map[string][]k8s_labels.Selector) {
+	// Check if the virtual service is using JWT claim based routing.
+	vs := r.Message.(*v1alpha3.VirtualService)
+	var vsRouteKey string
+	if vsRouteKey = routeBasedOnJWTClaimKey(vs); vsRouteKey == "" {
+		return
+	}
+	vsNs := r.Metadata.FullName.Namespace
+
+	// Check if the virtual service is applied to gateway.
+	for _, gwName := range vs.Gateways {
+		if gwName == util.MeshGateway {
+			continue
+		}
+
+		gwFullName := resource.NewShortOrFullName(vsNs, gwName)
+		gwRes := c.Find(collections.IstioNetworkingV1Alpha3Gateways.Name(), gwFullName)
+		if gwRes == nil {
+			// The gateway does not exist, this should already be covered by the gateway analyzer.
+			continue
+		}
+
+		gw := gwRes.Message.(*v1alpha3.Gateway)
+		gwSelector := k8s_labels.SelectorFromSet(gw.Selector)
+
+		// Check each pod selected by the gateway.
+		c.ForEach(collections.K8SCoreV1Pods.Name(), func(rPod *resource.Instance) bool {
+			pod := rPod.Message.(*v1.Pod)
+			podLabels := k8s_labels.Set(pod.ObjectMeta.Labels)
+			if !gwSelector.Matches(podLabels) {
+				return true
+			}
+
+			// Check if there is request authentication applied to the pod.
+			var hasRequestAuthNForPod bool
+
+			raSelectors := requestAuthNByNamespace[constants.IstioSystemNamespace]
+			raSelectors = append(raSelectors, requestAuthNByNamespace[pod.Namespace]...)
+			for _, raSelector := range raSelectors {
+				if raSelector.Matches(podLabels) {
+					hasRequestAuthNForPod = true
+					break
+				}
+			}
+			if !hasRequestAuthNForPod {
+				m := msg.NewJwtClaimBasedRoutingWithoutRequestAuthN(r, vsRouteKey, gwFullName.String(), pod.Name)
+				c.Report(collections.IstioNetworkingV1Alpha3Virtualservices.Name(), m)
+			}
+			return true
+		})
+	}
+}
+
+func routeBasedOnJWTClaimKey(vs *v1alpha3.VirtualService) string {
+	for _, httpRoute := range vs.GetHttp() {
+		for _, match := range httpRoute.GetMatch() {
+			for key := range match.GetHeaders() {
+				if strings.HasPrefix(key, constant.HeaderJWTClaim) {
+					return key
+				}
+			}
+			for key := range match.GetWithoutHeaders() {
+				if strings.HasPrefix(key, constant.HeaderJWTClaim) {
+					return key
+				}
+			}
+		}
+	}
+	return ""
+}
diff --git a/galley/pkg/config/analysis/msg/messages.gen.go b/galley/pkg/config/analysis/msg/messages.gen.go
index ad9bb4546a..7ed58c9de9 100755
--- a/galley/pkg/config/analysis/msg/messages.gen.go
+++ b/galley/pkg/config/analysis/msg/messages.gen.go
@@ -188,6 +188,10 @@
 	// NamespaceInjectionEnabledByDefault defines a diag.MessageType for message "NamespaceInjectionEnabledByDefault".
 	// Description: user namespace should be injectable if Istio is installed with enableNamespacesByDefault enabled and neither injection label is set.
 	NamespaceInjectionEnabledByDefault = diag.NewMessageType(diag.Info, "IST0148", "is enabled for Istio injection, as Istio is installed with enableNamespacesByDefault as true.")
+
+	// JwtClaimBasedRoutingWithoutRequestAuthN defines a diag.MessageType for message "JwtClaimBasedRoutingWithoutRequestAuthN".
+	// Description: Virtual service using JWT claim based routing without request authentication.
+	JwtClaimBasedRoutingWithoutRequestAuthN = diag.NewMessageType(diag.Error, "IST0149", "The virtual service uses the JWT claim based routing (key: %s) but found no request authentication for the gateway (%s) pod (%s). The request authentication must first be applied for the gateway pods to validate the JWT token and make the claims available for routing.")
 )
 
 // All returns a list of all known message types.
@@ -238,6 +242,7 @@ func All() []*diag.MessageType {
 		ImageAutoWithoutInjectionWarning,
 		ImageAutoWithoutInjectionError,
 		NamespaceInjectionEnabledByDefault,
+		JwtClaimBasedRoutingWithoutRequestAuthN,
 	}
 }
 
@@ -690,3 +695,14 @@ func NewNamespaceInjectionEnabledByDefault(r *resource.Instance) diag.Message {
 		r,
 	)
 }
+
+// NewJwtClaimBasedRoutingWithoutRequestAuthN returns a new diag.Message based on JwtClaimBasedRoutingWithoutRequestAuthN.
+func NewJwtClaimBasedRoutingWithoutRequestAuthN(r *resource.Instance, key string, gateway string, pod string) diag.Message {
+	return diag.NewMessage(
+		JwtClaimBasedRoutingWithoutRequestAuthN,
+		r,
+		key,
+		gateway,
+		pod,
+	)
+}
diff --git a/galley/pkg/config/analysis/msg/messages.yaml b/galley/pkg/config/analysis/msg/messages.yaml
index 507f0e17ac..bfc3f8dd2f 100644
--- a/galley/pkg/config/analysis/msg/messages.yaml
+++ b/galley/pkg/config/analysis/msg/messages.yaml
@@ -535,3 +535,16 @@ messages:
     description: "user namespace should be injectable if Istio is installed with enableNamespacesByDefault enabled and neither injection label is set."
     template: "is enabled for Istio injection, as Istio is installed with enableNamespacesByDefault as true."
     url: "https://istio.io/latest/docs/reference/config/analysis/ist0148/"
+
+  - name: "JwtClaimBasedRoutingWithoutRequestAuthN"
+    code: IST0149
+    level: Error
+    description: "Virtual service using JWT claim based routing without request authentication."
+    template: "The virtual service uses the JWT claim based routing (key: %s) but found no request authentication for the gateway (%s) pod (%s). The request authentication must first be applied for the gateway pods to validate the JWT token and make the claims available for routing."
+    args:
+      - name: key
+        type: string
+      - name: gateway
+        type: string
+      - name: pod
+        type: string
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route.go b/pilot/pkg/networking/core/v1alpha3/route/route.go
index 7d1cc02bfd..65cd6ee909 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route.go
@@ -38,6 +38,7 @@
 	"istio.io/istio/pilot/pkg/networking/core/v1alpha3/route/retry"
 	"istio.io/istio/pilot/pkg/networking/util"
 	authz "istio.io/istio/pilot/pkg/security/authz/model"
+	"istio.io/istio/pilot/pkg/util/constant"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
@@ -52,7 +53,6 @@
 	HeaderMethod    = ":method"
 	HeaderAuthority = ":authority"
 	HeaderScheme    = ":scheme"
-	HeaderJWTClaim  = "x-jwt-claim"
 )
 
 // DefaultRouteName is the name assigned to a route generated by default in absence of a virtual service.
@@ -936,21 +936,16 @@ func isCatchAllHeaderMatch(in *networking.StringMatch) bool {
 // translateMetadataMatch translates a header match to dynamic metadata matcher. Returns nil if the header is not supported
 // or the header format is invalid for generating metadata matcher.
 //
-// The currently only supported header is x-jwt-claim for JWT claims matching. Claims of type string or list of string
+// The currently only supported header is @request.auth.claims for JWT claims matching. Claims of type string or list of string
 // are supported and nested claims are also supported using `.` as a separator for claim names.
 // Examples:
-// - `x-jwt-claim.admin` matches the claim "admin".
-// - `x-jwt-claim.group.id` matches the nested claims "group" and "id".
+// - `@request.auth.claims.admin` matches the claim "admin".
+// - `@request.auth.claims.group.id` matches the nested claims "group" and "id".
 func translateMetadataMatch(name string, in *networking.StringMatch) *matcher.MetadataMatcher {
-	keyLen := len(HeaderJWTClaim)
-	if len(name) <= keyLen || !strings.HasPrefix(strings.ToLower(name), HeaderJWTClaim) {
-		return nil
-	}
-
-	sep, claims := name[keyLen], name[keyLen+1:]
-	if sep != '.' || len(claims) == 0 {
+	if !strings.HasPrefix(strings.ToLower(name), constant.HeaderJWTClaim) {
 		return nil
 	}
+	claims := strings.Split(name[len(constant.HeaderJWTClaim):], ".")
 
 	var value *matcher.StringMatcher
 	switch m := in.MatchType.(type) {
@@ -972,7 +967,7 @@ func translateMetadataMatch(name string, in *networking.StringMatch) *matcher.Me
 			},
 		}
 	}
-	return authz.MetadataMatcherForJWTClaims(strings.Split(claims, string(sep)), value)
+	return authz.MetadataMatcherForJWTClaims(claims, value)
 }
 
 // translateHeaderMatch translates to HeaderMatcher
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go b/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
index 71c5a9a13d..7b6822f423 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route_internal_test.go
@@ -469,45 +469,45 @@ func TestTranslateMetadataMatch(t *testing.T) {
 		want *matcher.MetadataMatcher
 	}{
 		{
-			name: "x-jwt-claim",
+			name: "@request.auth.claims",
 		},
 		{
-			name: "x-jwt-claim-",
+			name: "@request.auth.claims-",
 		},
 		{
-			name: "x-jwt-claim.",
+			name: "request.auth.claims.",
 		},
 		{
-			name: "x-jwt-claim%",
+			name: "@request.auth.claims-",
 		},
 		{
-			name: "x-jwt-claim%abc",
+			name: "@request.auth.claims-abc",
 		},
 		{
 			name: "x-some-other-header",
 		},
 		{
-			name: "x-jwt-claim.key1",
+			name: "@request.auth.claims.key1",
 			in:   &networking.StringMatch{MatchType: &networking.StringMatch_Exact{Exact: "exact"}},
 			want: authz.MetadataMatcherForJWTClaims([]string{"key1"}, authzmatcher.StringMatcher("exact")),
 		},
 		{
-			name: "x-jwt-claim.key1.key2",
+			name: "@request.auth.claims.key1.KEY2",
 			in:   &networking.StringMatch{MatchType: &networking.StringMatch_Exact{Exact: "exact"}},
-			want: authz.MetadataMatcherForJWTClaims([]string{"key1", "key2"}, authzmatcher.StringMatcher("exact")),
+			want: authz.MetadataMatcherForJWTClaims([]string{"key1", "KEY2"}, authzmatcher.StringMatcher("exact")),
 		},
 		{
-			name: "x-jwt-claim.key1-key2",
+			name: "@request.auth.claims.key1-key2",
 			in:   &networking.StringMatch{MatchType: &networking.StringMatch_Exact{Exact: "exact"}},
 			want: authz.MetadataMatcherForJWTClaims([]string{"key1-key2"}, authzmatcher.StringMatcher("exact")),
 		},
 		{
-			name: "x-jwt-claim.prefix",
+			name: "@request.auth.claims.prefix",
 			in:   &networking.StringMatch{MatchType: &networking.StringMatch_Prefix{Prefix: "prefix"}},
 			want: authz.MetadataMatcherForJWTClaims([]string{"prefix"}, authzmatcher.StringMatcher("prefix*")),
 		},
 		{
-			name: "x-jwt-claim.regex",
+			name: "@request.auth.claims.regex",
 			in:   &networking.StringMatch{MatchType: &networking.StringMatch_Regex{Regex: ".+?\\..+?\\..+?"}},
 			want: authz.MetadataMatcherForJWTClaims([]string{"regex"}, authzmatcher.StringMatcherRegex(".+?\\..+?\\..+?")),
 		},
diff --git a/pilot/pkg/networking/core/v1alpha3/route/route_test.go b/pilot/pkg/networking/core/v1alpha3/route/route_test.go
index 823eade08b..9685b138f4 100644
--- a/pilot/pkg/networking/core/v1alpha3/route/route_test.go
+++ b/pilot/pkg/networking/core/v1alpha3/route/route_test.go
@@ -1152,14 +1152,14 @@ func loadBalancerPolicy(name string) *networking.LoadBalancerSettings_Consistent
 					{
 						Name: "auth",
 						Headers: map[string]*networking.StringMatch{
-							"X-Jwt-Claim.Foo": {
+							"@request.auth.claims.Foo": {
 								MatchType: &networking.StringMatch_Exact{
 									Exact: "Bar",
 								},
 							},
 						},
 						WithoutHeaders: map[string]*networking.StringMatch{
-							"X-Jwt-Claim.Bla": {
+							"@request.auth.claims.Bla": {
 								MatchType: &networking.StringMatch_Exact{
 									Exact: "Bar",
 								},
diff --git a/pilot/pkg/util/constant/constant.go b/pilot/pkg/util/constant/constant.go
new file mode 100644
index 0000000000..1f6f1f25f5
--- /dev/null
+++ b/pilot/pkg/util/constant/constant.go
@@ -0,0 +1,20 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package constant
+
+const (
+	// HeaderJWTClaim is the special header name used in virtual service for routing based on JWT claims.
+	HeaderJWTClaim = "@request.auth.claims."
+)
diff --git a/pkg/config/schema/metadata.gen.go b/pkg/config/schema/metadata.gen.go
index 17f8150331..3df375e305 100644
--- a/pkg/config/schema/metadata.gen.go
+++ b/pkg/config/schema/metadata.gen.go
@@ -318,6 +318,7 @@ func (fi bindataFileInfo) Sys() interface{} {
       - "istio/networking/v1alpha3/sidecars"
       - "istio/networking/v1alpha3/virtualservices"
       - "istio/security/v1beta1/authorizationpolicies"
+      - "istio/security/v1beta1/requestauthentications"
       - "k8s/apiextensions.k8s.io/v1/customresourcedefinitions"
       - "k8s/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations"
       - "k8s/apps/v1/deployments"
diff --git a/pkg/config/schema/metadata.yaml b/pkg/config/schema/metadata.yaml
index 1d31246153..e1d1a2b71b 100644
--- a/pkg/config/schema/metadata.yaml
+++ b/pkg/config/schema/metadata.yaml
@@ -263,6 +263,7 @@ snapshots:
       - "istio/networking/v1alpha3/sidecars"
       - "istio/networking/v1alpha3/virtualservices"
       - "istio/security/v1beta1/authorizationpolicies"
+      - "istio/security/v1beta1/requestauthentications"
       - "k8s/apiextensions.k8s.io/v1/customresourcedefinitions"
       - "k8s/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations"
       - "k8s/apps/v1/deployments"
diff --git a/pkg/config/validation/validation.go b/pkg/config/validation/validation.go
index 545821c2f1..8bb0c4a723 100644
--- a/pkg/config/validation/validation.go
+++ b/pkg/config/validation/validation.go
@@ -47,6 +47,7 @@
 	telemetry "istio.io/api/telemetry/v1alpha1"
 	type_beta "istio.io/api/type/v1beta1"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/util/constant"
 	"istio.io/istio/pilot/pkg/util/sets"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
@@ -1960,6 +1961,7 @@ func(cfg config.Config) (Warning, error) {
 		}
 
 		appliesToMesh := false
+		appliesToGateway := false
 		if len(virtualService.Gateways) == 0 {
 			appliesToMesh = true
 		} else {
@@ -1967,6 +1969,25 @@ func(cfg config.Config) (Warning, error) {
 			for _, gatewayName := range virtualService.Gateways {
 				if gatewayName == constants.IstioMeshGateway {
 					appliesToMesh = true
+				} else {
+					appliesToGateway = true
+				}
+			}
+		}
+
+		if !appliesToGateway {
+			validateJWTClaimRoute := func(headers map[string]*networking.StringMatch) {
+				for key := range headers {
+					if strings.HasPrefix(key, constant.HeaderJWTClaim) {
+						msg := fmt.Sprintf("JWT claim based routing (key: %s) is only supported for gateway, found no gateways: %v", key, virtualService.Gateways)
+						errs = appendValidation(errs, errors.New(msg))
+					}
+				}
+			}
+			for _, http := range virtualService.GetHttp() {
+				for _, m := range http.GetMatch() {
+					validateJWTClaimRoute(m.GetHeaders())
+					validateJWTClaimRoute(m.GetWithoutHeaders())
 				}
 			}
 		}
diff --git a/pkg/config/validation/validation_test.go b/pkg/config/validation/validation_test.go
index 9eeda6bb97..569a80e675 100644
--- a/pkg/config/validation/validation_test.go
+++ b/pkg/config/validation/validation_test.go
@@ -2738,6 +2738,27 @@ func TestValidateVirtualService(t *testing.T) {
 				},
 			}},
 		}, valid: true, warning: false},
+		{name: "jwt claim route without gateway", in: &networking.VirtualService{
+			Hosts:    []string{"foo.bar"},
+			Gateways: []string{"mesh"},
+			Http: []*networking.HTTPRoute{{
+				Route: []*networking.HTTPRouteDestination{{
+					Destination: &networking.Destination{Host: "foo.baz"},
+				}},
+				Match: []*networking.HTTPMatchRequest{
+					{
+						Uri: &networking.StringMatch{
+							MatchType: &networking.StringMatch_Prefix{Prefix: "/"},
+						},
+						Headers: map[string]*networking.StringMatch{
+							"@request.auth.claims.foo": {
+								MatchType: &networking.StringMatch_Exact{Exact: "bar"},
+							},
+						},
+					},
+				},
+			}},
+		}, valid: false, warning: false},
 	}
 
 	for _, tc := range testCases {
diff --git a/tests/integration/pilot/common/routing.go b/tests/integration/pilot/common/routing.go
index 5616335fc8..bd69c2a851 100644
--- a/tests/integration/pilot/common/routing.go
+++ b/tests/integration/pilot/common/routing.go
@@ -2594,14 +2594,14 @@ func jwtClaimRoute(apps *EchoDeployments) []TrafficTestCase {
       {{- if .Headers }}
       headers:
         {{- range $data := .Headers }}
-          {{$data.Name}}:
+          "{{$data.Name}}":
             {{$data.Match}}: {{$data.Value}}
         {{- end }}
       {{- end }}
       {{- if .WithoutHeaders }}
       withoutHeaders:
         {{- range $data := .WithoutHeaders }}
-          {{$data.Name}}:
+          "{{$data.Name}}":
             {{$data.Match}}: {{$data.Value}}
         {{- end }}
       {{- end }}
@@ -2635,8 +2635,8 @@ func jwtClaimRoute(apps *EchoDeployments) []TrafficTestCase {
 	}
 	headersWithNoToken := map[string][]string{"Host": {"foo.bar"}}
 	headersWithNoTokenButSameHeader := map[string][]string{
-		"Host":                    {"foo.bar"},
-		"x-jwt-claim.nested.key1": {"valueA"},
+		"Host":                            {"foo.bar"},
+		"request.auth.claims.nested.key1": {"valueA"},
 	}
 
 	type configData struct {
@@ -2651,7 +2651,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"Headers": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2670,7 +2670,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.sub", "prefix", "sub"}},
+					"Headers": []configData{{"@request.auth.claims.sub", "prefix", "sub"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2690,8 +2690,8 @@ type configData struct {
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
 					"Headers": []configData{
-						{"x-jwt-claim.nested.key1", "exact", "valueA"},
-						{"x-jwt-claim.sub", "prefix", "sub"},
+						{"@request.auth.claims.nested.key1", "exact", "valueA"},
+						{"@request.auth.claims.sub", "prefix", "sub"},
 					},
 				}
 			},
@@ -2711,7 +2711,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"WithoutHeaders": []configData{{"x-jwt-claim.nested.key1", "exact", "value-not-matched"}},
+					"WithoutHeaders": []configData{{"@request.auth.claims.nested.key1", "exact", "value-not-matched"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2730,7 +2730,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"WithoutHeaders": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"WithoutHeaders": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2749,8 +2749,8 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers":        []configData{{"x-jwt-claim.sub", "prefix", "sub"}},
-					"WithoutHeaders": []configData{{"x-jwt-claim.nested.key1", "exact", "value-not-matched"}},
+					"Headers":        []configData{{"@request.auth.claims.sub", "prefix", "sub"}},
+					"WithoutHeaders": []configData{{"@request.auth.claims.nested.key1", "exact", "value-not-matched"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2770,8 +2770,8 @@ type configData struct {
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
 					"Headers": []configData{
-						{"x-jwt-claim.nested.key1", "exact", "valueA"},
-						{"x-jwt-claim.sub", "prefix", "value-not-matched"},
+						{"@request.auth.claims.nested.key1", "exact", "valueA"},
+						{"@request.auth.claims.sub", "prefix", "value-not-matched"},
 					},
 				}
 			},
@@ -2791,7 +2791,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.sub", "exact", "value-not-matched"}},
+					"Headers": []configData{{"@request.auth.claims.sub", "exact", "value-not-matched"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2810,7 +2810,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"Headers": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2829,7 +2829,7 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"Headers": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
@@ -2848,14 +2848,14 @@ type configData struct {
 			config:           configAll,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"Headers": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
 				Count:    1,
 				Port:     &echo.Port{Protocol: protocol.HTTP},
 				PortName: "http",
-				// Include a header x-jwt-claim.nested.key1 and value same as the JWT claim, should not be routed.
+				// Include a header @request.auth.claims.nested.key1 and value same as the JWT claim, should not be routed.
 				Headers:   headersWithNoTokenButSameHeader,
 				Validator: echo.ExpectCode("404"),
 			},
@@ -2868,7 +2868,7 @@ type configData struct {
 			config:           configRoute,
 			templateVars: func(src echo.Callers, dest echo.Instances) map[string]interface{} {
 				return map[string]interface{}{
-					"Headers": []configData{{"x-jwt-claim.nested.key1", "exact", "valueA"}},
+					"Headers": []configData{{"@request.auth.claims.nested.key1", "exact", "valueA"}},
 				}
 			},
 			opts: echo.CallOptions{
-- 
2.35.3

