From c900b96f8a30b4ad8a8b7af88d7a838fe6496239 Mon Sep 17 00:00:00 2001
From: Brad Ison <brad.ison@redhat.com>
Date: Wed, 10 Feb 2021 17:19:22 +0100
Subject: [mec] MAISTRA-1801: Support ServiceMeshExtension in istiod

MAISTRA-1801: Add ServiceMeshExtension types and clients

Partial pick of 8b1ed09411 for Maistra 2.1 / Istio 1.8 rebase.

This brings in the ServiceMeshExtension types and code-gen tasks, and
adds the generated clients.  It moves the existing generated Maistra
clients to the `v1` subdirectory of the client package.

MAISTRA-1801: Support ServiceMeshExtension in istiod

Partial pick of 8b1ed09411 for Maistra 2.1 / Istio 1.8 rebase.

This brings in the core changes to istiod to support extenions after
the previous commit adding the types and generated clients.

Also includes the fix from f3bf790a07 - MAISTRA-1873 (#182):

  - Properly delete extensions from store when they disappear

MAISTRA-1801: ServiceMeshExtension: Add mec component

Partial pick of 8b1ed09411 for Maistra 2.1 / Istio 1.8 rebase.

This adds the new `mec` component for ServiceMeshExtension.

Also includes the following squashed fixes:

  * 5687393dd3 - MAISTRA-1862 (#183):

    Fix NilPointerException when images can't be pulled

    This also improves logging by dropping some loglevels and always
    logging errors when calling pullStrategy.GetImage()

  * 4d5f66a7e6 - MAISTRA-1993 (#206):

    Add unit tests for ServiceMeshExtensions

    Note: Only code changes included here. No tests.

  * 7382c81b20 - MAISTRA-1948 (#206):

    Fix URL generation and parsing

MAISTRA-1801: Update vendor for ServiceMeshExtension support

This is just an update to the vendor directory after pulling changes
for ServiceMeshExtension support. The OpenShift client-go library has
been pulled from the release-4.6 branch, because Istio 1.8 uses the
version 1.19 Kubernetes client libraries, and OpenShift 4.6 is based
on the 1.19 Kubernetes release.

MAISTRA-1993: Add unit tests for ServiceMeshExtensions

Partial pick of 4d5f66a7e6 for Maistra 2.1 / Istio 1.8 rebase.

This includes only the changes to the tests from the original commit,
the other code changes have been squashed into an earlier commit.

This also includes the test changes from:

  * 7382c81b20 - MAISTRA-1948: Fix URL generation and parsing (#206)

- MAISTRA-2442 Increase pilot-agent binary max size to 60MB
---
 go.mod                                        |     3 +-
 go.sum                                        |    28 +-
 istioctl/pkg/authz/listener.go                |     4 +-
 .../github.com/openshift/client-go/LICENSE    |   191 +
 mec/cmd/mec/main.go                           |   187 +
 mec/deploy/example.yaml                       |    15 +
 mec/deploy/mec.yaml                           |   132 +
 .../pkg/model/interfaces.go                   |    19 +-
 mec/pkg/model/types.go                        |   104 +
 mec/pkg/model/types_test.go                   |    76 +
 mec/pkg/podman/podman.go                      |    79 +
 mec/pkg/pullstrategy/fake/strategy.go         |   112 +
 mec/pkg/pullstrategy/ossm/strategy.go         |   272 +
 mec/pkg/pullstrategy/ossm/strategy_test.go    |   338 +
 mec/pkg/server/httpserver.go                  |    82 +
 mec/pkg/server/httpserver_test.go             |   124 +
 mec/pkg/server/worker.go                      |   298 +
 mec/pkg/server/worker_test.go                 |   283 +
 pilot/cmd/pilot-discovery/app/cmd.go          |     3 +
 pilot/pkg/bootstrap/server.go                 |    28 +
 pilot/pkg/features/pilot.go                   |     3 +
 pilot/pkg/model/context.go                    |     4 +
 pilot/pkg/model/push_context.go               |    85 +
 pilot/pkg/model/push_context_test.go          |   120 +
 .../core/v1alpha3/listener_builder.go         |     7 +
 .../apis/servicemesh/v1alpha1/register.go     |    76 +
 .../v1alpha1/servicemeshextension_types.go    |    83 +
 .../v1alpha1/zz_generated.deepcopy.go         |   153 +
 .../{ => v1}/clientset/versioned/clientset.go |     2 +-
 .../{ => v1}/clientset/versioned/doc.go       |     0
 .../versioned/fake/clientset_generated.go     |     6 +-
 .../{ => v1}/clientset/versioned/fake/doc.go  |     0
 .../clientset/versioned/fake/register.go      |     0
 .../clientset/versioned/scheme/doc.go         |     0
 .../clientset/versioned/scheme/register.go    |     0
 .../versioned/typed/servicemesh/v1/doc.go     |     0
 .../typed/servicemesh/v1/fake/doc.go          |     0
 .../v1/fake/fake_servicemesh_client.go        |     2 +-
 .../v1/fake/fake_servicemeshmemberroll.go     |     0
 .../servicemesh/v1/generated_expansion.go     |     0
 .../servicemesh/v1/servicemesh_client.go      |     2 +-
 .../servicemesh/v1/servicemeshmemberroll.go   |     2 +-
 .../informers/externalversions/factory.go     |     6 +-
 .../informers/externalversions/generic.go     |     0
 .../internalinterfaces/factory_interfaces.go  |     2 +-
 .../externalversions/servicemesh/interface.go |     4 +-
 .../servicemesh/v1/interface.go               |     2 +-
 .../servicemesh/v1/servicemeshmemberroll.go   |     6 +-
 .../servicemesh/v1/expansion_generated.go     |     0
 .../servicemesh/v1/servicemeshmemberroll.go   |     0
 .../clientset/versioned/clientset.go          |    18 +-
 .../{ => v1alpha1}/clientset/versioned/doc.go |     0
 .../versioned/fake/clientset_generated.go     |    12 +-
 .../clientset/versioned/fake/doc.go           |     0
 .../clientset/versioned/fake/register.go      |     4 +-
 .../clientset/versioned/scheme/doc.go         |     0
 .../clientset/versioned/scheme/register.go    |     4 +-
 .../typed/servicemesh/v1alpha1}/doc.go        |     2 +-
 .../typed/servicemesh/v1alpha1}/fake/doc.go   |     0
 .../v1alpha1}/fake/fake_servicemesh_client.go |    10 +-
 .../fake/fake_servicemeshextension.go         |   140 +
 .../v1alpha1}/generated_expansion.go          |     4 +-
 .../v1alpha1}/servicemesh_client.go           |    38 +-
 .../v1alpha1/servicemeshextension.go          |   193 +
 .../informers/externalversions/factory.go     |    10 +-
 .../informers/externalversions/generic.go     |     8 +-
 .../internalinterfaces/factory_interfaces.go  |     2 +-
 .../externalversions/servicemesh/interface.go |    14 +-
 .../servicemesh/v1alpha1}/interface.go        |    14 +-
 .../v1alpha1/servicemeshextension.go          |    88 +
 .../v1alpha1}/expansion_generated.go          |    14 +-
 .../v1alpha1/servicemeshextension.go          |    92 +
 pkg/servicemesh/controller/controller.go      |     6 +-
 .../controller/extension/controller.go        |   138 +
 pkg/servicemesh/extension/apply_extension.go  |   193 +
 pkg/servicemesh/maistra.mk                    |    27 +-
 pkg/servicemesh/model/extension.go            |    45 +
 tests/binary/binaries_test.go                 |     2 +-
 .../openshift/api/image/docker10/doc.go       |     4 +
 .../api/image/docker10/dockertypes.go         |    56 +
 .../openshift/api/image/docker10/register.go  |    38 +
 .../image/docker10/zz_generated.deepcopy.go   |   113 +
 .../api/image/dockerpre012/deepcopy.go        |    18 +
 .../openshift/api/image/dockerpre012/doc.go   |     4 +
 .../api/image/dockerpre012/dockertypes.go     |   136 +
 .../api/image/dockerpre012/register.go        |    37 +
 .../dockerpre012/zz_generated.deepcopy.go     |   216 +
 .../openshift/api/image/v1/consts.go          |    69 +
 .../github.com/openshift/api/image/v1/doc.go  |     8 +
 .../openshift/api/image/v1/generated.pb.go    | 10890 ++++++++++++++++
 .../openshift/api/image/v1/generated.proto    |   626 +
 .../openshift/api/image/v1/legacy.go          |    33 +
 .../openshift/api/image/v1/register.go        |    54 +
 .../openshift/api/image/v1/types.go           |   634 +
 .../api/image/v1/zz_generated.deepcopy.go     |   978 ++
 .../v1/zz_generated.swagger_doc_generated.go  |   413 +
 vendor/github.com/openshift/client-go/LICENSE |   191 +
 .../image}/clientset/versioned/clientset.go   |    32 +-
 .../image/clientset/versioned/doc.go          |     4 +
 .../versioned/fake/clientset_generated.go     |    26 +-
 .../image/clientset/versioned/fake/doc.go     |     4 +
 .../clientset/versioned/fake/register.go      |    20 +-
 .../image/clientset/versioned/scheme/doc.go   |     4 +
 .../clientset/versioned/scheme/register.go    |    18 +-
 .../clientset/versioned/typed/image/v1/doc.go |     4 +
 .../versioned/typed/image/v1/fake/doc.go      |     4 +
 .../typed/image/v1/fake/fake_image.go         |   106 +
 .../typed/image/v1/fake/fake_image_client.go  |    52 +
 .../image/v1/fake/fake_imagesignature.go      |    38 +
 .../typed/image/v1/fake/fake_imagestream.go   |   149 +
 .../image/v1/fake/fake_imagestreamimage.go    |    33 +
 .../image/v1/fake/fake_imagestreamimport.go   |    33 +
 .../image/v1/fake/fake_imagestreammapping.go  |    33 +
 .../image/v1/fake/fake_imagestreamtag.go      |    86 +
 .../typed/image/v1/fake/fake_imagetag.go      |    86 +
 .../typed/image/v1/generated_expansion.go     |    19 +
 .../versioned/typed/image/v1/image.go         |   152 +
 .../versioned/typed/image/v1/image_client.go  |   108 +
 .../typed/image/v1/imagesignature.go          |    59 +
 .../versioned/typed/image/v1/imagestream.go   |   211 +
 .../typed/image/v1/imagestreamimage.go        |    51 +
 .../typed/image/v1/imagestreamimport.go       |    51 +
 .../typed/image/v1/imagestreammapping.go      |    52 +
 .../typed/image/v1/imagestreamtag.go          |   111 +
 .../versioned/typed/image/v1/imagetag.go      |   111 +
 vendor/modules.txt                            |    12 +-
 126 files changed, 20011 insertions(+), 197 deletions(-)
 create mode 100644 licenses/github.com/openshift/client-go/LICENSE
 create mode 100644 mec/cmd/mec/main.go
 create mode 100644 mec/deploy/example.yaml
 create mode 100644 mec/deploy/mec.yaml
 copy pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go => mec/pkg/model/interfaces.go (50%)
 create mode 100644 mec/pkg/model/types.go
 create mode 100644 mec/pkg/model/types_test.go
 create mode 100644 mec/pkg/podman/podman.go
 create mode 100644 mec/pkg/pullstrategy/fake/strategy.go
 create mode 100644 mec/pkg/pullstrategy/ossm/strategy.go
 create mode 100644 mec/pkg/pullstrategy/ossm/strategy_test.go
 create mode 100644 mec/pkg/server/httpserver.go
 create mode 100644 mec/pkg/server/httpserver_test.go
 create mode 100644 mec/pkg/server/worker.go
 create mode 100644 mec/pkg/server/worker_test.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
 create mode 100644 pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/clientset.go (96%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/fake/clientset_generated.go (90%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/fake/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/fake/register.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/scheme/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/scheme/register.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/fake/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go (92%)
 rename pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemeshmemberroll.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/generated_expansion.go (100%)
 copy pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go (97%)
 rename pkg/servicemesh/client/{ => v1}/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go (98%)
 copy pkg/servicemesh/client/{ => v1}/informers/externalversions/factory.go (95%)
 copy pkg/servicemesh/client/{ => v1}/informers/externalversions/generic.go (100%)
 copy pkg/servicemesh/client/{ => v1}/informers/externalversions/internalinterfaces/factory_interfaces.go (94%)
 copy pkg/servicemesh/client/{ => v1}/informers/externalversions/servicemesh/interface.go (87%)
 copy pkg/servicemesh/client/{ => v1}/informers/externalversions/servicemesh/v1/interface.go (93%)
 rename pkg/servicemesh/client/{ => v1}/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go (93%)
 copy pkg/servicemesh/client/{ => v1}/listers/servicemesh/v1/expansion_generated.go (100%)
 rename pkg/servicemesh/client/{ => v1}/listers/servicemesh/v1/servicemeshmemberroll.go (100%)
 copy pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/clientset.go (79%)
 rename pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/fake/clientset_generated.go (80%)
 rename pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/fake/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/fake/register.go (94%)
 rename pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/scheme/doc.go (100%)
 copy pkg/servicemesh/client/{ => v1alpha1}/clientset/versioned/scheme/register.go (94%)
 rename pkg/servicemesh/client/{clientset/versioned/typed/servicemesh/v1 => v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1}/doc.go (97%)
 rename pkg/servicemesh/client/{clientset/versioned/typed/servicemesh/v1 => v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1}/fake/doc.go (100%)
 rename pkg/servicemesh/client/{clientset/versioned/typed/servicemesh/v1 => v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1}/fake/fake_servicemesh_client.go (70%)
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
 rename pkg/servicemesh/client/{clientset/versioned/typed/servicemesh/v1 => v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1}/generated_expansion.go (90%)
 rename pkg/servicemesh/client/{clientset/versioned/typed/servicemesh/v1 => v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1}/servicemesh_client.go (56%)
 create mode 100644 pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
 rename pkg/servicemesh/client/{ => v1alpha1}/informers/externalversions/factory.go (93%)
 rename pkg/servicemesh/client/{ => v1alpha1}/informers/externalversions/generic.go (87%)
 rename pkg/servicemesh/client/{ => v1alpha1}/informers/externalversions/internalinterfaces/factory_interfaces.go (94%)
 rename pkg/servicemesh/client/{ => v1alpha1}/informers/externalversions/servicemesh/interface.go (70%)
 rename pkg/servicemesh/client/{informers/externalversions/servicemesh/v1 => v1alpha1/informers/externalversions/servicemesh/v1alpha1}/interface.go (69%)
 create mode 100644 pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
 rename pkg/servicemesh/client/{listers/servicemesh/v1 => v1alpha1/listers/servicemesh/v1alpha1}/expansion_generated.go (63%)
 create mode 100644 pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/servicemeshextension.go
 create mode 100644 pkg/servicemesh/controller/extension/controller.go
 create mode 100644 pkg/servicemesh/extension/apply_extension.go
 create mode 100644 pkg/servicemesh/model/extension.go
 create mode 100644 vendor/github.com/openshift/api/image/docker10/doc.go
 create mode 100644 vendor/github.com/openshift/api/image/docker10/dockertypes.go
 create mode 100644 vendor/github.com/openshift/api/image/docker10/register.go
 create mode 100644 vendor/github.com/openshift/api/image/docker10/zz_generated.deepcopy.go
 create mode 100644 vendor/github.com/openshift/api/image/dockerpre012/deepcopy.go
 create mode 100644 vendor/github.com/openshift/api/image/dockerpre012/doc.go
 create mode 100644 vendor/github.com/openshift/api/image/dockerpre012/dockertypes.go
 create mode 100644 vendor/github.com/openshift/api/image/dockerpre012/register.go
 create mode 100644 vendor/github.com/openshift/api/image/dockerpre012/zz_generated.deepcopy.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/consts.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/doc.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/generated.pb.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/generated.proto
 create mode 100644 vendor/github.com/openshift/api/image/v1/legacy.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/register.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/types.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/zz_generated.deepcopy.go
 create mode 100644 vendor/github.com/openshift/api/image/v1/zz_generated.swagger_doc_generated.go
 create mode 100644 vendor/github.com/openshift/client-go/LICENSE
 rename {pkg/servicemesh/client => vendor/github.com/openshift/client-go/image}/clientset/versioned/clientset.go (65%)
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/doc.go
 rename {pkg/servicemesh/client => vendor/github.com/openshift/client-go/image}/clientset/versioned/fake/clientset_generated.go (63%)
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/fake/doc.go
 rename {pkg/servicemesh/client => vendor/github.com/openshift/client-go/image}/clientset/versioned/fake/register.go (62%)
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/doc.go
 rename {pkg/servicemesh/client => vendor/github.com/openshift/client-go/image}/clientset/versioned/scheme/register.go (65%)
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/doc.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/doc.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image_client.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagesignature.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestream.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimage.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimport.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreammapping.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamtag.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagetag.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/generated_expansion.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image_client.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagesignature.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestream.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimage.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimport.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreammapping.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamtag.go
 create mode 100644 vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagetag.go

diff --git a/go.mod b/go.mod
index 4bee95d959..12448485d4 100644
--- a/go.mod
+++ b/go.mod
@@ -59,7 +59,8 @@ require (
 	github.com/mitchellh/copystructure v1.2.0
 	github.com/mitchellh/go-homedir v1.1.0
 	github.com/onsi/gomega v1.16.0
-	github.com/openshift/api v0.0.0-20200713203337-b2494ecb17dd
+	github.com/openshift/api v0.0.0-20200929171550-c99a4deebbe5
+	github.com/openshift/client-go v0.0.0-20200929181438-91d71ef2122c
 	github.com/pmezard/go-difflib v1.0.0
 	github.com/prometheus/client_golang v1.11.0
 	github.com/prometheus/client_model v0.2.0
diff --git a/go.sum b/go.sum
index a106e13128..6b2bcdb7fc 100644
--- a/go.sum
+++ b/go.sum
@@ -9,6 +9,7 @@ cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxK
 cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
 cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
 cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
+cloud.google.com/go v0.51.0/go.mod h1:hWtGJ6gnXH+KgDv+V0zFGDvpi07n3z8ZNj3T1RW0Gcw=
 cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
 cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
 cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
@@ -70,22 +71,26 @@ github.com/Azure/go-autorest v10.8.1+incompatible/go.mod h1:r+4oMnoxhatjLLJ6zxSW
 github.com/Azure/go-autorest v14.2.0+incompatible h1:V5VMDjClD3GiElqLWO7mz2MxNAK/vTfRHdAubSIPRgs=
 github.com/Azure/go-autorest v14.2.0+incompatible/go.mod h1:r+4oMnoxhatjLLJ6zxSWATqVooLgysK6ZNox3g/xq24=
 github.com/Azure/go-autorest/autorest v0.9.0/go.mod h1:xyHB1BMZT0cuDHU7I0+g046+BFDTQ8rEZB0s4Yfa6bI=
+github.com/Azure/go-autorest/autorest v0.9.6/go.mod h1:/FALq9T/kS7b5J5qsQ+RSTUdAmGFqi0vUdVNNx8q630=
 github.com/Azure/go-autorest/autorest v0.11.1/go.mod h1:JFgpikqFJ/MleTTxwepExTKnFUKKszPS8UavbQYUMuw=
 github.com/Azure/go-autorest/autorest v0.11.12/go.mod h1:eipySxLmqSyC5s5k1CLupqet0PSENBEDP93LQ9a8QYw=
 github.com/Azure/go-autorest/autorest v0.11.18/go.mod h1:dSiJPy22c3u0OtOKDNttNgqpNFY/GeWa7GH/Pz56QRA=
 github.com/Azure/go-autorest/autorest v0.11.20 h1:s8H1PbCZSqg/DH7JMlOz6YMig6htWLNPsjDdlLqCx3M=
 github.com/Azure/go-autorest/autorest v0.11.20/go.mod h1:o3tqFY+QR40VOlk+pV4d77mORO64jOXSgEnPQgLK6JY=
 github.com/Azure/go-autorest/autorest/adal v0.5.0/go.mod h1:8Z9fGy2MpX0PvDjB1pEgQTmVqjGhiHBW7RJJEciWzS0=
+github.com/Azure/go-autorest/autorest/adal v0.8.2/go.mod h1:ZjhuQClTqx435SRJ2iMlOxPYt3d2C/T/7TiQCVZSn3Q=
 github.com/Azure/go-autorest/autorest/adal v0.9.0/go.mod h1:/c022QCutn2P7uY+/oQWWNcK9YU+MH96NgK+jErpbcg=
 github.com/Azure/go-autorest/autorest/adal v0.9.5/go.mod h1:B7KF7jKIeC9Mct5spmyCB/A8CG/sEz1vwIRGv/bbw7A=
 github.com/Azure/go-autorest/autorest/adal v0.9.13/go.mod h1:W/MM4U6nLxnIskrw4UwWzlHfGjwUS50aOsc/I3yuU8M=
 github.com/Azure/go-autorest/autorest/adal v0.9.15 h1:X+p2GF0GWyOiSmqohIaEeuNFNDY4I4EOlVuUQvFdWMk=
 github.com/Azure/go-autorest/autorest/adal v0.9.15/go.mod h1:tGMin8I49Yij6AQ+rvV+Xa/zwxYQB5hmsd6DkfAx2+A=
 github.com/Azure/go-autorest/autorest/date v0.1.0/go.mod h1:plvfp3oPSKwf2DNjlBjWF/7vwR+cUD/ELuzDCXwHUVA=
+github.com/Azure/go-autorest/autorest/date v0.2.0/go.mod h1:vcORJHLJEh643/Ioh9+vPmf1Ij9AEBM5FuBIXLmIy0g=
 github.com/Azure/go-autorest/autorest/date v0.3.0 h1:7gUk1U5M/CQbp9WoqinNzJar+8KY+LPI6wiWrP/myHw=
 github.com/Azure/go-autorest/autorest/date v0.3.0/go.mod h1:BI0uouVdmngYNUzGWeSYnokU+TrmwEsOqdt8Y6sso74=
 github.com/Azure/go-autorest/autorest/mocks v0.1.0/go.mod h1:OTyCOPRA2IgIlWxVYxBee2F5Gr4kF2zd2J5cFRaIDN0=
 github.com/Azure/go-autorest/autorest/mocks v0.2.0/go.mod h1:OTyCOPRA2IgIlWxVYxBee2F5Gr4kF2zd2J5cFRaIDN0=
+github.com/Azure/go-autorest/autorest/mocks v0.3.0/go.mod h1:a8FDP3DYzQ4RYfVAxAN3SVSiiO77gL2j2ronKKP0syM=
 github.com/Azure/go-autorest/autorest/mocks v0.4.0/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=
 github.com/Azure/go-autorest/autorest/mocks v0.4.1 h1:K0laFcLE6VLTOwNgSxaGbUcLPuGXlNkbVvq4cW4nIHk=
 github.com/Azure/go-autorest/autorest/mocks v0.4.1/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=
@@ -999,9 +1004,11 @@ github.com/opencontainers/runtime-tools v0.0.0-20181011054405-1d69bd0f9c39/go.mo
 github.com/opencontainers/selinux v1.6.0/go.mod h1:VVGKuOLlE7v4PJyT6h7mNWvq1rzqiriPsEqVhc+svHE=
 github.com/opencontainers/selinux v1.8.0/go.mod h1:RScLhm78qiWa2gbVCcGkC7tCGdgk3ogry1nUQF8Evvo=
 github.com/opencontainers/selinux v1.8.2/go.mod h1:MUIHuUEvKB1wtJjQdOyYRgOnLD2xAPP8dBsCoU0KuF8=
-github.com/openshift/api v0.0.0-20200713203337-b2494ecb17dd h1:MV2FH/cm1wqoVCIL98GT46CMnXZw9faUoIzdZ4nfZw0=
-github.com/openshift/api v0.0.0-20200713203337-b2494ecb17dd/go.mod h1:vWmWTm4y7XR3wkLR+bDDjRbvkBfx2yP7yve6kfb7+Ts=
-github.com/openshift/build-machinery-go v0.0.0-20200713135615-1f43d26dccc7/go.mod h1:b1BuldmJlbA/xYtdZvKi+7j5YGB44qJUJDZ9zwiNCfE=
+github.com/openshift/api v0.0.0-20200929171550-c99a4deebbe5 h1:ZyeIVj2qV9fNF4SKVMAIhCSdGOnQcOxYDah2wXVqeiY=
+github.com/openshift/api v0.0.0-20200929171550-c99a4deebbe5/go.mod h1:Si/I9UGeRR3qzg01YWPmtlr0GeGk2fnuggXJRmjAZ6U=
+github.com/openshift/build-machinery-go v0.0.0-20200819073603-48aa266c95f7/go.mod h1:b1BuldmJlbA/xYtdZvKi+7j5YGB44qJUJDZ9zwiNCfE=
+github.com/openshift/client-go v0.0.0-20200929181438-91d71ef2122c h1:DQTWW8DGRN7fu5qwEPcbdP9hAxXi7dm5cvi0hrdR3UE=
+github.com/openshift/client-go v0.0.0-20200929181438-91d71ef2122c/go.mod h1:MwESrlhzumQGcGtPCpz/WjDrlvhu1fMNlLBcNYjO0fY=
 github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
 github.com/openzipkin/zipkin-go v0.1.1/go.mod h1:NtoC/o8u3JlF1lSlyPNswIbeQH9bJTmOf0Erfk+hxe8=
 github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
@@ -1300,6 +1307,7 @@ golang.org/x/crypto v0.0.0-20190617133340-57b3e21c3d56/go.mod h1:yigFU9vqHzYiE8U
 golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
 golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
 golang.org/x/crypto v0.0.0-20191122220453-ac88ee75c92c/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
+golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20200221231518-2aa609cf4a9d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
@@ -1626,7 +1634,6 @@ golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtn
 golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
 golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200115044656-831fdb1e1868/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
 golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
 golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
 golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
@@ -1643,6 +1650,7 @@ golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roY
 golang.org/x/tools v0.0.0-20200505023115-26f46d2f7ef8/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
+golang.org/x/tools v0.0.0-20200616133436-c1934b75d054/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
@@ -1913,8 +1921,8 @@ istio.io/gogo-genproto v0.0.0-20211206163843-5eda25c96270/go.mod h1:6BwTZRNbWS57
 istio.io/pkg v0.0.0-20211206163648-57f93bc2eff7 h1:ZVrtOhO4LiD78vS+L5PZFnM68OlaJV7pYSFCeMP9TYA=
 istio.io/pkg v0.0.0-20211206163648-57f93bc2eff7/go.mod h1:rJLxqU2GEnFR3cIiun1uoiG87ghuQSD8jFkcjyT3Qes=
 k8s.io/api v0.18.2/go.mod h1:SJCWI7OLzhZSvbY7U8zwNl9UA4o1fizoug34OV/2r78=
-k8s.io/api v0.18.3/go.mod h1:UOaMwERbqJMfeeeHc8XJKawj4P9TgDRnViIqqBeH2QA=
 k8s.io/api v0.18.4/go.mod h1:lOIQAKYgai1+vz9J7YcDZwC26Z0zQewYOGWdyIPUUQ4=
+k8s.io/api v0.19.0/go.mod h1:I1K45XlvTrDjmj5LoM5LuP/KYrhWbjUKT/SoPG0qTjw=
 k8s.io/api v0.20.1/go.mod h1:KqwcCVogGxQY3nBlRpwt+wpAMF/KjaCc7RpywacvqUo=
 k8s.io/api v0.20.2/go.mod h1:d7n6Ehyzx+S+cE3VhTGfVNNqtGc/oL9DCdYYahlurV8=
 k8s.io/api v0.20.4/go.mod h1:++lNL1AJMkDymriNniQsWRkMDzRaX2Y/POTUi8yvqYQ=
@@ -1931,8 +1939,8 @@ k8s.io/apiextensions-apiserver v0.22.1/go.mod h1:HeGmorjtRmRLE+Q8dJu6AYRoZccvCMs
 k8s.io/apiextensions-apiserver v0.22.2 h1:zK7qI8Ery7j2CaN23UCFaC1hj7dMiI87n01+nKuewd4=
 k8s.io/apiextensions-apiserver v0.22.2/go.mod h1:2E0Ve/isxNl7tWLSUDgi6+cmwHi5fQRdwGVCxbC+KFA=
 k8s.io/apimachinery v0.18.2/go.mod h1:9SnR/e11v5IbyPCGbvJViimtJ0SwHG4nfZFjU77ftcA=
-k8s.io/apimachinery v0.18.3/go.mod h1:OaXp26zu/5J7p0f92ASynJa1pZo06YlV9fG7BoWbCko=
 k8s.io/apimachinery v0.18.4/go.mod h1:OaXp26zu/5J7p0f92ASynJa1pZo06YlV9fG7BoWbCko=
+k8s.io/apimachinery v0.19.0/go.mod h1:DnPGDnARWFvYa3pMHgSxtbZb7gpzzAZ1pTfaUNDVlmA=
 k8s.io/apimachinery v0.20.1/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
 k8s.io/apimachinery v0.20.2/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
 k8s.io/apimachinery v0.20.4/go.mod h1:WlLqWAHZGg07AeltaI0MV5uk1Omp8xaN0JGLY6gkRpU=
@@ -1955,6 +1963,7 @@ k8s.io/cli-runtime v0.22.2 h1:fsd9rFk9FSaVq4SUq1fM27c8CFGsYZUJ/3BkgmjYWuY=
 k8s.io/cli-runtime v0.22.2/go.mod h1:tkm2YeORFpbgQHEK/igqttvPTRIHFRz5kATlw53zlMI=
 k8s.io/client-go v0.18.2/go.mod h1:Xcm5wVGXX9HAA2JJ2sSBUn3tCJ+4SVlCbl2MNNv+CIU=
 k8s.io/client-go v0.18.4/go.mod h1:f5sXwL4yAZRkAtzOxRWUhA/N8XzGCb+nPZI8PfobZ9g=
+k8s.io/client-go v0.19.0/go.mod h1:H9E/VT95blcFQnlyShFgnFT9ZnJOAceiUHM3MlRC+mU=
 k8s.io/client-go v0.20.1/go.mod h1:/zcHdt1TeWSd5HoUe6elJmHSQ6uLLgp4bIJHVEuy+/Y=
 k8s.io/client-go v0.20.4/go.mod h1:LiMv25ND1gLUdBeYxBIwKpkSC5IsozMMmOOeSJboP+k=
 k8s.io/client-go v0.20.6/go.mod h1:nNQMnOvEUEsOzRRFIIkdmYOjAZrC8bgq0ExboWSU1I0=
@@ -1964,8 +1973,8 @@ k8s.io/client-go v0.22.1/go.mod h1:BquC5A4UOo4qVDUtoc04/+Nxp1MeHcVc1HJm1KmG8kk=
 k8s.io/client-go v0.22.2 h1:DaSQgs02aCC1QcwUdkKZWOeaVsQjYvWv8ZazcZ6JcHc=
 k8s.io/client-go v0.22.2/go.mod h1:sAlhrkVDf50ZHx6z4K0S40wISNTarf1r800F+RlCF6U=
 k8s.io/code-generator v0.18.2/go.mod h1:+UHX5rSbxmR8kzS+FAv7um6dtYrZokQvjHpDSYRVkTc=
-k8s.io/code-generator v0.18.3/go.mod h1:TgNEVx9hCyPGpdtCWA34olQYLkh3ok9ar7XfSsr8b6c=
 k8s.io/code-generator v0.18.4/go.mod h1:TgNEVx9hCyPGpdtCWA34olQYLkh3ok9ar7XfSsr8b6c=
+k8s.io/code-generator v0.19.0/go.mod h1:moqLn7w0t9cMs4+5CQyxnfA/HV8MF6aAVENF+WZZhgk=
 k8s.io/code-generator v0.21.3/go.mod h1:K3y0Bv9Cz2cOW2vXUrNZlFbflhuPvuadW6JdnN6gGKo=
 k8s.io/code-generator v0.22.0/go.mod h1:eV77Y09IopzeXOJzndrDyCI88UBok2h6WxAlBwpxa+o=
 k8s.io/code-generator v0.22.1/go.mod h1:eV77Y09IopzeXOJzndrDyCI88UBok2h6WxAlBwpxa+o=
@@ -1988,6 +1997,7 @@ k8s.io/cri-api v0.20.6/go.mod h1:ew44AjNXwyn1s0U4xCKGodU7J1HzBeZ1MpGrpa5r8Yc=
 k8s.io/gengo v0.0.0-20190128074634-0689ccc1d7d6/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20200114144118-36b2048a9120/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
+k8s.io/gengo v0.0.0-20200428234225-8167cfdcfc14/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20201203183100-97869a43a9d9/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20201214224949-b6c5ce23f027/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20210813121822-485abfe95c7c/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
@@ -1998,6 +2008,7 @@ k8s.io/klog v1.0.0 h1:Pt+yjF5aB1xDSVbau4VsWe+dQNzA0qv1LlXdC2dF6Q8=
 k8s.io/klog v1.0.0/go.mod h1:4Bi6QPql/J/LkTDqv7R/cd3hPo4k2DG6Ptcz060Ez5I=
 k8s.io/klog/v2 v2.0.0/go.mod h1:PBfzABfn139FHAV07az/IF9Wp1bkk3vpT2XSJ76fSDE=
 k8s.io/klog/v2 v2.2.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=
+k8s.io/klog/v2 v2.3.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=
 k8s.io/klog/v2 v2.4.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=
 k8s.io/klog/v2 v2.5.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=
 k8s.io/klog/v2 v2.8.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=
@@ -2006,6 +2017,7 @@ k8s.io/klog/v2 v2.10.0 h1:R2HDMDJsHVTHA2n4RjwbeYXdOcBymXdX/JRb1v0VGhE=
 k8s.io/klog/v2 v2.10.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=
 k8s.io/kube-openapi v0.0.0-20200121204235-bf4fb3bd569c/go.mod h1:GRQhZsXIAJ1xR0C9bd8UpWHZ5plfAS9fzPjJuQ6JL3E=
 k8s.io/kube-openapi v0.0.0-20200410145947-61e04a5be9a6/go.mod h1:GRQhZsXIAJ1xR0C9bd8UpWHZ5plfAS9fzPjJuQ6JL3E=
+k8s.io/kube-openapi v0.0.0-20200805222855-6aeccd4b50c6/go.mod h1:UuqjUnNftUyPE5H64/qeyjQoUZhGpeFDVdxjTeEVN2o=
 k8s.io/kube-openapi v0.0.0-20201113171705-d219536bb9fd/go.mod h1:WOJ3KddDSol4tAGcJo0Tvi+dK12EcqSLqcWsryKMpfM=
 k8s.io/kube-openapi v0.0.0-20210305001622-591a79e4bda7/go.mod h1:wXW5VT87nVfh/iLV8FpR2uDvrFyomxbtb1KivDbvPTE=
 k8s.io/kube-openapi v0.0.0-20210421082810-95288971da7e/go.mod h1:vHXdDvt9+2spS2Rx9ql3I8tycm3H9FDfdUoIuKCefvw=
@@ -2019,6 +2031,7 @@ k8s.io/metrics v0.22.1/go.mod h1:i/ZNap89UkV1gLa26dn7fhKAdheJaKy+moOqJbiif7E=
 k8s.io/metrics v0.22.2/go.mod h1:GUcsBtpsqQD1tKFS/2wCKu4ZBowwRncLOJH1rgWs3uw=
 k8s.io/utils v0.0.0-20200324210504-a9aa75ae1b89/go.mod h1:sZAwmy6armz5eXlNoLmJcl4F1QuKu7sr+mFQ0byX7Ew=
 k8s.io/utils v0.0.0-20200603063816-c1c6865ac451/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
+k8s.io/utils v0.0.0-20200729134348-d5654de09c73/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
 k8s.io/utils v0.0.0-20201110183641-67b214c5f920/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
 k8s.io/utils v0.0.0-20210707171843-4b05e18ac7d9/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
 k8s.io/utils v0.0.0-20210722164352-7f3ee0f31471/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=
@@ -2056,6 +2069,7 @@ sigs.k8s.io/mcs-api v0.1.0 h1:edDbg0oRGfXw8TmZjKYep06LcJLv/qcYLidejnUp0PM=
 sigs.k8s.io/mcs-api v0.1.0/go.mod h1:gGiAryeFNB4GBsq2LBmVqSgKoobLxt+p7ii/WG5QYYw=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0-20200116222232-67a7b8c61874/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
+sigs.k8s.io/structured-merge-diff/v4 v4.0.1/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.0.2/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.0.3/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.1.0/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
diff --git a/istioctl/pkg/authz/listener.go b/istioctl/pkg/authz/listener.go
index 3378fd1767..3c44861a0b 100644
--- a/istioctl/pkg/authz/listener.go
+++ b/istioctl/pkg/authz/listener.go
@@ -58,7 +58,7 @@ func getFilterConfig(filter *listener.Filter, out proto.Message) error {
 	return nil
 }
 
-func getHTTPConnectionManager(filter *listener.Filter) *hcm_filter.HttpConnectionManager {
+func GetHTTPConnectionManager(filter *listener.Filter) *hcm_filter.HttpConnectionManager {
 	cm := &hcm_filter.HttpConnectionManager{}
 	if err := getFilterConfig(filter, cm); err != nil {
 		log.Errorf("failed to get HTTP connection manager config: %s", err)
@@ -86,7 +86,7 @@ func parse(listeners []*listener.Listener) []*parsedListener {
 			for _, filter := range fc.Filters {
 				switch filter.Name {
 				case wellknown.HTTPConnectionManager, "envoy.http_connection_manager":
-					if cm := getHTTPConnectionManager(filter); cm != nil {
+					if cm := GetHTTPConnectionManager(filter); cm != nil {
 						for _, httpFilter := range cm.GetHttpFilters() {
 							switch httpFilter.GetName() {
 							case wellknown.HTTPRoleBasedAccessControl:
diff --git a/licenses/github.com/openshift/client-go/LICENSE b/licenses/github.com/openshift/client-go/LICENSE
new file mode 100644
index 0000000000..c4ea8b6f9d
--- /dev/null
+++ b/licenses/github.com/openshift/client-go/LICENSE
@@ -0,0 +1,191 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   Copyright 2014 Red Hat, Inc.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/mec/cmd/mec/main.go b/mec/cmd/mec/main.go
new file mode 100644
index 0000000000..c2b839aaf1
--- /dev/null
+++ b/mec/cmd/mec/main.go
@@ -0,0 +1,187 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"io/ioutil"
+	"os"
+	"os/signal"
+	"strings"
+	"syscall"
+	"time"
+
+	"github.com/fsnotify/fsnotify"
+	"github.com/spf13/cobra"
+	"k8s.io/client-go/tools/cache"
+
+	"istio.io/istio/mec/pkg/pullstrategy/ossm"
+	"istio.io/istio/mec/pkg/server"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/istio/pkg/servicemesh/controller/extension"
+	"istio.io/pkg/filewatcher"
+	"istio.io/pkg/log"
+)
+
+const (
+	defaultResyncPeriod = time.Minute * 5
+)
+
+var (
+	baseURL        string
+	tokenPath      string
+	serveDirectory string
+	registryURL    string
+	resyncPeriod   string
+	namespace      string
+)
+
+func main() {
+	cmd := createCommand(os.Args[1:])
+	if err := cmd.Execute(); err != nil {
+		log.Errora(err)
+	}
+}
+
+func createCommand(args []string) *cobra.Command {
+	cmd := &cobra.Command{
+		Use: "mec [flags]",
+		Run: func(cmd *cobra.Command, args []string) {
+			resyncPeriod, err := time.ParseDuration(resyncPeriod)
+			if err != nil {
+				log.Warnf("Failed to parse --resyncPeriod parameter, using default 5m: %v", err)
+				resyncPeriod = defaultResyncPeriod
+			}
+			config, err := kube.BuildClientConfig("", "")
+			if err != nil {
+				log.Errorf("Failed to BuildClientConfig(): %v", err)
+			}
+			mrc, err := memberroll.NewMemberRollController(
+				config,
+				namespace,
+				"default",
+				resyncPeriod,
+			)
+			if err != nil {
+				log.Errorf("Failed to create MemberRoll Controller: %v", err)
+			}
+			ec, err := extension.NewControllerFromConfigFile(
+				"",
+				[]string{"test"},
+				mrc,
+				resyncPeriod,
+			)
+			if err != nil {
+				log.Errorf("Failed to create Extension Controller: %v", err)
+			}
+
+			p, err := ossm.NewOSSMPullStrategy(config, namespace)
+			if err != nil {
+				log.Errorf("Failed to create OSSMPullStrategy: %v", err)
+			}
+			w, err := server.NewWorker(config, p, baseURL, serveDirectory)
+			if err != nil {
+				log.Errorf("Failed to create worker: %v", err)
+				return
+			}
+			ec.RegisterEventHandler(cache.ResourceEventHandlerFuncs{
+				AddFunc: func(obj interface{}) {
+					w.Queue <- server.ExtensionEvent{
+						Extension: obj.(*v1alpha1.ServiceMeshExtension).DeepCopy(),
+						Operation: server.ExtensionEventOperationAdd,
+					}
+				},
+				DeleteFunc: func(obj interface{}) {
+					w.Queue <- server.ExtensionEvent{
+						Extension: obj.(*v1alpha1.ServiceMeshExtension).DeepCopy(),
+						Operation: server.ExtensionEventOperationDelete,
+					}
+				},
+				UpdateFunc: func(oldObj, newObj interface{}) {
+					w.Queue <- server.ExtensionEvent{
+						Extension: newObj.(*v1alpha1.ServiceMeshExtension).DeepCopy(),
+						Operation: server.ExtensionEventOperationUpdate,
+					}
+				},
+			})
+
+			ws := server.NewHTTPServer(8080, serveDirectory)
+
+			fw := filewatcher.NewWatcher()
+			err = fw.Add(tokenPath)
+			if err != nil {
+				_ = fw.Close()
+				log.Errorf("Error while creating watch on token file %s: %v", tokenPath, err)
+			}
+
+			stopChan := make(chan struct{}, 1)
+
+			go func() {
+				ch := fw.Events(tokenPath)
+				if ch != nil {
+					for {
+						select {
+						case <-ch:
+							log.Infof("Token file updated. Logging in to registry")
+							tokenBytes, err := ioutil.ReadFile(tokenPath)
+							if err != nil {
+								log.Errorf("Error reading token file %s: %v", tokenPath, err)
+							}
+							token := strings.TrimSpace(string(tokenBytes))
+							output, err := p.Login(registryURL, token)
+							if err != nil {
+								log.Errorf("Error logging in to registry: %v", err)
+							} else {
+								log.Infof("%s", output)
+							}
+						case <-stopChan:
+							return
+						}
+					}
+				}
+			}()
+			fw.Events(tokenPath) <- fsnotify.Event{}
+
+			mrc.Start(stopChan)
+			ec.Start(stopChan)
+			w.Start(stopChan)
+			ws.Start(stopChan)
+
+			sigc := make(chan os.Signal, 1)
+			signal.Notify(sigc,
+				syscall.SIGHUP,
+				syscall.SIGINT,
+				syscall.SIGTERM,
+				syscall.SIGQUIT)
+			<-sigc
+			fw.Close()
+			close(stopChan)
+		},
+	}
+
+	cmd.SetArgs(args)
+	cmd.PersistentFlags().StringVar(&resyncPeriod, "resyncPeriod", "5m", "Resync Period for the K8s controllers")
+	cmd.PersistentFlags().StringVar(&baseURL, "baseURL", "http://mec.istio-system.svc.cluster.local", "Base URL")
+	cmd.PersistentFlags().StringVar(&tokenPath, "tokenPath", "/var/run/secrets/kubernetes.io/serviceaccount/token",
+		"File containing to the ServiceAccount token to be used for communication with the K8s API server")
+	cmd.PersistentFlags().StringVar(&serveDirectory, "serveDirectory", "/srv",
+		"Directory form where WASM modules are served")
+	cmd.PersistentFlags().StringVar(&registryURL, "registryURL", "image-registry.openshift-image-registry.svc:5000",
+		"Registry from which to pull images by default")
+	cmd.PersistentFlags().StringVar(&namespace, "namespace", "istio-system", "The namespace that MEC is running in")
+
+	return cmd
+}
diff --git a/mec/deploy/example.yaml b/mec/deploy/example.yaml
new file mode 100644
index 0000000000..6e677b780d
--- /dev/null
+++ b/mec/deploy/example.yaml
@@ -0,0 +1,15 @@
+apiVersion: extensions.maistra.io/v1alpha1
+kind: ServiceMeshExtension
+metadata:
+  name: oidc-filter
+spec:
+  config: |
+    {
+      "auth_cluster": "outbound|8080||keycloak.default.svc.cluster.local",
+      "auth_host": "keycloak.default.svc.cluster.local:8080",
+      "login_uri": "http://localhost:8080/auth/realms/master/protocol/openid-connect/auth",
+      "token_uri": "http://localhost:8080/auth/realms/master/protocol/openid-connect/token",
+      "client_id": "test",
+      "client_secret": "INSERT_CLIENT_SECRET_HERE"
+    }
+  image: registry.gitlab.com/dgrimm/istio/oidc-filter:latest
diff --git a/mec/deploy/mec.yaml b/mec/deploy/mec.yaml
new file mode 100644
index 0000000000..523ce3c637
--- /dev/null
+++ b/mec/deploy/mec.yaml
@@ -0,0 +1,132 @@
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: mec
+  namespace: istio-system
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: mec
+  namespace: istio-system
+  labels:
+    app: mec
+spec:
+  ports:
+  - name: http
+    port: 80
+    targetPort: 8080
+  selector:
+    app: mec
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: mec
+  namespace: istio-system
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: mec
+  template:
+    metadata:
+      labels:
+        app: mec
+      annotations:
+        sidecar.istio.io/inject: "true"
+    spec:
+      serviceAccountName: mec
+      containers:
+      - image: registry.gitlab.com/dgrimm/istio/mec:latest
+        imagePullPolicy: Always
+        name: mec
+        command:
+        - mec
+        - --namespace
+        - cp
+        - --cluster
+        - outbound|80||mec.cp.svc.cluster.local
+        - --baseURL
+        - http://mec.cp.svc.cluster.local
+        env:
+        - name: HOME
+          value: /podman
+        ports:
+        - containerPort: 8080
+        volumeMounts:
+        - name: home
+          mountPath: /podman
+        - name: servedir
+          mountPath: /srv
+        - name: graph
+          mountPath: /var/lib/containers
+      volumes:
+      - name: home
+        emptyDir: {}
+      - name: servedir
+        emptyDir: {}
+      - name: graph
+        emptyDir: {}
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: mec
+rules:
+- apiGroups:
+  - extensions.maistra.io
+  resources:
+  - servicemeshextensions
+  - servicemeshextensions/status
+  verbs:
+  - get
+  - list
+  - watch
+  - update
+- apiGroups:
+  - maistra.io
+  resources:
+  - servicemeshmemberrolls
+  verbs:
+  - get
+  - list
+  - watch
+- apiGroups:
+  - image.openshift.io
+  resources:
+  - imagestreams
+  - imagestreamimports
+  verbs:
+  - create
+  - update
+  - get
+  - list
+  - watch
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: mec
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: mec
+subjects:
+- kind: ServiceAccount
+  name: mec
+  namespace: istio-system
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: registry-viewer
+  namespace: istio-system
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: registry-viewer
+subjects:
+- kind: ServiceAccount
+  name: mec
+  namespace: istio-system
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go b/mec/pkg/model/interfaces.go
similarity index 50%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
copy to mec/pkg/model/interfaces.go
index 9e3d02202f..88e5d210ec 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
+++ b/mec/pkg/model/interfaces.go
@@ -4,7 +4,7 @@
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
-//    http://www.apache.org/licenses/LICENSE-2.0
+//     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
@@ -12,8 +12,19 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// Code generated by client-gen. DO NOT EDIT.
+package model
 
-package v1
+type ImagePullStrategy interface {
+	// PullImage will go and Pull and image from a remote registry
+	PullImage(image *ImageRef) (Image, error)
+	// GetImage returns an image that has been pulled previously
+	GetImage(image *ImageRef) (Image, error)
+	// Login is used to provide credentials to the ImagePullStrategy
+	Login(registryURL, token string) (string, error)
+}
 
-type ServiceMeshMemberRollExpansion interface{}
+type Image interface {
+	CopyWasmModule(outputFile string) error
+	GetManifest() *Manifest
+	SHA256() string
+}
diff --git a/mec/pkg/model/types.go b/mec/pkg/model/types.go
new file mode 100644
index 0000000000..5b17525183
--- /dev/null
+++ b/mec/pkg/model/types.go
@@ -0,0 +1,104 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
+
+import (
+	"fmt"
+	"strings"
+
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+)
+
+type ImageRef struct {
+	Hub        string
+	Repository string
+	Tag        string
+	SHA256     string
+}
+
+type Manifest struct {
+	SchemaVersion ManifestSchemaVersion `yaml:"schemaVersion"`
+	Name          string                `yaml:"name"`
+	Description   string                `yaml:"description"`
+	Version       string                `yaml:"version"`
+	Phase         v1alpha1.FilterPhase  `yaml:"phase"`
+	Priority      int                   `yaml:"priority"`
+	Module        string                `yaml:"module"`
+}
+
+type ManifestSchemaVersion string
+
+const (
+	ManifestSchemaVersion1 = "1"
+
+	legalSHA256Chars = "0123456789abcdef"
+)
+
+func (i *ImageRef) String() string {
+	if i.SHA256 != "" {
+		return fmt.Sprintf("%s/%s@sha256:%s", i.Hub, i.Repository, i.SHA256)
+	}
+	return fmt.Sprintf("%s/%s:%s", i.Hub, i.Repository, i.Tag)
+}
+
+func StringToImageRef(ref string) (result *ImageRef) {
+	var tag, sha string
+	var uri string
+	if i := strings.Index(ref, "@"); i > -1 {
+		uri = ref[:i]
+		sha = ref[i+8:] // len("@sha256:") == 8
+		if len(sha) != 64 {
+			return nil
+		}
+		for i := 0; i < len(sha); i++ {
+			if !strings.Contains(legalSHA256Chars, sha[i:i+1]) { //nolint
+				return nil
+			}
+		}
+	} else {
+		refSplit := strings.Split(ref, ":")
+		if len(refSplit) < 2 || len(refSplit) > 3 {
+			return nil
+		} else if len(refSplit) == 3 {
+			// hostname can come with port
+			refSplit = []string{strings.Join(refSplit[:2], ":"), refSplit[2]}
+		}
+		uri = refSplit[0]
+		tag = refSplit[1]
+	}
+
+	uriSplit := strings.Split(uri, "/")
+	if len(uriSplit) < 2 {
+		return nil
+	}
+	hub := strings.Join(uriSplit[:len(uriSplit)-1], "/")
+	repo := uriSplit[len(uriSplit)-1]
+
+	if sha != "" {
+		result = &ImageRef{
+			Hub:        hub,
+			Repository: repo,
+			SHA256:     sha,
+		}
+	} else {
+		result = &ImageRef{
+			Hub:        hub,
+			Repository: repo,
+			Tag:        tag,
+		}
+	}
+
+	return result
+}
diff --git a/mec/pkg/model/types_test.go b/mec/pkg/model/types_test.go
new file mode 100644
index 0000000000..b02787aa45
--- /dev/null
+++ b/mec/pkg/model/types_test.go
@@ -0,0 +1,76 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
+
+import (
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+)
+
+func TestStringToImageRef(t *testing.T) {
+	testCases := []struct {
+		input  string
+		output *ImageRef
+	}{
+		{
+			input: "registry.io/corp/repo:latest",
+			output: &ImageRef{
+				Repository: "repo",
+				Hub:        "registry.io/corp",
+				Tag:        "latest",
+			},
+		},
+		{
+			input: "registry.io/corp/repo@sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			output: &ImageRef{
+				Repository: "repo",
+				Hub:        "registry.io/corp",
+				SHA256:     "41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			},
+		},
+		{
+			input:  "registry.io/corp/repo@sha256:af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			output: nil,
+		},
+		{
+			input:  "registry.io/corp/repo@sha256:invaliddc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			output: nil,
+		},
+		{
+			input:  "registry.io/corp/repo@sha256:41@f286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			output: nil,
+		},
+		{
+			input: "registry.io:8080/corp/repo:latest",
+			output: &ImageRef{
+				Repository: "repo",
+				Hub:        "registry.io:8080/corp",
+				Tag:        "latest",
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.input, func(t *testing.T) {
+			result := StringToImageRef(tc.input)
+			if !cmp.Equal(result, tc.output) {
+				t.Errorf("result not as expected, -got +want:\n%s", cmp.Diff(result, tc.output))
+			}
+			if result != nil && result.String() != tc.input {
+				t.Errorf("ImageRef.String() conversion failed, got: %s want: %s", result.String(), tc.input)
+			}
+		})
+	}
+}
diff --git a/mec/pkg/podman/podman.go b/mec/pkg/podman/podman.go
new file mode 100644
index 0000000000..eaf6e05cc6
--- /dev/null
+++ b/mec/pkg/podman/podman.go
@@ -0,0 +1,79 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package podman
+
+import (
+	"bytes"
+	"errors"
+	"os/exec"
+	"strings"
+	"sync"
+)
+
+var lock sync.Mutex = sync.Mutex{}
+
+type Podman interface {
+	Login(token, registry string) (string, error)
+	Pull(image string) (string, error)
+	Create(image string) (string, error)
+	Copy(from, to string) (string, error)
+	RemoveContainer(containerID string) error
+	GetImageID(image string) (string, error)
+}
+
+type podman struct{}
+
+func NewPodman() Podman {
+	return &podman{}
+}
+
+func (p *podman) Login(registry, token string) (string, error) {
+	return p.runCommand("login", "--tls-verify=false", "--username=mec", "--password="+token, registry)
+}
+
+func (p *podman) Pull(image string) (string, error) {
+	return p.runCommand("pull", "--tls-verify=false", image)
+}
+
+func (p *podman) Create(image string) (string, error) {
+	return p.runCommand("create", image, ".")
+}
+
+func (p *podman) Copy(from, to string) (string, error) {
+	return p.runCommand("cp", from, to)
+}
+
+func (p *podman) RemoveContainer(containerID string) error {
+	_, err := p.runCommand("rm", containerID)
+	return err
+}
+
+func (p *podman) GetImageID(image string) (string, error) {
+	return p.runCommand("image", "ls", "-nq", image)
+}
+
+func (p *podman) runCommand(args ...string) (string, error) {
+	lock.Lock()
+	defer lock.Unlock()
+	cmd := exec.Command("podman", append([]string{"--storage-driver=vfs"}, args...)...)
+	var out, errOut bytes.Buffer
+	cmd.Stdout = &out
+	cmd.Stderr = &errOut
+	err := cmd.Run()
+	if err != nil {
+		err = errors.New(strings.TrimSpace(errOut.String()))
+	}
+	return strings.TrimSpace(out.String()), err
+}
diff --git a/mec/pkg/pullstrategy/fake/strategy.go b/mec/pkg/pullstrategy/fake/strategy.go
new file mode 100644
index 0000000000..4b573aa222
--- /dev/null
+++ b/mec/pkg/pullstrategy/fake/strategy.go
@@ -0,0 +1,112 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package fake
+
+import (
+	"io/ioutil"
+	"os"
+	"strings"
+
+	"istio.io/istio/mec/pkg/model"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+)
+
+const (
+	FakeContainerSHA256  = "sha256:997890bc85c5796408ceb20b0ca75dabe6fe868136e926d24ad0f36aa424f99d"
+	FakeContainer2SHA256 = "sha256:04a68a66858919123dafb8b8f8d7b7c80f7f14f129bfd12930339c879acfce2a"
+	FakeModule           = "test"
+	FakeModuleSHA256     = "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
+	FakeModule2          = "another"
+	FakeModule2SHA256    = "ae448ac86c4e8e4dec645729708ef41873ae79c6dff84eff73360989487f08e5"
+)
+
+var (
+	FakeManifestYAML = `
+schemaVersion: 1
+
+name: testExtension
+description: bogus
+phase: PostAuthN
+priority: 12
+`
+
+	FakeManifest = model.Manifest{
+		SchemaVersion: model.ManifestSchemaVersion1,
+		Name:          "testExtension",
+		Description:   "bogus",
+		Phase:         v1alpha1.FilterPhasePostAuthN,
+		Priority:      12,
+	}
+	FakeManifest2 = model.Manifest{
+		SchemaVersion: model.ManifestSchemaVersion1,
+		Name:          "another extension",
+		Description:   "description",
+		Phase:         v1alpha1.FilterPhasePreAuthZ,
+		Priority:      8,
+	}
+)
+
+type image struct {
+	manifest     *model.Manifest
+	fileContent  []byte
+	containerSHA string
+}
+
+func (i *image) CopyWasmModule(outputFile string) error {
+	return ioutil.WriteFile(outputFile, i.fileContent, os.ModePerm)
+}
+
+func (i *image) GetManifest() *model.Manifest {
+	return i.manifest
+}
+
+func (i *image) SHA256() string {
+	return i.containerSHA
+}
+
+type PullStrategy struct {
+	pulledImages map[string]model.Image
+}
+
+func (p *PullStrategy) PullImage(imageRef *model.ImageRef) (model.Image, error) {
+	if p.pulledImages == nil {
+		p.pulledImages = make(map[string]model.Image)
+	}
+	if strings.Contains(imageRef.String(), "other") {
+		p.pulledImages[imageRef.String()] = &image{
+			manifest:     &FakeManifest2,
+			fileContent:  []byte(FakeModule2),
+			containerSHA: FakeContainer2SHA256,
+		}
+	} else {
+		p.pulledImages[imageRef.String()] = &image{
+			manifest:     &FakeManifest,
+			fileContent:  []byte(FakeModule),
+			containerSHA: FakeContainerSHA256,
+		}
+	}
+	return p.pulledImages[imageRef.String()], nil
+}
+
+func (p *PullStrategy) GetImage(imageRef *model.ImageRef) (model.Image, error) {
+	if img, ok := p.pulledImages[imageRef.String()]; ok {
+		return img, nil
+	}
+	return nil, nil
+}
+
+func (p *PullStrategy) Login(registryURL, token string) (string, error) {
+	return "", nil
+}
diff --git a/mec/pkg/pullstrategy/ossm/strategy.go b/mec/pkg/pullstrategy/ossm/strategy.go
new file mode 100644
index 0000000000..c9ff7277fe
--- /dev/null
+++ b/mec/pkg/pullstrategy/ossm/strategy.go
@@ -0,0 +1,272 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ossm
+
+import (
+	"context"
+	"crypto/sha256"
+	"fmt"
+	"io/ioutil"
+	"path"
+	"strings"
+
+	imagev1 "github.com/openshift/api/image/v1"
+	imagev1client "github.com/openshift/client-go/image/clientset/versioned/typed/image/v1"
+	"gopkg.in/yaml.v2"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/rest"
+
+	"istio.io/istio/mec/pkg/model"
+	"istio.io/istio/mec/pkg/podman"
+	"istio.io/pkg/log"
+)
+
+const (
+	imageStreamPrefix = "ossm-extension-"
+)
+
+type ossmPullStrategy struct {
+	client    imagev1client.ImageV1Interface
+	namespace string
+	podman    podman.Podman
+}
+
+func NewOSSMPullStrategy(config *rest.Config, namespace string) (model.ImagePullStrategy, error) {
+	cl, err := imagev1client.NewForConfig(config)
+	if err != nil {
+		log.Errorf("Failed to create imagev1 client: %s", err)
+		return nil, err
+	}
+
+	return &ossmPullStrategy{
+		client:    cl,
+		namespace: namespace,
+		podman:    podman.NewPodman(),
+	}, nil
+}
+
+func (p *ossmPullStrategy) createImageStreamImport(imageStreamName string, image *model.ImageRef) (*imagev1.ImageStreamImport, error) {
+	isi := &imagev1.ImageStreamImport{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: imageStreamName,
+		},
+		Spec: imagev1.ImageStreamImportSpec{
+			Import: true,
+			Images: []imagev1.ImageImportSpec{
+				{
+					From: corev1.ObjectReference{
+						Kind: "DockerImage",
+						Name: image.String(),
+					},
+					To: &corev1.LocalObjectReference{
+						Name: image.Repository,
+					},
+					ReferencePolicy: imagev1.TagReferencePolicy{
+						Type: imagev1.SourceTagReferencePolicy,
+					},
+				},
+			},
+		},
+	}
+
+	createdIsi, err := p.client.ImageStreamImports(p.namespace).Create(context.TODO(), isi, metav1.CreateOptions{})
+	if err != nil {
+		return nil, err
+	}
+
+	return createdIsi, nil
+}
+
+type ossmImage struct {
+	imageID  string
+	sha256   string
+	manifest *model.Manifest
+	podman   podman.Podman
+}
+
+func (p *ossmPullStrategy) GetImage(image *model.ImageRef) (model.Image, error) {
+	// only works with imageRefs that come with a SHA256 value
+	if image.SHA256 == "" {
+		return nil, fmt.Errorf("getImage() only works for pinned images")
+	}
+	imageID, err := p.podman.GetImageID(image.SHA256)
+	if err != nil {
+		return nil, err
+	} else if imageID == "" {
+		return nil, nil
+	}
+	manifest, err := p.extractManifest(imageID)
+	if err != nil {
+		log.Errorf("failed to extract manifest from container image: %s", err)
+		return nil, err
+	}
+	return &ossmImage{
+		manifest: manifest,
+		imageID:  imageID,
+		sha256:   "sha256:" + image.SHA256,
+		podman:   p.podman,
+	}, nil
+}
+
+// Pull retrieves an image from a remote registry
+func (p *ossmPullStrategy) PullImage(image *model.ImageRef) (model.Image, error) {
+	var imageStream *imagev1.ImageStream
+	var err error
+	imageStreamName := getImageStreamName(image)
+	for attempt := 0; attempt < 2; attempt++ {
+		imageStream, err = p.client.ImageStreams(p.namespace).Get(context.TODO(), imageStreamName, metav1.GetOptions{})
+		if errors.IsNotFound(err) {
+			createdIsi, err := p.createImageStreamImport(imageStreamName, image)
+			if err != nil {
+				log.Warnf("failed to create ImageStreamImport: %s, attempt %d", err, attempt)
+				continue
+			}
+			log.Infof("Created ImageStreamImport %s", createdIsi.Name)
+			continue
+		} else if err != nil {
+			log.Warnf("failed to Get() ImageStream: %s, attempt %d", err, attempt)
+			continue
+		}
+		if imageStream != nil {
+			tagFound := false
+			for _, tag := range imageStream.Spec.Tags {
+				if tag.From.Name == image.String() {
+					tagFound = true
+					break
+				}
+			}
+			if !tagFound {
+				createdIsi, err := p.createImageStreamImport(imageStreamName, image)
+				if err != nil {
+					log.Warnf("failed to create ImageStreamImport: %s, attempt %d", err, attempt)
+					continue
+				}
+				log.Infof("Created ImageStreamImport %s", createdIsi.Name)
+			}
+		}
+	}
+	if err != nil {
+		return nil, err
+	}
+	if len(imageStream.Status.Tags) == 0 || len(imageStream.Status.Tags[0].Items) == 0 || imageStream.Status.DockerImageRepository == "" {
+		return nil, fmt.Errorf("failed to pull Image: ImageStream has not processed image yet")
+	}
+	for _, condition := range imageStream.Status.Tags[0].Conditions {
+		if condition.Status == corev1.ConditionFalse {
+			return nil, fmt.Errorf("failed to pull image: %s", condition.Message)
+		}
+	}
+
+	// TODO implement importing always when ImagePullPolicy == Always
+	repo := imageStream.Status.DockerImageRepository
+	sha := imageStream.Status.Tags[0].Items[0].Image
+	log.Infof("Pulling container image %s", repo+"@"+sha)
+	imageID, err := p.podman.Pull(repo + "@" + sha)
+	if err != nil {
+		log.Errorf("failed to pull image: %s", err)
+		return nil, err
+	}
+	log.Infof("Pulled container image with ID %s", imageID)
+	manifest, err := p.extractManifest(imageID)
+	if err != nil {
+		log.Errorf("failed to extract manifest from container image: %s", err)
+		return nil, err
+	}
+	return &ossmImage{
+		manifest: manifest,
+		imageID:  imageID,
+		sha256:   sha,
+		podman:   p.podman,
+	}, nil
+}
+
+func (p *ossmPullStrategy) Login(registryURL, token string) (output string, err error) {
+	output, err = p.podman.Login(registryURL, token)
+	return output, err
+}
+
+func getImageStreamName(image *model.ImageRef) string {
+	reponame := image.Repository
+	if len(reponame) > 8 {
+		reponame = reponame[:8]
+	}
+	postfix := fmt.Sprintf("-%x", sha256.Sum256([]byte(image.String())))[:9]
+	return imageStreamPrefix + reponame + postfix
+}
+
+func (p *ossmPullStrategy) extractManifest(imageID string) (*model.Manifest, error) {
+	containerID, err := p.podman.Create(imageID)
+	if err != nil {
+		log.Errorf("failed to create an image: %s", err)
+		return nil, err
+	}
+	log.Infof("Created container with ID %s", containerID)
+	log.Infof("Extracting manifest from container with ID %s", containerID)
+
+	tmpDir, err := ioutil.TempDir("", containerID)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create temp dir: %s", err)
+	}
+	manifestFile := path.Join(tmpDir, "manifest.yaml")
+	_, err = p.podman.Copy(containerID+":/manifest.yaml", manifestFile)
+	if err != nil {
+		log.Errorf("failed to copy an image: %s", err)
+		return nil, err
+	}
+	manifestBytes, err := ioutil.ReadFile(manifestFile)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read manifest.yaml: %s", err)
+	}
+	manifest := &model.Manifest{}
+	err = yaml.Unmarshal(manifestBytes, manifest)
+	if err != nil {
+		return nil, fmt.Errorf("failed to unmarshal manifest.yaml: %s", err)
+	}
+	err = p.podman.RemoveContainer(containerID)
+	if err != nil {
+		return nil, fmt.Errorf("failed to remove container: %s", err)
+	}
+	log.Infof("Deleted container with ID %s", containerID)
+	return manifest, nil
+}
+
+func (ref *ossmImage) CopyWasmModule(outputFile string) error {
+	containerID, err := ref.podman.Create(ref.imageID)
+	if err != nil {
+		return err
+	}
+	log.Infof("Created container with ID %s", containerID)
+	log.Infof("Extracting WASM module from container with ID %s", containerID)
+	_, err = ref.podman.Copy(containerID+":/"+ref.manifest.Module, outputFile)
+	if err != nil {
+		return err
+	}
+	err = ref.podman.RemoveContainer(containerID)
+	if err != nil {
+		return err
+	}
+	log.Infof("Deleted container with ID %s", containerID)
+	return nil
+}
+
+func (ref *ossmImage) GetManifest() *model.Manifest {
+	return ref.manifest
+}
+
+func (ref *ossmImage) SHA256() string {
+	return strings.Split(ref.sha256, "sha256:")[1]
+}
diff --git a/mec/pkg/pullstrategy/ossm/strategy_test.go b/mec/pkg/pullstrategy/ossm/strategy_test.go
new file mode 100644
index 0000000000..e89fbc711a
--- /dev/null
+++ b/mec/pkg/pullstrategy/ossm/strategy_test.go
@@ -0,0 +1,338 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ossm
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os"
+	"strings"
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
+	imagev1 "github.com/openshift/api/image/v1"
+	"github.com/openshift/client-go/image/clientset/versioned/fake"
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	"istio.io/istio/mec/pkg/model"
+	"istio.io/istio/mec/pkg/podman"
+	fakestrategy "istio.io/istio/mec/pkg/pullstrategy/fake"
+)
+
+type fakePodman struct {
+	pulledImages []string
+	shaMap       map[string]string
+}
+
+func (p *fakePodman) assignSHA256(image, sha string) {
+	if p.shaMap == nil {
+		p.shaMap = map[string]string{}
+	}
+	p.shaMap[image] = sha
+}
+
+func (p *fakePodman) Login(token, registry string) (string, error) {
+	return "", nil
+}
+
+func (p *fakePodman) Pull(image string) (string, error) {
+	imageRef := model.StringToImageRef(image)
+	if imageRef.SHA256 != "" {
+		p.pulledImages = append(p.pulledImages, imageRef.SHA256)
+	}
+
+	return imageRef.SHA256, nil
+}
+
+func (p *fakePodman) Create(image string) (string, error) {
+	return "c" + image, nil
+}
+
+func (p *fakePodman) Copy(from, to string) (string, error) {
+	if strings.Contains(from, "manifest.yaml") {
+		err := ioutil.WriteFile(to, []byte(fakestrategy.FakeManifestYAML), os.ModePerm)
+		if err != nil {
+			return "", err
+		}
+	}
+	return "", nil
+}
+
+func (p *fakePodman) RemoveContainer(containerID string) error {
+	return nil
+}
+
+func (p *fakePodman) GetImageID(image string) (string, error) {
+	if strings.Contains(image, "broken") {
+		return "", fmt.Errorf("returning random error")
+	}
+	for _, pulledImage := range p.pulledImages {
+		if pulledImage == image {
+			return pulledImage, nil
+		}
+	}
+	return "", nil
+}
+
+func TestGetImage(t *testing.T) {
+	testCases := []struct {
+		name          string
+		imageRef      *model.ImageRef
+		imageSHA256   string
+		pullImage     bool
+		expectedError bool
+		expectedImage model.Image
+	}{
+		{
+			name:          "fail_noSHA256",
+			imageRef:      model.StringToImageRef("docker.io/test/test:latest"),
+			pullImage:     true,
+			expectedError: true,
+		},
+		{
+			name: "fail_cannotPull",
+			imageRef: &model.ImageRef{
+				SHA256: "broken6dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+			},
+			pullImage:     false,
+			expectedError: true,
+		},
+		{
+			name:          "pass_imageNotPresent",
+			imageRef:      model.StringToImageRef("docker.io/test/repo@sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3"),
+			pullImage:     false,
+			expectedError: false,
+			expectedImage: nil,
+		},
+		{
+			name:      "pass_imagePresent",
+			imageRef:  model.StringToImageRef("docker.io/test/test@sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3"),
+			pullImage: true,
+			expectedImage: &ossmImage{
+				imageID:  "41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+				sha256:   "sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+				manifest: &fakestrategy.FakeManifest,
+			},
+		},
+	}
+	fakePodman := &fakePodman{}
+	namespace := v1.Namespace{ObjectMeta: metav1.ObjectMeta{
+		Name: "test",
+	}}
+	clientSet := fake.NewSimpleClientset(&namespace)
+	strategy := &ossmPullStrategy{
+		client:    clientSet.ImageV1(),
+		namespace: namespace.Name,
+		podman:    fakePodman,
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			if tc.imageSHA256 != "" {
+				fakePodman.assignSHA256(tc.imageRef.String(), tc.imageSHA256)
+			}
+			if tc.pullImage {
+				strategy.podman.Pull(tc.imageRef.String())
+			}
+			image, err := strategy.GetImage(tc.imageRef)
+			if tc.expectedError {
+				if err == nil {
+					t.Errorf("Expected error but got nil")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("Expected no error but got %s", err)
+				}
+				if !cmp.Equal(image, tc.expectedImage, cmp.AllowUnexported(ossmImage{}), cmpopts.IgnoreInterfaces(struct{ podman.Podman }{})) {
+					t.Errorf(
+						"Image comparison failed: +got -want\n%v",
+						cmp.Diff(tc.expectedImage, image, cmp.AllowUnexported(ossmImage{}), cmpopts.IgnoreInterfaces(struct{ podman.Podman }{})),
+					)
+				}
+			}
+		})
+	}
+}
+
+func TestPullImage(t *testing.T) {
+	testCases := []struct {
+		name          string
+		imageStream   *imagev1.ImageStream
+		imageRef      *model.ImageRef
+		expectedError bool
+		expectedImage model.Image
+	}{
+		{
+			name: "pass_imageStreamPresent",
+			imageStream: &imagev1.ImageStream{
+				Spec: imagev1.ImageStreamSpec{
+					Tags: []imagev1.TagReference{
+						{
+							From: &v1.ObjectReference{
+								Name: "docker.io/test/test:latest",
+							},
+						},
+					},
+				},
+				Status: imagev1.ImageStreamStatus{
+					DockerImageRepository: "docker.io/test/test",
+					Tags: []imagev1.NamedTagEventList{
+						{
+							Conditions: []imagev1.TagEventCondition{
+								{
+									Status: v1.ConditionTrue,
+								},
+							},
+							Items: []imagev1.TagEvent{
+								{
+									Image: "sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+								},
+							},
+						},
+					},
+				},
+			},
+			imageRef:      model.StringToImageRef("docker.io/test/test:latest"),
+			expectedError: false,
+			expectedImage: &ossmImage{
+				imageID:  "41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+				sha256:   "sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+				manifest: &fakestrategy.FakeManifest,
+			},
+		},
+		{
+			name: "fail_statusConditionFalse",
+			imageStream: &imagev1.ImageStream{
+				Spec: imagev1.ImageStreamSpec{
+					Tags: []imagev1.TagReference{
+						{
+							From: &v1.ObjectReference{
+								Name: "docker.io/test/test:latest",
+							},
+						},
+					},
+				},
+				Status: imagev1.ImageStreamStatus{
+					DockerImageRepository: "docker.io/test/test",
+					Tags: []imagev1.NamedTagEventList{
+						{
+							Conditions: []imagev1.TagEventCondition{
+								{
+									Status: v1.ConditionFalse,
+								},
+							},
+							Items: []imagev1.TagEvent{
+								{
+									Image: "sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+								},
+							},
+						},
+					},
+				},
+			},
+			imageRef:      model.StringToImageRef("docker.io/test/test:latest"),
+			expectedError: true,
+		},
+		{
+			name: "fail_noStatus",
+			imageStream: &imagev1.ImageStream{
+				Spec: imagev1.ImageStreamSpec{
+					Tags: []imagev1.TagReference{
+						{
+							From: &v1.ObjectReference{
+								Name: "docker.io/test/test:latest",
+							},
+						},
+					},
+				},
+			},
+			imageRef:      model.StringToImageRef("docker.io/test/test:latest"),
+			expectedError: true,
+		},
+		{
+			name: "fail_noDockerImageRepository",
+			imageStream: &imagev1.ImageStream{
+				Spec: imagev1.ImageStreamSpec{
+					Tags: []imagev1.TagReference{
+						{
+							From: &v1.ObjectReference{
+								Name: "docker.io/test/test:latest",
+							},
+						},
+					},
+				},
+				Status: imagev1.ImageStreamStatus{
+					Tags: []imagev1.NamedTagEventList{
+						{
+							Conditions: []imagev1.TagEventCondition{
+								{
+									Status: v1.ConditionTrue,
+								},
+							},
+							Items: []imagev1.TagEvent{
+								{
+									Image: "sha256:41af286dc0b172ed2f1ca934fd2278de4a1192302ffa07087cea2682e7d372e3",
+								},
+							},
+						},
+					},
+				},
+			},
+			imageRef:      model.StringToImageRef("docker.io/test/test:latest"),
+			expectedError: true,
+		},
+	}
+	fakePodman := &fakePodman{}
+	namespace := v1.Namespace{ObjectMeta: metav1.ObjectMeta{
+		Name: "test",
+	}}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			var clientSet *fake.Clientset
+			if tc.imageStream != nil {
+				tc.imageStream.Name = getImageStreamName(tc.imageRef)
+				tc.imageStream.Namespace = namespace.Name
+				clientSet = fake.NewSimpleClientset(&namespace, tc.imageStream)
+			} else {
+				clientSet = fake.NewSimpleClientset(&namespace)
+			}
+
+			strategy := &ossmPullStrategy{
+				client:    clientSet.ImageV1(),
+				namespace: namespace.Name,
+				podman:    fakePodman,
+			}
+			image, err := strategy.PullImage(tc.imageRef)
+			if tc.expectedError {
+				if err == nil {
+					t.Error("Expected error but got nil")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("Expected no error but got %s", err)
+				}
+				if !cmp.Equal(image, tc.expectedImage, cmp.AllowUnexported(ossmImage{}), cmpopts.IgnoreInterfaces(struct{ podman.Podman }{})) {
+					t.Errorf(
+						"Image comparison failed: +got -want\n%v",
+						cmp.Diff(tc.expectedImage, image, cmp.AllowUnexported(ossmImage{}), cmpopts.IgnoreInterfaces(struct{ podman.Podman }{})),
+					)
+				}
+			}
+		})
+	}
+}
diff --git a/mec/pkg/server/httpserver.go b/mec/pkg/server/httpserver.go
new file mode 100644
index 0000000000..17006eaa2c
--- /dev/null
+++ b/mec/pkg/server/httpserver.go
@@ -0,0 +1,82 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"os"
+	"path"
+	"path/filepath"
+
+	"github.com/google/uuid"
+
+	"istio.io/pkg/log"
+)
+
+type HTTPServer struct {
+	serveDirectory string
+	mux            *http.ServeMux
+	srv            *http.Server
+}
+
+func (s *HTTPServer) handleRequest(res http.ResponseWriter, req *http.Request) {
+	uuid, err := uuid.Parse(filepath.Base(req.URL.Path))
+	if err != nil {
+		log.Errorf("Could not parse request path '%s' as UUID: %s", req.URL.Path, err)
+		res.WriteHeader(404)
+		return
+	}
+	filename := path.Join(s.serveDirectory, uuid.String())
+	if _, err := os.Stat(filename); err != nil {
+
+		log.Errorf("Failed to open file %s: %s", filename, err)
+		res.WriteHeader(404)
+		return
+	}
+	data, err := ioutil.ReadFile(filename)
+	if err != nil {
+		log.Errorf("Failed to read file %s: %s", filename, err)
+		res.WriteHeader(404)
+		return
+	}
+	res.WriteHeader(200)
+	if _, err := res.Write(data); err != nil {
+		log.Errorf("error writing response: %s", err)
+	}
+}
+
+func (s *HTTPServer) Start(stopChan <-chan struct{}) {
+	go func() {
+		if err := s.srv.ListenAndServe(); err != nil {
+			log.Errorf("error listening and serving: %s", err)
+		}
+	}()
+}
+
+func NewHTTPServer(port uint, serveDirectory string) *HTTPServer {
+	s := &HTTPServer{
+		serveDirectory: serveDirectory,
+	}
+	s.mux = http.NewServeMux()
+	s.mux.HandleFunc("/", s.handleRequest)
+
+	s.srv = &http.Server{
+		Addr:    fmt.Sprintf(":%d", port),
+		Handler: s.mux,
+	}
+	return s
+}
diff --git a/mec/pkg/server/httpserver_test.go b/mec/pkg/server/httpserver_test.go
new file mode 100644
index 0000000000..003248d199
--- /dev/null
+++ b/mec/pkg/server/httpserver_test.go
@@ -0,0 +1,124 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"io/ioutil"
+	"net/http"
+	"os"
+	"path"
+	"path/filepath"
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+)
+
+func TestHTTPServer(t *testing.T) {
+	testCases := []struct {
+		name           string
+		requestPath    string
+		filename       string
+		fileContent    []byte
+		expectedStatus int
+	}{
+		{
+			name:           "fail_validUUIDNotFound",
+			requestPath:    "71e7c506-24df-11eb-89f5-482ae3492105",
+			expectedStatus: 404,
+		},
+		{
+			name:           "pass_validUUIDFound",
+			requestPath:    "72e7c506-24df-11eb-89f5-482ae3492105",
+			fileContent:    []byte("all good"),
+			expectedStatus: 200,
+		},
+		{
+			name:           "fail_invalidUUID",
+			requestPath:    "73e7c50624df11eb89f5482ae3492105",
+			expectedStatus: 404,
+		},
+		{
+			name:           "fail_ignore_directories",
+			requestPath:    "test/74e7c506-24df-11eb-89f5-482ae3492105",
+			filename:       "test/74e7c506-24df-11eb-89f5-482ae3492105",
+			expectedStatus: 404,
+		},
+		{
+			name:           "pass_ignore_directories",
+			requestPath:    "test/asd/75e7c506-24df-11eb-89f5-482ae3492105",
+			filename:       "75e7c506-24df-11eb-89f5-482ae3492105",
+			fileContent:    []byte("test"),
+			expectedStatus: 200,
+		},
+	}
+	tmpDir, err := ioutil.TempDir("", "servertest")
+	if err != nil {
+		t.Fatalf("failed to create temp dir: %s", err)
+	}
+	defer func() {
+		err = os.RemoveAll(tmpDir)
+		if err != nil {
+			t.Fatalf("Failed to remove temp directory %s", tmpDir)
+		}
+	}()
+
+	server := NewHTTPServer(50505, tmpDir)
+	baseURL := "http://127.0.0.1:50505/"
+	stopChan := make(<-chan struct{})
+	server.Start(stopChan)
+	// wait a bit until the server is up
+	time.Sleep(time.Millisecond * 250)
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			filename := path.Join(tmpDir, tc.filename)
+			if tc.fileContent != nil {
+				if tc.filename == "" {
+					filename = path.Join(tmpDir, tc.requestPath)
+				}
+				if _, err := os.Stat(filepath.Dir(filename)); err != nil {
+					t.Logf("Directory %s does not exist, creating", filepath.Dir(filename))
+					os.MkdirAll(filepath.Dir(filename), os.ModePerm)
+				}
+				t.Logf("Writing to file %s", filename)
+				err := ioutil.WriteFile(filename, tc.fileContent, os.ModePerm)
+				if err != nil {
+					t.Errorf("%s", err)
+				}
+			}
+
+			url := baseURL + tc.requestPath
+			t.Logf("Sending GET request to %s", url)
+			resp, err := http.Get(url)
+			if err != nil {
+				t.Fatalf("failed to GET %s: %s", url, err)
+			}
+			if resp != nil && resp.StatusCode != tc.expectedStatus {
+				t.Fatalf("expected StatusCode %d but got %d", tc.expectedStatus, resp.StatusCode)
+			}
+			if resp != nil && tc.fileContent != nil {
+				os.Remove(filename)
+				defer resp.Body.Close()
+				body, err := ioutil.ReadAll(resp.Body)
+				if err != nil {
+					t.Fatalf("failed to read body: %s", err)
+				}
+				if !cmp.Equal(body, tc.fileContent) {
+					t.Fatalf("response didn't match. Expected %v but got %v", tc.fileContent, body)
+				}
+			}
+		})
+	}
+}
diff --git a/mec/pkg/server/worker.go b/mec/pkg/server/worker.go
new file mode 100644
index 0000000000..793f156fa0
--- /dev/null
+++ b/mec/pkg/server/worker.go
@@ -0,0 +1,298 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"context"
+	"crypto/sha256"
+	"fmt"
+	"io"
+	"net/url"
+	"os"
+	"path"
+	"strings"
+	"sync"
+
+	"github.com/google/uuid"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/rest"
+
+	"istio.io/istio/mec/pkg/model"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	v1alpha1client "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
+	"istio.io/pkg/log"
+)
+
+const (
+	ExtensionEventOperationAdd    = 0
+	ExtensionEventOperationDelete = 1
+	ExtensionEventOperationUpdate = 2
+)
+
+type ExtensionEvent struct {
+	Extension *v1alpha1.ServiceMeshExtension
+	Operation ExtensionEventOperation
+}
+
+type ExtensionEventOperation int
+
+type Worker struct {
+	baseURL        string
+	serveDirectory string
+
+	pullStrategy model.ImagePullStrategy
+
+	client       v1alpha1client.ServicemeshV1alpha1Interface
+	stopChan     <-chan struct{}
+	resultChan   chan workerResult
+	Queue        chan ExtensionEvent
+	enableLogger bool
+
+	mut sync.Mutex
+}
+
+type workerResult struct {
+	successful bool
+	errors     []error
+	messages   []string
+}
+
+func (r *workerResult) Fail() {
+	r.successful = false
+}
+
+func (r *workerResult) AddMessage(msg string) {
+	r.messages = append(r.messages, msg)
+}
+
+func (r *workerResult) AddError(err error) {
+	r.errors = append(r.errors, err)
+}
+
+func NewWorker(config *rest.Config, pullStrategy model.ImagePullStrategy, baseURL, serveDirectory string) (*Worker, error) {
+	client, err := v1alpha1client.NewForConfig(config)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create client from config: %v", err)
+	}
+
+	return &Worker{
+		client:         client,
+		Queue:          make(chan ExtensionEvent, 100),
+		resultChan:     make(chan workerResult, 100),
+		pullStrategy:   pullStrategy,
+		baseURL:        baseURL,
+		serveDirectory: serveDirectory,
+	}, nil
+}
+
+func (w *Worker) processEvent(event ExtensionEvent) {
+	result := workerResult{
+		errors:     []error{},
+		messages:   []string{},
+		successful: true,
+	}
+	extension := event.Extension
+	result.AddMessage("Processing " + extension.Namespace + "/" + extension.Name)
+
+	if event.Operation == ExtensionEventOperationDelete {
+		if len(extension.Status.Deployment.URL) > len(w.baseURL) {
+			id := extension.Status.Deployment.URL[len(w.baseURL):]
+			filename := path.Join(w.serveDirectory, id)
+			os.Remove(filename)
+		}
+		return
+	}
+	imageRef := model.StringToImageRef(extension.Spec.Image)
+
+	if imageRef == nil {
+		result.AddError(fmt.Errorf("failed to parse spec.image: '%s'", extension.Spec.Image))
+		result.Fail()
+		w.resultChan <- result
+		return
+	}
+
+	var img model.Image
+	var err error
+	if imageRef.SHA256 != "" {
+		img, err = w.pullStrategy.GetImage(imageRef)
+		if err != nil {
+			result.AddError(fmt.Errorf("failed to check whether image is already present: %s", err))
+		}
+	}
+	if img == nil {
+		result.AddMessage(fmt.Sprintf("Image %s not present. Pulling", imageRef.String()))
+		img, err = w.pullStrategy.PullImage(imageRef)
+		if err != nil {
+			result.AddError(fmt.Errorf("failed to pull image %s: %v", imageRef.String(), err))
+			result.Fail()
+			w.resultChan <- result
+			return
+		}
+	}
+	var id string
+	containerImageChanged := false
+
+	if strings.HasPrefix(extension.Status.Deployment.URL, w.baseURL) {
+		url, err := url.Parse(extension.Status.Deployment.URL)
+		if err != nil {
+			result.AddError(fmt.Errorf("failed to parse status.deployment.url: %s", err))
+			result.Fail()
+			w.resultChan <- result
+		}
+		id = path.Base(url.Path)
+	}
+
+	if img.SHA256() != extension.Status.Deployment.ContainerSHA256 {
+		// if container sha changed, re-generate UUID
+		containerImageChanged = true
+		if id != "" {
+			err := os.Remove(path.Join(w.serveDirectory, id))
+			if err != nil {
+				result.AddError(fmt.Errorf("failed to delete existing wasm module: %s", err))
+			}
+		}
+
+		wasmUUID, err := uuid.NewRandom()
+		if err != nil {
+			result.AddError(fmt.Errorf("failed to generate new UUID: %v", err))
+			result.Fail()
+			w.resultChan <- result
+			return
+		}
+		id = wasmUUID.String()
+	}
+
+	filename := path.Join(w.serveDirectory, id)
+	if _, err := os.Stat(filename); os.IsNotExist(err) {
+		err = img.CopyWasmModule(filename)
+		if err != nil {
+			result.AddError(fmt.Errorf("failed to extract wasm module: %v", err))
+			result.Fail()
+			w.resultChan <- result
+			return
+		}
+	}
+
+	sha, err := generateSHA256(filename)
+	if err != nil {
+		result.AddError(fmt.Errorf("failed to generate sha256 of wasm module: %v", err))
+		result.Fail()
+		w.resultChan <- result
+		return
+	}
+	result.AddMessage(fmt.Sprintf("WASM module SHA256 is %s", sha))
+
+	filePath, err := url.Parse(id)
+	if err != nil {
+		result.AddError(fmt.Errorf("failed to parse new UUID '%s' as URL path: %s", id, err))
+		result.Fail()
+		w.resultChan <- result
+
+	}
+	baseURL, err := url.Parse(w.baseURL)
+	if err != nil {
+		result.AddError(fmt.Errorf("failed to parse baseURL: %s", err))
+		result.Fail()
+		w.resultChan <- result
+	}
+
+	extension.Status.Deployment.SHA256 = sha
+	extension.Status.Deployment.ContainerSHA256 = img.SHA256()
+	extension.Status.Deployment.URL = baseURL.ResolveReference(filePath).String()
+	extension.Status.Deployment.Ready = true
+
+	manifest := img.GetManifest()
+
+	// apply defaults from manifest for phase and priority
+	if extension.Spec.Phase == nil {
+		extension.Status.Phase = manifest.Phase
+	} else {
+		extension.Status.Phase = *extension.Spec.Phase
+	}
+	if extension.Spec.Priority == nil {
+		extension.Status.Priority = manifest.Priority
+	} else {
+		extension.Status.Priority = *extension.Spec.Priority
+	}
+
+	if !containerImageChanged && extension.Generation > 0 && extension.Status.ObservedGeneration == extension.Generation {
+		result.AddMessage("Skipping status update")
+		w.resultChan <- result
+		return
+	}
+	extension.Status.ObservedGeneration = extension.Generation
+	_, err = w.client.ServiceMeshExtensions(extension.Namespace).UpdateStatus(context.TODO(), extension, v1.UpdateOptions{})
+	if err != nil {
+		result.AddError(fmt.Errorf("failed to update status of extension: %v", err))
+		result.Fail()
+	}
+	w.resultChan <- result
+}
+
+func (w *Worker) Start(stopChan <-chan struct{}) {
+	w.mut.Lock()
+	defer w.mut.Unlock()
+
+	if w.stopChan != nil {
+		return
+	}
+	w.stopChan = stopChan
+	log.Info("Starting worker")
+	go func() {
+		for {
+			select {
+			case event := <-w.Queue:
+				w.processEvent(event)
+			case <-w.stopChan:
+				log.Info("Stopping worker")
+				return
+			}
+		}
+	}()
+	if w.enableLogger {
+		go func() {
+			select {
+			case result := <-w.resultChan:
+				for _, msg := range result.messages {
+					log.Info(msg)
+				}
+				for _, err := range result.errors {
+					if !result.successful {
+						log.Errorf("%s", err)
+					} else {
+						log.Warnf("%s", err)
+					}
+				}
+			case <-w.stopChan:
+				return
+			}
+		}()
+	}
+}
+
+func generateSHA256(filename string) (string, error) {
+	f, err := os.Open(filename)
+	if err != nil {
+		return "", err
+	}
+	defer f.Close()
+
+	h := sha256.New()
+	if _, err := io.Copy(h, f); err != nil {
+		return "", err
+	}
+
+	return fmt.Sprintf("%x", h.Sum(nil)), nil
+}
diff --git a/mec/pkg/server/worker_test.go b/mec/pkg/server/worker_test.go
new file mode 100644
index 0000000000..3d4f0ba0e6
--- /dev/null
+++ b/mec/pkg/server/worker_test.go
@@ -0,0 +1,283 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package server
+
+import (
+	"context"
+	"fmt"
+	"io/ioutil"
+	"net/url"
+	"os"
+	"strings"
+	"sync"
+	"testing"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
+	"github.com/google/uuid"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	fakestrategy "istio.io/istio/mec/pkg/pullstrategy/fake"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake"
+	"istio.io/pkg/log"
+)
+
+const (
+	baseURL = "http://localhost:8080"
+)
+
+var (
+	oneHundred = 100
+	twoHundred = 200
+)
+
+func TestWorker(t *testing.T) {
+	testCases := []struct {
+		name           string
+		events         []ExtensionEvent
+		extension      v1alpha1.ServiceMeshExtension
+		expectedStatus v1alpha1.ServiceMeshExtensionStatus
+		expectedError  bool
+	}{
+		{
+			name: "invalid_resource",
+			extension: v1alpha1.ServiceMeshExtension{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:       "test",
+					Namespace:  "test",
+					Generation: 1,
+				},
+			},
+			expectedStatus: v1alpha1.ServiceMeshExtensionStatus{},
+			expectedError:  true,
+		},
+		{
+			name: "valid_resource",
+			extension: v1alpha1.ServiceMeshExtension{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:       "test",
+					Namespace:  "test",
+					Generation: 1,
+				},
+				Spec: v1alpha1.ServiceMeshExtensionSpec{
+					Image: "docker.io/test/test:latest",
+				},
+			},
+			expectedStatus: v1alpha1.ServiceMeshExtensionStatus{
+				Phase:    fakestrategy.FakeManifest.Phase,
+				Priority: fakestrategy.FakeManifest.Priority,
+				Deployment: v1alpha1.DeploymentStatus{
+					Ready:           true,
+					ContainerSHA256: fakestrategy.FakeContainerSHA256,
+					SHA256:          fakestrategy.FakeModuleSHA256,
+				},
+				ObservedGeneration: 1,
+			},
+		},
+		{
+			name: "valid_resource_update_module",
+			extension: v1alpha1.ServiceMeshExtension{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:       "test",
+					Namespace:  "test",
+					Generation: 1,
+				},
+				Spec: v1alpha1.ServiceMeshExtensionSpec{
+					Image: "docker.io/test/test:latest",
+				},
+			},
+			events: []ExtensionEvent{
+				{
+					Extension: &v1alpha1.ServiceMeshExtension{
+						ObjectMeta: metav1.ObjectMeta{
+							Name:       "test",
+							Namespace:  "test",
+							Generation: 2,
+						},
+						Spec: v1alpha1.ServiceMeshExtensionSpec{
+							Image: "docker.io/other/test:latest",
+						},
+					},
+					Operation: ExtensionEventOperationUpdate,
+				},
+			},
+			expectedStatus: v1alpha1.ServiceMeshExtensionStatus{
+				Phase:    fakestrategy.FakeManifest2.Phase,
+				Priority: fakestrategy.FakeManifest2.Priority,
+				Deployment: v1alpha1.DeploymentStatus{
+					Ready:           true,
+					ContainerSHA256: fakestrategy.FakeContainer2SHA256,
+					SHA256:          fakestrategy.FakeModule2SHA256,
+				},
+				ObservedGeneration: 2,
+			},
+		},
+		{
+			name: "valid_resource_update_priority",
+			extension: v1alpha1.ServiceMeshExtension{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:       "test",
+					Namespace:  "test",
+					Generation: 1,
+				},
+				Spec: v1alpha1.ServiceMeshExtensionSpec{
+					Image: "docker.io/test/test:latest",
+				},
+			},
+			events: []ExtensionEvent{
+				{
+					Extension: &v1alpha1.ServiceMeshExtension{
+						ObjectMeta: metav1.ObjectMeta{
+							Name:       "test",
+							Namespace:  "test",
+							Generation: 3,
+						},
+						Spec: v1alpha1.ServiceMeshExtensionSpec{
+							Image:    "docker.io/test/test:latest",
+							Priority: &oneHundred,
+						},
+					},
+					Operation: ExtensionEventOperationUpdate,
+				},
+				{
+					Extension: &v1alpha1.ServiceMeshExtension{
+						ObjectMeta: metav1.ObjectMeta{
+							Name:       "test",
+							Namespace:  "test",
+							Generation: 4,
+						},
+						Spec: v1alpha1.ServiceMeshExtensionSpec{
+							Image:    "docker.io/test/test:latest",
+							Priority: &twoHundred,
+						},
+					},
+					Operation: ExtensionEventOperationUpdate,
+				},
+			},
+			expectedStatus: v1alpha1.ServiceMeshExtensionStatus{
+				Phase:    fakestrategy.FakeManifest.Phase,
+				Priority: 200,
+				Deployment: v1alpha1.DeploymentStatus{
+					Ready:           true,
+					ContainerSHA256: fakestrategy.FakeContainerSHA256,
+					SHA256:          fakestrategy.FakeModuleSHA256,
+				},
+				ObservedGeneration: 4,
+			},
+		},
+	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			clientset := fake.NewSimpleClientset()
+			tmpDir, err := ioutil.TempDir("", "workertest")
+			if err != nil {
+				t.Fatalf("failed to create temp dir: %s", err)
+			}
+			defer func() {
+				err = os.RemoveAll(tmpDir)
+				if err != nil {
+					t.Fatalf("Failed to remove temp directory %s", tmpDir)
+				}
+			}()
+			w := createWorker(tmpDir, clientset)
+			stopChan := make(chan struct{})
+			w.Start(stopChan)
+			w.client.ServiceMeshExtensions(tc.extension.Namespace).Create(context.TODO(), &tc.extension, metav1.CreateOptions{})
+			w.Queue <- ExtensionEvent{
+				Extension: &tc.extension,
+				Operation: ExtensionEventOperationAdd,
+			}
+			res := <-w.resultChan
+			for _, msg := range res.messages {
+				log.Info(msg)
+			}
+			for _, err := range res.errors {
+				if !res.successful && !tc.expectedError {
+					log.Fatalf("expected no error but got: %s", err)
+				} else {
+					log.Infof("%s", err)
+				}
+			}
+
+			for _, event := range tc.events {
+				ext := event.Extension.DeepCopy()
+				updatedExtension, err := w.client.ServiceMeshExtensions(tc.extension.Namespace).Get(context.TODO(), tc.extension.Name, metav1.GetOptions{})
+				if err != nil {
+					t.Fatalf("failed to Get() extension: %s", err)
+				}
+				ext.Status = *updatedExtension.Status.DeepCopy()
+				switch event.Operation {
+				case ExtensionEventOperationAdd:
+					w.client.ServiceMeshExtensions(event.Extension.Namespace).Create(context.TODO(), ext, metav1.CreateOptions{})
+				case ExtensionEventOperationUpdate:
+					w.client.ServiceMeshExtensions(event.Extension.Namespace).Update(context.TODO(), ext, metav1.UpdateOptions{})
+				case ExtensionEventOperationDelete:
+					w.client.ServiceMeshExtensions(event.Extension.Namespace).Delete(context.TODO(), ext.Name, metav1.DeleteOptions{})
+				}
+				w.Queue <- ExtensionEvent{
+					Extension: ext,
+					Operation: event.Operation,
+				}
+				res := <-w.resultChan
+				for _, msg := range res.messages {
+					log.Info(msg)
+				}
+				for _, err := range res.errors {
+					if !res.successful && !tc.expectedError {
+						log.Fatalf("expected no error but got: %s", err)
+					} else {
+						log.Infof("%s", err)
+					}
+				}
+			}
+			stopChan <- struct{}{}
+			updatedExtension, err := w.client.ServiceMeshExtensions(tc.extension.Namespace).Get(context.TODO(), tc.extension.Name, metav1.GetOptions{})
+			if err != nil {
+				t.Fatalf("failed to Get() extension: %s", err)
+			}
+			// ignore Deployment.URL because it contains a random UUID
+			if !cmp.Equal(tc.expectedStatus, updatedExtension.Status, cmpopts.IgnoreFields(v1alpha1.DeploymentStatus{}, "URL")) {
+				t.Fatalf("comparison failed -got +want: %s", cmp.Diff(tc.expectedStatus, updatedExtension.Status, cmpopts.IgnoreFields(v1alpha1.DeploymentStatus{}, "URL")))
+			}
+			if !cmp.Equal(tc.expectedStatus, v1alpha1.ServiceMeshExtensionStatus{}) {
+				// validate URL
+				url, err := url.Parse(updatedExtension.Status.Deployment.URL)
+				if err != nil {
+					t.Fatalf("failed to parse baseURL: %s", err)
+				}
+				if fmt.Sprintf("%s://%s", url.Scheme, url.Host) != baseURL {
+					t.Fatalf("generated base URL path is invalid: %s", updatedExtension.Status.Deployment.URL)
+				}
+				if _, err := uuid.Parse(strings.TrimLeft(url.Path, "/")); err != nil {
+					t.Fatalf("generated URL path is invalid: %s", updatedExtension.Status.Deployment.URL)
+				}
+			}
+		})
+	}
+}
+
+func createWorker(tmpDir string, clientset *fake.Clientset) *Worker {
+	return &Worker{
+		baseURL:        baseURL,
+		client:         clientset.ServicemeshV1alpha1(),
+		mut:            sync.Mutex{},
+		pullStrategy:   &fakestrategy.PullStrategy{},
+		serveDirectory: tmpDir,
+		Queue:          make(chan ExtensionEvent),
+		resultChan:     make(chan workerResult, 100),
+		enableLogger:   false,
+	}
+}
diff --git a/pilot/cmd/pilot-discovery/app/cmd.go b/pilot/cmd/pilot-discovery/app/cmd.go
index 3b5c9e5792..d029591289 100644
--- a/pilot/cmd/pilot-discovery/app/cmd.go
+++ b/pilot/cmd/pilot-discovery/app/cmd.go
@@ -27,6 +27,7 @@
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pkg/cmd"
 	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/servicemesh/extension"
 	"istio.io/pkg/collateral"
 	"istio.io/pkg/ctrlz"
 	"istio.io/pkg/log"
@@ -158,6 +159,8 @@ func addFlags(c *cobra.Command) {
 		"Whether to prevent istiod watching Node objects")
 	c.PersistentFlags().BoolVar(&serverArgs.RegistryOptions.KubeOptions.EnableIngressClassName, "enableIngressClassName",
 		true, "Whether support processing Ingress resources that use the new ingressClassName field in their spec")
+	c.PersistentFlags().StringVar(&extension.CacheCluster, "cacheCluster", extension.DefaultCacheCluster,
+		"Cluster pointing to Extension Cache component. This is used in proxies to retrieve WASM filters.")
 
 	// using address, so it can be configured as localhost:.. (possibly UDS in future)
 	c.PersistentFlags().StringVar(&serverArgs.ServerOptions.HTTPAddr, "httpAddr", ":8080",
diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 2b96cf6115..e9ef700b51 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -30,6 +30,7 @@
 
 	"github.com/fsnotify/fsnotify"
 	prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
+	"github.com/hashicorp/go-multierror"
 	prom "github.com/prometheus/client_golang/prometheus"
 	"golang.org/x/net/http2"
 	"golang.org/x/net/http2/h2c"
@@ -68,6 +69,7 @@
 	"istio.io/istio/pkg/kube/inject"
 	"istio.io/istio/pkg/kube/multicluster"
 	"istio.io/istio/pkg/security"
+	"istio.io/istio/pkg/servicemesh/controller/extension"
 	"istio.io/istio/pkg/spiffe"
 	"istio.io/istio/security/pkg/k8s/chiron"
 	"istio.io/istio/security/pkg/pki/ca"
@@ -235,6 +237,12 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {
 		return nil, fmt.Errorf("error initializing kube client: %v", err)
 	}
 
+	if features.EnableMaistraExtensionSupport {
+		if err := s.initExtensionController(args); err != nil {
+			return nil, fmt.Errorf("extension client: %v", err)
+		}
+	}
+
 	s.initMeshConfiguration(args, s.fileWatcher)
 	spiffe.SetTrustDomain(s.environment.Mesh().GetTrustDomain())
 
@@ -622,6 +630,26 @@ func (s *Server) istiodReadyHandler(w http.ResponseWriter, _ *http.Request) {
 	w.WriteHeader(http.StatusOK)
 }
 
+// initExtensionController initializes the ServiceMeshExtension controller.
+func (s *Server) initExtensionController(args *PilotArgs) error {
+	if hasKubeRegistry(args.RegistryOptions.Registries) && args.RegistryOptions.FileDir == "" {
+		mrc := s.kubeClient.GetMemberRoll()
+		ec, err := extension.NewControllerFromConfigFile(
+			args.RegistryOptions.KubeConfig,
+			strings.Split(args.RegistryOptions.KubeOptions.WatchedNamespaces, ","),
+			mrc,
+			args.RegistryOptions.KubeOptions.ResyncPeriod,
+		)
+		if err != nil {
+			return multierror.Prefix(err, "Could not create ExtensionController.")
+		}
+		s.environment.ExtensionStore = ec
+		s.environment.ExtensionStore.Start(make(chan struct{}))
+	}
+
+	return nil
+}
+
 // initIstiodAdminServer initializes monitoring, debug and readiness end points.
 func (s *Server) initIstiodAdminServer(args *PilotArgs, whc func() map[string]string) error {
 	s.httpServer = &http.Server{
diff --git a/pilot/pkg/features/pilot.go b/pilot/pkg/features/pilot.go
index 6186fafae2..8a99e863ce 100644
--- a/pilot/pkg/features/pilot.go
+++ b/pilot/pkg/features/pilot.go
@@ -574,6 +574,9 @@
 				"`clientKey`, `clientCertificate`, `tokenFile`, and `exec`.").Get()
 		return sets.NewSet(strings.Split(v, ",")...)
 	}()
+
+	EnableMaistraExtensionSupport = env.RegisterBoolVar("ENABLE_MAISTRA_EXTENSIONS", false,
+		"If enabled, pilot, will watch ServiceMeshExtension resources and apply them to filter chains of its proxies").Get()
 )
 
 // UnsafeFeaturesEnabled returns true if any unsafe features are enabled.
diff --git a/pilot/pkg/model/context.go b/pilot/pkg/model/context.go
index 7b8cdfb851..ef9ee75d2a 100644
--- a/pilot/pkg/model/context.go
+++ b/pilot/pkg/model/context.go
@@ -43,6 +43,7 @@
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/mesh"
 	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/servicemesh/controller/extension"
 	"istio.io/istio/pkg/spiffe"
 	"istio.io/istio/pkg/util/identifier"
 	"istio.io/istio/pkg/util/protomarshal"
@@ -63,6 +64,9 @@ type Environment struct {
 	// Config interface for listing routing rules
 	IstioConfigStore
 
+	// Config interface for listing maistra-specific configuration
+	ExtensionStore extension.Controller
+
 	// Watcher is the watcher for the mesh config (to be merged into the config store)
 	mesh.Watcher
 
diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 846e9762ba..62b4f4e31d 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -40,6 +40,8 @@
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	maistramodel "istio.io/istio/pkg/servicemesh/model"
 	"istio.io/pkg/monitoring"
 )
 
@@ -209,6 +211,9 @@ type PushContext struct {
 	// wasm plugins for each namespace including global config namespace
 	wasmPluginsByNamespace map[string][]*WasmPluginWrapper
 
+	// extensions for each namespace including global config namespace
+	extensionsByNamespace map[string][]*maistramodel.ExtensionWrapper
+
 	// AuthnPolicies contains Authn policies by namespace.
 	AuthnPolicies *AuthenticationPolicies `json:"-"`
 
@@ -1135,6 +1140,12 @@ func (ps *PushContext) createNewContext(env *Environment) error {
 		return err
 	}
 
+	if features.EnableMaistraExtensionSupport {
+		if err := ps.initExtensions(env); err != nil {
+			return err
+		}
+	}
+
 	if err := ps.initGateways(env); err != nil {
 		return err
 	}
@@ -1260,6 +1271,8 @@ func (ps *PushContext) updateContext(
 		ps.envoyFiltersByNamespace = oldPushContext.envoyFiltersByNamespace
 	}
 
+	ps.extensionsByNamespace = oldPushContext.extensionsByNamespace
+
 	if gatewayChanged {
 		if err := ps.initGateways(env); err != nil {
 			return err
@@ -1876,6 +1889,78 @@ func (ps *PushContext) getMatchedEnvoyFilters(proxy *Proxy, namespaces string) [
 	return matchedEnvoyFilters
 }
 
+// pre computes extensions per namespace
+func (ps *PushContext) initExtensions(env *Environment) error {
+	if env == nil || env.ExtensionStore == nil {
+		return nil
+	}
+	ps.extensionsByNamespace = map[string][]*maistramodel.ExtensionWrapper{}
+	for _, extension := range env.ExtensionStore.GetExtensions() {
+		if ps.extensionsByNamespace[extension.Namespace] == nil {
+			ps.extensionsByNamespace[extension.Namespace] = []*maistramodel.ExtensionWrapper{}
+		}
+		if extension.Status.Deployment.Ready {
+			wrapper := maistramodel.ToWrapper(extension)
+			ps.extensionsByNamespace[extension.Namespace] = append(ps.extensionsByNamespace[extension.Namespace], wrapper)
+		}
+	}
+
+	return nil
+}
+
+// Extensions return the merged ExtensionWrappers of a proxy
+func (ps *PushContext) Extensions(proxy *Proxy) map[v1alpha1.FilterPhase][]*maistramodel.ExtensionWrapper {
+	if proxy == nil {
+		return nil
+	}
+	matchedExtensions := make(map[v1alpha1.FilterPhase][]*maistramodel.ExtensionWrapper)
+	// First get all the extension configs from the config root namespace
+	// and then add the ones from proxy's own namespace
+	if ps.Mesh.RootNamespace != "" {
+		// if there is no workload selector, the config applies to all workloads
+		// if there is a workload selector, check for matching workload labels
+		for _, ext := range ps.extensionsByNamespace[ps.Mesh.RootNamespace] {
+			var workloadLabels labels.Collection
+			if proxy.Metadata != nil && len(proxy.Metadata.Labels) > 0 {
+				workloadLabels = labels.Collection{proxy.Metadata.Labels}
+			}
+			if ext.WorkloadSelector == nil || workloadLabels.IsSupersetOf(ext.WorkloadSelector) {
+				matchedExtensions[ext.Phase] = append(matchedExtensions[ext.Phase], ext)
+			}
+		}
+	}
+
+	// To prevent duplicate extensions in case root namespace equals proxy's namespace
+	if proxy.ConfigNamespace != ps.Mesh.RootNamespace {
+		for _, ext := range ps.extensionsByNamespace[proxy.ConfigNamespace] {
+			var workloadLabels labels.Collection
+			if proxy.Metadata != nil && len(proxy.Metadata.Labels) > 0 {
+				workloadLabels = labels.Collection{proxy.Metadata.Labels}
+			}
+			if ext.WorkloadSelector == nil || workloadLabels.IsSupersetOf(ext.WorkloadSelector) {
+				matchedExtensions[ext.Phase] = append(matchedExtensions[ext.Phase], ext)
+			}
+		}
+	}
+
+	// sort slices by priority
+	for i, slice := range matchedExtensions {
+		sort.SliceStable(slice, func(i, j int) bool {
+			// if priority is the same, in order to still have a
+			// deterministic ordering, we sort based on name + image
+			if slice[i].Priority == slice[j].Priority {
+				in := slice[i].Image + slice[i].Image
+				jn := slice[j].Image + slice[i].Image
+				return in < jn
+			}
+			return slice[i].Priority > slice[j].Priority
+		})
+		matchedExtensions[i] = slice
+	}
+
+	return matchedExtensions
+}
+
 // pre computes gateways per namespace
 func (ps *PushContext) initGateways(env *Environment) error {
 	gatewayConfigs, err := env.List(gvk.Gateway, NamespaceAll)
diff --git a/pilot/pkg/model/push_context_test.go b/pilot/pkg/model/push_context_test.go
index 427607cbda..19aaf018c9 100644
--- a/pilot/pkg/model/push_context_test.go
+++ b/pilot/pkg/model/push_context_test.go
@@ -43,6 +43,8 @@
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/model"
 )
 
 func TestMergeUpdateRequest(t *testing.T) {
@@ -925,6 +927,124 @@ func TestInitPushContext(t *testing.T) {
 	}
 }
 
+func TestExtensions(t *testing.T) {
+	extensionsTestNamespace := []*model.ExtensionWrapper{
+		{
+			Name:             "v1",
+			Phase:            v1alpha1.FilterPhasePreAuthN,
+			WorkloadSelector: map[string]string{"app": "v1"},
+		},
+		{
+			Name:             "v2",
+			Phase:            v1alpha1.FilterPhasePostAuthN,
+			WorkloadSelector: map[string]string{"app": "v2"},
+		},
+	}
+	extensionsRootNamespace := []*model.ExtensionWrapper{
+		{
+			Name:             "globalv1",
+			Phase:            v1alpha1.FilterPhasePreAuthZ,
+			WorkloadSelector: map[string]string{"app": "v1"},
+		},
+		{
+			Name:             "globalv3",
+			Phase:            v1alpha1.FilterPhasePostAuthZ,
+			WorkloadSelector: map[string]string{"app": "v3"},
+		},
+	}
+
+	push := &PushContext{
+		Mesh: &meshconfig.MeshConfig{
+			RootNamespace: "istio-system",
+		},
+		extensionsByNamespace: map[string][]*model.ExtensionWrapper{
+			"istio-system": extensionsRootNamespace,
+			"test-ns":      extensionsTestNamespace,
+		},
+	}
+
+	cases := []struct {
+		name               string
+		proxy              *Proxy
+		expectedExtensions map[v1alpha1.FilterPhase][]*model.ExtensionWrapper
+	}{
+		{
+			name: "proxy matches two extensions",
+			proxy: &Proxy{
+				Metadata:        &NodeMetadata{IstioVersion: "1.4.0", Labels: map[string]string{"app": "v1"}},
+				ConfigNamespace: "test-ns",
+			},
+			expectedExtensions: map[v1alpha1.FilterPhase][]*model.ExtensionWrapper{
+				v1alpha1.FilterPhasePreAuthN: {
+					{
+						Name:             "v1",
+						Phase:            v1alpha1.FilterPhasePreAuthN,
+						WorkloadSelector: map[string]string{"app": "v1"},
+					},
+				},
+				v1alpha1.FilterPhasePreAuthZ: {
+					{
+						Name:             "globalv1",
+						Phase:            v1alpha1.FilterPhasePreAuthZ,
+						WorkloadSelector: map[string]string{"app": "v1"},
+					},
+				},
+			},
+		},
+		{
+			name: "proxy in root namespace matches an extension",
+			proxy: &Proxy{
+				Metadata:        &NodeMetadata{IstioVersion: "1.4.0", Labels: map[string]string{"app": "v3"}},
+				ConfigNamespace: "istio-system",
+			},
+			expectedExtensions: map[v1alpha1.FilterPhase][]*model.ExtensionWrapper{
+				v1alpha1.FilterPhasePostAuthZ: {
+					{
+						Name:             "globalv3",
+						Phase:            v1alpha1.FilterPhasePostAuthZ,
+						WorkloadSelector: map[string]string{"app": "v3"},
+					},
+				},
+			},
+		},
+
+		{
+			name: "proxy matches no extension",
+			proxy: &Proxy{
+				Metadata:        &NodeMetadata{IstioVersion: "1.4.0", Labels: map[string]string{"app": "v4"}},
+				ConfigNamespace: "test-ns",
+			},
+			expectedExtensions: map[v1alpha1.FilterPhase][]*model.ExtensionWrapper{},
+		},
+
+		{
+			name: "proxy matches extension in root ns",
+			proxy: &Proxy{
+				Metadata:        &NodeMetadata{IstioVersion: "1.4.0", Labels: map[string]string{"app": "v3"}},
+				ConfigNamespace: "test-n2",
+			},
+			expectedExtensions: map[v1alpha1.FilterPhase][]*model.ExtensionWrapper{
+				v1alpha1.FilterPhasePostAuthZ: {
+					{
+						Name:             "globalv3",
+						Phase:            v1alpha1.FilterPhasePostAuthZ,
+						WorkloadSelector: map[string]string{"app": "v3"},
+					},
+				},
+			},
+		},
+	}
+
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			extensions := push.Extensions(tt.proxy)
+			if !cmp.Equal(extensions, tt.expectedExtensions) {
+				t.Errorf("%s: Extension mismatch, +got -want: %s", tt.name, cmp.Diff(extensions, tt.expectedExtensions))
+			}
+		})
+	}
+}
+
 func TestSidecarScope(t *testing.T) {
 	ps := NewPushContext()
 	env := &Environment{Watcher: mesh.NewFixedWatcher(&meshconfig.MeshConfig{RootNamespace: "istio-system"})}
diff --git a/pilot/pkg/networking/core/v1alpha3/listener_builder.go b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
index 5e70e4f35d..cc36f6e1f8 100644
--- a/pilot/pkg/networking/core/v1alpha3/listener_builder.go
+++ b/pilot/pkg/networking/core/v1alpha3/listener_builder.go
@@ -38,6 +38,7 @@
 	xdsfilters "istio.io/istio/pilot/pkg/xds/filters"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/proto"
+	maistra_extension "istio.io/istio/pkg/servicemesh/extension"
 	"istio.io/pkg/log"
 )
 
@@ -422,12 +423,18 @@ func (lb *ListenerBuilder) patchListeners() {
 	}
 
 	if lb.node.Type == model.Router {
+		if features.EnableMaistraExtensionSupport {
+			maistra_extension.ApplyListenerListPatches(lb.gatewayListeners, lb.node, lb.push, true)
+		}
 		lb.gatewayListeners = envoyfilter.ApplyListenerPatches(networking.EnvoyFilter_GATEWAY, lb.envoyFilterWrapper,
 			lb.gatewayListeners, false)
 		return
 	}
 
 	lb.virtualOutboundListener = lb.patchOneListener(lb.virtualOutboundListener, networking.EnvoyFilter_SIDECAR_OUTBOUND)
+	if features.EnableMaistraExtensionSupport {
+		lb.virtualInboundListener = maistra_extension.ApplyListenerPatches(lb.virtualInboundListener, lb.node, lb.push, false)
+	}
 	lb.virtualInboundListener = lb.patchOneListener(lb.virtualInboundListener, networking.EnvoyFilter_SIDECAR_INBOUND)
 	lb.inboundListeners = envoyfilter.ApplyListenerPatches(networking.EnvoyFilter_SIDECAR_INBOUND, lb.envoyFilterWrapper, lb.inboundListeners, false)
 	lb.outboundListeners = envoyfilter.ApplyListenerPatches(networking.EnvoyFilter_SIDECAR_OUTBOUND, lb.envoyFilterWrapper, lb.outboundListeners, false)
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
new file mode 100644
index 0000000000..b277291e8e
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/register.go
@@ -0,0 +1,76 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1alpha1
+
+import (
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+)
+
+var SchemeGroupVersion = schema.GroupVersion{
+	Group:   "maistra.io",
+	Version: "v1alpha1",
+}
+
+var InternalSchemeGroupVersion = schema.GroupVersion{
+	Group:   "maistra.io",
+	Version: runtime.APIVersionInternal,
+}
+
+var (
+	SchemeBuilder      runtime.SchemeBuilder
+	localSchemeBuilder = &SchemeBuilder
+	AddToScheme        = localSchemeBuilder.AddToScheme
+)
+
+func init() {
+	// We only register manually written functions here. The registration of the
+	// generated functions takes place in the generated files. The separation
+	// makes the code compile even when the generated files are missing.
+	localSchemeBuilder.Register(addKnownTypes)
+	localSchemeBuilder.Register(addKnownInternalTypes)
+}
+
+// Resource takes an unqualified resource and returns a Group qualified GroupResource
+func Resource(resource string) schema.GroupResource {
+	return SchemeGroupVersion.WithResource(resource).GroupResource()
+}
+
+// Adds the list of known types to the given scheme.
+func addKnownTypes(scheme *runtime.Scheme) error {
+	scheme.AddKnownTypes(
+		SchemeGroupVersion,
+		&ServiceMeshExtension{},
+		&ServiceMeshExtensionList{},
+	)
+
+	metav1.AddToGroupVersion(
+		scheme,
+		SchemeGroupVersion,
+	)
+
+	return nil
+}
+
+func addKnownInternalTypes(scheme *runtime.Scheme) error {
+	scheme.AddKnownTypes(
+		InternalSchemeGroupVersion,
+		&ServiceMeshExtension{},
+		&ServiceMeshExtensionList{},
+	)
+
+	return nil
+}
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
new file mode 100644
index 0000000000..d185d3eba4
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/servicemeshextension_types.go
@@ -0,0 +1,83 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1alpha1
+
+import (
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// ServiceMeshExtensionSpec defines the desired state of ServiceMeshExtension
+type ServiceMeshExtensionSpec struct {
+	Image            string           `json:"image,omitempty"`
+	WorkloadSelector WorkloadSelector `json:"workloadSelector,omitempty"`
+	Phase            *FilterPhase     `json:"phase"`
+	Priority         *int             `json:"priority,omitempty"`
+	Config           string           `json:"config,omitempty"`
+}
+
+// ServiceMeshExtensionStatus defines the observed state of ServiceMeshExtension
+type ServiceMeshExtensionStatus struct {
+	Phase              FilterPhase      `json:"phase,omitempty"`
+	Priority           int              `json:"priority,omitempty"`
+	ObservedGeneration int64            `json:"observedGeneration,omitempty"`
+	Deployment         DeploymentStatus `json:"deployment,omitempty"`
+}
+
+type DeploymentStatus struct {
+	Ready           bool   `json:"ready,omitempty"`
+	ContainerSHA256 string `json:"containerSha256,omitempty"`
+	SHA256          string `json:"sha256,omitempty"`
+	URL             string `json:"url,omitempty"`
+}
+
+// WorkloadSelector is used to match workloads based on pod labels
+type WorkloadSelector struct {
+	Labels map[string]string `json:"labels"`
+}
+
+// FilterPhase defines point of injection of Envoy filter
+type FilterPhase string
+
+const (
+	FilterPhasePreAuthN  = "PreAuthN"
+	FilterPhasePostAuthN = "PostAuthN"
+	FilterPhasePreAuthZ  = "PreAuthZ"
+	FilterPhasePostAuthZ = "PostAuthZ"
+	FilterPhasePreStats  = "PreStats"
+	FilterPhasePostStats = "PostStats"
+)
+
+// +kubebuilder:object:root=true
+// +kubebuilder:subresource:statusw
+// +genclient
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ServiceMeshExtension is the Schema for the servicemeshextensions API
+type ServiceMeshExtension struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	Spec   ServiceMeshExtensionSpec   `json:"spec,omitempty"`
+	Status ServiceMeshExtensionStatus `json:"status,omitempty"`
+}
+
+// +kubebuilder:object:root=true
+
+// ServiceMeshExtensionList contains a list of ServiceMeshExtension
+type ServiceMeshExtensionList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []ServiceMeshExtension `json:"items"`
+}
diff --git a/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go b/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..b9e924407b
--- /dev/null
+++ b/pkg/servicemesh/apis/servicemesh/v1alpha1/zz_generated.deepcopy.go
@@ -0,0 +1,153 @@
+// +build !ignore_autogenerated
+
+/*
+Copyright Red Hat, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by controller-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	runtime "k8s.io/apimachinery/pkg/runtime"
+)
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *DeploymentStatus) DeepCopyInto(out *DeploymentStatus) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeploymentStatus.
+func (in *DeploymentStatus) DeepCopy() *DeploymentStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(DeploymentStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceMeshExtension) DeepCopyInto(out *ServiceMeshExtension) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtension.
+func (in *ServiceMeshExtension) DeepCopy() *ServiceMeshExtension {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceMeshExtension)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceMeshExtension) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceMeshExtensionList) DeepCopyInto(out *ServiceMeshExtensionList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]ServiceMeshExtension, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionList.
+func (in *ServiceMeshExtensionList) DeepCopy() *ServiceMeshExtensionList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceMeshExtensionList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceMeshExtensionList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceMeshExtensionSpec) DeepCopyInto(out *ServiceMeshExtensionSpec) {
+	*out = *in
+	in.WorkloadSelector.DeepCopyInto(&out.WorkloadSelector)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionSpec.
+func (in *ServiceMeshExtensionSpec) DeepCopy() *ServiceMeshExtensionSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceMeshExtensionSpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceMeshExtensionStatus) DeepCopyInto(out *ServiceMeshExtensionStatus) {
+	*out = *in
+	out.Deployment = in.Deployment
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMeshExtensionStatus.
+func (in *ServiceMeshExtensionStatus) DeepCopy() *ServiceMeshExtensionStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceMeshExtensionStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *WorkloadSelector) DeepCopyInto(out *WorkloadSelector) {
+	*out = *in
+	if in.Labels != nil {
+		in, out := &in.Labels, &out.Labels
+		*out = make(map[string]string, len(*in))
+		for key, val := range *in {
+			(*out)[key] = val
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new WorkloadSelector.
+func (in *WorkloadSelector) DeepCopy() *WorkloadSelector {
+	if in == nil {
+		return nil
+	}
+	out := new(WorkloadSelector)
+	in.DeepCopyInto(out)
+	return out
+}
diff --git a/pkg/servicemesh/client/clientset/versioned/clientset.go b/pkg/servicemesh/client/v1/clientset/versioned/clientset.go
similarity index 96%
copy from pkg/servicemesh/client/clientset/versioned/clientset.go
copy to pkg/servicemesh/client/v1/clientset/versioned/clientset.go
index 4ff35da131..731c38b7a7 100644
--- a/pkg/servicemesh/client/clientset/versioned/clientset.go
+++ b/pkg/servicemesh/client/v1/clientset/versioned/clientset.go
@@ -19,7 +19,7 @@
 import (
 	"fmt"
 
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
+	maistrav1 "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
diff --git a/pkg/servicemesh/client/clientset/versioned/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/doc.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/doc.go
copy to pkg/servicemesh/client/v1/clientset/versioned/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go b/pkg/servicemesh/client/v1/clientset/versioned/fake/clientset_generated.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go b/pkg/servicemesh/client/v1/clientset/versioned/fake/clientset_generated.go
similarity index 90%
copy from pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
copy to pkg/servicemesh/client/v1/clientset/versioned/fake/clientset_generated.go
index f3db68bbbd..c64610226d 100644
--- a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
+++ b/pkg/servicemesh/client/v1/clientset/versioned/fake/clientset_generated.go
@@ -17,9 +17,9 @@
 package fake
 
 import (
-	clientset "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
-	fakemaistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake"
+	clientset "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned"
+	maistrav1 "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1"
+	fakemaistrav1 "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/fake/doc.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/fake/doc.go
copy to pkg/servicemesh/client/v1/clientset/versioned/fake/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/register.go b/pkg/servicemesh/client/v1/clientset/versioned/fake/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/register.go b/pkg/servicemesh/client/v1/clientset/versioned/fake/register.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/fake/register.go
copy to pkg/servicemesh/client/v1/clientset/versioned/fake/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/scheme/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/scheme/doc.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/scheme/doc.go
copy to pkg/servicemesh/client/v1/clientset/versioned/scheme/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/register.go b/pkg/servicemesh/client/v1/clientset/versioned/scheme/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/register.go b/pkg/servicemesh/client/v1/clientset/versioned/scheme/register.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/scheme/register.go
copy to pkg/servicemesh/client/v1/clientset/versioned/scheme/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/doc.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go
copy to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/doc.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/doc.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/doc.go
copy to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
similarity index 92%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
copy to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
index 4596552de6..f6f147c669 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
+++ b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
@@ -17,7 +17,7 @@
 package fake
 
 import (
-	v1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
+	v1 "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1"
 	rest "k8s.io/client-go/rest"
 	testing "k8s.io/client-go/testing"
 )
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemeshmemberroll.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemeshmemberroll.go
similarity index 100%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemeshmemberroll.go
rename to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemeshmemberroll.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
similarity index 100%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
copy to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
similarity index 97%
copy from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
copy to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
index cdc7871f73..9ae5b3b69f 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
+++ b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
@@ -18,7 +18,7 @@
 
 import (
 	v1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
-	"istio.io/istio/pkg/servicemesh/client/clientset/versioned/scheme"
+	"istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/scheme"
 	rest "k8s.io/client-go/rest"
 )
 
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go
similarity index 98%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go
rename to pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go
index f114abc919..705858e733 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go
+++ b/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1/servicemeshmemberroll.go
@@ -21,7 +21,7 @@
 	"time"
 
 	v1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
-	scheme "istio.io/istio/pkg/servicemesh/client/clientset/versioned/scheme"
+	scheme "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/scheme"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
diff --git a/pkg/servicemesh/client/informers/externalversions/factory.go b/pkg/servicemesh/client/v1/informers/externalversions/factory.go
similarity index 95%
copy from pkg/servicemesh/client/informers/externalversions/factory.go
copy to pkg/servicemesh/client/v1/informers/externalversions/factory.go
index b92bedcd2e..584a2abc7f 100644
--- a/pkg/servicemesh/client/informers/externalversions/factory.go
+++ b/pkg/servicemesh/client/v1/informers/externalversions/factory.go
@@ -21,9 +21,9 @@
 	sync "sync"
 	time "time"
 
-	versioned "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
-	servicemesh "istio.io/istio/pkg/servicemesh/client/informers/externalversions/servicemesh"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces"
+	servicemesh "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/servicemesh"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
diff --git a/pkg/servicemesh/client/informers/externalversions/generic.go b/pkg/servicemesh/client/v1/informers/externalversions/generic.go
similarity index 100%
copy from pkg/servicemesh/client/informers/externalversions/generic.go
copy to pkg/servicemesh/client/v1/informers/externalversions/generic.go
diff --git a/pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go b/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces/factory_interfaces.go
diff --git a/pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go b/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces/factory_interfaces.go
similarity index 94%
copy from pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go
copy to pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces/factory_interfaces.go
index e478fa3095..1956836aaf 100644
--- a/pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go
+++ b/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces/factory_interfaces.go
@@ -19,7 +19,7 @@
 import (
 	time "time"
 
-	versioned "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	cache "k8s.io/client-go/tools/cache"
diff --git a/pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/interface.go
similarity index 87%
copy from pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go
copy to pkg/servicemesh/client/v1/informers/externalversions/servicemesh/interface.go
index 228660bdfe..eca9b7ac38 100644
--- a/pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go
+++ b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/interface.go
@@ -17,8 +17,8 @@
 package servicemesh
 
 import (
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
-	v1 "istio.io/istio/pkg/servicemesh/client/informers/externalversions/servicemesh/v1"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces"
+	v1 "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1"
 )
 
 // Interface provides access to each of this group's versions.
diff --git a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/interface.go
similarity index 93%
copy from pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go
copy to pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/interface.go
index 662ff340e2..8437cb0247 100644
--- a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go
+++ b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/interface.go
@@ -17,7 +17,7 @@
 package v1
 
 import (
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces"
 )
 
 // Interface provides access to all the informers in this group version.
diff --git a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go
similarity index 93%
rename from pkg/servicemesh/client/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go
rename to pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go
index 009b137cba..1898d98563 100644
--- a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go
+++ b/pkg/servicemesh/client/v1/informers/externalversions/servicemesh/v1/servicemeshmemberroll.go
@@ -21,9 +21,9 @@
 	time "time"
 
 	servicemeshv1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
-	versioned "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
-	v1 "istio.io/istio/pkg/servicemesh/client/listers/servicemesh/v1"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions/internalinterfaces"
+	v1 "istio.io/istio/pkg/servicemesh/client/v1/listers/servicemesh/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	watch "k8s.io/apimachinery/pkg/watch"
diff --git a/pkg/servicemesh/client/listers/servicemesh/v1/expansion_generated.go b/pkg/servicemesh/client/v1/listers/servicemesh/v1/expansion_generated.go
similarity index 100%
copy from pkg/servicemesh/client/listers/servicemesh/v1/expansion_generated.go
copy to pkg/servicemesh/client/v1/listers/servicemesh/v1/expansion_generated.go
diff --git a/pkg/servicemesh/client/listers/servicemesh/v1/servicemeshmemberroll.go b/pkg/servicemesh/client/v1/listers/servicemesh/v1/servicemeshmemberroll.go
diff --git a/pkg/servicemesh/client/listers/servicemesh/v1/servicemeshmemberroll.go b/pkg/servicemesh/client/v1/listers/servicemesh/v1/servicemeshmemberroll.go
similarity index 100%
rename from pkg/servicemesh/client/listers/servicemesh/v1/servicemeshmemberroll.go
rename to pkg/servicemesh/client/v1/listers/servicemesh/v1/servicemeshmemberroll.go
diff --git a/pkg/servicemesh/client/clientset/versioned/clientset.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
diff --git a/pkg/servicemesh/client/clientset/versioned/clientset.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
similarity index 79%
copy from pkg/servicemesh/client/clientset/versioned/clientset.go
copy to pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
index 4ff35da131..f048056bf0 100644
--- a/pkg/servicemesh/client/clientset/versioned/clientset.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/clientset.go
@@ -19,7 +19,7 @@
 import (
 	"fmt"
 
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
@@ -27,19 +27,19 @@
 
 type Interface interface {
 	Discovery() discovery.DiscoveryInterface
-	MaistraV1() maistrav1.MaistraV1Interface
+	ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface
 }
 
 // Clientset contains the clients for groups. Each group has exactly one
 // version included in a Clientset.
 type Clientset struct {
 	*discovery.DiscoveryClient
-	maistraV1 *maistrav1.MaistraV1Client
+	servicemeshV1alpha1 *servicemeshv1alpha1.ServicemeshV1alpha1Client
 }
 
-// MaistraV1 retrieves the MaistraV1Client
-func (c *Clientset) MaistraV1() maistrav1.MaistraV1Interface {
-	return c.maistraV1
+// ServicemeshV1alpha1 retrieves the ServicemeshV1alpha1Client
+func (c *Clientset) ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface {
+	return c.servicemeshV1alpha1
 }
 
 // Discovery retrieves the DiscoveryClient
@@ -63,7 +63,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 	}
 	var cs Clientset
 	var err error
-	cs.maistraV1, err = maistrav1.NewForConfig(&configShallowCopy)
+	cs.servicemeshV1alpha1, err = servicemeshv1alpha1.NewForConfig(&configShallowCopy)
 	if err != nil {
 		return nil, err
 	}
@@ -79,7 +79,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 // panics if there is an error in the config.
 func NewForConfigOrDie(c *rest.Config) *Clientset {
 	var cs Clientset
-	cs.maistraV1 = maistrav1.NewForConfigOrDie(c)
+	cs.servicemeshV1alpha1 = servicemeshv1alpha1.NewForConfigOrDie(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)
 	return &cs
@@ -88,7 +88,7 @@ func NewForConfigOrDie(c *rest.Config) *Clientset {
 // New creates a new Clientset for the given RESTClient.
 func New(c rest.Interface) *Clientset {
 	var cs Clientset
-	cs.maistraV1 = maistrav1.New(c)
+	cs.servicemeshV1alpha1 = servicemeshv1alpha1.New(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
 	return &cs
diff --git a/pkg/servicemesh/client/clientset/versioned/doc.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/doc.go
similarity index 100%
rename from pkg/servicemesh/client/clientset/versioned/doc.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
similarity index 80%
copy from pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
copy to pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
index f3db68bbbd..c0a70531a5 100644
--- a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/clientset_generated.go
@@ -17,9 +17,9 @@
 package fake
 
 import (
-	clientset "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
-	fakemaistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake"
+	clientset "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
+	fakeservicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
@@ -74,7 +74,7 @@ func (c *Clientset) Tracker() testing.ObjectTracker {
 
 var _ clientset.Interface = &Clientset{}
 
-// MaistraV1 retrieves the MaistraV1Client
-func (c *Clientset) MaistraV1() maistrav1.MaistraV1Interface {
-	return &fakemaistrav1.FakeMaistraV1{Fake: &c.Fake}
+// ServicemeshV1alpha1 retrieves the ServicemeshV1alpha1Client
+func (c *Clientset) ServicemeshV1alpha1() servicemeshv1alpha1.ServicemeshV1alpha1Interface {
+	return &fakeservicemeshv1alpha1.FakeServicemeshV1alpha1{Fake: &c.Fake}
 }
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/doc.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/doc.go
similarity index 100%
rename from pkg/servicemesh/client/clientset/versioned/fake/doc.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
similarity index 94%
copy from pkg/servicemesh/client/clientset/versioned/fake/register.go
copy to pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
index e6f82d54d4..0089129d44 100644
--- a/pkg/servicemesh/client/clientset/versioned/fake/register.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/fake/register.go
@@ -17,7 +17,7 @@
 package fake
 
 import (
-	maistrav1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -29,7 +29,7 @@
 var codecs = serializer.NewCodecFactory(scheme)
 var parameterCodec = runtime.NewParameterCodec(scheme)
 var localSchemeBuilder = runtime.SchemeBuilder{
-	maistrav1.AddToScheme,
+	servicemeshv1alpha1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/doc.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/doc.go
similarity index 100%
rename from pkg/servicemesh/client/clientset/versioned/scheme/doc.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/register.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
similarity index 94%
copy from pkg/servicemesh/client/clientset/versioned/scheme/register.go
copy to pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
index 7b74fba4a7..2a9754a1e0 100644
--- a/pkg/servicemesh/client/clientset/versioned/scheme/register.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme/register.go
@@ -17,7 +17,7 @@
 package scheme
 
 import (
-	maistrav1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -29,7 +29,7 @@
 var Codecs = serializer.NewCodecFactory(Scheme)
 var ParameterCodec = runtime.NewParameterCodec(Scheme)
 var localSchemeBuilder = runtime.SchemeBuilder{
-	maistrav1.AddToScheme,
+	servicemeshv1alpha1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/doc.go
similarity index 97%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/doc.go
index 4f64357b1f..0a35b21343 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/doc.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/doc.go
@@ -15,4 +15,4 @@
 // Code generated by client-gen. DO NOT EDIT.
 
 // This package has the automatically generated typed clients.
-package v1
+package v1alpha1
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/doc.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/doc.go
similarity index 100%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/doc.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/doc.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
similarity index 70%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
index 4596552de6..c4280e5e44 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake/fake_servicemesh_client.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemesh_client.go
@@ -17,22 +17,22 @@
 package fake
 
 import (
-	v1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
 	rest "k8s.io/client-go/rest"
 	testing "k8s.io/client-go/testing"
 )
 
-type FakeMaistraV1 struct {
+type FakeServicemeshV1alpha1 struct {
 	*testing.Fake
 }
 
-func (c *FakeMaistraV1) ServiceMeshMemberRolls(namespace string) v1.ServiceMeshMemberRollInterface {
-	return &FakeServiceMeshMemberRolls{c, namespace}
+func (c *FakeServicemeshV1alpha1) ServiceMeshExtensions(namespace string) v1alpha1.ServiceMeshExtensionInterface {
+	return &FakeServiceMeshExtensions{c, namespace}
 }
 
 // RESTClient returns a RESTClient that is used to communicate
 // with API server by this client implementation.
-func (c *FakeMaistraV1) RESTClient() rest.Interface {
+func (c *FakeServicemeshV1alpha1) RESTClient() rest.Interface {
 	var ret *rest.RESTClient
 	return ret
 }
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
new file mode 100644
index 0000000000..d863eb6de6
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/fake/fake_servicemeshextension.go
@@ -0,0 +1,140 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeServiceMeshExtensions implements ServiceMeshExtensionInterface
+type FakeServiceMeshExtensions struct {
+	Fake *FakeServicemeshV1alpha1
+	ns   string
+}
+
+var servicemeshextensionsResource = schema.GroupVersionResource{Group: "servicemesh", Version: "v1alpha1", Resource: "servicemeshextensions"}
+
+var servicemeshextensionsKind = schema.GroupVersionKind{Group: "servicemesh", Version: "v1alpha1", Kind: "ServiceMeshExtension"}
+
+// Get takes name of the serviceMeshExtension, and returns the corresponding serviceMeshExtension object, and an error if there is any.
+func (c *FakeServiceMeshExtensions) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewGetAction(servicemeshextensionsResource, c.ns, name), &v1alpha1.ServiceMeshExtension{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), err
+}
+
+// List takes label and field selectors, and returns the list of ServiceMeshExtensions that match those selectors.
+func (c *FakeServiceMeshExtensions) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.ServiceMeshExtensionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewListAction(servicemeshextensionsResource, servicemeshextensionsKind, c.ns, opts), &v1alpha1.ServiceMeshExtensionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1alpha1.ServiceMeshExtensionList{ListMeta: obj.(*v1alpha1.ServiceMeshExtensionList).ListMeta}
+	for _, item := range obj.(*v1alpha1.ServiceMeshExtensionList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested serviceMeshExtensions.
+func (c *FakeServiceMeshExtensions) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewWatchAction(servicemeshextensionsResource, c.ns, opts))
+
+}
+
+// Create takes the representation of a serviceMeshExtension and creates it.  Returns the server's representation of the serviceMeshExtension, and an error, if there is any.
+func (c *FakeServiceMeshExtensions) Create(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.CreateOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewCreateAction(servicemeshextensionsResource, c.ns, serviceMeshExtension), &v1alpha1.ServiceMeshExtension{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), err
+}
+
+// Update takes the representation of a serviceMeshExtension and updates it. Returns the server's representation of the serviceMeshExtension, and an error, if there is any.
+func (c *FakeServiceMeshExtensions) Update(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateAction(servicemeshextensionsResource, c.ns, serviceMeshExtension), &v1alpha1.ServiceMeshExtension{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeServiceMeshExtensions) UpdateStatus(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (*v1alpha1.ServiceMeshExtension, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateSubresourceAction(servicemeshextensionsResource, "status", c.ns, serviceMeshExtension), &v1alpha1.ServiceMeshExtension{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), err
+}
+
+// Delete takes name of the serviceMeshExtension and deletes it. Returns an error if one occurs.
+func (c *FakeServiceMeshExtensions) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewDeleteAction(servicemeshextensionsResource, c.ns, name), &v1alpha1.ServiceMeshExtension{})
+
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeServiceMeshExtensions) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewDeleteCollectionAction(servicemeshextensionsResource, c.ns, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1alpha1.ServiceMeshExtensionList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched serviceMeshExtension.
+func (c *FakeServiceMeshExtensions) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceMeshExtension, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewPatchSubresourceAction(servicemeshextensionsResource, c.ns, name, pt, data, subresources...), &v1alpha1.ServiceMeshExtension{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), err
+}
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
similarity index 90%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
index 9e3d02202f..0ac191c6e7 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/generated_expansion.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/generated_expansion.go
@@ -14,6 +14,6 @@
 
 // Code generated by client-gen. DO NOT EDIT.
 
-package v1
+package v1alpha1
 
-type ServiceMeshMemberRollExpansion interface{}
+type ServiceMeshExtensionExpansion interface{}
diff --git a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
similarity index 56%
rename from pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
rename to pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
index cdc7871f73..2f8e991308 100644
--- a/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/servicemesh_client.go
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemesh_client.go
@@ -14,30 +14,30 @@
 
 // Code generated by client-gen. DO NOT EDIT.
 
-package v1
+package v1alpha1
 
 import (
-	v1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
-	"istio.io/istio/pkg/servicemesh/client/clientset/versioned/scheme"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme"
 	rest "k8s.io/client-go/rest"
 )
 
-type MaistraV1Interface interface {
+type ServicemeshV1alpha1Interface interface {
 	RESTClient() rest.Interface
-	ServiceMeshMemberRollsGetter
+	ServiceMeshExtensionsGetter
 }
 
-// MaistraV1Client is used to interact with features provided by the maistra.io group.
-type MaistraV1Client struct {
+// ServicemeshV1alpha1Client is used to interact with features provided by the servicemesh group.
+type ServicemeshV1alpha1Client struct {
 	restClient rest.Interface
 }
 
-func (c *MaistraV1Client) ServiceMeshMemberRolls(namespace string) ServiceMeshMemberRollInterface {
-	return newServiceMeshMemberRolls(c, namespace)
+func (c *ServicemeshV1alpha1Client) ServiceMeshExtensions(namespace string) ServiceMeshExtensionInterface {
+	return newServiceMeshExtensions(c, namespace)
 }
 
-// NewForConfig creates a new MaistraV1Client for the given config.
-func NewForConfig(c *rest.Config) (*MaistraV1Client, error) {
+// NewForConfig creates a new ServicemeshV1alpha1Client for the given config.
+func NewForConfig(c *rest.Config) (*ServicemeshV1alpha1Client, error) {
 	config := *c
 	if err := setConfigDefaults(&config); err != nil {
 		return nil, err
@@ -46,12 +46,12 @@ func NewForConfig(c *rest.Config) (*MaistraV1Client, error) {
 	if err != nil {
 		return nil, err
 	}
-	return &MaistraV1Client{client}, nil
+	return &ServicemeshV1alpha1Client{client}, nil
 }
 
-// NewForConfigOrDie creates a new MaistraV1Client for the given config and
+// NewForConfigOrDie creates a new ServicemeshV1alpha1Client for the given config and
 // panics if there is an error in the config.
-func NewForConfigOrDie(c *rest.Config) *MaistraV1Client {
+func NewForConfigOrDie(c *rest.Config) *ServicemeshV1alpha1Client {
 	client, err := NewForConfig(c)
 	if err != nil {
 		panic(err)
@@ -59,13 +59,13 @@ func NewForConfigOrDie(c *rest.Config) *MaistraV1Client {
 	return client
 }
 
-// New creates a new MaistraV1Client for the given RESTClient.
-func New(c rest.Interface) *MaistraV1Client {
-	return &MaistraV1Client{c}
+// New creates a new ServicemeshV1alpha1Client for the given RESTClient.
+func New(c rest.Interface) *ServicemeshV1alpha1Client {
+	return &ServicemeshV1alpha1Client{c}
 }
 
 func setConfigDefaults(config *rest.Config) error {
-	gv := v1.SchemeGroupVersion
+	gv := v1alpha1.SchemeGroupVersion
 	config.GroupVersion = &gv
 	config.APIPath = "/apis"
 	config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()
@@ -79,7 +79,7 @@ func setConfigDefaults(config *rest.Config) error {
 
 // RESTClient returns a RESTClient that is used to communicate
 // with API server by this client implementation.
-func (c *MaistraV1Client) RESTClient() rest.Interface {
+func (c *ServicemeshV1alpha1Client) RESTClient() rest.Interface {
 	if c == nil {
 		return nil
 	}
diff --git a/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
new file mode 100644
index 0000000000..1a18eea8c1
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1/servicemeshextension.go
@@ -0,0 +1,193 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	"time"
+
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	scheme "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// ServiceMeshExtensionsGetter has a method to return a ServiceMeshExtensionInterface.
+// A group's client should implement this interface.
+type ServiceMeshExtensionsGetter interface {
+	ServiceMeshExtensions(namespace string) ServiceMeshExtensionInterface
+}
+
+// ServiceMeshExtensionInterface has methods to work with ServiceMeshExtension resources.
+type ServiceMeshExtensionInterface interface {
+	Create(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.CreateOptions) (*v1alpha1.ServiceMeshExtension, error)
+	Update(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (*v1alpha1.ServiceMeshExtension, error)
+	UpdateStatus(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (*v1alpha1.ServiceMeshExtension, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ServiceMeshExtension, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ServiceMeshExtensionList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceMeshExtension, err error)
+	ServiceMeshExtensionExpansion
+}
+
+// serviceMeshExtensions implements ServiceMeshExtensionInterface
+type serviceMeshExtensions struct {
+	client rest.Interface
+	ns     string
+}
+
+// newServiceMeshExtensions returns a ServiceMeshExtensions
+func newServiceMeshExtensions(c *ServicemeshV1alpha1Client, namespace string) *serviceMeshExtensions {
+	return &serviceMeshExtensions{
+		client: c.RESTClient(),
+		ns:     namespace,
+	}
+}
+
+// Get takes name of the serviceMeshExtension, and returns the corresponding serviceMeshExtension object, and an error if there is any.
+func (c *serviceMeshExtensions) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	result = &v1alpha1.ServiceMeshExtension{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of ServiceMeshExtensions that match those selectors.
+func (c *serviceMeshExtensions) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.ServiceMeshExtensionList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1alpha1.ServiceMeshExtensionList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested serviceMeshExtensions.
+func (c *serviceMeshExtensions) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a serviceMeshExtension and creates it.  Returns the server's representation of the serviceMeshExtension, and an error, if there is any.
+func (c *serviceMeshExtensions) Create(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.CreateOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	result = &v1alpha1.ServiceMeshExtension{}
+	err = c.client.Post().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceMeshExtension).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a serviceMeshExtension and updates it. Returns the server's representation of the serviceMeshExtension, and an error, if there is any.
+func (c *serviceMeshExtensions) Update(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	result = &v1alpha1.ServiceMeshExtension{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		Name(serviceMeshExtension.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceMeshExtension).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *serviceMeshExtensions) UpdateStatus(ctx context.Context, serviceMeshExtension *v1alpha1.ServiceMeshExtension, opts v1.UpdateOptions) (result *v1alpha1.ServiceMeshExtension, err error) {
+	result = &v1alpha1.ServiceMeshExtension{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		Name(serviceMeshExtension.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceMeshExtension).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the serviceMeshExtension and deletes it. Returns an error if one occurs.
+func (c *serviceMeshExtensions) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *serviceMeshExtensions) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched serviceMeshExtension.
+func (c *serviceMeshExtensions) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceMeshExtension, err error) {
+	result = &v1alpha1.ServiceMeshExtension{}
+	err = c.client.Patch(pt).
+		Namespace(c.ns).
+		Resource("servicemeshextensions").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/servicemesh/client/informers/externalversions/factory.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
similarity index 93%
rename from pkg/servicemesh/client/informers/externalversions/factory.go
rename to pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
index b92bedcd2e..20c4fa2980 100644
--- a/pkg/servicemesh/client/informers/externalversions/factory.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/factory.go
@@ -21,9 +21,9 @@
 	sync "sync"
 	time "time"
 
-	versioned "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
-	servicemesh "istio.io/istio/pkg/servicemesh/client/informers/externalversions/servicemesh"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
+	servicemesh "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -170,9 +170,9 @@ type SharedInformerFactory interface {
 	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
 	WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool
 
-	Maistra() servicemesh.Interface
+	Servicemesh() servicemesh.Interface
 }
 
-func (f *sharedInformerFactory) Maistra() servicemesh.Interface {
+func (f *sharedInformerFactory) Servicemesh() servicemesh.Interface {
 	return servicemesh.New(f, f.namespace, f.tweakListOptions)
 }
diff --git a/pkg/servicemesh/client/informers/externalversions/generic.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
similarity index 87%
rename from pkg/servicemesh/client/informers/externalversions/generic.go
rename to pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
index 528bcc7f26..e1e61e2945 100644
--- a/pkg/servicemesh/client/informers/externalversions/generic.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/generic.go
@@ -19,7 +19,7 @@
 import (
 	"fmt"
 
-	v1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	cache "k8s.io/client-go/tools/cache"
 )
@@ -50,9 +50,9 @@ func (f *genericInformer) Lister() cache.GenericLister {
 // TODO extend this to unknown resources with a client pool
 func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {
 	switch resource {
-	// Group=maistra.io, Version=v1
-	case v1.SchemeGroupVersion.WithResource("servicemeshmemberrolls"):
-		return &genericInformer{resource: resource.GroupResource(), informer: f.Maistra().V1().ServiceMeshMemberRolls().Informer()}, nil
+	// Group=servicemesh, Version=v1alpha1
+	case v1alpha1.SchemeGroupVersion.WithResource("servicemeshextensions"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Servicemesh().V1alpha1().ServiceMeshExtensions().Informer()}, nil
 
 	}
 
diff --git a/pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces/factory_interfaces.go
similarity index 94%
rename from pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go
rename to pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces/factory_interfaces.go
index e478fa3095..150e6d7e65 100644
--- a/pkg/servicemesh/client/informers/externalversions/internalinterfaces/factory_interfaces.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces/factory_interfaces.go
@@ -19,7 +19,7 @@
 import (
 	time "time"
 
-	versioned "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	cache "k8s.io/client-go/tools/cache"
diff --git a/pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/interface.go
similarity index 70%
rename from pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go
rename to pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/interface.go
index 228660bdfe..3598113d2e 100644
--- a/pkg/servicemesh/client/informers/externalversions/servicemesh/interface.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/interface.go
@@ -17,14 +17,14 @@
 package servicemesh
 
 import (
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
-	v1 "istio.io/istio/pkg/servicemesh/client/informers/externalversions/servicemesh/v1"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1"
 )
 
 // Interface provides access to each of this group's versions.
 type Interface interface {
-	// V1 provides access to shared informers for resources in V1.
-	V1() v1.Interface
+	// V1alpha1 provides access to shared informers for resources in V1alpha1.
+	V1alpha1() v1alpha1.Interface
 }
 
 type group struct {
@@ -38,7 +38,7 @@ func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakList
 	return &group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
 }
 
-// V1 returns a new v1.Interface.
-func (g *group) V1() v1.Interface {
-	return v1.New(g.factory, g.namespace, g.tweakListOptions)
+// V1alpha1 returns a new v1alpha1.Interface.
+func (g *group) V1alpha1() v1alpha1.Interface {
+	return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
 }
diff --git a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
similarity index 69%
rename from pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go
rename to pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
index 662ff340e2..fd3b2bbc22 100644
--- a/pkg/servicemesh/client/informers/externalversions/servicemesh/v1/interface.go
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/interface.go
@@ -14,16 +14,16 @@
 
 // Code generated by informer-gen. DO NOT EDIT.
 
-package v1
+package v1alpha1
 
 import (
-	internalinterfaces "istio.io/istio/pkg/servicemesh/client/informers/externalversions/internalinterfaces"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
 )
 
 // Interface provides access to all the informers in this group version.
 type Interface interface {
-	// ServiceMeshMemberRolls returns a ServiceMeshMemberRollInformer.
-	ServiceMeshMemberRolls() ServiceMeshMemberRollInformer
+	// ServiceMeshExtensions returns a ServiceMeshExtensionInformer.
+	ServiceMeshExtensions() ServiceMeshExtensionInformer
 }
 
 type version struct {
@@ -37,7 +37,7 @@ func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakList
 	return &version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
 }
 
-// ServiceMeshMemberRolls returns a ServiceMeshMemberRollInformer.
-func (v *version) ServiceMeshMemberRolls() ServiceMeshMemberRollInformer {
-	return &serviceMeshMemberRollInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
+// ServiceMeshExtensions returns a ServiceMeshExtensionInformer.
+func (v *version) ServiceMeshExtensions() ServiceMeshExtensionInformer {
+	return &serviceMeshExtensionInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
 }
diff --git a/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
new file mode 100644
index 0000000000..504a29f6c4
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/informers/externalversions/servicemesh/v1alpha1/servicemeshextension.go
@@ -0,0 +1,88 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	time "time"
+
+	servicemeshv1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	versioned "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned"
+	internalinterfaces "istio.io/istio/pkg/servicemesh/client/v1alpha1/informers/externalversions/internalinterfaces"
+	v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// ServiceMeshExtensionInformer provides access to a shared informer and lister for
+// ServiceMeshExtensions.
+type ServiceMeshExtensionInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1alpha1.ServiceMeshExtensionLister
+}
+
+type serviceMeshExtensionInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+	namespace        string
+}
+
+// NewServiceMeshExtensionInformer constructs a new informer for ServiceMeshExtension type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewServiceMeshExtensionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredServiceMeshExtensionInformer(client, namespace, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredServiceMeshExtensionInformer constructs a new informer for ServiceMeshExtension type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredServiceMeshExtensionInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.ServicemeshV1alpha1().ServiceMeshExtensions(namespace).List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.ServicemeshV1alpha1().ServiceMeshExtensions(namespace).Watch(context.TODO(), options)
+			},
+		},
+		&servicemeshv1alpha1.ServiceMeshExtension{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *serviceMeshExtensionInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredServiceMeshExtensionInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *serviceMeshExtensionInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&servicemeshv1alpha1.ServiceMeshExtension{}, f.defaultInformer)
+}
+
+func (f *serviceMeshExtensionInformer) Lister() v1alpha1.ServiceMeshExtensionLister {
+	return v1alpha1.NewServiceMeshExtensionLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/servicemesh/client/listers/servicemesh/v1/expansion_generated.go b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
similarity index 63%
rename from pkg/servicemesh/client/listers/servicemesh/v1/expansion_generated.go
rename to pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
index ada26b7c7c..a92f0a1fee 100644
--- a/pkg/servicemesh/client/listers/servicemesh/v1/expansion_generated.go
+++ b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/expansion_generated.go
@@ -14,12 +14,12 @@
 
 // Code generated by lister-gen. DO NOT EDIT.
 
-package v1
+package v1alpha1
 
-// ServiceMeshMemberRollListerExpansion allows custom methods to be added to
-// ServiceMeshMemberRollLister.
-type ServiceMeshMemberRollListerExpansion interface{}
+// ServiceMeshExtensionListerExpansion allows custom methods to be added to
+// ServiceMeshExtensionLister.
+type ServiceMeshExtensionListerExpansion interface{}
 
-// ServiceMeshMemberRollNamespaceListerExpansion allows custom methods to be added to
-// ServiceMeshMemberRollNamespaceLister.
-type ServiceMeshMemberRollNamespaceListerExpansion interface{}
+// ServiceMeshExtensionNamespaceListerExpansion allows custom methods to be added to
+// ServiceMeshExtensionNamespaceLister.
+type ServiceMeshExtensionNamespaceListerExpansion interface{}
diff --git a/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/servicemeshextension.go b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/servicemeshextension.go
new file mode 100644
index 0000000000..56c004da6c
--- /dev/null
+++ b/pkg/servicemesh/client/v1alpha1/listers/servicemesh/v1alpha1/servicemeshextension.go
@@ -0,0 +1,92 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	v1alpha1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// ServiceMeshExtensionLister helps list ServiceMeshExtensions.
+type ServiceMeshExtensionLister interface {
+	// List lists all ServiceMeshExtensions in the indexer.
+	List(selector labels.Selector) (ret []*v1alpha1.ServiceMeshExtension, err error)
+	// ServiceMeshExtensions returns an object that can list and get ServiceMeshExtensions.
+	ServiceMeshExtensions(namespace string) ServiceMeshExtensionNamespaceLister
+	ServiceMeshExtensionListerExpansion
+}
+
+// serviceMeshExtensionLister implements the ServiceMeshExtensionLister interface.
+type serviceMeshExtensionLister struct {
+	indexer cache.Indexer
+}
+
+// NewServiceMeshExtensionLister returns a new ServiceMeshExtensionLister.
+func NewServiceMeshExtensionLister(indexer cache.Indexer) ServiceMeshExtensionLister {
+	return &serviceMeshExtensionLister{indexer: indexer}
+}
+
+// List lists all ServiceMeshExtensions in the indexer.
+func (s *serviceMeshExtensionLister) List(selector labels.Selector) (ret []*v1alpha1.ServiceMeshExtension, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.ServiceMeshExtension))
+	})
+	return ret, err
+}
+
+// ServiceMeshExtensions returns an object that can list and get ServiceMeshExtensions.
+func (s *serviceMeshExtensionLister) ServiceMeshExtensions(namespace string) ServiceMeshExtensionNamespaceLister {
+	return serviceMeshExtensionNamespaceLister{indexer: s.indexer, namespace: namespace}
+}
+
+// ServiceMeshExtensionNamespaceLister helps list and get ServiceMeshExtensions.
+type ServiceMeshExtensionNamespaceLister interface {
+	// List lists all ServiceMeshExtensions in the indexer for a given namespace.
+	List(selector labels.Selector) (ret []*v1alpha1.ServiceMeshExtension, err error)
+	// Get retrieves the ServiceMeshExtension from the indexer for a given namespace and name.
+	Get(name string) (*v1alpha1.ServiceMeshExtension, error)
+	ServiceMeshExtensionNamespaceListerExpansion
+}
+
+// serviceMeshExtensionNamespaceLister implements the ServiceMeshExtensionNamespaceLister
+// interface.
+type serviceMeshExtensionNamespaceLister struct {
+	indexer   cache.Indexer
+	namespace string
+}
+
+// List lists all ServiceMeshExtensions in the indexer for a given namespace.
+func (s serviceMeshExtensionNamespaceLister) List(selector labels.Selector) (ret []*v1alpha1.ServiceMeshExtension, err error) {
+	err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.ServiceMeshExtension))
+	})
+	return ret, err
+}
+
+// Get retrieves the ServiceMeshExtension from the indexer for a given namespace and name.
+func (s serviceMeshExtensionNamespaceLister) Get(name string) (*v1alpha1.ServiceMeshExtension, error) {
+	obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1alpha1.Resource("servicemeshextension"), name)
+	}
+	return obj.(*v1alpha1.ServiceMeshExtension), nil
+}
diff --git a/pkg/servicemesh/controller/controller.go b/pkg/servicemesh/controller/controller.go
index f9fdb3461c..b3e25943c1 100644
--- a/pkg/servicemesh/controller/controller.go
+++ b/pkg/servicemesh/controller/controller.go
@@ -24,9 +24,9 @@
 	"k8s.io/client-go/tools/cache"
 
 	v1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
-	"istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	versioned_v1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
-	"istio.io/istio/pkg/servicemesh/client/informers/externalversions"
+	"istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned"
+	versioned_v1 "istio.io/istio/pkg/servicemesh/client/v1/clientset/versioned/typed/servicemesh/v1"
+	"istio.io/istio/pkg/servicemesh/client/v1/informers/externalversions"
 	"istio.io/pkg/log"
 )
 
diff --git a/pkg/servicemesh/controller/extension/controller.go b/pkg/servicemesh/controller/extension/controller.go
new file mode 100644
index 0000000000..4e565bb536
--- /dev/null
+++ b/pkg/servicemesh/controller/extension/controller.go
@@ -0,0 +1,138 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package extension
+
+import (
+	"context"
+	"fmt"
+	"time"
+
+	xnsinformers "github.com/maistra/xns-informer/pkg/informers"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/client-go/tools/cache"
+
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	versioned_v1alpha1 "istio.io/istio/pkg/servicemesh/client/v1alpha1/clientset/versioned/typed/servicemesh/v1alpha1"
+	memberroll "istio.io/istio/pkg/servicemesh/controller"
+	"istio.io/pkg/log"
+)
+
+type serviceMeshExtensionController struct {
+	informer cache.SharedIndexInformer
+	store    map[string]*v1alpha1.ServiceMeshExtension
+}
+
+type Controller interface {
+	GetExtensions() []*v1alpha1.ServiceMeshExtension
+	RegisterEventHandler(handler cache.ResourceEventHandler)
+	Start(<-chan struct{})
+}
+
+func NewControllerFromConfigFile(kubeConfig string, namespaces []string, mrc memberroll.MemberRollController, resync time.Duration) (Controller, error) {
+	config, err := kube.BuildClientConfig(kubeConfig, "")
+	if err != nil {
+		fmt.Printf("Could not create k8s config: %v", err)
+		return nil, err
+	}
+	cs, err := versioned_v1alpha1.NewForConfig(config)
+	if err != nil {
+		fmt.Printf("Could not create k8s clientset: %v", err)
+		return nil, err
+	}
+
+	namespaceSet := xnsinformers.NewNamespaceSet(namespaces...)
+	if mrc != nil {
+		mrc.Register(namespaceSet, "extensions-controller")
+	}
+
+	newInformer := func(namespace string) cache.SharedIndexInformer {
+		return cache.NewSharedIndexInformer(
+			&cache.ListWatch{
+				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
+					return cs.ServiceMeshExtensions(namespace).List(context.TODO(), options)
+				},
+				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
+					return cs.ServiceMeshExtensions(namespace).Watch(context.TODO(), options)
+				},
+			},
+			&v1alpha1.ServiceMeshExtension{},
+			resync,
+			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
+		)
+	}
+
+	store := make(map[string]*v1alpha1.ServiceMeshExtension)
+	informer := xnsinformers.NewMultiNamespaceInformer(namespaceSet, resync, newInformer)
+
+	informer.AddEventHandler(
+		cache.ResourceEventHandlerFuncs{
+			AddFunc: func(obj interface{}) {
+				extension, ok := obj.(*v1alpha1.ServiceMeshExtension)
+				if ok && extension != nil {
+					store[extension.Namespace+"/"+extension.Name] = extension.DeepCopy()
+					log.Infof("Added extension %s/%s", extension.Namespace, extension.Name)
+
+				}
+			},
+			UpdateFunc: func(old, cur interface{}) {
+				extension, ok := cur.(*v1alpha1.ServiceMeshExtension)
+				if ok && extension != nil {
+					store[extension.Namespace+"/"+extension.Name] = extension.DeepCopy()
+					log.Infof("Updated extension %s/%s", extension.Namespace, extension.Name)
+				}
+			},
+			DeleteFunc: func(obj interface{}) {
+				extension, ok := obj.(*v1alpha1.ServiceMeshExtension)
+				if !ok {
+					tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
+					if !ok {
+						log.Errorf("Couldn't get object from tombstone %#v", obj)
+						return
+					}
+					extension, ok = tombstone.Obj.(*v1alpha1.ServiceMeshExtension)
+					if !ok {
+						log.Errorf("Tombstone contained object that is not a service mesh member roll %#v", obj)
+						return
+					}
+				}
+				delete(store, extension.Namespace+"/"+extension.Name)
+				log.Infof("Deleted extension %s/%s", extension.Namespace, extension.Name)
+			},
+		})
+
+	return &serviceMeshExtensionController{
+		informer: informer,
+		store:    store,
+	}, nil
+}
+
+func (ec *serviceMeshExtensionController) GetExtensions() []*v1alpha1.ServiceMeshExtension {
+	ret := []*v1alpha1.ServiceMeshExtension{}
+	for _, v := range ec.store {
+		ret = append(ret, v.DeepCopy())
+	}
+	return ret
+}
+
+func (ec *serviceMeshExtensionController) Start(stopChan <-chan struct{}) {
+	go ec.informer.Run(stopChan)
+}
+
+func (ec *serviceMeshExtensionController) RegisterEventHandler(handler cache.ResourceEventHandler) {
+	ec.informer.AddEventHandler(handler)
+}
diff --git a/pkg/servicemesh/extension/apply_extension.go b/pkg/servicemesh/extension/apply_extension.go
new file mode 100644
index 0000000000..41678d489a
--- /dev/null
+++ b/pkg/servicemesh/extension/apply_extension.go
@@ -0,0 +1,193 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package extension
+
+import (
+	"fmt"
+
+	xdslistener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	hcm_filter "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
+	xdsutil "github.com/envoyproxy/go-control-plane/pkg/wellknown"
+	structpb "github.com/golang/protobuf/ptypes/struct"
+
+	"istio.io/istio/istioctl/pkg/authz"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/util"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+	maistramodel "istio.io/istio/pkg/servicemesh/model"
+)
+
+const (
+	DefaultCacheCluster = "outbound|80||mec.istio-system.svc.cluster.local"
+	defaultRuntime      = "envoy.wasm.runtime.v8"
+)
+
+var (
+	// CacheCluster is the Envoy cluster that is used to retrieve WASM filters from
+	CacheCluster = ""
+	// Runtime sets the WASM runtime to use for extensions
+	Runtime = defaultRuntime
+)
+
+// ApplyListenerPatches adds extensions to listener filterChains
+func ApplyListenerPatches(
+	listener *xdslistener.Listener,
+	proxy *model.Proxy,
+	push *model.PushContext,
+	patchAll bool,
+) *xdslistener.Listener {
+	if listener == nil {
+		return nil
+	}
+	extensionsMap := push.Extensions(proxy)
+
+	relevantFilterChains := []string{}
+	for _, si := range proxy.ServiceInstances {
+		relevantFilterChains = append(relevantFilterChains, fmt.Sprintf("%s_%d", si.Endpoint.Address, si.Endpoint.EndpointPort))
+	}
+
+	for fcIndex, fc := range listener.FilterChains {
+		// copy extensions map
+		extensions := make(map[v1alpha1.FilterPhase][]*maistramodel.ExtensionWrapper)
+		for k, v := range extensionsMap {
+			extensions[k] = []*maistramodel.ExtensionWrapper{}
+			extensions[k] = append(extensions[k], v...)
+		}
+		if !patchAll {
+			isRelevant := false
+			for _, relevant := range relevantFilterChains {
+				if fc.Name == relevant {
+					isRelevant = true
+				}
+			}
+			if !isRelevant {
+				continue
+			}
+		}
+		var hcm *hcm_filter.HttpConnectionManager
+		var hcmIndex int
+		for i, f := range fc.Filters {
+			if f.Name == "envoy.http_connection_manager" {
+				if hcm = authz.GetHTTPConnectionManager(f); hcm != nil {
+					hcmIndex = i
+					break
+				}
+			}
+		}
+		if hcm == nil {
+			continue
+		}
+		newHTTPFilters := make([]*hcm_filter.HttpFilter, 0)
+		for _, httpFilter := range hcm.GetHttpFilters() {
+			switch httpFilter.Name {
+			case "envoy.filters.http.jwt_authn":
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthN)
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+			case "istio_authn":
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthN)
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthN)
+			case "envoy.filters.http.rbac":
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthZ)
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthZ)
+			case "istio.stats":
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthZ)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthZ)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreStats)
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostStats)
+			case "envoy.router":
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthN)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreAuthZ)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostAuthZ)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePreStats)
+				newHTTPFilters = popAppend(newHTTPFilters, extensions, v1alpha1.FilterPhasePostStats)
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+			default:
+				newHTTPFilters = append(newHTTPFilters, httpFilter)
+			}
+		}
+		hcm.HttpFilters = newHTTPFilters
+		fc.Filters[hcmIndex] = &xdslistener.Filter{
+			Name:       xdsutil.HTTPConnectionManager,
+			ConfigType: &xdslistener.Filter_TypedConfig{TypedConfig: util.MessageToAny(hcm)},
+		}
+		listener.FilterChains[fcIndex] = fc
+	}
+	return listener
+}
+
+func ApplyListenerListPatches(
+	listeners []*xdslistener.Listener,
+	proxy *model.Proxy,
+	push *model.PushContext,
+	patchAll bool,
+) (out []*xdslistener.Listener) {
+	for _, listener := range listeners {
+		out = append(out, ApplyListenerPatches(listener, proxy, push, patchAll))
+	}
+	return out
+}
+
+func popAppend(list []*hcm_filter.HttpFilter,
+	filterMap map[v1alpha1.FilterPhase][]*maistramodel.ExtensionWrapper,
+	phase v1alpha1.FilterPhase) []*hcm_filter.HttpFilter {
+	for _, ext := range filterMap[phase] {
+		list = append(list, toEnvoyHTTPFilter(ext))
+	}
+	filterMap[phase] = []*maistramodel.ExtensionWrapper{}
+	return list
+}
+
+func toEnvoyHTTPFilter(extension *maistramodel.ExtensionWrapper) *hcm_filter.HttpFilter {
+	return &hcm_filter.HttpFilter{
+		Name: "envoy.filters.http.wasm",
+		ConfigType: &hcm_filter.HttpFilter_TypedConfig{
+			TypedConfig: util.MessageToAny(&structpb.Struct{
+				Fields: map[string]*structpb.Value{
+					"config": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+						"name":          {Kind: &structpb.Value_StringValue{StringValue: extension.Name}},
+						"rootId":        {Kind: &structpb.Value_StringValue{StringValue: extension.Name + "_root"}},
+						"configuration": {Kind: &structpb.Value_StringValue{StringValue: extension.Config}},
+						"vmConfig": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+							"code": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+								"remote": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+									"httpUri": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+										"uri":     {Kind: &structpb.Value_StringValue{StringValue: extension.FilterURL}},
+										"cluster": {Kind: &structpb.Value_StringValue{StringValue: CacheCluster}},
+										"timeout": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+											"seconds": {Kind: &structpb.Value_NumberValue{NumberValue: 30}},
+										}}}},
+									}}}},
+									"sha256": {Kind: &structpb.Value_StringValue{StringValue: extension.SHA256}},
+									"retryPolicy": {Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: map[string]*structpb.Value{
+										"numRetries": {Kind: &structpb.Value_NumberValue{NumberValue: 2}},
+									}}}},
+								}}}},
+							}}}},
+							"runtime": {Kind: &structpb.Value_StringValue{StringValue: Runtime}},
+						}}}},
+					}}}},
+				},
+			}),
+		},
+	}
+}
diff --git a/pkg/servicemesh/maistra.mk b/pkg/servicemesh/maistra.mk
index 2caa81bf8f..b3617199e4 100644
--- a/pkg/servicemesh/maistra.mk
+++ b/pkg/servicemesh/maistra.mk
@@ -18,7 +18,8 @@ informer_gen = informer-gen
 
 kube_base_output_package = istio.io/istio/pkg/servicemesh
 kube_api_base_package = $(kube_base_output_package)/apis
-kube_api_packages = $(kube_api_base_package)/servicemesh/v1
+kube_api_packages_v1 = $(kube_api_base_package)/servicemesh/v1
+kube_api_packages_v1alpha1 = $(kube_api_base_package)/servicemesh/v1alpha1
 kube_clientset_package = $(kube_base_output_package)/clientset
 
 # file header text
@@ -26,11 +27,14 @@ kube_go_header_text = pkg/servicemesh/header.go.txt
 # clientset name used by kubernetes client-gen
 kube_clientset_name = versioned
 # base output package used by kubernetes client-gen
-kube_clientset_package = $(kube_base_output_package)/client/clientset
+kube_clientset_package_v1 = $(kube_base_output_package)/client/v1/clientset
+kube_clientset_package_v1alpha1 = $(kube_base_output_package)/client/v1alpha1/clientset
 # base output package used by kubernetes lister-gen
-kube_listers_package = $(kube_base_output_package)/client/listers
+kube_listers_package_v1 = $(kube_base_output_package)/client/v1/listers
+kube_listers_package_v1alpha1 = $(kube_base_output_package)/client/v1alpha1/listers
 # base output package used by kubernetes informer-gen
-kube_informers_package = $(kube_base_output_package)/client/informers
+kube_informers_package_v1 = $(kube_base_output_package)/client/v1/informers
+kube_informers_package_v1alpha1 = $(kube_base_output_package)/client/v1alpha1/informers
 
 ifeq ($(IN_BUILD_CONTAINER),1)
 	# k8s code generators rely on GOPATH, using $GOPATH/src as the base package
@@ -46,9 +50,12 @@ endif
 
 .PHONY: maistra-gen-k8s-client
 maistra-gen-k8s-client:
-	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages) --output-package $(kube_clientset_package) -h $(kube_go_header_text)
-	@$(lister_gen) --input-dirs $(kube_api_packages) --output-package $(kube_listers_package) -h $(kube_go_header_text)
-	@$(informer_gen) --input-dirs $(kube_api_packages) --versioned-clientset-package $(kube_clientset_package)/$(kube_clientset_name) --listers-package $(kube_listers_package) --output-package $(kube_informers_package) -h $(kube_go_header_text)
+	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages_v1) --output-package $(kube_clientset_package_v1) -h $(kube_go_header_text)
+	@$(lister_gen) --input-dirs $(kube_api_packages_v1) --output-package $(kube_listers_package_v1) -h $(kube_go_header_text)
+	@$(informer_gen) --input-dirs $(kube_api_packages_v1) --versioned-clientset-package $(kube_clientset_package_v1)/$(kube_clientset_name) --listers-package $(kube_listers_package_v1) --output-package $(kube_informers_package_v1) -h $(kube_go_header_text)
+	@$(client_gen) --clientset-name $(kube_clientset_name) --input-base "" --input  $(kube_api_packages_v1alpha1) --output-package $(kube_clientset_package_v1alpha1) -h $(kube_go_header_text)
+	@$(lister_gen) --input-dirs $(kube_api_packages_v1alpha1) --output-package $(kube_listers_package_v1alpha1) -h $(kube_go_header_text)
+	@$(informer_gen) --input-dirs $(kube_api_packages_v1alpha1) --versioned-clientset-package $(kube_clientset_package_v1alpha1)/$(kube_clientset_name) --listers-package $(kube_listers_package_v1alpha1) --output-package $(kube_informers_package_v1alpha1) -h $(kube_go_header_text)
 	@$(move_generated)
 
 .PHONY: vendor
@@ -57,5 +64,9 @@ vendor:
 	@go mod vendor
 	@echo "done updating vendor"
 
-.PHONY: gen
+.PHONY: maistra-gen
 maistra-gen: maistra-gen-k8s-client vendor
+
+.PHONY: mec
+mec: build
+BINARIES += ./mec/cmd/mec
diff --git a/pkg/servicemesh/model/extension.go b/pkg/servicemesh/model/extension.go
new file mode 100644
index 0000000000..4a36fdaccb
--- /dev/null
+++ b/pkg/servicemesh/model/extension.go
@@ -0,0 +1,45 @@
+// Copyright Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package model
+
+import (
+	"istio.io/istio/pkg/config/labels"
+	"istio.io/istio/pkg/servicemesh/apis/servicemesh/v1alpha1"
+)
+
+// ExtensionWrapper is a wrapper around extensions
+type ExtensionWrapper struct {
+	Name             string
+	WorkloadSelector labels.Instance
+	Config           string
+	Image            string
+	FilterURL        string
+	SHA256           string
+	Phase            v1alpha1.FilterPhase
+	Priority         int
+}
+
+func ToWrapper(extension *v1alpha1.ServiceMeshExtension) *ExtensionWrapper {
+	return &ExtensionWrapper{
+		Name:             extension.Name,
+		WorkloadSelector: extension.Spec.WorkloadSelector.Labels,
+		Config:           extension.Spec.Config,
+		Image:            extension.Spec.Image,
+		FilterURL:        extension.Status.Deployment.URL,
+		SHA256:           extension.Status.Deployment.SHA256,
+		Phase:            extension.Status.Phase,
+		Priority:         extension.Status.Priority,
+	}
+}
diff --git a/tests/binary/binaries_test.go b/tests/binary/binaries_test.go
index da1b512255..0962f0fb8a 100644
--- a/tests/binary/binaries_test.go
+++ b/tests/binary/binaries_test.go
@@ -92,7 +92,7 @@ func TestBinarySizes(t *testing.T) {
 		// TODO: shrink the ranges here once the active work to reduce binary size is complete
 		// For now, having two small a range will result in lots of "merge conflicts"
 		"istioctl":    {60, 100},
-		"pilot-agent": {30, 45},
+		"pilot-agent": {30, 65}, // Maistra increases this from 45 to accommodate ServiceMeshExtensions
 		// TODO(https://github.com/kubernetes/kubernetes/issues/101384) bump this down a bit?
 		"pilot-discovery": {60, 95},
 		"bug-report":      {60, 100},
diff --git a/vendor/github.com/openshift/api/image/docker10/doc.go b/vendor/github.com/openshift/api/image/docker10/doc.go
new file mode 100644
index 0000000000..cc194d24db
diff --git a/vendor/github.com/openshift/api/image/docker10/dockertypes.go b/vendor/github.com/openshift/api/image/docker10/dockertypes.go
new file mode 100644
index 0000000000..a985553db4
diff --git a/vendor/github.com/openshift/api/image/docker10/register.go b/vendor/github.com/openshift/api/image/docker10/register.go
new file mode 100644
index 0000000000..31d616a06c
diff --git a/vendor/github.com/openshift/api/image/docker10/zz_generated.deepcopy.go b/vendor/github.com/openshift/api/image/docker10/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..b59f75ac21
diff --git a/vendor/github.com/openshift/api/image/dockerpre012/deepcopy.go b/vendor/github.com/openshift/api/image/dockerpre012/deepcopy.go
new file mode 100644
index 0000000000..ddeb4403c4
diff --git a/vendor/github.com/openshift/api/image/dockerpre012/doc.go b/vendor/github.com/openshift/api/image/dockerpre012/doc.go
new file mode 100644
index 0000000000..e4a56260f1
diff --git a/vendor/github.com/openshift/api/image/dockerpre012/dockertypes.go b/vendor/github.com/openshift/api/image/dockerpre012/dockertypes.go
new file mode 100644
index 0000000000..685e0b68c5
diff --git a/vendor/github.com/openshift/api/image/dockerpre012/register.go b/vendor/github.com/openshift/api/image/dockerpre012/register.go
new file mode 100644
index 0000000000..469806dbe7
diff --git a/vendor/github.com/openshift/api/image/dockerpre012/zz_generated.deepcopy.go b/vendor/github.com/openshift/api/image/dockerpre012/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..d9042704ad
diff --git a/vendor/github.com/openshift/api/image/v1/consts.go b/vendor/github.com/openshift/api/image/v1/consts.go
new file mode 100644
index 0000000000..11f57a44a3
diff --git a/vendor/github.com/openshift/api/image/v1/doc.go b/vendor/github.com/openshift/api/image/v1/doc.go
new file mode 100644
index 0000000000..e57d45bbf9
diff --git a/vendor/github.com/openshift/api/image/v1/generated.pb.go b/vendor/github.com/openshift/api/image/v1/generated.pb.go
new file mode 100644
index 0000000000..1a6b9e69fe
diff --git a/vendor/github.com/openshift/api/image/v1/generated.proto b/vendor/github.com/openshift/api/image/v1/generated.proto
new file mode 100644
index 0000000000..69ed48e89c
diff --git a/vendor/github.com/openshift/api/image/v1/legacy.go b/vendor/github.com/openshift/api/image/v1/legacy.go
new file mode 100644
index 0000000000..02bbaa2906
diff --git a/vendor/github.com/openshift/api/image/v1/register.go b/vendor/github.com/openshift/api/image/v1/register.go
new file mode 100644
index 0000000000..fc0910c246
diff --git a/vendor/github.com/openshift/api/image/v1/types.go b/vendor/github.com/openshift/api/image/v1/types.go
new file mode 100644
index 0000000000..c29cad9b25
diff --git a/vendor/github.com/openshift/api/image/v1/zz_generated.deepcopy.go b/vendor/github.com/openshift/api/image/v1/zz_generated.deepcopy.go
new file mode 100644
index 0000000000..aab4664823
diff --git a/vendor/github.com/openshift/api/image/v1/zz_generated.swagger_doc_generated.go b/vendor/github.com/openshift/api/image/v1/zz_generated.swagger_doc_generated.go
new file mode 100644
index 0000000000..a50ffbbc52
diff --git a/vendor/github.com/openshift/client-go/LICENSE b/vendor/github.com/openshift/client-go/LICENSE
new file mode 100644
index 0000000000..c4ea8b6f9d
diff --git a/pkg/servicemesh/client/clientset/versioned/clientset.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/clientset.go
similarity index 65%
rename from pkg/servicemesh/client/clientset/versioned/clientset.go
rename to vendor/github.com/openshift/client-go/image/clientset/versioned/clientset.go
index 4ff35da131..94520d6d4e 100644
--- a/pkg/servicemesh/client/clientset/versioned/clientset.go
+++ b/vendor/github.com/openshift/client-go/image/clientset/versioned/clientset.go
@@ -1,17 +1,3 @@
-// Copyright Red Hat, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 // Code generated by client-gen. DO NOT EDIT.
 
 package versioned
@@ -19,7 +5,7 @@
 import (
 	"fmt"
 
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
+	imagev1 "github.com/openshift/client-go/image/clientset/versioned/typed/image/v1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
@@ -27,19 +13,19 @@
 
 type Interface interface {
 	Discovery() discovery.DiscoveryInterface
-	MaistraV1() maistrav1.MaistraV1Interface
+	ImageV1() imagev1.ImageV1Interface
 }
 
 // Clientset contains the clients for groups. Each group has exactly one
 // version included in a Clientset.
 type Clientset struct {
 	*discovery.DiscoveryClient
-	maistraV1 *maistrav1.MaistraV1Client
+	imageV1 *imagev1.ImageV1Client
 }
 
-// MaistraV1 retrieves the MaistraV1Client
-func (c *Clientset) MaistraV1() maistrav1.MaistraV1Interface {
-	return c.maistraV1
+// ImageV1 retrieves the ImageV1Client
+func (c *Clientset) ImageV1() imagev1.ImageV1Interface {
+	return c.imageV1
 }
 
 // Discovery retrieves the DiscoveryClient
@@ -63,7 +49,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 	}
 	var cs Clientset
 	var err error
-	cs.maistraV1, err = maistrav1.NewForConfig(&configShallowCopy)
+	cs.imageV1, err = imagev1.NewForConfig(&configShallowCopy)
 	if err != nil {
 		return nil, err
 	}
@@ -79,7 +65,7 @@ func NewForConfig(c *rest.Config) (*Clientset, error) {
 // panics if there is an error in the config.
 func NewForConfigOrDie(c *rest.Config) *Clientset {
 	var cs Clientset
-	cs.maistraV1 = maistrav1.NewForConfigOrDie(c)
+	cs.imageV1 = imagev1.NewForConfigOrDie(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)
 	return &cs
@@ -88,7 +74,7 @@ func NewForConfigOrDie(c *rest.Config) *Clientset {
 // New creates a new Clientset for the given RESTClient.
 func New(c rest.Interface) *Clientset {
 	var cs Clientset
-	cs.maistraV1 = maistrav1.New(c)
+	cs.imageV1 = imagev1.New(c)
 
 	cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
 	return &cs
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/doc.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/doc.go
new file mode 100644
index 0000000000..0e0c2a8900
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/clientset_generated.go
similarity index 63%
rename from pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
rename to vendor/github.com/openshift/client-go/image/clientset/versioned/fake/clientset_generated.go
index f3db68bbbd..49898b7220 100644
--- a/pkg/servicemesh/client/clientset/versioned/fake/clientset_generated.go
+++ b/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/clientset_generated.go
@@ -1,25 +1,11 @@
-// Copyright Red Hat, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 // Code generated by client-gen. DO NOT EDIT.
 
 package fake
 
 import (
-	clientset "istio.io/istio/pkg/servicemesh/client/clientset/versioned"
-	maistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1"
-	fakemaistrav1 "istio.io/istio/pkg/servicemesh/client/clientset/versioned/typed/servicemesh/v1/fake"
+	clientset "github.com/openshift/client-go/image/clientset/versioned"
+	imagev1 "github.com/openshift/client-go/image/clientset/versioned/typed/image/v1"
+	fakeimagev1 "github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
@@ -74,7 +60,7 @@ func (c *Clientset) Tracker() testing.ObjectTracker {
 
 var _ clientset.Interface = &Clientset{}
 
-// MaistraV1 retrieves the MaistraV1Client
-func (c *Clientset) MaistraV1() maistrav1.MaistraV1Interface {
-	return &fakemaistrav1.FakeMaistraV1{Fake: &c.Fake}
+// ImageV1 retrieves the ImageV1Client
+func (c *Clientset) ImageV1() imagev1.ImageV1Interface {
+	return &fakeimagev1.FakeImageV1{Fake: &c.Fake}
 }
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/doc.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/doc.go
new file mode 100644
index 0000000000..3630ed1cd1
diff --git a/pkg/servicemesh/client/clientset/versioned/fake/register.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/register.go
similarity index 62%
rename from pkg/servicemesh/client/clientset/versioned/fake/register.go
rename to vendor/github.com/openshift/client-go/image/clientset/versioned/fake/register.go
index e6f82d54d4..d7efdf27ee 100644
--- a/pkg/servicemesh/client/clientset/versioned/fake/register.go
+++ b/vendor/github.com/openshift/client-go/image/clientset/versioned/fake/register.go
@@ -1,23 +1,9 @@
-// Copyright Red Hat, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 // Code generated by client-gen. DO NOT EDIT.
 
 package fake
 
 import (
-	maistrav1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
+	imagev1 "github.com/openshift/api/image/v1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -27,9 +13,9 @@
 
 var scheme = runtime.NewScheme()
 var codecs = serializer.NewCodecFactory(scheme)
-var parameterCodec = runtime.NewParameterCodec(scheme)
+
 var localSchemeBuilder = runtime.SchemeBuilder{
-	maistrav1.AddToScheme,
+	imagev1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/doc.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/doc.go
new file mode 100644
index 0000000000..14db57a58f
diff --git a/pkg/servicemesh/client/clientset/versioned/scheme/register.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/register.go
similarity index 65%
rename from pkg/servicemesh/client/clientset/versioned/scheme/register.go
rename to vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/register.go
index 7b74fba4a7..32fa9cb7ab 100644
--- a/pkg/servicemesh/client/clientset/versioned/scheme/register.go
+++ b/vendor/github.com/openshift/client-go/image/clientset/versioned/scheme/register.go
@@ -1,23 +1,9 @@
-// Copyright Red Hat, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 // Code generated by client-gen. DO NOT EDIT.
 
 package scheme
 
 import (
-	maistrav1 "istio.io/istio/pkg/servicemesh/apis/servicemesh/v1"
+	imagev1 "github.com/openshift/api/image/v1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
@@ -29,7 +15,7 @@
 var Codecs = serializer.NewCodecFactory(Scheme)
 var ParameterCodec = runtime.NewParameterCodec(Scheme)
 var localSchemeBuilder = runtime.SchemeBuilder{
-	maistrav1.AddToScheme,
+	imagev1.AddToScheme,
 }
 
 // AddToScheme adds all types of this clientset into the given scheme. This allows composition
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/doc.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/doc.go
new file mode 100644
index 0000000000..225e6b2be3
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/doc.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/doc.go
new file mode 100644
index 0000000000..2b5ba4c8e4
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image.go
new file mode 100644
index 0000000000..c85ba42a4a
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image_client.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_image_client.go
new file mode 100644
index 0000000000..c135a79bb6
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagesignature.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagesignature.go
new file mode 100644
index 0000000000..d16942383e
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestream.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestream.go
new file mode 100644
index 0000000000..5cf3cac1de
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimage.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimage.go
new file mode 100644
index 0000000000..aa97914259
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimport.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamimport.go
new file mode 100644
index 0000000000..5e7e5da326
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreammapping.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreammapping.go
new file mode 100644
index 0000000000..41841c11a6
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamtag.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagestreamtag.go
new file mode 100644
index 0000000000..facab5a8b4
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagetag.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/fake/fake_imagetag.go
new file mode 100644
index 0000000000..0d3e8dc957
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/generated_expansion.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/generated_expansion.go
new file mode 100644
index 0000000000..c495ba76e6
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image.go
new file mode 100644
index 0000000000..86d04f5310
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image_client.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/image_client.go
new file mode 100644
index 0000000000..1b85d2d6fa
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagesignature.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagesignature.go
new file mode 100644
index 0000000000..195b8f3717
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestream.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestream.go
new file mode 100644
index 0000000000..dcfb8942e4
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimage.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimage.go
new file mode 100644
index 0000000000..79f46753a7
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimport.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamimport.go
new file mode 100644
index 0000000000..7c43c951de
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreammapping.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreammapping.go
new file mode 100644
index 0000000000..5dc7df9574
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamtag.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagestreamtag.go
new file mode 100644
index 0000000000..4ea36ccdc2
diff --git a/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagetag.go b/vendor/github.com/openshift/client-go/image/clientset/versioned/typed/image/v1/imagetag.go
new file mode 100644
index 0000000000..a0d80e3ac8
-- 
2.35.3

